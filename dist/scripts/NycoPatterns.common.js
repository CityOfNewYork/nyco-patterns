'use strict';

/**
 * The Utility class
 * @class
 */

var Utility$1 = function Utility() {
  return this;
};
/**
 * Boolean for debug mode
 * @return {boolean} wether or not the front-end is in debug mode.
 */


Utility$1.debug = function () {
  return Utility$1.getUrlParameter(Utility$1.PARAMS.DEBUG) === '1';
};
/**
 * Returns the value of a given key in a URL query string. If no URL query
 * string is provided, the current URL location is used.
 * @param  {string}  name        - Key name.
 * @param  {?string} queryString - Optional query string to check.
 * @return {?string} Query parameter value.
 */


Utility$1.getUrlParameter = function (name, queryString) {
  var query = queryString || window.location.search;
  var param = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
  var regex = new RegExp('[\\?&]' + param + '=([^&#]*)');
  var results = regex.exec(query);
  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};
/**
 * For translating strings, there is a global LOCALIZED_STRINGS array that
 * is defined on the HTML template level so that those strings are exposed to
 * WPML translation. The LOCALIZED_STRINGS array is composed of objects with a
 * `slug` key whose value is some constant, and a `label` value which is the
 * translated equivalent. This function takes a slug name and returns the
 * label.
 * @param  {string} slug
 * @return {string} localized value
 */


Utility$1.localize = function (slug) {
  var text = slug || '';
  var strings = window.LOCALIZED_STRINGS || [];
  var match = strings.filter(function (s) {
    return s.hasOwnProperty('slug') && s['slug'] === slug ? s : false;
  });
  return match[0] && match[0].hasOwnProperty('label') ? match[0].label : text;
};
/**
 * Application parameters
 * @type {Object}
 */


Utility$1.PARAMS = {
  DEBUG: 'debug'
};
/**
 * Selectors for the Utility module
 * @type {Object}
 */

Utility$1.SELECTORS = {
  parseMarkdown: '[data-js="markdown"]'
};

/**
 * The Icon module
 * @class
 */

var Icons = function Icons(path) {
  path = path ? path : Icons.path;
  fetch(path).then(function (response) {
    if (response.ok) {
      return response.text();
    } else // eslint-disable-next-line no-console
      if (Utility$1.debug()) {
        console.dir(response);
      }
  }).catch(function (error) {
    // eslint-disable-next-line no-console
    if (Utility$1.debug()) {
      console.dir(error);
    }
  }).then(function (data) {
    var sprite = document.createElement('div');
    sprite.innerHTML = data;
    sprite.setAttribute('aria-hidden', true);
    sprite.setAttribute('style', 'display: none;');
    document.body.appendChild(sprite);
  });
  return this;
};
/** @type {String} The path of the icon file */


Icons.path = 'icons.svg';

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */

var Symbol$1 = root.Symbol;

/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString$1 = objectProto$1.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */

var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto$1 = Function.prototype,
    objectProto$2 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/** Used for built-in method references. */

var objectProto$3 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$2.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString = shortOut(baseSetToString);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */

function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */

function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */

function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */

var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */

var objectProto$4 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */

var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */

var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports$1 && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */

var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */

var objectProto$5 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$6;
  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */

var objectProto$7 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */

var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */

var getPrototype = overArg(Object.getPrototypeOf, Object);

/** `Object#toString` result references. */

var objectTag$1 = '[object Object]';
/** Used for built-in method references. */

var funcProto$2 = Function.prototype,
    objectProto$8 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$2 = funcProto$2.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString$2.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}

/** `Object#toString` result references. */

var domExcTag = '[object DOMException]',
    errorTag$1 = '[object Error]';
/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */

function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }

  var tag = baseGetTag(value);
  return tag == errorTag$1 || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */

var attempt = baseRest(function (func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */

function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

/** Used for built-in method references. */

var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */

function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined || eq(objValue, objectProto$9[key]) && !hasOwnProperty$7.call(object, key)) {
    return srcValue;
  }

  return objValue;
}

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};
/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */

var objectProto$a = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function (key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map characters to HTML entities. */

var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */

function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to match HTML entities and HTML characters. */

var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */

function escape(string) {
  string = toString(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
}

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */

var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': {
      'escape': escape
    }
  }
};

/** Used to match empty string literals in compiled template source. */

var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */

var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
/** Used to ensure capturing order of template delimiters. */

var reNoMatch = /($^)/;
/** Used to match unescaped characters in compiled string literals. */

var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */

function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }

  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);
  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);
  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '"; // Compile the regexp to match each delimiter.

  var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.

  var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';
  string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets.

    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }

    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }

    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }

    index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.

    return match;
  });
  source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.

  var variable = options.variable;

  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  } // Cleanup code by stripping empty strings.


  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

  source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
  var result = attempt(function () {
    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
  }); // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.

  result.source = source;

  if (isError(result)) {
    throw result;
  }

  return result;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */

var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */

function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */

var baseEach = createBaseEach(baseForOwn);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */

function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */

function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* Built-in method references that are verified to be native. */

var Map = getNative(root, 'Map');

/* Built-in method references that are verified to be native. */

var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto$b = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */

var objectProto$c = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$a = objectProto$c.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$a.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/** Detect free variable `exports`. */

var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
/** Built-in value references. */

var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

/** Built-in value references. */

var Uint8Array = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */

function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */

function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack());
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */

var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */

function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);

  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */

function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;
/** `Object#toString` result references. */

var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$2 = '[object Error]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';
var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag$2:
      return object.name == other.name && object.message == other.message;

    case regexpTag$1:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag$1:
      var convert = mapToArray;

    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */

var objectProto$d = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable$1 = objectProto$d.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$2 = 1;
/** Used for built-in method references. */

var objectProto$e = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$b = objectProto$e.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty$b.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* Built-in method references that are verified to be native. */

var DataView = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */

var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */

var Set$1 = getNative(root, 'Set');

/* Built-in method references that are verified to be native. */

var WeakMap = getNative(root, 'WeakMap');

/** `Object#toString` result references. */

var mapTag$2 = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$2 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';
var dataViewTag$2 = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map && getTag(new Map()) != mapTag$2 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$2 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;

        case mapCtorString:
          return mapTag$2;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag$2;

        case weakMapCtorString:
          return weakMapTag$1;
      }
    }

    return result;
  };
}

var getTag$1 = getTag;

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$3 = 1;
/** `Object#toString` result references. */

var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    objectTag$3 = '[object Object]';
/** Used for built-in method references. */

var objectProto$f = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$c = objectProto$f.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag$1 : getTag$1(object),
      othTag = othIsArr ? arrayTag$1 : getTag$1(other);
  objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
  var objIsObj = objTag == objectTag$3,
      othIsObj = othTag == objectTag$3,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$c.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$c.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */

function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */

function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/** Used to match property names within property paths. */

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */

var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */

function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

/** Used as references for various `Number` constants. */

var INFINITY$1 = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */

function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */

function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */

function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */

function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */

function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */

function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (typeof value == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);

  while (length--) {
    array[length] = array[length].value;
  }

  return array;
}

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */

function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);
    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }

    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }

  return 0;
}

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */

function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);

    if (result) {
      if (index >= ordersLength) {
        return result;
      }

      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


  return object.index - other.index;
}

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */

function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
  var result = baseMap(collection, function (value, key, collection) {
    var criteria = arrayMap(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return {
      'criteria': criteria,
      'index': ++index,
      'value': value
    };
  });
  return baseSortBy(result, function (object, other) {
    return compareMultiple(object, other, orders);
  });
}

/**
 * This method is like `_.sortBy` except that it allows specifying the sort
 * orders of the iteratees to sort by. If `orders` is unspecified, all values
 * are sorted in ascending order. Otherwise, specify an order of "desc" for
 * descending or "asc" for ascending sort order of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @param {string[]} [orders] The sort orders of `iteratees`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 34 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 36 }
 * ];
 *
 * // Sort by `user` in ascending order and by `age` in descending order.
 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 */

function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }

  if (!isArray(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }

  orders = guard ? undefined : orders;

  if (!isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }

  return baseOrderBy(collection, iteratees, orders);
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

/** Used as references for various `Number` constants. */

var INFINITY$2 = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY$2) ? noop : function (values) {
  return new Set$1(values);
};

/**
 *
 */

var Feed = function Feed(config) {
  this.default = Feed.default;
  this._settings = merge({}, Feed.default, config);
  this.init();
};
/**
 * Initializes the module
 */


Feed.prototype.init = function init() {
  var this$1 = this;
  var data = [];
  var feed = this._settings.feed;
  var config = {
    rssToJson: Feed.rssToJson,
    rssUrl: Array.isArray(feed) ? feed : [feed]
  }; // Go through each feed

  forEach(config.rssUrl, function (url, index) {
    // Make the request
    this$1._request(config, url).then(function (response) {
      // Process the data
      data.push(this$1._process(JSON.parse(response), this$1._settings)); // When all feeds have been requested, merge the data and compile

      if (data.length === config.rssUrl.length) {
        this$1._merge(data, this$1._settings);

        var compiled = this$1._render(this$1._merge(data, this$1._settings), this$1._settings);

        var el = document.querySelector(this$1._settings.selector);

        if (el) {
          el.innerHTML = compiled;
        }
      }
    });
  });

  return this;
};
/**
 * Create an XHR request for the feed data
 * @param{object} config The request data
 * @param{string} url  The request url
 * @return {Promise}     Resolves when the response is ready, rejects when
 *                       the operation times out or there is an error.
 */


Feed.prototype._request = function _request(config, url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function (event) {
      var _xhr = event.target;

      if (_xhr.readyState === 4) {
        if (_xhr.status >= 200 && _xhr.status < 400) {
          resolve(_xhr.response);
        } else {
          reject(new Error(_xhr.status));
        }
      }
    };

    xhr.ontimeout = function () {
      reject(new Error('The Feed request timed out'));
    };

    xhr.open('GET', config.rssToJson + "?rss_url=" + url, true);
    xhr.send();
    xhr = null;
  });
};
/**
 * Pass data to the appropriate processing function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The processed data
 */


Feed.prototype._process = function _process(data, settings) {
  return Feed.process[settings.type](data, settings);
};
/**
 * Pass data to the appropriate merge function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The merged feed data
 */


Feed.prototype._merge = function _merge(data, settings) {
  return Feed.merge[settings.type](data);
};
/**
 * Combine template components, pass data, and return compiled temlate
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {string}        The complied html string
 */


Feed.prototype._render = function _render(data, settings) {
  data.settings = settings;

  if (settings.log) {
    console.dir(data);
  }

  var template$1 = values(settings.templates).join('');

  var compiled = template(template$1, {
    'imports': {
      '_each': forEach
    }
  });

  return compiled(data);
};
/**
 * An open RSS to JSON api, see https://rss2json.com
 * @type {String}
 */


Feed.rssToJson = 'https://api.rss2json.com/v1/api.json';
/**
 * The template for the widget.
 * @type {String}
 */

Feed.templates = {
  medium: {
    opener: ['<section class="o-feed <%- settings.classes.wrapper %>" style="', '<% if (settings.fontSize) { %>font-size: <%- settings.fontSize %>;<% } %>', '<% if (settings.postBorderColor) { %>border-color: <%- settings.postBorderColor %>;<% } %>', '">'],
    header: ['<header class="o-feed__header <%- settings.classes.header %>">', '<div class="o-feed__avatar <%- settings.classes.avatar %>">', '<img src="', '<% if (settings.profileImg !== "") { %>', '<%- settings.profileImg %>', '<% } else { %>', '<%- feed.profileImg %>', '<% } %>" ', 'width="<%- settings.ratioProfile[0] %>" ', 'height="<%- settings.ratioProfile[1] %>">', '</div>', '<a class="o-feed__url <%- settings.classes.avatar %>" ', 'href="<% if (settings.titleUrl !== "") { %>', '<%- settings.titleUrl %>', '<% } else { %>', '<%- feed.url %>', '<% } %>" ', 'target="_blank" rel="noopener noreferrer nofollow">', '<% if (settings.title !== "") { %>', '<%- settings.title %>', '<% } else { %>', '<%- feed.title %>', '<% } %>', '</a>', '</header>'],
    posts: ['<div class="o-feed__items" style="', 'border-color: <%- settings.postBorderColor %>;', '">', '<% _each(items, function(post) { %>', '<div class="c-feed-item <%- settings.classes.feedItem %>">', '<h4 class="c-feed-item__title <%- settings.classes.title %>">', '<a class="c-feed-item__link <%- settings.classes.link %>"', 'href="<%- post.guid %>"', 'target="_blank"', 'rel="noopener noreferrer nofollow">', '<%- post.title %>', '</a>', '</h4>', '<span class="c-feed-item__date <%- settings.classes.date %>" ', 'title="<%- settings.postDateTitle %>">', '<%- post.date %>', '</span>', '<div class="c-feed-item__thumbnail <%- settings.classes.thumbnail %>"', 'style="', 'background-image: url(<%- post.thumbnail %>);', 'height: <%- settings.postImgHeight %>;"', 'aria-hidden="true">', '<img style="display: none;" src="<%- post.thumbnail %>" alt="<%- post.title %>">', '</div>', '<p class="c-feed-item__excerpt <%- settings.classes.excerpt %>">', '<%- post.excerpt %><%- settings.postExcerptTrail %>', '</p>', '<div class="c-feed-item__footer <%- settings.classes.itemFooter %>">', '<a class="c-feed-item__cta <%- settings.classes.cta %>" ', 'href="<%- post.guid %>" ', 'target="_blank" ', 'rel="noopener noreferrer nofollow">', '<%- settings.postCtaText %>', '</a>', '</div>', '</div>', '<% }); %>', '</div>'],
    closer: ['</section>']
  }
};
/**
 * Functions for processing the data based on the feed type.
 * @type {Object}
 */

Feed.process = {
  medium: function medium(data, settings) {
    var length = settings.postExcerptLength;

    forEach(data.items, function (post, index) {
      var excerpt = '';
      var date = ''; // Remove figures first

      excerpt = post.description.replace(/<figure.*>.*?<\/figure>/g, ''); // Remove all tags

      excerpt = excerpt.replace(/<(.|\n)*?>/g, ''); // Trim the excerpt

      excerpt = excerpt.substr(0, length);
      excerpt = excerpt.substr(0, Math.min(excerpt.length, excerpt.lastIndexOf(' ')));
      post.excerpt = excerpt; // Format the date

      date = new Date(Date.parse(post.pubDate.replace(' ', 'T'))).toLocaleDateString(settings.postDateLocal, settings.postDateFormat);
      post.date = date;
      return post;
    });

    return data;
  }
  /**
   * Functions for merging the data feeds together, based on the feed type.
   * @type {Object}
   */

};
Feed.merge = {
  medium: function medium(data) {
    var merged = {};
    var items = []; // Combine the post items

    data.forEach(function (feed) {
      items = items.concat(feed.items);
    }); // Merge the data, this will override values, it probably won't be
    // particularly useful for feeds that are the same, but potentially
    // different feed types could use this and combine unique data

    data.forEach(function (feed) {
      merged = merge(merged, feed);
    }); // Get unique posts
    // items = _uniqBy(items, (item) => item.guid);

    merged.items = orderBy(items, 'pubDate', 'desc');
    return merged;
  }
  /**
   * See https://rss2json.com/docs for details on default parameters
   * @type {Object}
   */

};
Feed.default = {
  feed: '',
  selector: '#js-feed',
  type: 'medium',
  title: '',
  titleUrl: '',
  profileImg: '',
  fontSize: '',
  ratioProfile: ['50', '50'],
  postBorderColor: 'lightsteelblue',
  postImgHeight: '200px',
  postExcerptLength: 120,
  postExcerptTrail: '',
  postCtaText: 'Read the full post',
  postDateLocal: 'en-US',
  postDateFormat: {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  },
  postDateTitle: 'Published Date',
  classes: {
    wrapper: '',
    header: '',
    url: '',
    feedItem: '',
    title: '',
    link: '',
    thumbnail: '',
    excerpt: '',
    itemFooter: '',
    cta: '',
    date: ''
  },
  templates: {
    opener: Feed.templates.medium.opener.join(''),
    header: Feed.templates.medium.header.join(''),
    posts: Feed.templates.medium.posts.join(''),
    closer: Feed.templates.medium.closer.join('')
  },
  log: false,
  unique: false
};

/**
 * The Simple Toggle class. This will toggle the class 'active' and 'hidden'
 * on target elements, determined by a click event on a selected link or
 * element. This will also toggle the aria-hidden attribute for targeted
 * elements to support screen readers. Target settings and other functionality
 * can be controlled through data attributes.
 *
 * This uses the .matches() method which will require a polyfill for IE
 * https://polyfill.io/v2/docs/features/#Element_prototype_matches
 *
 * Basic Usage;
 *
 * javascript:
 *   new Toggle().init();
 *
 * Toggling Anchor links:
 *   <a data-js='toggle' href='#main-menu'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Toggling aria-control elements:
 *
 *   <button data-js='toggle' aria-controls='#main-menu' aria-pressed='false'>
 *      Menu
 *   </button>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Create "Undo" Event (to close a dialogue);
 *   <a href='#main-menu' data-js='toggle' data-toggle-undo='#close'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'>
 *     <a id="close">Close</a>
 *   </div>
 * @class
 */

var Toggle = function Toggle(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Toggle.selector,
    namespace: s.namespace ? s.namespace : Toggle.namespace,
    inactiveClass: s.inactiveClass ? s.inactiveClass : Toggle.inactiveClass,
    activeClass: s.activeClass ? s.activeClass : Toggle.activeClass
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    event.preventDefault();

    this$1._toggle(event);
  });
  return this;
};
/**
 * Logs constants to the debugger
 * @param{object} eventThe main click event
 * @return {object}      The class
 */


Toggle.prototype._toggle = function _toggle(event) {
  var this$1 = this;
  var el = event.target;
  var target = false;
  /** Anchor Links */

  target = el.getAttribute('href') ? document.querySelector(el.getAttribute('href')) : target;
  /** Toggle Controls */
  // console.dir(el.getAttribute('aria-controls'));

  target = el.getAttribute('aria-controls') ? document.querySelector("#" + el.getAttribute('aria-controls')) : target;
  /** Main Functionality */

  if (!target) {
    return this;
  }

  this.elementToggle(el, target);
  /** Undo */

  if (el.dataset[this._settings.namespace + "Undo"]) {
    var undo = document.querySelector(el.dataset[this._settings.namespace + "Undo"]);
    undo.addEventListener('click', function (event) {
      event.preventDefault();
      this$1.elementToggle(el, target);
      undo.removeEventListener('click');
    });
  }

  return this;
};
/**
 * The main toggling method
 * @param{object} el   The current element to toggle active
 * @param{object} target The target element to toggle active/hidden
 * @return {object}      The class
 */


Toggle.prototype.elementToggle = function elementToggle(el, target) {
  if (this._settings.activeClass !== '') {
    el.classList.toggle(this._settings.activeClass);
    target.classList.toggle(this._settings.activeClass);
  }

  if (this._settings.inactiveClass !== '') {
    target.classList.toggle(this._settings.inactiveClass);
  } // Check the element for defined aria roles and toggle them if they exist


  for (var i = 0; i < Toggle.elAriaRoles.length; i++) {
    if (el.getAttribute(Toggle.elAriaRoles[i])) {
      el.setAttribute(Toggle.elAriaRoles[i], !(el.getAttribute(Toggle.elAriaRoles[i]) === 'true'));
    }
  } // Check the target for defined aria roles and toggle them if they exist


  for (var i$1 = 0; i$1 < Toggle.targetAriaRoles.length; i$1++) {
    if (target.getAttribute(Toggle.targetAriaRoles[i$1])) {
      target.setAttribute(Toggle.targetAriaRoles[i$1], !(target.getAttribute(Toggle.targetAriaRoles[i$1]) === 'true'));
    }
  }

  if (el.getAttribute('href') && target.classList.contains(this._settings.activeClass)) {
    window.location.hash = '';
    window.location.hash = el.getAttribute('href');
  }

  return this;
};
/** @type {String} The main selector to add the toggling function to */


Toggle.selector = '[data-js*="toggle"]';
/** @type {String} The namespace for our data attribute settings */

Toggle.namespace = 'toggle';
/** @type {String} The hide class */

Toggle.inactiveClass = 'hidden';
/** @type {String} The active class */

Toggle.activeClass = 'active';
/** @type {Array} Aria roles to toggle true/false on the toggling element */

Toggle.elAriaRoles = ['aria-pressed', 'aria-expanded'];
/** @type {Array} Aria roles to toggle true/false on the target element */

Toggle.targetAriaRoles = ['aria-hidden'];

/**
 * Tracking bus for Google analytics and Webtrends.
 */

var Track = function Track(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Track.selector
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    var key = event.target.dataset.trackKey;
    var data = JSON.parse(event.target.dataset.trackData);
    this$1.click(key, data);
  });
  return this;
};
/**
 * Tracking function wrapper
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 * @return {object}        The final data object
 */


Track.prototype.click = function click(key, data) {
  // Set the path name based on the location
  var d = data.map(function (el) {
    if (el.hasOwnProperty(Track.key)) {
      el[Track.key] = window.location.pathname + "/" + el[Track.key];
    }

    return el;
  });
  var wt = this.webtrends(key, d);
  var ga = this.gtag(key, d);
  /* eslint-disable no-console */

  if (Utility$1.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */


  return d;
};
/**
 * Data bus for tracking views in Webtrends and Google Analytics
 * @param{string}   appThe name of the Single Page Application to track
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.view = function view(app, key, data) {
  var wt = this.webtrends(key, data);
  var ga = this.gtagView(app, key);
  /* eslint-disable no-console */

  if (Utility$1.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */

};
/**
 * Push Events to Webtrends
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.webtrends = function webtrends(key, data) {
  var event = [{
    'WT.ti': key
  }];

  if (data[0] && data[0].hasOwnProperty(Track.key)) {
    event.push({
      'DCS.dcsuri': data[0][Track.key]
    });
  } else {
    Object.assign(event, data);
  } // Format data for Webtrends


  var wtd = {
    argsa: event.flatMap(function (e) {
      return Object.keys(e).flatMap(function (k) {
        return [k, e[k]];
      });
    })
  };
  /* eslint-disable no-undef */

  if (typeof Webtrends !== 'undefined') {
    Webtrends.multiTrack(wtd);
  }
  /* eslint-disable no-undef */


  return ['Webtrends', wtd];
};
/**
 * Push Click Events to Google Analytics
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.gtag = function gtag$1(key, data) {
  var uri = data.find(function (element) {
    return element.hasOwnProperty(Track.key);
  });
  var event = {
    'event_category': key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag(Track.key, uri[Track.key], event);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, uri[Track.key], event];
};
/**
 * Push Screen View Events to Google Analytics
 * @param{string}   appThe name of the application
 * @param{string}   keyThe key or event of the data
 */

Track.prototype.gtagView = function gtagView(app, key) {
  var view = {
    app_name: app,
    screen_name: key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag('event', 'screen_view', view);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, 'screen_view', view];
};
/** @type {String} The main selector to add the tracking function to */


Track.selector = '[data-js*="track"]';
/** @type {String} The main event tracking key to map to Webtrends DCS.uri */

Track.key = 'event';

/*!
 * Vue.js v2.6.6
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject$1(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject$1(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString$1(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject$1(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty$d = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty$d.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop$1(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity$1 = function (_) {
  return _;
};
/**
 * Generate a string containing static keys from compiler modules.
 */


function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject$1(a);
  var isObjectB = isObject$1(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop$1,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity$1,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeLetters = 'a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD';
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeLetters + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = '__proto__' in {}; // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set =
  /*@__PURE__*/
  function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop$1;
var tip = noop$1;
var generateComponentTrace = noop$1; // work around flow check

var formatComponentName = noop$1;
{
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat$1 = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat$1(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */

var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if (!config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto$1 = Array.prototype;
var arrayMethods = Object.create(arrayProto$1);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto$1[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject$1(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject$1(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if (customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

{
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */

function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject$1(toVal) && isPlainObject$1(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
    assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeLetters + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject$1(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject$1(val) ? val : {
        type: val
      };
    }
  } else {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject$1(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject$1(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject$1(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if (warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if (isObject$1(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject$1(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

function isExplicable(value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;

    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;

      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;

            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }

  globalHandleError(err, vm, info);
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res)) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      });
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */

  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop$1);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */


var mark;
var measure;
{
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;
{
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */

var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject$1(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
      warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      }
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (slots.$stable && prevSlots && prevSlots !== emptyObject && Object.keys(normalSlots).length === 0) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key in slots) {
      if (slots[key] && key[0] !== '$') {
        res[key] = normalizeScopedSlot(normalSlots, key, slots[key]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$1 in normalSlots) {
    if (!(key$1 in res)) {
      res[key$1] = proxyNormalSlot(normalSlots, key$1);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', slots ? !!slots.$stable : true);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    return res && res.length === 0 ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject$1(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if (!isObject$1(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity$1;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject$1(value)) {
      warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);

        if (!(key in hash) && !(camelizedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + camelizedKey] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject$1(value)) {
      warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
hasDynamicKeys, res) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, hasDynamicKeys, res);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (key !== '' && key !== null) {
      // null is a speical value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString$1;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject$1(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject$1(data.style)) {
    traverse(data.style);
  }

  if (isObject$1(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  }
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack becaues all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if (vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if (Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject$1(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  var owner = currentRenderingInstance;

  if (isDef(factory.owners)) {
    // already pending
    factory.owners.push(owner);
  } else {
    var owners = factory.owners = [owner];
    var sync = true;

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
      warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject$1(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject("timeout (" + res.timeout + "ms)");
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if (config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop$1, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.

  var hasDynamicScopedSlot = !!(parentVnode.data.scopedSlots && !parentVnode.data.scopedSlots.$stable || vm.$scopedSlots !== emptyObject && !vm.$scopedSlots.$stable); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  {
    circular = {};
  }
  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.

if (inBrowser && getNow() > document.createEvent('Event').timeStamp) {
  // if the low-res timestamp which is bigger than the event timestamp
  // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
  // and we need to use the hi-res version for event listeners as well.
  getNow = function () {
    return performance.now();
  };
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if (has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if (!config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = expOrFn.toString(); // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop$1;
      warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject$1(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop$1,
  set: noop$1
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.

    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject$1(data)) {
    data = {};
    warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];
    {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
      warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if (getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop$1, noop$1, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop$1;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop$1;
    sharedPropertyDefinition.set = userDef.set || noop$1;
  }

  if (sharedPropertyDefinition.set === noop$1) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop$1 : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject$1(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject$1(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
      }
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if (config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    {
      initProxy(vm);
    } // expose real self

    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if (config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if (!(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if (name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject$1(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];

  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.6';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject$1(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
      warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps =
/*#__PURE__*/
Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if (data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;
    {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5B:
          square++;
          break;
        // [

        case 0x5D:
          square--;
          break;
        // ]

        case 0x7B:
          curly++;
          break;
        // {

        case 0x7D:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);

          if (p !== ' ') {
            break;
          }
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');

  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
  }
}
/*  */

/* eslint-disable no-unused-vars */


function baseWarn(msg, range) {
  console.error("[Vue compiler]: " + msg);
}
/* eslint-enable no-unused-vars */


function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
}

function addAttr(el, name, value, range, dynamic) {
  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
  attrs.push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
} // add a raw attr (use this in preTransforms)


function addRawAttr(el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({
    name: name,
    value: value
  }, range));
}

function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker(symbol, name, dynamic) {
  return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
}

function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
  modifiers = modifiers || emptyObject; // warn prevent and passive modifier

  /* istanbul ignore if */

  if (warn && modifiers.prevent && modifiers.passive) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
  } // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.


  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  } // check capture modifier


  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }

  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */


  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;

  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({
    value: value.trim(),
    dynamic: dynamic
  }, range);

  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */

  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr(el, name) {
  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);

  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);

    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
} // note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.


function getAndRemoveAttr(el, name, removeFromMap) {
  var val;

  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;

    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }

  if (removeFromMap) {
    delete el.attrsMap[name];
  }

  return val;
}

function getAndRemoveAttrByRegex(el, name) {
  var list = el.attrsList;

  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];

    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr;
    }
  }
}

function rangeSetItem(item, range) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }

    if (range.end != null) {
      item.end = range.end;
    }
  }

  return item;
}
/*  */

/**
 * Cross-platform code generation for component v-model
 */


function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;
  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;

  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var assignment = genAssignmentCode(value, valueExpression);
  el.model = {
    value: "(" + value + ")",
    expression: JSON.stringify(value),
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}
/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


function genAssignmentCode(value, assignment) {
  var res = parseModel(value);

  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}
/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */


var len, str, chr, index$1, expressionPos, expressionEndPos;

function parseModel(val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');

    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */

    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;

  while (!eof()) {
    chr = next();

    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }

    if (chr === 0x5B) {
      inBracket++;
    }

    if (chr === 0x5D) {
      inBracket--;
    }

    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;

  while (!eof()) {
    chr = next();

    if (chr === stringQuote) {
      break;
    }
  }
}
/*  */


var warn$1; // in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;
  {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
  } // ensure runtime directive metadata


  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type

  {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];

    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
    }
  }
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
  var valueExpression = '$event.target.value';

  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);

  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);

  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.


function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // #9462 bail for iOS 9 bug: event.timeStamp is 0 after history.pushState
      e.timeStamp === 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    } // skip the update if old and new VDOM state is the same.
    // the only exception is `value` where the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This also covers #4521 by skipping the unnecesarry `checked` update.


    if (key !== 'value' && cur === oldProps[key]) {
      continue;
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else {
      elm[key] = cur;
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject$1(duration) ? duration.enter : duration);

  if (explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject$1(duration) ? duration.leave : duration);

  if (isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue$1);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue$1);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
    warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue$1(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue$1(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue$1(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if (children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if (mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop$1; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if (config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;

  if (!tagRE.test(text)) {
    return;
  }

  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;

  while (match = tagRE.exec(text)) {
    index = match.index; // push text token

    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    } // tag token


    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    rawTokens.push({
      '@binding': exp
    });
    lastIndex = index + match[0].length;
  }

  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }

  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  };
}
/*  */


function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');

  if (staticClass) {
    var res = parseText(staticClass, options.delimiters);

    if (res) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
    }
  }

  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }

  var classBinding = getBindingAttr(el, 'class', false
  /* getStatic */
  );

  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';

  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }

  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }

  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};
/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');

  if (staticStyle) {
    /* istanbul ignore if */
    {
      var res = parseText(staticStyle, options.delimiters);

      if (res) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false
  /* getStatic */
  );

  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';

  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }

  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }

  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};
/*  */

var decoder;
var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};
/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open
// (and which close themselves)

var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
/**
 * Not type-checking this file because it's mostly vendor code.
 */
// Regular Expressions for parsing tags and attributes

var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeLetters + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page

var comment = /^<!\--/;
var conditionalComment = /^<!\[/; // Special Elements (can contain anything)

var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};
var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992

var isIgnoreNewlineTag = makeMap('pre,textarea', true);

var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;

  while (html) {
    last = html; // Make sure we're not in a plaintext content element like script/style

    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');

      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }

            advance(commentEnd + 3);
            continue;
          }
        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        } // Doctype:


        var doctypeMatch = html.match(doctype);

        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        } // End tag:


        var endTagMatch = html.match(endTag);

        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        } // Start tag:


        var startTagMatch = parseStartTag();

        if (startTagMatch) {
          handleStartTag(startTagMatch);

          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }

          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;

      if (textEnd >= 0) {
        rest = html.slice(textEnd);

        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);

          if (next < 0) {
            break;
          }

          textEnd += next;
          rest = html.slice(textEnd);
        }

        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;

        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
          .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }

        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }

        if (options.chars) {
          options.chars(text);
        }

        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);

      if (!stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"", {
          start: index + html.length
        });
      }

      break;
    }
  } // Clean up any remaining tags


  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);

    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;

      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }

      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }

      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
    var l = match.attrs.length;
    var attrs = new Array(l);

    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };

      if (options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({
        tag: tagName,
        lowerCasedTag: tagName.toLowerCase(),
        attrs: attrs,
        start: match.start,
        end: match.end
      });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;

    if (start == null) {
      start = index;
    }

    if (end == null) {
      end = index;
    } // Find the closest opened tag of the same type


    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();

      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (i > pos || !tagName && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.", {
            start: stack[i].start
          });
        }

        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      } // Remove the open elements from the stack


      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }

      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}
/*  */


var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;
var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.]+/g;
var slotRE = /^v-slot(:|$)|^#/;
var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /\s+/g;
var invalidAttributeRE = /[\s"'<>\/=]/;
var decodeHTMLCached = cached(he.decode);
var emptySlotScopeToken = "_empty_"; // configurable state

var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  };
}
/**
 * Convert HTML string to AST.
 */


function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;

  maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;
  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement(element) {
    trimEndingWhitespace(element);

    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    } // tree management


    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else {
        warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", {
          start: element.start
        });
      }
    }

    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"';
          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }

        currentParent.children.push(element);
        element.parent = currentParent;
      }
    } // final children cleanup
    // filter out scoped slots


    element.children = element.children.filter(function (c) {
      return !c.slotScope;
    }); // remove trailing whitespace node again

    trimEndingWhitespace(element); // check pre state

    if (element.pre) {
      inVPre = false;
    }

    if (platformIsPreTag(element.tag)) {
      inPre = false;
    } // apply post-transforms


    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace(el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;

      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints(el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', {
        start: el.start
      });
    }

    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start(tag, attrs, unary, start$1) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug

      /* istanbul ignore if */

      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);

      if (ns) {
        element.ns = ns;
      }

      {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated;
          }, {});
        }

        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
              start: attr.start + attr.name.indexOf("["),
              end: attr.start + attr.name.length
            });
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', {
          start: element.start
        });
      } // apply pre-transforms


      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);

        if (element.pre) {
          inVPre = true;
        }
      }

      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }

      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },
    end: function end(tag, start, end$1) {
      var element = stack[stack.length - 1]; // pop stack

      stack.length -= 1;
      currentParent = stack[stack.length - 1];

      if (options.outputSourceRange) {
        element.end = end$1;
      }

      closeElement(element);
    },
    chars: function chars(text, start, end) {
      if (!currentParent) {
        {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.', {
              start: start
            });
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.", {
              start: start
            });
          }
        }
        return;
      } // IE textarea placeholder bug

      /* istanbul ignore if */


      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }

      var children = currentParent.children;

      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }

      if (text) {
        if (whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }

        var res;
        var child;

        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }

        if (child) {
          if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }

          children.push(child);
        }
      }
    },
    comment: function comment(text, start, end) {
      // adding anyting as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };

        if (options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }

        currentParent.children.push(child);
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var list = el.attrsList;
  var len = list.length;

  if (len) {
    var attrs = el.attrs = new Array(len);

    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };

      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element); // determine whether this is a plain element after
  // removing structural attributes

  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);

  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }

  processAttrs(element);
  return element;
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');

  if (exp) {
    {
      if (el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
      }

      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;

        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true
          /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');

  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;

  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var res = parseFor(exp);

    if (res) {
      extend(el, res);
    } else {
      warn$2("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
    }
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);

  if (!inMatch) {
    return;
  }

  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);

  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();

    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }

  return res;
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');

  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }

    var elseif = getAndRemoveAttr(el, 'v-else-if');

    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);

  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
  }
}

function findPrevElement(children) {
  var i = children.length;

  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
      }

      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }

  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');

  if (once$$1 != null) {
    el.once = true;
  }
} // handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">


function processSlotContent(el) {
  var slotScope;

  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */

    if (slotScope) {
      warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
    }

    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
    /* istanbul ignore if */
    if (el.attrsMap['v-for']) {
      warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
    }

    el.slotScope = slotScope;
  } // slot="xxx"


  var slotTarget = getBindingAttr(el, 'slot');

  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.

    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  } // 2.6 v-slot syntax


  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding) {
        {
          if (el.slotTarget || el.slotScope) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.parent && !maybeComponent(el.parent)) {
            warn$2("<template v-slot> can only appear at the root level inside " + "the receiving the component", el);
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding$1) {
        {
          if (!maybeComponent(el)) {
            warn$2("v-slot can only be used on components or <template>.", slotBinding$1);
          }

          if (el.slotScope || el.slotTarget) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.scopedSlots) {
            warn$2("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
          }
        } // add the component's children to its default slot

        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true;
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now

        el.children = []; // mark el non-plain so data gets generated

        el.plain = false;
      }
    }
  }
}

function getSlotName(binding) {
  var name = binding.name.replace(slotRE, '');

  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else {
      warn$2("v-slot shorthand syntax requires a slot name.", binding);
    }
  }

  return dynamicArgRE.test(name) // dynamic [name]
  ? {
    name: name.slice(1, -1),
    dynamic: true // static name

  } : {
    name: "\"" + name + "\"",
    dynamic: false
  };
} // handle <slot/> outlets


function processSlotOutlet(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');

    if (el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
    }
  }
}

function processComponent(el) {
  var binding;

  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }

  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;

  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;

    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true; // modifiers

      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier

      if (modifiers) {
        name = name.replace(modifierRE, '');
      }

      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        if (value.trim().length === 0) {
          warn$2("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
        }

        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);

            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }

          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }

          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");

            if (!isDynamic) {
              addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);

              if (hyphenate(name) !== camelize(name)) {
                addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
              }
            } else {
              // handler w/ dynamic event name
              addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$2, list[i], true // dynamic
              );
            }
          }
        }

        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else {
        // normal directives
        name = name.replace(dirRE, ''); // parse arg

        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;

        if (arg) {
          name = name.slice(0, -(arg.length + 1));

          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }

        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);

        if (name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      {
        var res = parseText(value, delimiters);

        if (res) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation

      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;

  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }

    parent = parent.parent;
  }

  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);

  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};

  for (var i = 0, l = attrs.length; i < l; i++) {
    if (map[attrs[i].name] && !isIE && !isEdge) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }

    map[attrs[i].name] = attrs[i].value;
  }

  return map;
} // for script (e.g. type="x/template") or style, do not decode content


function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;
/* istanbul ignore next */

function guardIESVGBug(attrs) {
  var res = [];

  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];

    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }

  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;

  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
    }

    _el = _el.parent;
  }
}
/*  */


function preTransformNode(el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;

    if (!map['v-model']) {
      return;
    }

    var typeBinding;

    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }

    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + map['v-bind'] + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox

      var branch0 = cloneASTElement(el); // process for on the main node

      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed

      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      }); // 2. add radio else-if condition

      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      }); // 3. other

      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0;
    }
  }
}

function cloneASTElement(el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}

var model$1 = {
  preTransformNode: preTransformNode
};
var modules$1 = [klass$1, style$1, model$1];
/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
  }
}
/*  */


function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};
/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};
/*  */

var isStaticKey;
var isPlatformReservedTag;
var genStaticKeysCached = cached(genStaticKeys$1);
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */

function optimize(root, options) {
  if (!root) {
    return;
  }

  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.

  markStatic$1(root); // second pass: mark static roots.

  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);

  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }

    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);

      if (!child.static) {
        node.static = false;
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);

        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    } // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.


    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }

    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }

  if (node.type === 3) {
    // text
    return true;
  }

  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;

    if (node.tag !== 'template') {
      return false;
    }

    if (node.for) {
      return true;
    }
  }

  return false;
}
/*  */


var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases

var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
}; // KeyboardEvent.key aliases

var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
}; // #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once

var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";

  for (var name in events) {
    var handlerCode = genHandler(events[name]);

    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }

  staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";

  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
  } else {
    return prefix + staticHandlers;
  }
}

function genHandler(handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }

    return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];

    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key]; // left/right

        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }

    if (keys.length) {
      code += genKeyFilter(keys);
    } // Make sure modifiers like prevent and stop get executed after key filtering


    if (genModifierCode) {
      code += genModifierCode;
    }

    var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return (// make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
  );
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);

  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }

  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
}
/*  */


function on(el, dir) {
  if (dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }

  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}
/*  */


function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}
/*  */


var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop$1
};
/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;

  this.maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;

    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;

      if (!el.plain || el.pre && state.maybeComponent(el)) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    } // module transforms


    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }

    return code;
  }
} // hoist static sub-trees out


function genStatic(el, state) {
  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.

  var originalPreState = state.pre;

  if (el.pre) {
    state.pre = el.pre;
  }

  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  state.pre = originalPreState;
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
} // v-once


function genOnce(el, state) {
  el.onceProcessed = true;

  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;

    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }

      parent = parent.parent;
    }

    if (!key) {
      state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
      return genElement(el, state);
    }

    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion

  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();

  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  } // v-if with v-once should generate code like (a)?_m(0):_m(1)


  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true
    /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion

  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{'; // directives first.
  // directives may mutate the el's other properties before they are generated.

  var dirs = genDirectives(el, state);

  if (dirs) {
    data += dirs + ',';
  } // key


  if (el.key) {
    data += "key:" + el.key + ",";
  } // ref


  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }

  if (el.refInFor) {
    data += "refInFor:true,";
  } // pre


  if (el.pre) {
    data += "pre:true,";
  } // record original tag name for components using "is" attribute


  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  } // module data generation functions


  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  } // attributes


  if (el.attrs) {
    data += "attrs:" + genProps(el.attrs) + ",";
  } // DOM props


  if (el.props) {
    data += "domProps:" + genProps(el.props) + ",";
  } // event handlers


  if (el.events) {
    data += genHandlers(el.events, false) + ",";
  }

  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  } // slot target
  // only for non-scoped slots


  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  } // scoped slots


  if (el.scopedSlots) {
    data += genScopedSlots(el, el.scopedSlots, state) + ",";
  } // component v-model


  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  } // inline-template


  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);

    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }

  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.

  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
  } // v-bind data wrap


  if (el.wrapData) {
    data = el.wrapData(data);
  } // v-on data wrap


  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }

  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;

  if (!dirs) {
    return;
  }

  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;

  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];

    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }

    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }

  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];

  if (el.children.length !== 1 || ast.type !== 1) {
    state.warn('Inline-template components must have exactly one child element.', {
      start: el.start
    });
  }

  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(el, slots, state) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    ;
  }); // OR when it is inside another scoped slot (the reactivity is disconnected)
  // #9438

  if (!needsForceUpdate) {
    var parent = el.parent;

    while (parent) {
      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken) {
        needsForceUpdate = true;
        break;
      }

      parent = parent.parent;
    }
  }

  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(slots[key], state);
  }).join(',') + "]" + (needsForceUpdate ? ",true" : "") + ")";
}

function containsSlotChild(el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true;
    }

    return el.children.some(containsSlotChild);
  }

  return false;
}

function genScopedSlot(el, state) {
  var isLegacySyntax = el.attrsMap['slot-scope'];

  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null");
  }

  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot);
  }

  var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
  var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}"; // reverse proxy v-slot without scope on this.$slots

  var reverseProxy = slotScope ? "" : ",proxy:true";
  return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;

  if (children.length) {
    var el$1 = children[0]; // optimize single v-for

    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
      return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
    }

    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
  }
} // determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed


function getNormalizationType(children, maybeComponent) {
  var res = 0;

  for (var i = 0; i < children.length; i++) {
    var el = children[i];

    if (el.type !== 1) {
      continue;
    }

    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }

    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }

  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  } else if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
    return {
      // slot props are camelized
      name: camelize(attr.name),
      value: attr.value,
      dynamic: attr.dynamic
    };
  })) : null;
  var bind$$1 = el.attrsMap['v-bind'];

  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }

  if (attrs) {
    res += "," + attrs;
  }

  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }

  return res + ')';
} // componentName is el.component, take it as argument to shun flow's pessimistic refinement


function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var staticProps = "";
  var dynamicProps = "";

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);

    if (prop.dynamic) {
      dynamicProps += prop.name + "," + value + ",";
    } else {
      staticProps += "\"" + prop.name + "\":" + value + ",";
    }
  }

  staticProps = "{" + staticProps.slice(0, -1) + "}";

  if (dynamicProps) {
    return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
  } else {
    return staticProps;
  }
} // #3895, #4268


function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}
/*  */
// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b'); // these unary operators should not be used as property/method names

var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template

function detectErrors(ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode(node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];

        if (value) {
          var range = node.rawAttrsMap[name];

          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", warn, range);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", warn, range);
          }
        }
      }
    }

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent(exp, text, warn, range) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);

  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
  }

  checkExpression(exp, text, warn, range);
}

function checkFor(node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier(ident, type, text, warn, range) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
    }
  }
}

function checkExpression(exp, text, warn, range) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
    } else {
      warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
    }
  }
}
/*  */


var range = 2;

function generateCodeFrame(source, start, end) {
  if (start === void 0) start = 0;
  if (end === void 0) end = source.length;
  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) {
          continue;
        }

        res.push("" + (j + 1) + repeat(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
        var lineLength = lines[j].length;

        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat(" ", pad) + repeat("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat("^", length$1));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}

function repeat(str, n) {
  var result = '';

  while (true) {
    // eslint-disable-line
    if (n & 1) {
      result += str;
    }

    n >>>= 1;

    if (n <= 0) {
      break;
    }

    str += str;
  }

  return result;
}
/*  */


function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({
      err: err,
      code: code
    });
    return noop$1;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);
  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;
    /* istanbul ignore if */

    {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    } // check cache

    var key = options.delimiters ? String(options.delimiters) + template : template;

    if (cache[key]) {
      return cache[key];
    } // compile


    var compiled = compile(template, options); // check compilation errors/tips

    {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
          });
        } else {
          warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
      }

      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) {
            return tip(e.msg, vm);
          });
        } else {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }
    } // turn code into functions

    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    }); // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use

    /* istanbul ignore if */

    {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;
          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }
    return cache[key] = res;
  };
}
/*  */


function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if (options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = {
              msg: msg
            };

            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }

              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }

            (tip ? tips : errors).push(data);
          };
        } // merge custom modules


        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        } // merge custom directives


        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
        } // copy other options


        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;
      var compiled = baseCompile(template.trim(), finalOptions);
      {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}
/*  */
// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.


var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);

  if (options.optimize !== false) {
    optimize(ast, options);
  }

  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});
/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;
/*  */
// check whether current browser encodes a char inside attribute values

var div;

function getShouldDecode(href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0;
} // #3663: IE encodes newlines inside attribute values while other browsers don't


var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]

var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;
/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});
var mount = Vue.prototype.$mount;

Vue.prototype.$mount = function (el, hydrating) {
  el = el && query(el);
  /* istanbul ignore if */

  if (el === document.body || el === document.documentElement) {
    warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options; // resolve template/el and convert to render function

  if (!options.render) {
    var template = options.template;

    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */

          if (!template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }

    if (template) {
      /* istanbul ignore if */
      if (config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;
      /* istanbul ignore if */

      if (config.performance && mark) {
        mark('compile end');
        measure("vue " + this._name + " compile", 'compile', 'compile end');
      }
    }
  }

  return mount.call(this, el, hydrating);
};
/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */


function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue.compile = compileToFunctions;

//
//
//
//
//
//
//
//
//
//
//
//
var script = {
  props: ['options', 'value'],
  data: function data() {
    return {
      selected: null
    };
  },
  mounted: function mounted() {
    this.selected = this.value;
  },
  watch: {
    value: function value(newValue) {
      this.selected = newValue;
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

function createInjector(context) {
  return function (id, style) {
    return addStyle(id, style);
  };
}

var HEAD = document.head || document.getElementsByTagName('head')[0];
var styles = {};

function addStyle(id, css) {
  var group = isOldIE ? css.media || 'default' : id;
  var style = styles[group] || (styles[group] = {
    ids: new Set(),
    styles: []
  });

  if (!style.ids.has(id)) {
    style.ids.add(id);
    var code = css.source;

    if (css.map) {
      // https://developer.chrome.com/devtools/docs/javascript-debugging
      // this makes source maps inside style tags work properly in Chrome
      code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

      code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
    }

    if (!style.element) {
      style.element = document.createElement('style');
      style.element.type = 'text/css';

      if (css.media) {
        style.element.setAttribute('media', css.media);
      }

      HEAD.appendChild(style.element);
    }

    if ('styleSheet' in style.element) {
      style.styles.push(code);
      style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
    } else {
      var index = style.ids.size - 1;
      var textNode = document.createTextNode(code);
      var nodes = style.element.childNodes;

      if (nodes[index]) {
        style.element.removeChild(nodes[index]);
      }

      if (nodes.length) {
        style.element.insertBefore(textNode, nodes[index]);
      } else {
        style.element.appendChild(textNode);
      }
    }
  }
}

var browser = createInjector;

/* script */
var __vue_script__ = script;

/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", [
    _c(
      "select",
      {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.selected,
            expression: "selected"
          }
        ],
        staticClass: "select",
        on: {
          input: function(event) {
            _vm.$emit("input", event.target.value);
          },
          change: function($event) {
            var $$selectedVal = Array.prototype.filter
              .call($event.target.options, function(o) {
                return o.selected
              })
              .map(function(o) {
                var val = "_value" in o ? o._value : o.value;
                return val
              });
            _vm.selected = $event.target.multiple
              ? $$selectedVal
              : $$selectedVal[0];
          }
        }
      },
      _vm._l(_vm.options, function(option) {
        return _c(
          "option",
          { key: option.value, domProps: { value: option.value } },
          [_vm._v("\n      " + _vm._s(option.text) + "\n    ")]
        )
      }),
      0
    )
  ])
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  var __vue_inject_styles__ = function (inject) {
    if (!inject) { return }
    inject("data-v-afd20650_0", { source: "\n\n\n\n\n\n\n\n\n\n", map: {"version":3,"sources":[],"names":[],"mappings":"","file":"select.vue"}, media: undefined });

  };
  /* scoped */
  var __vue_scope_id__ = undefined;
  /* module identifier */
  var __vue_module_identifier__ = undefined;
  /* functional template */
  var __vue_is_functional_template__ = false;
  /* style inject SSR */
  

  
  var SelectComponent = normalizeComponent_1(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    browser,
    undefined
  );

var SelectData = [{
  text: 'All Boroughs',
  value: 'all'
}, {
  text: 'Brooklyn',
  value: 'brooklyn'
}, {
  text: 'Queens',
  value: 'queens'
}, {
  text: 'Manhattan',
  value: 'manhattan'
}, {
  text: 'Staten Island',
  value: 'staten island'
}, {
  text: 'The Bronx',
  value: 'bronx'
}];

var Select = function Select(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


Select.prototype.init = function init() {
  Vue.component('nyco-select', SelectComponent);
  new Vue({
    el: '[data-js="app"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        options: Select.data,
        selected: 'all'
      };
    },
    methods: {}
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


Select.prototype._constants = function _constants(param) {
  console.dir(param);
};

Select.data = SelectData;

function dataHandler(newData, oldData) {
  if (oldData) {
    var chart = this.$data._chart;
    var newDatasetLabels = newData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldDatasetLabels = oldData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldLabels = JSON.stringify(oldDatasetLabels);
    var newLabels = JSON.stringify(newDatasetLabels);

    if (newLabels === oldLabels && oldData.datasets.length === newData.datasets.length) {
      newData.datasets.forEach(function (dataset, i) {
        var oldDatasetKeys = Object.keys(oldData.datasets[i]);
        var newDatasetKeys = Object.keys(dataset);
        var deletionKeys = oldDatasetKeys.filter(function (key) {
          return key !== '_meta' && newDatasetKeys.indexOf(key) === -1;
        });
        deletionKeys.forEach(function (deletionKey) {
          delete chart.data.datasets[i][deletionKey];
        });

        for (var attribute in dataset) {
          if (dataset.hasOwnProperty(attribute)) {
            chart.data.datasets[i][attribute] = dataset[attribute];
          }
        }
      });

      if (newData.hasOwnProperty('labels')) {
        chart.data.labels = newData.labels;
        this.$emit('labels:update');
      }

      if (newData.hasOwnProperty('xLabels')) {
        chart.data.xLabels = newData.xLabels;
        this.$emit('xlabels:update');
      }

      if (newData.hasOwnProperty('yLabels')) {
        chart.data.yLabels = newData.yLabels;
        this.$emit('ylabels:update');
      }

      chart.update();
      this.$emit('chart:update');
    } else {
      if (chart) {
        chart.destroy();
        this.$emit('chart:destroy');
      }

      this.renderChart(this.chartData, this.options);
      this.$emit('chart:render');
    }
  } else {
    if (this.$data._chart) {
      this.$data._chart.destroy();

      this.$emit('chart:destroy');
    }

    this.renderChart(this.chartData, this.options);
    this.$emit('chart:render');
  }
}

var reactiveData = {
  data: function data() {
    return {
      chartData: null
    };
  },
  watch: {
    'chartData': dataHandler
  }
};
var reactiveProp = {
  props: {
    chartData: {
      required: true
    }
  },
  watch: {
    'chartData': dataHandler
  }
};
var mixins = {
  reactiveData: reactiveData,
  reactiveProp: reactiveProp
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var moment = createCommonjsModule(function (module, exports) {

  (function (global, factory) {
    module.exports = factory();
  })(commonjsGlobal, function () {

    var hookCallback;

    function hooks() {
      return hookCallback.apply(null, arguments);
    } // This is done to register the method called with moment()
    // without creating circular dependencies.


    function setHookCallback(callback) {
      hookCallback = callback;
    }

    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
      // IE8 will treat undefined and null as object if it wasn't for
      // input != null
      return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;

        for (k in obj) {
          if (obj.hasOwnProperty(k)) {
            return false;
          }
        }

        return true;
      }
    }

    function isUndefined(input) {
      return input === void 0;
    }

    function isNumber(input) {
      return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
      var res = [],
          i;

      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }

      return res;
    }

    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }

      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }

      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }

      return a;
    }

    function createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
      // We need to deep clone this object.
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }

    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }

      return m._pf;
    }

    var some;

    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }

        return false;
      };
    }

    function isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
          return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }

      return m._isValid;
    }

    function createInvalid(flags) {
      var m = createUTC(NaN);

      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }

      return m;
    } // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.


    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
      var i, prop, val;

      if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
      }

      if (!isUndefined(from._i)) {
        to._i = from._i;
      }

      if (!isUndefined(from._f)) {
        to._f = from._f;
      }

      if (!isUndefined(from._l)) {
        to._l = from._l;
      }

      if (!isUndefined(from._strict)) {
        to._strict = from._strict;
      }

      if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
      }

      if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
      }

      if (!isUndefined(from._offset)) {
        to._offset = from._offset;
      }

      if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
      }

      if (!isUndefined(from._locale)) {
        to._locale = from._locale;
      }

      if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
          prop = momentProperties[i];
          val = from[prop];

          if (!isUndefined(val)) {
            to[prop] = val;
          }
        }
      }

      return to;
    }

    var updateInProgress = false; // Moment prototype object

    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);

      if (!this.isValid()) {
        this._d = new Date(NaN);
      } // Prevent infinite loop in case updateOffset creates new moment
      // objects.


      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }

    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }

    function absFloor(number) {
      if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }

    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;

      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }

      return value;
    } // compare two arrays, return the number of differences


    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;

      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }

      return diffs + lengthDiff;
    }

    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }

    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function () {
        var arguments$1 = arguments;

        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }

        if (firstTime) {
          var args = [];
          var arg;

          for (var i = 0; i < arguments.length; i++) {
            arg = '';

            if (typeof arguments$1[i] === 'object') {
              arg += '\n[' + i + '] ';

              for (var key in arguments[0]) {
                arg += key + ': ' + arguments$1[0][key] + ', ';
              }

              arg = arg.slice(0, -2); // Remove trailing comma and space
            } else {
              arg = arguments$1[i];
            }

            args.push(arg);
          }

          warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
          firstTime = false;
        }

        return fn.apply(this, arguments);
      }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }

      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set(config) {
      var prop, i;

      for (i in config) {
        prop = config[i];

        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }

      this._config = config; // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
      // TODO: Remove "ordinalParse" fallback in next major release.

      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
    }

    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig),
          prop;

      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }

      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          // make sure changes to properties don't modify parent config
          res[prop] = extend({}, res[prop]);
        }
      }

      return res;
    }

    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }

    var keys;

    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function (obj) {
        var i,
            res = [];

        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }

        return res;
      };
    }

    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };

    function calendar(key, mom, now) {
      var output = this._calendar[key] || this._calendar['sameElse'];
      return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];

      if (format || !formatUpper) {
        return format;
      }

      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
      });
      return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
      return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;

      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);

          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }

      return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
      var units = [];

      for (var u in unitsObj) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }

      units.sort(function (a, b) {
        return a.priority - b.priority;
      });
      return units;
    }

    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {}; // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }

    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;

      if (typeof callback === 'string') {
        func = function () {
          return this[callback]();
        };
      }

      if (token) {
        formatTokenFunctions[token] = func;
      }

      if (padded) {
        formatTokenFunctions[padded[0]] = function () {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }

      if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }

    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }

      return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;

      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }

      return function (mom) {
        var output = '',
            i;

        for (i = 0; i < length; i++) {
          output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }

        return output;
      };
    } // format date using native date object


    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }

      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
      return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
      var i = 5;

      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }

      localFormattingTokens.lastIndex = 0;

      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }

      return format;
    }

    var match1 = /\d/; //       0 - 9

    var match2 = /\d\d/; //      00 - 99

    var match3 = /\d{3}/; //     000 - 999

    var match4 = /\d{4}/; //    0000 - 9999

    var match6 = /[+-]?\d{6}/; // -999999 - 999999

    var match1to2 = /\d\d?/; //       0 - 99

    var match3to4 = /\d\d\d\d?/; //     999 - 9999

    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

    var match1to3 = /\d{1,3}/; //       0 - 999

    var match1to4 = /\d{1,4}/; //       0 - 9999

    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

    var matchUnsigned = /\d+/; //       0 - inf

    var matchSigned = /[+-]?\d+/; //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months

    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }

    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }

      return regexes[token](config._strict, config._locale);
    } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


    function unescapeFormat(s) {
      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }

    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
      var i,
          func = callback;

      if (typeof token === 'string') {
        token = [token];
      }

      if (isNumber(callback)) {
        func = function (input, array) {
          array[callback] = toInt(input);
        };
      }

      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }

    function addWeekParseToken(token, callback) {
      addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }

    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8; // FORMATTING

    addFormatToken('Y', 0, 0, function () {
      var y = this.year();
      return y <= 9999 ? '' + y : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

    addUnitAlias('year', 'y'); // PRIORITIES

    addUnitPriority('year', 1); // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
      array[YEAR] = parseInt(input, 10);
    }); // HELPERS

    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    } // HOOKS


    hooks.parseTwoDigitYear = function (input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    }; // MOMENTS


    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
      return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
      return function (value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }

    function get(mom, unit) {
      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        } else {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
      }
    } // MOMENTS


    function stringGet(units) {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units]();
      }

      return this;
    }

    function stringSet(units, value) {
      if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);

        for (var i = 0; i < prioritized.length; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);

        if (isFunction(this[units])) {
          return this[units](value);
        }
      }

      return this;
    }

    function mod(n, x) {
      return (n % x + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function (o) {
        // I know
        var i;

        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }

        return -1;
      };
    }

    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }

      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    } // FORMATTING


    addFormatToken('M', ['MM', 2], 'Mo', function () {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
      return this.localeData().months(this, format);
    }); // ALIASES

    addUnitAlias('month', 'M'); // PRIORITY

    addUnitPriority('month', 8); // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
      return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    }); // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

    function localeMonths(m, format) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months['standalone'];
      }

      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

    function localeMonthsShort(m, format) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
      }

      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
      var i,
          ii,
          mom,
          llc = monthName.toLocaleLowerCase();

      if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];

        for (i = 0; i < 12; ++i) {
          mom = createUTC([2000, i]);
          this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeMonthsParse(monthName, format, strict) {
      var i, mom, regex;

      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
      }

      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      } // TODO: add sorting
      // Sorting makes sure if one month (or abbr) is a prefix of another
      // see sorting in computeMonthsParse


      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);

        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }

        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    } // MOMENTS


    function setMonth(mom, value) {
      var dayOfMonth;

      if (!mom.isValid()) {
        // No op
        return mom;
      }

      if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

          if (!isNumber(value)) {
            return mom;
          }
        }
      }

      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

      return mom;
    }

    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, 'Month');
      }
    }

    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;

    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }

        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }

    var defaultMonthsRegex = matchWord;

    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
          this._monthsRegex = defaultMonthsRegex;
        }

        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }

    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom;

      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
      } // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.


      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }

      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate(y, m, d, h, M, s, ms) {
      // can't just apply() to create a date:
      // https://stackoverflow.com/q/181348
      var date; // the date constructor remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        date = new Date(y + 400, m, d, h, M, s, ms);

        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h, M, s, ms);
      }

      return date;
    }

    function createUTCDate(y) {
      var date; // the Date.UTC function remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));

        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }

      return date;
    } // start-of-first-week - start-of-year


    function firstWeekOffset(year, dow, doy) {
      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;

      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }

      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }

    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;

      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }

      return {
        week: resWeek,
        year: resYear
      };
    }

    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    } // FORMATTING


    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W'); // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5); // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    }); // HELPERS
    // LOCALES

    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    };

    function localeFirstDayOfWeek() {
      return this._week.dow;
    }

    function localeFirstDayOfYear() {
      return this._week.doy;
    } // MOMENTS


    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    } // FORMATTING


    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E'); // PRIORITY

    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11); // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
      return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
      return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
      return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
      week[token] = toInt(input);
    }); // HELPERS

    function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
        return input;
      }

      if (!isNaN(input)) {
        return parseInt(input, 10);
      }

      input = locale.weekdaysParse(input);

      if (typeof input === 'number') {
        return input;
      }

      return null;
    }

    function parseIsoWeekday(input, locale) {
      if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
      }

      return isNaN(input) ? null : input;
    } // LOCALES


    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

    function localeWeekdays(m, format) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
      var i,
          ii,
          mom,
          llc = weekdayName.toLocaleLowerCase();

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
          mom = createUTC([2000, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
      var i, mom, regex;

      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
      }

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);

        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
          this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
          this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
        }

        if (!this._weekdaysParse[i]) {
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    } // MOMENTS


    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }

    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      } // behaves the same as moment#day except
      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
      // as a setter, sunday should belong to the previous week.


      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }

    var defaultWeekdaysRegex = matchWord;

    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }

        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }

    var defaultWeekdaysShortRegex = matchWord;

    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }

        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }

    var defaultWeekdaysMinRegex = matchWord;

    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }

        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }

    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var minPieces = [],
          shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          minp,
          shortp,
          longp;

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.


      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    } // FORMATTING


    function hFormat() {
      return this.hours() % 12 || 12;
    }

    function kFormat() {
      return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }

    meridiem('a', true);
    meridiem('A', false); // ALIASES

    addUnitAlias('hour', 'h'); // PRIORITY

    addUnitPriority('hour', 13); // PARSING

    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    }); // LOCALES

    function localeIsPM(input) {
      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
      // Using charAt should be more compatible.
      return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    } // MOMENTS
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.


    var getSetHour = makeGetSet('Hours', true);
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    }; // internal storage for locale config files

    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    } // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;

      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;

        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));

          if (locale) {
            return locale;
          }

          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            //the next array item is better than a shallower substring of this one
            break;
          }

          j--;
        }

        i++;
      }

      return globalLocale;
    }

    function loadLocale(name) {
      var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

      if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          var aliasedRequire = commonjsRequire;
          aliasedRequire('./locale/' + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }

      return locales[name];
    } // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.


    function getSetGlobalLocale(key, values) {
      var data;

      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }

        if (data) {
          // moment.duration._locale = moment._locale = data;
          globalLocale = data;
        } else {
          if (typeof console !== 'undefined' && console.warn) {
            //warn user if arguments are passed but the locale could not be set
            console.warn('Locale ' + key + ' not found. Did you forget to load it?');
          }
        }
      }

      return globalLocale._abbr;
    }

    function defineLocale(name, config) {
      if (config !== null) {
        var locale,
            parentConfig = baseConfig;
        config.abbr = name;

        if (locales[name] != null) {
          deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale = loadLocale(config.parentLocale);

            if (locale != null) {
              parentConfig = locale._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }

              localeFamilies[config.parentLocale].push({
                name: name,
                config: config
              });
              return null;
            }
          }
        }

        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function (x) {
            defineLocale(x.name, x.config);
          });
        } // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.


        getSetGlobalLocale(name);
        return locales[name];
      } else {
        // useful for testing
        delete locales[name];
        return null;
      }
    }

    function updateLocale(name, config) {
      if (config != null) {
        var locale,
            tmpLocale,
            parentConfig = baseConfig; // MERGE

        tmpLocale = loadLocale(name);

        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }

        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale; // backwards compat for now: also set the locale

        getSetGlobalLocale(name);
      } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }

      return locales[name];
    } // returns locale data


    function getLocale(key) {
      var locale;

      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }

      if (!key) {
        return globalLocale;
      }

      if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);

        if (locale) {
          return locale;
        }

        key = [key];
      }

      return chooseLocale(key);
    }

    function listLocales() {
      return keys(locales);
    }

    function checkOverflow(m) {
      var overflow;
      var a = m._a;

      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }

        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }

        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
      }

      return m;
    } // Pick the first defined of two or three arguments.


    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }

      if (b != null) {
        return b;
      }

      return c;
    }

    function currentDateArray(config) {
      // hooks is actually the exported moment object
      var nowValue = new Date(hooks.now());

      if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
      }

      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    } // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]


    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          expectedWeekday,
          yearToUse;

      if (config._d) {
        return;
      }

      currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      } //if the day of the year is set, figure out what it is


      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      } // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything


      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      } // Zero out whatever was not defaulted, including time


      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      } // Check for 24:00:00.000


      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }

      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
      // with parseZone.

      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }

      if (config._nextDay) {
        config._a[HOUR] = 24;
      } // check for mismatching day of week


      if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }

    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
      w = config._w;

      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).

        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);

        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        var curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
          // weekday -- low day numbers are considered next week
          weekday = w.d;

          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          // local weekday -- counting starts from beginning of week
          weekday = w.e + dow;

          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          // default to beginning of week
          weekday = dow;
        }
      }

      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    } // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat;

      if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }

        if (dateFormat == null) {
          config._isValid = false;
          return;
        }

        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              // match[2] should be 'T' or space
              timeFormat = (match[2] || ' ') + isoTimes[i][0];
              break;
            }
          }

          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }

        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }

        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = 'Z';
          } else {
            config._isValid = false;
            return;
          }
        }

        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }

      return result;
    }

    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);

      if (year <= 49) {
        return 2000 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }

      return year;
    }

    function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }

      return true;
    }

    var obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
      } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100,
            h = (hm - m) / 100;
        return h * 60 + m;
      }
    } // date and time from ref 2822 format


    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i));

      if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);

        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    } // date from iso format or fallback


    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);

      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }

      configFromISO(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }

      configFromRFC2822(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      } // Final attempt, use Input Fallback


      hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }); // constant that refers to the ISO standard

    hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


    hooks.RFC_2822 = function () {}; // date from string and format string


    function configFromStringAndFormat(config) {
      // TODO: Move this to another part of the creation flow to prevent circular deps
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }

      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }

      config._a = [];
      getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));

        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));

          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }

          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        } // don't parse if it's not a known token


        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }

          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      } // add remaining unparsed input length to the string


      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      } // clear _12h flag if hour is <= 12


      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }

      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;

      if (meridiem == null) {
        // nothing to do
        return hour;
      }

      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);

        if (isPm && hour < 12) {
          hour += 12;
        }

        if (!isPm && hour === 12) {
          hour = 0;
        }

        return hour;
      } else {
        // this is not supposed to happen
        return hour;
      }
    } // date from string and array of format strings


    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore;

      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }

      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);

        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }

        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
          continue;
        } // if there is any input that was not parsed add a penalty for that format


        currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }

      extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
      if (config._d) {
        return;
      }

      var i = normalizeObjectUnits(config._i);
      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }

    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));

      if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
      }

      return res;
    }

    function prepareConfig(config) {
      var input = config._i,
          format = config._f;
      config._locale = config._locale || getLocale(config._l);

      if (input === null || format === undefined && input === '') {
        return createInvalid({
          nullInput: true
        });
      }

      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }

      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }

      if (!isValid(config)) {
        config._d = null;
      }

      return config;
    }

    function configFromInput(config) {
      var input = config._i;

      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};

      if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
      }

      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = undefined;
      } // object construction must be done this way.
      // https://github.com/moment/moment/issues/1423


      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    }); // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.

    function pickBy(fn, moments) {
      var res, i;

      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }

      if (!moments.length) {
        return createLocal();
      }

      res = moments[0];

      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }

      return res;
    } // TODO: Use [].sort instead?


    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }

    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }

    var now = function () {
      return Date.now ? Date.now() : +new Date();
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
      for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }

      var unitHasDecimal = false;

      for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false; // only allow non-integers for smallest unit
          }

          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }

      return true;
    }

    function isValid$1() {
      return this._isValid;
    }

    function createInvalid$1() {
      return createDuration(NaN);
    }

    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

      this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
      minutes * 6e4 + // 1000 * 60
      hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately

      this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.

      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = getLocale();

      this._bubble();
    }

    function isDuration(obj) {
      return obj instanceof Duration;
    }

    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    } // FORMATTING


    function offset(token, separator) {
      addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';

        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }

        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
      });
    }

    offset('Z', ':');
    offset('ZZ', ''); // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    }); // HELPERS
    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']

    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher);

      if (matches === null) {
        return null;
      }

      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    } // Return a moment from input, that is local/utc/zone equivalent to model.


    function cloneWithOffset(input, model) {
      var res, diff;

      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

        res._d.setTime(res._d.valueOf() + diff);

        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }

    function getDateOffset(m) {
      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
      // https://github.com/moment/moment/pull/1871
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    } // HOOKS
    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.


    hooks.updateOffset = function () {}; // MOMENTS
    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.


    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset = this._offset || 0,
          localAdjust;

      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(matchShortOffset, input);

          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }

        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }

        this._offset = input;
        this._isUTC = true;

        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }

        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(this, createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }

        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }

    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }

        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }

    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }

      return this;
    }

    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);

        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }

      return this;
    }

    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }

      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }

    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }

      var c = {};
      copyConfig(c, this);
      c = prepareConfig(c);

      if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }

      return this._isDSTShifted;
    }

    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    } // ASP.NET json date format regex


    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day

    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
      var duration = input,
          // matching against regexp is expensive, do it on demand
      match = null,
          sign,
          ret,
          diffRes;

      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input)) {
        duration = {};

        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

        };
      } else if (!!(match = isoRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          w: parseIso(match[4], sign),
          d: parseIso(match[5], sign),
          h: parseIso(match[6], sign),
          m: parseIso(match[7], sign),
          s: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        // checks for null or undefined
        duration = {};
      } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }

      ret = new Duration(duration);

      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }

      return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
      // We'd normally use ~~inp for this, but unfortunately it also
      // converts floats to ints.
      // inp may be undefined, so careful calling replace on it.
      var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

      return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }

      res.milliseconds = +other - +base.clone().add(res.months, 'M');
      return res;
    }

    function momentsDifference(base, other) {
      var res;

      if (!(base.isValid() && other.isValid())) {
        return {
          milliseconds: 0,
          months: 0
        };
      }

      other = cloneWithOffset(other, base);

      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }

      return res;
    } // TODO: remove 'name' arg after deprecation is removed


    function createAdder(direction, name) {
      return function (val, period) {
        var dur, tmp; //invert the arguments, but complain about it

        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
          tmp = val;
          val = period;
          period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);

      if (!mom.isValid()) {
        // No op
        return;
      }

      updateOffset = updateOffset == null ? true : updateOffset;

      if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
      }

      if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
      }

      if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }

      if (updateOffset) {
        hooks.updateOffset(mom, days || months);
      }
    }

    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
      var diff = myMoment.diff(now, 'days', true);
      return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1(time, formats) {
      // We want to compare the start of today, vs this.
      // Getting start-of-today depends on whether we're local/utc/offset or not.
      var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse';
      var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
      return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone() {
      return new Moment(this);
    }

    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }

    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }

    function isBetween(from, to, units, inclusivity) {
      var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);

      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }

      inclusivity = inclusivity || '()';
      return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }

    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
      var that, zoneDelta, output;

      if (!this.isValid()) {
        return NaN;
      }

      that = cloneWithOffset(input, this);

      if (!that.isValid()) {
        return NaN;
      }

      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);

      switch (units) {
        case 'year':
          output = monthDiff(this, that) / 12;
          break;

        case 'month':
          output = monthDiff(this, that);
          break;

        case 'quarter':
          output = monthDiff(this, that) / 3;
          break;

        case 'second':
          output = (this - that) / 1e3;
          break;
        // 1000

        case 'minute':
          output = (this - that) / 6e4;
          break;
        // 1000 * 60

        case 'hour':
          output = (this - that) / 36e5;
          break;
        // 1000 * 60 * 60

        case 'day':
          output = (this - that - zoneDelta) / 864e5;
          break;
        // 1000 * 60 * 60 * 24, negate dst

        case 'week':
          output = (this - that - zoneDelta) / 6048e5;
          break;
        // 1000 * 60 * 60 * 24 * 7, negate dst

        default:
          output = this - that;
      }

      return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
      // difference in months
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;

      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor2 - anchor);
      } //check for negative zero, return zero if negative zero


      return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }

      var utc = keepOffset !== true;
      var m = utc ? this.clone().utc() : this;

      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
      }

      return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */


    function inspect() {
      if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
      }

      var func = 'moment';
      var zone = '';

      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
      }

      var prefix = '[' + func + '("]';
      var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
      var datetime = '-MM-DD[T]HH:mm:ss.SSS';
      var suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }

      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          to: this,
          from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          from: this,
          to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    } // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.


    function locale(key) {
      var newLocaleData;

      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);

        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }

        return this;
      }
    }

    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });

    function localeData() {
      return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }

    function utcStartOfDate(y, m, d) {
      // Date.UTC remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }

    function startOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year(), 0, 1);
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;

        case 'month':
          time = startOfDate(this.year(), this.month(), 1);
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date());
          break;

        case 'hour':
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;

        case 'minute':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;

        case 'second':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function endOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

        case 'month':
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;

        case 'hour':
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;

        case 'minute':
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;

        case 'second':
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
      return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
      return new Date(this.valueOf());
    }

    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }

    function toJSON() {
      // new Date(NaN).toJSON() === null
      return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
      return isValid(this);
    }

    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
      return getParsingFlags(this).overflow;
    }

    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    } // FORMATTING


    addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
      return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1); // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
      week[token] = hooks.parseTwoDigitYear(input);
    }); // MOMENTS

    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;

      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;

      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);

        if (week > weeksTarget) {
          week = weeksTarget;
        }

        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    } // FORMATTING


    addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

    addUnitAlias('quarter', 'Q'); // PRIORITY

    addUnitPriority('quarter', 7); // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    }); // MOMENTS

    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    } // FORMATTING


    addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

    addUnitAlias('date', 'D'); // PRIORITY

    addUnitPriority('date', 9); // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
      // TODO: Remove "ordinalParse" fallback in next major release.
      return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    }); // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

    addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

    addUnitPriority('dayOfYear', 4); // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
      config._dayOfYear = toInt(input);
    }); // HELPERS
    // MOMENTS

    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    } // FORMATTING


    addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

    addUnitAlias('minute', 'm'); // PRIORITY

    addUnitPriority('minute', 14); // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE); // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

    addUnitAlias('second', 's'); // PRIORITY

    addUnitPriority('second', 15); // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND); // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

    addFormatToken('S', 0, 0, function () {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
      return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
      return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
      return this.millisecond() * 1000000;
    }); // ALIASES

    addUnitAlias('millisecond', 'ms'); // PRIORITY

    addUnitPriority('millisecond', 16); // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;

    for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
    } // MOMENTS


    var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix(input) {
      return createLocal(input * 1000);
    }

    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
      return string;
    }

    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
      var locale = getLocale();
      var utc = createUTC().set(setter, index);
      return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';

      if (index != null) {
        return get$1(format, index, field, 'month');
      }

      var i;
      var out = [];

      for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
      }

      return out;
    } // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)


    function listWeekdaysImpl(localeSorted, format, index, field) {
      if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      }

      var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0;

      if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
      }

      var i;
      var out = [];

      for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
      }

      return out;
    }

    function listMonths(format, index) {
      return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
      return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function (number) {
        var b = number % 10,
            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        return number + output;
      }
    }); // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;

    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }

    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    } // supports only 2.0-style add(1, 's') or add(duration)


    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    } // supports only 2.0-style subtract(1, 's') or subtract(duration)


    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }

    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
      // check: https://github.com/moment/moment/issues/2166

      if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
      } // The following code bubbles up values, see the tests for
      // examples of what that means.


      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24); // convert days to months

      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }

    function daysToMonths(days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      return days * 4800 / 146097;
    }

    function monthsToDays(months) {
      // the reverse of daysToMonths
      return months * 146097 / 4800;
    }

    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }

      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);

      if (units === 'month' || units === 'quarter' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);

        switch (units) {
          case 'month':
            return months;

          case 'quarter':
            return months / 3;

          case 'year':
            return months / 12;
        }
      } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));

        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;

          case 'day':
            return days + milliseconds / 864e5;

          case 'hour':
            return days * 24 + milliseconds / 36e5;

          case 'minute':
            return days * 1440 + milliseconds / 6e4;

          case 'second':
            return days * 86400 + milliseconds / 1000;
          // Math.floor prevents floating point math errors here

          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;

          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    } // TODO: Use this.as('ms')?


    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }

      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }

    function makeAs(alias) {
      return function () {
        return this.as(alias);
      };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asQuarters = makeAs('Q');
    var asYears = makeAs('y');

    function clone$1() {
      return createDuration(this);
    }

    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
      return function () {
        return this.isValid() ? this._data[name] : NaN;
      };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
      return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month
      M: 11 // months to year

    }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
      var duration = createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    } // This function allows you to set the rounding function for relative time strings


    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === undefined) {
        return round;
      }

      if (typeof roundingFunction === 'function') {
        round = roundingFunction;
        return true;
      }

      return false;
    } // This function allows you to set a threshold for relative time strings


    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }

      if (limit === undefined) {
        return thresholds[threshold];
      }

      thresholds[threshold] = limit;

      if (threshold === 's') {
        thresholds.ss = limit - 1;
      }

      return true;
    }

    function humanize(withSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var locale = this.localeData();
      var output = relativeTime$1(this, !withSuffix, locale);

      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }

      return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
      // for ISO strings we do not use the normal bubbling rules:
      //  * milliseconds bubble up until they become hours
      //  * days do not bubble at all
      //  * months bubble up until they become years
      // This is because there is no context-free conversion between hours and days
      // (think of clock changes)
      // and also not between days and months (28-31 days per month)
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var seconds = abs$1(this._milliseconds) / 1000;
      var days = abs$1(this._days);
      var months = abs$1(this._months);
      var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60; // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
      var total = this.asSeconds();

      if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
      }

      var totalSign = total < 0 ? '-' : '';
      var ymSign = sign(this._months) !== sign(total) ? '-' : '';
      var daysSign = sign(this._days) !== sign(total) ? '-' : '';
      var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
      return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang; // Side effect imports
    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf'); // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
      config._d = new Date(toInt(input));
    }); // Side effect imports

    hooks.version = '2.24.0';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

    hooks.HTML5_FMT = {
      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
      // <input type="datetime-local" step="0.001" />
      DATE: 'YYYY-MM-DD',
      // <input type="date" />
      TIME: 'HH:mm',
      // <input type="time" />
      TIME_SECONDS: 'HH:mm:ss',
      // <input type="time" step="1" />
      TIME_MS: 'HH:mm:ss.SSS',
      // <input type="time" step="0.001" />
      WEEK: 'GGGG-[W]WW',
      // <input type="week" />
      MONTH: 'YYYY-MM' // <input type="month" />

    };
    return hooks;
  });
});

var Chart$1 = createCommonjsModule(function (module, exports) {
  /*!
   * Chart.js v2.8.0
   * https://www.chartjs.org
   * (c) 2019 Chart.js Contributors
   * Released under the MIT License
   */
  (function (global, factory) {
    module.exports = factory(function () {
      try {
        return moment;
      } catch (e) {}
    }());
  })(commonjsGlobal, function (moment) {

    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
    /* MIT license */

    var conversions = {
      rgb2hsl: rgb2hsl,
      rgb2hsv: rgb2hsv,
      rgb2hwb: rgb2hwb,
      rgb2cmyk: rgb2cmyk,
      rgb2keyword: rgb2keyword,
      rgb2xyz: rgb2xyz,
      rgb2lab: rgb2lab,
      rgb2lch: rgb2lch,
      hsl2rgb: hsl2rgb,
      hsl2hsv: hsl2hsv,
      hsl2hwb: hsl2hwb,
      hsl2cmyk: hsl2cmyk,
      hsl2keyword: hsl2keyword,
      hsv2rgb: hsv2rgb,
      hsv2hsl: hsv2hsl,
      hsv2hwb: hsv2hwb,
      hsv2cmyk: hsv2cmyk,
      hsv2keyword: hsv2keyword,
      hwb2rgb: hwb2rgb,
      hwb2hsl: hwb2hsl,
      hwb2hsv: hwb2hsv,
      hwb2cmyk: hwb2cmyk,
      hwb2keyword: hwb2keyword,
      cmyk2rgb: cmyk2rgb,
      cmyk2hsl: cmyk2hsl,
      cmyk2hsv: cmyk2hsv,
      cmyk2hwb: cmyk2hwb,
      cmyk2keyword: cmyk2keyword,
      keyword2rgb: keyword2rgb,
      keyword2hsl: keyword2hsl,
      keyword2hsv: keyword2hsv,
      keyword2hwb: keyword2hwb,
      keyword2cmyk: keyword2cmyk,
      keyword2lab: keyword2lab,
      keyword2xyz: keyword2xyz,
      xyz2rgb: xyz2rgb,
      xyz2lab: xyz2lab,
      xyz2lch: xyz2lch,
      lab2xyz: lab2xyz,
      lab2rgb: lab2rgb,
      lab2lch: lab2lch,
      lch2lab: lch2lab,
      lch2xyz: lch2xyz,
      lch2rgb: lch2rgb
    };

    function rgb2hsl(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          l;

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max == min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    }

    function rgb2hsv(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          v;

      if (max == 0) {
        s = 0;
      } else {
        s = delta / max * 1000 / 10;
      }

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      v = max / 255 * 1000 / 10;
      return [h, s, v];
    }

    function rgb2hwb(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          h = rgb2hsl(rgb)[0],
          w = 1 / 255 * Math.min(r, Math.min(g, b)),
          b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    }

    function rgb2cmyk(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          c,
          m,
          y,
          k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    }

    function rgb2keyword(rgb) {
      return reverseKeywords[JSON.stringify(rgb)];
    }

    function rgb2xyz(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255; // assume sRGB

      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    }

    function rgb2lab(rgb) {
      var xyz = rgb2xyz(rgb),
          x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function rgb2lch(args) {
      return lab2lch(rgb2lab(args));
    }

    function hsl2rgb(hsl) {
      var h = hsl[0] / 360,
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          t1,
          t2,
          t3,
          rgb,
          val;

      if (s == 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        t3 < 0 && t3++;
        t3 > 1 && t3--;

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    }

    function hsl2hsv(hsl) {
      var h = hsl[0],
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          sv,
          v;

      if (l === 0) {
        // no need to do calc on black
        // also avoids divide by 0 error
        return [0, 0, 0];
      }

      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      v = (l + s) / 2;
      sv = 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    }

    function hsl2hwb(args) {
      return rgb2hwb(hsl2rgb(args));
    }

    function hsl2cmyk(args) {
      return rgb2cmyk(hsl2rgb(args));
    }

    function hsl2keyword(args) {
      return rgb2keyword(hsl2rgb(args));
    }

    function hsv2rgb(hsv) {
      var h = hsv[0] / 60,
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          hi = Math.floor(h) % 6;
      var f = h - Math.floor(h),
          p = 255 * v * (1 - s),
          q = 255 * v * (1 - s * f),
          t = 255 * v * (1 - s * (1 - f)),
          v = 255 * v;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    }

    function hsv2hsl(hsv) {
      var h = hsv[0],
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          sl,
          l;
      l = (2 - s) * v;
      sl = s * v;
      sl /= l <= 1 ? l : 2 - l;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    }

    function hsv2hwb(args) {
      return rgb2hwb(hsv2rgb(args));
    }

    function hsv2cmyk(args) {
      return rgb2cmyk(hsv2rgb(args));
    }

    function hsv2keyword(args) {
      return rgb2keyword(hsv2rgb(args));
    } // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


    function hwb2rgb(hwb) {
      var h = hwb[0] / 360,
          wh = hwb[1] / 100,
          bl = hwb[2] / 100,
          ratio = wh + bl,
          i,
          v,
          f,
          n; // wh + bl cant be > 1

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) != 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh); // linear interpolation

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    }

    function hwb2hsl(args) {
      return rgb2hsl(hwb2rgb(args));
    }

    function hwb2hsv(args) {
      return rgb2hsv(hwb2rgb(args));
    }

    function hwb2cmyk(args) {
      return rgb2cmyk(hwb2rgb(args));
    }

    function hwb2keyword(args) {
      return rgb2keyword(hwb2rgb(args));
    }

    function cmyk2rgb(cmyk) {
      var c = cmyk[0] / 100,
          m = cmyk[1] / 100,
          y = cmyk[2] / 100,
          k = cmyk[3] / 100,
          r,
          g,
          b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    }

    function cmyk2hsl(args) {
      return rgb2hsl(cmyk2rgb(args));
    }

    function cmyk2hsv(args) {
      return rgb2hsv(cmyk2rgb(args));
    }

    function cmyk2hwb(args) {
      return rgb2hwb(cmyk2rgb(args));
    }

    function cmyk2keyword(args) {
      return rgb2keyword(cmyk2rgb(args));
    }

    function xyz2rgb(xyz) {
      var x = xyz[0] / 100,
          y = xyz[1] / 100,
          z = xyz[2] / 100,
          r,
          g,
          b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    }

    function xyz2lab(xyz) {
      var x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function xyz2lch(args) {
      return lab2lch(xyz2lab(args));
    }

    function lab2xyz(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          x,
          y,
          z,
          y2;

      if (l <= 8) {
        y = l * 100 / 903.3;
        y2 = 7.787 * (y / 100) + 16 / 116;
      } else {
        y = 100 * Math.pow((l + 16) / 116, 3);
        y2 = Math.pow(y / 100, 1 / 3);
      }

      x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
      z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
      return [x, y, z];
    }

    function lab2lch(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          hr,
          h,
          c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    }

    function lab2rgb(args) {
      return xyz2rgb(lab2xyz(args));
    }

    function lch2lab(lch) {
      var l = lch[0],
          c = lch[1],
          h = lch[2],
          a,
          b,
          hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    }

    function lch2xyz(args) {
      return lab2xyz(lch2lab(args));
    }

    function lch2rgb(args) {
      return lab2rgb(lch2lab(args));
    }

    function keyword2rgb(keyword) {
      return cssKeywords[keyword];
    }

    function keyword2hsl(args) {
      return rgb2hsl(keyword2rgb(args));
    }

    function keyword2hsv(args) {
      return rgb2hsv(keyword2rgb(args));
    }

    function keyword2hwb(args) {
      return rgb2hwb(keyword2rgb(args));
    }

    function keyword2cmyk(args) {
      return rgb2cmyk(keyword2rgb(args));
    }

    function keyword2lab(args) {
      return rgb2lab(keyword2rgb(args));
    }

    function keyword2xyz(args) {
      return rgb2xyz(keyword2rgb(args));
    }

    var cssKeywords = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var reverseKeywords = {};

    for (var key in cssKeywords) {
      reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
    }

    var convert = function () {
      return new Converter();
    };

    for (var func in conversions) {
      // export Raw versions
      convert[func + "Raw"] = function (func) {
        // accept array or plain args
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          return conversions[func](arg);
        };
      }(func);

      var pair = /(\w+)2(\w+)/.exec(func),
          from = pair[1],
          to = pair[2]; // export rgb2hsl and ["rgb"]["hsl"]

      convert[from] = convert[from] || {};

      convert[from][to] = convert[func] = function (func) {
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          var val = conversions[func](arg);

          if (typeof val == "string" || val === undefined) {
            return val;
          } // keyword


          for (var i = 0; i < val.length; i++) {
            val[i] = Math.round(val[i]);
          }

          return val;
        };
      }(func);
    }
    /* Converter does lazy conversion and caching */


    var Converter = function () {
      this.convs = {};
    };
    /* Either get the values for a space or
      set the values for a space, depending on args */


    Converter.prototype.routeSpace = function (space, args) {
      var values = args[0];

      if (values === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof values == "number") {
        values = Array.prototype.slice.call(args);
      }

      return this.setValues(space, values);
    };
    /* Set the values for a space, invalidating cache */


    Converter.prototype.setValues = function (space, values) {
      this.space = space;
      this.convs = {};
      this.convs[space] = values;
      return this;
    };
    /* Get the values for a space. If there's already
      a conversion for the space, fetch it, otherwise
      compute it */


    Converter.prototype.getValues = function (space) {
      var vals = this.convs[space];

      if (!vals) {
        var fspace = this.space,
            from = this.convs[fspace];
        vals = convert[fspace][space](from);
        this.convs[space] = vals;
      }

      return vals;
    };

    ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
      Converter.prototype[space] = function (vals) {
        return this.routeSpace(space, arguments);
      };
    });
    var colorConvert = convert;
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    /* MIT license */

    var colorString = {
      getRgba: getRgba,
      getHsla: getHsla,
      getRgb: getRgb,
      getHsl: getHsl,
      getHwb: getHwb,
      getAlpha: getAlpha,
      hexString: hexString,
      rgbString: rgbString,
      rgbaString: rgbaString,
      percentString: percentString,
      percentaString: percentaString,
      hslString: hslString,
      hslaString: hslaString,
      hwbString: hwbString,
      keyword: keyword
    };

    function getRgba(string) {
      if (!string) {
        return;
      }

      var abbr = /^#([a-fA-F0-9]{3,4})$/i,
          hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
          rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          keyword = /(\w+)/;
      var rgb = [0, 0, 0],
          a = 1,
          match = string.match(abbr),
          hexAlpha = "";

      if (match) {
        match = match[1];
        hexAlpha = match[3];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(rgba)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i + 1]);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(per)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(keyword)) {
        if (match[1] == "transparent") {
          return [0, 0, 0, 0];
        }

        rgb = colorName[match[1]];

        if (!rgb) {
          return;
        }
      }

      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = scale(rgb[i], 0, 255);
      }

      if (!a && a != 0) {
        a = 1;
      } else {
        a = scale(a, 0, 1);
      }

      rgb[3] = a;
      return rgb;
    }

    function getHsla(string) {
      if (!string) {
        return;
      }

      var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hsl);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            s = scale(parseFloat(match[2]), 0, 100),
            l = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
    }

    function getHwb(string) {
      if (!string) {
        return;
      }

      var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hwb);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            w = scale(parseFloat(match[2]), 0, 100),
            b = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
    }

    function getRgb(string) {
      var rgba = getRgba(string);
      return rgba && rgba.slice(0, 3);
    }

    function getHsl(string) {
      var hsla = getHsla(string);
      return hsla && hsla.slice(0, 3);
    }

    function getAlpha(string) {
      var vals = getRgba(string);

      if (vals) {
        return vals[3];
      } else if (vals = getHsla(string)) {
        return vals[3];
      } else if (vals = getHwb(string)) {
        return vals[3];
      }
    } // generators


    function hexString(rgba, a) {
      var a = a !== undefined && rgba.length === 3 ? a : rgba[3];
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
    }

    function rgbString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return rgbaString(rgba, alpha);
      }

      return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
    }

    function rgbaString(rgba, alpha) {
      if (alpha === undefined) {
        alpha = rgba[3] !== undefined ? rgba[3] : 1;
      }

      return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
    }

    function percentString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return percentaString(rgba, alpha);
      }

      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgb(" + r + "%, " + g + "%, " + b + "%)";
    }

    function percentaString(rgba, alpha) {
      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
    }

    function hslString(hsla, alpha) {
      if (alpha < 1 || hsla[3] && hsla[3] < 1) {
        return hslaString(hsla, alpha);
      }

      return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
    }

    function hslaString(hsla, alpha) {
      if (alpha === undefined) {
        alpha = hsla[3] !== undefined ? hsla[3] : 1;
      }

      return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
    } // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
    // (hwb have alpha optional & 1 is default value)


    function hwbString(hwb, alpha) {
      if (alpha === undefined) {
        alpha = hwb[3] !== undefined ? hwb[3] : 1;
      }

      return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
    }

    function keyword(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    } // helpers


    function scale(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }

    function hexDouble(num) {
      var str = num.toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    } //create a list of reverse color names


    var reverseNames = {};

    for (var name in colorName) {
      reverseNames[colorName[name]] = name;
    }
    /* MIT license */


    var Color = function (obj) {
      if (obj instanceof Color) {
        return obj;
      }

      if (!(this instanceof Color)) {
        return new Color(obj);
      }

      this.valid = false;
      this.values = {
        rgb: [0, 0, 0],
        hsl: [0, 0, 0],
        hsv: [0, 0, 0],
        hwb: [0, 0, 0],
        cmyk: [0, 0, 0, 0],
        alpha: 1
      }; // parse Color() argument

      var vals;

      if (typeof obj === 'string') {
        vals = colorString.getRgba(obj);

        if (vals) {
          this.setValues('rgb', vals);
        } else if (vals = colorString.getHsla(obj)) {
          this.setValues('hsl', vals);
        } else if (vals = colorString.getHwb(obj)) {
          this.setValues('hwb', vals);
        }
      } else if (typeof obj === 'object') {
        vals = obj;

        if (vals.r !== undefined || vals.red !== undefined) {
          this.setValues('rgb', vals);
        } else if (vals.l !== undefined || vals.lightness !== undefined) {
          this.setValues('hsl', vals);
        } else if (vals.v !== undefined || vals.value !== undefined) {
          this.setValues('hsv', vals);
        } else if (vals.w !== undefined || vals.whiteness !== undefined) {
          this.setValues('hwb', vals);
        } else if (vals.c !== undefined || vals.cyan !== undefined) {
          this.setValues('cmyk', vals);
        }
      }
    };

    Color.prototype = {
      isValid: function () {
        return this.valid;
      },
      rgb: function () {
        return this.setSpace('rgb', arguments);
      },
      hsl: function () {
        return this.setSpace('hsl', arguments);
      },
      hsv: function () {
        return this.setSpace('hsv', arguments);
      },
      hwb: function () {
        return this.setSpace('hwb', arguments);
      },
      cmyk: function () {
        return this.setSpace('cmyk', arguments);
      },
      rgbArray: function () {
        return this.values.rgb;
      },
      hslArray: function () {
        return this.values.hsl;
      },
      hsvArray: function () {
        return this.values.hsv;
      },
      hwbArray: function () {
        var values = this.values;

        if (values.alpha !== 1) {
          return values.hwb.concat([values.alpha]);
        }

        return values.hwb;
      },
      cmykArray: function () {
        return this.values.cmyk;
      },
      rgbaArray: function () {
        var values = this.values;
        return values.rgb.concat([values.alpha]);
      },
      hslaArray: function () {
        var values = this.values;
        return values.hsl.concat([values.alpha]);
      },
      alpha: function (val) {
        if (val === undefined) {
          return this.values.alpha;
        }

        this.setValues('alpha', val);
        return this;
      },
      red: function (val) {
        return this.setChannel('rgb', 0, val);
      },
      green: function (val) {
        return this.setChannel('rgb', 1, val);
      },
      blue: function (val) {
        return this.setChannel('rgb', 2, val);
      },
      hue: function (val) {
        if (val) {
          val %= 360;
          val = val < 0 ? 360 + val : val;
        }

        return this.setChannel('hsl', 0, val);
      },
      saturation: function (val) {
        return this.setChannel('hsl', 1, val);
      },
      lightness: function (val) {
        return this.setChannel('hsl', 2, val);
      },
      saturationv: function (val) {
        return this.setChannel('hsv', 1, val);
      },
      whiteness: function (val) {
        return this.setChannel('hwb', 1, val);
      },
      blackness: function (val) {
        return this.setChannel('hwb', 2, val);
      },
      value: function (val) {
        return this.setChannel('hsv', 2, val);
      },
      cyan: function (val) {
        return this.setChannel('cmyk', 0, val);
      },
      magenta: function (val) {
        return this.setChannel('cmyk', 1, val);
      },
      yellow: function (val) {
        return this.setChannel('cmyk', 2, val);
      },
      black: function (val) {
        return this.setChannel('cmyk', 3, val);
      },
      hexString: function () {
        return colorString.hexString(this.values.rgb);
      },
      rgbString: function () {
        return colorString.rgbString(this.values.rgb, this.values.alpha);
      },
      rgbaString: function () {
        return colorString.rgbaString(this.values.rgb, this.values.alpha);
      },
      percentString: function () {
        return colorString.percentString(this.values.rgb, this.values.alpha);
      },
      hslString: function () {
        return colorString.hslString(this.values.hsl, this.values.alpha);
      },
      hslaString: function () {
        return colorString.hslaString(this.values.hsl, this.values.alpha);
      },
      hwbString: function () {
        return colorString.hwbString(this.values.hwb, this.values.alpha);
      },
      keyword: function () {
        return colorString.keyword(this.values.rgb, this.values.alpha);
      },
      rgbNumber: function () {
        var rgb = this.values.rgb;
        return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
      },
      luminosity: function () {
        // http://www.w3.org/TR/WCAG20/#relativeluminancedef
        var rgb = this.values.rgb;
        var lum = [];

        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }

        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function (color2) {
        // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();

        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }

        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function (color2) {
        var contrastRatio = this.contrast(color2);

        if (contrastRatio >= 7.1) {
          return 'AAA';
        }

        return contrastRatio >= 4.5 ? 'AA' : '';
      },
      dark: function () {
        // YIQ equation from http://24ways.org/2010/calculating-color-contrast
        var rgb = this.values.rgb;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        return yiq < 128;
      },
      light: function () {
        return !this.dark();
      },
      negate: function () {
        var rgb = [];

        for (var i = 0; i < 3; i++) {
          rgb[i] = 255 - this.values.rgb[i];
        }

        this.setValues('rgb', rgb);
        return this;
      },
      lighten: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] += hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      darken: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] -= hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      saturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] += hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      desaturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] -= hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      whiten: function (ratio) {
        var hwb = this.values.hwb;
        hwb[1] += hwb[1] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      blacken: function (ratio) {
        var hwb = this.values.hwb;
        hwb[2] += hwb[2] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      greyscale: function () {
        var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale

        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        this.setValues('rgb', [val, val, val]);
        return this;
      },
      clearer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha - alpha * ratio);
        return this;
      },
      opaquer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha + alpha * ratio);
        return this;
      },
      rotate: function (degrees) {
        var hsl = this.values.hsl;
        var hue = (hsl[0] + degrees) % 360;
        hsl[0] = hue < 0 ? 360 + hue : hue;
        this.setValues('hsl', hsl);
        return this;
      },

      /**
       * Ported from sass implementation in C
       * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
       */
      mix: function (mixinColor, weight) {
        var color1 = this;
        var color2 = mixinColor;
        var p = weight === undefined ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;
        return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
      },
      toJSON: function () {
        return this.rgb();
      },
      clone: function () {
        // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
        // making the final build way to big to embed in Chart.js. So let's do it manually,
        // assuming that values to clone are 1 dimension arrays containing only numbers,
        // except 'alpha' which is a number.
        var result = new Color();
        var source = this.values;
        var target = result.values;
        var value, type;

        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            value = source[prop];
            type = {}.toString.call(value);

            if (type === '[object Array]') {
              target[prop] = value.slice(0);
            } else if (type === '[object Number]') {
              target[prop] = value;
            } else {
              console.error('unexpected color value:', value);
            }
          }
        }

        return result;
      }
    };
    Color.prototype.spaces = {
      rgb: ['red', 'green', 'blue'],
      hsl: ['hue', 'saturation', 'lightness'],
      hsv: ['hue', 'saturation', 'value'],
      hwb: ['hue', 'whiteness', 'blackness'],
      cmyk: ['cyan', 'magenta', 'yellow', 'black']
    };
    Color.prototype.maxes = {
      rgb: [255, 255, 255],
      hsl: [360, 100, 100],
      hsv: [360, 100, 100],
      hwb: [360, 100, 100],
      cmyk: [100, 100, 100, 100]
    };

    Color.prototype.getValues = function (space) {
      var values = this.values;
      var vals = {};

      for (var i = 0; i < space.length; i++) {
        vals[space.charAt(i)] = values[space][i];
      }

      if (values.alpha !== 1) {
        vals.a = values.alpha;
      } // {r: 255, g: 255, b: 255, a: 0.4}


      return vals;
    };

    Color.prototype.setValues = function (space, vals) {
      var values = this.values;
      var spaces = this.spaces;
      var maxes = this.maxes;
      var alpha = 1;
      var i;
      this.valid = true;

      if (space === 'alpha') {
        alpha = vals;
      } else if (vals.length) {
        // [10, 10, 10]
        values[space] = vals.slice(0, space.length);
        alpha = vals[space.length];
      } else if (vals[space.charAt(0)] !== undefined) {
        // {r: 10, g: 10, b: 10}
        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[space.charAt(i)];
        }

        alpha = vals.a;
      } else if (vals[spaces[space][0]] !== undefined) {
        // {red: 10, green: 10, blue: 10}
        var chans = spaces[space];

        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[chans[i]];
        }

        alpha = vals.alpha;
      }

      values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

      if (space === 'alpha') {
        return false;
      }

      var capped; // cap values of the space prior converting all values

      for (i = 0; i < space.length; i++) {
        capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
        values[space][i] = Math.round(capped);
      } // convert to all the other color spaces


      for (var sname in spaces) {
        if (sname !== space) {
          values[sname] = colorConvert[space][sname](values[space]);
        }
      }

      return true;
    };

    Color.prototype.setSpace = function (space, args) {
      var vals = args[0];

      if (vals === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof vals === 'number') {
        vals = Array.prototype.slice.call(args);
      }

      this.setValues(space, vals);
      return this;
    };

    Color.prototype.setChannel = function (space, index, val) {
      var svalues = this.values[space];

      if (val === undefined) {
        // color.red()
        return svalues[index];
      } else if (val === svalues[index]) {
        // color.red(color.red())
        return this;
      } // color.red(100)


      svalues[index] = val;
      this.setValues(space, svalues);
      return this;
    };

    if (typeof window !== 'undefined') {
      window.Color = Color;
    }

    var chartjsColor = Color;
    /**
     * @namespace Chart.helpers
     */

    var helpers = {
      /**
       * An empty function that can be used, for example, for optional callback.
       */
      noop: function () {},

      /**
       * Returns a unique id, sequentially generated from a global variable.
       * @returns {number}
       * @function
       */
      uid: function () {
        var id = 0;
        return function () {
          return id++;
        };
      }(),

      /**
       * Returns true if `value` is neither null nor undefined, else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isNullOrUndef: function (value) {
        return value === null || typeof value === 'undefined';
      },

      /**
       * Returns true if `value` is an array (including typed arrays), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @function
       */
      isArray: function (value) {
        if (Array.isArray && Array.isArray(value)) {
          return true;
        }

        var type = Object.prototype.toString.call(value);

        if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
          return true;
        }

        return false;
      },

      /**
       * Returns true if `value` is an object (excluding null), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isObject: function (value) {
        return value !== null && Object.prototype.toString.call(value) === '[object Object]';
      },

      /**
       * Returns true if `value` is a finite number, else returns false
       * @param {*} value  - The value to test.
       * @returns {boolean}
       */
      isFinite: function (value) {
        return (typeof value === 'number' || value instanceof Number) && isFinite(value);
      },

      /**
       * Returns `value` if defined, else returns `defaultValue`.
       * @param {*} value - The value to return if defined.
       * @param {*} defaultValue - The value to return if `value` is undefined.
       * @returns {*}
       */
      valueOrDefault: function (value, defaultValue) {
        return typeof value === 'undefined' ? defaultValue : value;
      },

      /**
       * Returns value at the given `index` in array if defined, else returns `defaultValue`.
       * @param {Array} value - The array to lookup for value at `index`.
       * @param {number} index - The index in `value` to lookup for value.
       * @param {*} defaultValue - The value to return if `value[index]` is undefined.
       * @returns {*}
       */
      valueAtIndexOrDefault: function (value, index, defaultValue) {
        return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
      },

      /**
       * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
       * value returned by `fn`. If `fn` is not a function, this method returns undefined.
       * @param {function} fn - The function to call.
       * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @returns {*}
       */
      callback: function (fn, args, thisArg) {
        if (fn && typeof fn.call === 'function') {
          return fn.apply(thisArg, args);
        }
      },

      /**
       * Note(SB) for performance sake, this method should only be used when loopable type
       * is unknown or in none intensive code (not called often and small loopable). Else
       * it's preferable to use a regular for() loop and save extra function calls.
       * @param {object|Array} loopable - The object or array to be iterated.
       * @param {function} fn - The function to call for each item.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @param {boolean} [reverse] - If true, iterates backward on the loopable.
       */
      each: function (loopable, fn, thisArg, reverse) {
        var i, len, keys;

        if (helpers.isArray(loopable)) {
          len = loopable.length;

          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (helpers.isObject(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;

          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      },

      /**
       * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
       * @see https://stackoverflow.com/a/14853974
       * @param {Array} a0 - The array to compare
       * @param {Array} a1 - The array to compare
       * @returns {boolean}
       */
      arrayEquals: function (a0, a1) {
        var i, ilen, v0, v1;

        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }

        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];

          if (v0 instanceof Array && v1 instanceof Array) {
            if (!helpers.arrayEquals(v0, v1)) {
              return false;
            }
          } else if (v0 !== v1) {
            // NOTE: two different object instances will never be equal: {x:20} != {x:20}
            return false;
          }
        }

        return true;
      },

      /**
       * Returns a deep copy of `source` without keeping references on objects and arrays.
       * @param {*} source - The value to clone.
       * @returns {*}
       */
      clone: function (source) {
        if (helpers.isArray(source)) {
          return source.map(helpers.clone);
        }

        if (helpers.isObject(source)) {
          var target = {};
          var keys = Object.keys(source);
          var klen = keys.length;
          var k = 0;

          for (; k < klen; ++k) {
            target[keys[k]] = helpers.clone(source[keys[k]]);
          }

          return target;
        }

        return source;
      },

      /**
       * The default merger when Chart.helpers.merge is called without merger option.
       * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
       * @private
       */
      _merger: function (key, target, source, options) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.merge(tval, sval, options);
        } else {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Merges source[key] in target[key] only if target[key] is undefined.
       * @private
       */
      _mergerIf: function (key, target, source) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.mergeIf(tval, sval);
        } else if (!target.hasOwnProperty(key)) {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Recursively deep copies `source` properties into `target` with the given `options`.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @param {object} [options] - Merging options:
       * @param {function} [options.merger] - The merge method (key, target, source, options)
       * @returns {object} The `target` object.
       */
      merge: function (target, source, options) {
        var sources = helpers.isArray(source) ? source : [source];
        var ilen = sources.length;
        var merge, i, keys, klen, k;

        if (!helpers.isObject(target)) {
          return target;
        }

        options = options || {};
        merge = options.merger || helpers._merger;

        for (i = 0; i < ilen; ++i) {
          source = sources[i];

          if (!helpers.isObject(source)) {
            continue;
          }

          keys = Object.keys(source);

          for (k = 0, klen = keys.length; k < klen; ++k) {
            merge(keys[k], target, source, options);
          }
        }

        return target;
      },

      /**
       * Recursively deep copies `source` properties into `target` *only* if not defined in target.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @returns {object} The `target` object.
       */
      mergeIf: function (target, source) {
        return helpers.merge(target, source, {
          merger: helpers._mergerIf
        });
      },

      /**
       * Applies the contents of two or more objects together into the first object.
       * @param {object} target - The target object in which all objects are merged into.
       * @param {object} arg1 - Object containing additional properties to merge in target.
       * @param {object} argN - Additional objects containing properties to merge in target.
       * @returns {object} The `target` object.
       */
      extend: function (target) {
        var arguments$1 = arguments;

        var setFn = function (value, key) {
          target[key] = value;
        };

        for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
          helpers.each(arguments$1[i], setFn);
        }

        return target;
      },

      /**
       * Basic javascript inheritance based on the model created in Backbone.js
       */
      inherits: function (extensions) {
        var me = this;
        var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
          return me.apply(this, arguments);
        };

        var Surrogate = function () {
          this.constructor = ChartElement;
        };

        Surrogate.prototype = me.prototype;
        ChartElement.prototype = new Surrogate();
        ChartElement.extend = helpers.inherits;

        if (extensions) {
          helpers.extend(ChartElement.prototype, extensions);
        }

        ChartElement.__super__ = me.prototype;
        return ChartElement;
      }
    };
    var helpers_core = helpers; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.callback instead.
     * @function Chart.helpers.callCallback
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    helpers.callCallback = helpers.callback;
    /**
     * Provided for backward compatibility, use Array.prototype.indexOf instead.
     * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
     * @function Chart.helpers.indexOf
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.indexOf = function (array, item, fromIndex) {
      return Array.prototype.indexOf.call(array, item, fromIndex);
    };
    /**
     * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
     * @function Chart.helpers.getValueOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */


    helpers.getValueOrDefault = helpers.valueOrDefault;
    /**
     * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
     * @function Chart.helpers.getValueAtIndexOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
    /**
     * Easing functions adapted from Robert Penner's easing equations.
     * @namespace Chart.helpers.easingEffects
     * @see http://www.robertpenner.com/easing/
     */

    var effects = {
      linear: function (t) {
        return t;
      },
      easeInQuad: function (t) {
        return t * t;
      },
      easeOutQuad: function (t) {
        return -t * (t - 2);
      },
      easeInOutQuad: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t;
        }

        return -0.5 * (--t * (t - 2) - 1);
      },
      easeInCubic: function (t) {
        return t * t * t;
      },
      easeOutCubic: function (t) {
        return (t = t - 1) * t * t + 1;
      },
      easeInOutCubic: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t + 2);
      },
      easeInQuart: function (t) {
        return t * t * t * t;
      },
      easeOutQuart: function (t) {
        return -((t = t - 1) * t * t * t - 1);
      },
      easeInOutQuart: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t;
        }

        return -0.5 * ((t -= 2) * t * t * t - 2);
      },
      easeInQuint: function (t) {
        return t * t * t * t * t;
      },
      easeOutQuint: function (t) {
        return (t = t - 1) * t * t * t * t + 1;
      },
      easeInOutQuint: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t * t * t + 2);
      },
      easeInSine: function (t) {
        return -Math.cos(t * (Math.PI / 2)) + 1;
      },
      easeOutSine: function (t) {
        return Math.sin(t * (Math.PI / 2));
      },
      easeInOutSine: function (t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
      },
      easeInExpo: function (t) {
        return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
      },
      easeOutExpo: function (t) {
        return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
      },
      easeInOutExpo: function (t) {
        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(2, 10 * (t - 1));
        }

        return 0.5 * (-Math.pow(2, -10 * --t) + 2);
      },
      easeInCirc: function (t) {
        if (t >= 1) {
          return t;
        }

        return -(Math.sqrt(1 - t * t) - 1);
      },
      easeOutCirc: function (t) {
        return Math.sqrt(1 - (t = t - 1) * t);
      },
      easeInOutCirc: function (t) {
        if ((t /= 0.5) < 1) {
          return -0.5 * (Math.sqrt(1 - t * t) - 1);
        }

        return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      },
      easeInElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
      },
      easeOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
      },
      easeInOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if ((t /= 0.5) === 2) {
          return 1;
        }

        if (!p) {
          p = 0.45;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        if (t < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
        }

        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      easeInBack: function (t) {
        var s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      easeOutBack: function (t) {
        var s = 1.70158;
        return (t = t - 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack: function (t) {
        var s = 1.70158;

        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }

        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      easeInBounce: function (t) {
        return 1 - effects.easeOutBounce(1 - t);
      },
      easeOutBounce: function (t) {
        if (t < 1 / 2.75) {
          return 7.5625 * t * t;
        }

        if (t < 2 / 2.75) {
          return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        }

        if (t < 2.5 / 2.75) {
          return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        }

        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      },
      easeInOutBounce: function (t) {
        if (t < 0.5) {
          return effects.easeInBounce(t * 2) * 0.5;
        }

        return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
      }
    };
    var helpers_easing = {
      effects: effects
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
     * @function Chart.helpers.easingEffects
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.easingEffects = effects;
    var PI = Math.PI;
    var RAD_PER_DEG = PI / 180;
    var DOUBLE_PI = PI * 2;
    var HALF_PI = PI / 2;
    var QUARTER_PI = PI / 4;
    var TWO_THIRDS_PI = PI * 2 / 3;
    /**
     * @namespace Chart.helpers.canvas
     */

    var exports$1 = {
      /**
       * Clears the entire canvas associated to the given `chart`.
       * @param {Chart} chart - The chart for which to clear the canvas.
       */
      clear: function (chart) {
        chart.ctx.clearRect(0, 0, chart.width, chart.height);
      },

      /**
       * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
       * given size (width, height) and the same `radius` for all corners.
       * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
       * @param {number} x - The x axis of the coordinate for the rectangle starting point.
       * @param {number} y - The y axis of the coordinate for the rectangle starting point.
       * @param {number} width - The rectangle's width.
       * @param {number} height - The rectangle's height.
       * @param {number} radius - The rounded amount (in pixels) for the four corners.
       * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
       */
      roundedRect: function (ctx, x, y, width, height, radius) {
        if (radius) {
          var r = Math.min(radius, height / 2, width / 2);
          var left = x + r;
          var top = y + r;
          var right = x + width - r;
          var bottom = y + height - r;
          ctx.moveTo(x, top);

          if (left < right && top < bottom) {
            ctx.arc(left, top, r, -PI, -HALF_PI);
            ctx.arc(right, top, r, -HALF_PI, 0);
            ctx.arc(right, bottom, r, 0, HALF_PI);
            ctx.arc(left, bottom, r, HALF_PI, PI);
          } else if (left < right) {
            ctx.moveTo(left, y);
            ctx.arc(right, top, r, -HALF_PI, HALF_PI);
            ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
          } else if (top < bottom) {
            ctx.arc(left, top, r, -PI, 0);
            ctx.arc(left, bottom, r, 0, PI);
          } else {
            ctx.arc(left, top, r, -PI, PI);
          }

          ctx.closePath();
          ctx.moveTo(x, y);
        } else {
          ctx.rect(x, y, width, height);
        }
      },
      drawPoint: function (ctx, style, radius, x, y, rotation) {
        var type, xOffset, yOffset, size, cornerRadius;
        var rad = (rotation || 0) * RAD_PER_DEG;

        if (style && typeof style === 'object') {
          type = style.toString();

          if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
            return;
          }
        }

        if (isNaN(radius) || radius <= 0) {
          return;
        }

        ctx.beginPath();

        switch (style) {
          // Default includes circle
          default:
            ctx.arc(x, y, radius, 0, DOUBLE_PI);
            ctx.closePath();
            break;

          case 'triangle':
            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;

          case 'rectRounded':
            // NOTE: the rounded rect implementation changed to use `arc` instead of
            // `quadraticCurveTo` since it generates better results when rect is
            // almost a circle. 0.516 (instead of 0.5) produces results with visually
            // closer proportion to the previous impl and it is inscribed in the
            // circle with `radius`. For more details, see the following PRs:
            // https://github.com/chartjs/Chart.js/issues/5597
            // https://github.com/chartjs/Chart.js/issues/5858
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;

          case 'rect':
            if (!rotation) {
              size = Math.SQRT1_2 * radius;
              ctx.rect(x - size, y - size, 2 * size, 2 * size);
              break;
            }

            rad += QUARTER_PI;

          /* falls through */

          case 'rectRot':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + yOffset, y - xOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            ctx.closePath();
            break;

          case 'crossRot':
            rad += QUARTER_PI;

          /* falls through */

          case 'cross':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'star':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            rad += QUARTER_PI;
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'line':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;

          case 'dash':
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
            break;
        }

        ctx.fill();
        ctx.stroke();
      },

      /**
       * Returns true if the point is inside the rectangle
       * @param {object} point - The point to test
       * @param {object} area - The rectangle
       * @returns {boolean}
       * @private
       */
      _isPointInArea: function (point, area) {
        var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

        return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
      },
      clipArea: function (ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      },
      unclipArea: function (ctx) {
        ctx.restore();
      },
      lineTo: function (ctx, previous, target, flip) {
        var stepped = target.steppedLine;

        if (stepped) {
          if (stepped === 'middle') {
            var midpoint = (previous.x + target.x) / 2.0;
            ctx.lineTo(midpoint, flip ? target.y : previous.y);
            ctx.lineTo(midpoint, flip ? previous.y : target.y);
          } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }

          ctx.lineTo(target.x, target.y);
          return;
        }

        if (!target.tension) {
          ctx.lineTo(target.x, target.y);
          return;
        }

        ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
      }
    };
    var helpers_canvas = exports$1; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
     * @namespace Chart.helpers.clear
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.clear = exports$1.clear;
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
     * @namespace Chart.helpers.drawRoundedRectangle
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.drawRoundedRectangle = function (ctx) {
      ctx.beginPath();
      exports$1.roundedRect.apply(exports$1, arguments);
    };

    var defaults = {
      /**
       * @private
       */
      _set: function (scope, values) {
        return helpers_core.merge(this[scope] || (this[scope] = {}), values);
      }
    };

    defaults._set('global', {
      defaultColor: 'rgba(0,0,0,0.1)',
      defaultFontColor: '#666',
      defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      defaultFontSize: 12,
      defaultFontStyle: 'normal',
      defaultLineHeight: 1.2,
      showLines: true
    });

    var core_defaults = defaults;
    var valueOrDefault = helpers_core.valueOrDefault;
    /**
     * Converts the given font object into a CSS font string.
     * @param {object} font - A font object.
     * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
     * @private
     */

    function toFontString(font) {
      if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
        return null;
      }

      return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
    }
    /**
     * @alias Chart.helpers.options
     * @namespace
     */


    var helpers_options = {
      /**
       * Converts the given line height `value` in pixels for a specific font `size`.
       * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
       * @param {number} size - The font size (in pixels) used to resolve relative `value`.
       * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
       * @since 2.7.0
       */
      toLineHeight: function (value, size) {
        var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);

        if (!matches || matches[1] === 'normal') {
          return size * 1.2;
        }

        value = +matches[2];

        switch (matches[3]) {
          case 'px':
            return value;

          case '%':
            value /= 100;
            break;

          default:
            break;
        }

        return size * value;
      },

      /**
       * Converts the given value into a padding object with pre-computed width/height.
       * @param {number|object} value - If a number, set the value to all TRBL component,
       *  else, if and object, use defined properties and sets undefined ones to 0.
       * @returns {object} The padding values (top, right, bottom, left, width, height)
       * @since 2.7.0
       */
      toPadding: function (value) {
        var t, r, b, l;

        if (helpers_core.isObject(value)) {
          t = +value.top || 0;
          r = +value.right || 0;
          b = +value.bottom || 0;
          l = +value.left || 0;
        } else {
          t = r = b = l = +value || 0;
        }

        return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          height: t + b,
          width: l + r
        };
      },

      /**
       * Parses font options and returns the font object.
       * @param {object} options - A object that contains font options to be parsed.
       * @return {object} The font object.
       * @todo Support font.* options and renamed to toFont().
       * @private
       */
      _parseFont: function (options) {
        var globalDefaults = core_defaults.global;
        var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
        var font = {
          family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
          lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
          size: size,
          style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
          weight: null,
          string: ''
        };
        font.string = toFontString(font);
        return font;
      },

      /**
       * Evaluates the given `inputs` sequentially and returns the first defined value.
       * @param {Array} inputs - An array of values, falling back to the last value.
       * @param {object} [context] - If defined and the current value is a function, the value
       * is called with `context` as first argument and the result becomes the new input.
       * @param {number} [index] - If defined and the current value is an array, the value
       * at `index` become the new input.
       * @since 2.7.0
       */
      resolve: function (inputs, context, index) {
        var i, ilen, value;

        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];

          if (value === undefined) {
            continue;
          }

          if (context !== undefined && typeof value === 'function') {
            value = value(context);
          }

          if (index !== undefined && helpers_core.isArray(value)) {
            value = value[index];
          }

          if (value !== undefined) {
            return value;
          }
        }
      }
    };
    var helpers$1 = helpers_core;
    var easing = helpers_easing;
    var canvas = helpers_canvas;
    var options = helpers_options;
    helpers$1.easing = easing;
    helpers$1.canvas = canvas;
    helpers$1.options = options;

    function interpolate(start, view, model, ease) {
      var keys = Object.keys(model);
      var i, ilen, key, actual, origin, target, type, c0, c1;

      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        target = model[key]; // if a value is added to the model after pivot() has been called, the view
        // doesn't contain it, so let's initialize the view to the target value.

        if (!view.hasOwnProperty(key)) {
          view[key] = target;
        }

        actual = view[key];

        if (actual === target || key[0] === '_') {
          continue;
        }

        if (!start.hasOwnProperty(key)) {
          start[key] = actual;
        }

        origin = start[key];
        type = typeof target;

        if (type === typeof origin) {
          if (type === 'string') {
            c0 = chartjsColor(origin);

            if (c0.valid) {
              c1 = chartjsColor(target);

              if (c1.valid) {
                view[key] = c1.mix(c0, ease).rgbString();
                continue;
              }
            }
          } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
            view[key] = origin + (target - origin) * ease;
            continue;
          }
        }

        view[key] = target;
      }
    }

    var Element = function (configuration) {
      helpers$1.extend(this, configuration);
      this.initialize.apply(this, arguments);
    };

    helpers$1.extend(Element.prototype, {
      initialize: function () {
        this.hidden = false;
      },
      pivot: function () {
        var me = this;

        if (!me._view) {
          me._view = helpers$1.clone(me._model);
        }

        me._start = {};
        return me;
      },
      transition: function (ease) {
        var me = this;
        var model = me._model;
        var start = me._start;
        var view = me._view; // No animation -> No Transition

        if (!model || ease === 1) {
          me._view = model;
          me._start = null;
          return me;
        }

        if (!view) {
          view = me._view = {};
        }

        if (!start) {
          start = me._start = {};
        }

        interpolate(start, view, model, ease);
        return me;
      },
      tooltipPosition: function () {
        return {
          x: this._model.x,
          y: this._model.y
        };
      },
      hasValue: function () {
        return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
      }
    });
    Element.extend = helpers$1.inherits;
    var core_element = Element;
    var exports$2 = core_element.extend({
      chart: null,
      // the animation associated chart instance
      currentStep: 0,
      // the current animation step
      numSteps: 60,
      // default number of steps
      easing: '',
      // the easing to use for this animation
      render: null,
      // render function used by the animation service
      onAnimationProgress: null,
      // user specified callback to fire on each step of the animation
      onAnimationComplete: null // user specified callback to fire when the animation finishes

    });
    var core_animation = exports$2; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.Animation instead
     * @prop Chart.Animation#animationObject
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'animationObject', {
      get: function () {
        return this;
      }
    });
    /**
     * Provided for backward compatibility, use Chart.Animation#chart instead
     * @prop Chart.Animation#chartInstance
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'chartInstance', {
      get: function () {
        return this.chart;
      },
      set: function (value) {
        this.chart = value;
      }
    });

    core_defaults._set('global', {
      animation: {
        duration: 1000,
        easing: 'easeOutQuart',
        onProgress: helpers$1.noop,
        onComplete: helpers$1.noop
      }
    });

    var core_animations = {
      animations: [],
      request: null,

      /**
       * @param {Chart} chart - The chart to animate.
       * @param {Chart.Animation} animation - The animation that we will animate.
       * @param {number} duration - The animation duration in ms.
       * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
       */
      addAnimation: function (chart, animation, duration, lazy) {
        var animations = this.animations;
        var i, ilen;
        animation.chart = chart;
        animation.startTime = Date.now();
        animation.duration = duration;

        if (!lazy) {
          chart.animating = true;
        }

        for (i = 0, ilen = animations.length; i < ilen; ++i) {
          if (animations[i].chart === chart) {
            animations[i] = animation;
            return;
          }
        }

        animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word

        if (animations.length === 1) {
          this.requestAnimationFrame();
        }
      },
      cancelAnimation: function (chart) {
        var index = helpers$1.findIndex(this.animations, function (animation) {
          return animation.chart === chart;
        });

        if (index !== -1) {
          this.animations.splice(index, 1);
          chart.animating = false;
        }
      },
      requestAnimationFrame: function () {
        var me = this;

        if (me.request === null) {
          // Skip animation frame requests until the active one is executed.
          // This can happen when processing mouse events, e.g. 'mousemove'
          // and 'mouseout' events will trigger multiple renders.
          me.request = helpers$1.requestAnimFrame.call(window, function () {
            me.request = null;
            me.startDigest();
          });
        }
      },

      /**
       * @private
       */
      startDigest: function () {
        var me = this;
        me.advance(); // Do we have more stuff to animate?

        if (me.animations.length > 0) {
          me.requestAnimationFrame();
        }
      },

      /**
       * @private
       */
      advance: function () {
        var animations = this.animations;
        var animation, chart, numSteps, nextStep;
        var i = 0; // 1 animation per chart, so we are looping charts here

        while (i < animations.length) {
          animation = animations[i];
          chart = animation.chart;
          numSteps = animation.numSteps; // Make sure that currentStep starts at 1
          // https://github.com/chartjs/Chart.js/issues/6104

          nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
          animation.currentStep = Math.min(nextStep, numSteps);
          helpers$1.callback(animation.render, [chart, animation], chart);
          helpers$1.callback(animation.onAnimationProgress, [animation], chart);

          if (animation.currentStep >= numSteps) {
            helpers$1.callback(animation.onAnimationComplete, [animation], chart);
            chart.animating = false;
            animations.splice(i, 1);
          } else {
            ++i;
          }
        }
      }
    };
    var resolve = helpers$1.options.resolve;
    var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
    /**
     * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
     * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
     * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
     */

    function listenArrayEvents(array, listener) {
      if (array._chartjs) {
        array._chartjs.listeners.push(listener);

        return;
      }

      Object.defineProperty(array, '_chartjs', {
        configurable: true,
        enumerable: false,
        value: {
          listeners: [listener]
        }
      });
      arrayEvents.forEach(function (key) {
        var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
        var base = array[key];
        Object.defineProperty(array, key, {
          configurable: true,
          enumerable: false,
          value: function () {
            var args = Array.prototype.slice.call(arguments);
            var res = base.apply(this, args);
            helpers$1.each(array._chartjs.listeners, function (object) {
              if (typeof object[method] === 'function') {
                object[method].apply(object, args);
              }
            });
            return res;
          }
        });
      });
    }
    /**
     * Removes the given array event listener and cleanup extra attached properties (such as
     * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
     */


    function unlistenArrayEvents(array, listener) {
      var stub = array._chartjs;

      if (!stub) {
        return;
      }

      var listeners = stub.listeners;
      var index = listeners.indexOf(listener);

      if (index !== -1) {
        listeners.splice(index, 1);
      }

      if (listeners.length > 0) {
        return;
      }

      arrayEvents.forEach(function (key) {
        delete array[key];
      });
      delete array._chartjs;
    } // Base class for all dataset controllers (line, bar, etc)


    var DatasetController = function (chart, datasetIndex) {
      this.initialize(chart, datasetIndex);
    };

    helpers$1.extend(DatasetController.prototype, {
      /**
       * Element type used to generate a meta dataset (e.g. Chart.element.Line).
       * @type {Chart.core.element}
       */
      datasetElementType: null,

      /**
       * Element type used to generate a meta data (e.g. Chart.element.Point).
       * @type {Chart.core.element}
       */
      dataElementType: null,
      initialize: function (chart, datasetIndex) {
        var me = this;
        me.chart = chart;
        me.index = datasetIndex;
        me.linkScales();
        me.addElements();
      },
      updateIndex: function (datasetIndex) {
        this.index = datasetIndex;
      },
      linkScales: function () {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
          meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
        }

        if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
          meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
        }
      },
      getDataset: function () {
        return this.chart.data.datasets[this.index];
      },
      getMeta: function () {
        return this.chart.getDatasetMeta(this.index);
      },
      getScaleForId: function (scaleID) {
        return this.chart.scales[scaleID];
      },

      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().yAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getValueScale: function () {
        return this.getScaleForId(this._getValueScaleId());
      },

      /**
       * @private
       */
      _getIndexScale: function () {
        return this.getScaleForId(this._getIndexScaleId());
      },
      reset: function () {
        this.update(true);
      },

      /**
       * @private
       */
      destroy: function () {
        if (this._data) {
          unlistenArrayEvents(this._data, this);
        }
      },
      createMetaDataset: function () {
        var me = this;
        var type = me.datasetElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index
        });
      },
      createMetaData: function (index) {
        var me = this;
        var type = me.dataElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index,
          _index: index
        });
      },
      addElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data || [];
        var metaData = meta.data;
        var i, ilen;

        for (i = 0, ilen = data.length; i < ilen; ++i) {
          metaData[i] = metaData[i] || me.createMetaData(i);
        }

        meta.dataset = meta.dataset || me.createMetaDataset();
      },
      addElementAndReset: function (index) {
        var element = this.createMetaData(index);
        this.getMeta().data.splice(index, 0, element);
        this.updateElement(element, index, true);
      },
      buildOrUpdateElements: function () {
        var me = this;
        var dataset = me.getDataset();
        var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate
        // real-time charts), we need to monitor these data modifications and synchronize
        // the internal meta data accordingly.

        if (me._data !== data) {
          if (me._data) {
            // This case happens when the user replaced the data array instance.
            unlistenArrayEvents(me._data, me);
          }

          if (data && Object.isExtensible(data)) {
            listenArrayEvents(data, me);
          }

          me._data = data;
        } // Re-sync meta data in case the user replaced the data array or if we missed
        // any updates and so make sure that we handle number of datapoints changing.


        me.resyncElements();
      },
      update: helpers$1.noop,
      transition: function (easingValue) {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        for (; i < ilen; ++i) {
          elements[i].transition(easingValue);
        }

        if (meta.dataset) {
          meta.dataset.transition(easingValue);
        }
      },
      draw: function () {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        if (meta.dataset) {
          meta.dataset.draw();
        }

        for (; i < ilen; ++i) {
          elements[i].draw();
        }
      },
      removeHoverStyle: function (element) {
        helpers$1.merge(element._model, element.$previousStyle || {});
        delete element.$previousStyle;
      },
      setHoverStyle: function (element) {
        var dataset = this.chart.data.datasets[element._datasetIndex];
        var index = element._index;
        var custom = element.custom || {};
        var model = element._model;
        var getHoverColor = helpers$1.getHoverColor;
        element.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
        model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
        model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
      },

      /**
       * @private
       */
      resyncElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data;
        var numMeta = meta.data.length;
        var numData = data.length;

        if (numData < numMeta) {
          meta.data.splice(numData, numMeta - numData);
        } else if (numData > numMeta) {
          me.insertElements(numMeta, numData - numMeta);
        }
      },

      /**
       * @private
       */
      insertElements: function (start, count) {
        for (var i = 0; i < count; ++i) {
          this.addElementAndReset(start + i);
        }
      },

      /**
       * @private
       */
      onDataPush: function () {
        var count = arguments.length;
        this.insertElements(this.getDataset().data.length - count, count);
      },

      /**
       * @private
       */
      onDataPop: function () {
        this.getMeta().data.pop();
      },

      /**
       * @private
       */
      onDataShift: function () {
        this.getMeta().data.shift();
      },

      /**
       * @private
       */
      onDataSplice: function (start, count) {
        this.getMeta().data.splice(start, count);
        this.insertElements(start, arguments.length - 2);
      },

      /**
       * @private
       */
      onDataUnshift: function () {
        this.insertElements(0, arguments.length);
      }
    });
    DatasetController.extend = helpers$1.inherits;
    var core_datasetController = DatasetController;

    core_defaults._set('global', {
      elements: {
        arc: {
          backgroundColor: core_defaults.global.defaultColor,
          borderColor: '#fff',
          borderWidth: 2,
          borderAlign: 'center'
        }
      }
    });

    var element_arc = core_element.extend({
      inLabelRange: function (mouseX) {
        var vm = this._view;

        if (vm) {
          return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
        }

        return false;
      },
      inRange: function (chartX, chartY) {
        var vm = this._view;

        if (vm) {
          var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {
            x: chartX,
            y: chartY
          });
          var angle = pointRelativePosition.angle;
          var distance = pointRelativePosition.distance; // Sanitise angle range

          var startAngle = vm.startAngle;
          var endAngle = vm.endAngle;

          while (endAngle < startAngle) {
            endAngle += 2.0 * Math.PI;
          }

          while (angle > endAngle) {
            angle -= 2.0 * Math.PI;
          }

          while (angle < startAngle) {
            angle += 2.0 * Math.PI;
          } // Check if within the range of the open/close angle


          var betweenAngles = angle >= startAngle && angle <= endAngle;
          var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
          return betweenAngles && withinRadius;
        }

        return false;
      },
      getCenterPoint: function () {
        var vm = this._view;
        var halfAngle = (vm.startAngle + vm.endAngle) / 2;
        var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
        return {
          x: vm.x + Math.cos(halfAngle) * halfRadius,
          y: vm.y + Math.sin(halfAngle) * halfRadius
        };
      },
      getArea: function () {
        var vm = this._view;
        return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
      },
      tooltipPosition: function () {
        var vm = this._view;
        var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
        var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
        return {
          x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
          y: vm.y + Math.sin(centreAngle) * rangeFromCentre
        };
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var sA = vm.startAngle;
        var eA = vm.endAngle;
        var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;
        var angleMargin;
        ctx.save();
        ctx.beginPath();
        ctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);
        ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
        ctx.closePath();
        ctx.fillStyle = vm.backgroundColor;
        ctx.fill();

        if (vm.borderWidth) {
          if (vm.borderAlign === 'inner') {
            // Draw an inner border by cliping the arc and drawing a double-width border
            // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
            ctx.beginPath();
            angleMargin = pixelMargin / vm.outerRadius;
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);

            if (vm.innerRadius > pixelMargin) {
              angleMargin = pixelMargin / vm.innerRadius;
              ctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);
            } else {
              ctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);
            }

            ctx.closePath();
            ctx.clip();
            ctx.beginPath();
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
            ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
            ctx.closePath();
            ctx.lineWidth = vm.borderWidth * 2;
            ctx.lineJoin = 'round';
          } else {
            ctx.lineWidth = vm.borderWidth;
            ctx.lineJoin = 'bevel';
          }

          ctx.strokeStyle = vm.borderColor;
          ctx.stroke();
        }

        ctx.restore();
      }
    });
    var valueOrDefault$1 = helpers$1.valueOrDefault;
    var defaultColor = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        line: {
          tension: 0.4,
          backgroundColor: defaultColor,
          borderWidth: 3,
          borderColor: defaultColor,
          borderCapStyle: 'butt',
          borderDash: [],
          borderDashOffset: 0.0,
          borderJoinStyle: 'miter',
          capBezierPoints: true,
          fill: true // do we fill in the area between the line and its base axis

        }
      }
    });

    var element_line = core_element.extend({
      draw: function () {
        var me = this;
        var vm = me._view;
        var ctx = me._chart.ctx;
        var spanGaps = vm.spanGaps;

        var points = me._children.slice(); // clone array


        var globalDefaults = core_defaults.global;
        var globalOptionLineElements = globalDefaults.elements.line;
        var lastDrawnIndex = -1;
        var index, current, previous, currentVM; // If we are looping, adding the first point again

        if (me._loop && points.length) {
          points.push(points[0]);
        }

        ctx.save(); // Stroke Line Options

        ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash

        if (ctx.setLineDash) {
          ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
        }

        ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
        ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
        ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
        ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line

        ctx.beginPath();
        lastDrawnIndex = -1;

        for (index = 0; index < points.length; ++index) {
          current = points[index];
          previous = helpers$1.previousItem(points, index);
          currentVM = current._view; // First point moves to it's starting position no matter what

          if (index === 0) {
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = index;
            }
          } else {
            previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

            if (!currentVM.skip) {
              if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                // There was a gap and this is the first point after the gap
                ctx.moveTo(currentVM.x, currentVM.y);
              } else {
                // Line to next point
                helpers$1.canvas.lineTo(ctx, previous._view, current._view);
              }

              lastDrawnIndex = index;
            }
          }
        }

        ctx.stroke();
        ctx.restore();
      }
    });
    var valueOrDefault$2 = helpers$1.valueOrDefault;
    var defaultColor$1 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        point: {
          radius: 3,
          pointStyle: 'circle',
          backgroundColor: defaultColor$1,
          borderColor: defaultColor$1,
          borderWidth: 1,
          // Hover
          hitRadius: 1,
          hoverRadius: 4,
          hoverBorderWidth: 1
        }
      }
    });

    function xRange(mouseX) {
      var vm = this._view;
      return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
    }

    function yRange(mouseY) {
      var vm = this._view;
      return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
    }

    var element_point = core_element.extend({
      inRange: function (mouseX, mouseY) {
        var vm = this._view;
        return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
      },
      inLabelRange: xRange,
      inXRange: xRange,
      inYRange: yRange,
      getCenterPoint: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      },
      getArea: function () {
        return Math.PI * Math.pow(this._view.radius, 2);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y,
          padding: vm.radius + vm.borderWidth
        };
      },
      draw: function (chartArea) {
        var vm = this._view;
        var ctx = this._chart.ctx;
        var pointStyle = vm.pointStyle;
        var rotation = vm.rotation;
        var radius = vm.radius;
        var x = vm.x;
        var y = vm.y;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow

        if (vm.skip) {
          return;
        } // Clipping for Points.


        if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
          ctx.strokeStyle = vm.borderColor || defaultColor;
          ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
          ctx.fillStyle = vm.backgroundColor || defaultColor;
          helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
        }
      }
    });
    var defaultColor$2 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        rectangle: {
          backgroundColor: defaultColor$2,
          borderColor: defaultColor$2,
          borderSkipped: 'bottom',
          borderWidth: 0
        }
      }
    });

    function isVertical(vm) {
      return vm && vm.width !== undefined;
    }
    /**
     * Helper function to get the bounds of the bar regardless of the orientation
     * @param bar {Chart.Element.Rectangle} the bar
     * @return {Bounds} bounds of the bar
     * @private
     */


    function getBarBounds(vm) {
      var x1, x2, y1, y2, half;

      if (isVertical(vm)) {
        half = vm.width / 2;
        x1 = vm.x - half;
        x2 = vm.x + half;
        y1 = Math.min(vm.y, vm.base);
        y2 = Math.max(vm.y, vm.base);
      } else {
        half = vm.height / 2;
        x1 = Math.min(vm.x, vm.base);
        x2 = Math.max(vm.x, vm.base);
        y1 = vm.y - half;
        y2 = vm.y + half;
      }

      return {
        left: x1,
        top: y1,
        right: x2,
        bottom: y2
      };
    }

    function swap(orig, v1, v2) {
      return orig === v1 ? v2 : orig === v2 ? v1 : orig;
    }

    function parseBorderSkipped(vm) {
      var edge = vm.borderSkipped;
      var res = {};

      if (!edge) {
        return res;
      }

      if (vm.horizontal) {
        if (vm.base > vm.x) {
          edge = swap(edge, 'left', 'right');
        }
      } else if (vm.base < vm.y) {
        edge = swap(edge, 'bottom', 'top');
      }

      res[edge] = true;
      return res;
    }

    function parseBorderWidth(vm, maxW, maxH) {
      var value = vm.borderWidth;
      var skip = parseBorderSkipped(vm);
      var t, r, b, l;

      if (helpers$1.isObject(value)) {
        t = +value.top || 0;
        r = +value.right || 0;
        b = +value.bottom || 0;
        l = +value.left || 0;
      } else {
        t = r = b = l = +value || 0;
      }

      return {
        t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,
        r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,
        b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
        l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l
      };
    }

    function boundingRects(vm) {
      var bounds = getBarBounds(vm);
      var width = bounds.right - bounds.left;
      var height = bounds.bottom - bounds.top;
      var border = parseBorderWidth(vm, width / 2, height / 2);
      return {
        outer: {
          x: bounds.left,
          y: bounds.top,
          w: width,
          h: height
        },
        inner: {
          x: bounds.left + border.l,
          y: bounds.top + border.t,
          w: width - border.l - border.r,
          h: height - border.t - border.b
        }
      };
    }

    function inRange(vm, x, y) {
      var skipX = x === null;
      var skipY = y === null;
      var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
      return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
    }

    var element_rectangle = core_element.extend({
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var rects = boundingRects(vm);
        var outer = rects.outer;
        var inner = rects.inner;
        ctx.fillStyle = vm.backgroundColor;
        ctx.fillRect(outer.x, outer.y, outer.w, outer.h);

        if (outer.w === inner.w && outer.h === inner.h) {
          return;
        }

        ctx.save();
        ctx.beginPath();
        ctx.rect(outer.x, outer.y, outer.w, outer.h);
        ctx.clip();
        ctx.fillStyle = vm.borderColor;
        ctx.rect(inner.x, inner.y, inner.w, inner.h);
        ctx.fill('evenodd');
        ctx.restore();
      },
      height: function () {
        var vm = this._view;
        return vm.base - vm.y;
      },
      inRange: function (mouseX, mouseY) {
        return inRange(this._view, mouseX, mouseY);
      },
      inLabelRange: function (mouseX, mouseY) {
        var vm = this._view;
        return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
      },
      inXRange: function (mouseX) {
        return inRange(this._view, mouseX, null);
      },
      inYRange: function (mouseY) {
        return inRange(this._view, null, mouseY);
      },
      getCenterPoint: function () {
        var vm = this._view;
        var x, y;

        if (isVertical(vm)) {
          x = vm.x;
          y = (vm.y + vm.base) / 2;
        } else {
          x = (vm.x + vm.base) / 2;
          y = vm.y;
        }

        return {
          x: x,
          y: y
        };
      },
      getArea: function () {
        var vm = this._view;
        return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      }
    });
    var elements = {};
    var Arc = element_arc;
    var Line = element_line;
    var Point = element_point;
    var Rectangle = element_rectangle;
    elements.Arc = Arc;
    elements.Line = Line;
    elements.Point = Point;
    elements.Rectangle = Rectangle;
    var resolve$1 = helpers$1.options.resolve;

    core_defaults._set('bar', {
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }],
        yAxes: [{
          type: 'linear'
        }]
      }
    });
    /**
     * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
     * @private
     */


    function computeMinSampleSize(scale, pixels) {
      var min = scale.isHorizontal() ? scale.width : scale.height;
      var ticks = scale.getTicks();
      var prev, curr, i, ilen;

      for (i = 1, ilen = pixels.length; i < ilen; ++i) {
        min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
      }

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        curr = scale.getPixelForTick(i);
        min = i > 0 ? Math.min(min, curr - prev) : min;
        prev = curr;
      }

      return min;
    }
    /**
     * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
     * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
     * mode currently always generates bars equally sized (until we introduce scriptable options?).
     * @private
     */


    function computeFitCategoryTraits(index, ruler, options) {
      var thickness = options.barThickness;
      var count = ruler.stackCount;
      var curr = ruler.pixels[index];
      var size, ratio;

      if (helpers$1.isNullOrUndef(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
      } else {
        // When bar thickness is enforced, category and bar percentages are ignored.
        // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
        // and deprecate barPercentage since this value is ignored when thickness is absolute.
        size = thickness * count;
        ratio = 1;
      }

      return {
        chunk: size / count,
        ratio: ratio,
        start: curr - size / 2
      };
    }
    /**
     * Computes an "optimal" category that globally arranges bars side by side (no gap when
     * percentage options are 1), based on the previous and following categories. This mode
     * generates bars with different widths when data are not evenly spaced.
     * @private
     */


    function computeFlexCategoryTraits(index, ruler, options) {
      var pixels = ruler.pixels;
      var curr = pixels[index];
      var prev = index > 0 ? pixels[index - 1] : null;
      var next = index < pixels.length - 1 ? pixels[index + 1] : null;
      var percent = options.categoryPercentage;
      var start, size;

      if (prev === null) {
        // first data: its size is double based on the next point or,
        // if it's also the last data, we use the scale size.
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
      }

      if (next === null) {
        // last data: its size is also double based on the previous point.
        next = curr + curr - prev;
      }

      start = curr - (curr - Math.min(prev, next)) / 2 * percent;
      size = Math.abs(next - prev) / 2 * percent;
      return {
        chunk: size / ruler.stackCount,
        ratio: options.barPercentage,
        start: start
      };
    }

    var controller_bar = core_datasetController.extend({
      dataElementType: elements.Rectangle,
      initialize: function () {
        var me = this;
        var meta;
        core_datasetController.prototype.initialize.apply(me, arguments);
        meta = me.getMeta();
        meta.stack = me.getDataset().stack;
        meta.bar = true;
      },
      update: function (reset) {
        var me = this;
        var rects = me.getMeta().data;
        var i, ilen;
        me._ruler = me.getRuler();

        for (i = 0, ilen = rects.length; i < ilen; ++i) {
          me.updateElement(rects[i], i, reset);
        }
      },
      updateElement: function (rectangle, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        var options = me._resolveElementOptions(rectangle, index);

        rectangle._xScale = me.getScaleForId(meta.xAxisID);
        rectangle._yScale = me.getScaleForId(meta.yAxisID);
        rectangle._datasetIndex = me.index;
        rectangle._index = index;
        rectangle._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderSkipped: options.borderSkipped,
          borderWidth: options.borderWidth,
          datasetLabel: dataset.label,
          label: me.chart.data.labels[index]
        };

        me._updateElementGeometry(rectangle, index, reset);

        rectangle.pivot();
      },

      /**
       * @private
       */
      _updateElementGeometry: function (rectangle, index, reset) {
        var me = this;
        var model = rectangle._model;

        var vscale = me._getValueScale();

        var base = vscale.getBasePixel();
        var horizontal = vscale.isHorizontal();
        var ruler = me._ruler || me.getRuler();
        var vpixels = me.calculateBarValuePixels(me.index, index);
        var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
        model.horizontal = horizontal;
        model.base = reset ? base : vpixels.base;
        model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
        model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
        model.height = horizontal ? ipixels.size : undefined;
        model.width = horizontal ? undefined : ipixels.size;
      },

      /**
       * Returns the stacks based on groups and bar visibility.
       * @param {number} [last] - The dataset index
       * @returns {string[]} The list of stack IDs
       * @private
       */
      _getStacks: function (last) {
        var me = this;
        var chart = me.chart;

        var scale = me._getIndexScale();

        var stacked = scale.options.stacked;
        var ilen = last === undefined ? chart.data.datasets.length : last + 1;
        var stacks = [];
        var i, meta;

        for (i = 0; i < ilen; ++i) {
          meta = chart.getDatasetMeta(i);

          if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
            stacks.push(meta.stack);
          }
        }

        return stacks;
      },

      /**
       * Returns the effective number of stacks based on groups and bar visibility.
       * @private
       */
      getStackCount: function () {
        return this._getStacks().length;
      },

      /**
       * Returns the stack index for the given dataset based on groups and bar visibility.
       * @param {number} [datasetIndex] - The dataset index
       * @param {string} [name] - The stack name to find
       * @returns {number} The stack index
       * @private
       */
      getStackIndex: function (datasetIndex, name) {
        var stacks = this._getStacks(datasetIndex);

        var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present

        return index === -1 ? stacks.length - 1 : index;
      },

      /**
       * @private
       */
      getRuler: function () {
        var me = this;

        var scale = me._getIndexScale();

        var stackCount = me.getStackCount();
        var datasetIndex = me.index;
        var isHorizontal = scale.isHorizontal();
        var start = isHorizontal ? scale.left : scale.top;
        var end = start + (isHorizontal ? scale.width : scale.height);
        var pixels = [];
        var i, ilen, min;

        for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
          pixels.push(scale.getPixelForValue(null, i, datasetIndex));
        }

        min = helpers$1.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;
        return {
          min: min,
          pixels: pixels,
          start: start,
          end: end,
          stackCount: stackCount,
          scale: scale
        };
      },

      /**
       * Note: pixel values are not clamped to the scale area.
       * @private
       */
      calculateBarValuePixels: function (datasetIndex, index) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();

        var scale = me._getValueScale();

        var isHorizontal = scale.isHorizontal();
        var datasets = chart.data.datasets;
        var value = +scale.getRightValue(datasets[datasetIndex].data[index]);
        var minBarLength = scale.options.minBarLength;
        var stacked = scale.options.stacked;
        var stack = meta.stack;
        var start = 0;
        var i, imeta, ivalue, base, head, size;

        if (stacked || stacked === undefined && stack !== undefined) {
          for (i = 0; i < datasetIndex; ++i) {
            imeta = chart.getDatasetMeta(i);

            if (imeta.bar && imeta.stack === stack && imeta.controller._getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {
              ivalue = +scale.getRightValue(datasets[i].data[index]);

              if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
                start += ivalue;
              }
            }
          }
        }

        base = scale.getPixelForValue(start);
        head = scale.getPixelForValue(start + value);
        size = head - base;

        if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
          size = minBarLength;

          if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {
            head = base - minBarLength;
          } else {
            head = base + minBarLength;
          }
        }

        return {
          size: size,
          base: base,
          head: head,
          center: head + size / 2
        };
      },

      /**
       * @private
       */
      calculateBarIndexPixels: function (datasetIndex, index, ruler) {
        var me = this;
        var options = ruler.scale.options;
        var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
        var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
        var center = range.start + range.chunk * stackIndex + range.chunk / 2;
        var size = Math.min(helpers$1.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);
        return {
          base: center - size / 2,
          head: center + size / 2,
          center: center,
          size: size
        };
      },
      draw: function () {
        var me = this;
        var chart = me.chart;

        var scale = me._getValueScale();

        var rects = me.getMeta().data;
        var dataset = me.getDataset();
        var ilen = rects.length;
        var i = 0;
        helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);

        for (; i < ilen; ++i) {
          if (!isNaN(scale.getRightValue(dataset.data[i]))) {
            rects[i].draw();
          }
        }

        helpers$1.canvas.unclipArea(chart.ctx);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (rectangle, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = rectangle.custom || {};
        var options = chart.options.elements.rectangle;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$1([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      }
    });
    var valueOrDefault$3 = helpers$1.valueOrDefault;
    var resolve$2 = helpers$1.options.resolve;

    core_defaults._set('bubble', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          // bubble should probably use a linear scale by default
          position: 'bottom',
          id: 'x-axis-0' // need an ID so datasets can reference the scale

        }],
        yAxes: [{
          type: 'linear',
          position: 'left',
          id: 'y-axis-0'
        }]
      },
      tooltips: {
        callbacks: {
          title: function () {
            // Title doesn't make sense for scatter since we format the data as a point
            return '';
          },
          label: function (item, data) {
            var datasetLabel = data.datasets[item.datasetIndex].label || '';
            var dataPoint = data.datasets[item.datasetIndex].data[item.index];
            return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
          }
        }
      }
    });

    var controller_bubble = core_datasetController.extend({
      /**
       * @protected
       */
      dataElementType: elements.Point,

      /**
       * @protected
       */
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var points = meta.data; // Update Points

        helpers$1.each(points, function (point, index) {
          me.updateElement(point, index, reset);
        });
      },

      /**
       * @protected
       */
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var xScale = me.getScaleForId(meta.xAxisID);
        var yScale = me.getScaleForId(meta.yAxisID);

        var options = me._resolveElementOptions(point, index);

        var data = me.getDataset().data[index];
        var dsIndex = me.index;
        var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
        var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = dsIndex;
        point._index = index;
        point._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          hitRadius: options.hitRadius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          radius: reset ? 0 : options.radius,
          skip: custom.skip || isNaN(x) || isNaN(y),
          x: x,
          y: y
        };
        point.pivot();
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$3(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$3(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$3(options.hoverBorderWidth, options.borderWidth);
        model.radius = options.radius + options.hoverRadius;
      },

      /**
       * @private
       */
      _resolveElementOptions: function (point, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = point.custom || {};
        var options = chart.options.elements.point;
        var data = dataset.data[index];
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$2([custom[key], dataset[key], options[key]], context, index);
        } // Custom radius resolution


        values.radius = resolve$2([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);
        return values;
      }
    });
    var resolve$3 = helpers$1.options.resolve;
    var valueOrDefault$4 = helpers$1.valueOrDefault;

    core_defaults._set('doughnut', {
      animation: {
        // Boolean - Whether we animate the rotation of the Doughnut
        animateRotate: true,
        // Boolean - Whether we animate scaling the Doughnut from the centre
        animateScale: false
      },
      hover: {
        mode: 'single'
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc && arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$3([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$3([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$3([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i); // toggle visibility of index if exists

            if (meta.data[index]) {
              meta.data[index].hidden = !meta.data[index].hidden;
            }
          }

          chart.update();
        }
      },
      // The percentage of the chart that we cut out of the middle.
      cutoutPercentage: 50,
      // The rotation of the chart, where the first data arc begins.
      rotation: Math.PI * -0.5,
      // The total circumference of the chart.
      circumference: Math.PI * 2.0,
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (tooltipItem, data) {
            var dataLabel = data.labels[tooltipItem.index];
            var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

            if (helpers$1.isArray(dataLabel)) {
              // show value on first line of multiline label
              // need to clone because we are changing the value
              dataLabel = dataLabel.slice();
              dataLabel[0] += value;
            } else {
              dataLabel += value;
            }

            return dataLabel;
          }
        }
      }
    });

    var controller_doughnut = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
      getRingIndex: function (datasetIndex) {
        var ringIndex = 0;

        for (var j = 0; j < datasetIndex; ++j) {
          if (this.chart.isDatasetVisible(j)) {
            ++ringIndex;
          }
        }

        return ringIndex;
      },
      update: function (reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var availableWidth = chartArea.right - chartArea.left;
        var availableHeight = chartArea.bottom - chartArea.top;
        var minSize = Math.min(availableWidth, availableHeight);
        var offset = {
          x: 0,
          y: 0
        };
        var meta = me.getMeta();
        var arcs = meta.data;
        var cutoutPercentage = opts.cutoutPercentage;
        var circumference = opts.circumference;

        var chartWeight = me._getRingWeight(me.index);

        var i, ilen; // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc

        if (circumference < Math.PI * 2.0) {
          var startAngle = opts.rotation % (Math.PI * 2.0);
          startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
          var endAngle = startAngle + circumference;
          var start = {
            x: Math.cos(startAngle),
            y: Math.sin(startAngle)
          };
          var end = {
            x: Math.cos(endAngle),
            y: Math.sin(endAngle)
          };
          var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
          var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
          var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
          var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
          var cutout = cutoutPercentage / 100.0;
          var min = {
            x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
            y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
          };
          var max = {
            x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
            y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
          };
          var size = {
            width: (max.x - min.x) * 0.5,
            height: (max.y - min.y) * 0.5
          };
          minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
          offset = {
            x: (max.x + min.x) * -0.5,
            y: (max.y + min.y) * -0.5
          };
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
        }

        chart.borderWidth = me.getMaxBorderWidth();
        chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
        chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
        chart.offsetX = offset.x * chart.outerRadius;
        chart.offsetY = offset.y * chart.outerRadius;
        meta.total = me.calculateTotal();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
        me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          me.updateElement(arcs[i], i, reset);
        }
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var animationOpts = opts.animation;
        var centerX = (chartArea.left + chartArea.right) / 2;
        var centerY = (chartArea.top + chartArea.bottom) / 2;
        var startAngle = opts.rotation; // non reset case handled later

        var endAngle = opts.rotation; // non reset case handled later

        var dataset = me.getDataset();
        var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
        var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
        var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX + chart.offsetX,
            y: centerY + chart.offsetY,
            startAngle: startAngle,
            endAngle: endAngle,
            circumference: circumference,
            outerRadius: outerRadius,
            innerRadius: innerRadius,
            label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
          }
        });
        var model = arc._model; // Set correct angles if not resetting

        if (!reset || !animationOpts.animateRotate) {
          if (index === 0) {
            model.startAngle = opts.rotation;
          } else {
            model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
          }

          model.endAngle = model.startAngle + model.circumference;
        }

        arc.pivot();
      },
      calculateTotal: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var total = 0;
        var value;
        helpers$1.each(meta.data, function (element, index) {
          value = dataset.data[index];

          if (!isNaN(value) && !element.hidden) {
            total += Math.abs(value);
          }
        });
        /* if (total === 0) {
        	total = NaN;
        }*/

        return total;
      },
      calculateCircumference: function (value) {
        var total = this.getMeta().total;

        if (total > 0 && !isNaN(value)) {
          return Math.PI * 2.0 * (Math.abs(value) / total);
        }

        return 0;
      },
      // gets the max border or hover width to properly scale pie charts
      getMaxBorderWidth: function (arcs) {
        var me = this;
        var max = 0;
        var chart = me.chart;
        var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;

        if (!arcs) {
          // Find the outmost visible dataset
          for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              meta = chart.getDatasetMeta(i);
              arcs = meta.data;

              if (i !== me.index) {
                controller = meta.controller;
              }

              break;
            }
          }
        }

        if (!arcs) {
          return 0;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arc = arcs[i];
          options = controller ? controller._resolveElementOptions(arc, i) : arc._options;

          if (options.borderAlign !== 'inner') {
            borderWidth = options.borderWidth;
            hoverWidth = options.hoverBorderWidth;
            max = borderWidth > max ? borderWidth : max;
            max = hoverWidth > max ? hoverWidth : max;
          }
        }

        return max;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$3([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
       * @private
       */
      _getRingWeightOffset: function (datasetIndex) {
        var ringWeightOffset = 0;

        for (var i = 0; i < datasetIndex; ++i) {
          if (this.chart.isDatasetVisible(i)) {
            ringWeightOffset += this._getRingWeight(i);
          }
        }

        return ringWeightOffset;
      },

      /**
       * @private
       */
      _getRingWeight: function (dataSetIndex) {
        return Math.max(valueOrDefault$4(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
      },

      /**
       * Returns the sum of all visibile data set weights.  This value can be 0.
       * @private
       */
      _getVisibleDatasetWeightTotal: function () {
        return this._getRingWeightOffset(this.chart.data.datasets.length);
      }
    });

    core_defaults._set('horizontalBar', {
      hover: {
        mode: 'index',
        axis: 'y'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          position: 'bottom'
        }],
        yAxes: [{
          type: 'category',
          position: 'left',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }]
      },
      elements: {
        rectangle: {
          borderSkipped: 'left'
        }
      },
      tooltips: {
        mode: 'index',
        axis: 'y'
      }
    });

    var controller_horizontalBar = controller_bar.extend({
      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().yAxisID;
      }
    });
    var valueOrDefault$5 = helpers$1.valueOrDefault;
    var resolve$4 = helpers$1.options.resolve;
    var isPointInArea = helpers$1.canvas._isPointInArea;

    core_defaults._set('line', {
      showLines: true,
      spanGaps: false,
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          id: 'x-axis-0'
        }],
        yAxes: [{
          type: 'linear',
          id: 'y-axis-0'
        }]
      }
    });

    function lineEnabled(dataset, options) {
      return valueOrDefault$5(dataset.showLine, options.showLines);
    }

    var controller_line = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.getScaleForId(meta.yAxisID);
        var dataset = me.getDataset();
        var showLine = lineEnabled(dataset, me.chart.options);
        var i, ilen; // Update Line

        if (showLine) {
          // Compatibility: If the properties are defined with only the old name, use those values
          if (dataset.tension !== undefined && dataset.lineTension === undefined) {
            dataset.lineTension = dataset.tension;
          } // Utility


          line._scale = scale;
          line._datasetIndex = me.index; // Data

          line._children = points; // Model

          line._model = me._resolveLineOptions(line);
          line.pivot();
        } // Update Points


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        }

        if (showLine && line._model.tension !== 0) {
          me.updateBezierControlPoints();
        } // Now pivot the point for animation


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var datasetIndex = me.index;
        var value = dataset.data[index];
        var yScale = me.getScaleForId(meta.yAxisID);
        var xScale = me.getScaleForId(meta.xAxisID);
        var lineModel = meta.dataset._model;
        var x, y;

        var options = me._resolvePointOptions(point, index);

        x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
        y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility

        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = datasetIndex;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$5(custom.tension, lineModel ? lineModel.tension : 0),
          steppedLine: lineModel ? lineModel.steppedLine : false,
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options;
        var elementOptions = options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill', 'cubicInterpolationMode'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[key], elementOptions[key]]);
        } // The default behavior of lines is to break at null values, according
        // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
        // This option gives lines the ability to span gaps


        values.spanGaps = valueOrDefault$5(dataset.spanGaps, options.spanGaps);
        values.tension = valueOrDefault$5(dataset.lineTension, elementOptions.tension);
        values.steppedLine = resolve$4([custom.steppedLine, dataset.steppedLine, elementOptions.stepped]);
        return values;
      },
      calculatePointY: function (value, index, datasetIndex) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var yScale = me.getScaleForId(meta.yAxisID);
        var sumPos = 0;
        var sumNeg = 0;
        var i, ds, dsMeta;

        if (yScale.options.stacked) {
          for (i = 0; i < datasetIndex; i++) {
            ds = chart.data.datasets[i];
            dsMeta = chart.getDatasetMeta(i);

            if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
              var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));

              if (stackedRightValue < 0) {
                sumNeg += stackedRightValue || 0;
              } else {
                sumPos += stackedRightValue || 0;
              }
            }
          }

          var rightValue = Number(yScale.getRightValue(value));

          if (rightValue < 0) {
            return yScale.getPixelForValue(sumNeg + rightValue);
          }

          return yScale.getPixelForValue(sumPos + rightValue);
        }

        return yScale.getPixelForValue(value);
      },
      updateBezierControlPoints: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var lineModel = meta.dataset._model;
        var area = chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

        if (lineModel.spanGaps) {
          points = points.filter(function (pt) {
            return !pt._model.skip;
          });
        }

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        if (lineModel.cubicInterpolationMode === 'monotone') {
          helpers$1.splineCurveMonotone(points);
        } else {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;
            controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
            model.controlPointPreviousX = controlPoints.previous.x;
            model.controlPointPreviousY = controlPoints.previous.y;
            model.controlPointNextX = controlPoints.next.x;
            model.controlPointNextY = controlPoints.next.y;
          }
        }

        if (chart.options.elements.line.capBezierPoints) {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;

            if (isPointInArea(model, area)) {
              if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
              }

              if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
              }
            }
          }
        }
      },
      draw: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var points = meta.data || [];
        var area = chart.chartArea;
        var ilen = points.length;
        var halfBorderWidth;
        var i = 0;

        if (lineEnabled(me.getDataset(), chart.options)) {
          halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;
          helpers$1.canvas.clipArea(chart.ctx, {
            left: area.left,
            right: area.right,
            top: area.top - halfBorderWidth,
            bottom: area.bottom + halfBorderWidth
          });
          meta.dataset.draw();
          helpers$1.canvas.unclipArea(chart.ctx);
        } // Draw the points


        for (; i < ilen; ++i) {
          points[i].draw(area);
        }
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$5(options.hoverRadius, options.radius);
      }
    });
    var resolve$5 = helpers$1.options.resolve;

    core_defaults._set('polarArea', {
      scale: {
        type: 'radialLinear',
        angleLines: {
          display: false
        },
        gridLines: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        ticks: {
          beginAtZero: true
        }
      },
      // Boolean - Whether to animate the rotation of the chart
      animation: {
        animateRotate: true,
        animateScale: true
      },
      startAngle: -0.5 * Math.PI,
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$5([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$5([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$5([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i);
            meta.data[index].hidden = !meta.data[index].hidden;
          }

          chart.update();
        }
      },
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (item, data) {
            return data.labels[item.index] + ': ' + item.yLabel;
          }
        }
      }
    });

    var controller_polarArea = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var dataset = me.getDataset();
        var meta = me.getMeta();
        var start = me.chart.options.startAngle || 0;
        var starts = me._starts = [];
        var angles = me._angles = [];
        var arcs = meta.data;
        var i, ilen, angle;

        me._updateRadius();

        meta.count = me.countVisibleElements();

        for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
          starts[i] = start;
          angle = me._computeAngle(i);
          angles[i] = angle;
          start += angle;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
          me.updateElement(arcs[i], i, reset);
        }
      },

      /**
       * @private
       */
      _updateRadius: function () {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        chart.outerRadius = Math.max(minSize / 2, 0);
        chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
        me.innerRadius = me.outerRadius - chart.radiusLength;
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var opts = chart.options;
        var animationOpts = opts.animation;
        var scale = chart.scale;
        var labels = chart.data.labels;
        var centerX = scale.xCenter;
        var centerY = scale.yCenter; // var negHalfPI = -0.5 * Math.PI;

        var datasetStartAngle = opts.startAngle;
        var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var startAngle = me._starts[index];
        var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
        var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          _scale: scale,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX,
            y: centerY,
            innerRadius: 0,
            outerRadius: reset ? resetRadius : distance,
            startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
            endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
            label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
          }
        });
        arc.pivot();
      },
      countVisibleElements: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var count = 0;
        helpers$1.each(meta.data, function (element, index) {
          if (!isNaN(dataset.data[index]) && !element.hidden) {
            count++;
          }
        });
        return count;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        var valueOrDefault = helpers$1.valueOrDefault;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$5([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _computeAngle: function (index) {
        var me = this;
        var count = this.getMeta().count;
        var dataset = me.getDataset();
        var meta = me.getMeta();

        if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
          return 0;
        } // Scriptable options


        var context = {
          chart: me.chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        return resolve$5([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);
      }
    });

    core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));

    core_defaults._set('pie', {
      cutoutPercentage: 0
    }); // Pie charts are Doughnut chart with different defaults


    var controller_pie = controller_doughnut;
    var valueOrDefault$6 = helpers$1.valueOrDefault;
    var resolve$6 = helpers$1.options.resolve;

    core_defaults._set('radar', {
      scale: {
        type: 'radialLinear'
      },
      elements: {
        line: {
          tension: 0 // no bezier in radar

        }
      }
    });

    var controller_radar = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.chart.scale;
        var dataset = me.getDataset();
        var i, ilen; // Compatibility: If the properties are defined with only the old name, use those values

        if (dataset.tension !== undefined && dataset.lineTension === undefined) {
          dataset.lineTension = dataset.tension;
        } // Utility


        line._scale = scale;
        line._datasetIndex = me.index; // Data

        line._children = points;
        line._loop = true; // Model

        line._model = me._resolveLineOptions(line);
        line.pivot(); // Update Points

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        } // Update bezier control points


        me.updateBezierControlPoints(); // Now pivot the point for animation

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var scale = me.chart.scale;
        var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

        var options = me._resolvePointOptions(point, index);

        var lineModel = me.getMeta().dataset._model;

        var x = reset ? scale.xCenter : pointPosition.x;
        var y = reset ? scale.yCenter : pointPosition.y; // Utility

        point._scale = scale;
        point._options = options;
        point._datasetIndex = me.index;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          // value not used in dataset scale, but we want a consistent API between scales
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[key], options[key]]);
        }

        values.tension = valueOrDefault$6(dataset.lineTension, options.tension);
        return values;
      },
      updateBezierControlPoints: function () {
        var me = this;
        var meta = me.getMeta();
        var area = me.chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints;

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;
          controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph

          model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
          model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
          model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
          model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
        }
      },
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
      }
    });

    core_defaults._set('scatter', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          id: 'x-axis-1',
          // need an ID so datasets can reference the scale
          type: 'linear',
          // scatter should not use a category axis
          position: 'bottom'
        }],
        yAxes: [{
          id: 'y-axis-1',
          type: 'linear',
          position: 'left'
        }]
      },
      showLines: false,
      tooltips: {
        callbacks: {
          title: function () {
            return ''; // doesn't make sense for scatter since data are formatted as a point
          },
          label: function (item) {
            return '(' + item.xLabel + ', ' + item.yLabel + ')';
          }
        }
      }
    }); // Scatter charts use line controllers


    var controller_scatter = controller_line; // NOTE export a map in which the key represents the controller type, not
    // the class, and so must be CamelCase in order to be correctly retrieved
    // by the controller in core.controller.js (`controllers[meta.type]`).

    var controllers = {
      bar: controller_bar,
      bubble: controller_bubble,
      doughnut: controller_doughnut,
      horizontalBar: controller_horizontalBar,
      line: controller_line,
      polarArea: controller_polarArea,
      pie: controller_pie,
      radar: controller_radar,
      scatter: controller_scatter
    };
    /**
     * Helper function to get relative position for an event
     * @param {Event|IEvent} event - The event to get the position for
     * @param {Chart} chart - The chart
     * @returns {object} the event position
     */

    function getRelativePosition(e, chart) {
      if (e.native) {
        return {
          x: e.x,
          y: e.y
        };
      }

      return helpers$1.getRelativePosition(e, chart);
    }
    /**
     * Helper function to traverse all of the visible elements in the chart
     * @param {Chart} chart - the chart
     * @param {function} handler - the callback to execute for each visible item
     */


    function parseVisibleItems(chart, handler) {
      var datasets = chart.data.datasets;
      var meta, i, j, ilen, jlen;

      for (i = 0, ilen = datasets.length; i < ilen; ++i) {
        if (!chart.isDatasetVisible(i)) {
          continue;
        }

        meta = chart.getDatasetMeta(i);

        for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
          var element = meta.data[j];

          if (!element._view.skip) {
            handler(element);
          }
        }
      }
    }
    /**
     * Helper function to get the items that intersect the event position
     * @param {ChartElement[]} items - elements to filter
     * @param {object} position - the point to be nearest to
     * @return {ChartElement[]} the nearest items
     */


    function getIntersectItems(chart, position) {
      var elements = [];
      parseVisibleItems(chart, function (element) {
        if (element.inRange(position.x, position.y)) {
          elements.push(element);
        }
      });
      return elements;
    }
    /**
     * Helper function to get the items nearest to the event position considering all visible items in teh chart
     * @param {Chart} chart - the chart to look at elements from
     * @param {object} position - the point to be nearest to
     * @param {boolean} intersect - if true, only consider items that intersect the position
     * @param {function} distanceMetric - function to provide the distance between points
     * @return {ChartElement[]} the nearest items
     */


    function getNearestItems(chart, position, intersect, distanceMetric) {
      var minDistance = Number.POSITIVE_INFINITY;
      var nearestItems = [];
      parseVisibleItems(chart, function (element) {
        if (intersect && !element.inRange(position.x, position.y)) {
          return;
        }

        var center = element.getCenterPoint();
        var distance = distanceMetric(position, center);

        if (distance < minDistance) {
          nearestItems = [element];
          minDistance = distance;
        } else if (distance === minDistance) {
          // Can have multiple items at the same distance in which case we sort by size
          nearestItems.push(element);
        }
      });
      return nearestItems;
    }
    /**
     * Get a distance metric function for two points based on the
     * axis mode setting
     * @param {string} axis - the axis mode. x|y|xy
     */


    function getDistanceMetricForAxis(axis) {
      var useX = axis.indexOf('x') !== -1;
      var useY = axis.indexOf('y') !== -1;
      return function (pt1, pt2) {
        var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }

    function indexMode(chart, e, options) {
      var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour

      options.axis = options.axis || 'x';
      var distanceMetric = getDistanceMetricForAxis(options.axis);
      var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
      var elements = [];

      if (!items.length) {
        return [];
      }

      chart.data.datasets.forEach(function (dataset, datasetIndex) {
        if (chart.isDatasetVisible(datasetIndex)) {
          var meta = chart.getDatasetMeta(datasetIndex);
          var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)

          if (element && !element._view.skip) {
            elements.push(element);
          }
        }
      });
      return elements;
    }
    /**
     * @interface IInteractionOptions
     */

    /**
     * If true, only consider items that intersect the point
     * @name IInterfaceOptions#boolean
     * @type Boolean
     */

    /**
     * Contains interaction related functions
     * @namespace Chart.Interaction
     */


    var core_interaction = {
      // Helper function for different modes
      modes: {
        single: function (chart, e) {
          var position = getRelativePosition(e, chart);
          var elements = [];
          parseVisibleItems(chart, function (element) {
            if (element.inRange(position.x, position.y)) {
              elements.push(element);
              return elements;
            }
          });
          return elements.slice(0, 1);
        },

        /**
         * @function Chart.Interaction.modes.label
         * @deprecated since version 2.4.0
         * @todo remove at version 3
         * @private
         */
        label: indexMode,

        /**
         * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
         * @function Chart.Interaction.modes.index
         * @since v2.4.0
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        index: indexMode,

        /**
         * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect is false, we find the nearest item and return the items in that dataset
         * @function Chart.Interaction.modes.dataset
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        dataset: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

          if (items.length > 0) {
            items = chart.getDatasetMeta(items[0]._datasetIndex).data;
          }

          return items;
        },

        /**
         * @function Chart.Interaction.modes.x-axis
         * @deprecated since version 2.4.0. Use index mode and intersect == true
         * @todo remove at version 3
         * @private
         */
        'x-axis': function (chart, e) {
          return indexMode(chart, e, {
            intersect: false
          });
        },

        /**
         * Point mode returns all elements that hit test based on the event position
         * of the event
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        point: function (chart, e) {
          var position = getRelativePosition(e, chart);
          return getIntersectItems(chart, position);
        },

        /**
         * nearest mode returns the element closest to the point
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        nearest: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          return getNearestItems(chart, position, options.intersect, distanceMetric);
        },

        /**
         * x mode returns the elements that hit-test at the current x coordinate
         * @function Chart.Interaction.modes.x
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        x: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inXRange(position.x)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        },

        /**
         * y mode returns the elements that hit-test at the current y coordinate
         * @function Chart.Interaction.modes.y
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        y: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inYRange(position.y)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        }
      }
    };

    function filterByPosition(array, position) {
      return helpers$1.where(array, function (v) {
        return v.position === position;
      });
    }

    function sortByWeight(array, reverse) {
      array.forEach(function (v, i) {
        v._tmpIndex_ = i;
        return v;
      });
      array.sort(function (a, b) {
        var v0 = reverse ? b : a;
        var v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
      });
      array.forEach(function (v) {
        delete v._tmpIndex_;
      });
    }

    function findMaxPadding(boxes) {
      var top = 0;
      var left = 0;
      var bottom = 0;
      var right = 0;
      helpers$1.each(boxes, function (box) {
        if (box.getPadding) {
          var boxPadding = box.getPadding();
          top = Math.max(top, boxPadding.top);
          left = Math.max(left, boxPadding.left);
          bottom = Math.max(bottom, boxPadding.bottom);
          right = Math.max(right, boxPadding.right);
        }
      });
      return {
        top: top,
        left: left,
        bottom: bottom,
        right: right
      };
    }

    function addSizeByPosition(boxes, size) {
      helpers$1.each(boxes, function (box) {
        size[box.position] += box.isHorizontal() ? box.height : box.width;
      });
    }

    core_defaults._set('global', {
      layout: {
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      }
    });
    /**
     * @interface ILayoutItem
     * @prop {string} position - The position of the item in the chart layout. Possible values are
     * 'left', 'top', 'right', 'bottom', and 'chartArea'
     * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area
     * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
     * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
     * @prop {function} update - Takes two parameters: width and height. Returns size of item
     * @prop {function} getPadding -  Returns an object with padding on the edges
     * @prop {number} width - Width of item. Must be valid after update()
     * @prop {number} height - Height of item. Must be valid after update()
     * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update
     * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update
     * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update
     * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
     */
    // The layout service is very self explanatory.  It's responsible for the layout within a chart.
    // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
    // It is this service's responsibility of carrying out that layout.


    var core_layouts = {
      defaults: {},

      /**
       * Register a box to a chart.
       * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
       * @param {Chart} chart - the chart to use
       * @param {ILayoutItem} item - the item to add to be layed out
       */
      addBox: function (chart, item) {
        if (!chart.boxes) {
          chart.boxes = [];
        } // initialize item with default values


        item.fullWidth = item.fullWidth || false;
        item.position = item.position || 'top';
        item.weight = item.weight || 0;
        chart.boxes.push(item);
      },

      /**
       * Remove a layoutItem from a chart
       * @param {Chart} chart - the chart to remove the box from
       * @param {ILayoutItem} layoutItem - the item to remove from the layout
       */
      removeBox: function (chart, layoutItem) {
        var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;

        if (index !== -1) {
          chart.boxes.splice(index, 1);
        }
      },

      /**
       * Sets (or updates) options on the given `item`.
       * @param {Chart} chart - the chart in which the item lives (or will be added to)
       * @param {ILayoutItem} item - the item to configure with the given options
       * @param {object} options - the new item options.
       */
      configure: function (chart, item, options) {
        var props = ['fullWidth', 'position', 'weight'];
        var ilen = props.length;
        var i = 0;
        var prop;

        for (; i < ilen; ++i) {
          prop = props[i];

          if (options.hasOwnProperty(prop)) {
            item[prop] = options[prop];
          }
        }
      },

      /**
       * Fits boxes of the given chart into the given size by having each box measure itself
       * then running a fitting algorithm
       * @param {Chart} chart - the chart
       * @param {number} width - the width to fit into
       * @param {number} height - the height to fit into
       */
      update: function (chart, width, height) {
        if (!chart) {
          return;
        }

        var layoutOptions = chart.options.layout || {};
        var padding = helpers$1.options.toPadding(layoutOptions.padding);
        var leftPadding = padding.left;
        var rightPadding = padding.right;
        var topPadding = padding.top;
        var bottomPadding = padding.bottom;
        var leftBoxes = filterByPosition(chart.boxes, 'left');
        var rightBoxes = filterByPosition(chart.boxes, 'right');
        var topBoxes = filterByPosition(chart.boxes, 'top');
        var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
        var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea'); // Sort boxes by weight. A higher weight is further away from the chart area

        sortByWeight(leftBoxes, true);
        sortByWeight(rightBoxes, false);
        sortByWeight(topBoxes, true);
        sortByWeight(bottomBoxes, false);
        var verticalBoxes = leftBoxes.concat(rightBoxes);
        var horizontalBoxes = topBoxes.concat(bottomBoxes);
        var outerBoxes = verticalBoxes.concat(horizontalBoxes); // Essentially we now have any number of boxes on each of the 4 sides.
        // Our canvas looks like the following.
        // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
        // B1 is the bottom axis
        // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
        // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
        // an error will be thrown.
        //
        // |----------------------------------------------------|
        // |                  T1 (Full Width)                   |
        // |----------------------------------------------------|
        // |    |    |                 T2                  |    |
        // |    |----|-------------------------------------|----|
        // |    |    | C1 |                           | C2 |    |
        // |    |    |----|                           |----|    |
        // |    |    |                                     |    |
        // | L1 | L2 |           ChartArea (C0)            | R1 |
        // |    |    |                                     |    |
        // |    |    |----|                           |----|    |
        // |    |    | C3 |                           | C4 |    |
        // |    |----|-------------------------------------|----|
        // |    |    |                 B1                  |    |
        // |----------------------------------------------------|
        // |                  B2 (Full Width)                   |
        // |----------------------------------------------------|
        //
        // What we do to find the best sizing, we do the following
        // 1. Determine the minimum size of the chart area.
        // 2. Split the remaining width equally between each vertical axis
        // 3. Split the remaining height equally between each horizontal axis
        // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
        // 5. Adjust the sizes of each axis based on it's minimum reported size.
        // 6. Refit each axis
        // 7. Position each axis in the final location
        // 8. Tell the chart the final location of the chart area
        // 9. Tell any axes that overlay the chart area the positions of the chart area
        // Step 1

        var chartWidth = width - leftPadding - rightPadding;
        var chartHeight = height - topPadding - bottomPadding;
        var chartAreaWidth = chartWidth / 2; // min 50%
        // Step 2

        var verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length; // Step 3
        // TODO re-limit horizontal axis height (this limit has affected only padding calculation since PR 1837)
        // var horizontalBoxHeight = (height - chartAreaHeight) / horizontalBoxes.length;
        // Step 4

        var maxChartAreaWidth = chartWidth;
        var maxChartAreaHeight = chartHeight;
        var outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        var minBoxSizes = [];
        var maxPadding;

        function getMinimumBoxSize(box) {
          var minSize;
          var isHorizontal = box.isHorizontal();

          if (isHorizontal) {
            minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);
            maxChartAreaHeight -= minSize.height;
          } else {
            minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
            maxChartAreaWidth -= minSize.width;
          }

          minBoxSizes.push({
            horizontal: isHorizontal,
            width: minSize.width,
            box: box
          });
        }

        helpers$1.each(outerBoxes, getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)

        maxPadding = findMaxPadding(outerBoxes); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
        // be if the axes are drawn at their minimum sizes.
        // Steps 5 & 6
        // Function to fit a box

        function fitBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minBox) {
            return minBox.box === box;
          });

          if (minBoxSize) {
            if (minBoxSize.horizontal) {
              var scaleMargin = {
                left: Math.max(outerBoxSizes.left, maxPadding.left),
                right: Math.max(outerBoxSizes.right, maxPadding.right),
                top: 0,
                bottom: 0
              }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
              // on the margin. Sometimes they need to increase in size slightly

              box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
            } else {
              box.update(minBoxSize.width, maxChartAreaHeight);
            }
          }
        } // Update, and calculate the left and right margins for the horizontal boxes


        helpers$1.each(verticalBoxes, fitBox);
        addSizeByPosition(verticalBoxes, outerBoxSizes); // Set the Left and Right margins for the horizontal boxes

        helpers$1.each(horizontalBoxes, fitBox);
        addSizeByPosition(horizontalBoxes, outerBoxSizes);

        function finalFitVerticalBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minSize) {
            return minSize.box === box;
          });
          var scaleMargin = {
            left: 0,
            right: 0,
            top: outerBoxSizes.top,
            bottom: outerBoxSizes.bottom
          };

          if (minBoxSize) {
            box.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);
          }
        } // Let the left layout know the final margin


        helpers$1.each(verticalBoxes, finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)

        outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        addSizeByPosition(outerBoxes, outerBoxSizes); // We may be adding some padding to account for rotated x axis labels

        var leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);
        outerBoxSizes.left += leftPaddingAddition;
        outerBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);
        var topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);
        outerBoxSizes.top += topPaddingAddition;
        outerBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation
        // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
        // without calling `fit` again

        var newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;
        var newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;

        if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
          helpers$1.each(verticalBoxes, function (box) {
            box.height = newMaxChartAreaHeight;
          });
          helpers$1.each(horizontalBoxes, function (box) {
            if (!box.fullWidth) {
              box.width = newMaxChartAreaWidth;
            }
          });
          maxChartAreaHeight = newMaxChartAreaHeight;
          maxChartAreaWidth = newMaxChartAreaWidth;
        } // Step 7 - Position the boxes


        var left = leftPadding + leftPaddingAddition;
        var top = topPadding + topPaddingAddition;

        function placeBox(box) {
          if (box.isHorizontal()) {
            box.left = box.fullWidth ? leftPadding : outerBoxSizes.left;
            box.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;
            box.top = top;
            box.bottom = top + box.height; // Move to next point

            top = box.bottom;
          } else {
            box.left = left;
            box.right = left + box.width;
            box.top = outerBoxSizes.top;
            box.bottom = outerBoxSizes.top + maxChartAreaHeight; // Move to next point

            left = box.right;
          }
        }

        helpers$1.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height

        left += maxChartAreaWidth;
        top += maxChartAreaHeight;
        helpers$1.each(rightBoxes, placeBox);
        helpers$1.each(bottomBoxes, placeBox); // Step 8

        chart.chartArea = {
          left: outerBoxSizes.left,
          top: outerBoxSizes.top,
          right: outerBoxSizes.left + maxChartAreaWidth,
          bottom: outerBoxSizes.top + maxChartAreaHeight
        }; // Step 9

        helpers$1.each(chartAreaBoxes, function (box) {
          box.left = chart.chartArea.left;
          box.top = chart.chartArea.top;
          box.right = chart.chartArea.right;
          box.bottom = chart.chartArea.bottom;
          box.update(maxChartAreaWidth, maxChartAreaHeight);
        });
      }
    };
    /**
     * Platform fallback implementation (minimal).
     * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
     */

    var platform_basic = {
      acquireContext: function (item) {
        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        }

        return item && item.getContext('2d') || null;
      }
    };
    var platform_dom = "/*\n * DOM element rendering detection\n * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index: -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth: 1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop: 0;\n}\n";
    var platform_dom$1 =
    /*#__PURE__*/
    Object.freeze({
      default: platform_dom
    });

    function getCjsExportFromNamespace(n) {
      return n && n.default || n;
    }

    var stylesheet = getCjsExportFromNamespace(platform_dom$1);
    var EXPANDO_KEY = '$chartjs';
    var CSS_PREFIX = 'chartjs-';
    var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';
    var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
    var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
    var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
    /**
     * DOM event types -> Chart.js event types.
     * Note: only events with different types are mapped.
     * @see https://developer.mozilla.org/en-US/docs/Web/Events
     */

    var EVENT_TYPES = {
      touchstart: 'mousedown',
      touchmove: 'mousemove',
      touchend: 'mouseup',
      pointerenter: 'mouseenter',
      pointerdown: 'mousedown',
      pointermove: 'mousemove',
      pointerup: 'mouseup',
      pointerleave: 'mouseout',
      pointerout: 'mouseout'
    };
    /**
     * The "used" size is the final value of a dimension property after all calculations have
     * been performed. This method uses the computed style of `element` but returns undefined
     * if the computed style is not expressed in pixels. That can happen in some cases where
     * `element` has a size relative to its parent and this last one is not yet displayed,
     * for example because of `display: none` on a parent node.
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     * @returns {number} Size in pixels or undefined if unknown.
     */

    function readUsedSize(element, property) {
      var value = helpers$1.getStyle(element, property);
      var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? Number(matches[1]) : undefined;
    }
    /**
     * Initializes the canvas style and render size without modifying the canvas display size,
     * since responsiveness is handled by the controller.resize() method. The config is used
     * to determine the aspect ratio to apply in case no explicit height has been specified.
     */


    function initCanvas(canvas, config) {
      var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
      // returns null or '' if no explicit value has been set to the canvas attribute.

      var renderHeight = canvas.getAttribute('height');
      var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy

      canvas[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      }; // Force canvas to display as block to avoid extra space caused by inline
      // elements, which would interfere with the responsive resize process.
      // https://github.com/chartjs/Chart.js/issues/2538

      style.display = style.display || 'block';

      if (renderWidth === null || renderWidth === '') {
        var displayWidth = readUsedSize(canvas, 'width');

        if (displayWidth !== undefined) {
          canvas.width = displayWidth;
        }
      }

      if (renderHeight === null || renderHeight === '') {
        if (canvas.style.height === '') {
          // If no explicit render height and style height, let's apply the aspect ratio,
          // which one can be specified by the user but also by charts as default option
          // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
          canvas.height = canvas.width / (config.options.aspectRatio || 2);
        } else {
          var displayHeight = readUsedSize(canvas, 'height');

          if (displayWidth !== undefined) {
            canvas.height = displayHeight;
          }
        }
      }

      return canvas;
    }
    /**
     * Detects support for options object argument in addEventListener.
     * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
     * @private
     */


    var supportsEventListenerOptions = function () {
      var supports = false;

      try {
        var options = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line getter-return
          get: function () {
            supports = true;
          }
        });
        window.addEventListener('e', null, options);
      } catch (e) {// continue regardless of error
      }

      return supports;
    }(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
    // https://github.com/chartjs/Chart.js/issues/4287


    var eventListenerOptions = supportsEventListenerOptions ? {
      passive: true
    } : false;

    function addListener(node, type, listener) {
      node.addEventListener(type, listener, eventListenerOptions);
    }

    function removeListener(node, type, listener) {
      node.removeEventListener(type, listener, eventListenerOptions);
    }

    function createEvent(type, chart, x, y, nativeEvent) {
      return {
        type: type,
        chart: chart,
        native: nativeEvent || null,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
      };
    }

    function fromNativeEvent(event, chart) {
      var type = EVENT_TYPES[event.type] || event.type;
      var pos = helpers$1.getRelativePosition(event, chart);
      return createEvent(type, chart, pos.x, pos.y, event);
    }

    function throttled(fn, thisArg) {
      var ticking = false;
      var args = [];
      return function () {
        args = Array.prototype.slice.call(arguments);
        thisArg = thisArg || this;

        if (!ticking) {
          ticking = true;
          helpers$1.requestAnimFrame.call(window, function () {
            ticking = false;
            fn.apply(thisArg, args);
          });
        }
      };
    }

    function createDiv(cls) {
      var el = document.createElement('div');
      el.className = cls || '';
      return el;
    } // Implementation based on https://github.com/marcj/css-element-queries


    function createResizer(handler) {
      var maxSize = 1000000; // NOTE(SB) Don't use innerHTML because it could be considered unsafe.
      // https://github.com/chartjs/Chart.js/issues/5902

      var resizer = createDiv(CSS_SIZE_MONITOR);
      var expand = createDiv(CSS_SIZE_MONITOR + '-expand');
      var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');
      expand.appendChild(createDiv());
      shrink.appendChild(createDiv());
      resizer.appendChild(expand);
      resizer.appendChild(shrink);

      resizer._reset = function () {
        expand.scrollLeft = maxSize;
        expand.scrollTop = maxSize;
        shrink.scrollLeft = maxSize;
        shrink.scrollTop = maxSize;
      };

      var onScroll = function () {
        resizer._reset();

        handler();
      };

      addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
      addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
      return resizer;
    } // https://davidwalsh.name/detect-node-insertion


    function watchForRender(node, handler) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

      var proxy = expando.renderProxy = function (e) {
        if (e.animationName === CSS_RENDER_ANIMATION) {
          handler();
        }
      };

      helpers$1.each(ANIMATION_START_EVENTS, function (type) {
        addListener(node, type, proxy);
      }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
      // is removed then added back immediately (same animation frame?). Accessing the
      // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
      // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
      // https://github.com/chartjs/Chart.js/issues/4737

      expando.reflow = !!node.offsetParent;
      node.classList.add(CSS_RENDER_MONITOR);
    }

    function unwatchForRender(node) {
      var expando = node[EXPANDO_KEY] || {};
      var proxy = expando.renderProxy;

      if (proxy) {
        helpers$1.each(ANIMATION_START_EVENTS, function (type) {
          removeListener(node, type, proxy);
        });
        delete expando.renderProxy;
      }

      node.classList.remove(CSS_RENDER_MONITOR);
    }

    function addResizeListener(node, listener, chart) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.

      var resizer = expando.resizer = createResizer(throttled(function () {
        if (expando.resizer) {
          var container = chart.options.maintainAspectRatio && node.parentNode;
          var w = container ? container.clientWidth : 0;
          listener(createEvent('resize', chart));

          if (container && container.clientWidth < w && chart.canvas) {
            // If the container size shrank during chart resize, let's assume
            // scrollbar appeared. So we resize again with the scrollbar visible -
            // effectively making chart smaller and the scrollbar hidden again.
            // Because we are inside `throttled`, and currently `ticking`, scroll
            // events are ignored during this whole 2 resize process.
            // If we assumed wrong and something else happened, we are resizing
            // twice in a frame (potential performance issue)
            listener(createEvent('resize', chart));
          }
        }
      })); // The resizer needs to be attached to the node parent, so we first need to be
      // sure that `node` is attached to the DOM before injecting the resizer element.

      watchForRender(node, function () {
        if (expando.resizer) {
          var container = node.parentNode;

          if (container && container !== resizer.parentNode) {
            container.insertBefore(resizer, container.firstChild);
          } // The container size might have changed, let's reset the resizer state.


          resizer._reset();
        }
      });
    }

    function removeResizeListener(node) {
      var expando = node[EXPANDO_KEY] || {};
      var resizer = expando.resizer;
      delete expando.resizer;
      unwatchForRender(node);

      if (resizer && resizer.parentNode) {
        resizer.parentNode.removeChild(resizer);
      }
    }

    function injectCSS(platform, css) {
      // https://stackoverflow.com/q/3922139
      var style = platform._style || document.createElement('style');

      if (!platform._style) {
        platform._style = style;
        css = '/* Chart.js */\n' + css;
        style.setAttribute('type', 'text/css');
        document.getElementsByTagName('head')[0].appendChild(style);
      }

      style.appendChild(document.createTextNode(css));
    }

    var platform_dom$2 = {
      /**
       * When `true`, prevents the automatic injection of the stylesheet required to
       * correctly detect when the chart is added to the DOM and then resized. This
       * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
       * to be manually imported to make this library compatible with any CSP.
       * See https://github.com/chartjs/Chart.js/issues/5208
       */
      disableCSSInjection: false,

      /**
       * This property holds whether this platform is enabled for the current environment.
       * Currently used by platform.js to select the proper implementation.
       * @private
       */
      _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

      /**
       * @private
       */
      _ensureLoaded: function () {
        if (this._loaded) {
          return;
        }

        this._loaded = true; // https://github.com/chartjs/Chart.js/issues/5208

        if (!this.disableCSSInjection) {
          injectCSS(this, stylesheet);
        }
      },
      acquireContext: function (item, config) {
        if (typeof item === 'string') {
          item = document.getElementById(item);
        } else if (item.length) {
          // Support for array based queries (such as jQuery)
          item = item[0];
        }

        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        } // To prevent canvas fingerprinting, some add-ons undefine the getContext
        // method, for example: https://github.com/kkapsner/CanvasBlocker
        // https://github.com/chartjs/Chart.js/issues/2807


        var context = item && item.getContext && item.getContext('2d'); // Load platform resources on first chart creation, to make possible to change
        // platform options after importing the library (e.g. `disableCSSInjection`).

        this._ensureLoaded(); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
        // inside an iframe or when running in a protected environment. We could guess the
        // types from their toString() value but let's keep things flexible and assume it's
        // a sufficient condition if the item has a context2D which has item as `canvas`.
        // https://github.com/chartjs/Chart.js/issues/3887
        // https://github.com/chartjs/Chart.js/issues/4102
        // https://github.com/chartjs/Chart.js/issues/4152


        if (context && context.canvas === item) {
          initCanvas(item, config);
          return context;
        }

        return null;
      },
      releaseContext: function (context) {
        var canvas = context.canvas;

        if (!canvas[EXPANDO_KEY]) {
          return;
        }

        var initial = canvas[EXPANDO_KEY].initial;
        ['height', 'width'].forEach(function (prop) {
          var value = initial[prop];

          if (helpers$1.isNullOrUndef(value)) {
            canvas.removeAttribute(prop);
          } else {
            canvas.setAttribute(prop, value);
          }
        });
        helpers$1.each(initial.style || {}, function (value, key) {
          canvas.style[key] = value;
        }); // The canvas render size might have been changed (and thus the state stack discarded),
        // we can't use save() and restore() to restore the initial state. So make sure that at
        // least the canvas context is reset to the default state by setting the canvas width.
        // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
        // eslint-disable-next-line no-self-assign

        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
      },
      addEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          addResizeListener(canvas, listener, chart);
          return;
        }

        var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
        var proxies = expando.proxies || (expando.proxies = {});

        var proxy = proxies[chart.id + '_' + type] = function (event) {
          listener(fromNativeEvent(event, chart));
        };

        addListener(canvas, type, proxy);
      },
      removeEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          removeResizeListener(canvas);
          return;
        }

        var expando = listener[EXPANDO_KEY] || {};
        var proxies = expando.proxies || {};
        var proxy = proxies[chart.id + '_' + type];

        if (!proxy) {
          return;
        }

        removeListener(canvas, type, proxy);
      }
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use EventTarget.addEventListener instead.
     * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     * @function Chart.helpers.addEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.addEvent = addListener;
    /**
     * Provided for backward compatibility, use EventTarget.removeEventListener instead.
     * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
     * @function Chart.helpers.removeEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.removeEvent = removeListener; // @TODO Make possible to select another platform at build time.

    var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
    /**
     * @namespace Chart.platform
     * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
     * @since 2.4.0
     */

    var platform = helpers$1.extend({
      /**
       * @since 2.7.0
       */
      initialize: function () {},

      /**
       * Called at chart construction time, returns a context2d instance implementing
       * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
       * @param {*} item - The native item from which to acquire context (platform specific)
       * @param {object} options - The chart options
       * @returns {CanvasRenderingContext2D} context2d instance
       */
      acquireContext: function () {},

      /**
       * Called at chart destruction time, releases any resources associated to the context
       * previously returned by the acquireContext() method.
       * @param {CanvasRenderingContext2D} context - The context2d instance
       * @returns {boolean} true if the method succeeded, else false
       */
      releaseContext: function () {},

      /**
       * Registers the specified listener on the given chart.
       * @param {Chart} chart - Chart from which to listen for event
       * @param {string} type - The ({@link IEvent}) type to listen for
       * @param {function} listener - Receives a notification (an object that implements
       * the {@link IEvent} interface) when an event of the specified type occurs.
       */
      addEventListener: function () {},

      /**
       * Removes the specified listener previously registered with addEventListener.
       * @param {Chart} chart - Chart from which to remove the listener
       * @param {string} type - The ({@link IEvent}) type to remove
       * @param {function} listener - The listener function to remove from the event target.
       */
      removeEventListener: function () {}
    }, implementation);

    core_defaults._set('global', {
      plugins: {}
    });
    /**
     * The plugin service singleton
     * @namespace Chart.plugins
     * @since 2.1.0
     */


    var core_plugins = {
      /**
       * Globally registered plugins.
       * @private
       */
      _plugins: [],

      /**
       * This identifier is used to invalidate the descriptors cache attached to each chart
       * when a global plugin is registered or unregistered. In this case, the cache ID is
       * incremented and descriptors are regenerated during following API calls.
       * @private
       */
      _cacheId: 0,

      /**
       * Registers the given plugin(s) if not already registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      register: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          if (p.indexOf(plugin) === -1) {
            p.push(plugin);
          }
        });
        this._cacheId++;
      },

      /**
       * Unregisters the given plugin(s) only if registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      unregister: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          var idx = p.indexOf(plugin);

          if (idx !== -1) {
            p.splice(idx, 1);
          }
        });
        this._cacheId++;
      },

      /**
       * Remove all registered plugins.
       * @since 2.1.5
       */
      clear: function () {
        this._plugins = [];
        this._cacheId++;
      },

      /**
       * Returns the number of registered plugins?
       * @returns {number}
       * @since 2.1.5
       */
      count: function () {
        return this._plugins.length;
      },

      /**
       * Returns all registered plugin instances.
       * @returns {IPlugin[]} array of plugin objects.
       * @since 2.1.5
       */
      getAll: function () {
        return this._plugins;
      },

      /**
       * Calls enabled plugins for `chart` on the specified hook and with the given args.
       * This method immediately returns as soon as a plugin explicitly returns false. The
       * returned value can be used, for instance, to interrupt the current action.
       * @param {Chart} chart - The chart instance for which plugins should be called.
       * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
       * @param {Array} [args] - Extra arguments to apply to the hook call.
       * @returns {boolean} false if any of the plugins return false, else returns true.
       */
      notify: function (chart, hook, args) {
        var descriptors = this.descriptors(chart);
        var ilen = descriptors.length;
        var i, descriptor, plugin, params, method;

        for (i = 0; i < ilen; ++i) {
          descriptor = descriptors[i];
          plugin = descriptor.plugin;
          method = plugin[hook];

          if (typeof method === 'function') {
            params = [chart].concat(args || []);
            params.push(descriptor.options);

            if (method.apply(plugin, params) === false) {
              return false;
            }
          }
        }

        return true;
      },

      /**
       * Returns descriptors of enabled plugins for the given chart.
       * @returns {object[]} [{ plugin, options }]
       * @private
       */
      descriptors: function (chart) {
        var cache = chart.$plugins || (chart.$plugins = {});

        if (cache.id === this._cacheId) {
          return cache.descriptors;
        }

        var plugins = [];
        var descriptors = [];
        var config = chart && chart.config || {};
        var options = config.options && config.options.plugins || {};

        this._plugins.concat(config.plugins || []).forEach(function (plugin) {
          var idx = plugins.indexOf(plugin);

          if (idx !== -1) {
            return;
          }

          var id = plugin.id;
          var opts = options[id];

          if (opts === false) {
            return;
          }

          if (opts === true) {
            opts = helpers$1.clone(core_defaults.global.plugins[id]);
          }

          plugins.push(plugin);
          descriptors.push({
            plugin: plugin,
            options: opts || {}
          });
        });

        cache.descriptors = descriptors;
        cache.id = this._cacheId;
        return descriptors;
      },

      /**
       * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
       * but in some cases, this reference can be changed by the user when updating options.
       * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
       * @private
       */
      _invalidate: function (chart) {
        delete chart.$plugins;
      }
    };
    var core_scaleService = {
      // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
      // use the new chart options to grab the correct scale
      constructors: {},
      // Use a registration function so that we can move to an ES6 map when we no longer need to support
      // old browsers
      // Scale config defaults
      defaults: {},
      registerScaleType: function (type, scaleConstructor, scaleDefaults) {
        this.constructors[type] = scaleConstructor;
        this.defaults[type] = helpers$1.clone(scaleDefaults);
      },
      getScaleConstructor: function (type) {
        return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
      },
      getScaleDefaults: function (type) {
        // Return the scale defaults merged with the global settings so that we always use the latest ones
        return this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};
      },
      updateScaleDefaults: function (type, additions) {
        var me = this;

        if (me.defaults.hasOwnProperty(type)) {
          me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
        }
      },
      addScalesToLayout: function (chart) {
        // Adds each scale to the chart.boxes array to be sized accordingly
        helpers$1.each(chart.scales, function (scale) {
          // Set ILayoutItem parameters for backwards compatibility
          scale.fullWidth = scale.options.fullWidth;
          scale.position = scale.options.position;
          scale.weight = scale.options.weight;
          core_layouts.addBox(chart, scale);
        });
      }
    };
    var valueOrDefault$7 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      tooltips: {
        enabled: true,
        custom: null,
        mode: 'nearest',
        position: 'average',
        intersect: true,
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleFontStyle: 'bold',
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleFontColor: '#fff',
        titleAlign: 'left',
        bodySpacing: 2,
        bodyFontColor: '#fff',
        bodyAlign: 'left',
        footerFontStyle: 'bold',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFontColor: '#fff',
        footerAlign: 'left',
        yPadding: 6,
        xPadding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        multiKeyBackground: '#fff',
        displayColors: true,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        callbacks: {
          // Args are: (tooltipItems, data)
          beforeTitle: helpers$1.noop,
          title: function (tooltipItems, data) {
            var title = '';
            var labels = data.labels;
            var labelCount = labels ? labels.length : 0;

            if (tooltipItems.length > 0) {
              var item = tooltipItems[0];

              if (item.label) {
                title = item.label;
              } else if (item.xLabel) {
                title = item.xLabel;
              } else if (labelCount > 0 && item.index < labelCount) {
                title = labels[item.index];
              }
            }

            return title;
          },
          afterTitle: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeBody: helpers$1.noop,
          // Args are: (tooltipItem, data)
          beforeLabel: helpers$1.noop,
          label: function (tooltipItem, data) {
            var label = data.datasets[tooltipItem.datasetIndex].label || '';

            if (label) {
              label += ': ';
            }

            if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
              label += tooltipItem.value;
            } else {
              label += tooltipItem.yLabel;
            }

            return label;
          },
          labelColor: function (tooltipItem, chart) {
            var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
            var activeElement = meta.data[tooltipItem.index];
            var view = activeElement._view;
            return {
              borderColor: view.borderColor,
              backgroundColor: view.backgroundColor
            };
          },
          labelTextColor: function () {
            return this._options.bodyFontColor;
          },
          afterLabel: helpers$1.noop,
          // Args are: (tooltipItems, data)
          afterBody: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeFooter: helpers$1.noop,
          footer: helpers$1.noop,
          afterFooter: helpers$1.noop
        }
      }
    });

    var positioners = {
      /**
       * Average mode places the tooltip at the average position of the elements shown
       * @function Chart.Tooltip.positioners.average
       * @param elements {ChartElement[]} the elements being displayed in the tooltip
       * @returns {object} tooltip position
       */
      average: function (elements) {
        if (!elements.length) {
          return false;
        }

        var i, len;
        var x = 0;
        var y = 0;
        var count = 0;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var pos = el.tooltipPosition();
            x += pos.x;
            y += pos.y;
            ++count;
          }
        }

        return {
          x: x / count,
          y: y / count
        };
      },

      /**
       * Gets the tooltip position nearest of the item nearest to the event position
       * @function Chart.Tooltip.positioners.nearest
       * @param elements {Chart.Element[]} the tooltip elements
       * @param eventPosition {object} the position of the event in canvas coordinates
       * @returns {object} the tooltip position
       */
      nearest: function (elements, eventPosition) {
        var x = eventPosition.x;
        var y = eventPosition.y;
        var minDistance = Number.POSITIVE_INFINITY;
        var i, len, nearestElement;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var center = el.getCenterPoint();
            var d = helpers$1.distanceBetweenPoints(eventPosition, center);

            if (d < minDistance) {
              minDistance = d;
              nearestElement = el;
            }
          }
        }

        if (nearestElement) {
          var tp = nearestElement.tooltipPosition();
          x = tp.x;
          y = tp.y;
        }

        return {
          x: x,
          y: y
        };
      }
    }; // Helper to push or concat based on if the 2nd parameter is an array or not

    function pushOrConcat(base, toPush) {
      if (toPush) {
        if (helpers$1.isArray(toPush)) {
          // base = base.concat(toPush);
          Array.prototype.push.apply(base, toPush);
        } else {
          base.push(toPush);
        }
      }

      return base;
    }
    /**
     * Returns array of strings split by newline
     * @param {string} value - The value to split by newline.
     * @returns {string[]} value if newline present - Returned from String split() method
     * @function
     */


    function splitNewlines(str) {
      if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
        return str.split('\n');
      }

      return str;
    }
    /**
     * Private helper to create a tooltip item model
     * @param element - the chart element (point, arc, bar) to create the tooltip item for
     * @return new tooltip item
     */


    function createTooltipItem(element) {
      var xScale = element._xScale;
      var yScale = element._yScale || element._scale; // handle radar || polarArea charts

      var index = element._index;
      var datasetIndex = element._datasetIndex;

      var controller = element._chart.getDatasetMeta(datasetIndex).controller;

      var indexScale = controller._getIndexScale();

      var valueScale = controller._getValueScale();

      return {
        xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
        yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
        label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',
        value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',
        index: index,
        datasetIndex: datasetIndex,
        x: element._model.x,
        y: element._model.y
      };
    }
    /**
     * Helper to get the reset model for the tooltip
     * @param tooltipOpts {object} the tooltip options
     */


    function getBaseModel(tooltipOpts) {
      var globalDefaults = core_defaults.global;
      return {
        // Positioning
        xPadding: tooltipOpts.xPadding,
        yPadding: tooltipOpts.yPadding,
        xAlign: tooltipOpts.xAlign,
        yAlign: tooltipOpts.yAlign,
        // Body
        bodyFontColor: tooltipOpts.bodyFontColor,
        _bodyFontFamily: valueOrDefault$7(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
        _bodyFontStyle: valueOrDefault$7(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
        _bodyAlign: tooltipOpts.bodyAlign,
        bodyFontSize: valueOrDefault$7(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
        bodySpacing: tooltipOpts.bodySpacing,
        // Title
        titleFontColor: tooltipOpts.titleFontColor,
        _titleFontFamily: valueOrDefault$7(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
        _titleFontStyle: valueOrDefault$7(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
        titleFontSize: valueOrDefault$7(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
        _titleAlign: tooltipOpts.titleAlign,
        titleSpacing: tooltipOpts.titleSpacing,
        titleMarginBottom: tooltipOpts.titleMarginBottom,
        // Footer
        footerFontColor: tooltipOpts.footerFontColor,
        _footerFontFamily: valueOrDefault$7(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
        _footerFontStyle: valueOrDefault$7(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
        footerFontSize: valueOrDefault$7(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
        _footerAlign: tooltipOpts.footerAlign,
        footerSpacing: tooltipOpts.footerSpacing,
        footerMarginTop: tooltipOpts.footerMarginTop,
        // Appearance
        caretSize: tooltipOpts.caretSize,
        cornerRadius: tooltipOpts.cornerRadius,
        backgroundColor: tooltipOpts.backgroundColor,
        opacity: 0,
        legendColorBackground: tooltipOpts.multiKeyBackground,
        displayColors: tooltipOpts.displayColors,
        borderColor: tooltipOpts.borderColor,
        borderWidth: tooltipOpts.borderWidth
      };
    }
    /**
     * Get the size of the tooltip
     */


    function getTooltipSize(tooltip, model) {
      var ctx = tooltip._chart.ctx;
      var height = model.yPadding * 2; // Tooltip Padding

      var width = 0; // Count of all lines in the body

      var body = model.body;
      var combinedBodyLength = body.reduce(function (count, bodyItem) {
        return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
      }, 0);
      combinedBodyLength += model.beforeBody.length + model.afterBody.length;
      var titleLineCount = model.title.length;
      var footerLineCount = model.footer.length;
      var titleFontSize = model.titleFontSize;
      var bodyFontSize = model.bodyFontSize;
      var footerFontSize = model.footerFontSize;
      height += titleLineCount * titleFontSize; // Title Lines

      height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing

      height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin

      height += combinedBodyLength * bodyFontSize; // Body Lines

      height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing

      height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin

      height += footerLineCount * footerFontSize; // Footer Lines

      height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
      // Title width

      var widthPadding = 0;

      var maxLineWidth = function (line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };

      ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
      helpers$1.each(model.title, maxLineWidth); // Body width

      ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
      helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box

      widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
      helpers$1.each(body, function (bodyItem) {
        helpers$1.each(bodyItem.before, maxLineWidth);
        helpers$1.each(bodyItem.lines, maxLineWidth);
        helpers$1.each(bodyItem.after, maxLineWidth);
      }); // Reset back to 0

      widthPadding = 0; // Footer width

      ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
      helpers$1.each(model.footer, maxLineWidth); // Add padding

      width += 2 * model.xPadding;
      return {
        width: width,
        height: height
      };
    }
    /**
     * Helper to get the alignment of a tooltip given the size
     */


    function determineAlignment(tooltip, size) {
      var model = tooltip._model;
      var chart = tooltip._chart;
      var chartArea = tooltip._chart.chartArea;
      var xAlign = 'center';
      var yAlign = 'center';

      if (model.y < size.height) {
        yAlign = 'top';
      } else if (model.y > chart.height - size.height) {
        yAlign = 'bottom';
      }

      var lf, rf; // functions to determine left, right alignment

      var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart

      var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges

      var midX = (chartArea.left + chartArea.right) / 2;
      var midY = (chartArea.top + chartArea.bottom) / 2;

      if (yAlign === 'center') {
        lf = function (x) {
          return x <= midX;
        };

        rf = function (x) {
          return x > midX;
        };
      } else {
        lf = function (x) {
          return x <= size.width / 2;
        };

        rf = function (x) {
          return x >= chart.width - size.width / 2;
        };
      }

      olf = function (x) {
        return x + size.width + model.caretSize + model.caretPadding > chart.width;
      };

      orf = function (x) {
        return x - size.width - model.caretSize - model.caretPadding < 0;
      };

      yf = function (y) {
        return y <= midY ? 'top' : 'bottom';
      };

      if (lf(model.x)) {
        xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?

        if (olf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      } else if (rf(model.x)) {
        xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?

        if (orf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      }

      var opts = tooltip._options;
      return {
        xAlign: opts.xAlign ? opts.xAlign : xAlign,
        yAlign: opts.yAlign ? opts.yAlign : yAlign
      };
    }
    /**
     * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
     */


    function getBackgroundPoint(vm, size, alignment, chart) {
      // Background Position
      var x = vm.x;
      var y = vm.y;
      var caretSize = vm.caretSize;
      var caretPadding = vm.caretPadding;
      var cornerRadius = vm.cornerRadius;
      var xAlign = alignment.xAlign;
      var yAlign = alignment.yAlign;
      var paddingAndSize = caretSize + caretPadding;
      var radiusAndPadding = cornerRadius + caretPadding;

      if (xAlign === 'right') {
        x -= size.width;
      } else if (xAlign === 'center') {
        x -= size.width / 2;

        if (x + size.width > chart.width) {
          x = chart.width - size.width;
        }

        if (x < 0) {
          x = 0;
        }
      }

      if (yAlign === 'top') {
        y += paddingAndSize;
      } else if (yAlign === 'bottom') {
        y -= size.height + paddingAndSize;
      } else {
        y -= size.height / 2;
      }

      if (yAlign === 'center') {
        if (xAlign === 'left') {
          x += paddingAndSize;
        } else if (xAlign === 'right') {
          x -= paddingAndSize;
        }
      } else if (xAlign === 'left') {
        x -= radiusAndPadding;
      } else if (xAlign === 'right') {
        x += radiusAndPadding;
      }

      return {
        x: x,
        y: y
      };
    }

    function getAlignedX(vm, align) {
      return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
    }
    /**
     * Helper to build before and after body lines
     */


    function getBeforeAfterBodyLines(callback) {
      return pushOrConcat([], splitNewlines(callback));
    }

    var exports$3 = core_element.extend({
      initialize: function () {
        this._model = getBaseModel(this._options);
        this._lastActive = [];
      },
      // Get the title
      // Args are: (tooltipItem, data)
      getTitle: function () {
        var me = this;
        var opts = me._options;
        var callbacks = opts.callbacks;
        var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
        var title = callbacks.title.apply(me, arguments);
        var afterTitle = callbacks.afterTitle.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
      },
      // Args are: (tooltipItem, data)
      getBeforeBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
      },
      // Args are: (tooltipItem, data)
      getBody: function (tooltipItems, data) {
        var me = this;
        var callbacks = me._options.callbacks;
        var bodyItems = [];
        helpers$1.each(tooltipItems, function (tooltipItem) {
          var bodyItem = {
            before: [],
            lines: [],
            after: []
          };
          pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
          pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
          pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
          bodyItems.push(bodyItem);
        });
        return bodyItems;
      },
      // Args are: (tooltipItem, data)
      getAfterBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
      },
      // Get the footer and beforeFooter and afterFooter lines
      // Args are: (tooltipItem, data)
      getFooter: function () {
        var me = this;
        var callbacks = me._options.callbacks;
        var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
        var footer = callbacks.footer.apply(me, arguments);
        var afterFooter = callbacks.afterFooter.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
      },
      update: function (changed) {
        var me = this;
        var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
        // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
        // which breaks any animations.

        var existingModel = me._model;
        var model = me._model = getBaseModel(opts);
        var active = me._active;
        var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations

        var alignment = {
          xAlign: existingModel.xAlign,
          yAlign: existingModel.yAlign
        };
        var backgroundPoint = {
          x: existingModel.x,
          y: existingModel.y
        };
        var tooltipSize = {
          width: existingModel.width,
          height: existingModel.height
        };
        var tooltipPosition = {
          x: existingModel.caretX,
          y: existingModel.caretY
        };
        var i, len;

        if (active.length) {
          model.opacity = 1;
          var labelColors = [];
          var labelTextColors = [];
          tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
          var tooltipItems = [];

          for (i = 0, len = active.length; i < len; ++i) {
            tooltipItems.push(createTooltipItem(active[i]));
          } // If the user provided a filter function, use it to modify the tooltip items


          if (opts.filter) {
            tooltipItems = tooltipItems.filter(function (a) {
              return opts.filter(a, data);
            });
          } // If the user provided a sorting function, use it to modify the tooltip items


          if (opts.itemSort) {
            tooltipItems = tooltipItems.sort(function (a, b) {
              return opts.itemSort(a, b, data);
            });
          } // Determine colors for boxes


          helpers$1.each(tooltipItems, function (tooltipItem) {
            labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
            labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
          }); // Build the Text Lines

          model.title = me.getTitle(tooltipItems, data);
          model.beforeBody = me.getBeforeBody(tooltipItems, data);
          model.body = me.getBody(tooltipItems, data);
          model.afterBody = me.getAfterBody(tooltipItems, data);
          model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors

          model.x = tooltipPosition.x;
          model.y = tooltipPosition.y;
          model.caretPadding = opts.caretPadding;
          model.labelColors = labelColors;
          model.labelTextColors = labelTextColors; // data points

          model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip

          tooltipSize = getTooltipSize(this, model);
          alignment = determineAlignment(this, tooltipSize); // Final Size and Position

          backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
        } else {
          model.opacity = 0;
        }

        model.xAlign = alignment.xAlign;
        model.yAlign = alignment.yAlign;
        model.x = backgroundPoint.x;
        model.y = backgroundPoint.y;
        model.width = tooltipSize.width;
        model.height = tooltipSize.height; // Point where the caret on the tooltip points to

        model.caretX = tooltipPosition.x;
        model.caretY = tooltipPosition.y;
        me._model = model;

        if (changed && opts.custom) {
          opts.custom.call(me, model);
        }

        return me;
      },
      drawCaret: function (tooltipPoint, size) {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
      },
      getCaretPosition: function (tooltipPoint, size, vm) {
        var x1, x2, x3, y1, y2, y3;
        var caretSize = vm.caretSize;
        var cornerRadius = vm.cornerRadius;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var ptX = tooltipPoint.x;
        var ptY = tooltipPoint.y;
        var width = size.width;
        var height = size.height;

        if (yAlign === 'center') {
          y2 = ptY + height / 2;

          if (xAlign === 'left') {
            x1 = ptX;
            x2 = x1 - caretSize;
            x3 = x1;
            y1 = y2 + caretSize;
            y3 = y2 - caretSize;
          } else {
            x1 = ptX + width;
            x2 = x1 + caretSize;
            x3 = x1;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize;
          }
        } else {
          if (xAlign === 'left') {
            x2 = ptX + cornerRadius + caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else if (xAlign === 'right') {
            x2 = ptX + width - cornerRadius - caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else {
            x2 = vm.caretX;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          }

          if (yAlign === 'top') {
            y1 = ptY;
            y2 = y1 - caretSize;
            y3 = y1;
          } else {
            y1 = ptY + height;
            y2 = y1 + caretSize;
            y3 = y1; // invert drawing order

            var tmp = x3;
            x3 = x1;
            x1 = tmp;
          }
        }

        return {
          x1: x1,
          x2: x2,
          x3: x3,
          y1: y1,
          y2: y2,
          y3: y3
        };
      },
      drawTitle: function (pt, vm, ctx) {
        var title = vm.title;

        if (title.length) {
          pt.x = getAlignedX(vm, vm._titleAlign);
          ctx.textAlign = vm._titleAlign;
          ctx.textBaseline = 'top';
          var titleFontSize = vm.titleFontSize;
          var titleSpacing = vm.titleSpacing;
          ctx.fillStyle = vm.titleFontColor;
          ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
          var i, len;

          for (i = 0, len = title.length; i < len; ++i) {
            ctx.fillText(title[i], pt.x, pt.y);
            pt.y += titleFontSize + titleSpacing; // Line Height and spacing

            if (i + 1 === title.length) {
              pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
            }
          }
        }
      },
      drawBody: function (pt, vm, ctx) {
        var bodyFontSize = vm.bodyFontSize;
        var bodySpacing = vm.bodySpacing;
        var bodyAlign = vm._bodyAlign;
        var body = vm.body;
        var drawColorBoxes = vm.displayColors;
        var labelColors = vm.labelColors;
        var xLinePadding = 0;
        var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;
        var textColor;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'top';
        ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
        pt.x = getAlignedX(vm, bodyAlign); // Before Body

        var fillLineOfText = function (line) {
          ctx.fillText(line, pt.x + xLinePadding, pt.y);
          pt.y += bodyFontSize + bodySpacing;
        }; // Before body lines


        ctx.fillStyle = vm.bodyFontColor;
        helpers$1.each(vm.beforeBody, fillLineOfText);
        xLinePadding = drawColorBoxes && bodyAlign !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0; // Draw body lines now

        helpers$1.each(body, function (bodyItem, i) {
          textColor = vm.labelTextColors[i];
          ctx.fillStyle = textColor;
          helpers$1.each(bodyItem.before, fillLineOfText);
          helpers$1.each(bodyItem.lines, function (line) {
            // Draw Legend-like boxes if needed
            if (drawColorBoxes) {
              // Fill a white rect so that colours merge nicely if the opacity is < 1
              ctx.fillStyle = vm.legendColorBackground;
              ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Border

              ctx.lineWidth = 1;
              ctx.strokeStyle = labelColors[i].borderColor;
              ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Inner square

              ctx.fillStyle = labelColors[i].backgroundColor;
              ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
              ctx.fillStyle = textColor;
            }

            fillLineOfText(line);
          });
          helpers$1.each(bodyItem.after, fillLineOfText);
        }); // Reset back to 0 for after body

        xLinePadding = 0; // After body lines

        helpers$1.each(vm.afterBody, fillLineOfText);
        pt.y -= bodySpacing; // Remove last body spacing
      },
      drawFooter: function (pt, vm, ctx) {
        var footer = vm.footer;

        if (footer.length) {
          pt.x = getAlignedX(vm, vm._footerAlign);
          pt.y += vm.footerMarginTop;
          ctx.textAlign = vm._footerAlign;
          ctx.textBaseline = 'top';
          ctx.fillStyle = vm.footerFontColor;
          ctx.font = helpers$1.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
          helpers$1.each(footer, function (line) {
            ctx.fillText(line, pt.x, pt.y);
            pt.y += vm.footerFontSize + vm.footerSpacing;
          });
        }
      },
      drawBackground: function (pt, vm, ctx, tooltipSize) {
        ctx.fillStyle = vm.backgroundColor;
        ctx.strokeStyle = vm.borderColor;
        ctx.lineWidth = vm.borderWidth;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var x = pt.x;
        var y = pt.y;
        var width = tooltipSize.width;
        var height = tooltipSize.height;
        var radius = vm.cornerRadius;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);

        if (yAlign === 'top') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);

        if (yAlign === 'center' && xAlign === 'right') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);

        if (yAlign === 'bottom') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);

        if (yAlign === 'center' && xAlign === 'left') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();

        if (vm.borderWidth > 0) {
          ctx.stroke();
        }
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;

        if (vm.opacity === 0) {
          return;
        }

        var tooltipSize = {
          width: vm.width,
          height: vm.height
        };
        var pt = {
          x: vm.x,
          y: vm.y
        }; // IE11/Edge does not like very small opacities, so snap to 0

        var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip

        var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

        if (this._options.enabled && hasTooltipContent) {
          ctx.save();
          ctx.globalAlpha = opacity; // Draw Background

          this.drawBackground(pt, vm, ctx, tooltipSize); // Draw Title, Body, and Footer

          pt.y += vm.yPadding; // Titles

          this.drawTitle(pt, vm, ctx); // Body

          this.drawBody(pt, vm, ctx); // Footer

          this.drawFooter(pt, vm, ctx);
          ctx.restore();
        }
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       * @returns {boolean} true if the tooltip changed
       */
      handleEvent: function (e) {
        var me = this;
        var options = me._options;
        var changed = false;
        me._lastActive = me._lastActive || []; // Find Active Elements for tooltips

        if (e.type === 'mouseout') {
          me._active = [];
        } else {
          me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
        } // Remember Last Actives


        changed = !helpers$1.arrayEquals(me._active, me._lastActive); // Only handle target event on tooltip change

        if (changed) {
          me._lastActive = me._active;

          if (options.enabled || options.custom) {
            me._eventPosition = {
              x: e.x,
              y: e.y
            };
            me.update(true);
            me.pivot();
          }
        }

        return changed;
      }
    });
    /**
     * @namespace Chart.Tooltip.positioners
     */

    var positioners_1 = positioners;
    var core_tooltip = exports$3;
    core_tooltip.positioners = positioners_1;
    var valueOrDefault$8 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      elements: {},
      events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
      hover: {
        onHover: null,
        mode: 'nearest',
        intersect: true,
        animationDuration: 400
      },
      onClick: null,
      maintainAspectRatio: true,
      responsive: true,
      responsiveAnimationDuration: 0
    });
    /**
     * Recursively merge the given config objects representing the `scales` option
     * by incorporating scale defaults in `xAxes` and `yAxes` array items, then
     * returns a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeScaleConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          if (key === 'xAxes' || key === 'yAxes') {
            var slen = source[key].length;
            var i, type, scale;

            if (!target[key]) {
              target[key] = [];
            }

            for (i = 0; i < slen; ++i) {
              scale = source[key][i];
              type = valueOrDefault$8(scale.type, key === 'xAxes' ? 'category' : 'linear');

              if (i >= target[key].length) {
                target[key].push({});
              }

              if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
                // new/untyped scale or type changed: let's apply the new defaults
                // then merge source scale to correctly overwrite the defaults.
                helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
              } else {
                // scales type are the same
                helpers$1.merge(target[key][i], scale);
              }
            }
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }
    /**
     * Recursively merge the given config objects as the root options by handling
     * default scale options for the `scales` and `scale` properties, then returns
     * a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          var tval = target[key] || {};
          var sval = source[key];

          if (key === 'scales') {
            // scale config merging is complex. Add our own function here for that
            target[key] = mergeScaleConfig(tval, sval);
          } else if (key === 'scale') {
            // used in polar area & radar charts since there is only one scale
            target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }

    function initConfig(config) {
      config = config || {}; // Do NOT use mergeConfig for the data object because this method merges arrays
      // and so would change references to labels and datasets, preventing data updates.

      var data = config.data = config.data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
      return config;
    }

    function updateConfig(chart) {
      var newOptions = chart.options;
      helpers$1.each(chart.scales, function (scale) {
        core_layouts.removeBox(chart, scale);
      });
      newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
      chart.options = chart.config.options = newOptions;
      chart.ensureScalesHaveIDs();
      chart.buildOrUpdateScales(); // Tooltip

      chart.tooltip._options = newOptions.tooltips;
      chart.tooltip.initialize();
    }

    function positionIsHorizontal(position) {
      return position === 'top' || position === 'bottom';
    }

    var Chart = function (item, config) {
      this.construct(item, config);
      return this;
    };

    helpers$1.extend(Chart.prototype,
    /** @lends Chart */
    {
      /**
       * @private
       */
      construct: function (item, config) {
        var me = this;
        config = initConfig(config);
        var context = platform.acquireContext(item, config);
        var canvas = context && context.canvas;
        var height = canvas && canvas.height;
        var width = canvas && canvas.width;
        me.id = helpers$1.uid();
        me.ctx = context;
        me.canvas = canvas;
        me.config = config;
        me.width = width;
        me.height = height;
        me.aspectRatio = height ? width / height : null;
        me.options = config.options;
        me._bufferedRender = false;
        /**
         * Provided for backward compatibility, Chart and Chart.Controller have been merged,
         * the "instance" still need to be defined since it might be called from plugins.
         * @prop Chart#chart
         * @deprecated since version 2.6.0
         * @todo remove at version 3
         * @private
         */

        me.chart = me;
        me.controller = me; // chart.chart.controller #inception
        // Add the chart instance to the global namespace

        Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`

        Object.defineProperty(me, 'data', {
          get: function () {
            return me.config.data;
          },
          set: function (value) {
            me.config.data = value;
          }
        });

        if (!context || !canvas) {
          // The given item is not a compatible context2d element, let's return before finalizing
          // the chart initialization but after setting basic chart / controller properties that
          // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
          // https://github.com/chartjs/Chart.js/issues/2807
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }

        me.initialize();
        me.update();
      },

      /**
       * @private
       */
      initialize: function () {
        var me = this; // Before init plugin notification

        core_plugins.notify(me, 'beforeInit');
        helpers$1.retinaScale(me, me.options.devicePixelRatio);
        me.bindEvents();

        if (me.options.responsive) {
          // Initial resize before chart draws (must be silent to preserve initial animations).
          me.resize(true);
        } // Make sure scales have IDs and are built before we build any controllers.


        me.ensureScalesHaveIDs();
        me.buildOrUpdateScales();
        me.initToolTip(); // After init plugin notification

        core_plugins.notify(me, 'afterInit');
        return me;
      },
      clear: function () {
        helpers$1.canvas.clear(this);
        return this;
      },
      stop: function () {
        // Stops any current animation loop occurring
        core_animations.cancelAnimation(this);
        return this;
      },
      resize: function (silent) {
        var me = this;
        var options = me.options;
        var canvas = me.canvas;
        var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that
        // the canvas display style uses the same integer values to avoid blurring effect.
        // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed

        var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
        var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));

        if (me.width === newWidth && me.height === newHeight) {
          return;
        }

        canvas.width = me.width = newWidth;
        canvas.height = me.height = newHeight;
        canvas.style.width = newWidth + 'px';
        canvas.style.height = newHeight + 'px';
        helpers$1.retinaScale(me, options.devicePixelRatio);

        if (!silent) {
          // Notify any plugins about the resize
          var newSize = {
            width: newWidth,
            height: newHeight
          };
          core_plugins.notify(me, 'resize', [newSize]); // Notify of resize

          if (options.onResize) {
            options.onResize(me, newSize);
          }

          me.stop();
          me.update({
            duration: options.responsiveAnimationDuration
          });
        }
      },
      ensureScalesHaveIDs: function () {
        var options = this.options;
        var scalesOptions = options.scales || {};
        var scaleOptions = options.scale;
        helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {
          xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
        });
        helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {
          yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
        });

        if (scaleOptions) {
          scaleOptions.id = scaleOptions.id || 'scale';
        }
      },

      /**
       * Builds a map of scale ID to scale object for future lookup.
       */
      buildOrUpdateScales: function () {
        var me = this;
        var options = me.options;
        var scales = me.scales || {};
        var items = [];
        var updated = Object.keys(scales).reduce(function (obj, id) {
          obj[id] = false;
          return obj;
        }, {});

        if (options.scales) {
          items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
            return {
              options: xAxisOptions,
              dtype: 'category',
              dposition: 'bottom'
            };
          }), (options.scales.yAxes || []).map(function (yAxisOptions) {
            return {
              options: yAxisOptions,
              dtype: 'linear',
              dposition: 'left'
            };
          }));
        }

        if (options.scale) {
          items.push({
            options: options.scale,
            dtype: 'radialLinear',
            isDefault: true,
            dposition: 'chartArea'
          });
        }

        helpers$1.each(items, function (item) {
          var scaleOptions = item.options;
          var id = scaleOptions.id;
          var scaleType = valueOrDefault$8(scaleOptions.type, item.dtype);

          if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
            scaleOptions.position = item.dposition;
          }

          updated[id] = true;
          var scale = null;

          if (id in scales && scales[id].type === scaleType) {
            scale = scales[id];
            scale.options = scaleOptions;
            scale.ctx = me.ctx;
            scale.chart = me;
          } else {
            var scaleClass = core_scaleService.getScaleConstructor(scaleType);

            if (!scaleClass) {
              return;
            }

            scale = new scaleClass({
              id: id,
              type: scaleType,
              options: scaleOptions,
              ctx: me.ctx,
              chart: me
            });
            scales[scale.id] = scale;
          }

          scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)
          // and consider it as a regular scale part of the "scales"" map only! This would
          // make the logic easier and remove some useless? custom code.

          if (item.isDefault) {
            me.scale = scale;
          }
        }); // clear up discarded scales

        helpers$1.each(updated, function (hasUpdated, id) {
          if (!hasUpdated) {
            delete scales[id];
          }
        });
        me.scales = scales;
        core_scaleService.addScalesToLayout(this);
      },
      buildOrUpdateControllers: function () {
        var me = this;
        var newControllers = [];
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          var meta = me.getDatasetMeta(datasetIndex);
          var type = dataset.type || me.config.type;

          if (meta.type && meta.type !== type) {
            me.destroyDatasetMeta(datasetIndex);
            meta = me.getDatasetMeta(datasetIndex);
          }

          meta.type = type;

          if (meta.controller) {
            meta.controller.updateIndex(datasetIndex);
            meta.controller.linkScales();
          } else {
            var ControllerClass = controllers[meta.type];

            if (ControllerClass === undefined) {
              throw new Error('"' + meta.type + '" is not a chart type.');
            }

            meta.controller = new ControllerClass(me, datasetIndex);
            newControllers.push(meta.controller);
          }
        }, me);
        return newControllers;
      },

      /**
       * Reset the elements of all datasets
       * @private
       */
      resetElements: function () {
        var me = this;
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.reset();
        }, me);
      },

      /**
      * Resets the chart back to it's state before the initial animation
      */
      reset: function () {
        this.resetElements();
        this.tooltip.initialize();
      },
      update: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        updateConfig(me); // plugins options references might have change, let's invalidate the cache
        // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167

        core_plugins._invalidate(me);

        if (core_plugins.notify(me, 'beforeUpdate') === false) {
          return;
        } // In case the entire data object changed


        me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset

        var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts

        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
        }, me);
        me.updateLayout(); // Can only reset the new controllers after the scales have been updated

        if (me.options.animation && me.options.animation.duration) {
          helpers$1.each(newControllers, function (controller) {
            controller.reset();
          });
        }

        me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed
        // after update.

        me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.
        // When we reset the tooltip, we need to clear it

        me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it

        core_plugins.notify(me, 'afterUpdate');

        if (me._bufferedRender) {
          me._bufferedRequest = {
            duration: config.duration,
            easing: config.easing,
            lazy: config.lazy
          };
        } else {
          me.render(config);
        }
      },

      /**
       * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
       * hook, in which case, plugins will not be called on `afterLayout`.
       * @private
       */
      updateLayout: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeLayout') === false) {
          return;
        }

        core_layouts.update(this, this.width, this.height);
        /**
         * Provided for backward compatibility, use `afterLayout` instead.
         * @method IPlugin#afterScaleUpdate
         * @deprecated since version 2.5.0
         * @todo remove at version 3
         * @private
         */

        core_plugins.notify(me, 'afterScaleUpdate');
        core_plugins.notify(me, 'afterLayout');
      },

      /**
       * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
       * @private
       */
      updateDatasets: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {
          return;
        }

        for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.updateDataset(i);
        }

        core_plugins.notify(me, 'afterDatasetsUpdate');
      },

      /**
       * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
       * @private
       */
      updateDataset: function (index) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index
        };

        if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
          return;
        }

        meta.controller.update();
        core_plugins.notify(me, 'afterDatasetUpdate', [args]);
      },
      render: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        var animationOptions = me.options.animation;
        var duration = valueOrDefault$8(config.duration, animationOptions && animationOptions.duration);
        var lazy = config.lazy;

        if (core_plugins.notify(me, 'beforeRender') === false) {
          return;
        }

        var onComplete = function (animation) {
          core_plugins.notify(me, 'afterRender');
          helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
        };

        if (animationOptions && duration) {
          var animation = new core_animation({
            numSteps: duration / 16.66,
            // 60 fps
            easing: config.easing || animationOptions.easing,
            render: function (chart, animationObject) {
              var easingFunction = helpers$1.easing.effects[animationObject.easing];
              var currentStep = animationObject.currentStep;
              var stepDecimal = currentStep / animationObject.numSteps;
              chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
            },
            onAnimationProgress: animationOptions.onProgress,
            onAnimationComplete: onComplete
          });
          core_animations.addAnimation(me, animation, duration, lazy);
        } else {
          me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781

          onComplete(new core_animation({
            numSteps: 0,
            chart: me
          }));
        }

        return me;
      },
      draw: function (easingValue) {
        var me = this;
        me.clear();

        if (helpers$1.isNullOrUndef(easingValue)) {
          easingValue = 1;
        }

        me.transition(easingValue);

        if (me.width <= 0 || me.height <= 0) {
          return;
        }

        if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
          return;
        } // Draw all the scales


        helpers$1.each(me.boxes, function (box) {
          box.draw(me.chartArea);
        }, me);
        me.drawDatasets(easingValue);

        me._drawTooltip(easingValue);

        core_plugins.notify(me, 'afterDraw', [easingValue]);
      },

      /**
       * @private
       */
      transition: function (easingValue) {
        var me = this;

        for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
          if (me.isDatasetVisible(i)) {
            me.getDatasetMeta(i).controller.transition(easingValue);
          }
        }

        me.tooltip.transition(easingValue);
      },

      /**
       * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
       * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
       * @private
       */
      drawDatasets: function (easingValue) {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
          return;
        } // Draw datasets reversed to support proper line stacking


        for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
          if (me.isDatasetVisible(i)) {
            me.drawDataset(i, easingValue);
          }
        }

        core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
      },

      /**
       * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
       * hook, in which case, plugins will not be called on `afterDatasetDraw`.
       * @private
       */
      drawDataset: function (index, easingValue) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
          return;
        }

        meta.controller.draw(easingValue);
        core_plugins.notify(me, 'afterDatasetDraw', [args]);
      },

      /**
       * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
       * hook, in which case, plugins will not be called on `afterTooltipDraw`.
       * @private
       */
      _drawTooltip: function (easingValue) {
        var me = this;
        var tooltip = me.tooltip;
        var args = {
          tooltip: tooltip,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
          return;
        }

        tooltip.draw();
        core_plugins.notify(me, 'afterTooltipDraw', [args]);
      },

      /**
       * Get the single element that was clicked on
       * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
       */
      getElementAtEvent: function (e) {
        return core_interaction.modes.single(this, e);
      },
      getElementsAtEvent: function (e) {
        return core_interaction.modes.label(this, e, {
          intersect: true
        });
      },
      getElementsAtXAxis: function (e) {
        return core_interaction.modes['x-axis'](this, e, {
          intersect: true
        });
      },
      getElementsAtEventForMode: function (e, mode, options) {
        var method = core_interaction.modes[mode];

        if (typeof method === 'function') {
          return method(this, e, options);
        }

        return [];
      },
      getDatasetAtEvent: function (e) {
        return core_interaction.modes.dataset(this, e, {
          intersect: true
        });
      },
      getDatasetMeta: function (datasetIndex) {
        var me = this;
        var dataset = me.data.datasets[datasetIndex];

        if (!dataset._meta) {
          dataset._meta = {};
        }

        var meta = dataset._meta[me.id];

        if (!meta) {
          meta = dataset._meta[me.id] = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            // See isDatasetVisible() comment
            xAxisID: null,
            yAxisID: null
          };
        }

        return meta;
      },
      getVisibleDatasetCount: function () {
        var count = 0;

        for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          if (this.isDatasetVisible(i)) {
            count++;
          }
        }

        return count;
      },
      isDatasetVisible: function (datasetIndex) {
        var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
        // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.

        return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
      },
      generateLegend: function () {
        return this.options.legendCallback(this);
      },

      /**
       * @private
       */
      destroyDatasetMeta: function (datasetIndex) {
        var id = this.id;
        var dataset = this.data.datasets[datasetIndex];
        var meta = dataset._meta && dataset._meta[id];

        if (meta) {
          meta.controller.destroy();
          delete dataset._meta[id];
        }
      },
      destroy: function () {
        var me = this;
        var canvas = me.canvas;
        var i, ilen;
        me.stop(); // dataset controllers need to cleanup associated data

        for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.destroyDatasetMeta(i);
        }

        if (canvas) {
          me.unbindEvents();
          helpers$1.canvas.clear(me);
          platform.releaseContext(me.ctx);
          me.canvas = null;
          me.ctx = null;
        }

        core_plugins.notify(me, 'destroy');
        delete Chart.instances[me.id];
      },
      toBase64Image: function () {
        return this.canvas.toDataURL.apply(this.canvas, arguments);
      },
      initToolTip: function () {
        var me = this;
        me.tooltip = new core_tooltip({
          _chart: me,
          _chartInstance: me,
          // deprecated, backward compatibility
          _data: me.data,
          _options: me.options.tooltips
        }, me);
      },

      /**
       * @private
       */
      bindEvents: function () {
        var me = this;
        var listeners = me._listeners = {};

        var listener = function () {
          me.eventHandler.apply(me, arguments);
        };

        helpers$1.each(me.options.events, function (type) {
          platform.addEventListener(me, type, listener);
          listeners[type] = listener;
        }); // Elements used to detect size change should not be injected for non responsive charts.
        // See https://github.com/chartjs/Chart.js/issues/2210

        if (me.options.responsive) {
          listener = function () {
            me.resize();
          };

          platform.addEventListener(me, 'resize', listener);
          listeners.resize = listener;
        }
      },

      /**
       * @private
       */
      unbindEvents: function () {
        var me = this;
        var listeners = me._listeners;

        if (!listeners) {
          return;
        }

        delete me._listeners;
        helpers$1.each(listeners, function (listener, type) {
          platform.removeEventListener(me, type, listener);
        });
      },
      updateHoverStyle: function (elements, mode, enabled) {
        var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
        var element, i, ilen;

        for (i = 0, ilen = elements.length; i < ilen; ++i) {
          element = elements[i];

          if (element) {
            this.getDatasetMeta(element._datasetIndex).controller[method](element);
          }
        }
      },

      /**
       * @private
       */
      eventHandler: function (e) {
        var me = this;
        var tooltip = me.tooltip;

        if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {
          return;
        } // Buffer any update calls so that renders do not occur


        me._bufferedRender = true;
        me._bufferedRequest = null;
        var changed = me.handleEvent(e); // for smooth tooltip animations issue #4989
        // the tooltip should be the source of change
        // Animation check workaround:
        // tooltip._start will be null when tooltip isn't animating

        if (tooltip) {
          changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
        }

        core_plugins.notify(me, 'afterEvent', [e]);
        var bufferedRequest = me._bufferedRequest;

        if (bufferedRequest) {
          // If we have an update that was triggered, we need to do a normal render
          me.render(bufferedRequest);
        } else if (changed && !me.animating) {
          // If entering, leaving, or changing elements, animate the change via pivot
          me.stop(); // We only need to render at this point. Updating will cause scales to be
          // recomputed generating flicker & using more memory than necessary.

          me.render({
            duration: me.options.hover.animationDuration,
            lazy: true
          });
        }

        me._bufferedRender = false;
        me._bufferedRequest = null;
        return me;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event the event to handle
       * @return {boolean} true if the chart needs to re-render
       */
      handleEvent: function (e) {
        var me = this;
        var options = me.options || {};
        var hoverOptions = options.hover;
        var changed = false;
        me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips

        if (e.type === 'mouseout') {
          me.active = [];
        } else {
          me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
        } // Invoke onHover hook
        // Need to call with native event here to not break backwards compatibility


        helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

        if (e.type === 'mouseup' || e.type === 'click') {
          if (options.onClick) {
            // Use e.native here for backwards compatibility
            options.onClick.call(me, e.native, me.active);
          }
        } // Remove styling for last active (even if it may still be active)


        if (me.lastActive.length) {
          me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
        } // Built in hover styling


        if (me.active.length && hoverOptions.mode) {
          me.updateHoverStyle(me.active, hoverOptions.mode, true);
        }

        changed = !helpers$1.arrayEquals(me.active, me.lastActive); // Remember Last Actives

        me.lastActive = me.active;
        return changed;
      }
    });
    /**
     * NOTE(SB) We actually don't use this container anymore but we need to keep it
     * for backward compatibility. Though, it can still be useful for plugins that
     * would need to work on multiple charts?!
     */

    Chart.instances = {};
    var core_controller = Chart; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart instead.
     * @class Chart.Controller
     * @deprecated since version 2.6
     * @todo remove at version 3
     * @private
     */

    Chart.Controller = Chart;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    Chart.types = {};
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.configMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.configMerge = mergeConfig;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.scaleMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.scaleMerge = mergeScaleConfig;

    var core_helpers = function () {
      // -- Basic js utility methods
      helpers$1.where = function (collection, filterCallback) {
        if (helpers$1.isArray(collection) && Array.prototype.filter) {
          return collection.filter(filterCallback);
        }

        var filtered = [];
        helpers$1.each(collection, function (item) {
          if (filterCallback(item)) {
            filtered.push(item);
          }
        });
        return filtered;
      };

      helpers$1.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
        return array.findIndex(callback, scope);
      } : function (array, callback, scope) {
        scope = scope === undefined ? array : scope;

        for (var i = 0, ilen = array.length; i < ilen; ++i) {
          if (callback.call(scope, array[i], i, array)) {
            return i;
          }
        }

        return -1;
      };

      helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to start of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = -1;
        }

        for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      };

      helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to end of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = arrayToSearch.length;
        }

        for (var i = startIndex - 1; i >= 0; i--) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      }; // -- Math methods


      helpers$1.isNumber = function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      };

      helpers$1.almostEquals = function (x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      };

      helpers$1.almostWhole = function (x, epsilon) {
        var rounded = Math.round(x);
        return rounded - epsilon < x && rounded + epsilon > x;
      };

      helpers$1.max = function (array) {
        return array.reduce(function (max, value) {
          if (!isNaN(value)) {
            return Math.max(max, value);
          }

          return max;
        }, Number.NEGATIVE_INFINITY);
      };

      helpers$1.min = function (array) {
        return array.reduce(function (min, value) {
          if (!isNaN(value)) {
            return Math.min(min, value);
          }

          return min;
        }, Number.POSITIVE_INFINITY);
      };

      helpers$1.sign = Math.sign ? function (x) {
        return Math.sign(x);
      } : function (x) {
        x = +x; // convert to a number

        if (x === 0 || isNaN(x)) {
          return x;
        }

        return x > 0 ? 1 : -1;
      };
      helpers$1.log10 = Math.log10 ? function (x) {
        return Math.log10(x);
      } : function (x) {
        var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
        // Check for whole powers of 10,
        // which due to floating point rounding error should be corrected.

        var powerOf10 = Math.round(exponent);
        var isPowerOf10 = x === Math.pow(10, powerOf10);
        return isPowerOf10 ? powerOf10 : exponent;
      };

      helpers$1.toRadians = function (degrees) {
        return degrees * (Math.PI / 180);
      };

      helpers$1.toDegrees = function (radians) {
        return radians * (180 / Math.PI);
      };
      /**
       * Returns the number of decimal places
       * i.e. the number of digits after the decimal point, of the value of this Number.
       * @param {number} x - A number.
       * @returns {number} The number of decimal places.
       * @private
       */


      helpers$1._decimalPlaces = function (x) {
        if (!helpers$1.isFinite(x)) {
          return;
        }

        var e = 1;
        var p = 0;

        while (Math.round(x * e) / e !== x) {
          e *= 10;
          p++;
        }

        return p;
      }; // Gets the angle from vertical upright to the point about a centre.


      helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {
        var distanceFromXCenter = anglePoint.x - centrePoint.x;
        var distanceFromYCenter = anglePoint.y - centrePoint.y;
        var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

        if (angle < -0.5 * Math.PI) {
          angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
        }

        return {
          angle: angle,
          distance: radialDistanceFromCenter
        };
      };

      helpers$1.distanceBetweenPoints = function (pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      };
      /**
       * Provided for backward compatibility, not available anymore
       * @function Chart.helpers.aliasPixel
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       */


      helpers$1.aliasPixel = function (pixelWidth) {
        return pixelWidth % 2 === 0 ? 0 : 0.5;
      };
      /**
       * Returns the aligned pixel value to avoid anti-aliasing blur
       * @param {Chart} chart - The chart instance.
       * @param {number} pixel - A pixel value.
       * @param {number} width - The width of the element.
       * @returns {number} The aligned pixel value.
       * @private
       */


      helpers$1._alignPixel = function (chart, pixel, width) {
        var devicePixelRatio = chart.currentDevicePixelRatio;
        var halfWidth = width / 2;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
      };

      helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
        // Props to Rob Spencer at scaled innovation for his post on splining between points
        // http://scaledinnovation.com/analytics/splines/aboutSplines.html
        // This function must also respect "skipped" points
        var previous = firstPoint.skip ? middlePoint : firstPoint;
        var current = middlePoint;
        var next = afterPoint.skip ? middlePoint : afterPoint;
        var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
        var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
        var s01 = d01 / (d01 + d12);
        var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf

        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        var fa = t * s01; // scaling factor for triangle Ta

        var fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      };

      helpers$1.EPSILON = Number.EPSILON || 1e-14;

      helpers$1.splineCurveMonotone = function (points) {
        // This function calculates Bzier control points in a similar way than |splineCurve|,
        // but preserves monotonicity of the provided data and ensures no local extremums are added
        // between the dataset discrete points due to the interpolation.
        // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
        var pointsWithTangents = (points || []).map(function (point) {
          return {
            model: point._model,
            deltaK: 0,
            mK: 0
          };
        }); // Calculate slopes (deltaK) and initialize tangents (mK)

        var pointsLen = pointsWithTangents.length;
        var i, pointBefore, pointCurrent, pointAfter;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointAfter && !pointAfter.model.skip) {
            var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0

            pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
          }

          if (!pointBefore || pointBefore.model.skip) {
            pointCurrent.mK = pointCurrent.deltaK;
          } else if (!pointAfter || pointAfter.model.skip) {
            pointCurrent.mK = pointBefore.deltaK;
          } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
            pointCurrent.mK = 0;
          } else {
            pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
          }
        } // Adjust tangents to ensure monotonic properties


        var alphaK, betaK, tauK, squaredMagnitude;

        for (i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointsWithTangents[i];
          pointAfter = pointsWithTangents[i + 1];

          if (pointCurrent.model.skip || pointAfter.model.skip) {
            continue;
          }

          if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
            pointCurrent.mK = pointAfter.mK = 0;
            continue;
          }

          alphaK = pointCurrent.mK / pointCurrent.deltaK;
          betaK = pointAfter.mK / pointCurrent.deltaK;
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

          if (squaredMagnitude <= 9) {
            continue;
          }

          tauK = 3 / Math.sqrt(squaredMagnitude);
          pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
          pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
        } // Compute control points


        var deltaX;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointBefore && !pointBefore.model.skip) {
            deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
            pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
            pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
          }

          if (pointAfter && !pointAfter.model.skip) {
            deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
            pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
            pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
          }
        }
      };

      helpers$1.nextItem = function (collection, index, loop) {
        if (loop) {
          return index >= collection.length - 1 ? collection[0] : collection[index + 1];
        }

        return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
      };

      helpers$1.previousItem = function (collection, index, loop) {
        if (loop) {
          return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
        }

        return index <= 0 ? collection[0] : collection[index - 1];
      }; // Implementation of the nice number algorithm used in determining where axis labels will go


      helpers$1.niceNum = function (range, round) {
        var exponent = Math.floor(helpers$1.log10(range));
        var fraction = range / Math.pow(10, exponent);
        var niceFraction;

        if (round) {
          if (fraction < 1.5) {
            niceFraction = 1;
          } else if (fraction < 3) {
            niceFraction = 2;
          } else if (fraction < 7) {
            niceFraction = 5;
          } else {
            niceFraction = 10;
          }
        } else if (fraction <= 1.0) {
          niceFraction = 1;
        } else if (fraction <= 2) {
          niceFraction = 2;
        } else if (fraction <= 5) {
          niceFraction = 5;
        } else {
          niceFraction = 10;
        }

        return niceFraction * Math.pow(10, exponent);
      }; // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/


      helpers$1.requestAnimFrame = function () {
        if (typeof window === 'undefined') {
          return function (callback) {
            callback();
          };
        }

        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
          return window.setTimeout(callback, 1000 / 60);
        };
      }(); // -- DOM methods


      helpers$1.getRelativePosition = function (evt, chart) {
        var mouseX, mouseY;
        var e = evt.originalEvent || evt;
        var canvas = evt.target || evt.srcElement;
        var boundingRect = canvas.getBoundingClientRect();
        var touches = e.touches;

        if (touches && touches.length > 0) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        } // Scale mouse coordinates into canvas coordinates
        // by following the pattern laid out by 'jerryj' in the comments of
        // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/


        var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));
        var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));
        var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));
        var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));
        var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
        var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
        // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here

        mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
        mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
        return {
          x: mouseX,
          y: mouseY
        };
      }; // Private helper function to convert max-width/max-height values that may be percentages into a number


      function parseMaxStyle(styleValue, node, parentProperty) {
        var valueInPixels;

        if (typeof styleValue === 'string') {
          valueInPixels = parseInt(styleValue, 10);

          if (styleValue.indexOf('%') !== -1) {
            // percentage * size in dimension
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }

        return valueInPixels;
      }
      /**
       * Returns if the given value contains an effective constraint.
       * @private
       */


      function isConstrainedValue(value) {
        return value !== undefined && value !== null && value !== 'none';
      }
      /**
       * Returns the max width or height of the given DOM node in a cross-browser compatible fashion
       * @param {HTMLElement} domNode - the node to check the constraint on
       * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')
       * @param {string} percentageProperty - property of parent to use when calculating width as a percentage
       * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}
       */


      function getConstraintDimension(domNode, maxStyle, percentageProperty) {
        var view = document.defaultView;

        var parentNode = helpers$1._getParentNode(domNode);

        var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
        var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
        var hasCNode = isConstrainedValue(constrainedNode);
        var hasCContainer = isConstrainedValue(constrainedContainer);
        var infinity = Number.POSITIVE_INFINITY;

        if (hasCNode || hasCContainer) {
          return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
        }

        return 'none';
      } // returns Number or undefined if no constraint


      helpers$1.getConstraintWidth = function (domNode) {
        return getConstraintDimension(domNode, 'max-width', 'clientWidth');
      }; // returns Number or undefined if no constraint


      helpers$1.getConstraintHeight = function (domNode) {
        return getConstraintDimension(domNode, 'max-height', 'clientHeight');
      };
      /**
       * @private
      	 */


      helpers$1._calculatePadding = function (container, padding, parentDimension) {
        padding = helpers$1.getStyle(container, padding);
        return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
      };
      /**
       * @private
       */


      helpers$1._getParentNode = function (domNode) {
        var parent = domNode.parentNode;

        if (parent && parent.toString() === '[object ShadowRoot]') {
          parent = parent.host;
        }

        return parent;
      };

      helpers$1.getMaximumWidth = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientWidth;
        }

        var clientWidth = container.clientWidth;

        var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);

        var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);

        var w = clientWidth - paddingLeft - paddingRight;
        var cw = helpers$1.getConstraintWidth(domNode);
        return isNaN(cw) ? w : Math.min(w, cw);
      };

      helpers$1.getMaximumHeight = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientHeight;
        }

        var clientHeight = container.clientHeight;

        var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);

        var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);

        var h = clientHeight - paddingTop - paddingBottom;
        var ch = helpers$1.getConstraintHeight(domNode);
        return isNaN(ch) ? h : Math.min(h, ch);
      };

      helpers$1.getStyle = function (el, property) {
        return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
      };

      helpers$1.retinaScale = function (chart, forceRatio) {
        var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;

        if (pixelRatio === 1) {
          return;
        }

        var canvas = chart.canvas;
        var height = chart.height;
        var width = chart.width;
        canvas.height = height * pixelRatio;
        canvas.width = width * pixelRatio;
        chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,
        // making the chart visually bigger, so let's enforce it to the "correct" values.
        // See https://github.com/chartjs/Chart.js/issues/3575

        if (!canvas.style.height && !canvas.style.width) {
          canvas.style.height = height + 'px';
          canvas.style.width = width + 'px';
        }
      }; // -- Canvas methods


      helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {
        return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
      };

      helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        var data = cache.data = cache.data || {};
        var gc = cache.garbageCollect = cache.garbageCollect || [];

        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }

        ctx.font = font;
        var longest = 0;
        helpers$1.each(arrayOfThings, function (thing) {
          // Undefined strings and arrays should not be measured
          if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
            longest = helpers$1.measureText(ctx, data, gc, longest, thing);
          } else if (helpers$1.isArray(thing)) {
            // if it is an array lets measure each element
            // to do maybe simplify this function a bit so we can do this more recursively?
            helpers$1.each(thing, function (nestedThing) {
              // Undefined strings and arrays should not be measured
              if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
              }
            });
          }
        });
        var gcLen = gc.length / 2;

        if (gcLen > arrayOfThings.length) {
          for (var i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }

          gc.splice(0, gcLen);
        }

        return longest;
      };

      helpers$1.measureText = function (ctx, data, gc, longest, string) {
        var textWidth = data[string];

        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
        }

        if (textWidth > longest) {
          longest = textWidth;
        }

        return longest;
      };

      helpers$1.numberOfLabelLines = function (arrayOfThings) {
        var numberOfLines = 1;
        helpers$1.each(arrayOfThings, function (thing) {
          if (helpers$1.isArray(thing)) {
            if (thing.length > numberOfLines) {
              numberOfLines = thing.length;
            }
          }
        });
        return numberOfLines;
      };

      helpers$1.color = !chartjsColor ? function (value) {
        console.error('Color.js not found!');
        return value;
      } : function (value) {
        /* global CanvasGradient */
        if (value instanceof CanvasGradient) {
          value = core_defaults.global.defaultColor;
        }

        return chartjsColor(value);
      };

      helpers$1.getHoverColor = function (colorValue) {
        /* global CanvasPattern */
        return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
      };
    };

    function abstract() {
      throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');
    }
    /**
     * Date adapter (current used by the time scale)
     * @namespace Chart._adapters._date
     * @memberof Chart._adapters
     * @private
     */

    /**
     * Currently supported unit string values.
     * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}
     * @memberof Chart._adapters._date
     * @name Unit
     */

    /**
     * @class
     */


    function DateAdapter(options) {
      this.options = options || {};
    }

    helpers$1.extend(DateAdapter.prototype,
    /** @lends DateAdapter */
    {
      /**
       * Returns a map of time formats for the supported formatting units defined
       * in Unit as well as 'datetime' representing a detailed date/time string.
       * @returns {{string: string}}
       */
      formats: abstract,

      /**
       * Parses the given `value` and return the associated timestamp.
       * @param {any} value - the value to parse (usually comes from the data)
       * @param {string} [format] - the expected data format
       * @returns {(number|null)}
       * @function
       */
      parse: abstract,

      /**
       * Returns the formatted date in the specified `format` for a given `timestamp`.
       * @param {number} timestamp - the timestamp to format
       * @param {string} format - the date/time token
       * @return {string}
       * @function
       */
      format: abstract,

      /**
       * Adds the specified `amount` of `unit` to the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {number} amount - the amount to add
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      add: abstract,

      /**
       * Returns the number of `unit` between the given timestamps.
       * @param {number} max - the input timestamp (reference)
       * @param {number} min - the timestamp to substract
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      diff: abstract,

      /**
       * Returns start of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @param {number} [weekday] - the ISO day of the week with 1 being Monday
       * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
       * @function
       */
      startOf: abstract,

      /**
       * Returns end of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @function
       */
      endOf: abstract,
      // DEPRECATIONS

      /**
       * Provided for backward compatibility for scale.getValueForPixel(),
       * this method should be overridden only by the moment adapter.
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (value) {
        return value;
      }
    });

    DateAdapter.override = function (members) {
      helpers$1.extend(DateAdapter.prototype, members);
    };

    var _date = DateAdapter;
    var core_adapters = {
      _date: _date
    };
    /**
     * Namespace to hold static tick generation functions
     * @namespace Chart.Ticks
     */

    var core_ticks = {
      /**
       * Namespace to hold formatters for different types of ticks
       * @namespace Chart.Ticks.formatters
       */
      formatters: {
        /**
         * Formatter for value labels
         * @method Chart.Ticks.formatters.values
         * @param value the value to display
         * @return {string|string[]} the label to display
         */
        values: function (value) {
          return helpers$1.isArray(value) ? value : '' + value;
        },

        /**
         * Formatter for linear numeric ticks
         * @method Chart.Ticks.formatters.linear
         * @param tickValue {number} the value to be formatted
         * @param index {number} the position of the tickValue parameter in the ticks array
         * @param ticks {number[]} the list of ticks being converted
         * @return {string} string representation of the tickValue parameter
         */
        linear: function (tickValue, index, ticks) {
          // If we have lots of ticks, don't use the ones
          var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need

          if (Math.abs(delta) > 1) {
            if (tickValue !== Math.floor(tickValue)) {
              // not an integer
              delta = tickValue - Math.floor(tickValue);
            }
          }

          var logDelta = helpers$1.log10(Math.abs(delta));
          var tickString = '';

          if (tickValue !== 0) {
            var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));

            if (maxTick < 1e-4) {
              // all ticks are small numbers; use scientific notation
              var logTick = helpers$1.log10(Math.abs(tickValue));
              tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
            } else {
              var numDecimal = -1 * Math.floor(logDelta);
              numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places

              tickString = tickValue.toFixed(numDecimal);
            }
          } else {
            tickString = '0'; // never show decimal places for 0
          }

          return tickString;
        },
        logarithmic: function (tickValue, index, ticks) {
          var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));

          if (tickValue === 0) {
            return '0';
          } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
            return tickValue.toExponential();
          }

          return '';
        }
      }
    };
    var valueOrDefault$9 = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;

    core_defaults._set('scale', {
      display: true,
      position: 'left',
      offset: false,
      // grid line settings
      gridLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        drawBorder: true,
        drawOnChartArea: true,
        drawTicks: true,
        tickMarkLength: 10,
        zeroLineWidth: 1,
        zeroLineColor: 'rgba(0,0,0,0.25)',
        zeroLineBorderDash: [],
        zeroLineBorderDashOffset: 0.0,
        offsetGridLines: false,
        borderDash: [],
        borderDashOffset: 0.0
      },
      // scale label
      scaleLabel: {
        // display property
        display: false,
        // actual label
        labelString: '',
        // top/bottom padding
        padding: {
          top: 4,
          bottom: 4
        }
      },
      // label settings
      ticks: {
        beginAtZero: false,
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        padding: 0,
        reverse: false,
        display: true,
        autoSkip: true,
        autoSkipPadding: 0,
        labelOffset: 0,
        // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
        callback: core_ticks.formatters.values,
        minor: {},
        major: {}
      }
    });

    function labelsFromTicks(ticks) {
      var labels = [];
      var i, ilen;

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        labels.push(ticks[i].label);
      }

      return labels;
    }

    function getPixelForGridLine(scale, index, offsetGridLines) {
      var lineValue = scale.getPixelForTick(index);

      if (offsetGridLines) {
        if (scale.getTicks().length === 1) {
          lineValue -= scale.isHorizontal() ? Math.max(lineValue - scale.left, scale.right - lineValue) : Math.max(lineValue - scale.top, scale.bottom - lineValue);
        } else if (index === 0) {
          lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
          lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
        }
      }

      return lineValue;
    }

    function computeTextSize(context, tick, font) {
      return helpers$1.isArray(tick) ? helpers$1.longestText(context, font, tick) : context.measureText(tick).width;
    }

    var core_scale = core_element.extend({
      /**
       * Get the padding needed for the scale
       * @method getPadding
       * @private
       * @returns {Padding} the necessary padding
       */
      getPadding: function () {
        var me = this;
        return {
          left: me.paddingLeft || 0,
          top: me.paddingTop || 0,
          right: me.paddingRight || 0,
          bottom: me.paddingBottom || 0
        };
      },

      /**
       * Returns the scale tick objects ({label, major})
       * @since 2.7
       */
      getTicks: function () {
        return this._ticks;
      },
      // These methods are ordered by lifecyle. Utilities then follow.
      // Any function defined here is inherited by all scale types.
      // Any function can be extended by the scale type
      mergeTicksOptions: function () {
        var ticks = this.options.ticks;

        if (ticks.minor === false) {
          ticks.minor = {
            display: false
          };
        }

        if (ticks.major === false) {
          ticks.major = {
            display: false
          };
        }

        for (var key in ticks) {
          if (key !== 'major' && key !== 'minor') {
            if (typeof ticks.minor[key] === 'undefined') {
              ticks.minor[key] = ticks[key];
            }

            if (typeof ticks.major[key] === 'undefined') {
              ticks.major[key] = ticks[key];
            }
          }
        }
      },
      beforeUpdate: function () {
        helpers$1.callback(this.options.beforeUpdate, [this]);
      },
      update: function (maxWidth, maxHeight, margins) {
        var me = this;
        var i, ilen, labels, label, ticks, tick; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = helpers$1.extend({
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, margins);
        me._maxLabelLines = 0;
        me.longestLabelWidth = 0;
        me.longestTextCache = me.longestTextCache || {}; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Data min/max

        me.beforeDataLimits();
        me.determineDataLimits();
        me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!
        // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
        // and must not be accessed directly from outside this class. `this.ticks` being
        // around for long time and not marked as private, we can't change its structure
        // without unexpected breaking changes. If you need to access the scale ticks,
        // use scale.getTicks() instead.

        me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,
        // we still support no return (`this.ticks` internally set by calling this method).

        ticks = me.buildTicks() || []; // Allow modification of ticks in callback.

        ticks = me.afterBuildTicks(ticks) || ticks;
        me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD
        // COMPAT, we still support no return (`this.ticks` internally changed by calling
        // this method and supposed to contain only string values).

        labels = me.convertTicksToLabels(ticks) || me.ticks;
        me.afterTickToLabelConversion();
        me.ticks = labels; // BACKWARD COMPATIBILITY
        // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
        // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)

        for (i = 0, ilen = labels.length; i < ilen; ++i) {
          label = labels[i];
          tick = ticks[i];

          if (!tick) {
            ticks.push(tick = {
              label: label,
              major: false
            });
          } else {
            tick.label = label;
          }
        }

        me._ticks = ticks; // Tick Rotation

        me.beforeCalculateTickRotation();
        me.calculateTickRotation();
        me.afterCalculateTickRotation(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: function () {
        helpers$1.callback(this.options.afterUpdate, [this]);
      },
      //
      beforeSetDimensions: function () {
        helpers$1.callback(this.options.beforeSetDimensions, [this]);
      },
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0;
      },
      afterSetDimensions: function () {
        helpers$1.callback(this.options.afterSetDimensions, [this]);
      },
      // Data limits
      beforeDataLimits: function () {
        helpers$1.callback(this.options.beforeDataLimits, [this]);
      },
      determineDataLimits: helpers$1.noop,
      afterDataLimits: function () {
        helpers$1.callback(this.options.afterDataLimits, [this]);
      },
      //
      beforeBuildTicks: function () {
        helpers$1.callback(this.options.beforeBuildTicks, [this]);
      },
      buildTicks: helpers$1.noop,
      afterBuildTicks: function (ticks) {
        var me = this; // ticks is empty for old axis implementations here

        if (helpers$1.isArray(ticks) && ticks.length) {
          return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
        } // Support old implementations (that modified `this.ticks` directly in buildTicks)


        me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
        return ticks;
      },
      beforeTickToLabelConversion: function () {
        helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
      },
      convertTicksToLabels: function () {
        var me = this; // Convert ticks to strings

        var tickOpts = me.options.ticks;
        me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
      },
      afterTickToLabelConversion: function () {
        helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
      },
      //
      beforeCalculateTickRotation: function () {
        helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
      },
      calculateTickRotation: function () {
        var me = this;
        var context = me.ctx;
        var tickOpts = me.options.ticks;
        var labels = labelsFromTicks(me._ticks); // Get the width of each grid by calculating the difference
        // between x offsets between 0 and 1.

        var tickFont = helpers$1.options._parseFont(tickOpts);

        context.font = tickFont.string;
        var labelRotation = tickOpts.minRotation || 0;

        if (labels.length && me.options.display && me.isHorizontal()) {
          var originalLabelWidth = helpers$1.longestText(context, tickFont.string, labels, me.longestTextCache);
          var labelWidth = originalLabelWidth;
          var cosRotation, sinRotation; // Allow 3 pixels x2 padding either side for label readability

          var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter

          while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
            var angleRadians = helpers$1.toRadians(labelRotation);
            cosRotation = Math.cos(angleRadians);
            sinRotation = Math.sin(angleRadians);

            if (sinRotation * originalLabelWidth > me.maxHeight) {
              // go back one step
              labelRotation--;
              break;
            }

            labelRotation++;
            labelWidth = cosRotation * originalLabelWidth;
          }
        }

        me.labelRotation = labelRotation;
      },
      afterCalculateTickRotation: function () {
        helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
      },
      //
      beforeFit: function () {
        helpers$1.callback(this.options.beforeFit, [this]);
      },
      fit: function () {
        var me = this; // Reset

        var minSize = me.minSize = {
          width: 0,
          height: 0
        };
        var labels = labelsFromTicks(me._ticks);
        var opts = me.options;
        var tickOpts = opts.ticks;
        var scaleLabelOpts = opts.scaleLabel;
        var gridLineOpts = opts.gridLines;

        var display = me._isVisible();

        var position = opts.position;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var tickFont = parseFont(tickOpts);
        var tickMarkLength = opts.gridLines.tickMarkLength; // Width

        if (isHorizontal) {
          // subtract the margins to line up with the chartArea if we are a full width scale
          minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
        } else {
          minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } // height


        if (isHorizontal) {
          minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } else {
          minSize.height = me.maxHeight; // fill all the height
        } // Are we showing a title for the scale?


        if (scaleLabelOpts.display && display) {
          var scaleLabelFont = parseFont(scaleLabelOpts);
          var scaleLabelPadding = helpers$1.options.toPadding(scaleLabelOpts.padding);
          var deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;

          if (isHorizontal) {
            minSize.height += deltaHeight;
          } else {
            minSize.width += deltaHeight;
          }
        } // Don't bother fitting the ticks if we are not showing the labels


        if (tickOpts.display && display) {
          var largestTextWidth = helpers$1.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);
          var tallestLabelHeightInLines = helpers$1.numberOfLabelLines(labels);
          var lineSpace = tickFont.size * 0.5;
          var tickPadding = me.options.ticks.padding; // Store max number of lines and widest label for _autoSkip

          me._maxLabelLines = tallestLabelHeightInLines;
          me.longestLabelWidth = largestTextWidth;

          if (isHorizontal) {
            var angleRadians = helpers$1.toRadians(me.labelRotation);
            var cosRotation = Math.cos(angleRadians);
            var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation

            var labelHeight = sinRotation * largestTextWidth + tickFont.lineHeight * tallestLabelHeightInLines + lineSpace; // padding

            minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
            me.ctx.font = tickFont.string;
            var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);
            var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);
            var offsetLeft = me.getPixelForTick(0) - me.left;
            var offsetRight = me.right - me.getPixelForTick(labels.length - 1);
            var paddingLeft, paddingRight; // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
            // which means that the right padding is dominated by the font height

            if (me.labelRotation !== 0) {
              paddingLeft = position === 'bottom' ? cosRotation * firstLabelWidth : cosRotation * lineSpace;
              paddingRight = position === 'bottom' ? cosRotation * lineSpace : cosRotation * lastLabelWidth;
            } else {
              paddingLeft = firstLabelWidth / 2;
              paddingRight = lastLabelWidth / 2;
            }

            me.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges

            me.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;
          } else {
            // A vertical axis is more constrained by the width. Labels are the
            // dominant factor here, so get that length first and account for padding
            if (tickOpts.mirror) {
              largestTextWidth = 0;
            } else {
              // use lineSpace for consistency with horizontal axis
              // tickPadding is not implemented for horizontal
              largestTextWidth += tickPadding + lineSpace;
            }

            minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
            me.paddingTop = tickFont.size / 2;
            me.paddingBottom = tickFont.size / 2;
          }
        }

        me.handleMargins();
        me.width = minSize.width;
        me.height = minSize.height;
      },

      /**
       * Handle margins and padding interactions
       * @private
       */
      handleMargins: function () {
        var me = this;

        if (me.margins) {
          me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
          me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
          me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
          me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
        }
      },
      afterFit: function () {
        helpers$1.callback(this.options.afterFit, [this]);
      },
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      isFullWidth: function () {
        return this.options.fullWidth;
      },
      // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
      getRightValue: function (rawValue) {
        // Null and undefined values first
        if (helpers$1.isNullOrUndef(rawValue)) {
          return NaN;
        } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values


        if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {
          return NaN;
        } // If it is in fact an object, dive in one more level


        if (rawValue) {
          if (this.isHorizontal()) {
            if (rawValue.x !== undefined) {
              return this.getRightValue(rawValue.x);
            }
          } else if (rawValue.y !== undefined) {
            return this.getRightValue(rawValue.y);
          }
        } // Value is good, return it


        return rawValue;
      },

      /**
       * Used to get the value to display in the tooltip for the data at the given index
       * @param index
       * @param datasetIndex
       */
      getLabelForIndex: helpers$1.noop,

      /**
       * Returns the location of the given data point. Value can either be an index or a numerical value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param value
       * @param index
       * @param datasetIndex
       */
      getPixelForValue: helpers$1.noop,

      /**
       * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param pixel
       */
      getValueForPixel: helpers$1.noop,

      /**
       * Returns the location of the tick at the given index
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForTick: function (index) {
        var me = this;
        var offset = me.options.offset;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
          var pixel = tickWidth * index + me.paddingLeft;

          if (offset) {
            pixel += tickWidth / 2;
          }

          var finalVal = me.left + pixel;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
        return me.top + index * (innerHeight / (me._ticks.length - 1));
      },

      /**
       * Utility for getting the pixel location of a percentage of scale
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForDecimal: function (decimal) {
        var me = this;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var valueOffset = innerWidth * decimal + me.paddingLeft;
          var finalVal = me.left + valueOffset;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        return me.top + decimal * me.height;
      },

      /**
       * Returns the pixel for the minimum chart value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getBasePixel: function () {
        return this.getPixelForValue(this.getBaseValue());
      },
      getBaseValue: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
      },

      /**
       * Returns a subset of ticks to be plotted to avoid overlapping labels.
       * @private
       */
      _autoSkip: function (ticks) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor;
        var tickCount = ticks.length;
        var skipRatio = false;
        var maxTicks = optionTicks.maxTicksLimit; // Total space needed to display all ticks. First and last ticks are
        // drawn as their center at end of axis, so tickCount-1

        var ticksLength = me._tickSize() * (tickCount - 1); // Axis length

        var axisLength = isHorizontal ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.PaddingBottom);
        var result = [];
        var i, tick;

        if (ticksLength > axisLength) {
          skipRatio = 1 + Math.floor(ticksLength / axisLength);
        } // if they defined a max number of optionTicks,
        // increase skipRatio until that number is met


        if (tickCount > maxTicks) {
          skipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));
        }

        for (i = 0; i < tickCount; i++) {
          tick = ticks[i];

          if (skipRatio > 1 && i % skipRatio > 0) {
            // leave tick in place but make sure it's not displayed (#4635)
            delete tick.label;
          }

          result.push(tick);
        }

        return result;
      },

      /**
       * @private
       */
      _tickSize: function () {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor; // Calculate space needed by label in axis direction.

        var rot = helpers$1.toRadians(me.labelRotation);
        var cos = Math.abs(Math.cos(rot));
        var sin = Math.abs(Math.sin(rot));
        var padding = optionTicks.autoSkipPadding || 0;
        var w = me.longestLabelWidth + padding || 0;

        var tickFont = helpers$1.options._parseFont(optionTicks);

        var h = me._maxLabelLines * tickFont.lineHeight + padding || 0; // Calculate space needed for 1 tick in axis direction.

        return isHorizontal ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
      },

      /**
       * @private
       */
      _isVisible: function () {
        var me = this;
        var chart = me.chart;
        var display = me.options.display;
        var i, ilen, meta;

        if (display !== 'auto') {
          return !!display;
        } // When 'auto', the scale is visible if at least one associated dataset is visible.


        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);

            if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
              return true;
            }
          }
        }

        return false;
      },

      /**
       * Actually draw the scale on the canvas
       * @param {object} chartArea - the area of the chart to draw full grid lines on
       */
      draw: function (chartArea) {
        var me = this;
        var options = me.options;

        if (!me._isVisible()) {
          return;
        }

        var chart = me.chart;
        var context = me.ctx;
        var globalDefaults = core_defaults.global;
        var defaultFontColor = globalDefaults.defaultFontColor;
        var optionTicks = options.ticks.minor;
        var optionMajorTicks = options.ticks.major || optionTicks;
        var gridLines = options.gridLines;
        var scaleLabel = options.scaleLabel;
        var position = options.position;
        var isRotated = me.labelRotation !== 0;
        var isMirrored = optionTicks.mirror;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
        var tickFontColor = valueOrDefault$9(optionTicks.fontColor, defaultFontColor);
        var tickFont = parseFont(optionTicks);
        var lineHeight = tickFont.lineHeight;
        var majorTickFontColor = valueOrDefault$9(optionMajorTicks.fontColor, defaultFontColor);
        var majorTickFont = parseFont(optionMajorTicks);
        var tickPadding = optionTicks.padding;
        var labelOffset = optionTicks.labelOffset;
        var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
        var scaleLabelFontColor = valueOrDefault$9(scaleLabel.fontColor, defaultFontColor);
        var scaleLabelFont = parseFont(scaleLabel);
        var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
        var labelRotationRadians = helpers$1.toRadians(me.labelRotation);
        var itemsToDraw = [];
        var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
        var alignPixel = helpers$1._alignPixel;
        var borderValue, tickStart, tickEnd;

        if (position === 'top') {
          borderValue = alignPixel(chart, me.bottom, axisWidth);
          tickStart = me.bottom - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else if (position === 'bottom') {
          borderValue = alignPixel(chart, me.top, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.top + tl;
        } else if (position === 'left') {
          borderValue = alignPixel(chart, me.right, axisWidth);
          tickStart = me.right - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else {
          borderValue = alignPixel(chart, me.left, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.left + tl;
        }

        var epsilon = 0.0000001; // 0.0000001 is margin in pixels for Accumulated error.

        helpers$1.each(ticks, function (tick, index) {
          // autoskipper skipped this tick (#4635)
          if (helpers$1.isNullOrUndef(tick.label)) {
            return;
          }

          var label = tick.label;
          var lineWidth, lineColor, borderDash, borderDashOffset;

          if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
            // Draw the first index specially
            lineWidth = gridLines.zeroLineWidth;
            lineColor = gridLines.zeroLineColor;
            borderDash = gridLines.zeroLineBorderDash || [];
            borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;
          } else {
            lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);
            lineColor = valueAtIndexOrDefault(gridLines.color, index);
            borderDash = gridLines.borderDash || [];
            borderDashOffset = gridLines.borderDashOffset || 0.0;
          } // Common properties


          var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;
          var labelCount = helpers$1.isArray(label) ? label.length : 1;
          var lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);

          if (isHorizontal) {
            var labelYOffset = tl + tickPadding;

            if (lineValue < me.left - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);
            ty1 = tickStart;
            ty2 = tickEnd;
            labelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)

            if (position === 'top') {
              y1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;
              y2 = chartArea.bottom;
              textOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;
              textAlign = !isRotated ? 'center' : 'left';
              labelY = me.bottom - labelYOffset;
            } else {
              y1 = chartArea.top;
              y2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;
              textOffset = (!isRotated ? 0.5 : 0) * lineHeight;
              textAlign = !isRotated ? 'center' : 'right';
              labelY = me.top + labelYOffset;
            }
          } else {
            var labelXOffset = (isMirrored ? 0 : tl) + tickPadding;

            if (lineValue < me.top - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tickStart;
            tx2 = tickEnd;
            ty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);
            labelY = me.getPixelForTick(index) + labelOffset;
            textOffset = (1 - labelCount) * lineHeight / 2;

            if (position === 'left') {
              x1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;
              x2 = chartArea.right;
              textAlign = isMirrored ? 'left' : 'right';
              labelX = me.right - labelXOffset;
            } else {
              x1 = chartArea.left;
              x2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;
              textAlign = isMirrored ? 'right' : 'left';
              labelX = me.left + labelXOffset;
            }
          }

          itemsToDraw.push({
            tx1: tx1,
            ty1: ty1,
            tx2: tx2,
            ty2: ty2,
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            labelX: labelX,
            labelY: labelY,
            glWidth: lineWidth,
            glColor: lineColor,
            glBorderDash: borderDash,
            glBorderDashOffset: borderDashOffset,
            rotation: -1 * labelRotationRadians,
            label: label,
            major: tick.major,
            textOffset: textOffset,
            textAlign: textAlign
          });
        }); // Draw all of the tick labels, tick marks, and grid lines at the correct places

        helpers$1.each(itemsToDraw, function (itemToDraw) {
          var glWidth = itemToDraw.glWidth;
          var glColor = itemToDraw.glColor;

          if (gridLines.display && glWidth && glColor) {
            context.save();
            context.lineWidth = glWidth;
            context.strokeStyle = glColor;

            if (context.setLineDash) {
              context.setLineDash(itemToDraw.glBorderDash);
              context.lineDashOffset = itemToDraw.glBorderDashOffset;
            }

            context.beginPath();

            if (gridLines.drawTicks) {
              context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
              context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
            }

            if (gridLines.drawOnChartArea) {
              context.moveTo(itemToDraw.x1, itemToDraw.y1);
              context.lineTo(itemToDraw.x2, itemToDraw.y2);
            }

            context.stroke();
            context.restore();
          }

          if (optionTicks.display) {
            // Make sure we draw text in the correct color and font
            context.save();
            context.translate(itemToDraw.labelX, itemToDraw.labelY);
            context.rotate(itemToDraw.rotation);
            context.font = itemToDraw.major ? majorTickFont.string : tickFont.string;
            context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
            context.textBaseline = 'middle';
            context.textAlign = itemToDraw.textAlign;
            var label = itemToDraw.label;
            var y = itemToDraw.textOffset;

            if (helpers$1.isArray(label)) {
              for (var i = 0; i < label.length; ++i) {
                // We just make sure the multiline element is a string here..
                context.fillText('' + label[i], 0, y);
                y += lineHeight;
              }
            } else {
              context.fillText(label, 0, y);
            }

            context.restore();
          }
        });

        if (scaleLabel.display) {
          // Draw the scale label
          var scaleLabelX;
          var scaleLabelY;
          var rotation = 0;
          var halfLineHeight = scaleLabelFont.lineHeight / 2;

          if (isHorizontal) {
            scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width

            scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
          } else {
            var isLeft = position === 'left';
            scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
            scaleLabelY = me.top + (me.bottom - me.top) / 2;
            rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
          }

          context.save();
          context.translate(scaleLabelX, scaleLabelY);
          context.rotate(rotation);
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          context.fillStyle = scaleLabelFontColor; // render in correct colour

          context.font = scaleLabelFont.string;
          context.fillText(scaleLabel.labelString, 0, 0);
          context.restore();
        }

        if (axisWidth) {
          // Draw the line at the edge of the axis
          var firstLineWidth = axisWidth;
          var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);
          var x1, x2, y1, y2;

          if (isHorizontal) {
            x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
            x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
            y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }

          context.lineWidth = axisWidth;
          context.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
          context.beginPath();
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
          context.stroke();
        }
      }
    });
    var defaultConfig = {
      position: 'bottom'
    };
    var scale_category = core_scale.extend({
      /**
      * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
      * else fall back to data.labels
      * @private
      */
      getLabels: function () {
        var data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
      },
      determineDataLimits: function () {
        var me = this;
        var labels = me.getLabels();
        me.minIndex = 0;
        me.maxIndex = labels.length - 1;
        var findIndex;

        if (me.options.ticks.min !== undefined) {
          // user specified min value
          findIndex = labels.indexOf(me.options.ticks.min);
          me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
        }

        if (me.options.ticks.max !== undefined) {
          // user specified max value
          findIndex = labels.indexOf(me.options.ticks.max);
          me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
        }

        me.min = labels[me.minIndex];
        me.max = labels[me.maxIndex];
      },
      buildTicks: function () {
        var me = this;
        var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array

        me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var chart = me.chart;

        if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
          return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
        }

        return me.ticks[index - me.minIndex];
      },
      // Used to get data value locations.  Value can either be an index or a numerical value
      getPixelForValue: function (value, index) {
        var me = this;
        var offset = me.options.offset; // 1 is added because we need the length but we have the indexes

        var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1); // If value is a data object, then index is the index in the data array,
        // not the index of the scale. We need to change that.

        var valueCategory;

        if (value !== undefined && value !== null) {
          valueCategory = me.isHorizontal() ? value.x : value.y;
        }

        if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
          var labels = me.getLabels();
          value = valueCategory || value;
          var idx = labels.indexOf(value);
          index = idx !== -1 ? idx : index;
        }

        if (me.isHorizontal()) {
          var valueWidth = me.width / offsetAmt;
          var widthOffset = valueWidth * (index - me.minIndex);

          if (offset) {
            widthOffset += valueWidth / 2;
          }

          return me.left + widthOffset;
        }

        var valueHeight = me.height / offsetAmt;
        var heightOffset = valueHeight * (index - me.minIndex);

        if (offset) {
          heightOffset += valueHeight / 2;
        }

        return me.top + heightOffset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var offset = me.options.offset;
        var value;
        var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
        var horz = me.isHorizontal();
        var valueDimension = (horz ? me.width : me.height) / offsetAmt;
        pixel -= horz ? me.left : me.top;

        if (offset) {
          pixel -= valueDimension / 2;
        }

        if (pixel <= 0) {
          value = 0;
        } else {
          value = Math.round(pixel / valueDimension);
        }

        return value + me.minIndex;
      },
      getBasePixel: function () {
        return this.bottom;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults = defaultConfig;
    scale_category._defaults = _defaults;
    var noop = helpers$1.noop;
    var isNullOrUndef = helpers$1.isNullOrUndef;
    /**
     * Generate a set of linear ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks(generationOptions, dataRange) {
      var ticks = []; // To get a "nice" value for the tick spacing, we will use the appropriately named
      // "nice number" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
      // for details.

      var MIN_SPACING = 1e-14;
      var stepSize = generationOptions.stepSize;
      var unit = stepSize || 1;
      var maxNumSpaces = generationOptions.maxTicks - 1;
      var min = generationOptions.min;
      var max = generationOptions.max;
      var precision = generationOptions.precision;
      var rmin = dataRange.min;
      var rmax = dataRange.max;
      var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
      var factor, niceMin, niceMax, numSpaces; // Beyond MIN_SPACING floating point numbers being to lose precision
      // such that we can't do the math necessary to generate ticks

      if (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {
        return [rmin, rmax];
      }

      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);

      if (numSpaces > maxNumSpaces) {
        // If the calculated num of spaces exceeds maxNumSpaces, recalculate it
        spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
      }

      if (stepSize || isNullOrUndef(precision)) {
        // If a precision is not specified, calculate factor based on spacing
        factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
      } else {
        // If the user specified a precision, round to that number of decimal places
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
      }

      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.

      if (stepSize) {
        // If very close to our whole number, use it.
        if (!isNullOrUndef(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {
          niceMin = min;
        }

        if (!isNullOrUndef(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {
          niceMax = max;
        }
      }

      numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.

      if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }

      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      ticks.push(isNullOrUndef(min) ? niceMin : min);

      for (var j = 1; j < numSpaces; ++j) {
        ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
      }

      ticks.push(isNullOrUndef(max) ? niceMax : max);
      return ticks;
    }

    var scale_linearbase = core_scale.extend({
      getRightValue: function (value) {
        if (typeof value === 'string') {
          return +value;
        }

        return core_scale.prototype.getRightValue.call(this, value);
      },
      handleTickRangeOptions: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
        // do nothing since that would make the chart weird. If the user really wants a weird chart
        // axis, they can manually override it

        if (tickOpts.beginAtZero) {
          var minSign = helpers$1.sign(me.min);
          var maxSign = helpers$1.sign(me.max);

          if (minSign < 0 && maxSign < 0) {
            // move the top up to 0
            me.max = 0;
          } else if (minSign > 0 && maxSign > 0) {
            // move the bottom down to 0
            me.min = 0;
          }
        }

        var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
        var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

        if (tickOpts.min !== undefined) {
          me.min = tickOpts.min;
        } else if (tickOpts.suggestedMin !== undefined) {
          if (me.min === null) {
            me.min = tickOpts.suggestedMin;
          } else {
            me.min = Math.min(me.min, tickOpts.suggestedMin);
          }
        }

        if (tickOpts.max !== undefined) {
          me.max = tickOpts.max;
        } else if (tickOpts.suggestedMax !== undefined) {
          if (me.max === null) {
            me.max = tickOpts.suggestedMax;
          } else {
            me.max = Math.max(me.max, tickOpts.suggestedMax);
          }
        }

        if (setMin !== setMax) {
          // We set the min or the max but not both.
          // So ensure that our range is good
          // Inverted or 0 length range can happen when
          // ticks.min is set, and no datasets are visible
          if (me.min >= me.max) {
            if (setMin) {
              me.max = me.min + 1;
            } else {
              me.min = me.max - 1;
            }
          }
        }

        if (me.min === me.max) {
          me.max++;

          if (!tickOpts.beginAtZero) {
            me.min--;
          }
        }
      },
      getTickLimit: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var stepSize = tickOpts.stepSize;
        var maxTicksLimit = tickOpts.maxTicksLimit;
        var maxTicks;

        if (stepSize) {
          maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
        } else {
          maxTicks = me._computeTickLimit();
          maxTicksLimit = maxTicksLimit || 11;
        }

        if (maxTicksLimit) {
          maxTicks = Math.min(maxTicksLimit, maxTicks);
        }

        return maxTicks;
      },
      _computeTickLimit: function () {
        return Number.POSITIVE_INFINITY;
      },
      handleDirectionalChanges: noop,
      buildTicks: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of
        // the axis area. For now, we say that the minimum tick spacing in pixels must be 40
        // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
        // the graph. Make sure we always have at least 2 ticks

        var maxTicks = me.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        var numericGeneratorOptions = {
          maxTicks: maxTicks,
          min: tickOpts.min,
          max: tickOpts.max,
          precision: tickOpts.precision,
          stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
        };
        var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
        me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          ticks.reverse();
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }
      },
      convertTicksToLabels: function () {
        var me = this;
        me.ticksAsNumbers = me.ticks.slice();
        me.zeroLineIndex = me.ticks.indexOf(0);
        core_scale.prototype.convertTicksToLabels.call(me);
      }
    });
    var defaultConfig$1 = {
      position: 'left',
      ticks: {
        callback: core_ticks.formatters.linear
      }
    };
    var scale_linear = scale_linearbase.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();
        var DEFAULT_MIN = 0;
        var DEFAULT_MAX = 1;

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // First Calculate the range


        me.min = null;
        me.max = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (valuesPerStack[key] === undefined) {
              valuesPerStack[key] = {
                positiveValues: [],
                negativeValues: []
              };
            } // Store these per type


            var positiveValues = valuesPerStack[key].positiveValues;
            var negativeValues = valuesPerStack[key].negativeValues;

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                positiveValues[index] = positiveValues[index] || 0;
                negativeValues[index] = negativeValues[index] || 0;

                if (opts.relativePoints) {
                  positiveValues[index] = 100;
                } else if (value < 0) {
                  negativeValues[index] += value;
                } else {
                  positiveValues[index] += value;
                }
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
            var minVal = helpers$1.min(values);
            var maxVal = helpers$1.max(values);
            me.min = me.min === null ? minVal : Math.min(me.min, minVal);
            me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }
              });
            }
          });
        }

        me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
        me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        this.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        var me = this;
        var tickFont;

        if (me.isHorizontal()) {
          return Math.ceil(me.width / 40);
        }

        tickFont = helpers$1.options._parseFont(me.options.ticks);
        return Math.ceil(me.height / tickFont.lineHeight);
      },
      // Called after the ticks are built. We need
      handleDirectionalChanges: function () {
        if (!this.isHorizontal()) {
          // We are in a vertical orientation. The top value is the highest. So reverse the array
          this.ticks.reverse();
        }
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      // Utils
      getPixelForValue: function (value) {
        // This must be called after fit has been run so that
        // this.left, this.top, this.right, and this.bottom have been defined
        var me = this;
        var start = me.start;
        var rightValue = +me.getRightValue(value);
        var pixel;
        var range = me.end - start;

        if (me.isHorizontal()) {
          pixel = me.left + me.width / range * (rightValue - start);
        } else {
          pixel = me.bottom - me.height / range * (rightValue - start);
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var innerDimension = isHorizontal ? me.width : me.height;
        var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
        return me.start + (me.end - me.start) * offset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticksAsNumbers[index]);
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$1 = defaultConfig$1;
    scale_linear._defaults = _defaults$1;
    var valueOrDefault$a = helpers$1.valueOrDefault;
    /**
     * Generate a set of logarithmic ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks$1(generationOptions, dataRange) {
      var ticks = [];
      var tickVal = valueOrDefault$a(generationOptions.min, Math.pow(10, Math.floor(helpers$1.log10(dataRange.min))));
      var endExp = Math.floor(helpers$1.log10(dataRange.max));
      var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
      var exp, significand;

      if (tickVal === 0) {
        exp = Math.floor(helpers$1.log10(dataRange.minNotZero));
        significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
        ticks.push(tickVal);
        tickVal = significand * Math.pow(10, exp);
      } else {
        exp = Math.floor(helpers$1.log10(tickVal));
        significand = Math.floor(tickVal / Math.pow(10, exp));
      }

      var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

      do {
        ticks.push(tickVal);
        ++significand;

        if (significand === 10) {
          significand = 1;
          ++exp;
          precision = exp >= 0 ? 1 : precision;
        }

        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
      } while (exp < endExp || exp === endExp && significand < endSignificand);

      var lastTick = valueOrDefault$a(generationOptions.max, tickVal);
      ticks.push(lastTick);
      return ticks;
    }

    var defaultConfig$2 = {
      position: 'left',
      // label settings
      ticks: {
        callback: core_ticks.formatters.logarithmic
      }
    }; // TODO(v3): change this to positiveOrDefault

    function nonNegativeOrDefault(value, defaultValue) {
      return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
    }

    var scale_logarithmic = core_scale.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // Calculate Range


        me.min = null;
        me.max = null;
        me.minNotZero = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              if (valuesPerStack[key] === undefined) {
                valuesPerStack[key] = [];
              }

              helpers$1.each(dataset.data, function (rawValue, index) {
                var values = valuesPerStack[key];
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                values[index] = values[index] || 0;
                values[index] += value;
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            if (valuesForType.length > 0) {
              var minVal = helpers$1.min(valuesForType);
              var maxVal = helpers$1.max(valuesForType);
              me.min = me.min === null ? minVal : Math.min(me.min, minVal);
              me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
            }
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }

                if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                  me.minNotZero = value;
                }
              });
            }
          });
        } // Common base implementation to handle ticks.min, ticks.max


        this.handleTickRangeOptions();
      },
      handleTickRangeOptions: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var DEFAULT_MIN = 1;
        var DEFAULT_MAX = 10;
        me.min = nonNegativeOrDefault(tickOpts.min, me.min);
        me.max = nonNegativeOrDefault(tickOpts.max, me.max);

        if (me.min === me.max) {
          if (me.min !== 0 && me.min !== null) {
            me.min = Math.pow(10, Math.floor(helpers$1.log10(me.min)) - 1);
            me.max = Math.pow(10, Math.floor(helpers$1.log10(me.max)) + 1);
          } else {
            me.min = DEFAULT_MIN;
            me.max = DEFAULT_MAX;
          }
        }

        if (me.min === null) {
          me.min = Math.pow(10, Math.floor(helpers$1.log10(me.max)) - 1);
        }

        if (me.max === null) {
          me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers$1.log10(me.min)) + 1) : DEFAULT_MAX;
        }

        if (me.minNotZero === null) {
          if (me.min > 0) {
            me.minNotZero = me.min;
          } else if (me.max < 1) {
            me.minNotZero = Math.pow(10, Math.floor(helpers$1.log10(me.max)));
          } else {
            me.minNotZero = DEFAULT_MIN;
          }
        }
      },
      buildTicks: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = !me.isHorizontal();
        var generationOptions = {
          min: nonNegativeOrDefault(tickOpts.min),
          max: nonNegativeOrDefault(tickOpts.max)
        };
        var ticks = me.ticks = generateTicks$1(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          reverse = !reverse;
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }

        if (reverse) {
          ticks.reverse();
        }
      },
      convertTicksToLabels: function () {
        this.tickValues = this.ticks.slice();
        core_scale.prototype.convertTicksToLabels.call(this);
      },
      // Get the correct tooltip label
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.tickValues[index]);
      },

      /**
       * Returns the value of the first tick.
       * @param {number} value - The minimum not zero value.
       * @return {number} The first tick value.
       * @private
       */
      _getFirstTickValue: function (value) {
        var exp = Math.floor(helpers$1.log10(value));
        var significand = Math.floor(value / Math.pow(10, exp));
        return significand * Math.pow(10, exp);
      },
      getPixelForValue: function (value) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var offset = 0;
        var innerDimension, pixel, start, end, sign;
        value = +me.getRightValue(value);

        if (reverse) {
          start = me.end;
          end = me.start;
          sign = -1;
        } else {
          start = me.start;
          end = me.end;
          sign = 1;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          pixel = reverse ? me.right : me.left;
        } else {
          innerDimension = me.height;
          sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)

          pixel = reverse ? me.top : me.bottom;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            innerDimension -= offset;
            start = firstTickValue;
          }

          if (value !== 0) {
            offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
          }

          pixel += sign * offset;
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var innerDimension, start, end, value;

        if (reverse) {
          start = me.end;
          end = me.start;
        } else {
          start = me.start;
          end = me.end;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          value = reverse ? me.right - pixel : pixel - me.left;
        } else {
          innerDimension = me.height;
          value = reverse ? pixel - me.top : me.bottom - pixel;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            var offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            value -= offset;
            innerDimension -= offset;
            start = firstTickValue;
          }

          value *= log10(end) - log10(start);
          value /= innerDimension;
          value = Math.pow(10, log10(start) + value);
        }

        return value;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$2 = defaultConfig$2;
    scale_logarithmic._defaults = _defaults$2;
    var valueOrDefault$b = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
    var resolve$7 = helpers$1.options.resolve;
    var defaultConfig$3 = {
      display: true,
      // Boolean - Whether to animate scaling the chart from the centre
      animate: true,
      position: 'chartArea',
      angleLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0.0
      },
      gridLines: {
        circular: false
      },
      // label settings
      ticks: {
        // Boolean - Show a backdrop to the scale label
        showLabelBackdrop: true,
        // String - The colour of the label backdrop
        backdropColor: 'rgba(255,255,255,0.75)',
        // Number - The backdrop padding above & below the label in pixels
        backdropPaddingY: 2,
        // Number - The backdrop padding to the side of the label in pixels
        backdropPaddingX: 2,
        callback: core_ticks.formatters.linear
      },
      pointLabels: {
        // Boolean - if true, show point labels
        display: true,
        // Number - Point label font size in pixels
        fontSize: 10,
        // Function - Used to convert point labels
        callback: function (label) {
          return label;
        }
      }
    };

    function getValueCount(scale) {
      var opts = scale.options;
      return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
    }

    function getTickBackdropHeight(opts) {
      var tickOpts = opts.ticks;

      if (tickOpts.display && opts.display) {
        return valueOrDefault$b(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
      }

      return 0;
    }

    function measureLabelSize(ctx, lineHeight, label) {
      if (helpers$1.isArray(label)) {
        return {
          w: helpers$1.longestText(ctx, ctx.font, label),
          h: label.length * lineHeight
        };
      }

      return {
        w: ctx.measureText(label).width,
        h: lineHeight
      };
    }

    function determineLimits(angle, pos, size, min, max) {
      if (angle === min || angle === max) {
        return {
          start: pos - size / 2,
          end: pos + size / 2
        };
      } else if (angle < min || angle > max) {
        return {
          start: pos - size,
          end: pos
        };
      }

      return {
        start: pos,
        end: pos + size
      };
    }
    /**
     * Helper function to fit a radial linear scale with point labels
     */


    function fitWithPointLabels(scale) {
      // Right, this is really confusing and there is a lot of maths going on here
      // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
      //
      // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
      //
      // Solution:
      //
      // We assume the radius of the polygon is half the size of the canvas at first
      // at each index we check if the text overlaps.
      //
      // Where it does, we store that angle and that index.
      //
      // After finding the largest index and angle we calculate how much we need to remove
      // from the shape radius to move the point inwards by that x.
      //
      // We average the left and right distances to get the maximum shape radius that can fit in the box
      // along with labels.
      //
      // Once we have that, we can find the centre point for the chart, by taking the x text protrusion
      // on each side, removing that from the size, halving it and adding the left x protrusion width.
      //
      // This will mean we have a shape fitted to the canvas, as large as it can be with the labels
      // and position it in the most space efficient manner
      //
      // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
      var plFont = helpers$1.options._parseFont(scale.options.pointLabels); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
      // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points


      var furthestLimits = {
        l: 0,
        r: scale.width,
        t: 0,
        b: scale.height - scale.paddingTop
      };
      var furthestAngles = {};
      var i, textSize, pointPosition;
      scale.ctx.font = plFont.string;
      scale._pointLabelSizes = [];
      var valueCount = getValueCount(scale);

      for (i = 0; i < valueCount; i++) {
        pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
        textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');
        scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle

        var angleRadians = scale.getIndexAngle(i);
        var angle = helpers$1.toDegrees(angleRadians) % 360;
        var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

        if (hLimits.start < furthestLimits.l) {
          furthestLimits.l = hLimits.start;
          furthestAngles.l = angleRadians;
        }

        if (hLimits.end > furthestLimits.r) {
          furthestLimits.r = hLimits.end;
          furthestAngles.r = angleRadians;
        }

        if (vLimits.start < furthestLimits.t) {
          furthestLimits.t = vLimits.start;
          furthestAngles.t = angleRadians;
        }

        if (vLimits.end > furthestLimits.b) {
          furthestLimits.b = vLimits.end;
          furthestAngles.b = angleRadians;
        }
      }

      scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
    }

    function getTextAlignForAngle(angle) {
      if (angle === 0 || angle === 180) {
        return 'center';
      } else if (angle < 180) {
        return 'left';
      }

      return 'right';
    }

    function fillText(ctx, text, position, lineHeight) {
      var y = position.y + lineHeight / 2;
      var i, ilen;

      if (helpers$1.isArray(text)) {
        for (i = 0, ilen = text.length; i < ilen; ++i) {
          ctx.fillText(text[i], position.x, y);
          y += lineHeight;
        }
      } else {
        ctx.fillText(text, position.x, y);
      }
    }

    function adjustPointPositionForLabelHeight(angle, textSize, position) {
      if (angle === 90 || angle === 270) {
        position.y -= textSize.h / 2;
      } else if (angle > 270 || angle < 90) {
        position.y -= textSize.h;
      }
    }

    function drawPointLabels(scale) {
      var ctx = scale.ctx;
      var opts = scale.options;
      var angleLineOpts = opts.angleLines;
      var gridLineOpts = opts.gridLines;
      var pointLabelOpts = opts.pointLabels;
      var lineWidth = valueOrDefault$b(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
      var lineColor = valueOrDefault$b(angleLineOpts.color, gridLineOpts.color);
      var tickBackdropHeight = getTickBackdropHeight(opts);
      ctx.save();
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = lineColor;

      if (ctx.setLineDash) {
        ctx.setLineDash(resolve$7([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
        ctx.lineDashOffset = resolve$7([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);
      }

      var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max); // Point Label Font

      var plFont = helpers$1.options._parseFont(pointLabelOpts);

      ctx.font = plFont.string;
      ctx.textBaseline = 'middle';

      for (var i = getValueCount(scale) - 1; i >= 0; i--) {
        if (angleLineOpts.display && lineWidth && lineColor) {
          var outerPosition = scale.getPointPosition(i, outerDistance);
          ctx.beginPath();
          ctx.moveTo(scale.xCenter, scale.yCenter);
          ctx.lineTo(outerPosition.x, outerPosition.y);
          ctx.stroke();
        }

        if (pointLabelOpts.display) {
          // Extra pixels out for some label spacing
          var extra = i === 0 ? tickBackdropHeight / 2 : 0;
          var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5); // Keep this in loop since we may support array properties here

          var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
          ctx.fillStyle = pointLabelFontColor;
          var angleRadians = scale.getIndexAngle(i);
          var angle = helpers$1.toDegrees(angleRadians);
          ctx.textAlign = getTextAlignForAngle(angle);
          adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
          fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);
        }
      }

      ctx.restore();
    }

    function drawRadiusLine(scale, gridLineOpts, radius, index) {
      var ctx = scale.ctx;
      var circular = gridLineOpts.circular;
      var valueCount = getValueCount(scale);
      var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
      var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
      var pointPosition;

      if (!circular && !valueCount || !lineColor || !lineWidth) {
        return;
      }

      ctx.save();
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = lineWidth;

      if (ctx.setLineDash) {
        ctx.setLineDash(gridLineOpts.borderDash || []);
        ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;
      }

      ctx.beginPath();

      if (circular) {
        // Draw circular arcs between the points
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
      } else {
        // Draw straight lines connecting each index
        pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);

        for (var i = 1; i < valueCount; i++) {
          pointPosition = scale.getPointPosition(i, radius);
          ctx.lineTo(pointPosition.x, pointPosition.y);
        }
      }

      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    function numberOrZero(param) {
      return helpers$1.isNumber(param) ? param : 0;
    }

    var scale_radialLinear = scale_linearbase.extend({
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        me.width = me.maxWidth;
        me.height = me.maxHeight;
        me.paddingTop = getTickBackdropHeight(me.options) / 2;
        me.xCenter = Math.floor(me.width / 2);
        me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
        me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var min = Number.POSITIVE_INFINITY;
        var max = Number.NEGATIVE_INFINITY;
        helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {
          if (chart.isDatasetVisible(datasetIndex)) {
            var meta = chart.getDatasetMeta(datasetIndex);
            helpers$1.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue);

              if (isNaN(value) || meta.data[index].hidden) {
                return;
              }

              min = Math.min(value, min);
              max = Math.max(value, max);
            });
          }
        });
        me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
        me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        me.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
      },
      convertTicksToLabels: function () {
        var me = this;
        scale_linearbase.prototype.convertTicksToLabels.call(me); // Point labels

        me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      fit: function () {
        var me = this;
        var opts = me.options;

        if (opts.display && opts.pointLabels.display) {
          fitWithPointLabels(me);
        } else {
          me.setCenterPoint(0, 0, 0, 0);
        }
      },

      /**
       * Set radius reductions and determine new radius and center point
       * @private
       */
      setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {
        var me = this;
        var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
        var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
        var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
        var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
        radiusReductionLeft = numberOrZero(radiusReductionLeft);
        radiusReductionRight = numberOrZero(radiusReductionRight);
        radiusReductionTop = numberOrZero(radiusReductionTop);
        radiusReductionBottom = numberOrZero(radiusReductionBottom);
        me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
        me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
      },
      setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {
        var me = this;
        var maxRight = me.width - rightMovement - me.drawingArea;
        var maxLeft = leftMovement + me.drawingArea;
        var maxTop = topMovement + me.drawingArea;
        var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
        me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
        me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
      },
      getIndexAngle: function (index) {
        var angleMultiplier = Math.PI * 2 / getValueCount(this);
        var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
        var startAngleRadians = startAngle * Math.PI * 2 / 360; // Start from the top instead of right, so remove a quarter of the circle

        return index * angleMultiplier + startAngleRadians;
      },
      getDistanceFromCenterForValue: function (value) {
        var me = this;

        if (value === null) {
          return 0; // null always in center
        } // Take into account half font size + the yPadding of the top value


        var scalingFactor = me.drawingArea / (me.max - me.min);

        if (me.options.ticks.reverse) {
          return (me.max - value) * scalingFactor;
        }

        return (value - me.min) * scalingFactor;
      },
      getPointPosition: function (index, distanceFromCenter) {
        var me = this;
        var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
        return {
          x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
          y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
        };
      },
      getPointPositionForValue: function (index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
      },
      getBasePosition: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
      },
      draw: function () {
        var me = this;
        var opts = me.options;
        var gridLineOpts = opts.gridLines;
        var tickOpts = opts.ticks;

        if (opts.display) {
          var ctx = me.ctx;
          var startAngle = this.getIndexAngle(0);

          var tickFont = helpers$1.options._parseFont(tickOpts);

          if (opts.angleLines.display || opts.pointLabels.display) {
            drawPointLabels(me);
          }

          helpers$1.each(me.ticks, function (label, index) {
            // Don't draw a centre value (if it is minimum)
            if (index > 0 || tickOpts.reverse) {
              var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]); // Draw circular lines around the scale

              if (gridLineOpts.display && index !== 0) {
                drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
              }

              if (tickOpts.display) {
                var tickFontColor = valueOrDefault$b(tickOpts.fontColor, core_defaults.global.defaultFontColor);
                ctx.font = tickFont.string;
                ctx.save();
                ctx.translate(me.xCenter, me.yCenter);
                ctx.rotate(startAngle);

                if (tickOpts.showLabelBackdrop) {
                  var labelWidth = ctx.measureText(label).width;
                  ctx.fillStyle = tickOpts.backdropColor;
                  ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
                }

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = tickFontColor;
                ctx.fillText(label, 0, -yCenterOffset);
                ctx.restore();
              }
            }
          });
        }
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$3 = defaultConfig$3;
    scale_radialLinear._defaults = _defaults$3;
    var valueOrDefault$c = helpers$1.valueOrDefault; // Integer constants are from the ES6 spec.

    var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var INTERVALS = {
      millisecond: {
        common: true,
        size: 1,
        steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
      },
      second: {
        common: true,
        size: 1000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      minute: {
        common: true,
        size: 60000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      hour: {
        common: true,
        size: 3600000,
        steps: [1, 2, 3, 6, 12]
      },
      day: {
        common: true,
        size: 86400000,
        steps: [1, 2, 5]
      },
      week: {
        common: false,
        size: 604800000,
        steps: [1, 2, 3, 4]
      },
      month: {
        common: true,
        size: 2.628e9,
        steps: [1, 2, 3]
      },
      quarter: {
        common: false,
        size: 7.884e9,
        steps: [1, 2, 3, 4]
      },
      year: {
        common: true,
        size: 3.154e10
      }
    };
    var UNITS = Object.keys(INTERVALS);

    function sorter(a, b) {
      return a - b;
    }

    function arrayUnique(items) {
      var hash = {};
      var out = [];
      var i, ilen, item;

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];

        if (!hash[item]) {
          hash[item] = true;
          out.push(item);
        }
      }

      return out;
    }
    /**
     * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
     * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
     * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
     * extremity (left + width or top + height). Note that it would be more optimized to directly
     * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
     * to create the lookup table. The table ALWAYS contains at least two items: min and max.
     *
     * @param {number[]} timestamps - timestamps sorted from lowest to highest.
     * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min
     * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
     * If 'series', timestamps will be positioned at the same distance from each other. In this
     * case, only timestamps that break the time linearity are registered, meaning that in the
     * best case, all timestamps are linear, the table contains only min and max.
     */


    function buildLookupTable(timestamps, min, max, distribution) {
      if (distribution === 'linear' || !timestamps.length) {
        return [{
          time: min,
          pos: 0
        }, {
          time: max,
          pos: 1
        }];
      }

      var table = [];
      var items = [min];
      var i, ilen, prev, curr, next;

      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];

        if (curr > min && curr < max) {
          items.push(curr);
        }
      }

      items.push(max);

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i]; // only add points that breaks the scale linearity

        if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }

      return table;
    } // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/


    function lookup(table, key, value) {
      var lo = 0;
      var hi = table.length - 1;
      var mid, i0, i1;

      while (lo >= 0 && lo <= hi) {
        mid = lo + hi >> 1;
        i0 = table[mid - 1] || null;
        i1 = table[mid];

        if (!i0) {
          // given value is outside table (before first item)
          return {
            lo: null,
            hi: i1
          };
        } else if (i1[key] < value) {
          lo = mid + 1;
        } else if (i0[key] > value) {
          hi = mid - 1;
        } else {
          return {
            lo: i0,
            hi: i1
          };
        }
      } // given value is outside table (after last item)


      return {
        lo: i1,
        hi: null
      };
    }
    /**
     * Linearly interpolates the given source `value` using the table items `skey` values and
     * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
     * returns the position for a timestamp equal to 42. If value is out of bounds, values at
     * index [0, 1] or [n - 1, n] are used for the interpolation.
     */


    function interpolate$1(table, skey, sval, tkey) {
      var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)

      var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
      var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
      var span = next[skey] - prev[skey];
      var ratio = span ? (sval - prev[skey]) / span : 0;
      var offset = (next[tkey] - prev[tkey]) * ratio;
      return prev[tkey] + offset;
    }

    function toTimestamp(scale, input) {
      var adapter = scale._adapter;
      var options = scale.options.time;
      var parser = options.parser;
      var format = parser || options.format;
      var value = input;

      if (typeof parser === 'function') {
        value = parser(value);
      } // Only parse if its not a timestamp already


      if (!helpers$1.isFinite(value)) {
        value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);
      }

      if (value !== null) {
        return +value;
      } // Labels are in an incompatible format and no `parser` has been provided.
      // The user might still use the deprecated `format` option for parsing.


      if (!parser && typeof format === 'function') {
        value = format(input); // `format` could return something else than a timestamp, if so, parse it

        if (!helpers$1.isFinite(value)) {
          value = adapter.parse(value);
        }
      }

      return value;
    }

    function parse(scale, input) {
      if (helpers$1.isNullOrUndef(input)) {
        return null;
      }

      var options = scale.options.time;
      var value = toTimestamp(scale, scale.getRightValue(input));

      if (value === null) {
        return value;
      }

      if (options.round) {
        value = +scale._adapter.startOf(value, options.round);
      }

      return value;
    }
    /**
     * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
     * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
     */


    function determineStepSize(min, max, unit, capacity) {
      var range = max - min;
      var interval = INTERVALS[unit];
      var milliseconds = interval.size;
      var steps = interval.steps;
      var i, ilen, factor;

      if (!steps) {
        return Math.ceil(range / (capacity * milliseconds));
      }

      for (i = 0, ilen = steps.length; i < ilen; ++i) {
        factor = steps[i];

        if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
          break;
        }
      }

      return factor;
    }
    /**
     * Figures out what unit results in an appropriate number of auto-generated ticks
     */


    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      var ilen = UNITS.length;
      var i, interval, factor;

      for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
        interval = INTERVALS[UNITS[i]];
        factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
          return UNITS[i];
        }
      }

      return UNITS[ilen - 1];
    }
    /**
     * Figures out what unit to format a set of ticks with
     */


    function determineUnitForFormatting(scale, ticks, minUnit, min, max) {
      var ilen = UNITS.length;
      var i, unit;

      for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
        unit = UNITS[i];

        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {
          return unit;
        }
      }

      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }

    function determineMajorUnit(unit) {
      for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
        if (INTERVALS[UNITS[i]].common) {
          return UNITS[i];
        }
      }
    }
    /**
     * Generates a maximum of `capacity` timestamps between min and max, rounded to the
     * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
     * Important: this method can return ticks outside the min and max range, it's the
     * responsibility of the calling code to clamp values if needed.
     */


    function generate(scale, min, max, capacity) {
      var adapter = scale._adapter;
      var options = scale.options;
      var timeOpts = options.time;
      var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
      var major = determineMajorUnit(minor);
      var stepSize = valueOrDefault$c(timeOpts.stepSize, timeOpts.unitStepSize);
      var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
      var majorTicksEnabled = options.ticks.major.enabled;
      var interval = INTERVALS[minor];
      var first = min;
      var last = max;
      var ticks = [];
      var time;

      if (!stepSize) {
        stepSize = determineStepSize(min, max, minor, capacity);
      } // For 'week' unit, handle the first day of week option


      if (weekday) {
        first = +adapter.startOf(first, 'isoWeek', weekday);
        last = +adapter.startOf(last, 'isoWeek', weekday);
      } // Align first/last ticks on unit


      first = +adapter.startOf(first, weekday ? 'day' : minor);
      last = +adapter.startOf(last, weekday ? 'day' : minor); // Make sure that the last tick include max

      if (last < max) {
        last = +adapter.add(last, 1, minor);
      }

      time = first;

      if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
        // Align the first tick on the previous `minor` unit aligned on the `major` unit:
        // we first aligned time on the previous `major` unit then add the number of full
        // stepSize there is between first and the previous major time.
        time = +adapter.startOf(time, major);
        time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
      }

      for (; time < last; time = +adapter.add(time, stepSize, minor)) {
        ticks.push(+time);
      }

      ticks.push(+time);
      return ticks;
    }
    /**
     * Returns the start and end offsets from edges in the form of {start, end}
     * where each value is a relative width to the scale and ranges between 0 and 1.
     * They add extra margins on the both sides by scaling down the original scale.
     * Offsets are added when the `offset` option is true.
     */


    function computeOffsets(table, ticks, min, max, options) {
      var start = 0;
      var end = 0;
      var first, last;

      if (options.offset && ticks.length) {
        if (!options.time.min) {
          first = interpolate$1(table, 'time', ticks[0], 'pos');

          if (ticks.length === 1) {
            start = 1 - first;
          } else {
            start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;
          }
        }

        if (!options.time.max) {
          last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');

          if (ticks.length === 1) {
            end = last;
          } else {
            end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;
          }
        }
      }

      return {
        start: start,
        end: end
      };
    }

    function ticksFromTimestamps(scale, values, majorUnit) {
      var ticks = [];
      var i, ilen, value, major;

      for (i = 0, ilen = values.length; i < ilen; ++i) {
        value = values[i];
        major = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;
        ticks.push({
          value: value,
          major: major
        });
      }

      return ticks;
    }

    var defaultConfig$4 = {
      position: 'bottom',

      /**
       * Data distribution along the scale:
       * - 'linear': data are spread according to their time (distances can vary),
       * - 'series': data are spread at the same distance from each other.
       * @see https://github.com/chartjs/Chart.js/pull/4507
       * @since 2.7.0
       */
      distribution: 'linear',

      /**
       * Scale boundary strategy (bypassed by min/max time options)
       * - `data`: make sure data are fully visible, ticks outside are removed
       * - `ticks`: make sure ticks are fully visible, data outside are truncated
       * @see https://github.com/chartjs/Chart.js/pull/4556
       * @since 2.7.0
       */
      bounds: 'data',
      adapters: {},
      time: {
        parser: false,
        // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
        format: false,
        // DEPRECATED false == date objects, moment object, callback or a pattern string from https://momentjs.com/docs/#/parsing/string-format/
        unit: false,
        // false == automatic or override with week, month, year, etc.
        round: false,
        // none, or override with week, month, year, etc.
        displayFormat: false,
        // DEPRECATED
        isoWeekday: false,
        // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
        minUnit: 'millisecond',
        displayFormats: {}
      },
      ticks: {
        autoSkip: false,

        /**
         * Ticks generation input values:
         * - 'auto': generates "optimal" ticks based on scale size and time options.
         * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
         * - 'labels': generates ticks from user given `data.labels` values ONLY.
         * @see https://github.com/chartjs/Chart.js/pull/4507
         * @since 2.7.0
         */
        source: 'auto',
        major: {
          enabled: false
        }
      }
    };
    var scale_time = core_scale.extend({
      initialize: function () {
        this.mergeTicksOptions();
        core_scale.prototype.initialize.call(this);
      },
      update: function () {
        var me = this;
        var options = me.options;
        var time = options.time || (options.time = {});
        var adapter = me._adapter = new core_adapters._date(options.adapters.date); // DEPRECATIONS: output a message only one time per update

        if (time.format) {
          console.warn('options.time.format is deprecated and replaced by options.time.parser.');
        } // Backward compatibility: before introducing adapter, `displayFormats` was
        // supposed to contain *all* unit/string pairs but this can't be resolved
        // when loading the scale (adapters are loaded afterward), so let's populate
        // missing formats on update


        helpers$1.mergeIf(time.displayFormats, adapter.formats());
        return core_scale.prototype.update.apply(me, arguments);
      },

      /**
       * Allows data to be referenced via 't' attribute
       */
      getRightValue: function (rawValue) {
        if (rawValue && rawValue.t !== undefined) {
          rawValue = rawValue.t;
        }

        return core_scale.prototype.getRightValue.call(this, rawValue);
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var adapter = me._adapter;
        var timeOpts = me.options.time;
        var unit = timeOpts.unit || 'day';
        var min = MAX_INTEGER;
        var max = MIN_INTEGER;
        var timestamps = [];
        var datasets = [];
        var labels = [];
        var i, j, ilen, jlen, data, timestamp;
        var dataLabels = chart.data.labels || []; // Convert labels to timestamps

        for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
          labels.push(parse(me, dataLabels[i]));
        } // Convert data to timestamps


        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            data = chart.data.datasets[i].data; // Let's consider that all data have the same format.

            if (helpers$1.isObject(data[0])) {
              datasets[i] = [];

              for (j = 0, jlen = data.length; j < jlen; ++j) {
                timestamp = parse(me, data[j]);
                timestamps.push(timestamp);
                datasets[i][j] = timestamp;
              }
            } else {
              for (j = 0, jlen = labels.length; j < jlen; ++j) {
                timestamps.push(labels[j]);
              }

              datasets[i] = labels.slice(0);
            }
          } else {
            datasets[i] = [];
          }
        }

        if (labels.length) {
          // Sort labels **after** data have been converted
          labels = arrayUnique(labels).sort(sorter);
          min = Math.min(min, labels[0]);
          max = Math.max(max, labels[labels.length - 1]);
        }

        if (timestamps.length) {
          timestamps = arrayUnique(timestamps).sort(sorter);
          min = Math.min(min, timestamps[0]);
          max = Math.max(max, timestamps[timestamps.length - 1]);
        }

        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // In case there is no valid min/max, set limits based on unit time option

        min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
        max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)

        me.min = Math.min(min, max);
        me.max = Math.max(min + 1, max); // PRIVATE

        me._horizontal = me.isHorizontal();
        me._table = [];
        me._timestamps = {
          data: timestamps,
          datasets: datasets,
          labels: labels
        };
      },
      buildTicks: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        var options = me.options;
        var timeOpts = options.time;
        var timestamps = [];
        var ticks = [];
        var i, ilen, timestamp;

        switch (options.ticks.source) {
          case 'data':
            timestamps = me._timestamps.data;
            break;

          case 'labels':
            timestamps = me._timestamps.labels;
            break;

          case 'auto':
          default:
            timestamps = generate(me, min, max, me.getLabelCapacity(min), options);
        }

        if (options.bounds === 'ticks' && timestamps.length) {
          min = timestamps[0];
          max = timestamps[timestamps.length - 1];
        } // Enforce limits with user min/max options


        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // Remove ticks outside the min/max range

        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
          timestamp = timestamps[i];

          if (timestamp >= min && timestamp <= max) {
            ticks.push(timestamp);
          }
        }

        me.min = min;
        me.max = max; // PRIVATE

        me._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);
        me._majorUnit = determineMajorUnit(me._unit);
        me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
        me._offsets = computeOffsets(me._table, ticks, min, max, options);

        if (options.ticks.reverse) {
          ticks.reverse();
        }

        return ticksFromTimestamps(me, ticks, me._majorUnit);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var adapter = me._adapter;
        var data = me.chart.data;
        var timeOpts = me.options.time;
        var label = data.labels && index < data.labels.length ? data.labels[index] : '';
        var value = data.datasets[datasetIndex].data[index];

        if (helpers$1.isObject(value)) {
          label = me.getRightValue(value);
        }

        if (timeOpts.tooltipFormat) {
          return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
        }

        if (typeof label === 'string') {
          return label;
        }

        return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
      },

      /**
       * Function to format an individual tick mark
       * @private
       */
      tickFormatFunction: function (time, index, ticks, format) {
        var me = this;
        var adapter = me._adapter;
        var options = me.options;
        var formats = options.time.displayFormats;
        var minorFormat = formats[me._unit];
        var majorUnit = me._majorUnit;
        var majorFormat = formats[majorUnit];
        var majorTime = +adapter.startOf(time, majorUnit);
        var majorTickOpts = options.ticks.major;
        var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
        var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
        var tickOpts = major ? majorTickOpts : options.ticks.minor;
        var formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);
        return formatter ? formatter(label, index, ticks) : label;
      },
      convertTicksToLabels: function (ticks) {
        var labels = [];
        var i, ilen;

        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
        }

        return labels;
      },

      /**
       * @private
       */
      getPixelForOffset: function (time) {
        var me = this;
        var isReverse = me.options.ticks.reverse;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;
        var pos = interpolate$1(me._table, 'time', time, 'pos');
        var offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);
        return isReverse ? start - offset : start + offset;
      },
      getPixelForValue: function (value, index, datasetIndex) {
        var me = this;
        var time = null;

        if (index !== undefined && datasetIndex !== undefined) {
          time = me._timestamps.datasets[datasetIndex][index];
        }

        if (time === null) {
          time = parse(me, value);
        }

        if (time !== null) {
          return me.getPixelForOffset(time);
        }
      },
      getPixelForTick: function (index) {
        var ticks = this.getTicks();
        return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? me.left : me.top;
        var pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;
        var time = interpolate$1(me._table, 'pos', pos, 'time'); // DEPRECATION, we should return time directly

        return me._adapter._create(time);
      },

      /**
       * Crude approximation of what the label width might be
       * @private
       */
      getLabelWidth: function (label) {
        var me = this;
        var ticksOpts = me.options.ticks;
        var tickLabelWidth = me.ctx.measureText(label).width;
        var angle = helpers$1.toRadians(ticksOpts.maxRotation);
        var cosRotation = Math.cos(angle);
        var sinRotation = Math.sin(angle);
        var tickFontSize = valueOrDefault$c(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
        return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
      },

      /**
       * @private
       */
      getLabelCapacity: function (exampleTime) {
        var me = this; // pick the longest format (milliseconds) for guestimation

        var format = me.options.time.displayFormats.millisecond;
        var exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);
        var tickLabelWidth = me.getLabelWidth(exampleLabel);
        var innerWidth = me.isHorizontal() ? me.width : me.height;
        var capacity = Math.floor(innerWidth / tickLabelWidth);
        return capacity > 0 ? capacity : 1;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$4 = defaultConfig$4;
    scale_time._defaults = _defaults$4;
    var scales = {
      category: scale_category,
      linear: scale_linear,
      logarithmic: scale_logarithmic,
      radialLinear: scale_radialLinear,
      time: scale_time
    };
    var FORMATS = {
      datetime: 'MMM D, YYYY, h:mm:ss a',
      millisecond: 'h:mm:ss.SSS a',
      second: 'h:mm:ss a',
      minute: 'h:mm a',
      hour: 'hA',
      day: 'MMM D',
      week: 'll',
      month: 'MMM YYYY',
      quarter: '[Q]Q - YYYY',
      year: 'YYYY'
    };

    core_adapters._date.override(typeof moment === 'function' ? {
      _id: 'moment',
      // DEBUG ONLY
      formats: function () {
        return FORMATS;
      },
      parse: function (value, format) {
        if (typeof value === 'string' && typeof format === 'string') {
          value = moment(value, format);
        } else if (!(value instanceof moment)) {
          value = moment(value);
        }

        return value.isValid() ? value.valueOf() : null;
      },
      format: function (time, format) {
        return moment(time).format(format);
      },
      add: function (time, amount, unit) {
        return moment(time).add(amount, unit).valueOf();
      },
      diff: function (max, min, unit) {
        return moment.duration(moment(max).diff(moment(min))).as(unit);
      },
      startOf: function (time, unit, weekday) {
        time = moment(time);

        if (unit === 'isoWeek') {
          return time.isoWeekday(weekday).valueOf();
        }

        return time.startOf(unit).valueOf();
      },
      endOf: function (time, unit) {
        return moment(time).endOf(unit).valueOf();
      },
      // DEPRECATIONS

      /**
       * Provided for backward compatibility with scale.getValueForPixel().
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (time) {
        return moment(time);
      }
    } : {});

    core_defaults._set('global', {
      plugins: {
        filler: {
          propagate: true
        }
      }
    });

    var mappers = {
      dataset: function (source) {
        var index = source.fill;
        var chart = source.chart;
        var meta = chart.getDatasetMeta(index);
        var visible = meta && chart.isDatasetVisible(index);
        var points = visible && meta.dataset._children || [];
        var length = points.length || 0;
        return !length ? null : function (point, i) {
          return i < length && points[i]._view || null;
        };
      },
      boundary: function (source) {
        var boundary = source.boundary;
        var x = boundary ? boundary.x : null;
        var y = boundary ? boundary.y : null;
        return function (point) {
          return {
            x: x === null ? point.x : x,
            y: y === null ? point.y : y
          };
        };
      }
    }; // @todo if (fill[0] === '#')

    function decodeFill(el, index, count) {
      var model = el._model || {};
      var fill = model.fill;
      var target;

      if (fill === undefined) {
        fill = !!model.backgroundColor;
      }

      if (fill === false || fill === null) {
        return false;
      }

      if (fill === true) {
        return 'origin';
      }

      target = parseFloat(fill, 10);

      if (isFinite(target) && Math.floor(target) === target) {
        if (fill[0] === '-' || fill[0] === '+') {
          target = index + target;
        }

        if (target === index || target < 0 || target >= count) {
          return false;
        }

        return target;
      }

      switch (fill) {
        // compatibility
        case 'bottom':
          return 'start';

        case 'top':
          return 'end';

        case 'zero':
          return 'origin';
        // supported boundaries

        case 'origin':
        case 'start':
        case 'end':
          return fill;
        // invalid fill values

        default:
          return false;
      }
    }

    function computeBoundary(source) {
      var model = source.el._model || {};
      var scale = source.el._scale || {};
      var fill = source.fill;
      var target = null;
      var horizontal;

      if (isFinite(fill)) {
        return null;
      } // Backward compatibility: until v3, we still need to support boundary values set on
      // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
      // controllers might still use it (e.g. the Smith chart).


      if (fill === 'start') {
        target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
      } else if (fill === 'end') {
        target = model.scaleTop === undefined ? scale.top : model.scaleTop;
      } else if (model.scaleZero !== undefined) {
        target = model.scaleZero;
      } else if (scale.getBasePosition) {
        target = scale.getBasePosition();
      } else if (scale.getBasePixel) {
        target = scale.getBasePixel();
      }

      if (target !== undefined && target !== null) {
        if (target.x !== undefined && target.y !== undefined) {
          return target;
        }

        if (helpers$1.isFinite(target)) {
          horizontal = scale.isHorizontal();
          return {
            x: horizontal ? target : null,
            y: horizontal ? null : target
          };
        }
      }

      return null;
    }

    function resolveTarget(sources, index, propagate) {
      var source = sources[index];
      var fill = source.fill;
      var visited = [index];
      var target;

      if (!propagate) {
        return fill;
      }

      while (fill !== false && visited.indexOf(fill) === -1) {
        if (!isFinite(fill)) {
          return fill;
        }

        target = sources[fill];

        if (!target) {
          return false;
        }

        if (target.visible) {
          return fill;
        }

        visited.push(fill);
        fill = target.fill;
      }

      return false;
    }

    function createMapper(source) {
      var fill = source.fill;
      var type = 'dataset';

      if (fill === false) {
        return null;
      }

      if (!isFinite(fill)) {
        type = 'boundary';
      }

      return mappers[type](source);
    }

    function isDrawable(point) {
      return point && !point.skip;
    }

    function drawArea(ctx, curve0, curve1, len0, len1) {
      var i;

      if (!len0 || !len1) {
        return;
      } // building first area curve (normal)


      ctx.moveTo(curve0[0].x, curve0[0].y);

      for (i = 1; i < len0; ++i) {
        helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
      } // joining the two area curves


      ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)

      for (i = len1 - 1; i > 0; --i) {
        helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
      }
    }

    function doFill(ctx, points, mapper, view, color, loop) {
      var count = points.length;
      var span = view.spanGaps;
      var curve0 = [];
      var curve1 = [];
      var len0 = 0;
      var len1 = 0;
      var i, ilen, index, p0, p1, d0, d1;
      ctx.beginPath();

      for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
        index = i % count;
        p0 = points[index]._view;
        p1 = mapper(p0, index, view);
        d0 = isDrawable(p0);
        d1 = isDrawable(p1);

        if (d0 && d1) {
          len0 = curve0.push(p0);
          len1 = curve1.push(p1);
        } else if (len0 && len1) {
          if (!span) {
            drawArea(ctx, curve0, curve1, len0, len1);
            len0 = len1 = 0;
            curve0 = [];
            curve1 = [];
          } else {
            if (d0) {
              curve0.push(p0);
            }

            if (d1) {
              curve1.push(p1);
            }
          }
        }
      }

      drawArea(ctx, curve0, curve1, len0, len1);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    var plugin_filler = {
      id: 'filler',
      afterDatasetsUpdate: function (chart, options) {
        var count = (chart.data.datasets || []).length;
        var propagate = options.propagate;
        var sources = [];
        var meta, i, el, source;

        for (i = 0; i < count; ++i) {
          meta = chart.getDatasetMeta(i);
          el = meta.dataset;
          source = null;

          if (el && el._model && el instanceof elements.Line) {
            source = {
              visible: chart.isDatasetVisible(i),
              fill: decodeFill(el, i, count),
              chart: chart,
              el: el
            };
          }

          meta.$filler = source;
          sources.push(source);
        }

        for (i = 0; i < count; ++i) {
          source = sources[i];

          if (!source) {
            continue;
          }

          source.fill = resolveTarget(sources, i, propagate);
          source.boundary = computeBoundary(source);
          source.mapper = createMapper(source);
        }
      },
      beforeDatasetDraw: function (chart, args) {
        var meta = args.meta.$filler;

        if (!meta) {
          return;
        }

        var ctx = chart.ctx;
        var el = meta.el;
        var view = el._view;
        var points = el._children || [];
        var mapper = meta.mapper;
        var color = view.backgroundColor || core_defaults.global.defaultColor;

        if (mapper && color && points.length) {
          helpers$1.canvas.clipArea(ctx, chart.chartArea);
          doFill(ctx, points, mapper, view, color, el._loop);
          helpers$1.canvas.unclipArea(ctx);
        }
      }
    };
    var noop$1 = helpers$1.noop;
    var valueOrDefault$d = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      legend: {
        display: true,
        position: 'top',
        fullWidth: true,
        reverse: false,
        weight: 1000,
        // a callback that will handle
        onClick: function (e, legendItem) {
          var index = legendItem.datasetIndex;
          var ci = this.chart;
          var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment

          meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart

          ci.update();
        },
        onHover: null,
        onLeave: null,
        labels: {
          boxWidth: 40,
          padding: 10,
          // Generates labels shown in the legend
          // Valid properties to return:
          // text : text to display
          // fillStyle : fill of coloured box
          // strokeStyle: stroke of coloured box
          // hidden : if this legend item refers to a hidden item
          // lineCap : cap style for line
          // lineDash
          // lineDashOffset :
          // lineJoin :
          // lineWidth :
          generateLabels: function (chart) {
            var data = chart.data;
            return helpers$1.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
              return {
                text: dataset.label,
                fillStyle: !helpers$1.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
                hidden: !chart.isDatasetVisible(i),
                lineCap: dataset.borderCapStyle,
                lineDash: dataset.borderDash,
                lineDashOffset: dataset.borderDashOffset,
                lineJoin: dataset.borderJoinStyle,
                lineWidth: dataset.borderWidth,
                strokeStyle: dataset.borderColor,
                pointStyle: dataset.pointStyle,
                // Below is extra data used for toggling the datasets
                datasetIndex: i
              };
            }, this) : [];
          }
        }
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');

        for (var i = 0; i < chart.data.datasets.length; i++) {
          text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');

          if (chart.data.datasets[i].label) {
            text.push(chart.data.datasets[i].label);
          }

          text.push('</li>');
        }

        text.push('</ul>');
        return text.join('');
      }
    });
    /**
     * Helper function to get the box width based on the usePointStyle option
     * @param {object} labelopts - the label options on the legend
     * @param {number} fontSize - the label font size
     * @return {number} width of the color box area
     */


    function getBoxWidth(labelOpts, fontSize) {
      return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
    }
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Legend = core_element.extend({
      initialize: function (config) {
        helpers$1.extend(this, config); // Contains hit boxes for each dataset (in dataset order)

        this.legendHitBoxes = [];
        /**
        	 * @private
        	 */

        this._hoveredItem = null; // Are we in doughnut mode which has a different data type

        this.doughnutMode = false;
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      // Any function defined here is inherited by all legend types.
      // Any function can be extended by the legend type
      beforeUpdate: noop$1,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$1,
      //
      beforeSetDimensions: noop$1,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$1,
      //
      beforeBuildLabels: noop$1,
      buildLabels: function () {
        var me = this;
        var labelOpts = me.options.labels || {};
        var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];

        if (labelOpts.filter) {
          legendItems = legendItems.filter(function (item) {
            return labelOpts.filter(item, me.chart.data);
          });
        }

        if (me.options.reverse) {
          legendItems.reverse();
        }

        me.legendItems = legendItems;
      },
      afterBuildLabels: noop$1,
      //
      beforeFit: noop$1,
      fit: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var display = opts.display;
        var ctx = me.ctx;

        var labelFont = helpers$1.options._parseFont(labelOpts);

        var fontSize = labelFont.size; // Reset hit boxes

        var hitboxes = me.legendHitBoxes = [];
        var minSize = me.minSize;
        var isHorizontal = me.isHorizontal();

        if (isHorizontal) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = display ? 10 : 0;
        } else {
          minSize.width = display ? 10 : 0;
          minSize.height = me.maxHeight; // fill all the height
        } // Increase sizes here


        if (display) {
          ctx.font = labelFont.string;

          if (isHorizontal) {
            // Labels
            // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
            var lineWidths = me.lineWidths = [0];
            var totalHeight = 0;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

              if (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {
                totalHeight += fontSize + labelOpts.padding;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;
              } // Store the hitbox width and height here. Final position will be updated in `draw`


              hitboxes[i] = {
                left: 0,
                top: 0,
                width: width,
                height: fontSize
              };
              lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
            });
            minSize.height += totalHeight;
          } else {
            var vPadding = labelOpts.padding;
            var columnWidths = me.columnWidths = [];
            var totalWidth = labelOpts.padding;
            var currentColWidth = 0;
            var currentColHeight = 0;
            var itemHeight = fontSize + vPadding;
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column

              if (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {
                totalWidth += currentColWidth + labelOpts.padding;
                columnWidths.push(currentColWidth); // previous column width

                currentColWidth = 0;
                currentColHeight = 0;
              } // Get max width


              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`

              hitboxes[i] = {
                left: 0,
                top: 0,
                width: itemWidth,
                height: fontSize
              };
            });
            totalWidth += currentColWidth;
            columnWidths.push(currentColWidth);
            minSize.width += totalWidth;
          }
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$1,
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      // Actually draw the legend on the canvas
      draw: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor;
        var lineDefault = globalDefaults.elements.line;
        var legendWidth = me.width;
        var lineWidths = me.lineWidths;

        if (opts.display) {
          var ctx = me.ctx;
          var fontColor = valueOrDefault$d(labelOpts.fontColor, globalDefaults.defaultFontColor);

          var labelFont = helpers$1.options._parseFont(labelOpts);

          var fontSize = labelFont.size;
          var cursor; // Canvas setup

          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.lineWidth = 0.5;
          ctx.strokeStyle = fontColor; // for strikethrough effect

          ctx.fillStyle = fontColor; // render in correct colour

          ctx.font = labelFont.string;
          var boxWidth = getBoxWidth(labelOpts, fontSize);
          var hitboxes = me.legendHitBoxes; // current position

          var drawLegendBox = function (x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0) {
              return;
            } // Set the ctx for the box


            ctx.save();
            var lineWidth = valueOrDefault$d(legendItem.lineWidth, lineDefault.borderWidth);
            ctx.fillStyle = valueOrDefault$d(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault$d(legendItem.lineCap, lineDefault.borderCapStyle);
            ctx.lineDashOffset = valueOrDefault$d(legendItem.lineDashOffset, lineDefault.borderDashOffset);
            ctx.lineJoin = valueOrDefault$d(legendItem.lineJoin, lineDefault.borderJoinStyle);
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault$d(legendItem.strokeStyle, defaultColor);

            if (ctx.setLineDash) {
              // IE 9 and 10 do not support line dash
              ctx.setLineDash(valueOrDefault$d(legendItem.lineDash, lineDefault.borderDash));
            }

            if (opts.labels && opts.labels.usePointStyle) {
              // Recalculate x and y for drawPoint() because its expecting
              // x and y to be center of figure (instead of top left)
              var radius = boxWidth * Math.SQRT2 / 2;
              var centerX = x + boxWidth / 2;
              var centerY = y + fontSize / 2; // Draw pointStyle as legend symbol

              helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
            } else {
              // Draw box as legend symbol
              if (lineWidth !== 0) {
                ctx.strokeRect(x, y, boxWidth, fontSize);
              }

              ctx.fillRect(x, y, boxWidth, fontSize);
            }

            ctx.restore();
          };

          var fillText = function (x, y, legendItem, textWidth) {
            var halfFontSize = fontSize / 2;
            var xLeft = boxWidth + halfFontSize + x;
            var yMiddle = y + halfFontSize;
            ctx.fillText(legendItem.text, xLeft, yMiddle);

            if (legendItem.hidden) {
              // Strikethrough the text if hidden
              ctx.beginPath();
              ctx.lineWidth = 2;
              ctx.moveTo(xLeft, yMiddle);
              ctx.lineTo(xLeft + textWidth, yMiddle);
              ctx.stroke();
            }
          }; // Horizontal


          var isHorizontal = me.isHorizontal();

          if (isHorizontal) {
            cursor = {
              x: me.left + (legendWidth - lineWidths[0]) / 2 + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          } else {
            cursor = {
              x: me.left + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          }

          var itemHeight = fontSize + labelOpts.padding;
          helpers$1.each(me.legendItems, function (legendItem, i) {
            var textWidth = ctx.measureText(legendItem.text).width;
            var width = boxWidth + fontSize / 2 + textWidth;
            var x = cursor.x;
            var y = cursor.y; // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)
            // instead of me.right and me.bottom because me.width and me.height
            // may have been changed since me.minSize was calculated

            if (isHorizontal) {
              if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                y = cursor.y += itemHeight;
                cursor.line++;
                x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2 + labelOpts.padding;
              }
            } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
              x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
              y = cursor.y = me.top + labelOpts.padding;
              cursor.line++;
            }

            drawLegendBox(x, y, legendItem);
            hitboxes[i].left = x;
            hitboxes[i].top = y; // Fill the actual label

            fillText(x, y, legendItem, textWidth);

            if (isHorizontal) {
              cursor.x += width + labelOpts.padding;
            } else {
              cursor.y += itemHeight;
            }
          });
        }
      },

      /**
       * @private
       */
      _getLegendItemAt: function (x, y) {
        var me = this;
        var i, hitBox, lh;

        if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
          // See if we are touching one of the dataset boxes
          lh = me.legendHitBoxes;

          for (i = 0; i < lh.length; ++i) {
            hitBox = lh[i];

            if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
              // Touching an element
              return me.legendItems[i];
            }
          }
        }

        return null;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       */
      handleEvent: function (e) {
        var me = this;
        var opts = me.options;
        var type = e.type === 'mouseup' ? 'click' : e.type;
        var hoveredItem;

        if (type === 'mousemove') {
          if (!opts.onHover && !opts.onLeave) {
            return;
          }
        } else if (type === 'click') {
          if (!opts.onClick) {
            return;
          }
        } else {
          return;
        } // Chart event already has relative position in it


        hoveredItem = me._getLegendItemAt(e.x, e.y);

        if (type === 'click') {
          if (hoveredItem && opts.onClick) {
            // use e.native for backwards compatibility
            opts.onClick.call(me, e.native, hoveredItem);
          }
        } else {
          if (opts.onLeave && hoveredItem !== me._hoveredItem) {
            if (me._hoveredItem) {
              opts.onLeave.call(me, e.native, me._hoveredItem);
            }

            me._hoveredItem = hoveredItem;
          }

          if (opts.onHover && hoveredItem) {
            // use e.native for backwards compatibility
            opts.onHover.call(me, e.native, hoveredItem);
          }
        }
      }
    });

    function createNewLegendAndAttach(chart, legendOpts) {
      var legend = new Legend({
        ctx: chart.ctx,
        options: legendOpts,
        chart: chart
      });
      core_layouts.configure(chart, legend, legendOpts);
      core_layouts.addBox(chart, legend);
      chart.legend = legend;
    }

    var plugin_legend = {
      id: 'legend',

      /**
       * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
       * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Legend,
      beforeInit: function (chart) {
        var legendOpts = chart.options.legend;

        if (legendOpts) {
          createNewLegendAndAttach(chart, legendOpts);
        }
      },
      beforeUpdate: function (chart) {
        var legendOpts = chart.options.legend;
        var legend = chart.legend;

        if (legendOpts) {
          helpers$1.mergeIf(legendOpts, core_defaults.global.legend);

          if (legend) {
            core_layouts.configure(chart, legend, legendOpts);
            legend.options = legendOpts;
          } else {
            createNewLegendAndAttach(chart, legendOpts);
          }
        } else if (legend) {
          core_layouts.removeBox(chart, legend);
          delete chart.legend;
        }
      },
      afterEvent: function (chart, e) {
        var legend = chart.legend;

        if (legend) {
          legend.handleEvent(e);
        }
      }
    };
    var noop$2 = helpers$1.noop;

    core_defaults._set('global', {
      title: {
        display: false,
        fontStyle: 'bold',
        fullWidth: true,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000 // by default greater than legend (1000) to be above

      }
    });
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Title = core_element.extend({
      initialize: function (config) {
        var me = this;
        helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)

        me.legendHitBoxes = [];
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      beforeUpdate: noop$2,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$2,
      //
      beforeSetDimensions: noop$2,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$2,
      //
      beforeBuildLabels: noop$2,
      buildLabels: noop$2,
      afterBuildLabels: noop$2,
      //
      beforeFit: noop$2,
      fit: function () {
        var me = this;
        var opts = me.options;
        var display = opts.display;
        var minSize = me.minSize;
        var lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;

        var fontOpts = helpers$1.options._parseFont(opts);

        var textSize = display ? lineCount * fontOpts.lineHeight + opts.padding * 2 : 0;

        if (me.isHorizontal()) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = textSize;
        } else {
          minSize.width = textSize;
          minSize.height = me.maxHeight; // fill all the height
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$2,
      // Shared Methods
      isHorizontal: function () {
        var pos = this.options.position;
        return pos === 'top' || pos === 'bottom';
      },
      // Actually draw the title block on the canvas
      draw: function () {
        var me = this;
        var ctx = me.ctx;
        var opts = me.options;

        if (opts.display) {
          var fontOpts = helpers$1.options._parseFont(opts);

          var lineHeight = fontOpts.lineHeight;
          var offset = lineHeight / 2 + opts.padding;
          var rotation = 0;
          var top = me.top;
          var left = me.left;
          var bottom = me.bottom;
          var right = me.right;
          var maxWidth, titleX, titleY;
          ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour

          ctx.font = fontOpts.string; // Horizontal

          if (me.isHorizontal()) {
            titleX = left + (right - left) / 2; // midpoint of the width

            titleY = top + offset;
            maxWidth = right - left;
          } else {
            titleX = opts.position === 'left' ? left + offset : right - offset;
            titleY = top + (bottom - top) / 2;
            maxWidth = bottom - top;
            rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
          }

          ctx.save();
          ctx.translate(titleX, titleY);
          ctx.rotate(rotation);
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          var text = opts.text;

          if (helpers$1.isArray(text)) {
            var y = 0;

            for (var i = 0; i < text.length; ++i) {
              ctx.fillText(text[i], 0, y, maxWidth);
              y += lineHeight;
            }
          } else {
            ctx.fillText(text, 0, 0, maxWidth);
          }

          ctx.restore();
        }
      }
    });

    function createNewTitleBlockAndAttach(chart, titleOpts) {
      var title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart: chart
      });
      core_layouts.configure(chart, title, titleOpts);
      core_layouts.addBox(chart, title);
      chart.titleBlock = title;
    }

    var plugin_title = {
      id: 'title',

      /**
       * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
       * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Title,
      beforeInit: function (chart) {
        var titleOpts = chart.options.title;

        if (titleOpts) {
          createNewTitleBlockAndAttach(chart, titleOpts);
        }
      },
      beforeUpdate: function (chart) {
        var titleOpts = chart.options.title;
        var titleBlock = chart.titleBlock;

        if (titleOpts) {
          helpers$1.mergeIf(titleOpts, core_defaults.global.title);

          if (titleBlock) {
            core_layouts.configure(chart, titleBlock, titleOpts);
            titleBlock.options = titleOpts;
          } else {
            createNewTitleBlockAndAttach(chart, titleOpts);
          }
        } else if (titleBlock) {
          core_layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        }
      }
    };
    var plugins = {};
    var filler = plugin_filler;
    var legend = plugin_legend;
    var title = plugin_title;
    plugins.filler = filler;
    plugins.legend = legend;
    plugins.title = title;
    /**
     * @namespace Chart
     */

    core_controller.helpers = helpers$1; // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!

    core_helpers(core_controller);
    core_controller._adapters = core_adapters;
    core_controller.Animation = core_animation;
    core_controller.animationService = core_animations;
    core_controller.controllers = controllers;
    core_controller.DatasetController = core_datasetController;
    core_controller.defaults = core_defaults;
    core_controller.Element = core_element;
    core_controller.elements = elements;
    core_controller.Interaction = core_interaction;
    core_controller.layouts = core_layouts;
    core_controller.platform = platform;
    core_controller.plugins = core_plugins;
    core_controller.Scale = core_scale;
    core_controller.scaleService = core_scaleService;
    core_controller.Ticks = core_ticks;
    core_controller.Tooltip = core_tooltip; // Register built-in scales

    core_controller.helpers.each(scales, function (scale, type) {
      core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
    }); // Load to register built-in adapters (as side effects)
    // Loading built-in plugins

    for (var k in plugins) {
      if (plugins.hasOwnProperty(k)) {
        core_controller.plugins.register(plugins[k]);
      }
    }

    core_controller.platform.initialize();
    var src = core_controller;

    if (typeof window !== 'undefined') {
      window.Chart = core_controller;
    } // DEPRECATIONS

    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Chart
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */


    core_controller.Chart = core_controller;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Legend
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Legend = plugins.legend._element;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Title
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Title = plugins.title._element;
    /**
     * Provided for backward compatibility, use Chart.plugins instead
     * @namespace Chart.pluginService
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.pluginService = core_controller.plugins;
    /**
     * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
     * effect, instead simply create/register plugins via plain JavaScript objects.
     * @interface Chart.PluginBase
     * @deprecated since version 2.5.0
     * @todo remove at version 3
     * @private
     */

    core_controller.PluginBase = core_controller.Element.extend({});
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas instead.
     * @namespace Chart.canvasHelpers
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    core_controller.canvasHelpers = core_controller.helpers.canvas;
    /**
     * Provided for backward compatibility, use Chart.layouts instead.
     * @namespace Chart.layoutService
     * @deprecated since version 2.7.3
     * @todo remove at version 3
     * @private
     */

    core_controller.layoutService = core_controller.layouts;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.LinearScaleBase
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    core_controller.LinearScaleBase = scale_linearbase;
    /**
     * Provided for backward compatibility, instead we should create a new Chart
     * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     */

    core_controller.helpers.each(['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'], function (klass) {
      core_controller[klass] = function (ctx, cfg) {
        return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
          type: klass.charAt(0).toLowerCase() + klass.slice(1)
        }));
      };
    });
    return src;
  });
});

function generateChart(chartId, chartType) {
  return {
    render: function render(createElement) {
      return createElement('div', {
        style: this.styles,
        class: this.cssClasses
      }, [createElement('canvas', {
        attrs: {
          id: this.chartId,
          width: this.width,
          height: this.height
        },
        ref: 'canvas'
      })]);
    },
    props: {
      chartId: {
        default: chartId,
        type: String
      },
      width: {
        default: 400,
        type: Number
      },
      height: {
        default: 400,
        type: Number
      },
      cssClasses: {
        type: String,
        default: ''
      },
      styles: {
        type: Object
      },
      plugins: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    data: function data() {
      return {
        _chart: null,
        _plugins: this.plugins
      };
    },
    methods: {
      addPlugin: function addPlugin(plugin) {
        this.$data._plugins.push(plugin);
      },
      generateLegend: function generateLegend() {
        if (this.$data._chart) {
          return this.$data._chart.generateLegend();
        }
      },
      renderChart: function renderChart(data, options) {
        if (this.$data._chart) {
          this.$data._chart.destroy();
        }

        this.$data._chart = new Chart$1(this.$refs.canvas.getContext('2d'), {
          type: chartType,
          data: data,
          options: options,
          plugins: this.$data._plugins
        });
      }
    },
    beforeDestroy: function beforeDestroy() {
      if (this.$data._chart) {
        this.$data._chart.destroy();
      }
    }
  };
}
var Bar = generateChart('bar-chart', 'bar');
var HorizontalBar = generateChart('horizontalbar-chart', 'horizontalBar');
var Line = generateChart('line-chart', 'line');
var Pie = generateChart('pie-chart', 'pie');

var reactiveProp$1 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$1 = {
  extends: Bar,
  mixins: [reactiveProp$1],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$1 = script$1;

/* template */

  /* style */
  var __vue_inject_styles__$1 = undefined;
  /* scoped */
  var __vue_scope_id__$1 = undefined;
  /* module identifier */
  var __vue_module_identifier__$1 = undefined;
  /* functional template */
  var __vue_is_functional_template__$1 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent = normalizeComponent_1(
    {},
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    undefined,
    undefined
  );

var chartLabels = ['1980', '1990', '2000', '2010', '2020'];
var chartDataList = [6542564, 7322564, 8008278, 8175133, 5475133];
var ChartData = {
  data: {
    labels: chartLabels,
    datasets: [{
      data: chartDataList,
      fill: false,
      // used by line chart
      backgroundColor: ['#2F334F', '#3155A6', '#F2695D', '#EBBCD8', '#F9A137'],
      borderColor: ['#ACAEB9'],
      borderWidth: 1
    }]
  },
  bar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  horizontalBar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  pie: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: true
      },
      lineTension: 1
    }
  }
};

var chartType = 'bar';

var ChartBar = function ChartBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType, ChartComponent);
  new Vue({
    el: "[data-js=\"chart-" + chartType + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$2 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$2 = {
  extends: HorizontalBar,
  mixins: [reactiveProp$2],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$2 = script$2;

/* template */

  /* style */
  var __vue_inject_styles__$2 = undefined;
  /* scoped */
  var __vue_scope_id__$2 = undefined;
  /* module identifier */
  var __vue_module_identifier__$2 = undefined;
  /* functional template */
  var __vue_is_functional_template__$2 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$1 = normalizeComponent_1(
    {},
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    undefined,
    undefined
  );

var chartType$1 = 'horizontal-bar';

var ChartHorizontalBar = function ChartHorizontalBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartHorizontalBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$1, ChartComponent$1);
  new Vue({
    el: "[data-js=\"chart-" + chartType$1 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.horizontalBar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartHorizontalBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$3 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$3 = {
  extends: Line,
  mixins: [reactiveProp$3],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$3 = script$3;

/* template */

  /* style */
  var __vue_inject_styles__$3 = undefined;
  /* scoped */
  var __vue_scope_id__$3 = undefined;
  /* module identifier */
  var __vue_module_identifier__$3 = undefined;
  /* functional template */
  var __vue_is_functional_template__$3 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$2 = normalizeComponent_1(
    {},
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3,
    __vue_module_identifier__$3,
    undefined,
    undefined
  );

var chartType$2 = 'line';

var ChartLine = function ChartLine(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartLine.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$2, ChartComponent$2);
  new Vue({
    el: "[data-js=\"chart-" + chartType$2 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartLine.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$4 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$4 = {
  extends: Pie,
  mixins: [reactiveProp$4],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: true
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$4 = script$4;

/* template */

  /* style */
  var __vue_inject_styles__$4 = undefined;
  /* scoped */
  var __vue_scope_id__$4 = undefined;
  /* module identifier */
  var __vue_module_identifier__$4 = undefined;
  /* functional template */
  var __vue_is_functional_template__$4 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$3 = normalizeComponent_1(
    {},
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4,
    __vue_module_identifier__$4,
    undefined,
    undefined
  );

var chartType$3 = 'pie';

var ChartPie = function ChartPie(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartPie.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$3, ChartComponent$3);
  new Vue({
    el: "[data-js=\"chart-" + chartType$3 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.pie.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartPie.prototype._constants = function _constants(param) {
  console.dir(param);
};

//
//
var script$5 = {
  props: {
    'layers': {
      type: Array
    },
    'config': {
      type: Object
    }
  },
  data: function data() {
    return {
      map: null,
      mapPopup: null,
      mapFilter: null,
      activeLayer: null,
      mapLoaded: false,
      menuItems: [],
      selectedItems: []
    };
  },
  mounted: function mounted() {
    this.initializeMap();
  },
  destroyed: function destroyed() {
    this.map.remove();
  },
  watch: {
    'layers': function layers() {
      var layers = this.layers;

      if (this.config.mapType === 'multi') {
        for (var i = 0; i < layers.length; i++) {
          var layer = layers[i];
          this.trackLayer(layer.name);

          if (layer.default) {
            this.activeLayer = layer.name;
          }

          if (this.mapLoaded) {
            this.initializeLayer(layer);
          }
        }
      } else if (this.config.mapType === 'single') {
        var layer$1 = this.layers[0];
        this.activeLayer = layer$1.name;
        this.generateLegend(layer$1.data);

        if (this.mapLoaded) {
          this.initializeLayer(layer$1);
        }
      } else {
        throw new Error('mapType must be defined');
      }
    },
    'mapLoaded': function mapLoaded() {
      if (this.mapLoaded && this.layers.length) {
        var layers = this.layers;

        for (var i = 0; i < layers.length; i++) {
          this.initializeLayer(layers[i]);
        }
      }
    },
    'menuItems': function menuItems() {
      if (this.menuItems.length > 1) {
        this.initializeToggle(this.menuItems);
      }
    },
    'selectedItems': function selectedItems() {
      var layer = this.layers[0];
      var filter = ['in', layer.legendColumn];

      for (var i = 0; i < this.selectedItems.length; i++) {
        filter.push(this.selectedItems[i]);
      }

      if (this.selectedItems.length > 0) {
        var relatedFeatures = this.map.querySourceFeatures(layer.name, {
          sourceLayer: layer.name,
          filter: filter
        }); // set filter when legend item selected

        this.map.setFilter(layer.name + "-highlighted", filter);
        this.map.setLayoutProperty(layer.name + "-highlighted", 'visibility', 'visible');
      }

      if (!this.selectedItems.length && !this.mapPopup) {
        this.map.setFilter(layer.name + "-highlighted", null);
        this.map.setLayoutProperty(layer.name + "-highlighted", 'visibility', 'none');
      }
    }
  },
  methods: {
    initializeMap: function initializeMap() {
      var this$1 = this;
      var mapConfig = this.config;
      mapboxgl.accessToken = mapConfig.APIKey;
      this.map = new mapboxgl.Map({
        container: mapConfig.containerId,
        center: mapConfig.center,
        zoom: mapConfig.zoom,
        style: mapConfig.style
      });
      this.map.addControl(new mapboxgl.NavigationControl());
      this.map.on('load', function () {
        return this$1.mapLoaded = true;
      });
    },
    initializeLayer: function initializeLayer(layer) {
      if (this.map.getLayer(layer.name) === undefined && Object.entries(layer.data).length !== 0) {
        var visibility = layer.name === this.activeLayer ? 'visible' : 'none';
        var filter = layer.filterBy ? ['in', layer.filterBy, ''] : [];
        var fill = this.generateFillColor();
        this.map.addSource(layer.name, {
          'type': 'geojson',
          'data': layer.data
        });
        this.map.addLayer({
          'id': layer.name,
          'type': 'fill',
          'source': layer.name,
          'paint': {
            'fill-outline-color': fill[0],
            'fill-color': fill[1],
            'fill-opacity': 0.7
          },
          'layout': {
            'visibility': visibility
          }
        });
        this.map.addLayer({
          'id': layer.name + "-highlighted",
          'type': 'fill',
          'source': layer.name,
          'paint': {
            'fill-outline-color': fill[0],
            'fill-color': fill[1],
            'fill-opacity': 1
          },
          'filter': filter,
          'layout': {
            'visibility': visibility
          }
        });
        this.initializeFilter(layer);
        this.updateCursorOnHover(layer.name);
      }
    },
    initializePopup: function initializePopup(event, layer) {
      this.config.mapType === 'multi' ? this.popupMultiLayer(event, layer) : this.popupSingleLayer(event, layer);
    },
    initializeToggle: function initializeToggle(toggleList) {
      this.config.mapType === 'multi' ? this.toggleMultiLayer(toggleList) : this.toggleSingleLayer(toggleList);
    },
    initializeFilter: function initializeFilter(layer) {
      this.config.mapType === 'multi' ? this.filterMultiLayer(layer) : this.filterSingleLayer(layer);
    },
    updateCursorOnHover: function updateCursorOnHover(layerId) {
      var map = this.map; // change the cursor to a pointer when the mouse is over the layer.

      map.on('mouseenter', layerId, function () {
        map.getCanvas().style.cursor = 'pointer';
      }); // change the cursor back to the default when it leaves the layer.

      map.on('mouseleave', layerId, function () {
        map.getCanvas().style.cursor = '';
      });
    },
    generateFillColor: function generateFillColor() {
      // NYCO colors, ['fill-outline', 'fill']
      var colors = [// black, red
      ['#000000', '#F2695D'], // black, orange
      ['#000000', '#FFA133'], // dark blue, gray
      ['#2F334F', '#ACAEB9'], // blue, orange
      ['#3155A6', '#F9A137']];
      return colors[Math.floor(Math.random() * colors.length)];
    },
    // multi layer
    trackLayer: function trackLayer(reference) {
      if (!this.menuItems.includes(reference)) {
        this.menuItems.push(reference);
      }
    },
    popupMultiLayer: function popupMultiLayer(event, layer) {
      var $this = this;
      var map = $this.map;
      var layerName = layer.name + "-highlighted";
      var popup = new mapboxgl.Popup().setLngLat(event.lngLat).setHTML(event.features[0].properties[layer.filterBy]).addTo(map);

      if (popup.isOpen()) {
        $this.mapPopup = popup;
        map.setLayoutProperty(layerName, 'visibility', 'visible');
        map.setFilter(layerName, $this.mapFilter);
      }

      popup.on('close', function () {
        // reset associated states when popup dismissed while active
        if ($this.mapPopup === popup) {
          $this.mapPopup = null;
          $this.mapFilter = null;
          map.setFilter(layerName, null);
          map.setLayoutProperty(layerName, 'visibility', 'none');
        }
      });
    },
    filterMultiLayer: function filterMultiLayer(layer) {
      var $this = this;
      var map = $this.map;
      map.on('click', layer.name, function (e) {
        // set bbox as reactangle area around clicked point
        var bbox = [[e.point.x, e.point.y], [e.point.x, e.point.y]];
        var features = map.queryRenderedFeatures(bbox, {
          layers: [layer.name]
        });
        var filter = features.reduce(function (memo, feature) {
          memo.push(feature.properties[layer.filterBy]);
          return memo;
        }, ['in', "" + layer.filterBy]);
        $this.mapFilter = filter;
        $this.initializePopup(e, layer);
      });
    },
    toggleMultiLayer: function toggleMultiLayer(layersToToggle) {
      var $this = this;
      var map = $this.map;
      var activeLayer = $this.activeLayer;
      var linkContainer = document.getElementById(this.config.legendId); // clear all links before appending new ones to prevent duplicates

      while (linkContainer.firstChild) {
        linkContainer.removeChild(linkContainer.firstChild);
      }

      for (var i = 0; i < layersToToggle.length; i++) {
        var layerRef = layersToToggle[i];
        var link = document.createElement('a');
        link.href = '#';
        link.textContent = layerRef;

        if (layerRef === activeLayer) {
          link.classList.add('active');
        } // on click update link state, active layer reference, and layer visibility


        link.onclick = function (e) {
          e.preventDefault();
          e.stopPropagation();
          var selectedLayer = this.textContent;
          var links = linkContainer.getElementsByTagName('a'); // remove active popup

          if ($this.mapPopup) {
            $this.mapPopup.remove();
          }

          for (var i = 0; i < links.length; i++) {
            var currentLink = links[i];
            var currentLayer = currentLink.textContent;
            var currentLayerHighlight = currentLayer + "-highlighted";
            var layerVisibility = map.getLayoutProperty(currentLayer, 'visibility');

            if (currentLayer === selectedLayer) {
              // return if layer is already selected
              if (layerVisibility === 'visible' && currentLink.classList.contains('active')) {
                return;
              } // set our current layer as the global active layer,
              // add active class to link, set layer as visible


              $this.activeLayer = currentLayer;
              currentLink.classList.add('active');
              map.setLayoutProperty(currentLayer, 'visibility', 'visible');
            } else {
              // remove links active class, set layer visibility to none and remove filters
              currentLink.classList.remove('active');
              map.setLayoutProperty(currentLayer, 'visibility', 'none');
              map.setLayoutProperty(currentLayerHighlight, 'visibility', 'none');
              map.setFilter(currentLayerHighlight, null);
            }
          }
        };

        linkContainer.appendChild(link);
      }
    },
    // single layer
    generateLegend: function generateLegend(layerData) {
      var this$1 = this;
      layerData.features.forEach(function (feature) {
        var item = feature.properties[this$1.layers[0].legendColumn];

        if (!this$1.menuItems.includes(item) && item) {
          this$1.menuItems.push(item);
        }
      });
    },
    popupSingleLayer: function popupSingleLayer(event, layer) {
      var $this = this;
      var map = $this.map;
      var layerName = layer.name + "-highlighted"; // check whether shape falls under current legend selection

      var inCurrentSelection = true;
      var columnFilter = event.features[0].properties[layer.legendColumn];

      if (!$this.selectedItems.includes(columnFilter)) {
        inCurrentSelection = false;
      }

      var popup = new mapboxgl.Popup().setLngLat(event.lngLat).setHTML(event.features[0].properties[layer.filterBy]).addTo(map);

      if (popup.isOpen()) {
        $this.mapPopup = popup; // if there are no legend items selected, highlight selected map shape

        if (!$this.selectedItems.length) {
          map.setLayoutProperty(layerName, 'visibility', 'visible');
          map.setFilter(layerName, $this.mapFilter);
        } // if there are legend items selected and selected map shape isn't
        // within any of the selected legend items, highlight selected
        // map shape and clear legend


        if ($this.selectedItems.length > 0 && !inCurrentSelection) {
          map.setLayoutProperty(layerName, 'visibility', 'visible');
          map.setFilter(layerName, $this.mapFilter); // reset all checked legend items

          $this.selectedItems = [];
          var filterGroupInputs = document.getElementById(this.config.legendId).querySelectorAll('input:checked');

          for (var i = 0; i < filterGroupInputs.length; i++) {
            filterGroupInputs[i].checked = false;
          }
        }
      }

      popup.on('close', function () {
        // reset associated states when popup dismissed while active
        if ($this.mapPopup === popup) {
          $this.mapPopup = null;
          $this.mapFilter = null; // if there are no legend items selected, reset all filters

          if (!$this.selectedItems.length) {
            map.setFilter(layerName, null);
            map.setLayoutProperty(layerName, 'visibility', 'none');
          }
        }
      });
    },
    filterSingleLayer: function filterSingleLayer(layer) {
      var $this = this;
      var map = $this.map;
      map.on('click', layer.name, function (e) {
        // set bbox as reactangle area around clicked point
        var bbox = [[e.point.x, e.point.y], [e.point.x, e.point.y]];
        var features = map.queryRenderedFeatures(bbox, {
          layers: [layer.name]
        });
        var legendColumnValue = null;
        var filter = features.reduce(function (memo, feature) {
          legendColumnValue = feature.properties[layer.legendColumn];
          memo.push(feature.properties[layer.filterBy]);
          return memo;
        }, ['in', "" + layer.filterBy]);
        $this.mapFilter = filter;
        $this.initializePopup(e, layer);
      });
    },
    toggleSingleLayer: function toggleSingleLayer(filtersToToggle) {
      var $this = this;
      var map = $this.map;
      var filterGroup = document.getElementById(this.config.legendId);
      var layer = $this.layers[0];
      var legendColumn = layer.legendColumn; // clear all links before appending new ones to prevent duplicates

      while (filterGroup.firstChild) {
        filterGroup.removeChild(filterGroup.firstChild);
      } // initilize an input element for each filter type


      for (var i = 0; i < filtersToToggle.length; i++) {
        var layerRef = filtersToToggle[i]; // checkbox

        var input = document.createElement('input');
        input.type = 'checkbox';
        input.id = layerRef;
        input.value = layerRef;
        filterGroup.appendChild(input); // checkbox label

        var label = document.createElement('label');
        label.setAttribute('for', layerRef);
        label.setAttribute('title', layerRef);
        label.textContent = layerRef;
        filterGroup.appendChild(label); // when the checkbox changes state, update the selected items array.

        input.addEventListener('change', function (e) {
          var item = e.target.value; // reset the checkboxes checked state

          e.target.checked ? 'visible' : 'none'; // remove popup if one exists

          if ($this.mapPopup) {
            $this.mapPopup.remove();
          }

          if (e.target.checked && !$this.selectedItems.includes(item)) {
            $this.selectedItems.push(item);
          }

          if (!e.target.checked && $this.selectedItems.includes(item)) {
            $this.selectedItems = $this.selectedItems.filter(function (val) {
              return val !== item;
            });
          }
        });
      }
    }
  }
};

/* script */
var __vue_script__$5 = script$5;

/* template */
var __vue_render__$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div")
};
var __vue_staticRenderFns__$1 = [];
__vue_render__$1._withStripped = true;

  /* style */
  var __vue_inject_styles__$5 = undefined;
  /* scoped */
  var __vue_scope_id__$5 = undefined;
  /* module identifier */
  var __vue_module_identifier__$5 = undefined;
  /* functional template */
  var __vue_is_functional_template__$5 = false;
  /* style inject */
  
  /* style inject SSR */
  

  
  var MapComponent = normalizeComponent_1(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$5,
    __vue_script__$5,
    __vue_scope_id__$5,
    __vue_is_functional_template__$5,
    __vue_module_identifier__$5,
    undefined,
    undefined
  );

var MapData = {
  single: {
    layers: [],
    config: {
      APIKey: 'pk.eyJ1Ijoibnljby1wcm9kdWN0cyIsImEiOiJjanZjZ3Y4b2IxNXYwM3l0ZDN6bWN4ajA5In0.XSt-hoz5p3j2siyli0g0og',
      containerId: 'nyco-map-sl',
      legendId: 'nyco-map-legend',
      center: [-73.986710, 40.693391],
      zoom: 9,
      style: 'mapbox://styles/nyco-products/cjv6wjq8812ys1gp39mnvuk2w',
      mapType: 'single'
    }
  },
  multi: {
    layers: [],
    config: {
      APIKey: 'pk.eyJ1Ijoibnljby1wcm9kdWN0cyIsImEiOiJjanZjZ3Y4b2IxNXYwM3l0ZDN6bWN4ajA5In0.XSt-hoz5p3j2siyli0g0og',
      containerId: 'nyco-map-ml',
      legendId: 'nyco-map-menu',
      center: [-73.986710, 40.693391],
      zoom: 9,
      style: 'mapbox://styles/nyco-products/cjv6wjq8812ys1gp39mnvuk2w',
      mapType: 'multi'
    }
  }
};

var geojson = createCommonjsModule(function (module) {
  (function (GeoJSON) {
    GeoJSON.version = '0.5.0'; // Allow user to specify default parameters

    GeoJSON.defaults = {
      doThrows: {
        invalidGeometry: false
      }
    };

    function InvalidGeometryError() {
      var args = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
      var item = args.shift();
      var params = args.shift();
      Error.apply(this, args);
      this.message = this.message || "Invalid Geometry: " + 'item: ' + JSON.stringify(item) + ', params: ' + JSON.stringify(params);
    }

    InvalidGeometryError.prototype = Error;
    GeoJSON.errors = {
      InvalidGeometryError: InvalidGeometryError
    }; //exposing so this can be overriden maybe by geojson-validation or the like

    GeoJSON.isGeometryValid = function (geometry) {
      if (!geometry || !Object.keys(geometry).length) {
        return false;
      }

      return !!geometry.type && !!geometry.coordinates && Array.isArray(geometry.coordinates) && !!geometry.coordinates.length;
    }; // The one and only public function.
    // Converts an array of objects into a GeoJSON feature collection


    GeoJSON.parse = function (objects, params, callback) {
      var geojson,
          settings = applyDefaults(params, this.defaults),
          propFunc;
      geomAttrs.length = 0; // Reset the list of geometry fields

      setGeom(settings);
      propFunc = getPropFunction(settings);

      if (Array.isArray(objects)) {
        geojson = {
          "type": "FeatureCollection",
          "features": []
        };
        objects.forEach(function (item) {
          geojson.features.push(getFeature({
            item: item,
            params: settings,
            propFunc: propFunc
          }));
        });
        addOptionals(geojson, settings);
      } else {
        geojson = getFeature({
          item: objects,
          params: settings,
          propFunc: propFunc
        });
        addOptionals(geojson, settings);
      }

      if (callback && typeof callback === 'function') {
        callback(geojson);
      } else {
        return geojson;
      }
    }; // Helper functions


    var geoms = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon', 'GeoJSON'],
        geomAttrs = []; // Adds default settings to user-specified params
    // Does not overwrite any settings--only adds defaults
    // the the user did not specify

    function applyDefaults(params, defaults) {
      var settings = params || {};

      for (var setting in defaults) {
        if (defaults.hasOwnProperty(setting) && !settings[setting]) {
          settings[setting] = defaults[setting];
        }
      }

      return settings;
    } // Adds the optional GeoJSON properties crs and bbox
    // if they have been specified


    function addOptionals(geojson, settings) {
      if (settings.crs && checkCRS(settings.crs)) {
        if (settings.isPostgres) {
          geojson.geometry.crs = settings.crs;
        } else {
          geojson.crs = settings.crs;
        }
      }

      if (settings.bbox) {
        geojson.bbox = settings.bbox;
      }

      if (settings.extraGlobal) {
        geojson.properties = {};

        for (var key in settings.extraGlobal) {
          geojson.properties[key] = settings.extraGlobal[key];
        }
      }
    } // Verify that the structure of CRS object is valid


    function checkCRS(crs) {
      if (crs.type === 'name') {
        if (crs.properties && crs.properties.name) {
          return true;
        } else {
          throw new Error('Invalid CRS. Properties must contain "name" key');
        }
      } else if (crs.type === 'link') {
        if (crs.properties && crs.properties.href && crs.properties.type) {
          return true;
        } else {
          throw new Error('Invalid CRS. Properties must contain "href" and "type" key');
        }
      } else {
        throw new Error('Invald CRS. Type attribute must be "name" or "link"');
      }
    } // Moves the user-specified geometry parameters
    // under the `geom` key in param for easier access


    function setGeom(params) {
      params.geom = {};

      for (var param in params) {
        if (params.hasOwnProperty(param) && geoms.indexOf(param) !== -1) {
          params.geom[param] = params[param];
          delete params[param];
        }
      }

      setGeomAttrList(params.geom);
    } // Adds fields which contain geometry data
    // to geomAttrs. This list is used when adding
    // properties to the features so that no geometry
    // fields are added the properties key


    function setGeomAttrList(params) {
      for (var param in params) {
        if (params.hasOwnProperty(param)) {
          if (typeof params[param] === 'string') {
            geomAttrs.push(params[param]);
          } else if (typeof params[param] === 'object') {
            // Array of coordinates for Point
            geomAttrs.push(params[param][0]);
            geomAttrs.push(params[param][1]);
          }
        }
      }

      if (geomAttrs.length === 0) {
        throw new Error('No geometry attributes specified');
      }
    } // Creates a feature object to be added
    // to the GeoJSON features array


    function getFeature(args) {
      var item = args.item,
          params = args.params,
          propFunc = args.propFunc;
      var feature = {
        "type": "Feature"
      };
      feature.geometry = buildGeom(item, params);
      feature.properties = propFunc.call(item);
      return feature;
    }

    function isNested(val) {
      return /^.+\..+$/.test(val);
    } // Assembles the `geometry` property
    // for the feature output


    function buildGeom(item, params) {
      var geom = {};

      for (var gtype in params.geom) {
        var val = params.geom[gtype]; // Geometry parameter specified as: {Point: 'coords'}

        if (typeof val === 'string' && item.hasOwnProperty(val)) {
          if (gtype === 'GeoJSON') {
            geom = item[val];
          } else {
            geom.type = gtype;
            geom.coordinates = item[val];
          }
        }
        /* Handle things like:
        Polygon: {
          northeast: ['lat', 'lng'],
          southwest: ['lat', 'lng']
        }
        */
        else if (typeof val === 'object' && !Array.isArray(val)) {
            /*jshint loopfunc: true */
            var points = Object.keys(val).map(function (key) {
              var order = val[key];
              var newItem = item[key];
              return buildGeom(newItem, {
                geom: {
                  Point: order
                }
              });
            });
            geom.type = gtype;
            /*jshint loopfunc: true */

            geom.coordinates = [].concat(points.map(function (p) {
              return p.coordinates;
            }));
          } // Geometry parameter specified as: {Point: ['lat', 'lng']}
          else if (Array.isArray(val) && item.hasOwnProperty(val[0]) && item.hasOwnProperty(val[1])) {
              geom.type = gtype;
              geom.coordinates = [Number(item[val[1]]), Number(item[val[0]])];
            } // Geometry parameter specified as: {Point: ['container.lat', 'container.lng']}
            else if (Array.isArray(val) && isNested(val[0]) && isNested(val[1])) {
                var coordinates = [];

                for (var i = 0; i < val.length; i++) {
                  // i.e. 0 and 1
                  var paths = val[i].split('.');
                  var itemClone = item;

                  for (var j = 0; j < paths.length; j++) {
                    if (!itemClone.hasOwnProperty(paths[j])) {
                      return false;
                    }

                    itemClone = itemClone[paths[j]]; // Iterate deeper into the object
                  }

                  coordinates[i] = itemClone;
                }

                geom.type = gtype;
                geom.coordinates = [Number(coordinates[1]), Number(coordinates[0])];
              }
      }

      if (params.doThrows && params.doThrows.invalidGeometry && !GeoJSON.isGeometryValid(geom)) {
        throw new InvalidGeometryError(item, params);
      }

      return geom;
    } // Returns the function to be used to
    // build the properties object for each feature


    function getPropFunction(params) {
      var func;

      if (!params.exclude && !params.include) {
        func = function (properties) {
          for (var attr in this) {
            if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1) {
              properties[attr] = this[attr];
            }
          }
        };
      } else if (params.include) {
        func = function (properties) {
          params.include.forEach(function (attr) {
            properties[attr] = this[attr];
          }, this);
        };
      } else if (params.exclude) {
        func = function (properties) {
          for (var attr in this) {
            if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1 && params.exclude.indexOf(attr) === -1) {
              properties[attr] = this[attr];
            }
          }
        };
      }

      return function () {
        var properties = {};
        func.call(this, properties);

        if (params.extra) {
          addExtra(properties, params.extra);
        }

        return properties;
      };
    } // Adds data contained in the `extra`
    // parameter if it has been specified


    function addExtra(properties, extra) {
      for (var key in extra) {
        if (extra.hasOwnProperty(key)) {
          properties[key] = extra[key];
        }
      }

      return properties;
    }
  })(module.exports);
});

var RADIUS = 6378137;
var FLATTENING = 1 / 298.257223563;
var POLAR_RADIUS = 6356752.3142;
var wgs84 = {
  RADIUS: RADIUS,
  FLATTENING: FLATTENING,
  POLAR_RADIUS: POLAR_RADIUS
};

var geometry_1 = geometry;
var ring = ringArea;

function geometry(_) {
  var area = 0,
      i;

  switch (_.type) {
    case 'Polygon':
      return polygonArea(_.coordinates);

    case 'MultiPolygon':
      for (i = 0; i < _.coordinates.length; i++) {
        area += polygonArea(_.coordinates[i]);
      }

      return area;

    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
      return 0;

    case 'GeometryCollection':
      for (i = 0; i < _.geometries.length; i++) {
        area += geometry(_.geometries[i]);
      }

      return area;
  }
}

function polygonArea(coords) {
  var area = 0;

  if (coords && coords.length > 0) {
    area += Math.abs(ringArea(coords[0]));

    for (var i = 1; i < coords.length; i++) {
      area -= Math.abs(ringArea(coords[i]));
    }
  }

  return area;
}
/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */


function ringArea(coords) {
  var p1,
      p2,
      p3,
      lowerIndex,
      middleIndex,
      upperIndex,
      i,
      area = 0,
      coordsLength = coords.length;

  if (coordsLength > 2) {
    for (i = 0; i < coordsLength; i++) {
      if (i === coordsLength - 2) {
        // i = N-2
        lowerIndex = coordsLength - 2;
        middleIndex = coordsLength - 1;
        upperIndex = 0;
      } else if (i === coordsLength - 1) {
        // i = N-1
        lowerIndex = coordsLength - 1;
        middleIndex = 0;
        upperIndex = 1;
      } else {
        // i = 0 to N-3
        lowerIndex = i;
        middleIndex = i + 1;
        upperIndex = i + 2;
      }

      p1 = coords[lowerIndex];
      p2 = coords[middleIndex];
      p3 = coords[upperIndex];
      area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
    }

    area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
  }

  return area;
}

function rad(_) {
  return _ * Math.PI / 180;
}

var geojsonArea = {
  geometry: geometry_1,
  ring: ring
};

var geojsonRewind = rewind;

function rewind(gj, outer) {
  switch (gj && gj.type || null) {
    case 'FeatureCollection':
      gj.features = gj.features.map(curryOuter(rewind, outer));
      return gj;

    case 'Feature':
      gj.geometry = rewind(gj.geometry, outer);
      return gj;

    case 'Polygon':
    case 'MultiPolygon':
      return correct(gj, outer);

    default:
      return gj;
  }
}

function curryOuter(a, b) {
  return function (_) {
    return a(_, b);
  };
}

function correct(_, outer) {
  if (_.type === 'Polygon') {
    _.coordinates = correctRings(_.coordinates, outer);
  } else if (_.type === 'MultiPolygon') {
    _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
  }

  return _;
}

function correctRings(_, outer) {
  outer = !!outer;
  _[0] = wind(_[0], outer);

  for (var i = 1; i < _.length; i++) {
    _[i] = wind(_[i], !outer);
  }

  return _;
}

function wind(_, dir) {
  return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
  return geojsonArea.ring(_) >= 0;
}

var MapMultiLayer = function MapMultiLayer(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


MapMultiLayer.prototype.init = function init() {
  Vue.component('nyco-map-ml', MapComponent);
  new Vue({
    el: '[data-js="nyco-map-ml"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        layers: MapData.multi.layers,
        config: MapData.multi.config
      };
    },
    created: function created() {
      this.getZipcodeData();
      this.getBoroughData();
      this.getNeighborhoodData();
    },
    methods: {
      getZipcodeData: function getZipcodeData() {
        fetch('https://cdn.jsdelivr.net/gh/kimpenguin/geoJSON@master/tiger-zcta.geojson').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          MapData.multi.layers.push({
            name: 'zipcodes',
            data: JSON.parse(data),
            default: true,
            filterBy: 'GEOID10'
          });
        });
      },
      getBoroughData: function getBoroughData() {
        var this$1 = this;
        fetch('https://data.cityofnewyork.us/resource/7t3b-ywvw.json').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          data = JSON.parse(data);
          MapData.multi.layers.push({
            name: 'boroughs',
            data: this$1.convertToGeoJSON(data),
            default: false,
            filterBy: 'boro_name'
          });
        });
      },
      getNeighborhoodData: function getNeighborhoodData() {
        var this$1 = this;
        fetch('https://data.cityofnewyork.us/resource/q2z5-ai38.json').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          data = JSON.parse(data);
          MapData.multi.layers.push({
            name: 'neighborhoods',
            data: this$1.convertToGeoJSON(data),
            default: false,
            filterBy: 'ntaname'
          });
        });
      },
      convertToGeoJSON: function convertToGeoJSON(jsonData) {
        // ensure geojson satisfies right-hand rule
        var data = geojsonRewind(geojson.parse(jsonData, {
          GeoJSON: 'the_geom'
        }));
        return data;
      }
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


MapMultiLayer.prototype._constants = function _constants(param) {
  console.dir(param);
};

var MapSingleLayer = function MapSingleLayer(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


MapSingleLayer.prototype.init = function init() {
  Vue.component('nyco-map-sl', MapComponent);
  new Vue({
    el: '[data-js="nyco-map-sl"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        layers: MapData.single.layers,
        config: MapData.single.config
      };
    },
    created: function created() {
      this.getData();
    },
    methods: {
      getData: function getData() {
        fetch('https://cdn.jsdelivr.net/gh/kimpenguin/geoJSON@master/nyco-nyc_zipcodes.geojson').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          MapData.single.layers.push({
            name: 'nyco-nyc_zipcodes',
            data: JSON.parse(data),
            filterBy: 'ZCTA5CE10',
            legendColumn: 'BORO'
          });
        });
      }
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


MapSingleLayer.prototype._constants = function _constants(param) {
  console.dir(param);
};

/** import modules here as they are written */

/**
 * Methods for the global NycoPatterns instance
 */

var nyco = function nyco() {};

nyco.prototype.icons = function icons(path) {
  return new Icons(path);
};
/**
 * Method for the Feed Object
 * @param {Object}settingsSetting for the feed
 * @return{Object}          Feed instance
 */


nyco.prototype.feed = function feed(settings) {
  return new Feed(settings);
};
/**
 * Method for the Toggle Utility
 * @return{Object} Toggle instance
 */


nyco.prototype.toggle = function toggle(settings) {
  return new Toggle();
};
/**
 * Method for the Track Module
 * @return{Object} Track Module
 */


nyco.prototype.track = function track(settings) {
  return new Track();
};

nyco.prototype.select = function select() {
  return new Select();
};
/**
 * Method for the Chart Objects
 * @return{Object} Chart instance
 */


nyco.prototype.chart = function chart(type) {
  if (type === 'bar') {
    return new ChartBar();
  }

  if (type === 'horizontalBar') {
    return new ChartHorizontalBar();
  }

  if (type === 'line') {
    return new ChartLine();
  }

  if (type === 'pie') {
    return new ChartPie();
  }
};
/**
 * Method for the Map Module
 * @return{Object} Map Module
 */


nyco.prototype.map = function map(type) {
  if (type === 'multi') {
    return new MapMultiLayer();
  }

  if (type === 'single') {
    return new MapSingleLayer();
  }
};

module.exports = nyco;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTnljb1BhdHRlcm5zLmNvbW1vbi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2pzL21vZHVsZXMvdXRpbGl0eS5qcyIsIi4uLy4uL3NyYy9lbGVtZW50cy9pY29ucy9JY29ucy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvU291cmNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXROYXRpdmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlPYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXBwbHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyUmVzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY29uc3RhbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaG9ydE91dC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvU3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJlc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUFzc2lnbmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5c0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbkluV2l0aC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRXJyb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2F0dGVtcHQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXNjYXBlU3RyaW5nQ2hhci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlSW50ZXJwb2xhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUHJvcGVydHlPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZUh0bWxDaGFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUb1N0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VzY2FwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlRXNjYXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVFdmFsdWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGVTZXR0aW5ncy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUVhY2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGb3JPd24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRWFjaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdEZ1bmN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mb3JFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlQ2xlYXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NvY0luZGV4T2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19MaXN0Q2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0NsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaENsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0hhc2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXlhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWFwRGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwQ2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja1NldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N0YWNrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fVWludDhBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVR5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lT2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZU9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NhZmVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWVyZ2VEZWVwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1lcmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9tZXJnZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0Q2FjaGVBZGQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1NldENhY2hlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTb21lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEFycmF5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcFRvQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxCeVRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5UHVzaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlGaWx0ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFN5bWJvbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxPYmplY3RzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fRGF0YVZpZXcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19Qcm9taXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fV2Vha01hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTWF0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXRjaERhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXRjaGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21lbW9pemUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tZW1vaXplQ2FwcGVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaW5nVG9QYXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdFBhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b0tleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VIYXNJbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc1BhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2hhc0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3Byb3BlcnR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUl0ZXJhdGVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTb3J0QnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wYXJlQXNjZW5kaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29tcGFyZU11bHRpcGxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU9yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL29yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRmluZEluZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmFOLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaWN0SW5kZXhPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub29wLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlU2V0LmpzIiwiLi4vLi4vc3JjL29iamVjdHMvZmVlZC9GZWVkLmpzIiwiLi4vLi4vc3JjL3V0aWxpdGllcy90b2dnbGUvVG9nZ2xlLmpzIiwiLi4vLi4vc3JjL3V0aWxpdGllcy90cmFjay9UcmFjay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLmJyb3dzZXIuanMiLCIuLi8uLi9zcmMvZWxlbWVudHMvc2VsZWN0L3NlbGVjdC52dWUiLCIuLi8uLi9zcmMvZWxlbWVudHMvc2VsZWN0L3NlbGVjdC5kYXRhLmpzIiwiLi4vLi4vc3JjL2VsZW1lbnRzL3NlbGVjdC9zZWxlY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWNoYXJ0anMvZXMvbWl4aW5zL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9DaGFydC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUtY2hhcnRqcy9lcy9CYXNlQ2hhcnRzLmpzIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1iYXIudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LmRhdGEuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWJhci5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0taG9yaXpvbnRhbC1iYXIudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1ob3Jpem9udGFsLWJhci5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0tbGluZS52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWxpbmUuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZS52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZS5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL21hcC9tYXAudnVlIiwiLi4vLi4vc3JjL2pzL21hcC5kYXRhLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2dlb2pzb24vZ2VvanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy93Z3M4NC9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWFwYm94L2dlb2pzb24tYXJlYS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9nZW9qc29uLXJld2luZC9pbmRleC5qcyIsIi4uLy4uL3NyYy9qcy9NYXAuanMiLCIuLi8uLi9zcmMvanMvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIFV0aWxpdHkgY2xhc3NcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBVdGlsaXR5IHtcbiAgLyoqXG4gICAqIFRoZSBVdGlsaXR5IGNvbnN0cnVjdG9yXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIFV0aWxpdHkgY2xhc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxuICogQm9vbGVhbiBmb3IgZGVidWcgbW9kZVxuICogQHJldHVybiB7Ym9vbGVhbn0gd2V0aGVyIG9yIG5vdCB0aGUgZnJvbnQtZW5kIGlzIGluIGRlYnVnIG1vZGUuXG4gKi9cblV0aWxpdHkuZGVidWcgPSAoKSA9PiAoVXRpbGl0eS5nZXRVcmxQYXJhbWV0ZXIoVXRpbGl0eS5QQVJBTVMuREVCVUcpID09PSAnMScpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4ga2V5IGluIGEgVVJMIHF1ZXJ5IHN0cmluZy4gSWYgbm8gVVJMIHF1ZXJ5XG4gKiBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBjdXJyZW50IFVSTCBsb2NhdGlvbiBpcyB1c2VkLlxuICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgICAgICAgLSBLZXkgbmFtZS5cbiAqIEBwYXJhbSAgez9zdHJpbmd9IHF1ZXJ5U3RyaW5nIC0gT3B0aW9uYWwgcXVlcnkgc3RyaW5nIHRvIGNoZWNrLlxuICogQHJldHVybiB7P3N0cmluZ30gUXVlcnkgcGFyYW1ldGVyIHZhbHVlLlxuICovXG5VdGlsaXR5LmdldFVybFBhcmFtZXRlciA9IChuYW1lLCBxdWVyeVN0cmluZykgPT4ge1xuICBjb25zdCBxdWVyeSA9IHF1ZXJ5U3RyaW5nIHx8IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XG4gIGNvbnN0IHBhcmFtID0gbmFtZS5yZXBsYWNlKC9bXFxbXS8sICdcXFxcWycpLnJlcGxhY2UoL1tcXF1dLywgJ1xcXFxdJyk7XG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW1xcXFw/Jl0nICsgcGFyYW0gKyAnPShbXiYjXSopJyk7XG4gIGNvbnN0IHJlc3VsdHMgPSByZWdleC5leGVjKHF1ZXJ5KTtcblxuICByZXR1cm4gcmVzdWx0cyA9PT0gbnVsbCA/ICcnIDpcbiAgICBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG59O1xuXG4vKipcbiAqIEZvciB0cmFuc2xhdGluZyBzdHJpbmdzLCB0aGVyZSBpcyBhIGdsb2JhbCBMT0NBTElaRURfU1RSSU5HUyBhcnJheSB0aGF0XG4gKiBpcyBkZWZpbmVkIG9uIHRoZSBIVE1MIHRlbXBsYXRlIGxldmVsIHNvIHRoYXQgdGhvc2Ugc3RyaW5ncyBhcmUgZXhwb3NlZCB0b1xuICogV1BNTCB0cmFuc2xhdGlvbi4gVGhlIExPQ0FMSVpFRF9TVFJJTkdTIGFycmF5IGlzIGNvbXBvc2VkIG9mIG9iamVjdHMgd2l0aCBhXG4gKiBgc2x1Z2Aga2V5IHdob3NlIHZhbHVlIGlzIHNvbWUgY29uc3RhbnQsIGFuZCBhIGBsYWJlbGAgdmFsdWUgd2hpY2ggaXMgdGhlXG4gKiB0cmFuc2xhdGVkIGVxdWl2YWxlbnQuIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBzbHVnIG5hbWUgYW5kIHJldHVybnMgdGhlXG4gKiBsYWJlbC5cbiAqIEBwYXJhbSAge3N0cmluZ30gc2x1Z1xuICogQHJldHVybiB7c3RyaW5nfSBsb2NhbGl6ZWQgdmFsdWVcbiAqL1xuVXRpbGl0eS5sb2NhbGl6ZSA9IGZ1bmN0aW9uKHNsdWcpIHtcbiAgbGV0IHRleHQgPSBzbHVnIHx8ICcnO1xuICBjb25zdCBzdHJpbmdzID0gd2luZG93LkxPQ0FMSVpFRF9TVFJJTkdTIHx8IFtdO1xuICBjb25zdCBtYXRjaCA9IHN0cmluZ3MuZmlsdGVyKFxuICAgIChzKSA9PiAocy5oYXNPd25Qcm9wZXJ0eSgnc2x1ZycpICYmIHNbJ3NsdWcnXSA9PT0gc2x1ZykgPyBzIDogZmFsc2VcbiAgKTtcbiAgcmV0dXJuIChtYXRjaFswXSAmJiBtYXRjaFswXS5oYXNPd25Qcm9wZXJ0eSgnbGFiZWwnKSkgPyBtYXRjaFswXS5sYWJlbCA6IHRleHQ7XG59O1xuXG4vKipcbiAqIEFwcGxpY2F0aW9uIHBhcmFtZXRlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblV0aWxpdHkuUEFSQU1TID0ge1xuICBERUJVRzogJ2RlYnVnJ1xufTtcblxuLyoqXG4gKiBTZWxlY3RvcnMgZm9yIHRoZSBVdGlsaXR5IG1vZHVsZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuVXRpbGl0eS5TRUxFQ1RPUlMgPSB7XG4gIHBhcnNlTWFya2Rvd246ICdbZGF0YS1qcz1cIm1hcmtkb3duXCJdJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVXRpbGl0eTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFV0aWxpdHkgZnJvbSAnLi4vLi4vanMvbW9kdWxlcy91dGlsaXR5JztcblxuLyoqXG4gKiBUaGUgSWNvbiBtb2R1bGVcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBJY29ucyB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBpY29uIGZpbGVcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgY2xhc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhdGgpIHtcbiAgICBwYXRoID0gKHBhdGgpID8gcGF0aCA6IEljb25zLnBhdGg7XG5cbiAgICBmZXRjaChwYXRoKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaylcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihyZXNwb25zZSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihlcnJvcik7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3Qgc3ByaXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHNwcml0ZS5pbm5lckhUTUwgPSBkYXRhO1xuICAgICAgICBzcHJpdGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgICBzcHJpdGUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNwcml0ZSk7XG4gICAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgcGF0aCBvZiB0aGUgaWNvbiBmaWxlICovXG5JY29ucy5wYXRoID0gJ2ljb25zLnN2Zyc7XG5cbmV4cG9ydCBkZWZhdWx0IEljb25zO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbmV4cG9ydCBkZWZhdWx0IGNvcmVKc0RhdGE7XG4iLCJpbXBvcnQgY29yZUpzRGF0YSBmcm9tICcuL19jb3JlSnNEYXRhLmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU291cmNlO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc01hc2tlZCBmcm9tICcuL19pc01hc2tlZC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYXRpdmU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VmFsdWU7XG4iLCJpbXBvcnQgYmFzZUlzTmF0aXZlIGZyb20gJy4vX2Jhc2VJc05hdGl2ZS5qcyc7XG5pbXBvcnQgZ2V0VmFsdWUgZnJvbSAnLi9fZ2V0VmFsdWUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXROYXRpdmU7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVQcm9wZXJ0eTtcbiIsImltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcTtcbiIsImltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduVmFsdWU7XG4iLCJpbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlkZW50aXR5O1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcHBseTtcbiIsImltcG9ydCBhcHBseSBmcm9tICcuL19hcHBseS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJSZXN0O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnN0YW50O1xuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gJy4vY29uc3RhbnQuanMnO1xuaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZVByb3BlcnR5LmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hvcnRPdXQ7XG4iLCJpbXBvcnQgYmFzZVNldFRvU3RyaW5nIGZyb20gJy4vX2Jhc2VTZXRUb1N0cmluZy5qcyc7XG5pbXBvcnQgc2hvcnRPdXQgZnJvbSAnLi9fc2hvcnRPdXQuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5leHBvcnQgZGVmYXVsdCBzZXRUb1N0cmluZztcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBvdmVyUmVzdCBmcm9tICcuL19vdmVyUmVzdC5qcyc7XG5pbXBvcnQgc2V0VG9TdHJpbmcgZnJvbSAnLi9fc2V0VG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJlc3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0luZGV4O1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJdGVyYXRlZUNhbGw7XG4iLCJpbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGlzSXRlcmF0ZWVDYWxsIGZyb20gJy4vX2lzSXRlcmF0ZWVDYWxsLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQXNzaWduZXI7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVGltZXM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzQXJndW1lbnRzO1xuIiwiaW1wb3J0IGJhc2VJc0FyZ3VtZW50cyBmcm9tICcuL19iYXNlSXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViRmFsc2U7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzSW47XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXNJbiBmcm9tICcuL19uYXRpdmVLZXlzSW4uanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5c0luO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXNJbiBmcm9tICcuL19iYXNlS2V5c0luLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXNJbjtcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGNyZWF0ZUFzc2lnbmVyIGZyb20gJy4vX2NyZWF0ZUFzc2lnbmVyLmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBhbGlhcyBleHRlbmRXaXRoXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbldpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAqIH1cbiAqXG4gKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gKlxuICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduSW5XaXRoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJBcmc7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFByb3RvdHlwZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFcnJvcihFcnJvcik7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Vycm9yO1xuIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcbmltcG9ydCBiYXNlUmVzdCBmcm9tICcuL19iYXNlUmVzdC5qcyc7XG5pbXBvcnQgaXNFcnJvciBmcm9tICcuL2lzRXJyb3IuanMnO1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICogfSwgJz5fPicpO1xuICpcbiAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gKiAgIGVsZW1lbnRzID0gW107XG4gKiB9XG4gKi9cbnZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXR0ZW1wdDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VWYWx1ZXM7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICByZXR1cm4gc3JjVmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9ialZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluO1xuIiwiLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgJ1xcXFwnOiAnXFxcXCcsXG4gIFwiJ1wiOiBcIidcIixcbiAgJ1xcbic6ICduJyxcbiAgJ1xccic6ICdyJyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGVTdHJpbmdDaGFyO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzIGZyb20gJy4vX2Jhc2VLZXlzLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXM7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVJbnRlcnBvbGF0ZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5T2Y7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5T2YgZnJvbSAnLi9fYmFzZVByb3BlcnR5T2YuanMnO1xuXG4vKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xudmFyIGh0bWxFc2NhcGVzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbnZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlSHRtbENoYXI7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUb1N0cmluZztcbiIsImltcG9ydCBiYXNlVG9TdHJpbmcgZnJvbSAnLi9fYmFzZVRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1N0cmluZztcbiIsImltcG9ydCBlc2NhcGVIdG1sQ2hhciBmcm9tICcuL19lc2NhcGVIdG1sQ2hhci5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbnZhciByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gKlxuICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAqXG4gKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAqIFhTUyB2ZWN0b3JzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVzY2FwZTtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVFc2NhcGU7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nO1xuXG5leHBvcnQgZGVmYXVsdCByZUV2YWx1YXRlO1xuIiwiaW1wb3J0IGVzY2FwZSBmcm9tICcuL2VzY2FwZS5qcyc7XG5pbXBvcnQgcmVFc2NhcGUgZnJvbSAnLi9fcmVFc2NhcGUuanMnO1xuaW1wb3J0IHJlRXZhbHVhdGUgZnJvbSAnLi9fcmVFdmFsdWF0ZS5qcyc7XG5pbXBvcnQgcmVJbnRlcnBvbGF0ZSBmcm9tICcuL19yZUludGVycG9sYXRlLmpzJztcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgJ2ltcG9ydHMnOiB7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgJ18nOiB7ICdlc2NhcGUnOiBlc2NhcGUgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZVNldHRpbmdzO1xuIiwiaW1wb3J0IGFzc2lnbkluV2l0aCBmcm9tICcuL2Fzc2lnbkluV2l0aC5qcyc7XG5pbXBvcnQgYXR0ZW1wdCBmcm9tICcuL2F0dGVtcHQuanMnO1xuaW1wb3J0IGJhc2VWYWx1ZXMgZnJvbSAnLi9fYmFzZVZhbHVlcy5qcyc7XG5pbXBvcnQgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiBmcm9tICcuL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzJztcbmltcG9ydCBlc2NhcGVTdHJpbmdDaGFyIGZyb20gJy4vX2VzY2FwZVN0cmluZ0NoYXIuanMnO1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi9pc0Vycm9yLmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuaW1wb3J0IHJlSW50ZXJwb2xhdGUgZnJvbSAnLi9fcmVJbnRlcnBvbGF0ZS5qcyc7XG5pbXBvcnQgdGVtcGxhdGVTZXR0aW5ncyBmcm9tICcuL3RlbXBsYXRlU2V0dGluZ3MuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xudmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2hcbiAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gKi9cbnZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbi8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICpcbiAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSd0ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAqXG4gKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAqXG4gKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICpcbiAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICpcbiAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gKlxuICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gKiBjb21waWxlZChkYXRhKTtcbiAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gKlxuICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gKiBjb21waWxlZC5zb3VyY2U7XG4gKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gKiAvLyAgIHJldHVybiBfX3A7XG4gKiAvLyB9XG4gKlxuICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gKiAgIHZhciBKU1QgPSB7XFxcbiAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICogICB9O1xcXG4gKiAnKTtcbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gIHZhciBzZXR0aW5ncyA9IHRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0cy5fLnRlbXBsYXRlU2V0dGluZ3MgfHwgdGVtcGxhdGVTZXR0aW5ncztcblxuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICB2YXIgaXNFc2NhcGluZyxcbiAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICwgJ2cnKTtcblxuICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gIHZhciBzb3VyY2VVUkwgPSAnc291cmNlVVJMJyBpbiBvcHRpb25zID8gJy8vIyBzb3VyY2VVUkw9JyArIG9wdGlvbnMuc291cmNlVVJMICsgJ1xcbicgOiAnJztcblxuICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgfVxuICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICB9XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgIHJldHVybiBtYXRjaDtcbiAgfSk7XG5cbiAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZTtcbiAgaWYgKCF2YXJpYWJsZSkge1xuICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICB9XG4gIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgKHZhcmlhYmxlXG4gICAgICA/ICcnXG4gICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgKSArXG4gICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAoaXNFc2NhcGluZ1xuICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgOiAnJ1xuICAgICkgK1xuICAgIChpc0V2YWx1YXRpbmdcbiAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgIDogJztcXG4nXG4gICAgKSArXG4gICAgc291cmNlICtcbiAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gIH0pO1xuXG4gIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgdGhyb3cgcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRlbXBsYXRlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUVhY2g7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQmFzZUZvcjtcbiIsImltcG9ydCBjcmVhdGVCYXNlRm9yIGZyb20gJy4vX2NyZWF0ZUJhc2VGb3IuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGb3I7XG4iLCJpbXBvcnQgYmFzZUZvciBmcm9tICcuL19iYXNlRm9yLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUZvck93bjtcbiIsImltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQmFzZUVhY2g7XG4iLCJpbXBvcnQgYmFzZUZvck93biBmcm9tICcuL19iYXNlRm9yT3duLmpzJztcbmltcG9ydCBjcmVhdGVCYXNlRWFjaCBmcm9tICcuL19jcmVhdGVCYXNlRWFjaC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlRWFjaDtcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FzdEZ1bmN0aW9uO1xuIiwiaW1wb3J0IGFycmF5RWFjaCBmcm9tICcuL19hcnJheUVhY2guanMnO1xuaW1wb3J0IGJhc2VFYWNoIGZyb20gJy4vX2Jhc2VFYWNoLmpzJztcbmltcG9ydCBjYXN0RnVuY3Rpb24gZnJvbSAnLi9fY2FzdEZ1bmN0aW9uLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGFsaWFzIGVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQHNlZSBfLmZvckVhY2hSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICpcbiAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGNhc3RGdW5jdGlvbihpdGVyYXRlZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JFYWNoO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVDbGVhcjtcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzb2NJbmRleE9mO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZURlbGV0ZTtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlR2V0O1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlSGFzO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZVNldDtcbiIsImltcG9ydCBsaXN0Q2FjaGVDbGVhciBmcm9tICcuL19saXN0Q2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbGlzdENhY2hlRGVsZXRlIGZyb20gJy4vX2xpc3RDYWNoZURlbGV0ZS5qcyc7XG5pbXBvcnQgbGlzdENhY2hlR2V0IGZyb20gJy4vX2xpc3RDYWNoZUdldC5qcyc7XG5pbXBvcnQgbGlzdENhY2hlSGFzIGZyb20gJy4vX2xpc3RDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbGlzdENhY2hlU2V0IGZyb20gJy4vX2xpc3RDYWNoZVNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTGlzdENhY2hlO1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0hhcztcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVDcmVhdGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoRGVsZXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hHZXQ7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEhhcztcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hTZXQ7XG4iLCJpbXBvcnQgaGFzaENsZWFyIGZyb20gJy4vX2hhc2hDbGVhci5qcyc7XG5pbXBvcnQgaGFzaERlbGV0ZSBmcm9tICcuL19oYXNoRGVsZXRlLmpzJztcbmltcG9ydCBoYXNoR2V0IGZyb20gJy4vX2hhc2hHZXQuanMnO1xuaW1wb3J0IGhhc2hIYXMgZnJvbSAnLi9faGFzaEhhcy5qcyc7XG5pbXBvcnQgaGFzaFNldCBmcm9tICcuL19oYXNoU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IEhhc2g7XG4iLCJpbXBvcnQgSGFzaCBmcm9tICcuL19IYXNoLmpzJztcbmltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0tleWFibGU7XG4iLCJpbXBvcnQgaXNLZXlhYmxlIGZyb20gJy4vX2lzS2V5YWJsZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TWFwRGF0YTtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUdldDtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUhhcztcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlU2V0O1xuIiwiaW1wb3J0IG1hcENhY2hlQ2xlYXIgZnJvbSAnLi9fbWFwQ2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVEZWxldGUgZnJvbSAnLi9fbWFwQ2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IG1hcENhY2hlR2V0IGZyb20gJy4vX21hcENhY2hlR2V0LmpzJztcbmltcG9ydCBtYXBDYWNoZUhhcyBmcm9tICcuL19tYXBDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVTZXQgZnJvbSAnLi9fbWFwQ2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTWFwQ2FjaGU7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5pbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tTZXQ7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgc3RhY2tDbGVhciBmcm9tICcuL19zdGFja0NsZWFyLmpzJztcbmltcG9ydCBzdGFja0RlbGV0ZSBmcm9tICcuL19zdGFja0RlbGV0ZS5qcyc7XG5pbXBvcnQgc3RhY2tHZXQgZnJvbSAnLi9fc3RhY2tHZXQuanMnO1xuaW1wb3J0IHN0YWNrSGFzIGZyb20gJy4vX3N0YWNrSGFzLmpzJztcbmltcG9ydCBzdGFja1NldCBmcm9tICcuL19zdGFja1NldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuZXhwb3J0IGRlZmF1bHQgU3RhY2s7XG4iLCJpbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVCdWZmZXI7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgVWludDhBcnJheTtcbiIsImltcG9ydCBVaW50OEFycmF5IGZyb20gJy4vX1VpbnQ4QXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJpbXBvcnQgY2xvbmVBcnJheUJ1ZmZlciBmcm9tICcuL19jbG9uZUFycmF5QnVmZmVyLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlBcnJheTtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUNyZWF0ZTtcbiIsImltcG9ydCBiYXNlQ3JlYXRlIGZyb20gJy4vX2Jhc2VDcmVhdGUuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpbml0Q2xvbmVPYmplY3Q7XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZU9iamVjdDtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzYWZlR2V0O1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1BsYWluT2JqZWN0O1xuIiwiaW1wb3J0IGFzc2lnbk1lcmdlVmFsdWUgZnJvbSAnLi9fYXNzaWduTWVyZ2VWYWx1ZS5qcyc7XG5pbXBvcnQgY2xvbmVCdWZmZXIgZnJvbSAnLi9fY2xvbmVCdWZmZXIuanMnO1xuaW1wb3J0IGNsb25lVHlwZWRBcnJheSBmcm9tICcuL19jbG9uZVR5cGVkQXJyYXkuanMnO1xuaW1wb3J0IGNvcHlBcnJheSBmcm9tICcuL19jb3B5QXJyYXkuanMnO1xuaW1wb3J0IGluaXRDbG9uZU9iamVjdCBmcm9tICcuL19pbml0Q2xvbmVPYmplY3QuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0FycmF5TGlrZU9iamVjdCBmcm9tICcuL2lzQXJyYXlMaWtlT2JqZWN0LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QuanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgc2FmZUdldCBmcm9tICcuL19zYWZlR2V0LmpzJztcbmltcG9ydCB0b1BsYWluT2JqZWN0IGZyb20gJy4vdG9QbGFpbk9iamVjdC5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNZXJnZURlZXA7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGFzc2lnbk1lcmdlVmFsdWUgZnJvbSAnLi9fYXNzaWduTWVyZ2VWYWx1ZS5qcyc7XG5pbXBvcnQgYmFzZUZvciBmcm9tICcuL19iYXNlRm9yLmpzJztcbmltcG9ydCBiYXNlTWVyZ2VEZWVwIGZyb20gJy4vX2Jhc2VNZXJnZURlZXAuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5pbXBvcnQgc2FmZUdldCBmcm9tICcuL19zYWZlR2V0LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNZXJnZTtcbiIsImltcG9ydCBiYXNlTWVyZ2UgZnJvbSAnLi9fYmFzZU1lcmdlLmpzJztcbmltcG9ydCBjcmVhdGVBc3NpZ25lciBmcm9tICcuL19jcmVhdGVBc3NpZ25lci5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtZXJnZTtcbiIsImltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlcztcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0Q2FjaGVIYXM7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuaW1wb3J0IHNldENhY2hlQWRkIGZyb20gJy4vX3NldENhY2hlQWRkLmpzJztcbmltcG9ydCBzZXRDYWNoZUhhcyBmcm9tICcuL19zZXRDYWNoZUhhcy5qcyc7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuZXhwb3J0IGRlZmF1bHQgU2V0Q2FjaGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVNvbWU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FjaGVIYXM7XG4iLCJpbXBvcnQgU2V0Q2FjaGUgZnJvbSAnLi9fU2V0Q2FjaGUuanMnO1xuaW1wb3J0IGFycmF5U29tZSBmcm9tICcuL19hcnJheVNvbWUuanMnO1xuaW1wb3J0IGNhY2hlSGFzIGZyb20gJy4vX2NhY2hlSGFzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxBcnJheXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBUb0FycmF5O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0VG9BcnJheTtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBVaW50OEFycmF5IGZyb20gJy4vX1VpbnQ4QXJyYXkuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuaW1wb3J0IGVxdWFsQXJyYXlzIGZyb20gJy4vX2VxdWFsQXJyYXlzLmpzJztcbmltcG9ydCBtYXBUb0FycmF5IGZyb20gJy4vX21hcFRvQXJyYXkuanMnO1xuaW1wb3J0IHNldFRvQXJyYXkgZnJvbSAnLi9fc2V0VG9BcnJheS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsQnlUYWc7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5UHVzaDtcbiIsImltcG9ydCBhcnJheVB1c2ggZnJvbSAnLi9fYXJyYXlQdXNoLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldEFsbEtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5RmlsdGVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkFycmF5O1xuIiwiaW1wb3J0IGFycmF5RmlsdGVyIGZyb20gJy4vX2FycmF5RmlsdGVyLmpzJztcbmltcG9ydCBzdHViQXJyYXkgZnJvbSAnLi9zdHViQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldFN5bWJvbHM7XG4iLCJpbXBvcnQgYmFzZUdldEFsbEtleXMgZnJvbSAnLi9fYmFzZUdldEFsbEtleXMuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRBbGxLZXlzO1xuIiwiaW1wb3J0IGdldEFsbEtleXMgZnJvbSAnLi9fZ2V0QWxsS2V5cy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbE9iamVjdHM7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhVmlldztcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9taXNlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5leHBvcnQgZGVmYXVsdCBTZXQ7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgV2Vha01hcDtcbiIsImltcG9ydCBEYXRhVmlldyBmcm9tICcuL19EYXRhVmlldy5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuL19Qcm9taXNlLmpzJztcbmltcG9ydCBTZXQgZnJvbSAnLi9fU2V0LmpzJztcbmltcG9ydCBXZWFrTWFwIGZyb20gJy4vX1dlYWtNYXAuanMnO1xuaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRUYWc7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGVxdWFsQXJyYXlzIGZyb20gJy4vX2VxdWFsQXJyYXlzLmpzJztcbmltcG9ydCBlcXVhbEJ5VGFnIGZyb20gJy4vX2VxdWFsQnlUYWcuanMnO1xuaW1wb3J0IGVxdWFsT2JqZWN0cyBmcm9tICcuL19lcXVhbE9iamVjdHMuanMnO1xuaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzRXF1YWxEZWVwO1xuIiwiaW1wb3J0IGJhc2VJc0VxdWFsRGVlcCBmcm9tICcuL19iYXNlSXNFcXVhbERlZXAuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNFcXVhbDtcbiIsImltcG9ydCBTdGFjayBmcm9tICcuL19TdGFjay5qcyc7XG5pbXBvcnQgYmFzZUlzRXF1YWwgZnJvbSAnLi9fYmFzZUlzRXF1YWwuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTWF0Y2g7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiaW1wb3J0IGlzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19pc1N0cmljdENvbXBhcmFibGUuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hdGNoRGF0YTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJpbXBvcnQgYmFzZUlzTWF0Y2ggZnJvbSAnLi9fYmFzZUlzTWF0Y2guanMnO1xuaW1wb3J0IGdldE1hdGNoRGF0YSBmcm9tICcuL19nZXRNYXRjaERhdGEuanMnO1xuaW1wb3J0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXRjaGVzO1xuIiwiaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0tleTtcbiIsImltcG9ydCBNYXBDYWNoZSBmcm9tICcuL19NYXBDYWNoZS5qcyc7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZTtcbiIsImltcG9ydCBtZW1vaXplIGZyb20gJy4vbWVtb2l6ZS5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZUNhcHBlZDtcbiIsImltcG9ydCBtZW1vaXplQ2FwcGVkIGZyb20gJy4vX21lbW9pemVDYXBwZWQuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ1RvUGF0aDtcbiIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNLZXkgZnJvbSAnLi9faXNLZXkuanMnO1xuaW1wb3J0IHN0cmluZ1RvUGF0aCBmcm9tICcuL19zdHJpbmdUb1BhdGguanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYXN0UGF0aDtcbiIsImltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvS2V5O1xuIiwiaW1wb3J0IGNhc3RQYXRoIGZyb20gJy4vX2Nhc3RQYXRoLmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXQ7XG4iLCJpbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXQ7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUhhc0luO1xuIiwiaW1wb3J0IGNhc3RQYXRoIGZyb20gJy4vX2Nhc3RQYXRoLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNQYXRoO1xuIiwiaW1wb3J0IGJhc2VIYXNJbiBmcm9tICcuL19iYXNlSGFzSW4uanMnO1xuaW1wb3J0IGhhc1BhdGggZnJvbSAnLi9faGFzUGF0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzSW47XG4iLCJpbXBvcnQgYmFzZUlzRXF1YWwgZnJvbSAnLi9fYmFzZUlzRXF1YWwuanMnO1xuaW1wb3J0IGdldCBmcm9tICcuL2dldC5qcyc7XG5pbXBvcnQgaGFzSW4gZnJvbSAnLi9oYXNJbi5qcyc7XG5pbXBvcnQgaXNLZXkgZnJvbSAnLi9faXNLZXkuanMnO1xuaW1wb3J0IGlzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19pc1N0cmljdENvbXBhcmFibGUuanMnO1xuaW1wb3J0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eTtcbiIsImltcG9ydCBiYXNlR2V0IGZyb20gJy4vX2Jhc2VHZXQuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5RGVlcDtcbiIsImltcG9ydCBiYXNlUHJvcGVydHkgZnJvbSAnLi9fYmFzZVByb3BlcnR5LmpzJztcbmltcG9ydCBiYXNlUHJvcGVydHlEZWVwIGZyb20gJy4vX2Jhc2VQcm9wZXJ0eURlZXAuanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJvcGVydHk7XG4iLCJpbXBvcnQgYmFzZU1hdGNoZXMgZnJvbSAnLi9fYmFzZU1hdGNoZXMuanMnO1xuaW1wb3J0IGJhc2VNYXRjaGVzUHJvcGVydHkgZnJvbSAnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IHByb3BlcnR5IGZyb20gJy4vcHJvcGVydHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXRlcmF0ZWU7XG4iLCJpbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWFwO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNvcnRCeTtcbiIsImltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqXG4gKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wYXJlQXNjZW5kaW5nO1xuIiwiaW1wb3J0IGNvbXBhcmVBc2NlbmRpbmcgZnJvbSAnLi9fY29tcGFyZUFzY2VuZGluZy5qcyc7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBhcmVNdWx0aXBsZTtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgYmFzZU1hcCBmcm9tICcuL19iYXNlTWFwLmpzJztcbmltcG9ydCBiYXNlU29ydEJ5IGZyb20gJy4vX2Jhc2VTb3J0QnkuanMnO1xuaW1wb3J0IGJhc2VVbmFyeSBmcm9tICcuL19iYXNlVW5hcnkuanMnO1xuaW1wb3J0IGNvbXBhcmVNdWx0aXBsZSBmcm9tICcuL19jb21wYXJlTXVsdGlwbGUuanMnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICB2YXIgaW5kZXggPSAtMTtcbiAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLmxlbmd0aCA/IGl0ZXJhdGVlcyA6IFtpZGVudGl0eV0sIGJhc2VVbmFyeShiYXNlSXRlcmF0ZWUpKTtcblxuICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU9yZGVyQnk7XG4iLCJpbXBvcnQgYmFzZU9yZGVyQnkgZnJvbSAnLi9fYmFzZU9yZGVyQnkuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIHNvcnRcbiAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXG4gKiBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvclxuICogZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBcnJheVtdfEZ1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICogXTtcbiAqXG4gKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gKiBfLm9yZGVyQnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICovXG5mdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICB9XG4gIG9yZGVycyA9IGd1YXJkID8gdW5kZWZpbmVkIDogb3JkZXJzO1xuICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgIG9yZGVycyA9IG9yZGVycyA9PSBudWxsID8gW10gOiBbb3JkZXJzXTtcbiAgfVxuICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvcmRlckJ5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGaW5kSW5kZXg7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYU47XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmljdEluZGV4T2Y7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUluY2x1ZGVzV2l0aDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vb3A7XG4iLCJpbXBvcnQgU2V0IGZyb20gJy4vX1NldC5qcyc7XG5pbXBvcnQgbm9vcCBmcm9tICcuL25vb3AuanMnO1xuaW1wb3J0IHNldFRvQXJyYXkgZnJvbSAnLi9fc2V0VG9BcnJheS5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAqL1xudmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVNldDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IF90ZW1wbGF0ZSBmcm9tICdsb2Rhc2gtZXMvdGVtcGxhdGUnO1xuaW1wb3J0IF9mb3JFYWNoIGZyb20gJ2xvZGFzaC1lcy9mb3JFYWNoJztcbmltcG9ydCBfbWVyZ2UgZnJvbSAnbG9kYXNoLWVzL21lcmdlJztcbmltcG9ydCBfdmFsdWVzIGZyb20gJ2xvZGFzaC1lcy92YWx1ZXMnO1xuaW1wb3J0IF9vcmRlckJ5IGZyb20gJ2xvZGFzaC1lcy9vcmRlckJ5JztcbmltcG9ydCBfdW5pcUJ5IGZyb20gJ2xvZGFzaC1lcy91bmlxQnknO1xuXG4vKipcbiAqXG4gKi9cbmNsYXNzIEZlZWQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHQgPSBGZWVkLmRlZmF1bHQ7XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9tZXJnZSh7fSwgRmVlZC5kZWZhdWx0LCBjb25maWcpO1xuXG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBsZXQgZGF0YSA9IFtdO1xuICAgIGxldCBmZWVkID0gdGhpcy5fc2V0dGluZ3MuZmVlZDtcbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgcnNzVG9Kc29uOiBGZWVkLnJzc1RvSnNvbixcbiAgICAgIHJzc1VybDogKEFycmF5LmlzQXJyYXkoZmVlZCkpID8gZmVlZCA6IFtmZWVkXVxuICAgIH07XG5cbiAgICAvLyBHbyB0aHJvdWdoIGVhY2ggZmVlZFxuICAgIF9mb3JFYWNoKGNvbmZpZy5yc3NVcmwsICh1cmwsIGluZGV4KSA9PiB7XG4gICAgICAvLyBNYWtlIHRoZSByZXF1ZXN0XG4gICAgICB0aGlzLl9yZXF1ZXN0KGNvbmZpZywgdXJsKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGRhdGFcbiAgICAgICAgICBkYXRhLnB1c2godGhpcy5fcHJvY2VzcyhKU09OLnBhcnNlKHJlc3BvbnNlKSwgdGhpcy5fc2V0dGluZ3MpKTtcbiAgICAgICAgICAvLyBXaGVuIGFsbCBmZWVkcyBoYXZlIGJlZW4gcmVxdWVzdGVkLCBtZXJnZSB0aGUgZGF0YSBhbmQgY29tcGlsZVxuICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gY29uZmlnLnJzc1VybC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX21lcmdlKGRhdGEsIHRoaXMuX3NldHRpbmdzKTtcblxuICAgICAgICAgICAgbGV0IGNvbXBpbGVkID0gdGhpcy5fcmVuZGVyKFxuICAgICAgICAgICAgICB0aGlzLl9tZXJnZShkYXRhLCB0aGlzLl9zZXR0aW5ncyksXG4gICAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuX3NldHRpbmdzLnNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChlbCkgZWwuaW5uZXJIVE1MID0gY29tcGlsZWQ7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gWEhSIHJlcXVlc3QgZm9yIHRoZSBmZWVkIGRhdGFcbiAgICogQHBhcmFtICB7b2JqZWN0fSBjb25maWcgVGhlIHJlcXVlc3QgZGF0YVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAgICBUaGUgcmVxdWVzdCB1cmxcbiAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUmVzb2x2ZXMgd2hlbiB0aGUgcmVzcG9uc2UgaXMgcmVhZHksIHJlamVjdHMgd2hlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb3BlcmF0aW9uIHRpbWVzIG91dCBvciB0aGVyZSBpcyBhbiBlcnJvci5cbiAgICovXG4gIF9yZXF1ZXN0KGNvbmZpZywgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBsZXQgX3hociA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKF94aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIGlmIChfeGhyLnN0YXR1cyA+PSAyMDAgJiYgX3hoci5zdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAgIHJlc29sdmUoX3hoci5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoX3hoci5zdGF0dXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBGZWVkIHJlcXVlc3QgdGltZWQgb3V0JykpO1xuICAgICAgfTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCBgJHtjb25maWcucnNzVG9Kc29ufT9yc3NfdXJsPSR7dXJsfWAsIHRydWUpO1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICAgIHhociA9IG51bGw7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFzcyBkYXRhIHRvIHRoZSBhcHByb3ByaWF0ZSBwcm9jZXNzaW5nIGZ1bmN0aW9uIGJhc2VkIG9uIHR5cGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBkYXRhICAgICBUaGUgcmVxdWVzdGVkIGZlZWQgZGF0YSB0byBwYXNzXG4gICAqIEBwYXJhbSAge29iamVjdH0gc2V0dGluZ3MgVGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIHByb2Nlc3NlZCBkYXRhXG4gICAqL1xuICBfcHJvY2VzcyhkYXRhLCBzZXR0aW5ncykge1xuICAgIHJldHVybiBGZWVkLnByb2Nlc3Nbc2V0dGluZ3MudHlwZV0oZGF0YSwgc2V0dGluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhc3MgZGF0YSB0byB0aGUgYXBwcm9wcmlhdGUgbWVyZ2UgZnVuY3Rpb24gYmFzZWQgb24gdHlwZVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGRhdGEgICAgIFRoZSByZXF1ZXN0ZWQgZmVlZCBkYXRhIHRvIHBhc3NcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzZXR0aW5ncyBUaGUgYXBwbGljYXRpb24gc2V0dGluZ3NcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBUaGUgbWVyZ2VkIGZlZWQgZGF0YVxuICAgKi9cbiAgX21lcmdlKGRhdGEsIHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIEZlZWQubWVyZ2Vbc2V0dGluZ3MudHlwZV0oZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZSB0ZW1wbGF0ZSBjb21wb25lbnRzLCBwYXNzIGRhdGEsIGFuZCByZXR1cm4gY29tcGlsZWQgdGVtbGF0ZVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGRhdGEgICAgIFRoZSByZXF1ZXN0ZWQgZmVlZCBkYXRhIHRvIHBhc3NcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzZXR0aW5ncyBUaGUgYXBwbGljYXRpb24gc2V0dGluZ3NcbiAgICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICBUaGUgY29tcGxpZWQgaHRtbCBzdHJpbmdcbiAgICovXG4gIF9yZW5kZXIoZGF0YSwgc2V0dGluZ3MpIHtcbiAgICBkYXRhLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cbiAgICBpZiAoc2V0dGluZ3MubG9nKVxuICAgICAgY29uc29sZS5kaXIoZGF0YSk7XG5cbiAgICBsZXQgdGVtcGxhdGUgPSBfdmFsdWVzKHNldHRpbmdzLnRlbXBsYXRlcykuam9pbignJyk7XG4gICAgbGV0IGNvbXBpbGVkID0gX3RlbXBsYXRlKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICB7XG4gICAgICAgICdpbXBvcnRzJzoge1xuICAgICAgICAgICdfZWFjaCc6IF9mb3JFYWNoXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb21waWxlZChkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIG9wZW4gUlNTIHRvIEpTT04gYXBpLCBzZWUgaHR0cHM6Ly9yc3MyanNvbi5jb21cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkZlZWQucnNzVG9Kc29uID0gJ2h0dHBzOi8vYXBpLnJzczJqc29uLmNvbS92MS9hcGkuanNvbic7XG5cbi8qKlxuICogVGhlIHRlbXBsYXRlIGZvciB0aGUgd2lkZ2V0LlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuRmVlZC50ZW1wbGF0ZXMgPSB7XG4gIG1lZGl1bToge1xuICAgIG9wZW5lcjogW1xuICAgICAgJzxzZWN0aW9uIGNsYXNzPVwiby1mZWVkIDwlLSBzZXR0aW5ncy5jbGFzc2VzLndyYXBwZXIgJT5cIiBzdHlsZT1cIicsXG4gICAgICAgICc8JSBpZiAoc2V0dGluZ3MuZm9udFNpemUpIHsgJT5mb250LXNpemU6IDwlLSBzZXR0aW5ncy5mb250U2l6ZSAlPjs8JSB9ICU+JyxcbiAgICAgICAgJzwlIGlmIChzZXR0aW5ncy5wb3N0Qm9yZGVyQ29sb3IpIHsgJT5ib3JkZXItY29sb3I6IDwlLSBzZXR0aW5ncy5wb3N0Qm9yZGVyQ29sb3IgJT47PCUgfSAlPicsXG4gICAgICAnXCI+J1xuICAgIF0sXG4gICAgaGVhZGVyOiBbXG4gICAgICAnPGhlYWRlciBjbGFzcz1cIm8tZmVlZF9faGVhZGVyIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmhlYWRlciAlPlwiPicsXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiby1mZWVkX19hdmF0YXIgPCUtIHNldHRpbmdzLmNsYXNzZXMuYXZhdGFyICU+XCI+JyxcbiAgICAgICAgICAnPGltZyBzcmM9XCInLFxuICAgICAgICAgICAgICAgICc8JSBpZiAoc2V0dGluZ3MucHJvZmlsZUltZyAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAgICAgICAnPCUtIHNldHRpbmdzLnByb2ZpbGVJbWcgJT4nLFxuICAgICAgICAgICAgICAgICc8JSB9IGVsc2UgeyAlPicsXG4gICAgICAgICAgICAgICAgICAnPCUtIGZlZWQucHJvZmlsZUltZyAlPicsXG4gICAgICAgICAgICAgICAgJzwlIH0gJT5cIiAnLFxuICAgICAgICAgICAgICAgJ3dpZHRoPVwiPCUtIHNldHRpbmdzLnJhdGlvUHJvZmlsZVswXSAlPlwiICcsXG4gICAgICAgICAgICAgICAnaGVpZ2h0PVwiPCUtIHNldHRpbmdzLnJhdGlvUHJvZmlsZVsxXSAlPlwiPicsXG4gICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAnPGEgY2xhc3M9XCJvLWZlZWRfX3VybCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5hdmF0YXIgJT5cIiAnLFxuICAgICAgICAgICdocmVmPVwiPCUgaWYgKHNldHRpbmdzLnRpdGxlVXJsICE9PSBcIlwiKSB7ICU+JyxcbiAgICAgICAgICAgICc8JS0gc2V0dGluZ3MudGl0bGVVcmwgJT4nLFxuICAgICAgICAgICc8JSB9IGVsc2UgeyAlPicsXG4gICAgICAgICAgICAnPCUtIGZlZWQudXJsICU+JyxcbiAgICAgICAgICAnPCUgfSAlPlwiICcsXG4gICAgICAgICAgICd0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI+JyxcbiAgICAgICAgICAnPCUgaWYgKHNldHRpbmdzLnRpdGxlICE9PSBcIlwiKSB7ICU+JyxcbiAgICAgICAgICAgICc8JS0gc2V0dGluZ3MudGl0bGUgJT4nLFxuICAgICAgICAgICc8JSB9IGVsc2UgeyAlPicsXG4gICAgICAgICAgICAnPCUtIGZlZWQudGl0bGUgJT4nLFxuICAgICAgICAgICc8JSB9ICU+JyxcbiAgICAgICAgJzwvYT4nLFxuICAgICAgJzwvaGVhZGVyPidcbiAgICBdLFxuICAgIHBvc3RzOiBbXG4gICAgICAnPGRpdiBjbGFzcz1cIm8tZmVlZF9faXRlbXNcIiBzdHlsZT1cIicsXG4gICAgICAgICdib3JkZXItY29sb3I6IDwlLSBzZXR0aW5ncy5wb3N0Qm9yZGVyQ29sb3IgJT47JyxcbiAgICAgICdcIj4nLFxuICAgICAgICAnPCUgX2VhY2goaXRlbXMsIGZ1bmN0aW9uKHBvc3QpIHsgJT4nLFxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYy1mZWVkLWl0ZW0gPCUtIHNldHRpbmdzLmNsYXNzZXMuZmVlZEl0ZW0gJT5cIj4nLFxuICAgICAgICAgICAgJzxoNCBjbGFzcz1cImMtZmVlZC1pdGVtX190aXRsZSA8JS0gc2V0dGluZ3MuY2xhc3Nlcy50aXRsZSAlPlwiPicsXG4gICAgICAgICAgICAgICc8YSBjbGFzcz1cImMtZmVlZC1pdGVtX19saW5rIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmxpbmsgJT5cIicsXG4gICAgICAgICAgICAgICAgICdocmVmPVwiPCUtIHBvc3QuZ3VpZCAlPlwiJyxcbiAgICAgICAgICAgICAgICAgJ3RhcmdldD1cIl9ibGFua1wiJyxcbiAgICAgICAgICAgICAgICAgJ3JlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXIgbm9mb2xsb3dcIj4nLFxuICAgICAgICAgICAgICAgICc8JS0gcG9zdC50aXRsZSAlPicsXG4gICAgICAgICAgICAgICc8L2E+JyxcbiAgICAgICAgICAgICc8L2g0PicsXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJjLWZlZWQtaXRlbV9fZGF0ZSA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5kYXRlICU+XCIgJyxcbiAgICAgICAgICAgICAgICAgICd0aXRsZT1cIjwlLSBzZXR0aW5ncy5wb3N0RGF0ZVRpdGxlICU+XCI+JyxcbiAgICAgICAgICAgICAgJzwlLSBwb3N0LmRhdGUgJT4nLFxuICAgICAgICAgICAgJzwvc3Bhbj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjLWZlZWQtaXRlbV9fdGh1bWJuYWlsIDwlLSBzZXR0aW5ncy5jbGFzc2VzLnRodW1ibmFpbCAlPlwiJyxcbiAgICAgICAgICAgICAgICAgJ3N0eWxlPVwiJyxcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2U6IHVybCg8JS0gcG9zdC50aHVtYm5haWwgJT4pOycsXG4gICAgICAgICAgICAgICAgICAgICdoZWlnaHQ6IDwlLSBzZXR0aW5ncy5wb3N0SW1nSGVpZ2h0ICU+O1wiJyxcbiAgICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuPVwidHJ1ZVwiPicsXG4gICAgICAgICAgICAgICc8aW1nIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIiBzcmM9XCI8JS0gcG9zdC50aHVtYm5haWwgJT5cIiBhbHQ9XCI8JS0gcG9zdC50aXRsZSAlPlwiPicsXG4gICAgICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgICAgICc8cCBjbGFzcz1cImMtZmVlZC1pdGVtX19leGNlcnB0IDwlLSBzZXR0aW5ncy5jbGFzc2VzLmV4Y2VycHQgJT5cIj4nLFxuICAgICAgICAgICAgICAnPCUtIHBvc3QuZXhjZXJwdCAlPjwlLSBzZXR0aW5ncy5wb3N0RXhjZXJwdFRyYWlsICU+JyxcbiAgICAgICAgICAgICc8L3A+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYy1mZWVkLWl0ZW1fX2Zvb3RlciA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5pdGVtRm9vdGVyICU+XCI+JyxcbiAgICAgICAgICAgICAgJzxhIGNsYXNzPVwiYy1mZWVkLWl0ZW1fX2N0YSA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5jdGEgJT5cIiAnLFxuICAgICAgICAgICAgICAgICAnaHJlZj1cIjwlLSBwb3N0Lmd1aWQgJT5cIiAnLFxuICAgICAgICAgICAgICAgICAndGFyZ2V0PVwiX2JsYW5rXCIgJyxcbiAgICAgICAgICAgICAgICAgJ3JlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXIgbm9mb2xsb3dcIj4nLFxuICAgICAgICAgICAgICAgICc8JS0gc2V0dGluZ3MucG9zdEN0YVRleHQgJT4nLFxuICAgICAgICAgICAgICAnPC9hPicsXG4gICAgICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgJzwlIH0pOyAlPicsXG4gICAgICAnPC9kaXY+J1xuICAgIF0sXG4gICAgY2xvc2VyOiBbXG4gICAgICAnPC9zZWN0aW9uPidcbiAgICBdXG4gIH1cbn07XG5cbi8qKlxuICogRnVuY3Rpb25zIGZvciBwcm9jZXNzaW5nIHRoZSBkYXRhIGJhc2VkIG9uIHRoZSBmZWVkIHR5cGUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5GZWVkLnByb2Nlc3MgPSB7XG4gIG1lZGl1bTogZnVuY3Rpb24oZGF0YSwgc2V0dGluZ3MpIHtcbiAgICBsZXQgbGVuZ3RoID0gc2V0dGluZ3MucG9zdEV4Y2VycHRMZW5ndGg7XG5cbiAgICBfZm9yRWFjaChkYXRhLml0ZW1zLCBmdW5jdGlvbihwb3N0LCBpbmRleCkge1xuICAgICAgbGV0IGV4Y2VycHQgPSAnJztcbiAgICAgIGxldCBkYXRlID0gJyc7XG5cbiAgICAgIC8vIFJlbW92ZSBmaWd1cmVzIGZpcnN0XG4gICAgICBleGNlcnB0ID0gcG9zdC5kZXNjcmlwdGlvblxuICAgICAgICAucmVwbGFjZSgvPGZpZ3VyZS4qPi4qPzxcXC9maWd1cmU+L2csICcnKTtcblxuICAgICAgLy8gUmVtb3ZlIGFsbCB0YWdzXG4gICAgICBleGNlcnB0ID0gZXhjZXJwdC5yZXBsYWNlKC88KC58XFxuKSo/Pi9nLCAnJyk7XG5cbiAgICAgIC8vIFRyaW0gdGhlIGV4Y2VycHRcbiAgICAgIGV4Y2VycHQgPSBleGNlcnB0LnN1YnN0cigwLCBsZW5ndGgpO1xuICAgICAgZXhjZXJwdCA9IGV4Y2VycHQuc3Vic3RyKDAsXG4gICAgICAgIE1hdGgubWluKGV4Y2VycHQubGVuZ3RoLCBleGNlcnB0Lmxhc3RJbmRleE9mKCcgJykpXG4gICAgICApO1xuXG4gICAgICBwb3N0LmV4Y2VycHQgPSBleGNlcnB0O1xuXG4gICAgICAvLyBGb3JtYXQgdGhlIGRhdGVcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKHBvc3QucHViRGF0ZS5yZXBsYWNlKCcgJywgJ1QnKSkpXG4gICAgICAgIC50b0xvY2FsZURhdGVTdHJpbmcoc2V0dGluZ3MucG9zdERhdGVMb2NhbCwgc2V0dGluZ3MucG9zdERhdGVGb3JtYXQpO1xuXG4gICAgICBwb3N0LmRhdGUgPSBkYXRlO1xuXG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9KTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb25zIGZvciBtZXJnaW5nIHRoZSBkYXRhIGZlZWRzIHRvZ2V0aGVyLCBiYXNlZCBvbiB0aGUgZmVlZCB0eXBlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuRmVlZC5tZXJnZSA9IHtcbiAgbWVkaXVtOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgbGV0IG1lcmdlZCA9IHt9O1xuICAgIGxldCBpdGVtcyA9IFtdO1xuXG4gICAgLy8gQ29tYmluZSB0aGUgcG9zdCBpdGVtc1xuICAgIGRhdGEuZm9yRWFjaCgoZmVlZCkgPT4ge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoZmVlZC5pdGVtcyk7XG4gICAgfSk7XG5cbiAgICAvLyBNZXJnZSB0aGUgZGF0YSwgdGhpcyB3aWxsIG92ZXJyaWRlIHZhbHVlcywgaXQgcHJvYmFibHkgd29uJ3QgYmVcbiAgICAvLyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBmZWVkcyB0aGF0IGFyZSB0aGUgc2FtZSwgYnV0IHBvdGVudGlhbGx5XG4gICAgLy8gZGlmZmVyZW50IGZlZWQgdHlwZXMgY291bGQgdXNlIHRoaXMgYW5kIGNvbWJpbmUgdW5pcXVlIGRhdGFcbiAgICBkYXRhLmZvckVhY2goKGZlZWQpID0+IHtcbiAgICAgIG1lcmdlZCA9IF9tZXJnZShtZXJnZWQsIGZlZWQpO1xuICAgIH0pO1xuXG4gICAgLy8gR2V0IHVuaXF1ZSBwb3N0c1xuICAgIC8vIGl0ZW1zID0gX3VuaXFCeShpdGVtcywgKGl0ZW0pID0+IGl0ZW0uZ3VpZCk7XG5cbiAgICBtZXJnZWQuaXRlbXMgPSBfb3JkZXJCeShpdGVtcywgJ3B1YkRhdGUnLCAnZGVzYycpO1xuXG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfVxufVxuXG4vKipcbiAqIFNlZSBodHRwczovL3JzczJqc29uLmNvbS9kb2NzIGZvciBkZXRhaWxzIG9uIGRlZmF1bHQgcGFyYW1ldGVyc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuRmVlZC5kZWZhdWx0ID0ge1xuICBmZWVkOiAnJyxcbiAgc2VsZWN0b3I6ICcjanMtZmVlZCcsXG4gIHR5cGU6ICdtZWRpdW0nLFxuICB0aXRsZTogJycsXG4gIHRpdGxlVXJsOiAnJyxcbiAgcHJvZmlsZUltZzogJycsXG4gIGZvbnRTaXplOiAnJyxcbiAgcmF0aW9Qcm9maWxlOiBbJzUwJywgJzUwJ10sXG4gIHBvc3RCb3JkZXJDb2xvcjogJ2xpZ2h0c3RlZWxibHVlJyxcbiAgcG9zdEltZ0hlaWdodDogJzIwMHB4JyxcbiAgcG9zdEV4Y2VycHRMZW5ndGg6IDEyMCxcbiAgcG9zdEV4Y2VycHRUcmFpbDogJ+KApicsXG4gIHBvc3RDdGFUZXh0OiAnUmVhZCB0aGUgZnVsbCBwb3N0JyxcbiAgcG9zdERhdGVMb2NhbDogJ2VuLVVTJyxcbiAgcG9zdERhdGVGb3JtYXQ6IHtcbiAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgbW9udGg6ICdsb25nJyxcbiAgICBkYXk6ICdudW1lcmljJ1xuICB9LFxuICBwb3N0RGF0ZVRpdGxlOiAnUHVibGlzaGVkIERhdGUnLFxuICBjbGFzc2VzOiB7XG4gICAgd3JhcHBlcjogJycsXG4gICAgaGVhZGVyOiAnJyxcbiAgICB1cmw6ICcnLFxuICAgIGZlZWRJdGVtOiAnJyxcbiAgICB0aXRsZTogJycsXG4gICAgbGluazogJycsXG4gICAgdGh1bWJuYWlsOiAnJyxcbiAgICBleGNlcnB0OiAnJyxcbiAgICBpdGVtRm9vdGVyOiAnJyxcbiAgICBjdGE6ICcnLFxuICAgIGRhdGU6ICcnXG4gIH0sXG4gIHRlbXBsYXRlczoge1xuICAgIG9wZW5lcjogRmVlZC50ZW1wbGF0ZXMubWVkaXVtLm9wZW5lci5qb2luKCcnKSxcbiAgICBoZWFkZXI6IEZlZWQudGVtcGxhdGVzLm1lZGl1bS5oZWFkZXIuam9pbignJyksXG4gICAgcG9zdHM6IEZlZWQudGVtcGxhdGVzLm1lZGl1bS5wb3N0cy5qb2luKCcnKSxcbiAgICBjbG9zZXI6IEZlZWQudGVtcGxhdGVzLm1lZGl1bS5jbG9zZXIuam9pbignJylcbiAgfSxcbiAgbG9nOiBmYWxzZSxcbiAgdW5pcXVlOiBmYWxzZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRmVlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgU2ltcGxlIFRvZ2dsZSBjbGFzcy4gVGhpcyB3aWxsIHRvZ2dsZSB0aGUgY2xhc3MgJ2FjdGl2ZScgYW5kICdoaWRkZW4nXG4gKiBvbiB0YXJnZXQgZWxlbWVudHMsIGRldGVybWluZWQgYnkgYSBjbGljayBldmVudCBvbiBhIHNlbGVjdGVkIGxpbmsgb3JcbiAqIGVsZW1lbnQuIFRoaXMgd2lsbCBhbHNvIHRvZ2dsZSB0aGUgYXJpYS1oaWRkZW4gYXR0cmlidXRlIGZvciB0YXJnZXRlZFxuICogZWxlbWVudHMgdG8gc3VwcG9ydCBzY3JlZW4gcmVhZGVycy4gVGFyZ2V0IHNldHRpbmdzIGFuZCBvdGhlciBmdW5jdGlvbmFsaXR5XG4gKiBjYW4gYmUgY29udHJvbGxlZCB0aHJvdWdoIGRhdGEgYXR0cmlidXRlcy5cbiAqXG4gKiBUaGlzIHVzZXMgdGhlIC5tYXRjaGVzKCkgbWV0aG9kIHdoaWNoIHdpbGwgcmVxdWlyZSBhIHBvbHlmaWxsIGZvciBJRVxuICogaHR0cHM6Ly9wb2x5ZmlsbC5pby92Mi9kb2NzL2ZlYXR1cmVzLyNFbGVtZW50X3Byb3RvdHlwZV9tYXRjaGVzXG4gKlxuICogQmFzaWMgVXNhZ2U7XG4gKlxuICogamF2YXNjcmlwdDpcbiAqICAgbmV3IFRvZ2dsZSgpLmluaXQoKTtcbiAqXG4gKiBUb2dnbGluZyBBbmNob3IgbGlua3M6XG4gKiAgIDxhIGRhdGEtanM9J3RvZ2dsZScgaHJlZj0nI21haW4tbWVudSc+TWVudTwvYT5cbiAqICAgPGRpdiBpZD0nbWFpbi1tZW51JyBhcmlhLWhpZGRlbj0ndHJ1ZSc+IC4uLiA8L2Rpdj5cbiAqXG4gKiBUb2dnbGluZyBhcmlhLWNvbnRyb2wgZWxlbWVudHM6XG4gKlxuICogICA8YnV0dG9uIGRhdGEtanM9J3RvZ2dsZScgYXJpYS1jb250cm9scz0nI21haW4tbWVudScgYXJpYS1wcmVzc2VkPSdmYWxzZSc+XG4gKiAgICAgIE1lbnVcbiAqICAgPC9idXR0b24+XG4gKiAgIDxkaXYgaWQ9J21haW4tbWVudScgYXJpYS1oaWRkZW49J3RydWUnPiAuLi4gPC9kaXY+XG4gKlxuICogQ3JlYXRlIFwiVW5kb1wiIEV2ZW50ICh0byBjbG9zZSBhIGRpYWxvZ3VlKTtcbiAqICAgPGEgaHJlZj0nI21haW4tbWVudScgZGF0YS1qcz0ndG9nZ2xlJyBkYXRhLXRvZ2dsZS11bmRvPScjY2xvc2UnPk1lbnU8L2E+XG4gKiAgIDxkaXYgaWQ9J21haW4tbWVudScgYXJpYS1oaWRkZW49J3RydWUnPlxuICogICAgIDxhIGlkPVwiY2xvc2VcIj5DbG9zZTwvYT5cbiAqICAgPC9kaXY+XG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgVG9nZ2xlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHMgU2V0dGluZ3MgZm9yIHRoaXMgVG9nZ2xlIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgY2xhc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHMpIHtcbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgcyA9ICghcykgPyB7fSA6IHM7XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IHtcbiAgICAgIHNlbGVjdG9yOiAocy5zZWxlY3RvcikgPyBzLnNlbGVjdG9yIDogVG9nZ2xlLnNlbGVjdG9yLFxuICAgICAgbmFtZXNwYWNlOiAocy5uYW1lc3BhY2UpID8gcy5uYW1lc3BhY2UgOiBUb2dnbGUubmFtZXNwYWNlLFxuICAgICAgaW5hY3RpdmVDbGFzczogKHMuaW5hY3RpdmVDbGFzcykgPyBzLmluYWN0aXZlQ2xhc3MgOiBUb2dnbGUuaW5hY3RpdmVDbGFzcyxcbiAgICAgIGFjdGl2ZUNsYXNzOiAocy5hY3RpdmVDbGFzcykgPyBzLmFjdGl2ZUNsYXNzIDogVG9nZ2xlLmFjdGl2ZUNsYXNzLFxuICAgIH07XG5cbiAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMuX3NldHRpbmdzLnNlbGVjdG9yKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl90b2dnbGUoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gZXZlbnQgIFRoZSBtYWluIGNsaWNrIGV2ZW50XG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIFRoZSBjbGFzc1xuICAgKi9cbiAgX3RvZ2dsZShldmVudCkge1xuICAgIGxldCBlbCA9IGV2ZW50LnRhcmdldDtcbiAgICBsZXQgdGFyZ2V0ID0gZmFsc2U7XG5cbiAgICAvKiogQW5jaG9yIExpbmtzICovXG4gICAgdGFyZ2V0ID0gKGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSA/XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSA6IHRhcmdldDtcblxuICAgIC8qKiBUb2dnbGUgQ29udHJvbHMgKi9cbiAgICAvLyBjb25zb2xlLmRpcihlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSk7XG4gICAgdGFyZ2V0ID0gKGVsLmdldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpKSA/XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKX1gKSA6IHRhcmdldDtcblxuICAgIC8qKiBNYWluIEZ1bmN0aW9uYWxpdHkgKi9cbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5lbGVtZW50VG9nZ2xlKGVsLCB0YXJnZXQpO1xuXG4gICAgLyoqIFVuZG8gKi9cbiAgICBpZiAoZWwuZGF0YXNldFtgJHt0aGlzLl9zZXR0aW5ncy5uYW1lc3BhY2V9VW5kb2BdKSB7XG4gICAgICBjb25zdCB1bmRvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgZWwuZGF0YXNldFtgJHt0aGlzLl9zZXR0aW5ncy5uYW1lc3BhY2V9VW5kb2BdXG4gICAgICApO1xuXG4gICAgICB1bmRvLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudFRvZ2dsZShlbCwgdGFyZ2V0KTtcbiAgICAgICAgdW5kby5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1haW4gdG9nZ2xpbmcgbWV0aG9kXG4gICAqIEBwYXJhbSAge29iamVjdH0gZWwgICAgIFRoZSBjdXJyZW50IGVsZW1lbnQgdG8gdG9nZ2xlIGFjdGl2ZVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IGVsZW1lbnQgdG8gdG9nZ2xlIGFjdGl2ZS9oaWRkZW5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgVGhlIGNsYXNzXG4gICAqL1xuICBlbGVtZW50VG9nZ2xlKGVsLCB0YXJnZXQpIHtcbiAgICBpZiAodGhpcy5fc2V0dGluZ3MuYWN0aXZlQ2xhc3MgIT09ICcnKSB7XG4gICAgICBlbC5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUNsYXNzKTtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUNsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2V0dGluZ3MuaW5hY3RpdmVDbGFzcyAhPT0gJycpIHtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuX3NldHRpbmdzLmluYWN0aXZlQ2xhc3MpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBlbGVtZW50IGZvciBkZWZpbmVkIGFyaWEgcm9sZXMgYW5kIHRvZ2dsZSB0aGVtIGlmIHRoZXkgZXhpc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRvZ2dsZS5lbEFyaWFSb2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZShUb2dnbGUuZWxBcmlhUm9sZXNbaV0pKVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoVG9nZ2xlLmVsQXJpYVJvbGVzW2ldLFxuICAgICAgICAgICEoZWwuZ2V0QXR0cmlidXRlKFRvZ2dsZS5lbEFyaWFSb2xlc1tpXSkgPT09ICd0cnVlJykpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSB0YXJnZXQgZm9yIGRlZmluZWQgYXJpYSByb2xlcyBhbmQgdG9nZ2xlIHRoZW0gaWYgdGhleSBleGlzdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVG9nZ2xlLnRhcmdldEFyaWFSb2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRhcmdldC5nZXRBdHRyaWJ1dGUoVG9nZ2xlLnRhcmdldEFyaWFSb2xlc1tpXSkpXG4gICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoVG9nZ2xlLnRhcmdldEFyaWFSb2xlc1tpXSxcbiAgICAgICAgICAhKHRhcmdldC5nZXRBdHRyaWJ1dGUoVG9nZ2xlLnRhcmdldEFyaWFSb2xlc1tpXSkgPT09ICd0cnVlJykpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpICYmXG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUNsYXNzKSlcbiAgICB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnO1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIG1haW4gc2VsZWN0b3IgdG8gYWRkIHRoZSB0b2dnbGluZyBmdW5jdGlvbiB0byAqL1xuVG9nZ2xlLnNlbGVjdG9yID0gJ1tkYXRhLWpzKj1cInRvZ2dsZVwiXSc7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgbmFtZXNwYWNlIGZvciBvdXIgZGF0YSBhdHRyaWJ1dGUgc2V0dGluZ3MgKi9cblRvZ2dsZS5uYW1lc3BhY2UgPSAndG9nZ2xlJztcblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBoaWRlIGNsYXNzICovXG5Ub2dnbGUuaW5hY3RpdmVDbGFzcyA9ICdoaWRkZW4nO1xuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIGFjdGl2ZSBjbGFzcyAqL1xuVG9nZ2xlLmFjdGl2ZUNsYXNzID0gJ2FjdGl2ZSc7XG5cbi8qKiBAdHlwZSB7QXJyYXl9IEFyaWEgcm9sZXMgdG8gdG9nZ2xlIHRydWUvZmFsc2Ugb24gdGhlIHRvZ2dsaW5nIGVsZW1lbnQgKi9cblRvZ2dsZS5lbEFyaWFSb2xlcyA9IFsnYXJpYS1wcmVzc2VkJywgJ2FyaWEtZXhwYW5kZWQnXTtcblxuLyoqIEB0eXBlIHtBcnJheX0gQXJpYSByb2xlcyB0byB0b2dnbGUgdHJ1ZS9mYWxzZSBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQgKi9cblRvZ2dsZS50YXJnZXRBcmlhUm9sZXMgPSBbJ2FyaWEtaGlkZGVuJ107XG5cbmV4cG9ydCBkZWZhdWx0IFRvZ2dsZTsiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBVdGlsaXR5IGZyb20gJy4uLy4uL2pzL21vZHVsZXMvdXRpbGl0eSc7XG5cbi8qKlxuICogVHJhY2tpbmcgYnVzIGZvciBHb29nbGUgYW5hbHl0aWNzIGFuZCBXZWJ0cmVuZHMuXG4gKi9cbmNsYXNzIFRyYWNrIHtcbiAgY29uc3RydWN0b3Iocykge1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG5cbiAgICBzID0gKCFzKSA/IHt9IDogcztcblxuICAgIHRoaXMuX3NldHRpbmdzID0ge1xuICAgICAgc2VsZWN0b3I6IChzLnNlbGVjdG9yKSA/IHMuc2VsZWN0b3IgOiBUcmFjay5zZWxlY3RvcixcbiAgICB9O1xuXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLl9zZXR0aW5ncy5zZWxlY3RvcikpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgbGV0IGtleSA9IGV2ZW50LnRhcmdldC5kYXRhc2V0LnRyYWNrS2V5O1xuICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LnRhcmdldC5kYXRhc2V0LnRyYWNrRGF0YSk7XG5cbiAgICAgIHRoaXMuY2xpY2soa2V5LCBkYXRhKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNraW5nIGZ1bmN0aW9uIHdyYXBwZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBUaGUgZmluYWwgZGF0YSBvYmplY3RcbiAgICovXG4gIGNsaWNrKGtleSwgZGF0YSkge1xuICAgIC8vIFNldCB0aGUgcGF0aCBuYW1lIGJhc2VkIG9uIHRoZSBsb2NhdGlvblxuICAgIGNvbnN0IGQgPSBkYXRhLm1hcChlbCA9PiB7XG4gICAgICAgIGlmIChlbC5oYXNPd25Qcm9wZXJ0eShUcmFjay5rZXkpKVxuICAgICAgICAgIGVsW1RyYWNrLmtleV0gPSBgJHt3aW5kb3cubG9jYXRpb24ucGF0aG5hbWV9LyR7ZWxbVHJhY2sua2V5XX1gXG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH0pO1xuXG4gICAgbGV0IHd0ID0gdGhpcy53ZWJ0cmVuZHMoa2V5LCBkKTtcbiAgICBsZXQgZ2EgPSB0aGlzLmd0YWcoa2V5LCBkKTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKVxuICAgICAgY29uc29sZS5kaXIoeydUcmFjayc6IFt3dCwgZ2FdfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cbiAgICByZXR1cm4gZDtcbiAgfTtcblxuICAvKipcbiAgICogRGF0YSBidXMgZm9yIHRyYWNraW5nIHZpZXdzIGluIFdlYnRyZW5kcyBhbmQgR29vZ2xlIEFuYWx5dGljc1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBhcHAgIFRoZSBuYW1lIG9mIHRoZSBTaW5nbGUgUGFnZSBBcHBsaWNhdGlvbiB0byB0cmFja1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBrZXkgIFRoZSBrZXkgb3IgZXZlbnQgb2YgdGhlIGRhdGFcbiAgICogQHBhcmFtICB7Y29sbGVjdGlvbn0gZGF0YSBUaGUgZGF0YSB0byB0cmFja1xuICAgKi9cbiAgdmlldyhhcHAsIGtleSwgZGF0YSkge1xuICAgIGxldCB3dCA9IHRoaXMud2VidHJlbmRzKGtleSwgZGF0YSk7XG4gICAgbGV0IGdhID0gdGhpcy5ndGFnVmlldyhhcHAsIGtleSk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgaWYgKFV0aWxpdHkuZGVidWcoKSlcbiAgICAgIGNvbnNvbGUuZGlyKHsnVHJhY2snOiBbd3QsIGdhXX0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXNoIEV2ZW50cyB0byBXZWJ0cmVuZHNcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICovXG4gIHdlYnRyZW5kcyhrZXksIGRhdGEpIHtcbiAgICBsZXQgZXZlbnQgPSBbe1xuICAgICAgJ1dULnRpJzoga2V5XG4gICAgfV07XG5cbiAgICBpZiAoZGF0YVswXSAmJiBkYXRhWzBdLmhhc093blByb3BlcnR5KFRyYWNrLmtleSkpIHtcbiAgICAgIGV2ZW50LnB1c2goe1xuICAgICAgICAnRENTLmRjc3VyaSc6IGRhdGFbMF1bVHJhY2sua2V5XVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZXZlbnQsIGRhdGEpO1xuICAgIH1cblxuICAgIC8vIEZvcm1hdCBkYXRhIGZvciBXZWJ0cmVuZHNcbiAgICBsZXQgd3RkID0ge2FyZ3NhOiBldmVudC5mbGF0TWFwKGUgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLmZsYXRNYXAoayA9PiBbaywgZVtrXV0pO1xuICAgIH0pfTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgaWYgKHR5cGVvZiBXZWJ0cmVuZHMgIT09ICd1bmRlZmluZWQnKVxuICAgICAgV2VidHJlbmRzLm11bHRpVHJhY2sod3RkKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuXG4gICAgcmV0dXJuIFsnV2VidHJlbmRzJywgd3RkXTtcbiAgfTtcblxuICAvKipcbiAgICogUHVzaCBDbGljayBFdmVudHMgdG8gR29vZ2xlIEFuYWx5dGljc1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBrZXkgIFRoZSBrZXkgb3IgZXZlbnQgb2YgdGhlIGRhdGFcbiAgICogQHBhcmFtICB7Y29sbGVjdGlvbn0gZGF0YSBUaGUgZGF0YSB0byB0cmFja1xuICAgKi9cbiAgZ3RhZyhrZXksIGRhdGEpIHtcbiAgICBsZXQgdXJpID0gZGF0YS5maW5kKChlbGVtZW50KSA9PiBlbGVtZW50Lmhhc093blByb3BlcnR5KFRyYWNrLmtleSkpO1xuXG4gICAgbGV0IGV2ZW50ID0ge1xuICAgICAgJ2V2ZW50X2NhdGVnb3J5Jzoga2V5XG4gICAgfTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgaWYgKHR5cGVvZiBndGFnICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGd0YWcoVHJhY2sua2V5LCB1cmlbVHJhY2sua2V5XSwgZXZlbnQpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYgKi9cblxuICAgIHJldHVybiBbJ2d0YWcnLCBUcmFjay5rZXksIHVyaVtUcmFjay5rZXldLCBldmVudF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggU2NyZWVuIFZpZXcgRXZlbnRzIHRvIEdvb2dsZSBBbmFseXRpY3NcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgYXBwICBUaGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb25cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqL1xuICBndGFnVmlldyhhcHAsIGtleSkge1xuICAgIGxldCB2aWV3ID0ge1xuICAgICAgYXBwX25hbWU6IGFwcCxcbiAgICAgIHNjcmVlbl9uYW1lOiBrZXlcbiAgICB9O1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICBpZiAodHlwZW9mIGd0YWcgIT09ICd1bmRlZmluZWQnKVxuICAgICAgZ3RhZygnZXZlbnQnLCAnc2NyZWVuX3ZpZXcnLCB2aWV3KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG5cbiAgICByZXR1cm4gWydndGFnJywgVHJhY2sua2V5LCAnc2NyZWVuX3ZpZXcnLCB2aWV3XTtcbiAgfTtcbn1cblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBtYWluIHNlbGVjdG9yIHRvIGFkZCB0aGUgdHJhY2tpbmcgZnVuY3Rpb24gdG8gKi9cblRyYWNrLnNlbGVjdG9yID0gJ1tkYXRhLWpzKj1cInRyYWNrXCJdJztcblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBtYWluIGV2ZW50IHRyYWNraW5nIGtleSB0byBtYXAgdG8gV2VidHJlbmRzIERDUy51cmkgKi9cblRyYWNrLmtleSA9ICdldmVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYWNrOyIsIi8qIVxuICogVnVlLmpzIHYyLjYuNlxuICogKGMpIDIwMTQtMjAxOSBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxuY29uc3QgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gKi9cbmNvbnN0IF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICBjb25zdCBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiAoXG4gICAgaXNEZWYodmFsKSAmJlxuICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gdmFsID0+IG1hcFt2YWwudG9Mb3dlckNhc2UoKV1cbiAgICA6IHZhbCA9PiBtYXBbdmFsXVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG5jb25zdCBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xuY29uc3QgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVkKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVkKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVkKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxuICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cbiAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxuY29uc3QgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gID8gbmF0aXZlQmluZFxuICA6IHBvbHlmaWxsQmluZDtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBsZXQgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xuY29uc3Qgbm8gPSAoYSwgYiwgYykgPT4gZmFsc2U7XG5cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gKi9cbmNvbnN0IGlkZW50aXR5ID0gKF8pID0+IF87XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKChrZXlzLCBtKSA9PiB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZVxuICBjb25zdCBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgY29uc3QgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGUsIGkpID0+IHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGtleSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgcmV0dXJuIGlcbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbmNvbnN0IEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG5jb25zdCBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJyxcbiAgJ3NlcnZlclByZWZldGNoJ1xuXTtcblxuLyogICovXG5cblxuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xuICAgKiBUaGlzIHdpbGwgc2lnbmlmaWNhbnRseSByZWR1Y2UgcGVyZm9ybWFuY2UgaWYgc2V0IHRvIGZhbHNlLlxuICAgKi9cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG4vKipcbiAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXG4gKiBza2lwcGluZyBcXHUxMDAwMC1cXHVFRkZGRiBkdWUgdG8gaXQgZnJlZXppbmcgdXAgUGhhbnRvbUpTXG4gKi9cbmNvbnN0IHVuaWNvZGVMZXR0ZXJzID0gJ2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQnO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgY29uc3QgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG5jb25zdCBiYWlsUkUgPSBuZXcgUmVnRXhwKGBbXiR7dW5pY29kZUxldHRlcnN9LiRfXFxcXGRdYCk7XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHJldHVyblxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbmNvbnN0IGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbmNvbnN0IGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbmNvbnN0IHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG5jb25zdCBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuY29uc3QgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xuY29uc3QgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbmNvbnN0IGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xuY29uc3QgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG5jb25zdCBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuY29uc3QgaXNQaGFudG9tSlMgPSBVQSAmJiAvcGhhbnRvbWpzLy50ZXN0KFVBKTtcbmNvbnN0IGlzRkYgPSBVQSAmJiBVQS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG5jb25zdCBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbmxldCBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG5sZXQgX2lzU2VydmVyO1xuY29uc3QgaXNTZXJ2ZXJSZW5kZXJpbmcgPSAoKSA9PiB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10gJiYgZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG5jb25zdCBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG5jb25zdCBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG5sZXQgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gY2xhc3MgU2V0ICAge1xuICAgIFxuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfVxuICAgIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmxldCB3YXJuID0gbm9vcDtcbmxldCB0aXAgPSBub29wO1xubGV0IGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbmxldCBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG57XG4gIGNvbnN0IGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIGNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIGNvbnN0IGNsYXNzaWZ5ID0gc3RyID0+IHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGMgPT4gYy50b1VwcGVyQ2FzZSgpKVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTtcblxuICB3YXJuID0gKG1zZywgdm0pID0+IHtcbiAgICBjb25zdCB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihgW1Z1ZSB3YXJuXTogJHttc2d9JHt0cmFjZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gKG1zZywgdm0pID0+IHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtWdWUgdGlwXTogJHttc2d9YCArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9ICh2bSwgaW5jbHVkZUZpbGUpID0+IHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bTtcbiAgICBsZXQgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgY29uc3QgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IGA8JHtjbGFzc2lmeShuYW1lKX0+YCA6IGA8QW5vbnltb3VzPmApICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IGAgYXQgJHtmaWxlfWAgOiAnJylcbiAgICApXG4gIH07XG5cbiAgY29uc3QgcmVwZWF0ID0gKHN0ciwgbikgPT4ge1xuICAgIGxldCByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSByZXMgKz0gc3RyO1xuICAgICAgaWYgKG4gPiAxKSBzdHIgKz0gc3RyO1xuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSB2bSA9PiB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICBjb25zdCB0cmVlID0gW107XG4gICAgICBsZXQgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoKHZtLCBpKSA9PiBgJHtcbiAgICAgICAgICBpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMilcbiAgICAgICAgfSR7XG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gYCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSl9Li4uICgke3ZtWzFdfSByZWN1cnNpdmUgY2FsbHMpYFxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKVxuICAgICAgICB9YClcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgXFxuXFxuKGZvdW5kIGluICR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bSl9KWBcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5sZXQgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbmNsYXNzIERlcCB7XG4gIFxuICBcbiAgXG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuaWQgPSB1aWQrKztcbiAgICB0aGlzLnN1YnMgPSBbXTtcbiAgfVxuXG4gIGFkZFN1YiAoc3ViKSB7XG4gICAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbiAgfVxuXG4gIHJlbW92ZVN1YiAoc3ViKSB7XG4gICAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbiAgfVxuXG4gIGRlcGVuZCAoKSB7XG4gICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeSAoKSB7XG4gICAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgICBjb25zdCBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gICAgaWYgKCFjb25maWcuYXN5bmMpIHtcbiAgICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcbiAgICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcbiAgICAgIC8vIG9yZGVyXG4gICAgICBzdWJzLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4vLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xuY29uc3QgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAodGFyZ2V0KSB7XG4gIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgdGFyZ2V0U3RhY2sucG9wKCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbn1cblxuLyogICovXG5cbmNsYXNzIFZOb2RlIHtcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgIC8vIHJlbmRlcmVkIGluIHRoaXMgY29tcG9uZW50J3Mgc2NvcGVcbiAgXG4gIFxuICAgLy8gY29tcG9uZW50IGluc3RhbmNlXG4gICAvLyBjb21wb25lbnQgcGxhY2Vob2xkZXIgbm9kZVxuXG4gIC8vIHN0cmljdGx5IGludGVybmFsXG4gICAvLyBjb250YWlucyByYXcgSFRNTD8gKHNlcnZlciBvbmx5KVxuICAgLy8gaG9pc3RlZCBzdGF0aWMgbm9kZVxuICAgLy8gbmVjZXNzYXJ5IGZvciBlbnRlciB0cmFuc2l0aW9uIGNoZWNrXG4gICAvLyBlbXB0eSBjb21tZW50IHBsYWNlaG9sZGVyP1xuICAgLy8gaXMgYSBjbG9uZWQgbm9kZT9cbiAgIC8vIGlzIGEgdi1vbmNlIG5vZGU/XG4gICAvLyBhc3luYyBjb21wb25lbnQgZmFjdG9yeSBmdW5jdGlvblxuICBcbiAgXG4gIFxuICAgLy8gcmVhbCBjb250ZXh0IHZtIGZvciBmdW5jdGlvbmFsIG5vZGVzXG4gICAvLyBmb3IgU1NSIGNhY2hpbmdcbiAgIC8vIHVzZWQgdG8gc3RvcmUgZnVuY3Rpb25hbCByZW5kZXIgY29udGV4dCBmb3IgZGV2dG9vbHNcbiAgIC8vIGZ1bmN0aW9uYWwgc2NvcGUgaWQgc3VwcG9ydFxuXG4gIGNvbnN0cnVjdG9yIChcbiAgICB0YWcsXG4gICAgZGF0YSxcbiAgICBjaGlsZHJlbixcbiAgICB0ZXh0LFxuICAgIGVsbSxcbiAgICBjb250ZXh0LFxuICAgIGNvbXBvbmVudE9wdGlvbnMsXG4gICAgYXN5bmNGYWN0b3J5XG4gICkge1xuICAgIHRoaXMudGFnID0gdGFnO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5lbG0gPSBlbG07XG4gICAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICAgIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gICAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gICAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gICAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IGNoaWxkICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxuICB9XG59XG5cbmNvbnN0IGNyZWF0ZUVtcHR5Vk5vZGUgPSAodGV4dCA9ICcnKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIGNvbnN0IGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICAvLyAjNzk3NVxuICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xuICAgIC8vIGEgY2hpbGQuXG4gICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSxcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG5jb25zdCBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuY29uc3QgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxuY29uc3QgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIGNvbnN0IG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBjb25zdCBvYiA9IHRoaXMuX19vYl9fO1xuICAgIGxldCBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG5jb25zdCBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG5sZXQgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG5jbGFzcyBPYnNlcnZlciB7XG4gIFxuICBcbiAgIC8vIG51bWJlciBvZiB2bXMgdGhhdCBoYXZlIHRoaXMgb2JqZWN0IGFzIHJvb3QgJGRhdGFcblxuICBjb25zdHJ1Y3RvciAodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gICAgdGhpcy52bUNvdW50ID0gMDtcbiAgICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmIChoYXNQcm90bykge1xuICAgICAgICBwcm90b0F1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5QXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhbGsodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gICAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICAgKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAgICovXG4gIHdhbGsgKG9iaikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gICAqL1xuICBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIGNvbnN0IGRlcCA9IG5ldyBEZXAoKTtcblxuICBjb25zdCBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIGNvbnN0IGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgY29uc3Qgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cblxuICBsZXQgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAoY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgLy8gIzc5ODE6IGZvciBhY2Nlc3NvciBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVyXG4gICAgICBpZiAoZ2V0dGVyICYmICFzZXR0ZXIpIHJldHVyblxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpXG4gICkge1xuICAgIHdhcm4oYENhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6ICR7KHRhcmdldCl9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGNvbnN0IG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpXG4gICkge1xuICAgIHdhcm4oYENhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6ICR7KHRhcmdldCl9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKGxldCBlLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xuY29uc3Qgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbntcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgYG9wdGlvbiBcIiR7a2V5fVwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIGAgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSByZXR1cm4gdG9cbiAgbGV0IGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgY29uc3Qga2V5cyA9IGhhc1N5bWJvbFxuICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXG4gICAgOiBPYmplY3Qua2V5cyhmcm9tKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIC8vIGluIGNhc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IG9ic2VydmVkLi4uXG4gICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIGNvbnRpbnVlXG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdG9WYWwgIT09IGZyb21WYWwgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QodG9WYWwpICYmXG4gICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpXG4gICAgKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIGNvbnN0IGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgY29uc3QgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIGNvbnN0IHJlcyA9IGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbDtcbiAgcmV0dXJuIHJlc1xuICAgID8gZGVkdXBlSG9va3MocmVzKVxuICAgIDogcmVzXG59XG5cbmZ1bmN0aW9uIGRlZHVwZUhvb2tzIChob29rcykge1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XG4gICAgICByZXMucHVzaChob29rc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goaG9vayA9PiB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBjb25zdCByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgaWYgKGNoaWxkVmFsKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7XG4gIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIGNoaWxkVmFsID0gdW5kZWZpbmVkO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpXG4gIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsXG4gIGNvbnN0IHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZFZhbCkge1xuICAgIGxldCBwYXJlbnQgPSByZXRba2V5XTtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBpZiAoY2hpbGRWYWwgJiYgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsXG4gIGNvbnN0IHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbmNvbnN0IGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghbmV3IFJlZ0V4cChgXlthLXpBLVpdW1xcXFwtXFxcXC4wLTlfJHt1bmljb2RlTGV0dGVyc31dKiRgKS50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnc2hvdWxkIGNvbmZvcm0gdG8gdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZSBpbiBodG1sNSBzcGVjaWZpY2F0aW9uLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIGNvbnN0IHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgcmV0dXJuXG4gIGNvbnN0IHJlcyA9IHt9O1xuICBsZXQgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2FybihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXCJwcm9wc1wiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIGAgK1xuICAgICAgYGJ1dCBnb3QgJHt0b1Jhd1R5cGUocHJvcHMpfS5gLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIGNvbnN0IGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoIWluamVjdCkgcmV0dXJuXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluamVjdCkge1xuICAgICAgY29uc3QgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdhcm4oXG4gICAgICBgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwiaW5qZWN0XCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgYCArXG4gICAgICBgYnV0IGdvdCAke3RvUmF3VHlwZShpbmplY3QpfS5gLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICBjb25zdCBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRpcnMpIHtcbiAgICAgIGNvbnN0IGRlZiQkMSA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmJCQxLCB1cGRhdGU6IGRlZiQkMSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm4oXG4gICAgICBgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwiJHtuYW1lfVwiOiBleHBlY3RlZCBhbiBPYmplY3QsIGAgK1xuICAgICAgYGJ1dCBnb3QgJHt0b1Jhd1R5cGUodmFsdWUpfS5gLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG5cbiAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gIC8vIHRoZSByZXN1bHQgb2YgYW5vdGhlciBtZXJnZU9wdGlvbnMgY2FsbC5cbiAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgaWYgKGNoaWxkLmV4dGVuZHMpIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgbGV0IGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIGNvbnN0IHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgcmV0dXJuIGFzc2V0c1tpZF1cbiAgY29uc3QgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdXG4gIGNvbnN0IFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdXG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICBjb25zdCByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmICh3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIGNvbnN0IHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICBjb25zdCBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgbGV0IHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGJvb2xlYW4gY2FzdGluZ1xuICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgY29uc3Qgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIGNvbnN0IHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgfVxuICB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICBjb25zdCBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQgdHlwZSA9IHByb3AudHlwZTtcbiAgbGV0IHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgY29uc3QgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cblxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcyksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICBsZXQgdmFsaWQ7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgY29uc3QgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi5gICtcbiAgICBgIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKX1gO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICBjb25zdCByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xuICB9XG4gIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgd2l0aCB2YWx1ZSAke3JlY2VpdmVkVmFsdWV9LmA7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2Vcbn1cblxuZnVuY3Rpb24gc3R5bGVWYWx1ZSAodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlfWBcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUgKHZhbHVlKSB7XG4gIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGVsZW0gPT4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSlcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuICguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzLnNvbWUoZWxlbSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJylcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIGxldCBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgY29uc3QgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgIGlmIChob29rcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHJldHVyblxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcgKFxuICBoYW5kbGVyLFxuICBjb250ZXh0LFxuICBhcmdzLFxuICB2bSxcbiAgaW5mb1xuKSB7XG4gIGxldCByZXM7XG4gIHRyeSB7XG4gICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgaWYgKHJlcyAmJiAhcmVzLl9pc1Z1ZSAmJiBpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzLmNhdGNoKGUgPT4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBgIChQcm9taXNlL2FzeW5jKWApKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgdGhlIHVzZXIgaW50ZW50aW9uYWxseSB0aHJvd3MgdGhlIG9yaWdpbmFsIGVycm9yIGluIHRoZSBoYW5kbGVyLFxuICAgICAgLy8gZG8gbm90IGxvZyBpdCB0d2ljZVxuICAgICAgaWYgKGUgIT09IGVycikge1xuICAgICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gbG9nRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAge1xuICAgIHdhcm4oYEVycm9yIGluICR7aW5mb306IFwiJHtlcnIudG9TdHJpbmcoKX1cImAsIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cblxubGV0IGlzVXNpbmdNaWNyb1Rhc2sgPSBmYWxzZTtcblxuY29uc3QgY2FsbGJhY2tzID0gW107XG5sZXQgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgY29uc3QgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIG1pY3JvdGFza3MuXG4vLyBJbiAyLjUgd2UgdXNlZCAobWFjcm8pIHRhc2tzIChpbiBjb21iaW5hdGlvbiB3aXRoIG1pY3JvdGFza3MpLlxuLy8gSG93ZXZlciwgaXQgaGFzIHN1YnRsZSBwcm9ibGVtcyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnRcbi8vIChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuLy8gQWxzbywgdXNpbmcgKG1hY3JvKSB0YXNrcyBpbiBldmVudCBoYW5kbGVyIHdvdWxkIGNhdXNlIHNvbWUgd2VpcmQgYmVoYXZpb3JzXG4vLyB0aGF0IGNhbm5vdCBiZSBjaXJjdW12ZW50ZWQgKGUuZy4gIzcxMDksICM3MTUzLCAjNzU0NiwgIzc4MzQsICM4MTA5KS5cbi8vIFNvIHdlIG5vdyB1c2UgbWljcm90YXNrcyBldmVyeXdoZXJlLCBhZ2Fpbi5cbi8vIEEgbWFqb3IgZHJhd2JhY2sgb2YgdGhpcyB0cmFkZW9mZiBpcyB0aGF0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvc1xuLy8gd2hlcmUgbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTAsIHdoaWNoIGhhdmUgd29ya2Fyb3VuZHMpXG4vLyBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWUgZXZlbnQgKCM2NTY2KS5cbmxldCB0aW1lckZ1bmM7XG5cbi8vIFRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4vLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbi8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbi8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgc2V0VGltZW91dChub29wKTtcbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gIGxldCBjb3VudGVyID0gMTtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaENhbGxiYWNrcyk7XG4gIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgfSk7XG4gIHRpbWVyRnVuYyA9ICgpID0+IHtcbiAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAvLyBUZWNoaW5pY2FsbHkgaXQgbGV2ZXJhZ2VzIHRoZSAobWFjcm8pIHRhc2sgcXVldWUsXG4gIC8vIGJ1dCBpdCBpcyBzdGlsbCBhIGJldHRlciBjaG9pY2UgdGhhbiBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gIHRpbWVyRnVuYyA9ICgpID0+IHtcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgbGV0IF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaCgoKSA9PiB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICB0aW1lckZ1bmMoKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxubGV0IG1hcms7XG5sZXQgbWVhc3VyZTtcblxue1xuICBjb25zdCBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSB0YWcgPT4gcGVyZi5tYXJrKHRhZyk7XG4gICAgbWVhc3VyZSA9IChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSA9PiB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG5sZXQgaW5pdFByb3h5O1xuXG57XG4gIGNvbnN0IGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIGNvbnN0IHdhcm5Ob25QcmVzZW50ID0gKHRhcmdldCwga2V5KSA9PiB7XG4gICAgd2FybihcbiAgICAgIGBQcm9wZXJ0eSBvciBtZXRob2QgXCIke2tleX1cIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IGAgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IHdhcm5SZXNlcnZlZFByZWZpeCA9ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgUHJvcGVydHkgXCIke2tleX1cIiBtdXN0IGJlIGFjY2Vzc2VkIHdpdGggXCIkZGF0YS4ke2tleX1cIiBiZWNhdXNlIGAgK1xuICAgICAgJ3Byb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCBcIiRcIiBvciBcIl9cIiBhcmUgbm90IHByb3hpZWQgaW4gdGhlIFZ1ZSBpbnN0YW5jZSB0byAnICtcbiAgICAgICdwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIFZ1ZSBpbnRlcm5hbHMnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICBjb25zdCBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oYEF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLiR7a2V5fWApO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgaGFzSGFuZGxlciA9IHtcbiAgICBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICBjb25zdCBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgY29uc3QgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fFxuICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTtcbiAgICAgICAgZWxzZSB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTtcbiAgICAgICAgZWxzZSB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICBjb25zdCBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICBjb25zdCBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5jb25zdCBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgbGV0IGksIGtleXM7XG4gIGNvbnN0IGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgY29uc3QgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTtcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7XG4gIH1cbn1cblxuLyogICovXG5cbmNvbnN0IG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKChuYW1lKSA9PiB7XG4gIGNvbnN0IHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICBjb25zdCBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICBjb25zdCBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZSxcbiAgICBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgY29uc3QgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgY29uc3QgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cywgdm0sIGB2LW9uIGhhbmRsZXJgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIGB2LW9uIGhhbmRsZXJgKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgY3JlYXRlT25jZUhhbmRsZXIsXG4gIHZtXG4pIHtcbiAgbGV0IG5hbWUsIGRlZiQkMSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYkJDEgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFwiJHtldmVudC5uYW1lfVwiOiBnb3QgYCArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyLCB2bSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNUcnVlKGV2ZW50Lm9uY2UpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlT25jZUhhbmRsZXIoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICBkZWYgPSBkZWYuZGF0YS5ob29rIHx8IChkZWYuZGF0YS5ob29rID0ge30pO1xuICB9XG4gIGxldCBpbnZva2VyO1xuICBjb25zdCBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIGNvbnN0IHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCByZXMgPSB7fTtcbiAgY29uc3QgeyBhdHRycywgcHJvcHMgfSA9IGRhdGE7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAge1xuICAgICAgICBjb25zdCBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIGBQcm9wIFwiJHtrZXlJbkxvd2VyQ2FzZX1cIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IGAgK1xuICAgICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3Rvcil9LCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc2AgK1xuICAgICAgICAgICAgYCBcIiR7a2V5fVwiLiBgICtcbiAgICAgICAgICAgIGBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIGAgK1xuICAgICAgICAgICAgYHByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gYCArXG4gICAgICAgICAgICBgdGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7YWx0S2V5fVwiIGluc3RlYWQgb2YgXCIke2tleX1cIi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGxldCBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSBjb250aW51ZVxuICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgYCR7bmVzdGVkSW5kZXggfHwgJyd9XyR7aX1gKTtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgKGNbMF0pLnRleHQpO1xuICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgIGMua2V5ID0gYF9fdmxpc3Qke25lc3RlZEluZGV4fV8ke2l9X19gO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgY29uc3QgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICBjb25zdCByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldLCAoKSA9PiB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIGAgK1xuICAgICAgICAgICAgYG92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gYCArXG4gICAgICAgICAgICBgaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFwiJHtrZXl9XCJgLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSBjb250aW51ZVxuICAgICAgY29uc3QgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICBsZXQgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIGNvbnN0IHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKGBJbmplY3Rpb24gXCIke2tleX1cIiBub3QgZm91bmRgLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHJldHVybiB7fVxuICB9XG4gIGNvbnN0IHNsb3RzID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgY29uc3QgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIGNvbnN0IHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAoY29uc3QgbmFtZSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBub3JtYWxTbG90cyxcbiAgcHJldlNsb3RzXG4pIHtcbiAgbGV0IHJlcztcbiAgaWYgKCFzbG90cykge1xuICAgIHJlcyA9IHt9O1xuICB9IGVsc2UgaWYgKHNsb3RzLl9ub3JtYWxpemVkKSB7XG4gICAgLy8gZmFzdCBwYXRoIDE6IGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXIgb25seSwgcGFyZW50IGRpZCBub3QgY2hhbmdlXG4gICAgcmV0dXJuIHNsb3RzLl9ub3JtYWxpemVkXG4gIH0gZWxzZSBpZiAoXG4gICAgc2xvdHMuJHN0YWJsZSAmJlxuICAgIHByZXZTbG90cyAmJlxuICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID09PSAwXG4gICkge1xuICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcbiAgICByZXR1cm4gcHJldlNsb3RzXG4gIH0gZWxzZSB7XG4gICAgcmVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1trZXldICYmIGtleVswXSAhPT0gJyQnKSB7XG4gICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xuICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxTbG90cykge1xuICAgIGlmICghKGtleSBpbiByZXMpKSB7XG4gICAgICByZXNba2V5XSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxuICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcbiAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgKHNsb3RzKS5fbm9ybWFsaXplZCA9IHJlcztcbiAgfVxuICBkZWYocmVzLCAnJHN0YWJsZScsIHNsb3RzID8gISFzbG90cy4kc3RhYmxlIDogdHJ1ZSk7XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICBjb25zdCBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcbiAgICByZXMgPSByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzKVxuICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcbiAgICByZXR1cm4gcmVzICYmIHJlcy5sZW5ndGggPT09IDBcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHJlc1xuICB9O1xuICAvLyB0aGlzIGlzIGEgc2xvdCB1c2luZyB0aGUgbmV3IHYtc2xvdCBzeW50YXggd2l0aG91dCBzY29wZS4gYWx0aG91Z2ggaXQgaXNcbiAgLy8gY29tcGlsZWQgYXMgYSBzY29wZWQgc2xvdCwgcmVuZGVyIGZuIHVzZXJzIHdvdWxkIGV4cGVjdCBpdCB0byBiZSBwcmVzZW50XG4gIC8vIG9uIHRoaXMuJHNsb3RzIGJlY2F1c2UgdGhlIHVzYWdlIGlzIHNlbWFudGljYWxseSBhIG5vcm1hbCBzbG90LlxuICBpZiAoZm4ucHJveHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsU2xvdHMsIGtleSwge1xuICAgICAgZ2V0OiBub3JtYWxpemVkLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkXG59XG5cbmZ1bmN0aW9uIHByb3h5Tm9ybWFsU2xvdChzbG90cywga2V5KSB7XG4gIHJldHVybiAoKSA9PiBzbG90c1trZXldXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIGxldCByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgaWYgKGhhc1N5bWJvbCAmJiB2YWxbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgcmV0ID0gW107XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICBsZXQgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICByZXQucHVzaChyZW5kZXIocmVzdWx0LnZhbHVlLCByZXQubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc0RlZihyZXQpKSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICBjb25zdCBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgbGV0IG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICBub2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgY29uc3QgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgY29uc3QgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5LZXlDb2RlO1xuICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpXG4gIH0gZWxzZSBpZiAobWFwcGVkS2V5Q29kZSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSlcbiAgfSBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcbiAgICByZXR1cm4gaHlwaGVuYXRlKGV2ZW50S2V5TmFtZSkgIT09IGtleVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcCxcbiAgaXNTeW5jXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNoO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkgJiYgIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgY29uc3Qgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bYHVwZGF0ZToke2NhbWVsaXplZEtleX1gXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIGNvbnN0IGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgbGV0IHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgYF9fc3RhdGljX18ke2luZGV4fWAsIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgYF9fb25jZV9fJHtpbmRleH0ke2tleSA/IGBfJHtrZXl9YCA6IGBgfWAsIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIGAke2tleX1fJHtpfWAsIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICBjb25zdCBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIGhhc0R5bmFtaWNLZXlzLFxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbG90ID0gZm5zW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgaGFzRHluYW1pY0tleXMsIHJlcyk7XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmREeW5hbWljS2V5cyAoYmFzZU9iaiwgdmFsdWVzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3Qga2V5ID0gdmFsdWVzW2ldO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgfSBlbHNlIGlmIChrZXkgIT09ICcnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgLy8gbnVsbCBpcyBhIHNwZWljYWwgdmFsdWUgZm9yIGV4cGxpY2l0bHkgcmVtb3ZpbmcgYSBiaW5kaW5nXG4gICAgICB3YXJuKFxuICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogJHtrZXl9YCxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VPYmpcbn1cblxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIGxldCBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIGNvbnN0IGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICBjb25zdCBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy4kc2xvdHMpIHtcbiAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICBkYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB0aGlzLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJHNsb3RzXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQgKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuc2xvdHMoKSlcbiAgICB9XG4gIH0pKTtcblxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy4kc2xvdHMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gKGEsIGIsIGMsIGQpID0+IHtcbiAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGNvbnN0IHByb3BzID0ge307XG4gIGNvbnN0IHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTtcbiAgfVxuXG4gIGNvbnN0IHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIGNvbnN0IHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcblxuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dClcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIGNvbnN0IHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgY29uc3QgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgY2xvbmUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICB7XG4gICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gIH1cbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG5jb25zdCBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0ICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgaWYgKFxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlXG4gICAgKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIGNvbnN0IG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBjb25zdCBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0ICh2bm9kZSkge1xuICAgIGNvbnN0IHsgY29udGV4dCwgY29tcG9uZW50SW5zdGFuY2UgfSA9IHZub2RlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95ICh2bm9kZSkge1xuICAgIGNvbnN0IHsgY29tcG9uZW50SW5zdGFuY2UgfSA9IHZub2RlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB3YXJuKGBJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiAke1N0cmluZyhDdG9yKX1gLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgbGV0IGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICBjb25zdCBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgY29uc3QgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIGNvbnN0IHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgY29uc3QgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgY29uc3Qgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgYHZ1ZS1jb21wb25lbnQtJHtDdG9yLmNpZH0ke25hbWUgPyBgLSR7bmFtZX1gIDogJyd9YCxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvciwgcHJvcHNEYXRhLCBsaXN0ZW5lcnMsIHRhZywgY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbikge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIHBhcmVudFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICBjb25zdCBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgY29uc3QgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgY29uc3QgZXhpc3RpbmcgPSBob29rc1trZXldO1xuICAgIGNvbnN0IHRvTWVyZ2UgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcbiAgICAgIGhvb2tzW2tleV0gPSBleGlzdGluZyA/IG1lcmdlSG9vayQxKHRvTWVyZ2UsIGV4aXN0aW5nKSA6IHRvTWVyZ2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChmMSwgZjIpIHtcbiAgY29uc3QgbWVyZ2VkID0gKGEsIGIpID0+IHtcbiAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgZjEoYSwgYik7XG4gICAgZjIoYSwgYik7XG4gIH07XG4gIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIGNvbnN0IHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIGNvbnN0IGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0J1xuICA7KGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgY29uc3Qgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBjb25zdCBleGlzdGluZyA9IG9uW2V2ZW50XTtcbiAgY29uc3QgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICBpZiAoaXNEZWYoZXhpc3RpbmcpKSB7XG4gICAgaWYgKFxuICAgICAgQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgICAgPyBleGlzdGluZy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTFcbiAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIG9uW2V2ZW50XSA9IFtjYWxsYmFja10uY29uY2F0KGV4aXN0aW5nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbmNvbnN0IFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xuY29uc3QgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICB3YXJuKFxuICAgICAgYEF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9XFxuYCArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIGxldCB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIGxldCBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCghZGF0YSB8fCAhZGF0YS5wcmUpICYmIGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAoaXNEZWYobnMpKSBhcHBseU5TKHZub2RlLCBucyk7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICBucyA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVmICM1MzE4XG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICB9XG4gIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gIGNvbnN0IG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgY29uc3QgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgY29uc3QgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IChhLCBiLCBjLCBkKSA9PiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSAoYSwgYiwgYywgZCkgPT4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICBjb25zdCBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsICgpID0+IHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihgJGF0dHJzIGlzIHJlYWRvbmx5LmAsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsICgpID0+IHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihgJGxpc3RlbmVycyBpcyByZWFkb25seS5gLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH1cbn1cblxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBjb25zdCB7IHJlbmRlciwgX3BhcmVudFZub2RlIH0gPSB2bS4kb3B0aW9ucztcblxuICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcbiAgICAgIHZtLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdm0uJHNsb3RzLFxuICAgICAgICB2bS4kc2NvcGVkU2xvdHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIGxldCB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIG1haW50YWluIGEgc3RhY2sgYmVjYXVlcyBhbGwgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHdoZW4gcGFyZW50IGNvbXBvbmVudCBpcyBwYXRjaGVkLlxuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gdm07XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgcmVuZGVyYCk7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGByZW5kZXJFcnJvcmApO1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bm9kZSA9IHZub2RlWzBdO1xuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBjb25zdCBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yXG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgY29uc3Qgb3duZXIgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChpc0RlZihmYWN0b3J5Lm93bmVycykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5Lm93bmVycy5wdXNoKG93bmVyKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvd25lcnMgPSBmYWN0b3J5Lm93bmVycyA9IFtvd25lcl07XG4gICAgbGV0IHN5bmMgPSB0cnVlO1xuXG4gICAgY29uc3QgZm9yY2VSZW5kZXIgPSAocmVuZGVyQ29tcGxldGVkKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG93bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgKG93bmVyc1tpXSkuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc29sdmUgPSBvbmNlKChyZXMpID0+IHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCByZWplY3QgPSBvbmNlKHJlYXNvbiA9PiB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiAke1N0cmluZyhmYWN0b3J5KX1gICtcbiAgICAgICAgKHJlYXNvbiA/IGBcXG5SZWFzb246ICR7cmVhc29ufWAgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlcy5jb21wb25lbnQpKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIGB0aW1lb3V0ICgke3Jlcy50aW1lb3V0fW1zKWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIGNvbnN0IGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxubGV0IHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChldmVudCwgZm4pIHtcbiAgY29uc3QgX3RhcmdldCA9IHRhcmdldDtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICBjb25zdCByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgY29uc3QgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZtLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZtLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIGNvbnN0IGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICBsZXQgY2I7XG4gICAgbGV0IGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICB7XG4gICAgICBjb25zdCBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IGAgK1xuICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUodm0pfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBgICtcbiAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgYCArXG4gICAgICAgICAgYHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBgICtcbiAgICAgICAgICBgWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShldmVudCl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICBjb25zdCBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgY29uc3QgaW5mbyA9IGBldmVudCBoYW5kbGVyIGZvciBcIiR7ZXZlbnR9XCJgO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG5sZXQgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xubGV0IGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xuICBjb25zdCBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICBjb25zdCBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgbGV0IHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgY29uc3QgcHJldkVsID0gdm0uJGVsO1xuICAgIGNvbnN0IHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICBjb25zdCByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICBjb25zdCBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICBsZXQgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIGxldCB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gdm0uX25hbWU7XG4gICAgICBjb25zdCBpZCA9IHZtLl91aWQ7XG4gICAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtcGVyZi1zdGFydDoke2lkfWA7XG4gICAgICBjb25zdCBlbmRUYWcgPSBgdnVlLXBlcmYtZW5kOiR7aWR9YDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICBjb25zdCB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoYHZ1ZSAke25hbWV9IHJlbmRlcmAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKGB2dWUgJHtuYW1lfSBwYXRjaGAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwge1xuICAgIGJlZm9yZSAoKSB7XG4gICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4uXG5cbiAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAvLyBkeW5hbWljIHNsb3QgbmFtZXMpLiBTdGF0aWMgc2NvcGVkIHNsb3RzIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaGFzIHRoZVxuICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXG4gIGNvbnN0IGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoXG4gICAgKHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgJiYgIXBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAodm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhdm0uJHNjb3BlZFNsb3RzLiRzdGFibGUpXG4gICk7XG5cbiAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAvLyB1cGRhdGUuIER5bmFtaWMgc2NvcGVkIHNsb3RzIG1heSBhbHNvIGhhdmUgY2hhbmdlZC4gSW4gc3VjaCBjYXNlcywgYSBmb3JjZWRcbiAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gIGNvbnN0IG5lZWRzRm9yY2VVcGRhdGUgPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIGhhc0R5bmFtaWNTY29wZWRTbG90XG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIGNvbnN0IHByb3BzID0gdm0uX3Byb3BzO1xuICAgIGNvbnN0IHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgY29uc3QgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICBjb25zdCBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICBjb25zdCBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBjb25zdCBpbmZvID0gYCR7aG9va30gaG9va2A7XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG5jb25zdCBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG5jb25zdCBxdWV1ZSA9IFtdO1xuY29uc3QgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbmxldCBoYXMgPSB7fTtcbmxldCBjaXJjdWxhciA9IHt9O1xubGV0IHdhaXRpbmcgPSBmYWxzZTtcbmxldCBmbHVzaGluZyA9IGZhbHNlO1xubGV0IGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLy8gQXN5bmMgZWRnZSBjYXNlICM2NTY2IHJlcXVpcmVzIHNhdmluZyB0aGUgdGltZXN0YW1wIHdoZW4gZXZlbnQgbGlzdGVuZXJzIGFyZVxuLy8gYXR0YWNoZWQuIEhvd2V2ZXIsIGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCkgaGFzIGEgcGVyZiBvdmVyaGVhZCBlc3BlY2lhbGx5XG4vLyBpZiB0aGUgcGFnZSBoYXMgdGhvdXNhbmRzIG9mIGV2ZW50IGxpc3RlbmVycy4gSW5zdGVhZCwgd2UgdGFrZSBhIHRpbWVzdGFtcFxuLy8gZXZlcnkgdGltZSB0aGUgc2NoZWR1bGVyIGZsdXNoZXMgYW5kIHVzZSB0aGF0IGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzXG4vLyBhdHRhY2hlZCBkdXJpbmcgdGhhdCBmbHVzaC5cbmxldCBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSAwO1xuXG4vLyBBc3luYyBlZGdlIGNhc2UgZml4IHJlcXVpcmVzIHN0b3JpbmcgYW4gZXZlbnQgbGlzdGVuZXIncyBhdHRhY2ggdGltZXN0YW1wLlxubGV0IGdldE5vdyA9IERhdGUubm93O1xuXG4vLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxuLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcbi8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxuLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxuaWYgKGluQnJvd3NlciAmJiBnZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xuICAvLyBpZiB0aGUgbG93LXJlcyB0aW1lc3RhbXAgd2hpY2ggaXMgYmlnZ2VyIHRoYW4gdGhlIGV2ZW50IHRpbWVzdGFtcFxuICAvLyAod2hpY2ggaXMgZXZhbHVhdGVkIEFGVEVSKSBpdCBtZWFucyB0aGUgZXZlbnQgaXMgdXNpbmcgYSBoaS1yZXMgdGltZXN0YW1wLFxuICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cbiAgZ2V0Tm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSBnZXROb3coKTtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICBsZXQgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydCgoYSwgYikgPT4gYS5pZCAtIGIuaWQpO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZiAod2F0Y2hlci5iZWZvcmUpIHtcbiAgICAgIHdhdGNoZXIuYmVmb3JlKCk7XG4gICAgfVxuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAoaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gYGluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFwiJHt3YXRjaGVyLmV4cHJlc3Npb259XCJgXG4gICAgICAgICAgICAgIDogYGluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5gXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICBjb25zdCBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIGNvbnN0IHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICBsZXQgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICBjb25zdCB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgY29uc3QgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIGxldCBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghY29uZmlnLmFzeW5jKSB7XG4gICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cblxuXG5sZXQgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG5jbGFzcyBXYXRjaGVyIHtcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuXG4gIGNvbnN0cnVjdG9yIChcbiAgICB2bSxcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnMsXG4gICAgaXNSZW5kZXJXYXRjaGVyXG4gICkge1xuICAgIHRoaXMudm0gPSB2bTtcbiAgICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gICAgfVxuICAgIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAgIC8vIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jYiA9IGNiO1xuICAgIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gICAgdGhpcy5kZXBzID0gW107XG4gICAgdGhpcy5uZXdEZXBzID0gW107XG4gICAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XG4gICAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gICAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYEZhaWxlZCB3YXRjaGluZyBwYXRoOiBcIiR7ZXhwT3JGbn1cIiBgICtcbiAgICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogdGhpcy5nZXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBnZXQgKCkge1xuICAgIHB1c2hUYXJnZXQodGhpcyk7XG4gICAgbGV0IHZhbHVlO1xuICAgIGNvbnN0IHZtID0gdGhpcy52bTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgYGdldHRlciBmb3Igd2F0Y2hlciBcIiR7dGhpcy5leHByZXNzaW9ufVwiYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHBvcFRhcmdldCgpO1xuICAgICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgKi9cbiAgYWRkRGVwIChkZXApIHtcbiAgICBjb25zdCBpZCA9IGRlcC5pZDtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gICAqL1xuICBjbGVhbnVwRGVwcyAoKSB7XG4gICAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRtcCA9IHRoaXMuZGVwSWRzO1xuICAgIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gICAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gICAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgICB0bXAgPSB0aGlzLmRlcHM7XG4gICAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICAgIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAgICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAgICovXG4gIHVwZGF0ZSAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAgICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAgICovXG4gIHJ1biAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICAgIHRoaXMuZGVlcFxuICAgICAgKSB7XG4gICAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgYGNhbGxiYWNrIGZvciB3YXRjaGVyIFwiJHt0aGlzLmV4cHJlc3Npb259XCJgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICAgKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gICAqL1xuICBldmFsdWF0ZSAoKSB7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICAgKi9cbiAgZGVwZW5kICgpIHtcbiAgICBsZXQgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAgICovXG4gIHRlYXJkb3duICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgY29uc3Qgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTtcbiAgaWYgKG9wdHMubWV0aG9kcykgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpO1xuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIGNvbnN0IHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgY29uc3QgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIGNvbnN0IGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgY29uc3QgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgY29uc3QgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgY29uc3QgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgXCIke2h5cGhlbmF0ZWRLZXl9XCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLmAsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCAoKSA9PiB7XG4gICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBgICtcbiAgICAgICAgICAgIGBvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBgICtcbiAgICAgICAgICAgIGBJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgYCArXG4gICAgICAgICAgICBgdmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXCIke2tleX1cImAsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIGBfcHJvcHNgLCBrZXkpO1xuICAgIH1cbiAgfVxuICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICBsZXQgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgY29uc3QgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgY29uc3QgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuYCxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgVGhlIGRhdGEgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gYCArXG4gICAgICAgIGBVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuYCxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgYF9kYXRhYCwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgYGRhdGEoKWApO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbmNvbnN0IGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGNvbnN0IHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICBjb25zdCBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBjb25zdCB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICBjb25zdCBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAoZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIi5gLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oYFRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLmAsIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oYFRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuYCwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgY29uc3Qgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmKTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmLmdldClcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcbiAgfVxuICBpZiAoc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgQ29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuYCxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIGNvbnN0IHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICBjb25zdCBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RzW2tleV19XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBgICtcbiAgICAgICAgICBgRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuYCxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBgICtcbiAgICAgICAgICBgQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2gpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICBjb25zdCBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICBjb25zdCBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihgJHByb3BzIGlzIHJlYWRvbmx5LmAsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIGNvbnN0IHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvciwgdm0sIGBjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXCIke3dhdGNoZXIuZXhwcmVzc2lvbn1cImApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5sZXQgdWlkJDMgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgIGxldCBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBgdnVlLXBlcmYtc3RhcnQ6JHt2bS5fdWlkfWA7XG4gICAgICBlbmRUYWcgPSBgdnVlLXBlcmYtZW5kOiR7dm0uX3VpZH1gO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZShgdnVlICR7dm0uX25hbWV9IGluaXRgLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIGNvbnN0IHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG5cbiAgY29uc3Qgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICBsZXQgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICBjb25zdCBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIGNvbnN0IGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIGNvbnN0IG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICBsZXQgbW9kaWZpZWQ7XG4gIGNvbnN0IGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgY29uc3Qgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKGNvbnN0IGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSBtb2RpZmllZCA9IHt9O1xuICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlKTtcbnN0YXRlTWl4aW4oVnVlKTtcbmV2ZW50c01peGluKFZ1ZSk7XG5saWZlY3ljbGVNaXhpbihWdWUpO1xucmVuZGVyTWl4aW4oVnVlKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgY29uc3QgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIGxldCBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgY29uc3QgU3VwZXIgPSB0aGlzO1xuICAgIGNvbnN0IFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgY29uc3QgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIGNvbnN0IHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBgX3Byb3BzYCwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICBjb25zdCBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2godHlwZSA9PiB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIGNvbnN0IHsgY2FjaGUsIGtleXMsIF92bm9kZSB9ID0ga2VlcEFsaXZlSW5zdGFuY2U7XG4gIGZvciAoY29uc3Qga2V5IGluIGNhY2hlKSB7XG4gICAgY29uc3QgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgY29uc3QgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG5jb25zdCBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkICgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcy5jYWNoZSwga2V5LCB0aGlzLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIHZhbCA9PiB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMsIG5hbWUgPT4gbWF0Y2hlcyh2YWwsIG5hbWUpKTtcbiAgICB9KTtcbiAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIHZhbCA9PiB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMsIG5hbWUgPT4gIW1hdGNoZXModmFsLCBuYW1lKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBjb25zdCB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgY29uc3QgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlIH0gPSB0aGlzO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGNhY2hlLCBrZXlzIH0gPSB0aGlzO1xuICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyBgOjoke2NvbXBvbmVudE9wdGlvbnMudGFnfWAgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICBjb25zdCBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9ICgpID0+IGNvbmZpZztcbiAge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSAoKSA9PiB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuLFxuICAgIGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXG4gIFZ1ZS5vYnNlcnZhYmxlID0gKG9iaikgPT4ge1xuICAgIG9ic2VydmUob2JqKTtcbiAgICByZXR1cm4gb2JqXG4gIH07XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbn0pO1xuXG5WdWUudmVyc2lvbiA9ICcyLjYuNic7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxuY29uc3QgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG5jb25zdCBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbmNvbnN0IG11c3RVc2VQcm9wID0gKHRhZywgdHlwZSwgYXR0cikgPT4ge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbmNvbnN0IGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxuY29uc3QgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlID0gbWFrZU1hcCgnZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seScpO1xuXG5jb25zdCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXG4gICAgPyAnZmFsc2UnXG4gICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN0cmluZyB2YWx1ZSBmb3IgY29udGVudGVkaXRhYmxlXG4gICAgOiBrZXkgPT09ICdjb250ZW50ZWRpdGFibGUnICYmIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSh2YWx1ZSlcbiAgICAgID8gdmFsdWVcbiAgICAgIDogJ3RydWUnXG59O1xuXG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxuY29uc3QgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxuY29uc3QgaXNYbGluayA9IChuYW1lKSA9PiB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbmNvbnN0IGdldFhsaW5rUHJvcCA9IChuYW1lKSA9PiB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxuY29uc3QgaXNGYWxzeUF0dHJWYWx1ZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICBsZXQgZGF0YSA9IHZub2RlLmRhdGE7XG4gIGxldCBwYXJlbnROb2RlID0gdm5vZGU7XG4gIGxldCBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBsZXQgc3RyaW5naWZpZWQ7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHJlcyArPSAnICc7XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICBsZXQgcmVzID0gJyc7XG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHJlcyArPSAnICc7XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5jb25zdCBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG5jb25zdCBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbmNvbnN0IGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbmNvbnN0IGlzUHJlVGFnID0gKHRhZykgPT4gdGFnID09PSAncHJlJztcblxuY29uc3QgaXNSZXNlcnZlZFRhZyA9ICh0YWcpID0+IHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbmNvbnN0IHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG5jb25zdCBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIGNvbnN0IGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICBjb25zdCBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFpc0RlZihrZXkpKSByZXR1cm5cblxuICBjb25zdCB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIGNvbnN0IHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgY29uc3QgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxuY29uc3QgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG5jb25zdCBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgKFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgKSB8fCAoXG4gICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSByZXR1cm4gdHJ1ZVxuICBsZXQgaTtcbiAgY29uc3QgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICBjb25zdCB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICBsZXQgaSwga2V5O1xuICBjb25zdCBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIG1hcFtrZXldID0gaTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgbGV0IGksIGo7XG4gIGNvbnN0IGNicyA9IHt9O1xuXG4gIGNvbnN0IHsgbW9kdWxlcywgbm9kZU9wcyB9ID0gYmFja2VuZDtcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGlnbm9yZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xuICAgICAgICB9KVxuICAgICAgKSAmJlxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgIClcbiAgfVxuXG4gIGxldCBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxtIChcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbSxcbiAgICBuZXN0ZWQsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleFxuICApIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgIC8vIG5vdyBpdCdzIHVzZWQgYXMgYSBuZXcgbm9kZSwgb3ZlcndyaXRpbmcgaXRzIGVsbSB3b3VsZCBjYXVzZVxuICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgIC8vIGFzc29jaWF0ZWQgRE9NIGVsZW1lbnQgZm9yIGl0LlxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBsZXQgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBjb25zdCBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGxldCBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICBsZXQgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChub2RlT3BzLnBhcmVudE5vZGUocmVmJCQxKSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICBsZXQgaTtcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICB9XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBmYWxzZSwgdm5vZGVzLCBzdGFydElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgbGV0IGksIGo7XG4gICAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIGkodm5vZGUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSBjYnMuZGVzdHJveVtpXSh2bm9kZSk7XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjb25zdCBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICBsZXQgaTtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgbGV0IG9sZFN0YXJ0SWR4ID0gMDtcbiAgICBsZXQgbmV3U3RhcnRJZHggPSAwO1xuICAgIGxldCBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIGxldCBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgbGV0IG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICBsZXQgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIGxldCBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgbGV0IG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIGNvbnN0IGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIGNvbnN0IHNlZW5LZXlzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJyR7a2V5fScuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5gLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAoXG4gICAgb2xkVm5vZGUsXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXgsXG4gICAgcmVtb3ZlT25seVxuICApIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgaTtcbiAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgY29uc3QgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgeyB0YWcsIGRhdGEsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgIHZub2RlLmVsbSA9IGVsbTtcblxuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gYXNzZXJ0IG5vZGUgbWF0Y2hcbiAgICB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGxldCBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIGNvbnN0IGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIGNvbnN0IG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgY29uc3QgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgbGV0IGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIGNvbnN0IHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGluc2VydC5mbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaV0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICBjb25zdCBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIGNvbnN0IGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIGNvbnN0IG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgY29uc3QgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIGNvbnN0IGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIGNvbnN0IGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgbGV0IGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIGNvbnN0IGNhbGxJbnNlcnQgPSAoKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCAoKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgY29uc3QgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIGxldCBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8IGAke2Rpci5uYW1lfS4ke09iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKX1gXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgY29uc3QgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIGBkaXJlY3RpdmUgJHtkaXIubmFtZX0gJHtob29rfSBob29rYCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBjb25zdCBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IGtleSwgY3VyLCBvbGQ7XG4gIGNvbnN0IGVsbSA9IHZub2RlLmVsbTtcbiAgY29uc3Qgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICBsZXQgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoZWwudGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxuICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgID8gJ3RydWUnXG4gICAgICAgIDoga2V5O1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlU2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgLy8gaW1tZWRpYXRlbHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFxuICAgICAgaXNJRSAmJiAhaXNJRTkgJiZcbiAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiB2YWx1ZSAhPT0gJycgJiYgIWVsLl9faWVwaFxuICAgICkge1xuICAgICAgY29uc3QgYmxvY2tlciA9IGUgPT4ge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgfTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICBjb25zdCBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgY29uc3QgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG5jb25zdCB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICBsZXQgaW5TaW5nbGUgPSBmYWxzZTtcbiAgbGV0IGluRG91YmxlID0gZmFsc2U7XG4gIGxldCBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIGxldCBpblJlZ2V4ID0gZmFsc2U7XG4gIGxldCBjdXJseSA9IDA7XG4gIGxldCBzcXVhcmUgPSAwO1xuICBsZXQgcGFyZW4gPSAwO1xuICBsZXQgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgbGV0IGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIGluU2luZ2xlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIGluUmVnZXggPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIGxldCBqID0gaSAtIDE7XG4gICAgICAgIGxldCBwO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIGNvbnN0IGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiBgX2YoXCIke2ZpbHRlcn1cIikoJHtleHB9KWBcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIGNvbnN0IGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiBgX2YoXCIke25hbWV9XCIpKCR7ZXhwfSR7YXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3N9YFxuICB9XG59XG5cbi8qICAqL1xuXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2csIHJhbmdlKSB7XG4gIGNvbnNvbGUuZXJyb3IoYFtWdWUgY29tcGlsZXJdOiAke21zZ31gKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChtID0+IG1ba2V5XSkuZmlsdGVyKF8gPT4gXylcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lLCB2YWx1ZSwgZHluYW1pYyB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIGNvbnN0IGF0dHJzID0gZHluYW1pY1xuICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZSwgdmFsdWUsIGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG5mdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlKSB7XG4gIGVsLmF0dHJzTWFwW25hbWVdID0gdmFsdWU7XG4gIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWUsIHZhbHVlIH0sIHJhbmdlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBpc0R5bmFtaWNBcmcsXG4gIG1vZGlmaWVycyxcbiAgcmFuZ2Vcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oe1xuICAgIG5hbWUsXG4gICAgcmF3TmFtZSxcbiAgICB2YWx1ZSxcbiAgICBhcmcsXG4gICAgaXNEeW5hbWljQXJnLFxuICAgIG1vZGlmaWVyc1xuICB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXJNYXJrZXIgKHN5bWJvbCwgbmFtZSwgZHluYW1pYykge1xuICByZXR1cm4gZHluYW1pY1xuICAgID8gYF9wKCR7bmFtZX0sXCIke3N5bWJvbH1cIilgXG4gICAgOiBzeW1ib2wgKyBuYW1lIC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuLFxuICByYW5nZSxcbiAgZHluYW1pY1xuKSB7XG4gIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBgKCR7bmFtZX0pPT09J2NsaWNrJz8nY29udGV4dG1lbnUnOigke25hbWV9KWA7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ2NvbnRleHRtZW51JztcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgbmFtZSA9IGAoJHtuYW1lfSk9PT0nY2xpY2snPydtb3VzZXVwJzooJHtuYW1lfSlgO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdtb3VzZXVwJztcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCchJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyYnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuXG4gIGxldCBldmVudHM7XG4gIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cblxuICBjb25zdCBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYyB9LCByYW5nZSk7XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICBjb25zdCBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxuXG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWVcbikge1xuICByZXR1cm4gZWwucmF3QXR0cnNNYXBbJzonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFsndi1iaW5kOicgKyBuYW1lXSB8fFxuICAgIGVsLnJhd0F0dHJzTWFwW25hbWVdXG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIGNvbnN0IGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIGNvbnN0IHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgbGV0IHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleCAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgY29uc3QgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGF0dHIgPSBsaXN0W2ldO1xuICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gYXR0clxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICBpdGVtLFxuICByYW5nZVxuKSB7XG4gIGlmIChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IHsgbnVtYmVyLCB0cmltIH0gPSBtb2RpZmllcnMgfHwge307XG5cbiAgY29uc3QgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICBsZXQgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgYCh0eXBlb2YgJHtiYXNlVmFsdWVFeHByZXNzaW9ufSA9PT0gJ3N0cmluZydgICtcbiAgICAgIGA/ICR7YmFzZVZhbHVlRXhwcmVzc2lvbn0udHJpbSgpYCArXG4gICAgICBgOiAke2Jhc2VWYWx1ZUV4cHJlc3Npb259KWA7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IGBfbigke3ZhbHVlRXhwcmVzc2lvbn0pYDtcbiAgfVxuICBjb25zdCBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IGAoJHt2YWx1ZX0pYCxcbiAgICBleHByZXNzaW9uOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksXG4gICAgY2FsbGJhY2s6IGBmdW5jdGlvbiAoJHtiYXNlVmFsdWVFeHByZXNzaW9ufSkgeyR7YXNzaWdubWVudH19YFxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgY29uc3QgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlfT0ke2Fzc2lnbm1lbnR9YFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHNldCgke3Jlcy5leHB9LCAke3Jlcy5rZXl9LCAke2Fzc2lnbm1lbnR9KWBcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxubGV0IGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICB2YWwgPSB2YWwudHJpbSgpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIGxldCBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgaW5CcmFja2V0Kys7XG4gICAgaWYgKGNociA9PT0gMHg1RCkgaW5CcmFja2V0LS07XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIGNvbnN0IHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxubGV0IHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbmNvbnN0IFJBTkdFX1RPS0VOID0gJ19fcic7XG5jb25zdCBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIGNvbnN0IHZhbHVlID0gZGlyLnZhbHVlO1xuICBjb25zdCBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICBjb25zdCB0YWcgPSBlbC50YWc7XG4gIGNvbnN0IHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIHtcbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGA8JHtlbC50YWd9IHYtbW9kZWw9XCIke3ZhbHVlfVwiIHR5cGU9XCJmaWxlXCI+OlxcbmAgK1xuICAgICAgICBgRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICB3YXJuJDEoXG4gICAgICBgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIj46IGAgK1xuICAgICAgYHYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gYCArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIGNvbnN0IHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIGNvbnN0IHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIGNvbnN0IGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBgQXJyYXkuaXNBcnJheSgke3ZhbHVlfSlgICtcbiAgICBgP19pKCR7dmFsdWV9LCR7dmFsdWVCaW5kaW5nfSk+LTFgICsgKFxuICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgID8gYDooJHt2YWx1ZX0pYFxuICAgICAgICA6IGA6X3EoJHt2YWx1ZX0sJHt0cnVlVmFsdWVCaW5kaW5nfSlgXG4gICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICBgdmFyICQkYT0ke3ZhbHVlfSxgICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgYCQkYz0kJGVsLmNoZWNrZWQ/KCR7dHJ1ZVZhbHVlQmluZGluZ30pOigke2ZhbHNlVmFsdWVCaW5kaW5nfSk7YCArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBgdmFyICQkdj0ke251bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nfSxgICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgYGlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJigke2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKX0pfWAgK1xuICAgICAgYGVsc2V7JCRpPi0xJiYoJHtnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpJyl9KX1gICtcbiAgICBgfWVsc2V7JHtnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpfX1gLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIGxldCB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyBgX24oJHt2YWx1ZUJpbmRpbmd9KWAgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgYF9xKCR7dmFsdWV9LCR7dmFsdWVCaW5kaW5nfSlgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICBjb25zdCBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgK1xuICAgIGAuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KWAgK1xuICAgIGAubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcIl92YWx1ZVwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7YCArXG4gICAgYHJldHVybiAke251bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnfX0pYDtcblxuICBjb25zdCBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIGxldCBjb2RlID0gYHZhciAkJHNlbGVjdGVkVmFsID0gJHtzZWxlY3RlZFZhbH07YDtcbiAgY29kZSA9IGAke2NvZGV9ICR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpfWA7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICBjb25zdCB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAge1xuICAgIGNvbnN0IHZhbHVlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcbiAgICBjb25zdCB0eXBlQmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh2YWx1ZSAmJiAhdHlwZUJpbmRpbmcpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgd2FybiQxKFxuICAgICAgICBgJHtiaW5kaW5nfT1cIiR7dmFsdWV9XCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IGAgK1xuICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwW2JpbmRpbmddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHsgbGF6eSwgbnVtYmVyLCB0cmltIH0gPSBtb2RpZmllcnMgfHwge307XG4gIGNvbnN0IG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgY29uc3QgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIGxldCB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gYCRldmVudC50YXJnZXQudmFsdWUudHJpbSgpYDtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gYF9uKCR7dmFsdWVFeHByZXNzaW9ufSlgO1xuICB9XG5cbiAgbGV0IGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IGBpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47JHtjb2RlfWA7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCBgKCR7dmFsdWV9KWApO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBjb25zdCBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbmxldCB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgY29uc3QgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIGNvbnN0IHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuLy8gaW1wbGVtZW50YXRpb24gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzb1xuLy8gc2FmZSB0byBleGNsdWRlLlxuY29uc3QgdXNlTWljcm90YXNrRml4ID0gaXNVc2luZ01pY3JvVGFzayAmJiAhKGlzRkYgJiYgTnVtYmVyKGlzRkZbMV0pIDw9IDUzKTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgIGNvbnN0IGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgIGNvbnN0IG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gb3JpZ2luYWwuX3dyYXBwZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKFxuICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAvLyB0aGlzIGlzIGp1c3QgYSBzYWZldHkgbmV0IGluIGNhc2UgZXZlbnQudGltZVN0YW1wIGlzIHVucmVsaWFibGUgaW5cbiAgICAgICAgLy8gY2VydGFpbiB3ZWlyZCBlbnZpcm9ubWVudHMuLi5cbiAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAvLyBldmVudCBpcyBmaXJlZCBhZnRlciBoYW5kbGVyIGF0dGFjaG1lbnRcbiAgICAgICAgZS50aW1lU3RhbXAgPj0gYXR0YWNoZWRUaW1lc3RhbXAgfHxcbiAgICAgICAgLy8gIzk0NjIgYmFpbCBmb3IgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICBlLnRpbWVTdGFtcCA9PT0gMCB8fFxuICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmUsIHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgY29uc3Qgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmxldCBzdmdDb250YWluZXI7XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBrZXksIGN1cjtcbiAgY29uc3QgZWxtID0gdm5vZGUuZWxtO1xuICBjb25zdCBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIGxldCBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIGNvbnRpbnVlXG4gICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNraXAgdGhlIHVwZGF0ZSBpZiBvbGQgYW5kIG5ldyBWRE9NIHN0YXRlIGlzIHRoZSBzYW1lLlxuICAgIC8vIHRoZSBvbmx5IGV4Y2VwdGlvbiBpcyBgdmFsdWVgIHdoZXJlIHRoZSBET00gdmFsdWUgbWF5IGJlIHRlbXBvcmFyaWx5XG4gICAgLy8gb3V0IG9mIHN5bmMgd2l0aCBWRE9NIHN0YXRlIGR1ZSB0byBmb2N1cywgY29tcG9zaXRpb24gYW5kIG1vZGlmaWVycy5cbiAgICAvLyBUaGlzIGFsc28gY292ZXJzICM0NTIxIGJ5IHNraXBwaW5nIHRoZSB1bm5lY2VzYXJyeSBgY2hlY2tlZGAgdXBkYXRlLlxuICAgIGlmIChrZXkgIT09ICd2YWx1ZScgJiYgY3VyID09PSBvbGRQcm9wc1trZXldKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICBjb25zdCBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJIVE1MIGZvciBTVkcgZWxlbWVudHNcbiAgICAgIHN2Z0NvbnRhaW5lciA9IHN2Z0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBgPHN2Zz4ke2N1cn08L3N2Zz5gO1xuICAgICAgY29uc3Qgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICBsZXQgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICBjb25zdCB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgY29uc3QgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxuY29uc3QgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgY29uc3QgcmVzID0ge307XG4gIGNvbnN0IGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICBjb25zdCBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICBjb25zdCBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgY29uc3QgcmVzID0ge307XG4gIGxldCBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICBsZXQgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIGxldCBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuY29uc3QgY3NzVmFyUkUgPSAvXi0tLztcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5jb25zdCBzZXRQcm9wID0gKGVsLCBuYW1lLCB2YWwpID0+IHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbmxldCBlbXB0eVN0eWxlO1xuY29uc3Qgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgY29uc3QgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gIGNvbnN0IG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgY3VyLCBuYW1lO1xuICBjb25zdCBlbCA9IHZub2RlLmVsbTtcbiAgY29uc3Qgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICBjb25zdCBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIGNvbnN0IG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIGNvbnN0IHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIGNvbnN0IG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG5jb25zdCB3aGl0ZXNwYWNlUkUgPSAvXFxzKy87XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGMgPT4gZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY3VyID0gYCAke2VsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJ30gYDtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChjID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgY3VyID0gYCAke2VsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJ30gYDtcbiAgICBjb25zdCB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbmNvbnN0IGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKG5hbWUgPT4ge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IGAke25hbWV9LWVudGVyYCxcbiAgICBlbnRlclRvQ2xhc3M6IGAke25hbWV9LWVudGVyLXRvYCxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLFxuICAgIGxlYXZlQ2xhc3M6IGAke25hbWV9LWxlYXZlYCxcbiAgICBsZWF2ZVRvQ2xhc3M6IGAke25hbWV9LWxlYXZlLXRvYCxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgXG4gIH1cbn0pO1xuXG5jb25zdCBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbmNvbnN0IFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG5jb25zdCBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xubGV0IHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xubGV0IHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbmxldCBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG5sZXQgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbmNvbnN0IHJhZiA9IGluQnJvd3NlclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgOiBzZXRUaW1lb3V0XG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZm4gPT4gZm4oKTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoKCkgPT4ge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgaWYgKCF0eXBlKSByZXR1cm4gY2IoKVxuICBjb25zdCBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgbGV0IGVuZGVkID0gMDtcbiAgY29uc3QgZW5kID0gKCkgPT4ge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICBjb25zdCBvbkVuZCA9IGUgPT4ge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxuY29uc3QgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgbGV0IHR5cGU7XG4gIGxldCB0aW1lb3V0ID0gMDtcbiAgbGV0IHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICBjb25zdCBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHRpbWVvdXQsXG4gICAgcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKChkLCBpKSA9PiB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIGNvbnN0IGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICBjb25zdCBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCB7XG4gICAgY3NzLFxuICAgIHR5cGUsXG4gICAgZW50ZXJDbGFzcyxcbiAgICBlbnRlclRvQ2xhc3MsXG4gICAgZW50ZXJBY3RpdmVDbGFzcyxcbiAgICBhcHBlYXJDbGFzcyxcbiAgICBhcHBlYXJUb0NsYXNzLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzLFxuICAgIGJlZm9yZUVudGVyLFxuICAgIGVudGVyLFxuICAgIGFmdGVyRW50ZXIsXG4gICAgZW50ZXJDYW5jZWxsZWQsXG4gICAgYmVmb3JlQXBwZWFyLFxuICAgIGFwcGVhcixcbiAgICBhZnRlckFwcGVhcixcbiAgICBhcHBlYXJDYW5jZWxsZWQsXG4gICAgZHVyYXRpb25cbiAgfSA9IGRhdGE7XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIGxldCBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIGxldCB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgY29uc3QgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgY29uc3QgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIGNvbnN0IHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgY29uc3QgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgY29uc3QgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgY29uc3QgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICBjb25zdCBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIGNvbnN0IGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICBjb25zdCBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIGNvbnN0IHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgY29uc3QgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoKCkgPT4ge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICBjb25zdCBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICBjb25zdCBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCB7XG4gICAgY3NzLFxuICAgIHR5cGUsXG4gICAgbGVhdmVDbGFzcyxcbiAgICBsZWF2ZVRvQ2xhc3MsXG4gICAgbGVhdmVBY3RpdmVDbGFzcyxcbiAgICBiZWZvcmVMZWF2ZSxcbiAgICBsZWF2ZSxcbiAgICBhZnRlckxlYXZlLFxuICAgIGxlYXZlQ2FuY2VsbGVkLFxuICAgIGRlbGF5TGVhdmUsXG4gICAgZHVyYXRpb25cbiAgfSA9IGRhdGE7XG5cbiAgY29uc3QgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICBjb25zdCB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgY29uc3QgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgY29uc3QgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoKCkgPT4ge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgJHtuYW1lfSBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBgICtcbiAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBgPHRyYW5zaXRpb24+IGV4cGxpY2l0ICR7bmFtZX0gZHVyYXRpb24gaXMgTmFOIC0gYCArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGNvbnN0IGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmUgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbmNvbnN0IG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxuY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wcywgbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsICgpID0+IHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsICgpID0+IHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIGNvbnN0IHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgY29uc3QgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoKG8sIGkpID0+ICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgY29uc3QgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZSh2ID0+IGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucykpXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGNvbnN0IHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgYDxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cIiR7YmluZGluZy5leHByZXNzaW9ufVwiPiBgICtcbiAgICAgIGBleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke1xuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxuICAgICAgfWAsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAobGV0IGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KG8gPT4gIWxvb3NlRXF1YWwobywgdmFsdWUpKVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgcmV0dXJuXG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZCAoZWwsIHsgdmFsdWUgfSwgdm5vZGUpIHtcbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIGNvbnN0IHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBjb25zdCBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsICgpID0+IHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZSAoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSByZXR1cm5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIGNvbnN0IHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgKCkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsICgpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvd1xufTtcblxuLyogICovXG5cbmNvbnN0IHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgY29uc3QgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgY29uc3QgZGF0YSA9IHt9O1xuICBjb25zdCBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgY29uc3QgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSldID0gbGlzdGVuZXJzW2tleV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG5jb25zdCBpc05vdFRleHROb2RlID0gKGMpID0+IGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTtcblxuY29uc3QgaXNWU2hvd0RpcmVjdGl2ZSA9IGQgPT4gZC5uYW1lID09PSAnc2hvdyc7XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlciAoaCkge1xuICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgY29uc3QgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIGNvbnN0IGlkID0gYF9fdHJhbnNpdGlvbi0ke3RoaXMuX3VpZH0tYDtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICBjb25zdCBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgY29uc3Qgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICBjb25zdCBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgY29uc3Qgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVsYXllZExlYXZlO1xuICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgbGVhdmUgPT4geyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG5jb25zdCBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzLFxuXG4gIGJlZm9yZU1vdW50ICgpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XG4gICAgdGhpcy5fdXBkYXRlID0gKHZub2RlLCBoeWRyYXRpbmcpID0+IHtcbiAgICAgIGNvbnN0IHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgICB0aGlzLmtlcHQsXG4gICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgICApO1xuICAgICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgIHVwZGF0ZS5jYWxsKHRoaXMsIHZub2RlLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyIChoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIGNvbnN0IHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICBjb25zdCB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICBjb25zdCBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oYDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8JHtuYW1lfT5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGtlcHQgPSBbXTtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmV2Q2hpbGRyZW5baV07XG4gICAgICAgIGMuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMuZGF0YS5wb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgdXBkYXRlZCAoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICBjb25zdCBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICBjb25zdCBlbCA9IGMuZWxtO1xuICAgICAgICBjb25zdCBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goKGNscykgPT4geyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICBjb25zdCBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIGNvbnN0IG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIGNvbnN0IG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICBjb25zdCBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgYFlvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5gICtcbiAgICAgICAgYE1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5gICtcbiAgICAgICAgYFNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sYFxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxuY29uc3QgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxccj9cXG4pKz8pXFx9XFx9L2c7XG5jb25zdCByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxuY29uc3QgYnVpbGRSZWdleCA9IGNhY2hlZChkZWxpbWl0ZXJzID0+IHtcbiAgY29uc3Qgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIGNvbnN0IGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIGNvbnN0IHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCByYXdUb2tlbnMgPSBbXTtcbiAgbGV0IGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIGxldCBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIGNvbnN0IGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKGBfcygke2V4cH0pYCk7XG4gICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBjb25zdCB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICBjb25zdCBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBjb25zdCByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgYGNsYXNzPVwiJHtzdGF0aWNDbGFzc31cIjogYCArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICBjb25zdCBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICBsZXQgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IGBzdGF0aWNDbGFzczoke2VsLnN0YXRpY0NsYXNzfSxgO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IGBjbGFzczoke2VsLmNsYXNzQmluZGluZ30sYDtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICBjb25zdCB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICBjb25zdCBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICBjb25zdCByZXMgPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYHN0eWxlPVwiJHtzdGF0aWNTdHlsZX1cIjogYCArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LicsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3N0eWxlJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgY29uc3Qgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICBsZXQgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IGBzdGF0aWNTdHlsZToke2VsLnN0YXRpY1N0eWxlfSxgO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IGBzdHlsZTooJHtlbC5zdHlsZUJpbmRpbmd9KSxgO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG4vKiAgKi9cblxubGV0IGRlY29kZXI7XG5cbnZhciBoZSA9IHtcbiAgZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG5jb25zdCBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbmNvbnN0IGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuY29uc3QgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbmNvbnN0IGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xuY29uc3QgZHluYW1pY0FyZ0F0dHJpYnV0ZSA9IC9eXFxzKigoPzp2LVtcXHctXSs6fEB8OnwjKVxcW1tePV0rXFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbmNvbnN0IG5jbmFtZSA9IGBbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVoke3VuaWNvZGVMZXR0ZXJzfV0qYDtcbmNvbnN0IHFuYW1lQ2FwdHVyZSA9IGAoKD86JHtuY25hbWV9XFxcXDopPyR7bmNuYW1lfSlgO1xuY29uc3Qgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cChgXjwke3FuYW1lQ2FwdHVyZX1gKTtcbmNvbnN0IHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbmNvbnN0IGVuZFRhZyA9IG5ldyBSZWdFeHAoYF48XFxcXC8ke3FuYW1lQ2FwdHVyZX1bXj5dKj5gKTtcbmNvbnN0IGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNlZCBhcyBIVE1MIGNvbW1lbnQgd2hlbiBpbmxpbmVkIGluIHBhZ2VcbmNvbnN0IGNvbW1lbnQgPSAvXjwhXFwtLS87XG5jb25zdCBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG5jb25zdCBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbmNvbnN0IHJlQ2FjaGUgPSB7fTtcblxuY29uc3QgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCcsXG4gICcmIzM5Oyc6IFwiJ1wiXG59O1xuY29uc3QgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOSk7L2c7XG5jb25zdCBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5fCMxMHwjOSk7L2c7XG5cbi8vICM1OTkyXG5jb25zdCBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbmNvbnN0IHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9ICh0YWcsIGh0bWwpID0+IHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJztcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIGNvbnN0IHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgbWF0Y2ggPT4gZGVjb2RpbmdNYXBbbWF0Y2hdKVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgY29uc3QgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgY29uc3QgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgY29uc3QgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgbGV0IHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICBjb25zdCBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICBjb25zdCBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIGNvbnN0IGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICBjb25zdCBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgY29uc3QgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgY29uc3Qgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YXJ0VGFnTWF0Y2gudGFnTmFtZSwgaHRtbCkpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHRleHQsIHJlc3QsIG5leHQ7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIGJyZWFrXG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICBjb25zdCBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICBjb25zdCByZXN0ID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0Lmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0O1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKCFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybihgTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcIiR7aHRtbH1cImAsIHsgc3RhcnQ6IGluZGV4ICsgaHRtbC5sZW5ndGggfSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIGxldCBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhdHRyLnN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgY29uc3QgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgY29uc3QgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgY29uc3QgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICBjb25zdCBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIGNvbnN0IHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBhcmdzLnN0YXJ0ICsgYXJnc1swXS5tYXRjaCgvXlxccyovKS5sZW5ndGg7XG4gICAgICAgIGF0dHJzW2ldLmVuZCA9IGFyZ3MuZW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzLCBzdGFydDogbWF0Y2guc3RhcnQsIGVuZDogbWF0Y2guZW5kIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIGxldCBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSBzdGFydCA9IGluZGV4O1xuICAgIGlmIChlbmQgPT0gbnVsbCkgZW5kID0gaW5kZXg7XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAoaSA+IHBvcyB8fCAhdGFnTmFtZSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICBgdGFnIDwke3N0YWNrW2ldLnRhZ30+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLmAsXG4gICAgICAgICAgICB7IHN0YXJ0OiBzdGFja1tpXS5zdGFydCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBvblJFID0gL15AfF52LW9uOi87XG5jb25zdCBkaXJSRSA9IC9edi18XkB8XjovO1xuY29uc3QgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbmNvbnN0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG5jb25zdCBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuY29uc3QgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG5jb25zdCBhcmdSRSA9IC86KC4qKSQvO1xuY29uc3QgYmluZFJFID0gL146fF5cXC58XnYtYmluZDovO1xuY29uc3QgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG5jb25zdCBzbG90UkUgPSAvXnYtc2xvdCg6fCQpfF4jLztcblxuY29uc3QgbGluZUJyZWFrUkUgPSAvW1xcclxcbl0vO1xuY29uc3Qgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy9nO1xuXG5jb25zdCBpbnZhbGlkQXR0cmlidXRlUkUgPSAvW1xcc1wiJzw+XFwvPV0vO1xuXG5jb25zdCBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbmNvbnN0IGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBgX2VtcHR5X2A7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxubGV0IHdhcm4kMjtcbmxldCBkZWxpbWl0ZXJzO1xubGV0IHRyYW5zZm9ybXM7XG5sZXQgcHJlVHJhbnNmb3JtcztcbmxldCBwb3N0VHJhbnNmb3JtcztcbmxldCBwbGF0Zm9ybUlzUHJlVGFnO1xubGV0IHBsYXRmb3JtTXVzdFVzZVByb3A7XG5sZXQgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5sZXQgbWF5YmVDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICB0YWcsXG4gIGF0dHJzLFxuICBwYXJlbnRcbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDEsXG4gICAgdGFnLFxuICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgcmF3QXR0cnNNYXA6IHt9LFxuICAgIHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgY29uc3QgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgbWF5YmVDb21wb25lbnQgPSAoZWwpID0+ICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7XG5cbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgY29uc3QgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICBjb25zdCB3aGl0ZXNwYWNlT3B0aW9uID0gb3B0aW9ucy53aGl0ZXNwYWNlO1xuICBsZXQgcm9vdDtcbiAgbGV0IGN1cnJlbnRQYXJlbnQ7XG4gIGxldCBpblZQcmUgPSBmYWxzZTtcbiAgbGV0IGluUHJlID0gZmFsc2U7XG4gIGxldCB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnLCByYW5nZSkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZywgcmFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlRWxlbWVudCAoZWxlbWVudCkge1xuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuICAgIGlmICghaW5WUHJlICYmICFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgZWxlbWVudCA9IHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBlbGVtZW50ICE9PSByb290KSB7XG4gICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIGBDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBgICtcbiAgICAgICAgICBgSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBgICtcbiAgICAgICAgICBgdXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuYCxcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cbiAgICAgICAgICBjb25zdCBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIidcbiAgICAgICAgICA7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaW5hbCBjaGlsZHJlbiBjbGVhbnVwXG4gICAgLy8gZmlsdGVyIG91dCBzY29wZWQgc2xvdHNcbiAgICBlbGVtZW50LmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbi5maWx0ZXIoYyA9PiAhKGMpLnNsb3RTY29wZSk7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgaWYgKCFpblByZSkge1xuICAgICAgbGV0IGxhc3ROb2RlO1xuICAgICAgd2hpbGUgKFxuICAgICAgICAobGFzdE5vZGUgPSBlbC5jaGlsZHJlbltlbC5jaGlsZHJlbi5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICkge1xuICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgYENhbm5vdCB1c2UgPCR7ZWwudGFnfT4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBgICtcbiAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJyxcbiAgICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICBvdXRwdXRTb3VyY2VSYW5nZTogb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSxcbiAgICBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIGNvbnN0IG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgZWxlbWVudC5yYXdBdHRyc01hcCA9IGVsZW1lbnQuYXR0cnNMaXN0LnJlZHVjZSgoY3VtdWxhdGVkLCBhdHRyKSA9PiB7XG4gICAgICAgICAgICBjdW11bGF0ZWRbYXR0ci5uYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICByZXR1cm4gY3VtdWxhdGVkXG4gICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgaWYgKGludmFsaWRBdHRyaWJ1dGVSRS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgYEludmFsaWQgZHluYW1pYyBhcmd1bWVudCBleHByZXNzaW9uOiBhdHRyaWJ1dGUgbmFtZXMgY2Fubm90IGNvbnRhaW4gYCArXG4gICAgICAgICAgICAgIGBzcGFjZXMsIHF1b3RlcywgPCwgPiwgLyBvciA9LmAsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5pbmRleE9mKGBbYCksXG4gICAgICAgICAgICAgICAgZW5kOiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmxlbmd0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgYDwke3RhZ30+YCArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZCAodGFnLCBzdGFydCwgZW5kKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQ7XG4gICAgICB9XG4gICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nLFxuICAgICAgICAgICAgICB7IHN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIGB0ZXh0IFwiJHt0ZXh0fVwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5gLFxuICAgICAgICAgICAgICB7IHN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIGlmIChpblByZSB8fCB0ZXh0LnRyaW0oKSkge1xuICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlLW9ubHkgbm9kZSByaWdodCBhZnRlciBhbiBvcGVuaW5nIHRhZ1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBjb25kZW5zZSBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlcyBpbnRvIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2Uod2hpdGVzcGFjZVJFJDEsICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgbGV0IGNoaWxkO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiByZXMuZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRva2VuczogcmVzLnRva2VucyxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgLy8gYWRkaW5nIGFueXRpbmcgYXMgYSBzaWJsaW5nIHRvIHRoZSByb290IG5vZGUgaXMgZm9yYmlkZGVuXG4gICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcbiAgICAgIGlmIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0ge1xuICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGNvbnN0IGxlbiA9IGxpc3QubGVuZ3RoO1xuICBpZiAobGVuKSB7XG4gICAgY29uc3QgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShsaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0W2ldLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBsaXN0W2ldLnN0YXJ0O1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKFxuICBlbGVtZW50LFxuICBvcHRpb25zXG4pIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAhZWxlbWVudC5rZXkgJiZcbiAgICAhZWxlbWVudC5zY29wZWRTbG90cyAmJlxuICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgKTtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgY29uc3QgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIGA8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuYCxcbiAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZWwuZm9yKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gZWwuaXRlcmF0b3IyIHx8IGVsLml0ZXJhdG9yMTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICBpZiAoaXRlcmF0b3IgJiYgaXRlcmF0b3IgPT09IGV4cCAmJiBwYXJlbnQgJiYgcGFyZW50LnRhZyA9PT0gJ3RyYW5zaXRpb24tZ3JvdXAnKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgYERvIG5vdCB1c2Ugdi1mb3IgaW5kZXggYXMga2V5IG9uIDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiwgYCArXG4gICAgICAgICAgICBgdGhpcyBpcyB0aGUgc2FtZSBhcyBub3QgdXNpbmcga2V5cy5gLFxuICAgICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKSxcbiAgICAgICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgY29uc3QgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIGxldCBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgY29uc3QgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYEludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogJHtleHB9YCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cblxuXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XG4gIGNvbnN0IGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgcmV0dXJuXG4gIGNvbnN0IHJlcyA9IHt9O1xuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIGNvbnN0IGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIGNvbnN0IGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XG4gICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICBjb25zdCBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICBjb25zdCBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHdhcm4kMihcbiAgICAgIGB2LSR7ZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnfSBgICtcbiAgICAgIGB1c2VkIG9uIGVsZW1lbnQgPCR7ZWwudGFnfT4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuYCxcbiAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBgdGV4dCBcIiR7Y2hpbGRyZW5baV0udGV4dC50cmltKCl9XCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBgICtcbiAgICAgICAgICBgd2lsbCBiZSBpZ25vcmVkLmAsXG4gICAgICAgICAgY2hpbGRyZW5baV1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICBjb25zdCBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXG4vLyBlLmcuIDx0ZW1wbGF0ZSBzbG90PVwieHh4XCI+LCA8ZGl2IHNsb3Qtc2NvcGU9XCJ4eHhcIj5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgbGV0IHNsb3RTY29wZTtcbiAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChzbG90U2NvcGUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYHRoZSBcInNjb3BlXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIGAgK1xuICAgICAgICBgcmVwbGFjZWQgYnkgXCJzbG90LXNjb3BlXCIgc2luY2UgMi41LiBUaGUgbmV3IFwic2xvdC1zY29wZVwiIGF0dHJpYnV0ZSBgICtcbiAgICAgICAgYGNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBgICtcbiAgICAgICAgYGRlbm90ZSBzY29wZWQgc2xvdHMuYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICB9IGVsc2UgaWYgKChzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpKSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBgQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDwke2VsLnRhZ30+IGAgK1xuICAgICAgICBgKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIGAgK1xuICAgICAgICBgc2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLmAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgfVxuXG4gIC8vIHNsb3Q9XCJ4eHhcIlxuICBjb25zdCBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0LCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gMi42IHYtc2xvdCBzeW50YXhcbiAge1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIC8vIHYtc2xvdCBvbiA8dGVtcGxhdGU+XG4gICAgICBjb25zdCBzbG90QmluZGluZyA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgaWYgKHNsb3RCaW5kaW5nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgYFVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuYCxcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5wYXJlbnQgJiYgIW1heWJlQ29tcG9uZW50KGVsLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgYDx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgYCArXG4gICAgICAgICAgICAgIGB0aGUgcmVjZWl2aW5nIHRoZSBjb21wb25lbnRgLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuYW1lLCBkeW5hbWljIH0gPSBnZXRTbG90TmFtZShzbG90QmluZGluZyk7XG4gICAgICAgIGVsLnNsb3RUYXJnZXQgPSBuYW1lO1xuICAgICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgY29uc3Qgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFtYXliZUNvbXBvbmVudChlbCkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgYHYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5gLFxuICAgICAgICAgICAgICBzbG90QmluZGluZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLmAsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgYFRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgYCArXG4gICAgICAgICAgICAgIGA8dGVtcGxhdGU+IHN5bnRheCB3aGVuIHRoZXJlIGFyZSBvdGhlciBuYW1lZCBzbG90cy5gLFxuICAgICAgICAgICAgICBzbG90QmluZGluZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRoZSBjb21wb25lbnQncyBjaGlsZHJlbiB0byBpdHMgZGVmYXVsdCBzbG90XG4gICAgICAgIGNvbnN0IHNsb3RzID0gZWwuc2NvcGVkU2xvdHMgfHwgKGVsLnNjb3BlZFNsb3RzID0ge30pO1xuICAgICAgICBjb25zdCB7IG5hbWUsIGR5bmFtaWMgfSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgY29uc3Qgc2xvdENvbnRhaW5lciA9IHNsb3RzW25hbWVdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXQgPSBuYW1lO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcbiAgICAgICAgc2xvdENvbnRhaW5lci5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmZpbHRlcigoYykgPT4ge1xuICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIGMucGFyZW50ID0gc2xvdENvbnRhaW5lcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuO1xuICAgICAgICAvLyByZW1vdmUgY2hpbGRyZW4gYXMgdGhleSBhcmUgcmV0dXJuZWQgZnJvbSBzY29wZWRTbG90cyBub3dcbiAgICAgICAgZWwuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLy8gbWFyayBlbCBub24tcGxhaW4gc28gZGF0YSBnZXRzIGdlbmVyYXRlZFxuICAgICAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTbG90TmFtZSAoYmluZGluZykge1xuICBsZXQgbmFtZSA9IGJpbmRpbmcubmFtZS5yZXBsYWNlKHNsb3RSRSwgJycpO1xuICBpZiAoIW5hbWUpIHtcbiAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcbiAgICAgIG5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYHYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLmAsXG4gICAgICAgIGJpbmRpbmdcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkeW5hbWljQXJnUkUudGVzdChuYW1lKVxuICAgIC8vIGR5bmFtaWMgW25hbWVdXG4gICAgPyB7IG5hbWU6IG5hbWUuc2xpY2UoMSwgLTEpLCBkeW5hbWljOiB0cnVlIH1cbiAgICAvLyBzdGF0aWMgbmFtZVxuICAgIDogeyBuYW1lOiBgXCIke25hbWV9XCJgLCBkeW5hbWljOiBmYWxzZSB9XG59XG5cbi8vIGhhbmRsZSA8c2xvdC8+IG91dGxldHNcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYFxcYGtleVxcYCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIGAgK1xuICAgICAgICBgYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gYCArXG4gICAgICAgIGBVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5gLFxuICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICBsZXQgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgY29uc3QgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgbGV0IGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XG4gICAgICAvLyBzdXBwb3J0IC5mb28gc2hvcnRoYW5kIHN5bnRheCBmb3IgdGhlIC5wcm9wIG1vZGlmaWVyXG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIGBUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcInYtYmluZDoke25hbWV9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgbmFtZSA9ICdpbm5lckhUTUwnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBzeW5jR2VuID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGAkZXZlbnRgKTtcbiAgICAgICAgICAgIGlmICghaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgYHVwZGF0ZToke2NhbWVsaXplKG5hbWUpfWAsXG4gICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChoeXBoZW5hdGUobmFtZSkgIT09IGNhbWVsaXplKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgYHVwZGF0ZToke2h5cGhlbmF0ZShuYW1lKX1gLFxuICAgICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBoYW5kbGVyIHcvIGR5bmFtaWMgZXZlbnQgbmFtZVxuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGBcInVwZGF0ZTpcIisoJHtuYW1lfSlgLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXSxcbiAgICAgICAgICAgICAgICB0cnVlIC8vIGR5bmFtaWNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByb3ApIHx8IChcbiAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxuICAgICAgICApKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICBjb25zdCBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICBsZXQgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWMsIG1vZGlmaWVycywgbGlzdFtpXSk7XG4gICAgICAgIGlmIChuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIHtcbiAgICAgICAgY29uc3QgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIGAke25hbWV9PVwiJHt2YWx1ZX1cIjogYCArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LicsXG4gICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBsaXN0W2ldKTtcbiAgICAgIC8vICM2ODg3IGZpcmVmb3ggZG9lc24ndCB1cGRhdGUgbXV0ZWQgc3RhdGUgaWYgc2V0IHZpYSBhdHRyaWJ1dGVcbiAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiZcbiAgICAgICAgICBuYW1lID09PSAnbXV0ZWQnICYmXG4gICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgIGFkZFByb3AoZWwsIG5hbWUsICd0cnVlJywgbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIGxldCBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIGNvbnN0IG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChtID0+IHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgY29uc3QgbWFwID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxuY29uc3QgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbmNvbnN0IGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgbGV0IF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIj46IGAgK1xuICAgICAgICBgWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIGAgK1xuICAgICAgICBgVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgYCArXG4gICAgICAgIGB3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBgICtcbiAgICAgICAgYENvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLmAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICBjb25zdCBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICBpZiAoIW1hcFsndi1tb2RlbCddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgdHlwZUJpbmRpbmc7XG4gICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgfVxuICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gYCgke21hcFsndi1iaW5kJ119KS50eXBlYDtcbiAgICB9XG5cbiAgICBpZiAodHlwZUJpbmRpbmcpIHtcbiAgICAgIGNvbnN0IGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgIGNvbnN0IGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IGAmJigke2lmQ29uZGl0aW9ufSlgIDogYGA7XG4gICAgICBjb25zdCBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XG4gICAgICBjb25zdCBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgY29uc3QgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXG4gICAgICBwcm9jZXNzRm9yKGJyYW5jaDApO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XG4gICAgICBicmFuY2gwLnByb2Nlc3NlZCA9IHRydWU7IC8vIHByZXZlbnQgaXQgZnJvbSBkb3VibGUtcHJvY2Vzc2VkXG4gICAgICBicmFuY2gwLmlmID0gYCgke3R5cGVCaW5kaW5nfSk9PT0nY2hlY2tib3gnYCArIGlmQ29uZGl0aW9uRXh0cmE7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogYnJhbmNoMC5pZixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgIH0pO1xuICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXG4gICAgICBjb25zdCBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBgKCR7dHlwZUJpbmRpbmd9KT09PSdyYWRpbydgICsgaWZDb25kaXRpb25FeHRyYSxcbiAgICAgICAgYmxvY2s6IGJyYW5jaDFcbiAgICAgIH0pO1xuICAgICAgLy8gMy4gb3RoZXJcbiAgICAgIGNvbnN0IGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCBgX3MoJHtkaXIudmFsdWV9KWAsIGRpcik7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCBgX3MoJHtkaXIudmFsdWV9KWAsIGRpcik7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWwsXG4gIHRleHQsXG4gIGh0bWxcbn07XG5cbi8qICAqL1xuXG5jb25zdCBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbi8qICAqL1xuXG5sZXQgaXNTdGF0aWNLZXk7XG5sZXQgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG5jb25zdCBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgcmV0dXJuXG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yIChsZXQgaSA9IDEsIGwgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yIChsZXQgaSA9IDEsIGwgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2ldLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbmNvbnN0IGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xuY29uc3QgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xuY29uc3Qgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbmNvbnN0IGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXkgYWxpYXNlc1xuY29uc3Qga2V5TmFtZXMgPSB7XG4gIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICBlc2M6IFsnRXNjJywgJ0VzY2FwZSddLFxuICB0YWI6ICdUYWInLFxuICBlbnRlcjogJ0VudGVyJyxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgU3BhY2ViYXJgIGZvciBTcGFjZSBrZXkgbmFtZS5cbiAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbmNvbnN0IGdlbkd1YXJkID0gY29uZGl0aW9uID0+IGBpZigke2NvbmRpdGlvbn0pcmV0dXJuIG51bGw7YDtcblxuY29uc3QgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChgJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRgKSxcbiAgY3RybDogZ2VuR3VhcmQoYCEkZXZlbnQuY3RybEtleWApLFxuICBzaGlmdDogZ2VuR3VhcmQoYCEkZXZlbnQuc2hpZnRLZXlgKSxcbiAgYWx0OiBnZW5HdWFyZChgISRldmVudC5hbHRLZXlgKSxcbiAgbWV0YTogZ2VuR3VhcmQoYCEkZXZlbnQubWV0YUtleWApLFxuICBsZWZ0OiBnZW5HdWFyZChgJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBgKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChgJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFgKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKGAnYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMmApXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmVcbikge1xuICBjb25zdCBwcmVmaXggPSBpc05hdGl2ZSA/ICduYXRpdmVPbjonIDogJ29uOic7XG4gIGxldCBzdGF0aWNIYW5kbGVycyA9IGBgO1xuICBsZXQgZHluYW1pY0hhbmRsZXJzID0gYGA7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBldmVudHMpIHtcbiAgICBjb25zdCBoYW5kbGVyQ29kZSA9IGdlbkhhbmRsZXIoZXZlbnRzW25hbWVdKTtcbiAgICBpZiAoZXZlbnRzW25hbWVdICYmIGV2ZW50c1tuYW1lXS5keW5hbWljKSB7XG4gICAgICBkeW5hbWljSGFuZGxlcnMgKz0gYCR7bmFtZX0sJHtoYW5kbGVyQ29kZX0sYDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGljSGFuZGxlcnMgKz0gYFwiJHtuYW1lfVwiOiR7aGFuZGxlckNvZGV9LGA7XG4gICAgfVxuICB9XG4gIHN0YXRpY0hhbmRsZXJzID0gYHske3N0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKX19YDtcbiAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgIHJldHVybiBwcmVmaXggKyBgX2QoJHtzdGF0aWNIYW5kbGVyc30sWyR7ZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKX1dKWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gYFske2hhbmRsZXIubWFwKGhhbmRsZXIgPT4gZ2VuSGFuZGxlcihoYW5kbGVyKSkuam9pbignLCcpfV1gXG4gIH1cblxuICBjb25zdCBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgY29uc3QgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIGNvbnN0IGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIHJldHVybiBgZnVuY3Rpb24oJGV2ZW50KXske1xuICAgICAgaXNGdW5jdGlvbkludm9jYXRpb24gPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX1gIDogaGFuZGxlci52YWx1ZVxuICAgIH19YCAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgbGV0IGNvZGUgPSAnJztcbiAgICBsZXQgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXVxuICAgICAgICAgICAgLmZpbHRlcihrZXlNb2RpZmllciA9PiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXSlcbiAgICAgICAgICAgIC5tYXAoa2V5TW9kaWZpZXIgPT4gYCRldmVudC4ke2tleU1vZGlmaWVyfUtleWApXG4gICAgICAgICAgICAuam9pbignfHwnKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IGByZXR1cm4gJHtoYW5kbGVyLnZhbHVlfSgkZXZlbnQpYFxuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IGByZXR1cm4gKCR7aGFuZGxlci52YWx1ZX0pKCRldmVudClgXG4gICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cbiAgICAgICAgICA/IGByZXR1cm4gJHtoYW5kbGVyLnZhbHVlfWBcbiAgICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIGBmdW5jdGlvbigkZXZlbnQpeyR7Y29kZX0ke2hhbmRsZXJDb2RlfX1gXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBrZXkgZmlsdGVycyBvbmx5IGFwcGx5IHRvIEtleWJvYXJkRXZlbnRzXG4gICAgLy8gIzk0NDE6IGNhbid0IHVzZSAna2V5Q29kZScgaW4gJGV2ZW50IGJlY2F1c2UgQ2hyb21lIGF1dG9maWxsIGZpcmVzIGZha2VcbiAgICAvLyBrZXkgZXZlbnRzIHRoYXQgZG8gbm90IGhhdmUga2V5Q29kZSBwcm9wZXJ0eS4uLlxuICAgIGBpZighJGV2ZW50LnR5cGUuaW5kZXhPZigna2V5JykmJmAgK1xuICAgIGAke2tleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJyl9KXJldHVybiBudWxsO2BcbiAgKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgY29uc3Qga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gYCRldmVudC5rZXlDb2RlIT09JHtrZXlWYWx9YFxuICB9XG4gIGNvbnN0IGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICBjb25zdCBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgcmV0dXJuIChcbiAgICBgX2soJGV2ZW50LmtleUNvZGUsYCArXG4gICAgYCR7SlNPTi5zdHJpbmdpZnkoa2V5KX0sYCArXG4gICAgYCR7SlNPTi5zdHJpbmdpZnkoa2V5Q29kZSl9LGAgK1xuICAgIGAkZXZlbnQua2V5LGAgK1xuICAgIGAke0pTT04uc3RyaW5naWZ5KGtleU5hbWUpfWAgK1xuICAgIGApYFxuICApXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICBpZiAoZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oYHYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5gKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gKGNvZGUpID0+IGBfZygke2NvZGV9LCR7ZGlyLnZhbHVlfSlgO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gKGNvZGUpID0+IHtcbiAgICByZXR1cm4gYF9iKCR7Y29kZX0sJyR7ZWwudGFnfScsJHtkaXIudmFsdWV9LCR7XG4gICAgICBkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZSdcbiAgICB9JHtcbiAgICAgIGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnXG4gICAgfSlgXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuXG5cblxuXG5jbGFzcyBDb2RlZ2VuU3RhdGUge1xuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gICAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gICAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gICAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICAgIGNvbnN0IGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gICAgdGhpcy5tYXliZUNvbXBvbmVudCA9IChlbCkgPT4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTtcbiAgICB0aGlzLm9uY2VJZCA9IDA7XG4gICAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgICB0aGlzLnByZSA9IGZhbHNlO1xuICB9XG59XG5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIGNvbnN0IHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgY29uc3QgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogYHdpdGgodGhpcyl7cmV0dXJuICR7Y29kZX19YCxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICBpZiAoZWwucGFyZW50KSB7XG4gICAgZWwucHJlID0gZWwucHJlIHx8IGVsLnBhcmVudC5wcmU7XG4gIH1cblxuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0ICYmICFzdGF0ZS5wcmUpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgbGV0IGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkYXRhO1xuICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSkpIHtcbiAgICAgICAgZGF0YSA9IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gYF9jKCcke2VsLnRhZ30nJHtcbiAgICAgICAgZGF0YSA/IGAsJHtkYXRhfWAgOiAnJyAvLyBkYXRhXG4gICAgICB9JHtcbiAgICAgICAgY2hpbGRyZW4gPyBgLCR7Y2hpbGRyZW59YCA6ICcnIC8vIGNoaWxkcmVuXG4gICAgICB9KWA7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cbiAgY29uc3Qgb3JpZ2luYWxQcmVTdGF0ZSA9IHN0YXRlLnByZTtcbiAgaWYgKGVsLnByZSkge1xuICAgIHN0YXRlLnByZSA9IGVsLnByZTtcbiAgfVxuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaChgd2l0aCh0aGlzKXtyZXR1cm4gJHtnZW5FbGVtZW50KGVsLCBzdGF0ZSl9fWApO1xuICBzdGF0ZS5wcmUgPSBvcmlnaW5hbFByZVN0YXRlO1xuICByZXR1cm4gYF9tKCR7XG4gICAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDFcbiAgfSR7XG4gICAgZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJydcbiAgfSlgXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIGxldCBrZXkgPSAnJztcbiAgICBsZXQgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgc3RhdGUud2FybihcbiAgICAgICAgYHYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBgLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1vbmNlJ11cbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfVxuICAgIHJldHVybiBgX28oJHtnZW5FbGVtZW50KGVsLCBzdGF0ZSl9LCR7c3RhdGUub25jZUlkKyt9LCR7a2V5fSlgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgY29uc3QgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiBgKCR7Y29uZGl0aW9uLmV4cH0pPyR7XG4gICAgICBnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaylcbiAgICB9OiR7XG4gICAgICBnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG4gICAgfWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7Z2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spfWBcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgY29uc3QgZXhwID0gZWwuZm9yO1xuICBjb25zdCBhbGlhcyA9IGVsLmFsaWFzO1xuICBjb25zdCBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyBgLCR7ZWwuaXRlcmF0b3IxfWAgOiAnJztcbiAgY29uc3QgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gYCwke2VsLml0ZXJhdG9yMn1gIDogJyc7XG5cbiAgaWYgKHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgYDwke2VsLnRhZ30gdi1mb3I9XCIke2FsaWFzfSBpbiAke2V4cH1cIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIGAgK1xuICAgICAgYHYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIGAgK1xuICAgICAgYFNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uYCxcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBgJHthbHRIZWxwZXIgfHwgJ19sJ30oKCR7ZXhwfSksYCArXG4gICAgYGZ1bmN0aW9uKCR7YWxpYXN9JHtpdGVyYXRvcjF9JHtpdGVyYXRvcjJ9KXtgICtcbiAgICAgIGByZXR1cm4gJHsoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSl9YCArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsLCBzdGF0ZSkge1xuICBsZXQgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICBjb25zdCBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgZGF0YSArPSBkaXJzICsgJywnO1xuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBga2V5OiR7ZWwua2V5fSxgO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBgcmVmOiR7ZWwucmVmfSxgO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gYHJlZkluRm9yOnRydWUsYDtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gYHByZTp0cnVlLGA7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gYHRhZzpcIiR7ZWwudGFnfVwiLGA7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gYGF0dHJzOiR7Z2VuUHJvcHMoZWwuYXR0cnMpfSxgO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IGBkb21Qcm9wczoke2dlblByb3BzKGVsLnByb3BzKX0sYDtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSBgJHtnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlKX0sYDtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSBgJHtnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpfSxgO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gYHNsb3Q6JHtlbC5zbG90VGFyZ2V0fSxgO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IGAke2dlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpfSxgO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gYG1vZGVsOnt2YWx1ZToke1xuICAgICAgZWwubW9kZWwudmFsdWVcbiAgICB9LGNhbGxiYWNrOiR7XG4gICAgICBlbC5tb2RlbC5jYWxsYmFja1xuICAgIH0sZXhwcmVzc2lvbjoke1xuICAgICAgZWwubW9kZWwuZXhwcmVzc2lvblxuICAgIH19LGA7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIGNvbnN0IGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gYCR7aW5saW5lVGVtcGxhdGV9LGA7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXG4gIC8vIHYtYmluZCB3aXRoIGR5bmFtaWMgYXJndW1lbnRzIG11c3QgYmUgYXBwbGllZCB1c2luZyB0aGUgc2FtZSB2LWJpbmQgb2JqZWN0XG4gIC8vIG1lcmdlIGhlbHBlciBzbyB0aGF0IGNsYXNzL3N0eWxlL211c3RVc2VQcm9wIGF0dHJzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbiAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xuICAgIGRhdGEgPSBgX2IoJHtkYXRhfSxcIiR7ZWwudGFnfVwiLCR7Z2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKX0pYDtcbiAgfVxuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICBjb25zdCBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSByZXR1cm5cbiAgbGV0IHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICBsZXQgaGFzUnVudGltZSA9IGZhbHNlO1xuICBsZXQgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgY29uc3QgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gYHtuYW1lOlwiJHtkaXIubmFtZX1cIixyYXdOYW1lOlwiJHtkaXIucmF3TmFtZX1cIiR7XG4gICAgICAgIGRpci52YWx1ZSA/IGAsdmFsdWU6KCR7ZGlyLnZhbHVlfSksZXhwcmVzc2lvbjoke0pTT04uc3RyaW5naWZ5KGRpci52YWx1ZSl9YCA6ICcnXG4gICAgICB9JHtcbiAgICAgICAgZGlyLmFyZyA/IGAsYXJnOiR7ZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiBgXCIke2Rpci5hcmd9XCJgfWAgOiAnJ1xuICAgICAgfSR7XG4gICAgICAgIGRpci5tb2RpZmllcnMgPyBgLG1vZGlmaWVyczoke0pTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpfWAgOiAnJ1xuICAgICAgfX0sYDtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgY29uc3QgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDEpIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicsXG4gICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgKTtcbiAgfVxuICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XG4gICAgY29uc3QgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICByZXR1cm4gYGlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXske1xuICAgICAgaW5saW5lUmVuZGVyRm5zLnJlbmRlclxuICAgIH19LHN0YXRpY1JlbmRlckZuczpbJHtcbiAgICAgIGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGNvZGUgPT4gYGZ1bmN0aW9uKCl7JHtjb2RlfX1gKS5qb2luKCcsJylcbiAgICB9XX1gXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBlbCxcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gIC8vIGJ1dCBpbiBzb21lIGNhc2VzIHdlIGhhdmUgdG8gYmFpbC1vdXQgb2YgdGhpcyBvcHRpbWl6YXRpb25cbiAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICBsZXQgbmVlZHNGb3JjZVVwZGF0ZSA9IE9iamVjdC5rZXlzKHNsb3RzKS5zb21lKGtleSA9PiB7XG4gICAgY29uc3Qgc2xvdCA9IHNsb3RzW2tleV07XG4gICAgcmV0dXJuIChcbiAgICAgIHNsb3Quc2xvdFRhcmdldER5bmFtaWMgfHxcbiAgICAgIHNsb3QuaWYgfHxcbiAgICAgIHNsb3QuZm9yIHx8XG4gICAgICBjb250YWluc1Nsb3RDaGlsZChzbG90KSAvLyBpcyBwYXNzaW5nIGRvd24gc2xvdCBmcm9tIHBhcmVudCB3aGljaCBtYXkgYmUgZHluYW1pY1xuICAgIClcbiAgfSk7XG4gIC8vIE9SIHdoZW4gaXQgaXMgaW5zaWRlIGFub3RoZXIgc2NvcGVkIHNsb3QgKHRoZSByZWFjdGl2aXR5IGlzIGRpc2Nvbm5lY3RlZClcbiAgLy8gIzk0MzhcbiAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgbGV0IHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB7XG4gICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYHNjb3BlZFNsb3RzOl91KFske1xuICAgIE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoa2V5ID0+IHtcbiAgICAgIHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKVxuICAgIH0pLmpvaW4oJywnKVxuICB9XSR7bmVlZHNGb3JjZVVwZGF0ZSA/IGAsdHJ1ZWAgOiBgYH0pYFxufVxuXG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBlbC5jaGlsZHJlbi5zb21lKGNvbnRhaW5zU2xvdENoaWxkKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgY29uc3QgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkICYmICFpc0xlZ2FjeVN5bnRheCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QsIGBudWxsYClcbiAgfVxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgfVxuICBjb25zdCBzbG90U2NvcGUgPSBlbC5zbG90U2NvcGUgPT09IGVtcHR5U2xvdFNjb3BlVG9rZW5cbiAgICA/IGBgXG4gICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgY29uc3QgZm4gPSBgZnVuY3Rpb24oJHtzbG90U2NvcGV9KXtgICtcbiAgICBgcmV0dXJuICR7ZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgID8gYCgke2VsLmlmfSk/JHtnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnfTp1bmRlZmluZWRgXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9fWA7XG4gIC8vIHJldmVyc2UgcHJveHkgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgY29uc3QgcmV2ZXJzZVByb3h5ID0gc2xvdFNjb3BlID8gYGAgOiBgLHByb3h5OnRydWVgO1xuICByZXR1cm4gYHtrZXk6JHtlbC5zbG90VGFyZ2V0IHx8IGBcImRlZmF1bHRcImB9LGZuOiR7Zm59JHtyZXZlcnNlUHJveHl9fWBcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjb25zdCBlbCA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsLmZvciAmJlxuICAgICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbC50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgY29uc3Qgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgICAgPyBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgPyBgLDFgIDogYCwwYFxuICAgICAgICA6IGBgO1xuICAgICAgcmV0dXJuIGAkeyhhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSl9JHtub3JtYWxpemF0aW9uVHlwZX1gXG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICBjb25zdCBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIGBbJHtjaGlsZHJlbi5tYXAoYyA9PiBnZW4oYywgc3RhdGUpKS5qb2luKCcsJyl9XSR7XG4gICAgICBub3JtYWxpemF0aW9uVHlwZSA/IGAsJHtub3JtYWxpemF0aW9uVHlwZX1gIDogJydcbiAgICB9YFxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIGxldCByZXMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShjID0+IG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGMgPT4gbWF5YmVDb21wb25lbnQoYy5ibG9jaykpKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiBgX3YoJHt0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSlcbiAgfSlgXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIGBfZSgke0pTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCl9KWBcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIGNvbnN0IHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgY29uc3QgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICBsZXQgcmVzID0gYF90KCR7c2xvdE5hbWV9JHtjaGlsZHJlbiA/IGAsJHtjaGlsZHJlbn1gIDogJyd9YDtcbiAgY29uc3QgYXR0cnMgPSBlbC5hdHRycyB8fCBlbC5keW5hbWljQXR0cnNcbiAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGF0dHIgPT4gKHtcbiAgICAgICAgLy8gc2xvdCBwcm9wcyBhcmUgY2FtZWxpemVkXG4gICAgICAgIG5hbWU6IGNhbWVsaXplKGF0dHIubmFtZSksXG4gICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICBkeW5hbWljOiBhdHRyLmR5bmFtaWNcbiAgICAgIH0pKSlcbiAgICA6IG51bGw7XG4gIGNvbnN0IGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IGAsbnVsbGA7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IGAsJHthdHRyc31gO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IGAke2F0dHJzID8gJycgOiAnLG51bGwnfSwke2JpbmQkJDF9YDtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIGBfYygke2NvbXBvbmVudE5hbWV9LCR7Z2VuRGF0YSQyKGVsLCBzdGF0ZSl9JHtcbiAgICBjaGlsZHJlbiA/IGAsJHtjaGlsZHJlbn1gIDogJydcbiAgfSlgXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICBsZXQgc3RhdGljUHJvcHMgPSBgYDtcbiAgbGV0IGR5bmFtaWNQcm9wcyA9IGBgO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgIGNvbnN0IHZhbHVlID0gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpO1xuICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNQcm9wcyArPSBgJHtwcm9wLm5hbWV9LCR7dmFsdWV9LGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY1Byb3BzICs9IGBcIiR7cHJvcC5uYW1lfVwiOiR7dmFsdWV9LGA7XG4gICAgfVxuICB9XG4gIHN0YXRpY1Byb3BzID0gYHske3N0YXRpY1Byb3BzLnNsaWNlKDAsIC0xKX19YDtcbiAgaWYgKGR5bmFtaWNQcm9wcykge1xuICAgIHJldHVybiBgX2QoJHtzdGF0aWNQcm9wc30sWyR7ZHluYW1pY1Byb3BzLnNsaWNlKDAsIC0xKX1dKWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGljUHJvcHNcbiAgfVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG5jb25zdCBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xuY29uc3QgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG5jb25zdCBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCwgd2Fybikge1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgd2Fybik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCB3YXJuKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBjb25zdCByYW5nZSA9IG5vZGUucmF3QXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIGB2LWZvcj1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIGAke25hbWV9PVwiJHt2YWx1ZX1cImAsIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCBgJHtuYW1lfT1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIHdhcm4sIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgY29uc3Qgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgY29uc3Qga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgd2FybihcbiAgICAgIGBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IGAgK1xuICAgICAgYFwiJHtrZXl3b3JkTWF0Y2hbMF19XCIgaW4gZXhwcmVzc2lvbiAke3RleHQudHJpbSgpfWAsXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgaWRlbnQsXG4gIHR5cGUsXG4gIHRleHQsXG4gIHdhcm4sXG4gIHJhbmdlXG4pIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKGB2YXIgJHtpZGVudH09X2ApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oYGludmFsaWQgJHt0eXBlfSBcIiR7aWRlbnR9XCIgaW4gZXhwcmVzc2lvbjogJHt0ZXh0LnRyaW0oKX1gLCByYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihgcmV0dXJuICR7ZXhwfWApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc3Qga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogYCArXG4gICAgICAgIGBcIiR7a2V5d29yZE1hdGNoWzBdfVwiXFxuICBSYXcgZXhwcmVzc2lvbjogJHt0ZXh0LnRyaW0oKX1gLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgYGludmFsaWQgZXhwcmVzc2lvbjogJHtlLm1lc3NhZ2V9IGluXFxuXFxuYCArXG4gICAgICAgIGAgICAgJHtleHB9XFxuXFxuYCArXG4gICAgICAgIGAgIFJhdyBleHByZXNzaW9uOiAke3RleHQudHJpbSgpfVxcbmAsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3QgcmFuZ2UgPSAyO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZSAoXG4gIHNvdXJjZSxcbiAgc3RhcnQgPSAwLFxuICBlbmQgPSBzb3VyY2UubGVuZ3RoXG4pIHtcbiAgY29uc3QgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIGNvbnRpbnVlXG4gICAgICAgIHJlcy5wdXNoKGAke2ogKyAxfSR7cmVwZWF0KGAgYCwgMyAtIFN0cmluZyhqICsgMSkubGVuZ3RoKX18ICAke2xpbmVzW2pdfWApO1xuICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyByZXBlYXQoYCBgLCBwYWQpICsgcmVwZWF0KGBeYCwgbGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgcmVwZWF0KGBeYCwgbGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpXG59XG5cbmZ1bmN0aW9uIHJlcGVhdCAoc3RyLCBuKSB7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChuICYgMSkgcmVzdWx0ICs9IHN0cjtcbiAgICBuID4+Pj0gMTtcbiAgICBpZiAobiA8PSAwKSBicmVha1xuICAgIHN0ciArPSBzdHI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyLCBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICBjb25zdCB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICBjb25zdCBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgY29uc3QgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICBgRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcbiR7ZS5tc2d9XFxuXFxuYCArXG4gICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICBgRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcbiR7dGVtcGxhdGV9XFxuXFxuYCArXG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGUgPT4gYC0gJHtlfWApLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGUgPT4gdGlwKGUubXNnLCB2bSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChtc2cgPT4gdGlwKG1zZywgdm0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGNvbnN0IGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGNvZGUgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBgRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5gICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoKHsgZXJyLCBjb2RlIH0pID0+IGAke2Vyci50b1N0cmluZygpfSBpblxcblxcbiR7Y29kZX1cXG5gKS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yIChiYXNlQ29tcGlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICBjb25zdCB0aXBzID0gW107XG5cbiAgICAgIGxldCB3YXJuID0gKG1zZywgcmFuZ2UsIHRpcCkgPT4ge1xuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICBjb25zdCBsZWFkaW5nU3BhY2VMZW5ndGggPSB0ZW1wbGF0ZS5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG5cbiAgICAgICAgICB3YXJuID0gKG1zZywgcmFuZ2UsIHRpcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHsgbXNnIH07XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5lbmQgPSByYW5nZS5lbmQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKGRhdGEpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMgfHwgbnVsbCksXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xuXG4gICAgICBjb25zdCBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcbiAgICAgIHtcbiAgICAgICAgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCwgd2Fybik7XG4gICAgICB9XG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICAgIHJldHVybiBjb21waWxlZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlLFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cbmNvbnN0IGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG5jb25zdCB7IGNvbXBpbGUsIGNvbXBpbGVUb0Z1bmN0aW9ucyB9ID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmxldCBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IGA8YSBocmVmPVwiXFxuXCIvPmAgOiBgPGRpdiBhPVwiXFxuXCIvPmA7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG5jb25zdCBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZShmYWxzZSkgOiBmYWxzZTtcbi8vICM2ODI4OiBjaHJvbWUgZW5jb2RlcyBjb250ZW50IGluIGFbaHJlZl1cbmNvbnN0IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxuY29uc3QgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGlkID0+IHtcbiAgY29uc3QgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG5jb25zdCBtb3VudCA9IFZ1ZS5wcm90b3R5cGUuJG1vdW50O1xuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICB3YXJuKFxuICAgICAgYERvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLmBcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIGxldCB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgYFRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiAke29wdGlvbnMudGVtcGxhdGV9YCxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZShgdnVlICR7dGhpcy5fbmFtZX0gY29tcGlsZWAsICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8c2VsZWN0IGNsYXNzPSdzZWxlY3QnIHYtbW9kZWw9J3NlbGVjdGVkJyBAaW5wdXQ9J2V2ZW50ID0+IHsgJGVtaXQoXCJpbnB1dFwiLCBldmVudC50YXJnZXQudmFsdWUpIH0nPlxuICAgICAgPG9wdGlvbiB2LWZvcj0nb3B0aW9uIGluIG9wdGlvbnMnIDprZXk9J29wdGlvbi52YWx1ZScgOnZhbHVlPSdvcHRpb24udmFsdWUnPlxuICAgICAgICB7eyBvcHRpb24udGV4dCB9fVxuICAgICAgPC9vcHRpb24+XG4gICAgPC9zZWxlY3Q+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHN0eWxlPjwvc3R5bGU+XG5cbjxzY3JpcHQ+XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczogWydvcHRpb25zJywgJ3ZhbHVlJ10sXG4gICAgZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdGVkOiBudWxsLFxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnZhbHVlO1xuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNlbGVjdERhdGEgPSBbXG4gIHsgdGV4dDogJ0FsbCBCb3JvdWdocycsIHZhbHVlOiAnYWxsJyB9LFxuICB7IHRleHQ6ICdCcm9va2x5bicsIHZhbHVlOiAnYnJvb2tseW4nIH0sXG4gIHsgdGV4dDogJ1F1ZWVucycsIHZhbHVlOiAncXVlZW5zJyB9LFxuICB7IHRleHQ6ICdNYW5oYXR0YW4nLCB2YWx1ZTogJ21hbmhhdHRhbicgfSxcbiAgeyB0ZXh0OiAnU3RhdGVuIElzbGFuZCcsIHZhbHVlOiAnc3RhdGVuIGlzbGFuZCcgfSxcbiAgeyB0ZXh0OiAnVGhlIEJyb254JywgdmFsdWU6ICdicm9ueCcgfVxuXTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0RGF0YTsiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBWdWUgZnJvbSAndnVlL2Rpc3QvdnVlLmVzbS5icm93c2VyJzsgLy9cbmltcG9ydCBTZWxlY3RDb21wb25lbnQgZnJvbSAnLi9zZWxlY3QudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IFNlbGVjdERhdGEgZnJvbSAnLi9zZWxlY3QuZGF0YS5qcyc7IC8vIE91ciBzYW1wbGUgZGF0YVxuXG5jbGFzcyBTZWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoJ255Y28tc2VsZWN0JywgU2VsZWN0Q29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6ICdbZGF0YS1qcz1cImFwcFwiXScsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3B0aW9uczogU2VsZWN0LmRhdGEsXG4gICAgICAgICAgc2VsZWN0ZWQ6ICdhbGwnLFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cblNlbGVjdC5kYXRhID0gU2VsZWN0RGF0YTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0OyIsImZ1bmN0aW9uIGRhdGFIYW5kbGVyKG5ld0RhdGEsIG9sZERhdGEpIHtcbiAgaWYgKG9sZERhdGEpIHtcbiAgICB2YXIgY2hhcnQgPSB0aGlzLiRkYXRhLl9jaGFydDtcbiAgICB2YXIgbmV3RGF0YXNldExhYmVscyA9IG5ld0RhdGEuZGF0YXNldHMubWFwKGZ1bmN0aW9uIChkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YXNldC5sYWJlbDtcbiAgICB9KTtcbiAgICB2YXIgb2xkRGF0YXNldExhYmVscyA9IG9sZERhdGEuZGF0YXNldHMubWFwKGZ1bmN0aW9uIChkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YXNldC5sYWJlbDtcbiAgICB9KTtcbiAgICB2YXIgb2xkTGFiZWxzID0gSlNPTi5zdHJpbmdpZnkob2xkRGF0YXNldExhYmVscyk7XG4gICAgdmFyIG5ld0xhYmVscyA9IEpTT04uc3RyaW5naWZ5KG5ld0RhdGFzZXRMYWJlbHMpO1xuXG4gICAgaWYgKG5ld0xhYmVscyA9PT0gb2xkTGFiZWxzICYmIG9sZERhdGEuZGF0YXNldHMubGVuZ3RoID09PSBuZXdEYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgbmV3RGF0YS5kYXRhc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhc2V0LCBpKSB7XG4gICAgICAgIHZhciBvbGREYXRhc2V0S2V5cyA9IE9iamVjdC5rZXlzKG9sZERhdGEuZGF0YXNldHNbaV0pO1xuICAgICAgICB2YXIgbmV3RGF0YXNldEtleXMgPSBPYmplY3Qua2V5cyhkYXRhc2V0KTtcbiAgICAgICAgdmFyIGRlbGV0aW9uS2V5cyA9IG9sZERhdGFzZXRLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGtleSAhPT0gJ19tZXRhJyAmJiBuZXdEYXRhc2V0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGRlbGV0aW9uS2V5KSB7XG4gICAgICAgICAgZGVsZXRlIGNoYXJ0LmRhdGEuZGF0YXNldHNbaV1bZGVsZXRpb25LZXldO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gZGF0YXNldCkge1xuICAgICAgICAgIGlmIChkYXRhc2V0Lmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgIGNoYXJ0LmRhdGEuZGF0YXNldHNbaV1bYXR0cmlidXRlXSA9IGRhdGFzZXRbYXR0cmlidXRlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobmV3RGF0YS5oYXNPd25Qcm9wZXJ0eSgnbGFiZWxzJykpIHtcbiAgICAgICAgY2hhcnQuZGF0YS5sYWJlbHMgPSBuZXdEYXRhLmxhYmVscztcbiAgICAgICAgdGhpcy4kZW1pdCgnbGFiZWxzOnVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3RGF0YS5oYXNPd25Qcm9wZXJ0eSgneExhYmVscycpKSB7XG4gICAgICAgIGNoYXJ0LmRhdGEueExhYmVscyA9IG5ld0RhdGEueExhYmVscztcbiAgICAgICAgdGhpcy4kZW1pdCgneGxhYmVsczp1cGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0RhdGEuaGFzT3duUHJvcGVydHkoJ3lMYWJlbHMnKSkge1xuICAgICAgICBjaGFydC5kYXRhLnlMYWJlbHMgPSBuZXdEYXRhLnlMYWJlbHM7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3lsYWJlbHM6dXBkYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgdGhpcy4kZW1pdCgnY2hhcnQ6dXBkYXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaGFydCkge1xuICAgICAgICBjaGFydC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OmRlc3Ryb3knKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OnJlbmRlcicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy4kZGF0YS5fY2hhcnQpIHtcbiAgICAgIHRoaXMuJGRhdGEuX2NoYXJ0LmRlc3Ryb3koKTtcblxuICAgICAgdGhpcy4kZW1pdCgnY2hhcnQ6ZGVzdHJveScpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy4kZW1pdCgnY2hhcnQ6cmVuZGVyJyk7XG4gIH1cbn1cblxuZXhwb3J0IHZhciByZWFjdGl2ZURhdGEgPSB7XG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXJ0RGF0YTogbnVsbFxuICAgIH07XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgJ2NoYXJ0RGF0YSc6IGRhdGFIYW5kbGVyXG4gIH1cbn07XG5leHBvcnQgdmFyIHJlYWN0aXZlUHJvcCA9IHtcbiAgcHJvcHM6IHtcbiAgICBjaGFydERhdGE6IHtcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgICdjaGFydERhdGEnOiBkYXRhSGFuZGxlclxuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQge1xuICByZWFjdGl2ZURhdGE6IHJlYWN0aXZlRGF0YSxcbiAgcmVhY3RpdmVQcm9wOiByZWFjdGl2ZVByb3Bcbn07IiwiLy8hIG1vbWVudC5qc1xuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICBmdW5jdGlvbiBob29rcyAoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgICAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2VkRGF0ZVBhcnRzIDogW10sXG4gICAgICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgcmZjMjgyMiAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB3ZWVrZGF5TWlzbWF0Y2ggOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgfVxuXG4gICAgdmFyIHNvbWU7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgICAgICB2YXIgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpc05vd1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3Mud2Vla2RheU1pc21hdGNoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID0gaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuID09IG51bGwgfHwgIU9iamVjdC5pc0Zyb3plbihtKSkge1xuICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSBob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQgKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vciAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAvLyAtMCAtPiAwXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgICAgICBpZiAoaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihudWxsLCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGFyZztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0gJ1xcblsnICsgaSArICddICc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhcm4obXNnICsgJ1xcbkFyZ3VtZW50czogJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQgKGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICAgICAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLCBwcm9wO1xuICAgICAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXM7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgaSwgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG4gICAgdmFyIGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcblxuICAgIGZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgIHBhc3QgICA6ICclcyBhZ28nLFxuICAgICAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgc3MgOiAnJWQgc2Vjb25kcycsXG4gICAgICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgIGggIDogJ2FuIGhvdXInLFxuICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgIGQgIDogJ2EgZGF5JyxcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgIE0gIDogJ2EgbW9udGgnLFxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICB5ICA6ICdhIHllYXInLFxuICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICByZXR1cm4gKGlzRnVuY3Rpb24ob3V0cHV0KSkgP1xuICAgICAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhbGlhc2VzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICB2YXIgcHJpb3JpdGllcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgICAgIHByaW9yaXRpZXNbdW5pdF0gPSBwcmlvcml0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgICAgIHZhciB1bml0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciB1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgICAgICB1bml0cy5wdXNoKHt1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XX0pO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1bml0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxuICAgIHZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG4gICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJycsIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSkgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbiAgICB2YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG4gICAgdmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxuICAgIHZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxuICAgIHZhciBtYXRjaDV0bzYgICAgICA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LzsgLy8gICA5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbiAgICB2YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcblxuICAgIHZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbiAgICB2YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbiAgICB2YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgIHZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbiAgICB2YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4gICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgIHZhciBtYXRjaFdvcmQgPSAvWzAtOV17MCwyNTZ9WydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGMDdcXHVGRjEwLVxcdUZGRUZdezEsMjU2fXxbXFx1MDYwMC1cXHUwNkZGXFwvXXsxLDI1Nn0oXFxzKj9bXFx1MDYwMC1cXHUwNkZGXXsxLDI1Nn0pezEsMn0vaTtcblxuICAgIHZhciByZWdleGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuICh0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDA7XG4gICAgdmFyIE1PTlRIID0gMTtcbiAgICB2YXIgREFURSA9IDI7XG4gICAgdmFyIEhPVVIgPSAzO1xuICAgIHZhciBNSU5VVEUgPSA0O1xuICAgIHZhciBTRUNPTkQgPSA1O1xuICAgIHZhciBNSUxMSVNFQ09ORCA9IDY7XG4gICAgdmFyIFdFRUsgPSA3O1xuICAgIHZhciBXRUVLREFZID0gODtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0ICh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNldCQxKHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCAobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uaXNWYWxpZCgpID9cbiAgICAgICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCQxIChtb20sIHVuaXQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChtb20uaXNWYWxpZCgpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnRnVsbFllYXInICYmIGlzTGVhcFllYXIobW9tLnllYXIoKSkgJiYgbW9tLm1vbnRoKCkgPT09IDEgJiYgbW9tLmRhdGUoKSA9PT0gMjkpIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUsIG1vbS5tb250aCgpLCBkYXlzSW5Nb250aCh2YWx1ZSwgbW9tLm1vbnRoKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0ICh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9kKG4sIHgpIHtcbiAgICAgICAgcmV0dXJuICgobiAlIHgpICsgeCkgJSB4O1xuICAgIH1cblxuICAgIHZhciBpbmRleE9mO1xuXG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIC8vIEkga25vd1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RNb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgICAgICB5ZWFyICs9IChtb250aCAtIG1vZE1vbnRoKSAvIDEyO1xuICAgICAgICByZXR1cm4gbW9kTW9udGggPT09IDEgPyAoaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpIDogKDMxIC0gbW9kTW9udGggJSA3ICUgMik7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vO1xuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzID0gJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzIChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzWyh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnQgOlxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAgICAgLy8gY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcbiAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSArIDQwMCwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0RnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUgKHkpIHtcbiAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgYXJnc1swXSA9IHkgKyA0MDA7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICAgICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgICAgIHJlc1dlZWssIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgICAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNnRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOYU4oaW5wdXQpID8gbnVsbCA6IGlucHV0O1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcbiAgICBmdW5jdGlvbiBzaGlmdFdlZWtkYXlzICh3cywgbikge1xuICAgICAgICByZXR1cm4gd3Muc2xpY2UobiwgNykuY29uY2F0KHdzLnNsaWNlKDAsIG4pKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIHdlZWtkYXlzID0gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5cyA6XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1sobSAmJiBtICE9PSB0cnVlICYmIHRoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ107XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHdlZWtkYXlzLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gd2Vla2RheXNbbS5kYXkoKV0gOiB3ZWVrZGF5cztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIChtID09PSB0cnVlKSA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNTaG9ydCwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICAgICAgcmV0dXJuIChtID09PSB0cnVlKSA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNNaW4sIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlJDEod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGQnICYmIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNNaW5SZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tLCBtaW5wLCBzaG9ydHAsIGxvbmdwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgbG9uZ3AgPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpO1xuICAgICAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdBJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2trJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaycsICdrayddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUlzUE0gKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1lcmlkaWVtIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgLy8gdGhpcyBydWxlLlxuICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgIHZhciBiYXNlQ29uZmlnID0ge1xuICAgICAgICBjYWxlbmRhcjogZGVmYXVsdENhbGVuZGFyLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxuICAgICAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxuICAgICAgICBvcmRpbmFsOiBkZWZhdWx0T3JkaW5hbCxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UsXG4gICAgICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcblxuICAgICAgICBtb250aHM6IGRlZmF1bHRMb2NhbGVNb250aHMsXG4gICAgICAgIG1vbnRoc1Nob3J0OiBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQsXG5cbiAgICAgICAgd2VlazogZGVmYXVsdExvY2FsZVdlZWssXG5cbiAgICAgICAgd2Vla2RheXM6IGRlZmF1bHRMb2NhbGVXZWVrZGF5cyxcbiAgICAgICAgd2Vla2RheXNNaW46IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbixcbiAgICAgICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXG5cbiAgICAgICAgbWVyaWRpZW1QYXJzZTogZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2VcbiAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge307XG4gICAgdmFyIGxvY2FsZUZhbWlsaWVzID0ge307XG4gICAgdmFyIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xuICAgIH1cblxuICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuICAgIC8vIHRyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4gICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgICAgICB2YXIgaSA9IDAsIGosIG5leHQsIGxvY2FsZSwgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsO1xuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgdmFyIGFsaWFzZWRSZXF1aXJlID0gcmVxdWlyZTtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy93YXJuIHVzZXIgaWYgYXJndW1lbnRzIGFyZSBwYXNzZWQgYnV0IHRoZSBsb2NhbGUgY291bGQgbm90IGJlIHNldFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0xvY2FsZSAnICsga2V5ICsgICcgbm90IGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byBsb2FkIGl0PycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoJ2RlZmluZUxvY2FsZU92ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoY29uZmlnLnBhcmVudExvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVMb2NhbGUoeC5uYW1lLCB4LmNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgbG9jYWxlIEFGVEVSIGFsbCBjaGlsZCBsb2NhbGVzIGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gY3JlYXRlZCwgc28gd2Ugd29uJ3QgZW5kIHVwIHdpdGggdGhlIGNoaWxkIGxvY2FsZSBzZXQuXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSwgdG1wTG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgIHRtcExvY2FsZSA9IGxvYWRMb2NhbGUobmFtZSk7XG4gICAgICAgICAgICBpZiAodG1wTG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XG4gICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICBmdW5jdGlvbiBnZXRMb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyAobSkge1xuICAgICAgICB2YXIgb3ZlcmZsb3c7XG4gICAgICAgIHZhciBhID0gbS5fYTtcblxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgICAgIGFbREFURV0gICAgICAgIDwgMSB8fCBhW0RBVEVdICAgICAgICA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKSA/IERBVEUgOlxuICAgICAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgICAgICBhW1NFQ09ORF0gICAgICA8IDAgfHwgYVtTRUNPTkRdICAgICAgPiA1OSAgPyBTRUNPTkQgOlxuICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dEYXlPZlllYXIgJiYgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksIG5vd1ZhbHVlLmdldFVUQ01vbnRoKCksIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5IChjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCBleHBlY3RlZFdlZWtkYXksIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSB8fCBjb25maWcuX2RheU9mWWVhciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDID8gY29uZmlnLl9kLmdldFVUQ0RheSgpIDogY29uZmlnLl9kLmdldERheSgpO1xuXG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIHR5cGVvZiBjb25maWcuX3cuZCAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uZmlnLl93LmQgIT09IGV4cGVjdGVkV2Vla2RheSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgIHZhciBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpc28gODYwMSByZWdleFxuICAgIC8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxuICAgIHZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuICAgIHZhciBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxuICAgIHZhciB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vO1xuXG4gICAgdmFyIGlzb0RhdGVzID0gW1xuICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcbiAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZREREJywgL1xcZHs3fS9dXG4gICAgXTtcblxuICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICB2YXIgaXNvVGltZXMgPSBbXG4gICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISCcsIC9cXGRcXGQvXVxuICAgIF07XG5cbiAgICB2YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLCBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUkZDIDI4MjIgcmVnZXg6IEZvciBkZXRhaWxzIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNzZWN0aW9uLTMuM1xuICAgIHZhciByZmMyODIyID0gL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLztcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKVxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChzZWNvbmRTdHIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhclN0cikge1xuICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KHllYXJTdHIsIDEwKTtcbiAgICAgICAgaWYgKHllYXIgPD0gNDkpIHtcbiAgICAgICAgICAgIHJldHVybiAyMDAwICsgeWVhcjtcbiAgICAgICAgfSBlbHNlIGlmICh5ZWFyIDw9IDk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ZWFyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKS5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKS5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKS5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW50ZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKHBhcnNlZElucHV0WzBdLCBwYXJzZWRJbnB1dFsxXSwgcGFyc2VkSW5wdXRbMl0pLmdldERheSgpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXlQcm92aWRlZCAhPT0gd2Vla2RheUFjdHVhbCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBvYnNPZmZzZXRzID0ge1xuICAgICAgICBVVDogMCxcbiAgICAgICAgR01UOiAwLFxuICAgICAgICBFRFQ6IC00ICogNjAsXG4gICAgICAgIEVTVDogLTUgKiA2MCxcbiAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICBDU1Q6IC02ICogNjAsXG4gICAgICAgIE1EVDogLTYgKiA2MCxcbiAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICBQRFQ6IC03ICogNjAsXG4gICAgICAgIFBTVDogLTggKiA2MFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gICAgICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKTtcbiAgICAgICAgICAgIHZhciBtID0gaG0gJSAxMDAsIGggPSAoaG0gLSBtKSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBoICogNjAgKyBtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2ggPSByZmMyODIyLmV4ZWMocHJlcHJvY2Vzc1JGQzI4MjIoY29uZmlnLl9pKSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhtYXRjaFs0XSwgbWF0Y2hbM10sIG1hdGNoWzJdLCBtYXRjaFs1XSwgbWF0Y2hbNl0sIG1hdGNoWzddKTtcbiAgICAgICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXG4gICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhbiB1cGNvbWluZyBtYWpvciByZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG4gICAgaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuJywgdG9rZW4sICdwYXJzZWRJbnB1dCcsIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgIHZhciBpc1BtO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAvL1xuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcbiAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICB2YXIgcmVzLCBpO1xuICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuICAgIGZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4ICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xuICAgIH07XG5cbiAgICB2YXIgb3JkZXJpbmcgPSBbJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTtcblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtKSB7XG4gICAgICAgICAgICBpZiAoIShpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXRIYXNEZWNpbWFsID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgbm9ybWFsaXplZElucHV0Lmlzb1dlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSBpc0R1cmF0aW9uVmFsaWQobm9ybWFsaXplZElucHV0KTtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0byB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNSb3VuZCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcik7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBtaW51dGVzID09PSAwID9cbiAgICAgICAgICAwIDpcbiAgICAgICAgICBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICBob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAvL1xuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gL14oXFwtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspKFxcLlxcZCopPyk/JC87XG5cbiAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgdmFyIGlzb1JlZ2V4ID0gL14oLXxcXCspP1AoPzooWy0rXT9bMC05LC5dKilZKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilXKT8oPzooWy0rXT9bMC05LC5dKilEKT8oPzpUKD86KFstK10/WzAtOSwuXSopSCk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopUyk/KT8kLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBoICA6IHRvSW50KG1hdGNoW0hPVVJdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtcyA6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24gLy8gdGhlIG1pbGxpc2Vjb25kIGRlY2ltYWwgcG9pbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG1hdGNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuICAgIGNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7fTtcblxuICAgICAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSAodGltZSwgZm9ybWF0cykge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICAgICAgdmFyIGxvY2FsRnJvbSA9IGlzTW9tZW50KGZyb20pID8gZnJvbSA6IGNyZWF0ZUxvY2FsKGZyb20pLFxuICAgICAgICAgICAgbG9jYWxUbyA9IGlzTW9tZW50KHRvKSA/IHRvIDogY3JlYXRlTG9jYWwodG8pO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbEZyb20uaXNWYWxpZCgpICYmIGxvY2FsVG8uaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICAgICAgcmV0dXJuIChpbmNsdXNpdml0eVswXSA9PT0gJygnID8gdGhpcy5pc0FmdGVyKGxvY2FsRnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUobG9jYWxGcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJyA/IHRoaXMuaXNCZWZvcmUobG9jYWxUbywgdW5pdHMpIDogIXRoaXMuaXNBZnRlcihsb2NhbFRvLCB1bml0cykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCksXG4gICAgICAgICAgICBpbnB1dE1zO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckFmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0LFxuICAgICAgICAgICAgem9uZURlbHRhLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMTI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDFlMzsgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7IGJyZWFrOyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gODY0ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBkZWZhdWx0OiBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nKGtlZXBPZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHV0YyA9IGtlZXBPZmZzZXQgIT09IHRydWU7XG4gICAgICAgIHZhciBtID0gdXRjID8gdGhpcy5jbG9uZSgpLnV0YygpIDogdGhpcztcbiAgICAgICAgaWYgKG0ueWVhcigpIDwgMCB8fCBtLnllYXIoKSA+IDk5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLnJlcGxhY2UoJ1onLCBmb3JtYXRNb21lbnQobSwgJ1onKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW9tZW50LmludmFsaWQoLyogJyArIHRoaXMuX2kgKyAnICovKSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSAnbW9tZW50JztcbiAgICAgICAgdmFyIHpvbmUgPSAnJztcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XG4gICAgICAgICAgICB6b25lID0gJ1onO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgICAgICB2YXIgeWVhciA9ICgwIDw9IHRoaXMueWVhcigpICYmIHRoaXMueWVhcigpIDw9IDk5OTkpID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIHZhciBNU19QRVJfU0VDT05EID0gMTAwMDtcbiAgICB2YXIgTVNfUEVSX01JTlVURSA9IDYwICogTVNfUEVSX1NFQ09ORDtcbiAgICB2YXIgTVNfUEVSX0hPVVIgPSA2MCAqIE1TX1BFUl9NSU5VVEU7XG4gICAgdmFyIE1TX1BFUl80MDBfWUVBUlMgPSAoMzY1ICogNDAwICsgOTcpICogMjQgKiBNU19QRVJfSE9VUjtcblxuICAgIC8vIGFjdHVhbCBtb2R1bG8gLSBoYW5kbGVzIG5lZ2F0aXZlIG51bWJlcnMgKGZvciBkYXRlcyBiZWZvcmUgMTk3MCk6XG4gICAgZnVuY3Rpb24gbW9kJDEoZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuIChkaXZpZGVuZCAlIGRpdmlzb3IgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0Y1N0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gRGF0ZS5VVEMgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSwgbSwgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgICAgICB2YXIgdGltZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRPZkRhdGUgPSB0aGlzLl9pc1VUQyA/IHV0Y1N0YXJ0T2ZEYXRlIDogbG9jYWxTdGFydE9mRGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIDAsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgLSB0aGlzLm1vbnRoKCkgJSAzLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUgKyAodGhpcy5faXNVVEMgPyAwIDogdGhpcy51dGNPZmZzZXQoKSAqIE1TX1BFUl9NSU5VVEUpLCBNU19QRVJfSE9VUik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfU0VDT05EKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpICsgMSwgMCwgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgLSB0aGlzLm1vbnRoKCkgJSAzICsgMywgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpICsgMSwgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkgKyA3KSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKSArIDcpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfSE9VUiAtIG1vZCQxKHRpbWUgKyAodGhpcy5faXNVVEMgPyAwIDogdGhpcy51dGNPZmZzZXQoKSAqIE1TX1BFUl9NSU5VVEUpLCBNU19QRVJfSE9VUikgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfTUlOVVRFIC0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfU0VDT05EIC0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMiAoKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgICAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdxdWFydGVyJywgNyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/XG4gICAgICAgICAgKGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZSB8fCBsb2NhbGUuX29yZGluYWxQYXJzZSkgOlxuICAgICAgICAgIGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbiAgICBhZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdKTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uYWRkICAgICAgICAgICAgICAgPSBhZGQ7XG4gICAgcHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBjYWxlbmRhciQxO1xuICAgIHByb3RvLmNsb25lICAgICAgICAgICAgID0gY2xvbmU7XG4gICAgcHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xuICAgIHByb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG4gICAgcHJvdG8uZm9ybWF0ICAgICAgICAgICAgPSBmb3JtYXQ7XG4gICAgcHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xuICAgIHByb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbiAgICBwcm90by50byAgICAgICAgICAgICAgICA9IHRvO1xuICAgIHByb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XG4gICAgcHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdHZXQ7XG4gICAgcHJvdG8uaW52YWxpZEF0ICAgICAgICAgPSBpbnZhbGlkQXQ7XG4gICAgcHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xuICAgIHByb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG4gICAgcHJvdG8uaXNCZXR3ZWVuICAgICAgICAgPSBpc0JldHdlZW47XG4gICAgcHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XG4gICAgcHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xuICAgIHByb3RvLmlzU2FtZU9yQmVmb3JlICAgID0gaXNTYW1lT3JCZWZvcmU7XG4gICAgcHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBpc1ZhbGlkJDI7XG4gICAgcHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xuICAgIHByb3RvLmxvY2FsZSAgICAgICAgICAgID0gbG9jYWxlO1xuICAgIHByb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcbiAgICBwcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICBwcm90by5taW4gICAgICAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbiAgICBwcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcbiAgICBwcm90by5zZXQgICAgICAgICAgICAgICA9IHN0cmluZ1NldDtcbiAgICBwcm90by5zdGFydE9mICAgICAgICAgICA9IHN0YXJ0T2Y7XG4gICAgcHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBzdWJ0cmFjdDtcbiAgICBwcm90by50b0FycmF5ICAgICAgICAgICA9IHRvQXJyYXk7XG4gICAgcHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbiAgICBwcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcbiAgICBwcm90by50b0lTT1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nO1xuICAgIHByb3RvLmluc3BlY3QgICAgICAgICAgID0gaW5zcGVjdDtcbiAgICBwcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcbiAgICBwcm90by50b1N0cmluZyAgICAgICAgICA9IHRvU3RyaW5nO1xuICAgIHByb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbiAgICBwcm90by52YWx1ZU9mICAgICAgICAgICA9IHZhbHVlT2Y7XG4gICAgcHJvdG8uY3JlYXRpb25EYXRhICAgICAgPSBjcmVhdGlvbkRhdGE7XG4gICAgcHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG4gICAgcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG4gICAgcHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuICAgIHByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG4gICAgcHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbiAgICBwcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuICAgIHByb3RvLndlZWsgICAgICAgICAgID0gcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbiAgICBwcm90by5pc29XZWVrICAgICAgICA9IHByb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG4gICAgcHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBwcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIHByb3RvLmRheSAgICAgICAgPSBwcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIHByb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBwcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuICAgIHByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XG4gICAgcHJvdG8ubWludXRlID0gcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcbiAgICBwcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuICAgIHByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG4gICAgcHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG4gICAgcHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBwcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgcHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICBwcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xuICAgIHByb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgcHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xuICAgIHByb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XG4gICAgcHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBwcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIHByb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcbiAgICBwcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG4gICAgcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG4gICAgcHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG4gICAgcHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsIGdldFNldFpvbmUpO1xuICAgIHByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZSgnaXNEU1RTaGlmdGVkIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RzdC1zaGlmdGVkLyBmb3IgbW9yZSBpbmZvcm1hdGlvbicsIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVbml4IChpbnB1dCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJblpvbmUgKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBwcm90byQxID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDEuY2FsZW5kYXIgICAgICAgID0gY2FsZW5kYXI7XG4gICAgcHJvdG8kMS5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90byQxLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xuICAgIHByb3RvJDEub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbiAgICBwcm90byQxLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlVGltZTtcbiAgICBwcm90byQxLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG8kMS5zZXQgICAgICAgICAgICAgPSBzZXQ7XG5cbiAgICBwcm90byQxLm1vbnRocyAgICAgICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvJDEubW9udGhzUGFyc2UgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG4gICAgcHJvdG8kMS5tb250aHNSZWdleCAgICAgICA9IG1vbnRoc1JlZ2V4O1xuICAgIHByb3RvJDEubW9udGhzU2hvcnRSZWdleCAgPSBtb250aHNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIHByb3RvJDEud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5c1JlZ2V4ICAgICAgID0gICAgICAgIHdlZWtkYXlzUmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggID0gICAgICAgIHdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzTWluUmVnZXggICAgPSAgICAgICAgd2Vla2RheXNNaW5SZWdleDtcblxuICAgIHByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gZ2V0JDEgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpO1xuICAgICAgICB2YXIgdXRjID0gY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwgKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vICgpXG4gICAgLy8gKDUpXG4gICAgLy8gKGZtdCwgNSlcbiAgICAvLyAoZm10KVxuICAgIC8vICh0cnVlKVxuICAgIC8vICh0cnVlLCA1KVxuICAgIC8vICh0cnVlLCBmbXQsIDUpXG4gICAgLy8gKHRydWUsIGZtdClcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgIH1cblxuICAgIGdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgaG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBnZXRTZXRHbG9iYWxMb2NhbGUpO1xuICAgIGhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgZ2V0TG9jYWxlKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBhYnMgKCkge1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QkMSAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICAgICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gYWRkJDEgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gc3VidHJhY3QkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICAgICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICAgICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcyAodW5pdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5cztcbiAgICAgICAgdmFyIG1vbnRocztcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogICByZXR1cm4gbW9udGhzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiByZXR1cm4gbW9udGhzIC8gMztcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFyJzogICAgcmV0dXJuIG1vbnRocyAvIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiB2YWx1ZU9mJDEgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG4gICAgdmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG4gICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgdmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG4gICAgdmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG4gICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgdmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG4gICAgdmFyIGFzUXVhcnRlcnMgICAgID0gbWFrZUFzKCdRJyk7XG4gICAgdmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBjbG9uZSQxICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCQyICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgIHZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG4gICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgc3M6IDQ0LCAgICAgICAgIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICBzIDogNDUsICAgICAgICAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbSA6IDQ1LCAgICAgICAgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICBoIDogMjIsICAgICAgICAgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgIGQgOiAyNiwgICAgICAgICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE0gOiAxMSAgICAgICAgICAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICAgICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICAgICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgICAgICB2YXIgYSA9IHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICAgJiYgWydzcycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gICAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAgICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICAgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gICAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xuICAgICAgICByZXR1cm4gKCh4ID4gMCkgLSAoeCA8IDApKSB8fCAreDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gYWJzJDEodGhpcy5fZGF5cyk7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSBhYnMkMSh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsU2lnbiArICdQJyArXG4gICAgICAgICAgICAoWSA/IHltU2lnbiArIFkgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKE0gPyB5bVNpZ24gKyBNICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChEID8gZGF5c1NpZ24gKyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaG1zU2lnbiArIGggKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG0gPyBobXNTaWduICsgbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAocyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMi5pc1ZhbGlkICAgICAgICA9IGlzVmFsaWQkMTtcbiAgICBwcm90byQyLmFicyAgICAgICAgICAgID0gYWJzO1xuICAgIHByb3RvJDIuYWRkICAgICAgICAgICAgPSBhZGQkMTtcbiAgICBwcm90byQyLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3QkMTtcbiAgICBwcm90byQyLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgcHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBwcm90byQyLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBwcm90byQyLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIHByb3RvJDIuYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIHByb3RvJDIuYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBwcm90byQyLmFzUXVhcnRlcnMgICAgID0gYXNRdWFydGVycztcbiAgICBwcm90byQyLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBwcm90byQyLnZhbHVlT2YgICAgICAgID0gdmFsdWVPZiQxO1xuICAgIHByb3RvJDIuX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG4gICAgcHJvdG8kMi5jbG9uZSAgICAgICAgICA9IGNsb25lJDE7XG4gICAgcHJvdG8kMi5nZXQgICAgICAgICAgICA9IGdldCQyO1xuICAgIHByb3RvJDIubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG4gICAgcHJvdG8kMi5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG4gICAgcHJvdG8kMi5ob3VycyAgICAgICAgICA9IGhvdXJzO1xuICAgIHByb3RvJDIuZGF5cyAgICAgICAgICAgPSBkYXlzO1xuICAgIHByb3RvJDIud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbiAgICBwcm90byQyLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xuICAgIHByb3RvJDIueWVhcnMgICAgICAgICAgPSB5ZWFycztcbiAgICBwcm90byQyLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b0pTT04gICAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90byQyLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuICAgIHByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgdG9JU09TdHJpbmckMSk7XG4gICAgcHJvdG8kMi5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIGhvb2tzLnZlcnNpb24gPSAnMi4yNC4wJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbiAgICBob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBwcm90bztcbiAgICBob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG4gICAgaG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIGhvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbiAgICBob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVVEM7XG4gICAgaG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gY3JlYXRlVW5peDtcbiAgICBob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0TW9udGhzO1xuICAgIGhvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICBob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgaG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gY3JlYXRlSW52YWxpZDtcbiAgICBob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVEdXJhdGlvbjtcbiAgICBob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICBob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0V2Vla2RheXM7XG4gICAgaG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gY3JlYXRlSW5ab25lO1xuICAgIGhvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGdldExvY2FsZTtcbiAgICBob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuICAgIGhvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RNb250aHNTaG9ydDtcbiAgICBob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0V2Vla2RheXNNaW47XG4gICAgaG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgIGhvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbiAgICBob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsaXN0TG9jYWxlcztcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0V2Vla2RheXNTaG9ydDtcbiAgICBob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyAgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgaG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG4gICAgaG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gcHJvdG87XG5cbiAgICAvLyBjdXJyZW50bHkgSFRNTDUgaW5wdXQgdHlwZSBvbmx5IHN1cHBvcnRzIDI0LWhvdXIgZm9ybWF0c1xuICAgIGhvb2tzLkhUTUw1X0ZNVCA9IHtcbiAgICAgICAgREFURVRJTUVfTE9DQUw6ICdZWVlZLU1NLUREVEhIOm1tJywgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX1NFQ09ORFM6ICdZWVlZLU1NLUREVEhIOm1tOnNzJywgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBEQVRFOiAnWVlZWS1NTS1ERCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgICAgICBUSU1FOiAnSEg6bW0nLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgICAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIFdFRUs6ICdHR0dHLVtXXVdXJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxuICAgIH07XG5cbiAgICByZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iLCIvKiFcbiAqIENoYXJ0LmpzIHYyLjguMFxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDE5IENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZnVuY3Rpb24oKSB7IHRyeSB7IHJldHVybiByZXF1aXJlKCdtb21lbnQnKTsgfSBjYXRjaChlKSB7IH0gfSgpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydyZXF1aXJlJ10sIGZ1bmN0aW9uKHJlcXVpcmUpIHsgcmV0dXJuIGZhY3RvcnkoZnVuY3Rpb24oKSB7IHRyeSB7IHJldHVybiByZXF1aXJlKCdtb21lbnQnKTsgfSBjYXRjaChlKSB7IH0gfSgpKTsgfSkgOlxuKGdsb2JhbC5DaGFydCA9IGZhY3RvcnkoZ2xvYmFsLm1vbWVudCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cbm1vbWVudCA9IG1vbWVudCAmJiBtb21lbnQuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSA/IG1vbWVudFsnZGVmYXVsdCddIDogbW9tZW50O1xuXG4vKiBNSVQgbGljZW5zZSAqL1xuXG52YXIgY29udmVyc2lvbnMgPSB7XG4gIHJnYjJoc2w6IHJnYjJoc2wsXG4gIHJnYjJoc3Y6IHJnYjJoc3YsXG4gIHJnYjJod2I6IHJnYjJod2IsXG4gIHJnYjJjbXlrOiByZ2IyY215ayxcbiAgcmdiMmtleXdvcmQ6IHJnYjJrZXl3b3JkLFxuICByZ2IyeHl6OiByZ2IyeHl6LFxuICByZ2IybGFiOiByZ2IybGFiLFxuICByZ2IybGNoOiByZ2IybGNoLFxuXG4gIGhzbDJyZ2I6IGhzbDJyZ2IsXG4gIGhzbDJoc3Y6IGhzbDJoc3YsXG4gIGhzbDJod2I6IGhzbDJod2IsXG4gIGhzbDJjbXlrOiBoc2wyY215ayxcbiAgaHNsMmtleXdvcmQ6IGhzbDJrZXl3b3JkLFxuXG4gIGhzdjJyZ2I6IGhzdjJyZ2IsXG4gIGhzdjJoc2w6IGhzdjJoc2wsXG4gIGhzdjJod2I6IGhzdjJod2IsXG4gIGhzdjJjbXlrOiBoc3YyY215ayxcbiAgaHN2MmtleXdvcmQ6IGhzdjJrZXl3b3JkLFxuXG4gIGh3YjJyZ2I6IGh3YjJyZ2IsXG4gIGh3YjJoc2w6IGh3YjJoc2wsXG4gIGh3YjJoc3Y6IGh3YjJoc3YsXG4gIGh3YjJjbXlrOiBod2IyY215ayxcbiAgaHdiMmtleXdvcmQ6IGh3YjJrZXl3b3JkLFxuXG4gIGNteWsycmdiOiBjbXlrMnJnYixcbiAgY215azJoc2w6IGNteWsyaHNsLFxuICBjbXlrMmhzdjogY215azJoc3YsXG4gIGNteWsyaHdiOiBjbXlrMmh3YixcbiAgY215azJrZXl3b3JkOiBjbXlrMmtleXdvcmQsXG5cbiAga2V5d29yZDJyZ2I6IGtleXdvcmQycmdiLFxuICBrZXl3b3JkMmhzbDoga2V5d29yZDJoc2wsXG4gIGtleXdvcmQyaHN2OiBrZXl3b3JkMmhzdixcbiAga2V5d29yZDJod2I6IGtleXdvcmQyaHdiLFxuICBrZXl3b3JkMmNteWs6IGtleXdvcmQyY215ayxcbiAga2V5d29yZDJsYWI6IGtleXdvcmQybGFiLFxuICBrZXl3b3JkMnh5ejoga2V5d29yZDJ4eXosXG5cbiAgeHl6MnJnYjogeHl6MnJnYixcbiAgeHl6MmxhYjogeHl6MmxhYixcbiAgeHl6MmxjaDogeHl6MmxjaCxcblxuICBsYWIyeHl6OiBsYWIyeHl6LFxuICBsYWIycmdiOiBsYWIycmdiLFxuICBsYWIybGNoOiBsYWIybGNoLFxuXG4gIGxjaDJsYWI6IGxjaDJsYWIsXG4gIGxjaDJ4eXo6IGxjaDJ4eXosXG4gIGxjaDJyZ2I6IGxjaDJyZ2Jcbn07XG5cblxuZnVuY3Rpb24gcmdiMmhzbChyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0vMjU1LFxuICAgICAgZyA9IHJnYlsxXS8yNTUsXG4gICAgICBiID0gcmdiWzJdLzI1NSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgIGgsIHMsIGw7XG5cbiAgaWYgKG1heCA9PSBtaW4pXG4gICAgaCA9IDA7XG4gIGVsc2UgaWYgKHIgPT0gbWF4KVxuICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGcgPT0gbWF4KVxuICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICBlbHNlIGlmIChiID09IG1heClcbiAgICBoID0gNCArIChyIC0gZykvIGRlbHRhO1xuXG4gIGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cbiAgaWYgKGggPCAwKVxuICAgIGggKz0gMzYwO1xuXG4gIGwgPSAobWluICsgbWF4KSAvIDI7XG5cbiAgaWYgKG1heCA9PSBtaW4pXG4gICAgcyA9IDA7XG4gIGVsc2UgaWYgKGwgPD0gMC41KVxuICAgIHMgPSBkZWx0YSAvIChtYXggKyBtaW4pO1xuICBlbHNlXG4gICAgcyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXG4gIHJldHVybiBbaCwgcyAqIDEwMCwgbCAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJoc3YocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLFxuICAgICAgZyA9IHJnYlsxXSxcbiAgICAgIGIgPSByZ2JbMl0sXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCB2O1xuXG4gIGlmIChtYXggPT0gMClcbiAgICBzID0gMDtcbiAgZWxzZVxuICAgIHMgPSAoZGVsdGEvbWF4ICogMTAwMCkvMTA7XG5cbiAgaWYgKG1heCA9PSBtaW4pXG4gICAgaCA9IDA7XG4gIGVsc2UgaWYgKHIgPT0gbWF4KVxuICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGcgPT0gbWF4KVxuICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICBlbHNlIGlmIChiID09IG1heClcbiAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICB2ID0gKChtYXggLyAyNTUpICogMTAwMCkgLyAxMDtcblxuICByZXR1cm4gW2gsIHMsIHZdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHdiKHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgaCA9IHJnYjJoc2wocmdiKVswXSxcbiAgICAgIHcgPSAxLzI1NSAqIE1hdGgubWluKHIsIE1hdGgubWluKGcsIGIpKSxcbiAgICAgIGIgPSAxIC0gMS8yNTUgKiBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG5cbiAgcmV0dXJuIFtoLCB3ICogMTAwLCBiICogMTAwXTtcbn1cblxuZnVuY3Rpb24gcmdiMmNteWsocmdiKSB7XG4gIHZhciByID0gcmdiWzBdIC8gMjU1LFxuICAgICAgZyA9IHJnYlsxXSAvIDI1NSxcbiAgICAgIGIgPSByZ2JbMl0gLyAyNTUsXG4gICAgICBjLCBtLCB5LCBrO1xuXG4gIGsgPSBNYXRoLm1pbigxIC0gciwgMSAtIGcsIDEgLSBiKTtcbiAgYyA9ICgxIC0gciAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICBtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHkgPSAoMSAtIGIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgcmV0dXJuIFtjICogMTAwLCBtICogMTAwLCB5ICogMTAwLCBrICogMTAwXTtcbn1cblxuZnVuY3Rpb24gcmdiMmtleXdvcmQocmdiKSB7XG4gIHJldHVybiByZXZlcnNlS2V5d29yZHNbSlNPTi5zdHJpbmdpZnkocmdiKV07XG59XG5cbmZ1bmN0aW9uIHJnYjJ4eXoocmdiKSB7XG4gIHZhciByID0gcmdiWzBdIC8gMjU1LFxuICAgICAgZyA9IHJnYlsxXSAvIDI1NSxcbiAgICAgIGIgPSByZ2JbMl0gLyAyNTU7XG5cbiAgLy8gYXNzdW1lIHNSR0JcbiAgciA9IHIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChyICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKHIgLyAxMi45Mik7XG4gIGcgPSBnID4gMC4wNDA0NSA/IE1hdGgucG93KCgoZyArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChnIC8gMTIuOTIpO1xuICBiID0gYiA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoYiAvIDEyLjkyKTtcblxuICB2YXIgeCA9IChyICogMC40MTI0KSArIChnICogMC4zNTc2KSArIChiICogMC4xODA1KTtcbiAgdmFyIHkgPSAociAqIDAuMjEyNikgKyAoZyAqIDAuNzE1MikgKyAoYiAqIDAuMDcyMik7XG4gIHZhciB6ID0gKHIgKiAwLjAxOTMpICsgKGcgKiAwLjExOTIpICsgKGIgKiAwLjk1MDUpO1xuXG4gIHJldHVybiBbeCAqIDEwMCwgeSAqMTAwLCB6ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gcmdiMmxhYihyZ2IpIHtcbiAgdmFyIHh5eiA9IHJnYjJ4eXoocmdiKSxcbiAgICAgICAgeCA9IHh5elswXSxcbiAgICAgICAgeSA9IHh5elsxXSxcbiAgICAgICAgeiA9IHh5elsyXSxcbiAgICAgICAgbCwgYSwgYjtcblxuICB4IC89IDk1LjA0NztcbiAgeSAvPSAxMDA7XG4gIHogLz0gMTA4Ljg4MztcblxuICB4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMS8zKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcbiAgeSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEvMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG4gIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxLzMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG4gIGwgPSAoMTE2ICogeSkgLSAxNjtcbiAgYSA9IDUwMCAqICh4IC0geSk7XG4gIGIgPSAyMDAgKiAoeSAtIHopO1xuXG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIHJnYjJsY2goYXJncykge1xuICByZXR1cm4gbGFiMmxjaChyZ2IybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMnJnYihoc2wpIHtcbiAgdmFyIGggPSBoc2xbMF0gLyAzNjAsXG4gICAgICBzID0gaHNsWzFdIC8gMTAwLFxuICAgICAgbCA9IGhzbFsyXSAvIDEwMCxcbiAgICAgIHQxLCB0MiwgdDMsIHJnYiwgdmFsO1xuXG4gIGlmIChzID09IDApIHtcbiAgICB2YWwgPSBsICogMjU1O1xuICAgIHJldHVybiBbdmFsLCB2YWwsIHZhbF07XG4gIH1cblxuICBpZiAobCA8IDAuNSlcbiAgICB0MiA9IGwgKiAoMSArIHMpO1xuICBlbHNlXG4gICAgdDIgPSBsICsgcyAtIGwgKiBzO1xuICB0MSA9IDIgKiBsIC0gdDI7XG5cbiAgcmdiID0gWzAsIDAsIDBdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHQzID0gaCArIDEgLyAzICogLSAoaSAtIDEpO1xuICAgIHQzIDwgMCAmJiB0MysrO1xuICAgIHQzID4gMSAmJiB0My0tO1xuXG4gICAgaWYgKDYgKiB0MyA8IDEpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqIDYgKiB0MztcbiAgICBlbHNlIGlmICgyICogdDMgPCAxKVxuICAgICAgdmFsID0gdDI7XG4gICAgZWxzZSBpZiAoMyAqIHQzIDwgMilcbiAgICAgIHZhbCA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNjtcbiAgICBlbHNlXG4gICAgICB2YWwgPSB0MTtcblxuICAgIHJnYltpXSA9IHZhbCAqIDI1NTtcbiAgfVxuXG4gIHJldHVybiByZ2I7XG59XG5cbmZ1bmN0aW9uIGhzbDJoc3YoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICBzdiwgdjtcblxuICBpZihsID09PSAwKSB7XG4gICAgICAvLyBubyBuZWVkIHRvIGRvIGNhbGMgb24gYmxhY2tcbiAgICAgIC8vIGFsc28gYXZvaWRzIGRpdmlkZSBieSAwIGVycm9yXG4gICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICB9XG5cbiAgbCAqPSAyO1xuICBzICo9IChsIDw9IDEpID8gbCA6IDIgLSBsO1xuICB2ID0gKGwgKyBzKSAvIDI7XG4gIHN2ID0gKDIgKiBzKSAvIChsICsgcyk7XG4gIHJldHVybiBbaCwgc3YgKiAxMDAsIHYgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiBoc2wyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2IoaHNsMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChoc2wycmdiKGFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiBoc3YycmdiKGhzdikge1xuICB2YXIgaCA9IGhzdlswXSAvIDYwLFxuICAgICAgcyA9IGhzdlsxXSAvIDEwMCxcbiAgICAgIHYgPSBoc3ZbMl0gLyAxMDAsXG4gICAgICBoaSA9IE1hdGguZmxvb3IoaCkgJSA2O1xuXG4gIHZhciBmID0gaCAtIE1hdGguZmxvb3IoaCksXG4gICAgICBwID0gMjU1ICogdiAqICgxIC0gcyksXG4gICAgICBxID0gMjU1ICogdiAqICgxIC0gKHMgKiBmKSksXG4gICAgICB0ID0gMjU1ICogdiAqICgxIC0gKHMgKiAoMSAtIGYpKSksXG4gICAgICB2ID0gMjU1ICogdjtcblxuICBzd2l0Y2goaGkpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gW3YsIHQsIHBdO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBbcSwgdiwgcF07XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFtwLCB2LCB0XTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gW3AsIHEsIHZdO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBbdCwgcCwgdl07XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIFt2LCBwLCBxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoc3YyaHNsKGhzdikge1xuICB2YXIgaCA9IGhzdlswXSxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgc2wsIGw7XG5cbiAgbCA9ICgyIC0gcykgKiB2O1xuICBzbCA9IHMgKiB2O1xuICBzbCAvPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgc2wgPSBzbCB8fCAwO1xuICBsIC89IDI7XG4gIHJldHVybiBbaCwgc2wgKiAxMDAsIGwgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiBoc3YyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2IoaHN2MnJnYihhcmdzKSlcbn1cblxuZnVuY3Rpb24gaHN2MmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHN2MnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzdjJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGhzdjJyZ2IoYXJncykpO1xufVxuXG4vLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtY29sb3IvI2h3Yi10by1yZ2JcbmZ1bmN0aW9uIGh3YjJyZ2IoaHdiKSB7XG4gIHZhciBoID0gaHdiWzBdIC8gMzYwLFxuICAgICAgd2ggPSBod2JbMV0gLyAxMDAsXG4gICAgICBibCA9IGh3YlsyXSAvIDEwMCxcbiAgICAgIHJhdGlvID0gd2ggKyBibCxcbiAgICAgIGksIHYsIGYsIG47XG5cbiAgLy8gd2ggKyBibCBjYW50IGJlID4gMVxuICBpZiAocmF0aW8gPiAxKSB7XG4gICAgd2ggLz0gcmF0aW87XG4gICAgYmwgLz0gcmF0aW87XG4gIH1cblxuICBpID0gTWF0aC5mbG9vcig2ICogaCk7XG4gIHYgPSAxIC0gYmw7XG4gIGYgPSA2ICogaCAtIGk7XG4gIGlmICgoaSAmIDB4MDEpICE9IDApIHtcbiAgICBmID0gMSAtIGY7XG4gIH1cbiAgbiA9IHdoICsgZiAqICh2IC0gd2gpOyAgLy8gbGluZWFyIGludGVycG9sYXRpb25cblxuICBzd2l0Y2ggKGkpIHtcbiAgICBkZWZhdWx0OlxuICAgIGNhc2UgNjpcbiAgICBjYXNlIDA6IHIgPSB2OyBnID0gbjsgYiA9IHdoOyBicmVhaztcbiAgICBjYXNlIDE6IHIgPSBuOyBnID0gdjsgYiA9IHdoOyBicmVhaztcbiAgICBjYXNlIDI6IHIgPSB3aDsgZyA9IHY7IGIgPSBuOyBicmVhaztcbiAgICBjYXNlIDM6IHIgPSB3aDsgZyA9IG47IGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDQ6IHIgPSBuOyBnID0gd2g7IGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDU6IHIgPSB2OyBnID0gd2g7IGIgPSBuOyBicmVhaztcbiAgfVxuXG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIGh3YjJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmhzdihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHN2KGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2IyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsycmdiKGNteWspIHtcbiAgdmFyIGMgPSBjbXlrWzBdIC8gMTAwLFxuICAgICAgbSA9IGNteWtbMV0gLyAxMDAsXG4gICAgICB5ID0gY215a1syXSAvIDEwMCxcbiAgICAgIGsgPSBjbXlrWzNdIC8gMTAwLFxuICAgICAgciwgZywgYjtcblxuICByID0gMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgayk7XG4gIGcgPSAxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKTtcbiAgYiA9IDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspO1xuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiBjbXlrMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2IoY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoY215azJyZ2IoYXJncykpO1xufVxuXG5cbmZ1bmN0aW9uIHh5ejJyZ2IoeHl6KSB7XG4gIHZhciB4ID0geHl6WzBdIC8gMTAwLFxuICAgICAgeSA9IHh5elsxXSAvIDEwMCxcbiAgICAgIHogPSB4eXpbMl0gLyAxMDAsXG4gICAgICByLCBnLCBiO1xuXG4gIHIgPSAoeCAqIDMuMjQwNikgKyAoeSAqIC0xLjUzNzIpICsgKHogKiAtMC40OTg2KTtcbiAgZyA9ICh4ICogLTAuOTY4OSkgKyAoeSAqIDEuODc1OCkgKyAoeiAqIDAuMDQxNSk7XG4gIGIgPSAoeCAqIDAuMDU1NykgKyAoeSAqIC0wLjIwNDApICsgKHogKiAxLjA1NzApO1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KHIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiByID0gKHIgKiAxMi45Mik7XG5cbiAgZyA9IGcgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coZywgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IGcgPSAoZyAqIDEyLjkyKTtcblxuICBiID0gYiA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhiLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogYiA9IChiICogMTIuOTIpO1xuXG4gIHIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCByKSwgMSk7XG4gIGcgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBnKSwgMSk7XG4gIGIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBiKSwgMSk7XG5cbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24geHl6MmxhYih4eXopIHtcbiAgdmFyIHggPSB4eXpbMF0sXG4gICAgICB5ID0geHl6WzFdLFxuICAgICAgeiA9IHh5elsyXSxcbiAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiB4eXoybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2goeHl6MmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGxhYjJ4eXoobGFiKSB7XG4gIHZhciBsID0gbGFiWzBdLFxuICAgICAgYSA9IGxhYlsxXSxcbiAgICAgIGIgPSBsYWJbMl0sXG4gICAgICB4LCB5LCB6LCB5MjtcblxuICBpZiAobCA8PSA4KSB7XG4gICAgeSA9IChsICogMTAwKSAvIDkwMy4zO1xuICAgIHkyID0gKDcuNzg3ICogKHkgLyAxMDApKSArICgxNiAvIDExNik7XG4gIH0gZWxzZSB7XG4gICAgeSA9IDEwMCAqIE1hdGgucG93KChsICsgMTYpIC8gMTE2LCAzKTtcbiAgICB5MiA9IE1hdGgucG93KHkgLyAxMDAsIDEvMyk7XG4gIH1cblxuICB4ID0geCAvIDk1LjA0NyA8PSAwLjAwODg1NiA/IHggPSAoOTUuMDQ3ICogKChhIC8gNTAwKSArIHkyIC0gKDE2IC8gMTE2KSkpIC8gNy43ODcgOiA5NS4wNDcgKiBNYXRoLnBvdygoYSAvIDUwMCkgKyB5MiwgMyk7XG5cbiAgeiA9IHogLyAxMDguODgzIDw9IDAuMDA4ODU5ID8geiA9ICgxMDguODgzICogKHkyIC0gKGIgLyAyMDApIC0gKDE2IC8gMTE2KSkpIC8gNy43ODcgOiAxMDguODgzICogTWF0aC5wb3coeTIgLSAoYiAvIDIwMCksIDMpO1xuXG4gIHJldHVybiBbeCwgeSwgel07XG59XG5cbmZ1bmN0aW9uIGxhYjJsY2gobGFiKSB7XG4gIHZhciBsID0gbGFiWzBdLFxuICAgICAgYSA9IGxhYlsxXSxcbiAgICAgIGIgPSBsYWJbMl0sXG4gICAgICBociwgaCwgYztcblxuICBociA9IE1hdGguYXRhbjIoYiwgYSk7XG4gIGggPSBociAqIDM2MCAvIDIgLyBNYXRoLlBJO1xuICBpZiAoaCA8IDApIHtcbiAgICBoICs9IDM2MDtcbiAgfVxuICBjID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICByZXR1cm4gW2wsIGMsIGhdO1xufVxuXG5mdW5jdGlvbiBsYWIycmdiKGFyZ3MpIHtcbiAgcmV0dXJuIHh5ejJyZ2IobGFiMnh5eihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGxjaDJsYWIobGNoKSB7XG4gIHZhciBsID0gbGNoWzBdLFxuICAgICAgYyA9IGxjaFsxXSxcbiAgICAgIGggPSBsY2hbMl0sXG4gICAgICBhLCBiLCBocjtcblxuICBociA9IGggLyAzNjAgKiAyICogTWF0aC5QSTtcbiAgYSA9IGMgKiBNYXRoLmNvcyhocik7XG4gIGIgPSBjICogTWF0aC5zaW4oaHIpO1xuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiBsY2gyeHl6KGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJ4eXoobGNoMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGxjaDJyZ2IoYXJncykge1xuICByZXR1cm4gbGFiMnJnYihsY2gybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJyZ2Ioa2V5d29yZCkge1xuICByZXR1cm4gY3NzS2V5d29yZHNba2V5d29yZF07XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmhzdihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHN2KGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3YihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQybGFiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJsYWIoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMnh5eihhcmdzKSB7XG4gIHJldHVybiByZ2IyeHl6KGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxudmFyIGNzc0tleXdvcmRzID0ge1xuICBhbGljZWJsdWU6ICBbMjQwLDI0OCwyNTVdLFxuICBhbnRpcXVld2hpdGU6IFsyNTAsMjM1LDIxNV0sXG4gIGFxdWE6IFswLDI1NSwyNTVdLFxuICBhcXVhbWFyaW5lOiBbMTI3LDI1NSwyMTJdLFxuICBhenVyZTogIFsyNDAsMjU1LDI1NV0sXG4gIGJlaWdlOiAgWzI0NSwyNDUsMjIwXSxcbiAgYmlzcXVlOiBbMjU1LDIyOCwxOTZdLFxuICBibGFjazogIFswLDAsMF0sXG4gIGJsYW5jaGVkYWxtb25kOiBbMjU1LDIzNSwyMDVdLFxuICBibHVlOiBbMCwwLDI1NV0sXG4gIGJsdWV2aW9sZXQ6IFsxMzgsNDMsMjI2XSxcbiAgYnJvd246ICBbMTY1LDQyLDQyXSxcbiAgYnVybHl3b29kOiAgWzIyMiwxODQsMTM1XSxcbiAgY2FkZXRibHVlOiAgWzk1LDE1OCwxNjBdLFxuICBjaGFydHJldXNlOiBbMTI3LDI1NSwwXSxcbiAgY2hvY29sYXRlOiAgWzIxMCwxMDUsMzBdLFxuICBjb3JhbDogIFsyNTUsMTI3LDgwXSxcbiAgY29ybmZsb3dlcmJsdWU6IFsxMDAsMTQ5LDIzN10sXG4gIGNvcm5zaWxrOiBbMjU1LDI0OCwyMjBdLFxuICBjcmltc29uOiAgWzIyMCwyMCw2MF0sXG4gIGN5YW46IFswLDI1NSwyNTVdLFxuICBkYXJrYmx1ZTogWzAsMCwxMzldLFxuICBkYXJrY3lhbjogWzAsMTM5LDEzOV0sXG4gIGRhcmtnb2xkZW5yb2Q6ICBbMTg0LDEzNCwxMV0sXG4gIGRhcmtncmF5OiBbMTY5LDE2OSwxNjldLFxuICBkYXJrZ3JlZW46ICBbMCwxMDAsMF0sXG4gIGRhcmtncmV5OiBbMTY5LDE2OSwxNjldLFxuICBkYXJra2hha2k6ICBbMTg5LDE4MywxMDddLFxuICBkYXJrbWFnZW50YTogIFsxMzksMCwxMzldLFxuICBkYXJrb2xpdmVncmVlbjogWzg1LDEwNyw0N10sXG4gIGRhcmtvcmFuZ2U6IFsyNTUsMTQwLDBdLFxuICBkYXJrb3JjaGlkOiBbMTUzLDUwLDIwNF0sXG4gIGRhcmtyZWQ6ICBbMTM5LDAsMF0sXG4gIGRhcmtzYWxtb246IFsyMzMsMTUwLDEyMl0sXG4gIGRhcmtzZWFncmVlbjogWzE0MywxODgsMTQzXSxcbiAgZGFya3NsYXRlYmx1ZTogIFs3Miw2MSwxMzldLFxuICBkYXJrc2xhdGVncmF5OiAgWzQ3LDc5LDc5XSxcbiAgZGFya3NsYXRlZ3JleTogIFs0Nyw3OSw3OV0sXG4gIGRhcmt0dXJxdW9pc2U6ICBbMCwyMDYsMjA5XSxcbiAgZGFya3Zpb2xldDogWzE0OCwwLDIxMV0sXG4gIGRlZXBwaW5rOiBbMjU1LDIwLDE0N10sXG4gIGRlZXBza3libHVlOiAgWzAsMTkxLDI1NV0sXG4gIGRpbWdyYXk6ICBbMTA1LDEwNSwxMDVdLFxuICBkaW1ncmV5OiAgWzEwNSwxMDUsMTA1XSxcbiAgZG9kZ2VyYmx1ZTogWzMwLDE0NCwyNTVdLFxuICBmaXJlYnJpY2s6ICBbMTc4LDM0LDM0XSxcbiAgZmxvcmFsd2hpdGU6ICBbMjU1LDI1MCwyNDBdLFxuICBmb3Jlc3RncmVlbjogIFszNCwxMzksMzRdLFxuICBmdWNoc2lhOiAgWzI1NSwwLDI1NV0sXG4gIGdhaW5zYm9ybzogIFsyMjAsMjIwLDIyMF0sXG4gIGdob3N0d2hpdGU6IFsyNDgsMjQ4LDI1NV0sXG4gIGdvbGQ6IFsyNTUsMjE1LDBdLFxuICBnb2xkZW5yb2Q6ICBbMjE4LDE2NSwzMl0sXG4gIGdyYXk6IFsxMjgsMTI4LDEyOF0sXG4gIGdyZWVuOiAgWzAsMTI4LDBdLFxuICBncmVlbnllbGxvdzogIFsxNzMsMjU1LDQ3XSxcbiAgZ3JleTogWzEyOCwxMjgsMTI4XSxcbiAgaG9uZXlkZXc6IFsyNDAsMjU1LDI0MF0sXG4gIGhvdHBpbms6ICBbMjU1LDEwNSwxODBdLFxuICBpbmRpYW5yZWQ6ICBbMjA1LDkyLDkyXSxcbiAgaW5kaWdvOiBbNzUsMCwxMzBdLFxuICBpdm9yeTogIFsyNTUsMjU1LDI0MF0sXG4gIGtoYWtpOiAgWzI0MCwyMzAsMTQwXSxcbiAgbGF2ZW5kZXI6IFsyMzAsMjMwLDI1MF0sXG4gIGxhdmVuZGVyYmx1c2g6ICBbMjU1LDI0MCwyNDVdLFxuICBsYXduZ3JlZW46ICBbMTI0LDI1MiwwXSxcbiAgbGVtb25jaGlmZm9uOiBbMjU1LDI1MCwyMDVdLFxuICBsaWdodGJsdWU6ICBbMTczLDIxNiwyMzBdLFxuICBsaWdodGNvcmFsOiBbMjQwLDEyOCwxMjhdLFxuICBsaWdodGN5YW46ICBbMjI0LDI1NSwyNTVdLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwyNTAsMjEwXSxcbiAgbGlnaHRncmF5OiAgWzIxMSwyMTEsMjExXSxcbiAgbGlnaHRncmVlbjogWzE0NCwyMzgsMTQ0XSxcbiAgbGlnaHRncmV5OiAgWzIxMSwyMTEsMjExXSxcbiAgbGlnaHRwaW5rOiAgWzI1NSwxODIsMTkzXSxcbiAgbGlnaHRzYWxtb246ICBbMjU1LDE2MCwxMjJdLFxuICBsaWdodHNlYWdyZWVuOiAgWzMyLDE3OCwxNzBdLFxuICBsaWdodHNreWJsdWU6IFsxMzUsMjA2LDI1MF0sXG4gIGxpZ2h0c2xhdGVncmF5OiBbMTE5LDEzNiwxNTNdLFxuICBsaWdodHNsYXRlZ3JleTogWzExOSwxMzYsMTUzXSxcbiAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsMTk2LDIyMl0sXG4gIGxpZ2h0eWVsbG93OiAgWzI1NSwyNTUsMjI0XSxcbiAgbGltZTogWzAsMjU1LDBdLFxuICBsaW1lZ3JlZW46ICBbNTAsMjA1LDUwXSxcbiAgbGluZW46ICBbMjUwLDI0MCwyMzBdLFxuICBtYWdlbnRhOiAgWzI1NSwwLDI1NV0sXG4gIG1hcm9vbjogWzEyOCwwLDBdLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBbMTAyLDIwNSwxNzBdLFxuICBtZWRpdW1ibHVlOiBbMCwwLDIwNV0sXG4gIG1lZGl1bW9yY2hpZDogWzE4Niw4NSwyMTFdLFxuICBtZWRpdW1wdXJwbGU6IFsxNDcsMTEyLDIxOV0sXG4gIG1lZGl1bXNlYWdyZWVuOiBbNjAsMTc5LDExM10sXG4gIG1lZGl1bXNsYXRlYmx1ZTogIFsxMjMsMTA0LDIzOF0sXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAgWzAsMjUwLDE1NF0sXG4gIG1lZGl1bXR1cnF1b2lzZTogIFs3MiwyMDksMjA0XSxcbiAgbWVkaXVtdmlvbGV0cmVkOiAgWzE5OSwyMSwxMzNdLFxuICBtaWRuaWdodGJsdWU6IFsyNSwyNSwxMTJdLFxuICBtaW50Y3JlYW06ICBbMjQ1LDI1NSwyNTBdLFxuICBtaXN0eXJvc2U6ICBbMjU1LDIyOCwyMjVdLFxuICBtb2NjYXNpbjogWzI1NSwyMjgsMTgxXSxcbiAgbmF2YWpvd2hpdGU6ICBbMjU1LDIyMiwxNzNdLFxuICBuYXZ5OiBbMCwwLDEyOF0sXG4gIG9sZGxhY2U6ICBbMjUzLDI0NSwyMzBdLFxuICBvbGl2ZTogIFsxMjgsMTI4LDBdLFxuICBvbGl2ZWRyYWI6ICBbMTA3LDE0MiwzNV0sXG4gIG9yYW5nZTogWzI1NSwxNjUsMF0sXG4gIG9yYW5nZXJlZDogIFsyNTUsNjksMF0sXG4gIG9yY2hpZDogWzIxOCwxMTIsMjE0XSxcbiAgcGFsZWdvbGRlbnJvZDogIFsyMzgsMjMyLDE3MF0sXG4gIHBhbGVncmVlbjogIFsxNTIsMjUxLDE1Ml0sXG4gIHBhbGV0dXJxdW9pc2U6ICBbMTc1LDIzOCwyMzhdLFxuICBwYWxldmlvbGV0cmVkOiAgWzIxOSwxMTIsMTQ3XSxcbiAgcGFwYXlhd2hpcDogWzI1NSwyMzksMjEzXSxcbiAgcGVhY2hwdWZmOiAgWzI1NSwyMTgsMTg1XSxcbiAgcGVydTogWzIwNSwxMzMsNjNdLFxuICBwaW5rOiBbMjU1LDE5MiwyMDNdLFxuICBwbHVtOiBbMjIxLDE2MCwyMjFdLFxuICBwb3dkZXJibHVlOiBbMTc2LDIyNCwyMzBdLFxuICBwdXJwbGU6IFsxMjgsMCwxMjhdLFxuICByZWJlY2NhcHVycGxlOiBbMTAyLCA1MSwgMTUzXSxcbiAgcmVkOiAgWzI1NSwwLDBdLFxuICByb3N5YnJvd246ICBbMTg4LDE0MywxNDNdLFxuICByb3lhbGJsdWU6ICBbNjUsMTA1LDIyNV0sXG4gIHNhZGRsZWJyb3duOiAgWzEzOSw2OSwxOV0sXG4gIHNhbG1vbjogWzI1MCwxMjgsMTE0XSxcbiAgc2FuZHlicm93bjogWzI0NCwxNjQsOTZdLFxuICBzZWFncmVlbjogWzQ2LDEzOSw4N10sXG4gIHNlYXNoZWxsOiBbMjU1LDI0NSwyMzhdLFxuICBzaWVubmE6IFsxNjAsODIsNDVdLFxuICBzaWx2ZXI6IFsxOTIsMTkyLDE5Ml0sXG4gIHNreWJsdWU6ICBbMTM1LDIwNiwyMzVdLFxuICBzbGF0ZWJsdWU6ICBbMTA2LDkwLDIwNV0sXG4gIHNsYXRlZ3JheTogIFsxMTIsMTI4LDE0NF0sXG4gIHNsYXRlZ3JleTogIFsxMTIsMTI4LDE0NF0sXG4gIHNub3c6IFsyNTUsMjUwLDI1MF0sXG4gIHNwcmluZ2dyZWVuOiAgWzAsMjU1LDEyN10sXG4gIHN0ZWVsYmx1ZTogIFs3MCwxMzAsMTgwXSxcbiAgdGFuOiAgWzIxMCwxODAsMTQwXSxcbiAgdGVhbDogWzAsMTI4LDEyOF0sXG4gIHRoaXN0bGU6ICBbMjE2LDE5MSwyMTZdLFxuICB0b21hdG86IFsyNTUsOTksNzFdLFxuICB0dXJxdW9pc2U6ICBbNjQsMjI0LDIwOF0sXG4gIHZpb2xldDogWzIzOCwxMzAsMjM4XSxcbiAgd2hlYXQ6ICBbMjQ1LDIyMiwxNzldLFxuICB3aGl0ZTogIFsyNTUsMjU1LDI1NV0sXG4gIHdoaXRlc21va2U6IFsyNDUsMjQ1LDI0NV0sXG4gIHllbGxvdzogWzI1NSwyNTUsMF0sXG4gIHllbGxvd2dyZWVuOiAgWzE1NCwyMDUsNTBdXG59O1xuXG52YXIgcmV2ZXJzZUtleXdvcmRzID0ge307XG5mb3IgKHZhciBrZXkgaW4gY3NzS2V5d29yZHMpIHtcbiAgcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KGNzc0tleXdvcmRzW2tleV0pXSA9IGtleTtcbn1cblxudmFyIGNvbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBuZXcgQ29udmVydGVyKCk7XG59O1xuXG5mb3IgKHZhciBmdW5jIGluIGNvbnZlcnNpb25zKSB7XG4gIC8vIGV4cG9ydCBSYXcgdmVyc2lvbnNcbiAgY29udmVydFtmdW5jICsgXCJSYXdcIl0gPSAgKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBhY2NlcHQgYXJyYXkgb3IgcGxhaW4gYXJnc1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09IFwibnVtYmVyXCIpXG4gICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY29udmVyc2lvbnNbZnVuY10oYXJnKTtcbiAgICB9XG4gIH0pKGZ1bmMpO1xuXG4gIHZhciBwYWlyID0gLyhcXHcrKTIoXFx3KykvLmV4ZWMoZnVuYyksXG4gICAgICBmcm9tID0gcGFpclsxXSxcbiAgICAgIHRvID0gcGFpclsyXTtcblxuICAvLyBleHBvcnQgcmdiMmhzbCBhbmQgW1wicmdiXCJdW1wiaHNsXCJdXG4gIGNvbnZlcnRbZnJvbV0gPSBjb252ZXJ0W2Zyb21dIHx8IHt9O1xuXG4gIGNvbnZlcnRbZnJvbV1bdG9dID0gY29udmVydFtmdW5jXSA9IChmdW5jdGlvbihmdW5jKSB7IFxuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09IFwibnVtYmVyXCIpXG4gICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBcbiAgICAgIHZhciB2YWwgPSBjb252ZXJzaW9uc1tmdW5jXShhcmcpO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIiB8fCB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHZhbDsgLy8ga2V5d29yZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgdmFsW2ldID0gTWF0aC5yb3VuZCh2YWxbaV0pO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH0pKGZ1bmMpO1xufVxuXG5cbi8qIENvbnZlcnRlciBkb2VzIGxhenkgY29udmVyc2lvbiBhbmQgY2FjaGluZyAqL1xudmFyIENvbnZlcnRlciA9IGZ1bmN0aW9uKCkge1xuICAgdGhpcy5jb252cyA9IHt9O1xufTtcblxuLyogRWl0aGVyIGdldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlIG9yXG4gIHNldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLCBkZXBlbmRpbmcgb24gYXJncyAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5yb3V0ZVNwYWNlID0gZnVuY3Rpb24oc3BhY2UsIGFyZ3MpIHtcbiAgIHZhciB2YWx1ZXMgPSBhcmdzWzBdO1xuICAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjb2xvci5yZ2IoKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcbiAgIH1cbiAgIC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT0gXCJudW1iZXJcIikge1xuICAgICAgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7ICAgICAgICBcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuc2V0VmFsdWVzKHNwYWNlLCB2YWx1ZXMpO1xufTtcbiAgXG4vKiBTZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSwgaW52YWxpZGF0aW5nIGNhY2hlICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlLCB2YWx1ZXMpIHtcbiAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgIHRoaXMuY29udnMgPSB7fTtcbiAgIHRoaXMuY29udnNbc3BhY2VdID0gdmFsdWVzO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiBHZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZS4gSWYgdGhlcmUncyBhbHJlYWR5XG4gIGEgY29udmVyc2lvbiBmb3IgdGhlIHNwYWNlLCBmZXRjaCBpdCwgb3RoZXJ3aXNlXG4gIGNvbXB1dGUgaXQgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24oc3BhY2UpIHtcbiAgIHZhciB2YWxzID0gdGhpcy5jb252c1tzcGFjZV07XG4gICBpZiAoIXZhbHMpIHtcbiAgICAgIHZhciBmc3BhY2UgPSB0aGlzLnNwYWNlLFxuICAgICAgICAgIGZyb20gPSB0aGlzLmNvbnZzW2ZzcGFjZV07XG4gICAgICB2YWxzID0gY29udmVydFtmc3BhY2VdW3NwYWNlXShmcm9tKTtcblxuICAgICAgdGhpcy5jb252c1tzcGFjZV0gPSB2YWxzO1xuICAgfVxuICByZXR1cm4gdmFscztcbn07XG5cbltcInJnYlwiLCBcImhzbFwiLCBcImhzdlwiLCBcImNteWtcIiwgXCJrZXl3b3JkXCJdLmZvckVhY2goZnVuY3Rpb24oc3BhY2UpIHtcbiAgIENvbnZlcnRlci5wcm90b3R5cGVbc3BhY2VdID0gZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMucm91dGVTcGFjZShzcGFjZSwgYXJndW1lbnRzKTtcbiAgIH07XG59KTtcblxudmFyIGNvbG9yQ29udmVydCA9IGNvbnZlcnQ7XG5cbnZhciBjb2xvck5hbWUgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59O1xuXG4vKiBNSVQgbGljZW5zZSAqL1xuXG5cbnZhciBjb2xvclN0cmluZyA9IHtcbiAgIGdldFJnYmE6IGdldFJnYmEsXG4gICBnZXRIc2xhOiBnZXRIc2xhLFxuICAgZ2V0UmdiOiBnZXRSZ2IsXG4gICBnZXRIc2w6IGdldEhzbCxcbiAgIGdldEh3YjogZ2V0SHdiLFxuICAgZ2V0QWxwaGE6IGdldEFscGhhLFxuXG4gICBoZXhTdHJpbmc6IGhleFN0cmluZyxcbiAgIHJnYlN0cmluZzogcmdiU3RyaW5nLFxuICAgcmdiYVN0cmluZzogcmdiYVN0cmluZyxcbiAgIHBlcmNlbnRTdHJpbmc6IHBlcmNlbnRTdHJpbmcsXG4gICBwZXJjZW50YVN0cmluZzogcGVyY2VudGFTdHJpbmcsXG4gICBoc2xTdHJpbmc6IGhzbFN0cmluZyxcbiAgIGhzbGFTdHJpbmc6IGhzbGFTdHJpbmcsXG4gICBod2JTdHJpbmc6IGh3YlN0cmluZyxcbiAgIGtleXdvcmQ6IGtleXdvcmRcbn07XG5cbmZ1bmN0aW9uIGdldFJnYmEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGFiYnIgPSAgL14jKFthLWZBLUYwLTldezMsNH0pJC9pLFxuICAgICAgIGhleCA9ICAvXiMoW2EtZkEtRjAtOV17Nn0oW2EtZkEtRjAtOV17Mn0pPykkL2ksXG4gICAgICAgcmdiYSA9IC9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyosXFxzKihbKy1dP1xcZCspXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvaSxcbiAgICAgICBwZXIgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkL2ksXG4gICAgICAga2V5d29yZCA9IC8oXFx3KykvO1xuXG4gICB2YXIgcmdiID0gWzAsIDAsIDBdLFxuICAgICAgIGEgPSAxLFxuICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKGFiYnIpLFxuICAgICAgIGhleEFscGhhID0gXCJcIjtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGhleEFscGhhID0gbWF0Y2hbM107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaV0gKyBtYXRjaFtpXSwgMTYpO1xuICAgICAgfVxuICAgICAgaWYgKGhleEFscGhhKSB7XG4gICAgICAgICBhID0gTWF0aC5yb3VuZCgocGFyc2VJbnQoaGV4QWxwaGEgKyBoZXhBbHBoYSwgMTYpIC8gMjU1KSAqIDEwMCkgLyAxMDA7XG4gICAgICB9XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChoZXgpKSB7XG4gICAgICBoZXhBbHBoYSA9IG1hdGNoWzJdO1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaC5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgICAgaWYgKGhleEFscGhhKSB7XG4gICAgICAgICBhID0gTWF0aC5yb3VuZCgocGFyc2VJbnQoaGV4QWxwaGEsIDE2KSAvIDI1NSkgKiAxMDApIC8gMTAwO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0pO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChtYXRjaFtpICsgMV0pICogMi41NSk7XG4gICAgICB9XG4gICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChrZXl3b3JkKSkge1xuICAgICAgaWYgKG1hdGNoWzFdID09IFwidHJhbnNwYXJlbnRcIikge1xuICAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICAgIHJnYiA9IGNvbG9yTmFtZVttYXRjaFsxXV07XG4gICAgICBpZiAoIXJnYikge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgfVxuXG4gICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgcmdiW2ldID0gc2NhbGUocmdiW2ldLCAwLCAyNTUpO1xuICAgfVxuICAgaWYgKCFhICYmIGEgIT0gMCkge1xuICAgICAgYSA9IDE7XG4gICB9XG4gICBlbHNlIHtcbiAgICAgIGEgPSBzY2FsZShhLCAwLCAxKTtcbiAgIH1cbiAgIHJnYlszXSA9IGE7XG4gICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBnZXRIc2xhKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBoc2wgPSAvXmhzbGE/XFwoXFxzKihbKy1dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHNsKTtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICBzID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgbCA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuICAgICAgcmV0dXJuIFtoLCBzLCBsLCBhXTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0SHdiKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBod2IgPSAvXmh3YlxcKFxccyooWystXT9cXGQrKSg/OmRlZyk/XFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkvO1xuICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGh3Yik7XG4gICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgICAgIHZhciBoID0gc2NhbGUocGFyc2VJbnQobWF0Y2hbMV0pLCAwLCAzNjApLFxuICAgICAgICAgIHcgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKSxcbiAgICAgICAgICBiID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCksXG4gICAgICAgICAgYSA9IHNjYWxlKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHcsIGIsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZ2Ioc3RyaW5nKSB7XG4gICB2YXIgcmdiYSA9IGdldFJnYmEoc3RyaW5nKTtcbiAgIHJldHVybiByZ2JhICYmIHJnYmEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEhzbChzdHJpbmcpIHtcbiAgdmFyIGhzbGEgPSBnZXRIc2xhKHN0cmluZyk7XG4gIHJldHVybiBoc2xhICYmIGhzbGEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEFscGhhKHN0cmluZykge1xuICAgdmFyIHZhbHMgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICBpZiAodmFscykge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHNsYShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRId2Ioc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG59XG5cbi8vIGdlbmVyYXRvcnNcbmZ1bmN0aW9uIGhleFN0cmluZyhyZ2JhLCBhKSB7XG4gICB2YXIgYSA9IChhICE9PSB1bmRlZmluZWQgJiYgcmdiYS5sZW5ndGggPT09IDMpID8gYSA6IHJnYmFbM107XG4gICByZXR1cm4gXCIjXCIgKyBoZXhEb3VibGUocmdiYVswXSkgXG4gICAgICAgICAgICAgICsgaGV4RG91YmxlKHJnYmFbMV0pXG4gICAgICAgICAgICAgICsgaGV4RG91YmxlKHJnYmFbMl0pXG4gICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAoYSA+PSAwICYmIGEgPCAxKVxuICAgICAgICAgICAgICAgICA/IGhleERvdWJsZShNYXRoLnJvdW5kKGEgKiAyNTUpKVxuICAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgICAgKTtcbn1cblxuZnVuY3Rpb24gcmdiU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChyZ2JhWzNdICE9PSB1bmRlZmluZWQgPyByZ2JhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdXG4gICAgICAgICAgICsgXCIsIFwiICsgYWxwaGEgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudFN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSk7XG4gICB9XG4gICB2YXIgciA9IE1hdGgucm91bmQocmdiYVswXS8yNTUgKiAxMDApLFxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XG5cbiAgIHJldHVybiBcInJnYihcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuICAgcmV0dXJuIFwicmdiYShcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlLCBcIiArIChhbHBoYSB8fCByZ2JhWzNdIHx8IDEpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbFN0cmluZyhoc2xhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAoaHNsYVszXSAmJiBoc2xhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcImhzbChcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbGFTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChoc2xhWzNdICE9PSB1bmRlZmluZWQgPyBoc2xhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2xhKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSwgXCJcbiAgICAgICAgICAgKyBhbHBoYSArIFwiKVwiO1xufVxuXG4vLyBod2IgaXMgYSBiaXQgZGlmZmVyZW50IHRoYW4gcmdiKGEpICYgaHNsKGEpIHNpbmNlIHRoZXJlIGlzIG5vIGFscGhhIHNwZWNpZmljIHN5bnRheFxuLy8gKGh3YiBoYXZlIGFscGhhIG9wdGlvbmFsICYgMSBpcyBkZWZhdWx0IHZhbHVlKVxuZnVuY3Rpb24gaHdiU3RyaW5nKGh3YiwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChod2JbM10gIT09IHVuZGVmaW5lZCA/IGh3YlszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHdiKFwiICsgaHdiWzBdICsgXCIsIFwiICsgaHdiWzFdICsgXCIlLCBcIiArIGh3YlsyXSArIFwiJVwiXG4gICAgICAgICAgICsgKGFscGhhICE9PSB1bmRlZmluZWQgJiYgYWxwaGEgIT09IDEgPyBcIiwgXCIgKyBhbHBoYSA6IFwiXCIpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQocmdiKSB7XG4gIHJldHVybiByZXZlcnNlTmFtZXNbcmdiLnNsaWNlKDAsIDMpXTtcbn1cblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gc2NhbGUobnVtLCBtaW4sIG1heCkge1xuICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgbnVtKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gaGV4RG91YmxlKG51bSkge1xuICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICByZXR1cm4gKHN0ci5sZW5ndGggPCAyKSA/IFwiMFwiICsgc3RyIDogc3RyO1xufVxuXG5cbi8vY3JlYXRlIGEgbGlzdCBvZiByZXZlcnNlIGNvbG9yIG5hbWVzXG52YXIgcmV2ZXJzZU5hbWVzID0ge307XG5mb3IgKHZhciBuYW1lIGluIGNvbG9yTmFtZSkge1xuICAgcmV2ZXJzZU5hbWVzW2NvbG9yTmFtZVtuYW1lXV0gPSBuYW1lO1xufVxuXG4vKiBNSVQgbGljZW5zZSAqL1xuXG5cblxudmFyIENvbG9yID0gZnVuY3Rpb24gKG9iaikge1xuXHRpZiAob2JqIGluc3RhbmNlb2YgQ29sb3IpIHtcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2xvcikpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKG9iaik7XG5cdH1cblxuXHR0aGlzLnZhbGlkID0gZmFsc2U7XG5cdHRoaXMudmFsdWVzID0ge1xuXHRcdHJnYjogWzAsIDAsIDBdLFxuXHRcdGhzbDogWzAsIDAsIDBdLFxuXHRcdGhzdjogWzAsIDAsIDBdLFxuXHRcdGh3YjogWzAsIDAsIDBdLFxuXHRcdGNteWs6IFswLCAwLCAwLCAwXSxcblx0XHRhbHBoYTogMVxuXHR9O1xuXG5cdC8vIHBhcnNlIENvbG9yKCkgYXJndW1lbnRcblx0dmFyIHZhbHM7XG5cdGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHRcdHZhbHMgPSBjb2xvclN0cmluZy5nZXRSZ2JhKG9iaik7XG5cdFx0aWYgKHZhbHMpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMgPSBjb2xvclN0cmluZy5nZXRIc2xhKG9iaikpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMgPSBjb2xvclN0cmluZy5nZXRId2Iob2JqKSkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIHZhbHMpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuXHRcdHZhbHMgPSBvYmo7XG5cdFx0aWYgKHZhbHMuciAhPT0gdW5kZWZpbmVkIHx8IHZhbHMucmVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMubCAhPT0gdW5kZWZpbmVkIHx8IHZhbHMubGlnaHRuZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMudiAhPT0gdW5kZWZpbmVkIHx8IHZhbHMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzdicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy53ICE9PSB1bmRlZmluZWQgfHwgdmFscy53aGl0ZW5lc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy5jICE9PSB1bmRlZmluZWQgfHwgdmFscy5jeWFuICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdjbXlrJywgdmFscyk7XG5cdFx0fVxuXHR9XG59O1xuXG5Db2xvci5wcm90b3R5cGUgPSB7XG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWxpZDtcblx0fSxcblx0cmdiOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ3JnYicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGhzbDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdoc2wnLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRoc3Y6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHN2JywgYXJndW1lbnRzKTtcblx0fSxcblx0aHdiOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2h3YicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGNteWs6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnY215aycsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0cmdiQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMucmdiO1xuXHR9LFxuXHRoc2xBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5oc2w7XG5cdH0sXG5cdGhzdkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmhzdjtcblx0fSxcblx0aHdiQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0aWYgKHZhbHVlcy5hbHBoYSAhPT0gMSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlcy5od2IuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlcy5od2I7XG5cdH0sXG5cdGNteWtBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5jbXlrO1xuXHR9LFxuXHRyZ2JhQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0cmV0dXJuIHZhbHVlcy5yZ2IuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0fSxcblx0aHNsYUFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXMuaHNsLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdH0sXG5cdGFscGhhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0fVxuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIHZhbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVkOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMCwgdmFsKTtcblx0fSxcblx0Z3JlZW46IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdyZ2InLCAxLCB2YWwpO1xuXHR9LFxuXHRibHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMiwgdmFsKTtcblx0fSxcblx0aHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKHZhbCkge1xuXHRcdFx0dmFsICU9IDM2MDtcblx0XHRcdHZhbCA9IHZhbCA8IDAgPyAzNjAgKyB2YWwgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzbCcsIDAsIHZhbCk7XG5cdH0sXG5cdHNhdHVyYXRpb246IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAxLCB2YWwpO1xuXHR9LFxuXHRsaWdodG5lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAyLCB2YWwpO1xuXHR9LFxuXHRzYXR1cmF0aW9udjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzdicsIDEsIHZhbCk7XG5cdH0sXG5cdHdoaXRlbmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2h3YicsIDEsIHZhbCk7XG5cdH0sXG5cdGJsYWNrbmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2h3YicsIDIsIHZhbCk7XG5cdH0sXG5cdHZhbHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHN2JywgMiwgdmFsKTtcblx0fSxcblx0Y3lhbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAwLCB2YWwpO1xuXHR9LFxuXHRtYWdlbnRhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDEsIHZhbCk7XG5cdH0sXG5cdHllbGxvdzogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAyLCB2YWwpO1xuXHR9LFxuXHRibGFjazogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAzLCB2YWwpO1xuXHR9LFxuXG5cdGhleFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5oZXhTdHJpbmcodGhpcy52YWx1ZXMucmdiKTtcblx0fSxcblx0cmdiU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnJnYlN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0cmdiYVN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5yZ2JhU3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRwZXJjZW50U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnBlcmNlbnRTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGhzbFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5oc2xTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGhzbGFTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaHNsYVN0cmluZyh0aGlzLnZhbHVlcy5oc2wsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0aHdiU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmh3YlN0cmluZyh0aGlzLnZhbHVlcy5od2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0a2V5d29yZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5rZXl3b3JkKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXG5cdHJnYk51bWJlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0cmV0dXJuIChyZ2JbMF0gPDwgMTYpIHwgKHJnYlsxXSA8PCA4KSB8IHJnYlsyXTtcblx0fSxcblxuXHRsdW1pbm9zaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0dmFyIGx1bSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hhbiA9IHJnYltpXSAvIDI1NTtcblx0XHRcdGx1bVtpXSA9IChjaGFuIDw9IDAuMDM5MjgpID8gY2hhbiAvIDEyLjkyIDogTWF0aC5wb3coKChjaGFuICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC4yMTI2ICogbHVtWzBdICsgMC43MTUyICogbHVtWzFdICsgMC4wNzIyICogbHVtWzJdO1xuXHR9LFxuXG5cdGNvbnRyYXN0OiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZlxuXHRcdHZhciBsdW0xID0gdGhpcy5sdW1pbm9zaXR5KCk7XG5cdFx0dmFyIGx1bTIgPSBjb2xvcjIubHVtaW5vc2l0eSgpO1xuXHRcdGlmIChsdW0xID4gbHVtMikge1xuXHRcdFx0cmV0dXJuIChsdW0xICsgMC4wNSkgLyAobHVtMiArIDAuMDUpO1xuXHRcdH1cblx0XHRyZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG5cdH0sXG5cblx0bGV2ZWw6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHR2YXIgY29udHJhc3RSYXRpbyA9IHRoaXMuY29udHJhc3QoY29sb3IyKTtcblx0XHRpZiAoY29udHJhc3RSYXRpbyA+PSA3LjEpIHtcblx0XHRcdHJldHVybiAnQUFBJztcblx0XHR9XG5cblx0XHRyZXR1cm4gKGNvbnRyYXN0UmF0aW8gPj0gNC41KSA/ICdBQScgOiAnJztcblx0fSxcblxuXHRkYXJrOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gWUlRIGVxdWF0aW9uIGZyb20gaHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0dmFyIHlpcSA9IChyZ2JbMF0gKiAyOTkgKyByZ2JbMV0gKiA1ODcgKyByZ2JbMl0gKiAxMTQpIC8gMTAwMDtcblx0XHRyZXR1cm4geWlxIDwgMTI4O1xuXHR9LFxuXG5cdGxpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmRhcmsoKTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYltpXSA9IDI1NSAtIHRoaXMudmFsdWVzLnJnYltpXTtcblx0XHR9XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIHJnYik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0bGlnaHRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMl0gKz0gaHNsWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGFya2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsyXSAtPSBoc2xbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMV0gKz0gaHNsWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGVzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMV0gLT0gaHNsWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d2hpdGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy52YWx1ZXMuaHdiO1xuXHRcdGh3YlsxXSArPSBod2JbMV0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgaHdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRibGFja2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy52YWx1ZXMuaHdiO1xuXHRcdGh3YlsyXSArPSBod2JbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgaHdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRncmV5c2NhbGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JheXNjYWxlI0NvbnZlcnRpbmdfY29sb3JfdG9fZ3JheXNjYWxlXG5cdFx0dmFyIHZhbCA9IHJnYlswXSAqIDAuMyArIHJnYlsxXSAqIDAuNTkgKyByZ2JbMl0gKiAwLjExO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCBbdmFsLCB2YWwsIHZhbF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsZWFyZXI6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBhbHBoYSA9IHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIGFscGhhIC0gKGFscGhhICogcmF0aW8pKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvcGFxdWVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgYWxwaGEgPSB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCBhbHBoYSArIChhbHBoYSAqIHJhdGlvKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbiAoZGVncmVlcykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0dmFyIGh1ZSA9IChoc2xbMF0gKyBkZWdyZWVzKSAlIDM2MDtcblx0XHRoc2xbMF0gPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQb3J0ZWQgZnJvbSBzYXNzIGltcGxlbWVudGF0aW9uIGluIENcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL3Nhc3MvbGlic2Fzcy9ibG9iLzBlNmI0YTI4NTAwOTIzNTZhYTNlY2UwN2M2YjI0OWYwMjIxY2FjZWQvZnVuY3Rpb25zLmNwcCNMMjA5XG5cdCAqL1xuXHRtaXg6IGZ1bmN0aW9uIChtaXhpbkNvbG9yLCB3ZWlnaHQpIHtcblx0XHR2YXIgY29sb3IxID0gdGhpcztcblx0XHR2YXIgY29sb3IyID0gbWl4aW5Db2xvcjtcblx0XHR2YXIgcCA9IHdlaWdodCA9PT0gdW5kZWZpbmVkID8gMC41IDogd2VpZ2h0O1xuXG5cdFx0dmFyIHcgPSAyICogcCAtIDE7XG5cdFx0dmFyIGEgPSBjb2xvcjEuYWxwaGEoKSAtIGNvbG9yMi5hbHBoYSgpO1xuXG5cdFx0dmFyIHcxID0gKCgodyAqIGEgPT09IC0xKSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG5cdFx0dmFyIHcyID0gMSAtIHcxO1xuXG5cdFx0cmV0dXJuIHRoaXNcblx0XHRcdC5yZ2IoXG5cdFx0XHRcdHcxICogY29sb3IxLnJlZCgpICsgdzIgKiBjb2xvcjIucmVkKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmdyZWVuKCkgKyB3MiAqIGNvbG9yMi5ncmVlbigpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ibHVlKCkgKyB3MiAqIGNvbG9yMi5ibHVlKClcblx0XHRcdClcblx0XHRcdC5hbHBoYShjb2xvcjEuYWxwaGEoKSAqIHAgKyBjb2xvcjIuYWxwaGEoKSAqICgxIC0gcCkpO1xuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJnYigpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gTk9URShTQik6IHVzaW5nIG5vZGUtY2xvbmUgY3JlYXRlcyBhIGRlcGVuZGVuY3kgdG8gQnVmZmVyIHdoZW4gdXNpbmcgYnJvd3NlcmlmeSxcblx0XHQvLyBtYWtpbmcgdGhlIGZpbmFsIGJ1aWxkIHdheSB0byBiaWcgdG8gZW1iZWQgaW4gQ2hhcnQuanMuIFNvIGxldCdzIGRvIGl0IG1hbnVhbGx5LFxuXHRcdC8vIGFzc3VtaW5nIHRoYXQgdmFsdWVzIHRvIGNsb25lIGFyZSAxIGRpbWVuc2lvbiBhcnJheXMgY29udGFpbmluZyBvbmx5IG51bWJlcnMsXG5cdFx0Ly8gZXhjZXB0ICdhbHBoYScgd2hpY2ggaXMgYSBudW1iZXIuXG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBDb2xvcigpO1xuXHRcdHZhciBzb3VyY2UgPSB0aGlzLnZhbHVlcztcblx0XHR2YXIgdGFyZ2V0ID0gcmVzdWx0LnZhbHVlcztcblx0XHR2YXIgdmFsdWUsIHR5cGU7XG5cblx0XHRmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuXHRcdFx0aWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcblx0XHRcdFx0dHlwZSA9ICh7fSkudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gdmFsdWUuc2xpY2UoMCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcblx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCd1bmV4cGVjdGVkIGNvbG9yIHZhbHVlOicsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zcGFjZXMgPSB7XG5cdHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG5cdGhzdjogWydodWUnLCAnc2F0dXJhdGlvbicsICd2YWx1ZSddLFxuXHRod2I6IFsnaHVlJywgJ3doaXRlbmVzcycsICdibGFja25lc3MnXSxcblx0Y215azogWydjeWFuJywgJ21hZ2VudGEnLCAneWVsbG93JywgJ2JsYWNrJ11cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5tYXhlcyA9IHtcblx0cmdiOiBbMjU1LCAyNTUsIDI1NV0sXG5cdGhzbDogWzM2MCwgMTAwLCAxMDBdLFxuXHRoc3Y6IFszNjAsIDEwMCwgMTAwXSxcblx0aHdiOiBbMzYwLCAxMDAsIDEwMF0sXG5cdGNteWs6IFsxMDAsIDEwMCwgMTAwLCAxMDBdXG59O1xuXG5Db2xvci5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwYWNlKSB7XG5cdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0dmFyIHZhbHMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFsc1tzcGFjZS5jaGFyQXQoaSldID0gdmFsdWVzW3NwYWNlXVtpXTtcblx0fVxuXG5cdGlmICh2YWx1ZXMuYWxwaGEgIT09IDEpIHtcblx0XHR2YWxzLmEgPSB2YWx1ZXMuYWxwaGE7XG5cdH1cblxuXHQvLyB7cjogMjU1LCBnOiAyNTUsIGI6IDI1NSwgYTogMC40fVxuXHRyZXR1cm4gdmFscztcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAoc3BhY2UsIHZhbHMpIHtcblx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHR2YXIgc3BhY2VzID0gdGhpcy5zcGFjZXM7XG5cdHZhciBtYXhlcyA9IHRoaXMubWF4ZXM7XG5cdHZhciBhbHBoYSA9IDE7XG5cdHZhciBpO1xuXG5cdHRoaXMudmFsaWQgPSB0cnVlO1xuXG5cdGlmIChzcGFjZSA9PT0gJ2FscGhhJykge1xuXHRcdGFscGhhID0gdmFscztcblx0fSBlbHNlIGlmICh2YWxzLmxlbmd0aCkge1xuXHRcdC8vIFsxMCwgMTAsIDEwXVxuXHRcdHZhbHVlc1tzcGFjZV0gPSB2YWxzLnNsaWNlKDAsIHNwYWNlLmxlbmd0aCk7XG5cdFx0YWxwaGEgPSB2YWxzW3NwYWNlLmxlbmd0aF07XG5cdH0gZWxzZSBpZiAodmFsc1tzcGFjZS5jaGFyQXQoMCldICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyB7cjogMTAsIGc6IDEwLCBiOiAxMH1cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW3NwYWNlLmNoYXJBdChpKV07XG5cdFx0fVxuXG5cdFx0YWxwaGEgPSB2YWxzLmE7XG5cdH0gZWxzZSBpZiAodmFsc1tzcGFjZXNbc3BhY2VdWzBdXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8ge3JlZDogMTAsIGdyZWVuOiAxMCwgYmx1ZTogMTB9XG5cdFx0dmFyIGNoYW5zID0gc3BhY2VzW3NwYWNlXTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWVzW3NwYWNlXVtpXSA9IHZhbHNbY2hhbnNbaV1dO1xuXHRcdH1cblxuXHRcdGFscGhhID0gdmFscy5hbHBoYTtcblx0fVxuXG5cdHZhbHVlcy5hbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChhbHBoYSA9PT0gdW5kZWZpbmVkID8gdmFsdWVzLmFscGhhIDogYWxwaGEpKSk7XG5cblx0aWYgKHNwYWNlID09PSAnYWxwaGEnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGNhcHBlZDtcblxuXHQvLyBjYXAgdmFsdWVzIG9mIHRoZSBzcGFjZSBwcmlvciBjb252ZXJ0aW5nIGFsbCB2YWx1ZXNcblx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2FwcGVkID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4ZXNbc3BhY2VdW2ldLCB2YWx1ZXNbc3BhY2VdW2ldKSk7XG5cdFx0dmFsdWVzW3NwYWNlXVtpXSA9IE1hdGgucm91bmQoY2FwcGVkKTtcblx0fVxuXG5cdC8vIGNvbnZlcnQgdG8gYWxsIHRoZSBvdGhlciBjb2xvciBzcGFjZXNcblx0Zm9yICh2YXIgc25hbWUgaW4gc3BhY2VzKSB7XG5cdFx0aWYgKHNuYW1lICE9PSBzcGFjZSkge1xuXHRcdFx0dmFsdWVzW3NuYW1lXSA9IGNvbG9yQ29udmVydFtzcGFjZV1bc25hbWVdKHZhbHVlc1tzcGFjZV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldFNwYWNlID0gZnVuY3Rpb24gKHNwYWNlLCBhcmdzKSB7XG5cdHZhciB2YWxzID0gYXJnc1swXTtcblxuXHRpZiAodmFscyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gY29sb3IucmdiKClcblx0XHRyZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuXHR9XG5cblx0Ly8gY29sb3IucmdiKDEwLCAxMCwgMTApXG5cdGlmICh0eXBlb2YgdmFscyA9PT0gJ251bWJlcicpIHtcblx0XHR2YWxzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG5cdH1cblxuXHR0aGlzLnNldFZhbHVlcyhzcGFjZSwgdmFscyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldENoYW5uZWwgPSBmdW5jdGlvbiAoc3BhY2UsIGluZGV4LCB2YWwpIHtcblx0dmFyIHN2YWx1ZXMgPSB0aGlzLnZhbHVlc1tzcGFjZV07XG5cdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIGNvbG9yLnJlZCgpXG5cdFx0cmV0dXJuIHN2YWx1ZXNbaW5kZXhdO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gc3ZhbHVlc1tpbmRleF0pIHtcblx0XHQvLyBjb2xvci5yZWQoY29sb3IucmVkKCkpXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBjb2xvci5yZWQoMTAwKVxuXHRzdmFsdWVzW2luZGV4XSA9IHZhbDtcblx0dGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHN2YWx1ZXMpO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5Db2xvciA9IENvbG9yO1xufVxuXG52YXIgY2hhcnRqc0NvbG9yID0gQ29sb3I7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzXG4gKi9cbnZhciBoZWxwZXJzID0ge1xuXHQvKipcblx0ICogQW4gZW1wdHkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIGZvciBvcHRpb25hbCBjYWxsYmFjay5cblx0ICovXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB1bmlxdWUgaWQsIHNlcXVlbnRpYWxseSBnZW5lcmF0ZWQgZnJvbSBhIGdsb2JhbCB2YXJpYWJsZS5cblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHR1aWQ6IChmdW5jdGlvbigpIHtcblx0XHR2YXIgaWQgPSAwO1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBpZCsrO1xuXHRcdH07XG5cdH0oKSksXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG5laXRoZXIgbnVsbCBub3IgdW5kZWZpbmVkLCBlbHNlIHJldHVybnMgZmFsc2UuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0aXNOdWxsT3JVbmRlZjogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgKGluY2x1ZGluZyB0eXBlZCBhcnJheXMpLCBlbHNlIHJldHVybnMgZmFsc2UuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0aXNBcnJheTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblx0XHRpZiAodHlwZS5zdWJzdHIoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnN1YnN0cigtNikgPT09ICdBcnJheV0nKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QgKGV4Y2x1ZGluZyBudWxsKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGlzT2JqZWN0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIHJldHVybnMgZmFsc2Vcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Zpbml0ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKHZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBgdmFsdWVgIGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cblx0ICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdHZhbHVlT3JEZWZhdWx0OiBmdW5jdGlvbih2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB2YWx1ZSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiBhcnJheSBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIC0gVGhlIGFycmF5IHRvIGxvb2t1cCBmb3IgdmFsdWUgYXQgYGluZGV4YC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGluIGB2YWx1ZWAgdG8gbG9va3VwIGZvciB2YWx1ZS5cblx0ICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZVtpbmRleF1gIGlzIHVuZGVmaW5lZC5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHR2YWx1ZUF0SW5kZXhPckRlZmF1bHQ6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMudmFsdWVPckRlZmF1bHQoaGVscGVycy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlW2luZGV4XSA6IHZhbHVlLCBkZWZhdWx0VmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxscyBgZm5gIHdpdGggdGhlIGdpdmVuIGBhcmdzYCBpbiB0aGUgc2NvcGUgZGVmaW5lZCBieSBgdGhpc0FyZ2AgYW5kIHJldHVybnMgdGhlXG5cdCAqIHZhbHVlIHJldHVybmVkIGJ5IGBmbmAuIElmIGBmbmAgaXMgbm90IGEgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuXHQgKiBAcGFyYW0ge0FycmF5fHVuZGVmaW5lZHxudWxsfSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB3aXRoIHdoaWNoIGBmbmAgc2hvdWxkIGJlIGNhbGxlZC5cblx0ICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGlzQXJnKSB7XG5cdFx0aWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBOb3RlKFNCKSBmb3IgcGVyZm9ybWFuY2Ugc2FrZSwgdGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIGxvb3BhYmxlIHR5cGVcblx0ICogaXMgdW5rbm93biBvciBpbiBub25lIGludGVuc2l2ZSBjb2RlIChub3QgY2FsbGVkIG9mdGVuIGFuZCBzbWFsbCBsb29wYWJsZSkuIEVsc2Vcblx0ICogaXQncyBwcmVmZXJhYmxlIHRvIHVzZSBhIHJlZ3VsYXIgZm9yKCkgbG9vcCBhbmQgc2F2ZSBleHRyYSBmdW5jdGlvbiBjYWxscy5cblx0ICogQHBhcmFtIHtvYmplY3R8QXJyYXl9IGxvb3BhYmxlIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSBpdGVyYXRlZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gLSBJZiB0cnVlLCBpdGVyYXRlcyBiYWNrd2FyZCBvbiB0aGUgbG9vcGFibGUuXG5cdCAqL1xuXHRlYWNoOiBmdW5jdGlvbihsb29wYWJsZSwgZm4sIHRoaXNBcmcsIHJldmVyc2UpIHtcblx0XHR2YXIgaSwgbGVuLCBrZXlzO1xuXHRcdGlmIChoZWxwZXJzLmlzQXJyYXkobG9vcGFibGUpKSB7XG5cdFx0XHRsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG5cdFx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0XHRmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaGVscGVycy5pc09iamVjdChsb29wYWJsZSkpIHtcblx0XHRcdGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG5cdFx0XHRsZW4gPSBrZXlzLmxlbmd0aDtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYGEwYCBhbmQgYGExYCBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LCBlbHNlIHJldHVybnMgZmFsc2UuXG5cdCAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0ODUzOTc0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGEwIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcblx0ICogQHBhcmFtIHtBcnJheX0gYTEgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGFycmF5RXF1YWxzOiBmdW5jdGlvbihhMCwgYTEpIHtcblx0XHR2YXIgaSwgaWxlbiwgdjAsIHYxO1xuXG5cdFx0aWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR2MCA9IGEwW2ldO1xuXHRcdFx0djEgPSBhMVtpXTtcblxuXHRcdFx0aWYgKHYwIGluc3RhbmNlb2YgQXJyYXkgJiYgdjEgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRpZiAoIWhlbHBlcnMuYXJyYXlFcXVhbHModjAsIHYxKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh2MCAhPT0gdjEpIHtcblx0XHRcdFx0Ly8gTk9URTogdHdvIGRpZmZlcmVudCBvYmplY3QgaW5zdGFuY2VzIHdpbGwgbmV2ZXIgYmUgZXF1YWw6IHt4OjIwfSAhPSB7eDoyMH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cblx0ICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgdmFsdWUgdG8gY2xvbmUuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0Y2xvbmU6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdGlmIChoZWxwZXJzLmlzQXJyYXkoc291cmNlKSkge1xuXHRcdFx0cmV0dXJuIHNvdXJjZS5tYXAoaGVscGVycy5jbG9uZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3Qoc291cmNlKSkge1xuXHRcdFx0dmFyIHRhcmdldCA9IHt9O1xuXHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXHRcdFx0dmFyIGtsZW4gPSBrZXlzLmxlbmd0aDtcblx0XHRcdHZhciBrID0gMDtcblxuXHRcdFx0Zm9yICg7IGsgPCBrbGVuOyArK2spIHtcblx0XHRcdFx0dGFyZ2V0W2tleXNba11dID0gaGVscGVycy5jbG9uZShzb3VyY2Vba2V5c1trXV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdHJldHVybiBzb3VyY2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0IG1lcmdlciB3aGVuIENoYXJ0LmhlbHBlcnMubWVyZ2UgaXMgY2FsbGVkIHdpdGhvdXQgbWVyZ2VyIG9wdGlvbi5cblx0ICogTm90ZShTQik6IGFsc28gdXNlZCBieSBtZXJnZUNvbmZpZyBhbmQgbWVyZ2VTY2FsZUNvbmZpZyBhcyBmYWxsYmFjay5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9tZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldO1xuXHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XG5cblx0XHRpZiAoaGVscGVycy5pc09iamVjdCh0dmFsKSAmJiBoZWxwZXJzLmlzT2JqZWN0KHN2YWwpKSB7XG5cdFx0XHRoZWxwZXJzLm1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMuY2xvbmUoc3ZhbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBNZXJnZXMgc291cmNlW2tleV0gaW4gdGFyZ2V0W2tleV0gb25seSBpZiB0YXJnZXRba2V5XSBpcyB1bmRlZmluZWQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbWVyZ2VySWY6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UpIHtcblx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldO1xuXHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XG5cblx0XHRpZiAoaGVscGVycy5pc09iamVjdCh0dmFsKSAmJiBoZWxwZXJzLmlzT2JqZWN0KHN2YWwpKSB7XG5cdFx0XHRoZWxwZXJzLm1lcmdlSWYodHZhbCwgc3ZhbCk7XG5cdFx0fSBlbHNlIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHRhcmdldFtrZXldID0gaGVscGVycy5jbG9uZShzdmFsKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG5cdCAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cblx0ICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gTWVyZ2luZyBvcHRpb25zOlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5tZXJnZXJdIC0gVGhlIG1lcmdlIG1ldGhvZCAoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cblx0ICovXG5cdG1lcmdlOiBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdHZhciBzb3VyY2VzID0gaGVscGVycy5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcblx0XHR2YXIgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuXHRcdHZhciBtZXJnZSwgaSwga2V5cywga2xlbiwgaztcblxuXHRcdGlmICghaGVscGVycy5pc09iamVjdCh0YXJnZXQpKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdG1lcmdlID0gb3B0aW9ucy5tZXJnZXIgfHwgaGVscGVycy5fbWVyZ2VyO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0c291cmNlID0gc291cmNlc1tpXTtcblx0XHRcdGlmICghaGVscGVycy5pc09iamVjdChzb3VyY2UpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblx0XHRcdGZvciAoayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuXHRcdFx0XHRtZXJnZShrZXlzW2tdLCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSxcblxuXHQvKipcblx0ICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgICpvbmx5KiBpZiBub3QgZGVmaW5lZCBpbiB0YXJnZXQuXG5cdCAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cblx0ICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgYHRhcmdldGAgb2JqZWN0LlxuXHQgKi9cblx0bWVyZ2VJZjogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcblx0XHRyZXR1cm4gaGVscGVycy5tZXJnZSh0YXJnZXQsIHNvdXJjZSwge21lcmdlcjogaGVscGVycy5fbWVyZ2VySWZ9KTtcblx0fSxcblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgY29udGVudHMgb2YgdHdvIG9yIG1vcmUgb2JqZWN0cyB0b2dldGhlciBpbnRvIHRoZSBmaXJzdCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgb2JqZWN0cyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmcxIC0gT2JqZWN0IGNvbnRhaW5pbmcgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIG1lcmdlIGluIHRhcmdldC5cblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ04gLSBBZGRpdGlvbmFsIG9iamVjdHMgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIG1lcmdlIGluIHRhcmdldC5cblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cblx0ICovXG5cdGV4dGVuZDogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyIHNldEZuID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0dGFyZ2V0W2tleV0gPSB2YWx1ZTtcblx0XHR9O1xuXHRcdGZvciAodmFyIGkgPSAxLCBpbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aGVscGVycy5lYWNoKGFyZ3VtZW50c1tpXSwgc2V0Rm4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBCYXNpYyBqYXZhc2NyaXB0IGluaGVyaXRhbmNlIGJhc2VkIG9uIHRoZSBtb2RlbCBjcmVhdGVkIGluIEJhY2tib25lLmpzXG5cdCAqL1xuXHRpbmhlcml0czogZnVuY3Rpb24oZXh0ZW5zaW9ucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIENoYXJ0RWxlbWVudCA9IChleHRlbnNpb25zICYmIGV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykpID8gZXh0ZW5zaW9ucy5jb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY29uc3RydWN0b3IgPSBDaGFydEVsZW1lbnQ7XG5cdFx0fTtcblxuXHRcdFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBtZS5wcm90b3R5cGU7XG5cdFx0Q2hhcnRFbGVtZW50LnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGUoKTtcblx0XHRDaGFydEVsZW1lbnQuZXh0ZW5kID0gaGVscGVycy5pbmhlcml0cztcblxuXHRcdGlmIChleHRlbnNpb25zKSB7XG5cdFx0XHRoZWxwZXJzLmV4dGVuZChDaGFydEVsZW1lbnQucHJvdG90eXBlLCBleHRlbnNpb25zKTtcblx0XHR9XG5cblx0XHRDaGFydEVsZW1lbnQuX19zdXBlcl9fID0gbWUucHJvdG90eXBlO1xuXHRcdHJldHVybiBDaGFydEVsZW1lbnQ7XG5cdH1cbn07XG5cbnZhciBoZWxwZXJzX2NvcmUgPSBoZWxwZXJzO1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FsbGJhY2sgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmNhbGxDYWxsYmFja1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5jYWxsQ2FsbGJhY2sgPSBoZWxwZXJzLmNhbGxiYWNrO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgaW5zdGVhZC5cbiAqIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGNvbXBhdGliaWxpdHk6IENocm9tZSwgT3BlcmEsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5pbmRleE9mXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbUluZGV4KSB7XG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGFycmF5LCBpdGVtLCBmcm9tSW5kZXgpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMudmFsdWVPckRlZmF1bHQgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdDtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0IGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gUm9iZXJ0IFBlbm5lcidzIGVhc2luZyBlcXVhdGlvbnMuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nRWZmZWN0c1xuICogQHNlZSBodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nL1xuICovXG52YXIgZWZmZWN0cyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQ7XG5cdH0sXG5cblx0ZWFzZUluUXVhZDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtdCAqICh0IC0gMik7XG5cdH0sXG5cblx0ZWFzZUluT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLTAuNSAqICgoLS10KSAqICh0IC0gMikgLSAxKTtcblx0fSxcblxuXHRlYXNlSW5DdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dEN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqIHQgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKyAyKTtcblx0fSxcblxuXHRlYXNlSW5RdWFydDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRRdWFydDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtKCh0ID0gdCAtIDEpICogdCAqIHQgKiB0IC0gMSk7XG5cdH0sXG5cblx0ZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLTAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpO1xuXHR9LFxuXG5cdGVhc2VJblF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRRdWludDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XG5cdH0sXG5cblx0ZWFzZUluU2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtTWF0aC5jb3ModCAqIChNYXRoLlBJIC8gMikpICsgMTtcblx0fSxcblxuXHRlYXNlT3V0U2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNpbih0ICogKE1hdGguUEkgLyAyKSk7XG5cdH0sXG5cblx0ZWFzZUluT3V0U2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiB0KSAtIDEpO1xuXHR9LFxuXG5cdGVhc2VJbkV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG5cdH0sXG5cblx0ZWFzZU91dEV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPT09IDEpID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0RXhwbzogZnVuY3Rpb24odCkge1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMik7XG5cdH0sXG5cblx0ZWFzZUluQ2lyYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICh0ID49IDEpIHtcblx0XHRcdHJldHVybiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuXHR9LFxuXG5cdGVhc2VPdXRDaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCgxIC0gKHQgPSB0IC0gMSkgKiB0KTtcblx0fSxcblxuXHRlYXNlSW5PdXRDaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpO1xuXHR9LFxuXG5cdGVhc2VJbkVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHZhciBhID0gMTtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCFwKSB7XG5cdFx0XHRwID0gMC4zO1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0fSxcblxuXHRlYXNlT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxO1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoIXApIHtcblx0XHRcdHAgPSAwLjM7XG5cdFx0fVxuXHRcdGlmIChhIDwgMSkge1xuXHRcdFx0YSA9IDE7XG5cdFx0XHRzID0gcCAvIDQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cdFx0fVxuXHRcdHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHZhciBwID0gMDtcblx0XHR2YXIgYSA9IDE7XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRpZiAoKHQgLz0gMC41KSA9PT0gMikge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdGlmICghcCkge1xuXHRcdFx0cCA9IDAuNDU7XG5cdFx0fVxuXHRcdGlmIChhIDwgMSkge1xuXHRcdFx0YSA9IDE7XG5cdFx0XHRzID0gcCAvIDQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cdFx0fVxuXHRcdGlmICh0IDwgMSkge1xuXHRcdFx0cmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdFx0fVxuXHRcdHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG5cdH0sXG5cdGVhc2VJbkJhY2s6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0cmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG5cdH0sXG5cblx0ZWFzZU91dEJhY2s6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG5cdH0sXG5cblx0ZWFzZUluQm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpO1xuXHR9LFxuXG5cdGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA8ICgxIC8gMi43NSkpIHtcblx0XHRcdHJldHVybiA3LjU2MjUgKiB0ICogdDtcblx0XHR9XG5cdFx0aWYgKHQgPCAoMiAvIDIuNzUpKSB7XG5cdFx0XHRyZXR1cm4gNy41NjI1ICogKHQgLT0gKDEuNSAvIDIuNzUpKSAqIHQgKyAwLjc1O1xuXHRcdH1cblx0XHRpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xuXHRcdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgyLjI1IC8gMi43NSkpICogdCArIDAuOTM3NTtcblx0XHR9XG5cdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgyLjYyNSAvIDIuNzUpKSAqIHQgKyAwLjk4NDM3NTtcblx0fSxcblxuXHRlYXNlSW5PdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA8IDAuNSkge1xuXHRcdFx0cmV0dXJuIGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNTtcblx0XHR9XG5cdFx0cmV0dXJuIGVmZmVjdHMuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41O1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19lYXNpbmcgPSB7XG5cdGVmZmVjdHM6IGVmZmVjdHNcbn07XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5lYXNpbmcuZWZmZWN0cyBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZWFzaW5nRWZmZWN0c1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVyc19jb3JlLmVhc2luZ0VmZmVjdHMgPSBlZmZlY3RzO1xuXG52YXIgUEkgPSBNYXRoLlBJO1xudmFyIFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG52YXIgRE9VQkxFX1BJID0gUEkgKiAyO1xudmFyIEhBTEZfUEkgPSBQSSAvIDI7XG52YXIgUVVBUlRFUl9QSSA9IFBJIC8gNDtcbnZhciBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuY2FudmFzXG4gKi9cbnZhciBleHBvcnRzJDEgPSB7XG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMgYXNzb2NpYXRlZCB0byB0aGUgZ2l2ZW4gYGNoYXJ0YC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgZm9yIHdoaWNoIHRvIGNsZWFyIHRoZSBjYW52YXMuXG5cdCAqL1xuXHRjbGVhcjogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRjaGFydC5jdHguY2xlYXJSZWN0KDAsIDAsIGNoYXJ0LndpZHRoLCBjaGFydC5oZWlnaHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgXCJwYXRoXCIgZm9yIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIGF0IHBvc2l0aW9uICh4LCB5KSB3aXRoIGFcblx0ICogZ2l2ZW4gc2l6ZSAod2lkdGgsIGhlaWdodCkgYW5kIHRoZSBzYW1lIGByYWRpdXNgIGZvciBhbGwgY29ybmVycy5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIFRoZSBjYW52YXMgMkQgQ29udGV4dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBheGlzIG9mIHRoZSBjb29yZGluYXRlIGZvciB0aGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGF4aXMgb2YgdGhlIGNvb3JkaW5hdGUgZm9yIHRoZSByZWN0YW5nbGUgc3RhcnRpbmcgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSByZWN0YW5nbGUncyB3aWR0aC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSByZWN0YW5nbGUncyBoZWlnaHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcm91bmRlZCBhbW91bnQgKGluIHBpeGVscykgZm9yIHRoZSBmb3VyIGNvcm5lcnMuXG5cdCAqIEB0b2RvIGhhbmRsZSBgcmFkaXVzYCBhcyB0b3AtbGVmdCwgdG9wLXJpZ2h0LCBib3R0b20tcmlnaHQsIGJvdHRvbS1sZWZ0IGFycmF5L29iamVjdD9cblx0ICovXG5cdHJvdW5kZWRSZWN0OiBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuXHRcdGlmIChyYWRpdXMpIHtcblx0XHRcdHZhciByID0gTWF0aC5taW4ocmFkaXVzLCBoZWlnaHQgLyAyLCB3aWR0aCAvIDIpO1xuXHRcdFx0dmFyIGxlZnQgPSB4ICsgcjtcblx0XHRcdHZhciB0b3AgPSB5ICsgcjtcblx0XHRcdHZhciByaWdodCA9IHggKyB3aWR0aCAtIHI7XG5cdFx0XHR2YXIgYm90dG9tID0geSArIGhlaWdodCAtIHI7XG5cblx0XHRcdGN0eC5tb3ZlVG8oeCwgdG9wKTtcblx0XHRcdGlmIChsZWZ0IDwgcmlnaHQgJiYgdG9wIDwgYm90dG9tKSB7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCAtUEksIC1IQUxGX1BJKTtcblx0XHRcdFx0Y3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgMCk7XG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIGJvdHRvbSwgciwgMCwgSEFMRl9QSSk7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCBIQUxGX1BJLCBQSSk7XG5cdFx0XHR9IGVsc2UgaWYgKGxlZnQgPCByaWdodCkge1xuXHRcdFx0XHRjdHgubW92ZVRvKGxlZnQsIHkpO1xuXHRcdFx0XHRjdHguYXJjKHJpZ2h0LCB0b3AsIHIsIC1IQUxGX1BJLCBIQUxGX1BJKTtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIEhBTEZfUEksIFBJICsgSEFMRl9QSSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRvcCA8IGJvdHRvbSkge1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCAwKTtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIDAsIFBJKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCAtUEksIFBJKTtcblx0XHRcdH1cblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdH1cblx0fSxcblxuXHRkcmF3UG9pbnQ6IGZ1bmN0aW9uKGN0eCwgc3R5bGUsIHJhZGl1cywgeCwgeSwgcm90YXRpb24pIHtcblx0XHR2YXIgdHlwZSwgeE9mZnNldCwgeU9mZnNldCwgc2l6ZSwgY29ybmVyUmFkaXVzO1xuXHRcdHZhciByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcblxuXHRcdGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHR0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcblx0XHRcdGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuXHRcdFx0XHRjdHguZHJhd0ltYWdlKHN0eWxlLCB4IC0gc3R5bGUud2lkdGggLyAyLCB5IC0gc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdHN3aXRjaCAoc3R5bGUpIHtcblx0XHQvLyBEZWZhdWx0IGluY2x1ZGVzIGNpcmNsZVxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgRE9VQkxFX1BJKTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3RyaWFuZ2xlJzpcblx0XHRcdGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcblx0XHRcdHJhZCArPSBUV09fVEhJUkRTX1BJO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuXHRcdFx0cmFkICs9IFRXT19USElSRFNfUEk7XG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdyZWN0Um91bmRlZCc6XG5cdFx0XHQvLyBOT1RFOiB0aGUgcm91bmRlZCByZWN0IGltcGxlbWVudGF0aW9uIGNoYW5nZWQgdG8gdXNlIGBhcmNgIGluc3RlYWQgb2Zcblx0XHRcdC8vIGBxdWFkcmF0aWNDdXJ2ZVRvYCBzaW5jZSBpdCBnZW5lcmF0ZXMgYmV0dGVyIHJlc3VsdHMgd2hlbiByZWN0IGlzXG5cdFx0XHQvLyBhbG1vc3QgYSBjaXJjbGUuIDAuNTE2IChpbnN0ZWFkIG9mIDAuNSkgcHJvZHVjZXMgcmVzdWx0cyB3aXRoIHZpc3VhbGx5XG5cdFx0XHQvLyBjbG9zZXIgcHJvcG9ydGlvbiB0byB0aGUgcHJldmlvdXMgaW1wbCBhbmQgaXQgaXMgaW5zY3JpYmVkIGluIHRoZVxuXHRcdFx0Ly8gY2lyY2xlIHdpdGggYHJhZGl1c2AuIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGUgZm9sbG93aW5nIFBSczpcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81NTk3XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTg1OFxuXHRcdFx0Y29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG5cdFx0XHRzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG5cdFx0XHRjdHguYXJjKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG5cdFx0XHRjdHguYXJjKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xuXHRcdFx0Y3R4LmFyYyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcblx0XHRcdGN0eC5hcmMoeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3JlY3QnOlxuXHRcdFx0aWYgKCFyb3RhdGlvbikge1xuXHRcdFx0XHRzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuXHRcdFx0XHRjdHgucmVjdCh4IC0gc2l6ZSwgeSAtIHNpemUsIDIgKiBzaXplLCAyICogc2l6ZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmFkICs9IFFVQVJURVJfUEk7XG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0Y2FzZSAncmVjdFJvdCc6XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnY3Jvc3NSb3QnOlxuXHRcdFx0cmFkICs9IFFVQVJURVJfUEk7XG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0Y2FzZSAnY3Jvc3MnOlxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3N0YXInOlxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2xpbmUnOlxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2Rhc2gnOlxuXHRcdFx0Y3R4Lm1vdmVUbyh4LCB5KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiByYWRpdXMsIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGN0eC5maWxsKCk7XG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludCAtIFRoZSBwb2ludCB0byB0ZXN0XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmVhIC0gVGhlIHJlY3RhbmdsZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9pc1BvaW50SW5BcmVhOiBmdW5jdGlvbihwb2ludCwgYXJlYSkge1xuXHRcdHZhciBlcHNpbG9uID0gMWUtNjsgLy8gMWUtNiBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBhY2N1bXVsYXRlZCBlcnJvci5cblxuXHRcdHJldHVybiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gZXBzaWxvbiAmJiBwb2ludC54IDwgYXJlYS5yaWdodCArIGVwc2lsb24gJiZcblx0XHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIGVwc2lsb24gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgZXBzaWxvbjtcblx0fSxcblxuXHRjbGlwQXJlYTogZnVuY3Rpb24oY3R4LCBhcmVhKSB7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG5cdFx0Y3R4LmNsaXAoKTtcblx0fSxcblxuXHR1bmNsaXBBcmVhOiBmdW5jdGlvbihjdHgpIHtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9LFxuXG5cdGxpbmVUbzogZnVuY3Rpb24oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwKSB7XG5cdFx0dmFyIHN0ZXBwZWQgPSB0YXJnZXQuc3RlcHBlZExpbmU7XG5cdFx0aWYgKHN0ZXBwZWQpIHtcblx0XHRcdGlmIChzdGVwcGVkID09PSAnbWlkZGxlJykge1xuXHRcdFx0XHR2YXIgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcblx0XHRcdFx0Y3R4LmxpbmVUbyhtaWRwb2ludCwgZmxpcCA/IHRhcmdldC55IDogcHJldmlvdXMueSk7XG5cdFx0XHRcdGN0eC5saW5lVG8obWlkcG9pbnQsIGZsaXAgPyBwcmV2aW91cy55IDogdGFyZ2V0LnkpO1xuXHRcdFx0fSBlbHNlIGlmICgoc3RlcHBlZCA9PT0gJ2FmdGVyJyAmJiAhZmxpcCkgfHwgKHN0ZXBwZWQgIT09ICdhZnRlcicgJiYgZmxpcCkpIHtcblx0XHRcdFx0Y3R4LmxpbmVUbyhwcmV2aW91cy54LCB0YXJnZXQueSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcblx0XHRcdH1cblx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRhcmdldC50ZW5zaW9uKSB7XG5cdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LmJlemllckN1cnZlVG8oXG5cdFx0XHRmbGlwID8gcHJldmlvdXMuY29udHJvbFBvaW50UHJldmlvdXNYIDogcHJldmlvdXMuY29udHJvbFBvaW50TmV4dFgsXG5cdFx0XHRmbGlwID8gcHJldmlvdXMuY29udHJvbFBvaW50UHJldmlvdXNZIDogcHJldmlvdXMuY29udHJvbFBvaW50TmV4dFksXG5cdFx0XHRmbGlwID8gdGFyZ2V0LmNvbnRyb2xQb2ludE5leHRYIDogdGFyZ2V0LmNvbnRyb2xQb2ludFByZXZpb3VzWCxcblx0XHRcdGZsaXAgPyB0YXJnZXQuY29udHJvbFBvaW50TmV4dFkgOiB0YXJnZXQuY29udHJvbFBvaW50UHJldmlvdXNZLFxuXHRcdFx0dGFyZ2V0LngsXG5cdFx0XHR0YXJnZXQueSk7XG5cdH1cbn07XG5cbnZhciBoZWxwZXJzX2NhbnZhcyA9IGV4cG9ydHMkMTtcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbnZhcy5jbGVhciBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNsZWFyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzX2NvcmUuY2xlYXIgPSBleHBvcnRzJDEuY2xlYXI7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbnZhcy5yb3VuZGVkUmVjdCBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmRyYXdSb3VuZGVkUmVjdGFuZ2xlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzX2NvcmUuZHJhd1JvdW5kZWRSZWN0YW5nbGUgPSBmdW5jdGlvbihjdHgpIHtcblx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRleHBvcnRzJDEucm91bmRlZFJlY3QuYXBwbHkoZXhwb3J0cyQxLCBhcmd1bWVudHMpO1xufTtcblxudmFyIGRlZmF1bHRzID0ge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zZXQ6IGZ1bmN0aW9uKHNjb3BlLCB2YWx1ZXMpIHtcblx0XHRyZXR1cm4gaGVscGVyc19jb3JlLm1lcmdlKHRoaXNbc2NvcGVdIHx8ICh0aGlzW3Njb3BlXSA9IHt9KSwgdmFsdWVzKTtcblx0fVxufTtcblxuZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRkZWZhdWx0Q29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLFxuXHRkZWZhdWx0Rm9udENvbG9yOiAnIzY2NicsXG5cdGRlZmF1bHRGb250RmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG5cdGRlZmF1bHRGb250U2l6ZTogMTIsXG5cdGRlZmF1bHRGb250U3R5bGU6ICdub3JtYWwnLFxuXHRkZWZhdWx0TGluZUhlaWdodDogMS4yLFxuXHRzaG93TGluZXM6IHRydWVcbn0pO1xuXG52YXIgY29yZV9kZWZhdWx0cyA9IGRlZmF1bHRzO1xuXG52YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzX2NvcmUudmFsdWVPckRlZmF1bHQ7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGZvbnQgb2JqZWN0IGludG8gYSBDU1MgZm9udCBzdHJpbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gZm9udCAtIEEgZm9udCBvYmplY3QuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBDU1MgZm9udCBzdHJpbmcuIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQpIHtcblx0aWYgKCFmb250IHx8IGhlbHBlcnNfY29yZS5pc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaGVscGVyc19jb3JlLmlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gKGZvbnQuc3R5bGUgPyBmb250LnN0eWxlICsgJyAnIDogJycpXG5cdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcblx0XHQrIGZvbnQuZmFtaWx5O1xufVxuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm9wdGlvbnNcbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIGhlbHBlcnNfb3B0aW9ucyA9IHtcblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiBsaW5lIGhlaWdodCBgdmFsdWVgIGluIHBpeGVscyBmb3IgYSBzcGVjaWZpYyBmb250IGBzaXplYC5cblx0ICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZSAtIFRoZSBsaW5lSGVpZ2h0IHRvIHBhcnNlIChlZy4gMS42LCAnMTRweCcsICc3NSUnLCAnMS42ZW0nKS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgZm9udCBzaXplIChpbiBwaXhlbHMpIHVzZWQgdG8gcmVzb2x2ZSByZWxhdGl2ZSBgdmFsdWVgLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGluIHBpeGVscyAoc2l6ZSAqIDEuMiBpZiB2YWx1ZSBpcyBpbnZhbGlkKS5cblx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbGluZS1oZWlnaHRcblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHR0b0xpbmVIZWlnaHQ6IGZ1bmN0aW9uKHZhbHVlLCBzaXplKSB7XG5cdFx0dmFyIG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8pO1xuXHRcdGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuXHRcdFx0cmV0dXJuIHNpemUgKiAxLjI7XG5cdFx0fVxuXG5cdFx0dmFsdWUgPSArbWF0Y2hlc1syXTtcblxuXHRcdHN3aXRjaCAobWF0Y2hlc1szXSkge1xuXHRcdGNhc2UgJ3B4Jzpcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRjYXNlICclJzpcblx0XHRcdHZhbHVlIC89IDEwMDtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gc2l6ZSAqIHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIHBhZGRpbmcgb2JqZWN0IHdpdGggcHJlLWNvbXB1dGVkIHdpZHRoL2hlaWdodC5cblx0ICogQHBhcmFtIHtudW1iZXJ8b2JqZWN0fSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcblx0ICogIGVsc2UsIGlmIGFuZCBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQpXG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0dG9QYWRkaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciB0LCByLCBiLCBsO1xuXG5cdFx0aWYgKGhlbHBlcnNfY29yZS5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHRcdHQgPSArdmFsdWUudG9wIHx8IDA7XG5cdFx0XHRyID0gK3ZhbHVlLnJpZ2h0IHx8IDA7XG5cdFx0XHRiID0gK3ZhbHVlLmJvdHRvbSB8fCAwO1xuXHRcdFx0bCA9ICt2YWx1ZS5sZWZ0IHx8IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHQgPSByID0gYiA9IGwgPSArdmFsdWUgfHwgMDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiB0LFxuXHRcdFx0cmlnaHQ6IHIsXG5cdFx0XHRib3R0b206IGIsXG5cdFx0XHRsZWZ0OiBsLFxuXHRcdFx0aGVpZ2h0OiB0ICsgYixcblx0XHRcdHdpZHRoOiBsICsgclxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBhcnNlcyBmb250IG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIGZvbnQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZm9udCBvcHRpb25zIHRvIGJlIHBhcnNlZC5cblx0ICogQHJldHVybiB7b2JqZWN0fSBUaGUgZm9udCBvYmplY3QuXG5cdCAqIEB0b2RvIFN1cHBvcnQgZm9udC4qIG9wdGlvbnMgYW5kIHJlbmFtZWQgdG8gdG9Gb250KCkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcGFyc2VGb250OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdHZhciBmb250ID0ge1xuXHRcdFx0ZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRcdGxpbmVIZWlnaHQ6IGhlbHBlcnNfY29yZS5vcHRpb25zLnRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRMaW5lSGVpZ2h0KSwgc2l6ZSksXG5cdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0c3R5bGU6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRcdHdlaWdodDogbnVsbCxcblx0XHRcdHN0cmluZzogJydcblx0XHR9O1xuXG5cdFx0Zm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG5cdFx0cmV0dXJuIGZvbnQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gYGlucHV0c2Agc2VxdWVudGlhbGx5IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBpbnB1dHMgLSBBbiBhcnJheSBvZiB2YWx1ZXMsIGZhbGxpbmcgYmFjayB0byB0aGUgbGFzdCB2YWx1ZS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSB2YWx1ZVxuXHQgKiBpcyBjYWxsZWQgd2l0aCBgY29udGV4dGAgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZSByZXN1bHQgYmVjb21lcyB0aGUgbmV3IGlucHV0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XSAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGFuIGFycmF5LCB0aGUgdmFsdWVcblx0ICogYXQgYGluZGV4YCBiZWNvbWUgdGhlIG5ldyBpbnB1dC5cblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRyZXNvbHZlOiBmdW5jdGlvbihpbnB1dHMsIGNvbnRleHQsIGluZGV4KSB7XG5cdFx0dmFyIGksIGlsZW4sIHZhbHVlO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHZhbHVlID0gaW5wdXRzW2ldO1xuXHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaGVscGVyc19jb3JlLmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbaW5kZXhdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxudmFyIGhlbHBlcnMkMSA9IGhlbHBlcnNfY29yZTtcbnZhciBlYXNpbmcgPSBoZWxwZXJzX2Vhc2luZztcbnZhciBjYW52YXMgPSBoZWxwZXJzX2NhbnZhcztcbnZhciBvcHRpb25zID0gaGVscGVyc19vcHRpb25zO1xuaGVscGVycyQxLmVhc2luZyA9IGVhc2luZztcbmhlbHBlcnMkMS5jYW52YXMgPSBjYW52YXM7XG5oZWxwZXJzJDEub3B0aW9ucyA9IG9wdGlvbnM7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHN0YXJ0LCB2aWV3LCBtb2RlbCwgZWFzZSkge1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1vZGVsKTtcblx0dmFyIGksIGlsZW4sIGtleSwgYWN0dWFsLCBvcmlnaW4sIHRhcmdldCwgdHlwZSwgYzAsIGMxO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGtleSA9IGtleXNbaV07XG5cblx0XHR0YXJnZXQgPSBtb2RlbFtrZXldO1xuXG5cdFx0Ly8gaWYgYSB2YWx1ZSBpcyBhZGRlZCB0byB0aGUgbW9kZWwgYWZ0ZXIgcGl2b3QoKSBoYXMgYmVlbiBjYWxsZWQsIHRoZSB2aWV3XG5cdFx0Ly8gZG9lc24ndCBjb250YWluIGl0LCBzbyBsZXQncyBpbml0aWFsaXplIHRoZSB2aWV3IHRvIHRoZSB0YXJnZXQgdmFsdWUuXG5cdFx0aWYgKCF2aWV3Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHZpZXdba2V5XSA9IHRhcmdldDtcblx0XHR9XG5cblx0XHRhY3R1YWwgPSB2aWV3W2tleV07XG5cblx0XHRpZiAoYWN0dWFsID09PSB0YXJnZXQgfHwga2V5WzBdID09PSAnXycpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghc3RhcnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0c3RhcnRba2V5XSA9IGFjdHVhbDtcblx0XHR9XG5cblx0XHRvcmlnaW4gPSBzdGFydFtrZXldO1xuXG5cdFx0dHlwZSA9IHR5cGVvZiB0YXJnZXQ7XG5cblx0XHRpZiAodHlwZSA9PT0gdHlwZW9mIG9yaWdpbikge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGMwID0gY2hhcnRqc0NvbG9yKG9yaWdpbik7XG5cdFx0XHRcdGlmIChjMC52YWxpZCkge1xuXHRcdFx0XHRcdGMxID0gY2hhcnRqc0NvbG9yKHRhcmdldCk7XG5cdFx0XHRcdFx0aWYgKGMxLnZhbGlkKSB7XG5cdFx0XHRcdFx0XHR2aWV3W2tleV0gPSBjMS5taXgoYzAsIGVhc2UpLnJnYlN0cmluZygpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGhlbHBlcnMkMS5pc0Zpbml0ZShvcmlnaW4pICYmIGhlbHBlcnMkMS5pc0Zpbml0ZSh0YXJnZXQpKSB7XG5cdFx0XHRcdHZpZXdba2V5XSA9IG9yaWdpbiArICh0YXJnZXQgLSBvcmlnaW4pICogZWFzZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmlld1trZXldID0gdGFyZ2V0O1xuXHR9XG59XG5cbnZhciBFbGVtZW50ID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbikge1xuXHRoZWxwZXJzJDEuZXh0ZW5kKHRoaXMsIGNvbmZpZ3VyYXRpb24pO1xuXHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbmhlbHBlcnMkMS5leHRlbmQoRWxlbWVudC5wcm90b3R5cGUsIHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhpZGRlbiA9IGZhbHNlO1xuXHR9LFxuXG5cdHBpdm90OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmICghbWUuX3ZpZXcpIHtcblx0XHRcdG1lLl92aWV3ID0gaGVscGVycyQxLmNsb25lKG1lLl9tb2RlbCk7XG5cdFx0fVxuXHRcdG1lLl9zdGFydCA9IHt9O1xuXHRcdHJldHVybiBtZTtcblx0fSxcblxuXHR0cmFuc2l0aW9uOiBmdW5jdGlvbihlYXNlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbW9kZWwgPSBtZS5fbW9kZWw7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuX3N0YXJ0O1xuXHRcdHZhciB2aWV3ID0gbWUuX3ZpZXc7XG5cblx0XHQvLyBObyBhbmltYXRpb24gLT4gTm8gVHJhbnNpdGlvblxuXHRcdGlmICghbW9kZWwgfHwgZWFzZSA9PT0gMSkge1xuXHRcdFx0bWUuX3ZpZXcgPSBtb2RlbDtcblx0XHRcdG1lLl9zdGFydCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gbWU7XG5cdFx0fVxuXG5cdFx0aWYgKCF2aWV3KSB7XG5cdFx0XHR2aWV3ID0gbWUuX3ZpZXcgPSB7fTtcblx0XHR9XG5cblx0XHRpZiAoIXN0YXJ0KSB7XG5cdFx0XHRzdGFydCA9IG1lLl9zdGFydCA9IHt9O1xuXHRcdH1cblxuXHRcdGludGVycG9sYXRlKHN0YXJ0LCB2aWV3LCBtb2RlbCwgZWFzZSk7XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdGhpcy5fbW9kZWwueCxcblx0XHRcdHk6IHRoaXMuX21vZGVsLnlcblx0XHR9O1xuXHR9LFxuXG5cdGhhc1ZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaGVscGVycyQxLmlzTnVtYmVyKHRoaXMuX21vZGVsLngpICYmIGhlbHBlcnMkMS5pc051bWJlcih0aGlzLl9tb2RlbC55KTtcblx0fVxufSk7XG5cbkVsZW1lbnQuZXh0ZW5kID0gaGVscGVycyQxLmluaGVyaXRzO1xuXG52YXIgY29yZV9lbGVtZW50ID0gRWxlbWVudDtcblxudmFyIGV4cG9ydHMkMiA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRjaGFydDogbnVsbCwgLy8gdGhlIGFuaW1hdGlvbiBhc3NvY2lhdGVkIGNoYXJ0IGluc3RhbmNlXG5cdGN1cnJlbnRTdGVwOiAwLCAvLyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RlcFxuXHRudW1TdGVwczogNjAsIC8vIGRlZmF1bHQgbnVtYmVyIG9mIHN0ZXBzXG5cdGVhc2luZzogJycsIC8vIHRoZSBlYXNpbmcgdG8gdXNlIGZvciB0aGlzIGFuaW1hdGlvblxuXHRyZW5kZXI6IG51bGwsIC8vIHJlbmRlciBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBhbmltYXRpb24gc2VydmljZVxuXG5cdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IG51bGwsIC8vIHVzZXIgc3BlY2lmaWVkIGNhbGxiYWNrIHRvIGZpcmUgb24gZWFjaCBzdGVwIG9mIHRoZSBhbmltYXRpb25cblx0b25BbmltYXRpb25Db21wbGV0ZTogbnVsbCwgLy8gdXNlciBzcGVjaWZpZWQgY2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXNcbn0pO1xuXG52YXIgY29yZV9hbmltYXRpb24gPSBleHBvcnRzJDI7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuQW5pbWF0aW9uIGluc3RlYWRcbiAqIEBwcm9wIENoYXJ0LkFuaW1hdGlvbiNhbmltYXRpb25PYmplY3RcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMkMi5wcm90b3R5cGUsICdhbmltYXRpb25PYmplY3QnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuQW5pbWF0aW9uI2NoYXJ0IGluc3RlYWRcbiAqIEBwcm9wIENoYXJ0LkFuaW1hdGlvbiNjaGFydEluc3RhbmNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzJDIucHJvdG90eXBlLCAnY2hhcnRJbnN0YW5jZScsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFydDtcblx0fSxcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuY2hhcnQgPSB2YWx1ZTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRhbmltYXRpb246IHtcblx0XHRkdXJhdGlvbjogMTAwMCxcblx0XHRlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuXHRcdG9uUHJvZ3Jlc3M6IGhlbHBlcnMkMS5ub29wLFxuXHRcdG9uQ29tcGxldGU6IGhlbHBlcnMkMS5ub29wXG5cdH1cbn0pO1xuXG52YXIgY29yZV9hbmltYXRpb25zID0ge1xuXHRhbmltYXRpb25zOiBbXSxcblx0cmVxdWVzdDogbnVsbCxcblxuXHQvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgdG8gYW5pbWF0ZS5cblx0ICogQHBhcmFtIHtDaGFydC5BbmltYXRpb259IGFuaW1hdGlvbiAtIFRoZSBhbmltYXRpb24gdGhhdCB3ZSB3aWxsIGFuaW1hdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gbGF6eSAtIGlmIHRydWUsIHRoZSBjaGFydCBpcyBub3QgbWFya2VkIGFzIGFuaW1hdGluZyB0byBlbmFibGUgbW9yZSByZXNwb25zaXZlIGludGVyYWN0aW9uc1xuXHQgKi9cblx0YWRkQW5pbWF0aW9uOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgbGF6eSkge1xuXHRcdHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0YW5pbWF0aW9uLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0YW5pbWF0aW9uLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cdFx0YW5pbWF0aW9uLmR1cmF0aW9uID0gZHVyYXRpb247XG5cblx0XHRpZiAoIWxhenkpIHtcblx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAoYW5pbWF0aW9uc1tpXS5jaGFydCA9PT0gY2hhcnQpIHtcblx0XHRcdFx0YW5pbWF0aW9uc1tpXSA9IGFuaW1hdGlvbjtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG5vIGFuaW1hdGlvbnMgcXVldWVkLCBtYW51YWxseSBraWNrc3RhcnQgYSBkaWdlc3QsIGZvciBsYWNrIG9mIGEgYmV0dGVyIHdvcmRcblx0XHRpZiAoYW5pbWF0aW9ucy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNhbmNlbEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgaW5kZXggPSBoZWxwZXJzJDEuZmluZEluZGV4KHRoaXMuYW5pbWF0aW9ucywgZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9uLmNoYXJ0ID09PSBjaGFydDtcblx0XHR9KTtcblxuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0Y2hhcnQuYW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdHJlcXVlc3RBbmltYXRpb25GcmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAobWUucmVxdWVzdCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gU2tpcCBhbmltYXRpb24gZnJhbWUgcmVxdWVzdHMgdW50aWwgdGhlIGFjdGl2ZSBvbmUgaXMgZXhlY3V0ZWQuXG5cdFx0XHQvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBwcm9jZXNzaW5nIG1vdXNlIGV2ZW50cywgZS5nLiAnbW91c2Vtb3ZlJ1xuXHRcdFx0Ly8gYW5kICdtb3VzZW91dCcgZXZlbnRzIHdpbGwgdHJpZ2dlciBtdWx0aXBsZSByZW5kZXJzLlxuXHRcdFx0bWUucmVxdWVzdCA9IGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWUucmVxdWVzdCA9IG51bGw7XG5cdFx0XHRcdG1lLnN0YXJ0RGlnZXN0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzdGFydERpZ2VzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdG1lLmFkdmFuY2UoKTtcblxuXHRcdC8vIERvIHdlIGhhdmUgbW9yZSBzdHVmZiB0byBhbmltYXRlP1xuXHRcdGlmIChtZS5hbmltYXRpb25zLmxlbmd0aCA+IDApIHtcblx0XHRcdG1lLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGFkdmFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xuXHRcdHZhciBhbmltYXRpb24sIGNoYXJ0LCBudW1TdGVwcywgbmV4dFN0ZXA7XG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0Ly8gMSBhbmltYXRpb24gcGVyIGNoYXJ0LCBzbyB3ZSBhcmUgbG9vcGluZyBjaGFydHMgaGVyZVxuXHRcdHdoaWxlIChpIDwgYW5pbWF0aW9ucy5sZW5ndGgpIHtcblx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaV07XG5cdFx0XHRjaGFydCA9IGFuaW1hdGlvbi5jaGFydDtcblx0XHRcdG51bVN0ZXBzID0gYW5pbWF0aW9uLm51bVN0ZXBzO1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBjdXJyZW50U3RlcCBzdGFydHMgYXQgMVxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzYxMDRcblx0XHRcdG5leHRTdGVwID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIGFuaW1hdGlvbi5zdGFydFRpbWUpIC8gYW5pbWF0aW9uLmR1cmF0aW9uICogbnVtU3RlcHMpICsgMTtcblx0XHRcdGFuaW1hdGlvbi5jdXJyZW50U3RlcCA9IE1hdGgubWluKG5leHRTdGVwLCBudW1TdGVwcyk7XG5cblx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb24ucmVuZGVyLCBbY2hhcnQsIGFuaW1hdGlvbl0sIGNoYXJ0KTtcblx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb24ub25BbmltYXRpb25Qcm9ncmVzcywgW2FuaW1hdGlvbl0sIGNoYXJ0KTtcblxuXHRcdFx0aWYgKGFuaW1hdGlvbi5jdXJyZW50U3RlcCA+PSBudW1TdGVwcykge1xuXHRcdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLm9uQW5pbWF0aW9uQ29tcGxldGUsIFthbmltYXRpb25dLCBjaGFydCk7XG5cdFx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRhbmltYXRpb25zLnNwbGljZShpLCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCsraTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbnZhciByZXNvbHZlID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxudmFyIGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xuXG4vKipcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG4gKiBjYWxsZWQgb24gdGhlICdvbkRhdGEqJyBjYWxsYmFja3MgKGUuZy4gb25EYXRhUHVzaCwgZXRjLikgd2l0aCBzYW1lIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG5cdGlmIChhcnJheS5fY2hhcnRqcykge1xuXHRcdGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0dmFsdWU6IHtcblx0XHRcdGxpc3RlbmVyczogW2xpc3RlbmVyXVxuXHRcdH1cblx0fSk7XG5cblx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgbWV0aG9kID0gJ29uRGF0YScgKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7XG5cdFx0dmFyIGJhc2UgPSBhcnJheVtrZXldO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHZhciByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycywgZnVuY3Rpb24ob2JqZWN0KSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0b2JqZWN0W21ldGhvZF0uYXBwbHkob2JqZWN0LCBhcmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIGFycmF5IGV2ZW50IGxpc3RlbmVyIGFuZCBjbGVhbnVwIGV4dHJhIGF0dGFjaGVkIHByb3BlcnRpZXMgKHN1Y2ggYXNcbiAqIHRoZSBfY2hhcnRqcyBzdHViIGFuZCBvdmVycmlkZGVuIG1ldGhvZHMpIGlmIGFycmF5IGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBsaXN0ZW5lcnMuXG4gKi9cbmZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG5cdHZhciBzdHViID0gYXJyYXkuX2NoYXJ0anM7XG5cdGlmICghc3R1Yikge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcblx0dmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuXHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXHRpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRhcnJheUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGRlbGV0ZSBhcnJheVtrZXldO1xuXHR9KTtcblxuXHRkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5cbi8vIEJhc2UgY2xhc3MgZm9yIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIChsaW5lLCBiYXIsIGV0YylcbnZhciBEYXRhc2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcblx0dGhpcy5pbml0aWFsaXplKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xufTtcblxuaGVscGVycyQxLmV4dGVuZChEYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcblxuXHQvKipcblx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGFzZXQgKGUuZy4gQ2hhcnQuZWxlbWVudC5MaW5lKS5cblx0ICogQHR5cGUge0NoYXJ0LmNvcmUuZWxlbWVudH1cblx0ICovXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogbnVsbCxcblxuXHQvKipcblx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGEgKGUuZy4gQ2hhcnQuZWxlbWVudC5Qb2ludCkuXG5cdCAqIEB0eXBlIHtDaGFydC5jb3JlLmVsZW1lbnR9XG5cdCAqL1xuXHRkYXRhRWxlbWVudFR5cGU6IG51bGwsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0bWUuY2hhcnQgPSBjaGFydDtcblx0XHRtZS5pbmRleCA9IGRhdGFzZXRJbmRleDtcblx0XHRtZS5saW5rU2NhbGVzKCk7XG5cdFx0bWUuYWRkRWxlbWVudHMoKTtcblx0fSxcblxuXHR1cGRhdGVJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcblx0fSxcblxuXHRsaW5rU2NhbGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXG5cdFx0aWYgKG1ldGEueEF4aXNJRCA9PT0gbnVsbCB8fCAhKG1ldGEueEF4aXNJRCBpbiBtZS5jaGFydC5zY2FsZXMpKSB7XG5cdFx0XHRtZXRhLnhBeGlzSUQgPSBkYXRhc2V0LnhBeGlzSUQgfHwgbWUuY2hhcnQub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0uaWQ7XG5cdFx0fVxuXHRcdGlmIChtZXRhLnlBeGlzSUQgPT09IG51bGwgfHwgIShtZXRhLnlBeGlzSUQgaW4gbWUuY2hhcnQuc2NhbGVzKSkge1xuXHRcdFx0bWV0YS55QXhpc0lEID0gZGF0YXNldC55QXhpc0lEIHx8IG1lLmNoYXJ0Lm9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLmlkO1xuXHRcdH1cblx0fSxcblxuXHRnZXREYXRhc2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuXHR9LFxuXG5cdGdldE1ldGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuXHR9LFxuXG5cdGdldFNjYWxlRm9ySWQ6IGZ1bmN0aW9uKHNjYWxlSUQpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0VmFsdWVTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS54QXhpc0lEO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFNjYWxlRm9ySWQodGhpcy5fZ2V0VmFsdWVTY2FsZUlkKCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldEluZGV4U2NhbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFNjYWxlRm9ySWQodGhpcy5fZ2V0SW5kZXhTY2FsZUlkKCkpO1xuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZSh0cnVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7XG5cdFx0XHR1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRjcmVhdGVNZXRhRGF0YXNldDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdHlwZSA9IG1lLmRhdGFzZXRFbGVtZW50VHlwZTtcblx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XG5cdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9KTtcblx0fSxcblxuXHRjcmVhdGVNZXRhRGF0YTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0eXBlID0gbWUuZGF0YUVsZW1lbnRUeXBlO1xuXHRcdHJldHVybiB0eXBlICYmIG5ldyB0eXBlKHtcblx0XHRcdF9jaGFydDogbWUuY2hhcnQsXG5cdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdF9pbmRleDogaW5kZXhcblx0XHR9KTtcblx0fSxcblxuXHRhZGRFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhIHx8IFtdO1xuXHRcdHZhciBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWV0YURhdGFbaV0gPSBtZXRhRGF0YVtpXSB8fCBtZS5jcmVhdGVNZXRhRGF0YShpKTtcblx0XHR9XG5cblx0XHRtZXRhLmRhdGFzZXQgPSBtZXRhLmRhdGFzZXQgfHwgbWUuY3JlYXRlTWV0YURhdGFzZXQoKTtcblx0fSxcblxuXHRhZGRFbGVtZW50QW5kUmVzZXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmNyZWF0ZU1ldGFEYXRhKGluZGV4KTtcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNwbGljZShpbmRleCwgMCwgZWxlbWVudCk7XG5cdFx0dGhpcy51cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCB0cnVlKTtcblx0fSxcblxuXHRidWlsZE9yVXBkYXRlRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcblxuXHRcdC8vIEluIG9yZGVyIHRvIGNvcnJlY3RseSBoYW5kbGUgZGF0YSBhZGRpdGlvbi9kZWxldGlvbiBhbmltYXRpb24gKGFuIHRodXMgc2ltdWxhdGVcblx0XHQvLyByZWFsLXRpbWUgY2hhcnRzKSwgd2UgbmVlZCB0byBtb25pdG9yIHRoZXNlIGRhdGEgbW9kaWZpY2F0aW9ucyBhbmQgc3luY2hyb25pemVcblx0XHQvLyB0aGUgaW50ZXJuYWwgbWV0YSBkYXRhIGFjY29yZGluZ2x5LlxuXHRcdGlmIChtZS5fZGF0YSAhPT0gZGF0YSkge1xuXHRcdFx0aWYgKG1lLl9kYXRhKSB7XG5cdFx0XHRcdC8vIFRoaXMgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgaW5zdGFuY2UuXG5cdFx0XHRcdHVubGlzdGVuQXJyYXlFdmVudHMobWUuX2RhdGEsIG1lKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuXHRcdFx0XHRsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCBtZSk7XG5cdFx0XHR9XG5cdFx0XHRtZS5fZGF0YSA9IGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gUmUtc3luYyBtZXRhIGRhdGEgaW4gY2FzZSB0aGUgdXNlciByZXBsYWNlZCB0aGUgZGF0YSBhcnJheSBvciBpZiB3ZSBtaXNzZWRcblx0XHQvLyBhbnkgdXBkYXRlcyBhbmQgc28gbWFrZSBzdXJlIHRoYXQgd2UgaGFuZGxlIG51bWJlciBvZiBkYXRhcG9pbnRzIGNoYW5naW5nLlxuXHRcdG1lLnJlc3luY0VsZW1lbnRzKCk7XG5cdH0sXG5cblx0dXBkYXRlOiBoZWxwZXJzJDEubm9vcCxcblxuXHR0cmFuc2l0aW9uOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRlbGVtZW50c1tpXS50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0XHR9XG5cblx0XHRpZiAobWV0YS5kYXRhc2V0KSB7XG5cdFx0XHRtZXRhLmRhdGFzZXQudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGlmIChtZXRhLmRhdGFzZXQpIHtcblx0XHRcdG1ldGEuZGF0YXNldC5kcmF3KCk7XG5cdFx0fVxuXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGVsZW1lbnRzW2ldLmRyYXcoKTtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdGhlbHBlcnMkMS5tZXJnZShlbGVtZW50Ll9tb2RlbCwgZWxlbWVudC4kcHJldmlvdXNTdHlsZSB8fCB7fSk7XG5cdFx0ZGVsZXRlIGVsZW1lbnQuJHByZXZpb3VzU3R5bGU7XG5cdH0sXG5cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2VsZW1lbnQuX2RhdGFzZXRJbmRleF07XG5cdFx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBtb2RlbCA9IGVsZW1lbnQuX21vZGVsO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRlbGVtZW50LiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGhcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gcmVzb2x2ZShbY3VzdG9tLmhvdmVyQmFja2dyb3VuZENvbG9yLCBkYXRhc2V0LmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG1vZGVsLmJhY2tncm91bmRDb2xvcildLCB1bmRlZmluZWQsIGluZGV4KTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJvcmRlckNvbG9yLCBkYXRhc2V0LmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3IobW9kZWwuYm9yZGVyQ29sb3IpXSwgdW5kZWZpbmVkLCBpbmRleCk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSByZXNvbHZlKFtjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCwgZGF0YXNldC5ob3ZlckJvcmRlcldpZHRoLCBtb2RlbC5ib3JkZXJXaWR0aF0sIHVuZGVmaW5lZCwgaW5kZXgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVzeW5jRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGRhdGEgPSBtZS5nZXREYXRhc2V0KCkuZGF0YTtcblx0XHR2YXIgbnVtTWV0YSA9IG1ldGEuZGF0YS5sZW5ndGg7XG5cdFx0dmFyIG51bURhdGEgPSBkYXRhLmxlbmd0aDtcblxuXHRcdGlmIChudW1EYXRhIDwgbnVtTWV0YSkge1xuXHRcdFx0bWV0YS5kYXRhLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG5cdFx0fSBlbHNlIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuXHRcdFx0bWUuaW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGluc2VydEVsZW1lbnRzOiBmdW5jdGlvbihzdGFydCwgY291bnQpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcblx0XHRcdHRoaXMuYWRkRWxlbWVudEFuZFJlc2V0KHN0YXJ0ICsgaSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhUHVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHR0aGlzLmluc2VydEVsZW1lbnRzKHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50KTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVBvcDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5wb3AoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVNoaWZ0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNoaWZ0KCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFTcGxpY2U6IGZ1bmN0aW9uKHN0YXJ0LCBjb3VudCkge1xuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG5cdFx0dGhpcy5pbnNlcnRFbGVtZW50cyhzdGFydCwgYXJndW1lbnRzLmxlbmd0aCAtIDIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhVW5zaGlmdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pbnNlcnRFbGVtZW50cygwLCBhcmd1bWVudHMubGVuZ3RoKTtcblx0fVxufSk7XG5cbkRhdGFzZXRDb250cm9sbGVyLmV4dGVuZCA9IGhlbHBlcnMkMS5pbmhlcml0cztcblxudmFyIGNvcmVfZGF0YXNldENvbnRyb2xsZXIgPSBEYXRhc2V0Q29udHJvbGxlcjtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7XG5cdFx0YXJjOiB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiAnI2ZmZicsXG5cdFx0XHRib3JkZXJXaWR0aDogMixcblx0XHRcdGJvcmRlckFsaWduOiAnY2VudGVyJ1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBlbGVtZW50X2FyYyA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRpbkxhYmVsUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cblx0XHRpZiAodm0pIHtcblx0XHRcdHJldHVybiAoTWF0aC5wb3cobW91c2VYIC0gdm0ueCwgMikgPCBNYXRoLnBvdyh2bS5yYWRpdXMgKyB2bS5ob3ZlclJhZGl1cywgMikpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aW5SYW5nZTogZnVuY3Rpb24oY2hhcnRYLCBjaGFydFkpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtKSB7XG5cdFx0XHR2YXIgcG9pbnRSZWxhdGl2ZVBvc2l0aW9uID0gaGVscGVycyQxLmdldEFuZ2xlRnJvbVBvaW50KHZtLCB7eDogY2hhcnRYLCB5OiBjaGFydFl9KTtcblx0XHRcdHZhclx0YW5nbGUgPSBwb2ludFJlbGF0aXZlUG9zaXRpb24uYW5nbGU7XG5cdFx0XHR2YXIgZGlzdGFuY2UgPSBwb2ludFJlbGF0aXZlUG9zaXRpb24uZGlzdGFuY2U7XG5cblx0XHRcdC8vIFNhbml0aXNlIGFuZ2xlIHJhbmdlXG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IHZtLnN0YXJ0QW5nbGU7XG5cdFx0XHR2YXIgZW5kQW5nbGUgPSB2bS5lbmRBbmdsZTtcblx0XHRcdHdoaWxlIChlbmRBbmdsZSA8IHN0YXJ0QW5nbGUpIHtcblx0XHRcdFx0ZW5kQW5nbGUgKz0gMi4wICogTWF0aC5QSTtcblx0XHRcdH1cblx0XHRcdHdoaWxlIChhbmdsZSA+IGVuZEFuZ2xlKSB7XG5cdFx0XHRcdGFuZ2xlIC09IDIuMCAqIE1hdGguUEk7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoYW5nbGUgPCBzdGFydEFuZ2xlKSB7XG5cdFx0XHRcdGFuZ2xlICs9IDIuMCAqIE1hdGguUEk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgdGhlIG9wZW4vY2xvc2UgYW5nbGVcblx0XHRcdHZhciBiZXR3ZWVuQW5nbGVzID0gKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIHdpdGhpblJhZGl1cyA9IChkaXN0YW5jZSA+PSB2bS5pbm5lclJhZGl1cyAmJiBkaXN0YW5jZSA8PSB2bS5vdXRlclJhZGl1cyk7XG5cblx0XHRcdHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGhhbGZBbmdsZSA9ICh2bS5zdGFydEFuZ2xlICsgdm0uZW5kQW5nbGUpIC8gMjtcblx0XHR2YXIgaGFsZlJhZGl1cyA9ICh2bS5pbm5lclJhZGl1cyArIHZtLm91dGVyUmFkaXVzKSAvIDI7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLnggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcblx0XHRcdHk6IHZtLnkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuXHRcdH07XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gTWF0aC5QSSAqICgodm0uZW5kQW5nbGUgLSB2bS5zdGFydEFuZ2xlKSAvICgyICogTWF0aC5QSSkpICogKE1hdGgucG93KHZtLm91dGVyUmFkaXVzLCAyKSAtIE1hdGgucG93KHZtLmlubmVyUmFkaXVzLCAyKSk7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBjZW50cmVBbmdsZSA9IHZtLnN0YXJ0QW5nbGUgKyAoKHZtLmVuZEFuZ2xlIC0gdm0uc3RhcnRBbmdsZSkgLyAyKTtcblx0XHR2YXIgcmFuZ2VGcm9tQ2VudHJlID0gKHZtLm91dGVyUmFkaXVzIC0gdm0uaW5uZXJSYWRpdXMpIC8gMiArIHZtLmlubmVyUmFkaXVzO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLnggKyAoTWF0aC5jb3MoY2VudHJlQW5nbGUpICogcmFuZ2VGcm9tQ2VudHJlKSxcblx0XHRcdHk6IHZtLnkgKyAoTWF0aC5zaW4oY2VudHJlQW5nbGUpICogcmFuZ2VGcm9tQ2VudHJlKVxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBzQSA9IHZtLnN0YXJ0QW5nbGU7XG5cdFx0dmFyIGVBID0gdm0uZW5kQW5nbGU7XG5cdFx0dmFyIHBpeGVsTWFyZ2luID0gKHZtLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xuXHRcdHZhciBhbmdsZU1hcmdpbjtcblxuXHRcdGN0eC5zYXZlKCk7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyh2bS54LCB2bS55LCBNYXRoLm1heCh2bS5vdXRlclJhZGl1cyAtIHBpeGVsTWFyZ2luLCAwKSwgc0EsIGVBKTtcblx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLmlubmVyUmFkaXVzLCBlQSwgc0EsIHRydWUpO1xuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblxuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0Y3R4LmZpbGwoKTtcblxuXHRcdGlmICh2bS5ib3JkZXJXaWR0aCkge1xuXHRcdFx0aWYgKHZtLmJvcmRlckFsaWduID09PSAnaW5uZXInKSB7XG5cdFx0XHRcdC8vIERyYXcgYW4gaW5uZXIgYm9yZGVyIGJ5IGNsaXBpbmcgdGhlIGFyYyBhbmQgZHJhd2luZyBhIGRvdWJsZS13aWR0aCBib3JkZXJcblx0XHRcdFx0Ly8gRW5sYXJnZSB0aGUgY2xpcHBpbmcgYXJjIGJ5IDAuMzMgcGl4ZWxzIHRvIGVsaW1pbmF0ZSBnbGl0Y2hlcyBiZXR3ZWVuIGJvcmRlcnNcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gdm0ub3V0ZXJSYWRpdXM7XG5cdFx0XHRcdGN0eC5hcmModm0ueCwgdm0ueSwgdm0ub3V0ZXJSYWRpdXMsIHNBIC0gYW5nbGVNYXJnaW4sIGVBICsgYW5nbGVNYXJnaW4pO1xuXHRcdFx0XHRpZiAodm0uaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xuXHRcdFx0XHRcdGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyB2bS5pbm5lclJhZGl1cztcblx0XHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLmlubmVyUmFkaXVzIC0gcGl4ZWxNYXJnaW4sIGVBICsgYW5nbGVNYXJnaW4sIHNBIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eC5hcmModm0ueCwgdm0ueSwgcGl4ZWxNYXJnaW4sIGVBICsgTWF0aC5QSSAvIDIsIHNBIC0gTWF0aC5QSSAvIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0Y3R4LmNsaXAoKTtcblxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5hcmModm0ueCwgdm0ueSwgdm0ub3V0ZXJSYWRpdXMsIHNBLCBlQSk7XG5cdFx0XHRcdGN0eC5hcmModm0ueCwgdm0ueSwgdm0uaW5uZXJSYWRpdXMsIGVBLCBzQSwgdHJ1ZSk7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblxuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGggKiAyO1xuXHRcdFx0XHRjdHgubGluZUpvaW4gPSAncm91bmQnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoO1xuXHRcdFx0XHRjdHgubGluZUpvaW4gPSAnYmV2ZWwnO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvcjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9XG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDEgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbnZhciBkZWZhdWx0Q29sb3IgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdGxpbmU6IHtcblx0XHRcdHRlbnNpb246IDAuNCxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDMsXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yLFxuXHRcdFx0Ym9yZGVyQ2FwU3R5bGU6ICdidXR0Jyxcblx0XHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdFx0Ym9yZGVyRGFzaE9mZnNldDogMC4wLFxuXHRcdFx0Ym9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuXHRcdFx0Y2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuXHRcdFx0ZmlsbDogdHJ1ZSwgLy8gZG8gd2UgZmlsbCBpbiB0aGUgYXJlYSBiZXR3ZWVuIHRoZSBsaW5lIGFuZCBpdHMgYmFzZSBheGlzXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGVsZW1lbnRfbGluZSA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB2bSA9IG1lLl92aWV3O1xuXHRcdHZhciBjdHggPSBtZS5fY2hhcnQuY3R4O1xuXHRcdHZhciBzcGFuR2FwcyA9IHZtLnNwYW5HYXBzO1xuXHRcdHZhciBwb2ludHMgPSBtZS5fY2hpbGRyZW4uc2xpY2UoKTsgLy8gY2xvbmUgYXJyYXlcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzID0gZ2xvYmFsRGVmYXVsdHMuZWxlbWVudHMubGluZTtcblx0XHR2YXIgbGFzdERyYXduSW5kZXggPSAtMTtcblx0XHR2YXIgaW5kZXgsIGN1cnJlbnQsIHByZXZpb3VzLCBjdXJyZW50Vk07XG5cblx0XHQvLyBJZiB3ZSBhcmUgbG9vcGluZywgYWRkaW5nIHRoZSBmaXJzdCBwb2ludCBhZ2FpblxuXHRcdGlmIChtZS5fbG9vcCAmJiBwb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRwb2ludHMucHVzaChwb2ludHNbMF0pO1xuXHRcdH1cblxuXHRcdGN0eC5zYXZlKCk7XG5cblx0XHQvLyBTdHJva2UgTGluZSBPcHRpb25zXG5cdFx0Y3R4LmxpbmVDYXAgPSB2bS5ib3JkZXJDYXBTdHlsZSB8fCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyQ2FwU3R5bGU7XG5cblx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcblx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRjdHguc2V0TGluZURhc2godm0uYm9yZGVyRGFzaCB8fCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyRGFzaCk7XG5cdFx0fVxuXG5cdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQkMSh2bS5ib3JkZXJEYXNoT2Zmc2V0LCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyRGFzaE9mZnNldCk7XG5cdFx0Y3R4LmxpbmVKb2luID0gdm0uYm9yZGVySm9pblN0eWxlIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJKb2luU3R5bGU7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDEodm0uYm9yZGVyV2lkdGgsIGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJXaWR0aCk7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3IgfHwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yO1xuXG5cdFx0Ly8gU3Ryb2tlIExpbmVcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0bGFzdERyYXduSW5kZXggPSAtMTtcblxuXHRcdGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcblx0XHRcdGN1cnJlbnQgPSBwb2ludHNbaW5kZXhdO1xuXHRcdFx0cHJldmlvdXMgPSBoZWxwZXJzJDEucHJldmlvdXNJdGVtKHBvaW50cywgaW5kZXgpO1xuXHRcdFx0Y3VycmVudFZNID0gY3VycmVudC5fdmlldztcblxuXHRcdFx0Ly8gRmlyc3QgcG9pbnQgbW92ZXMgdG8gaXQncyBzdGFydGluZyBwb3NpdGlvbiBubyBtYXR0ZXIgd2hhdFxuXHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRcdGlmICghY3VycmVudFZNLnNraXApIHtcblx0XHRcdFx0XHRjdHgubW92ZVRvKGN1cnJlbnRWTS54LCBjdXJyZW50Vk0ueSk7XG5cdFx0XHRcdFx0bGFzdERyYXduSW5kZXggPSBpbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJldmlvdXMgPSBsYXN0RHJhd25JbmRleCA9PT0gLTEgPyBwcmV2aW91cyA6IHBvaW50c1tsYXN0RHJhd25JbmRleF07XG5cblx0XHRcdFx0aWYgKCFjdXJyZW50Vk0uc2tpcCkge1xuXHRcdFx0XHRcdGlmICgobGFzdERyYXduSW5kZXggIT09IChpbmRleCAtIDEpICYmICFzcGFuR2FwcykgfHwgbGFzdERyYXduSW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdFx0XHQvLyBUaGVyZSB3YXMgYSBnYXAgYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHBvaW50IGFmdGVyIHRoZSBnYXBcblx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8oY3VycmVudFZNLngsIGN1cnJlbnRWTS55KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gTGluZSB0byBuZXh0IHBvaW50XG5cdFx0XHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLmxpbmVUbyhjdHgsIHByZXZpb3VzLl92aWV3LCBjdXJyZW50Ll92aWV3KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFzdERyYXduSW5kZXggPSBpbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGN0eC5zdHJva2UoKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9XG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDIgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbnZhciBkZWZhdWx0Q29sb3IkMSA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7XG5cdFx0cG9pbnQ6IHtcblx0XHRcdHJhZGl1czogMyxcblx0XHRcdHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0Q29sb3IkMSxcblx0XHRcdGJvcmRlckNvbG9yOiBkZWZhdWx0Q29sb3IkMSxcblx0XHRcdGJvcmRlcldpZHRoOiAxLFxuXHRcdFx0Ly8gSG92ZXJcblx0XHRcdGhpdFJhZGl1czogMSxcblx0XHRcdGhvdmVyUmFkaXVzOiA0LFxuXHRcdFx0aG92ZXJCb3JkZXJXaWR0aDogMVxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIHhSYW5nZShtb3VzZVgpIHtcblx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0cmV0dXJuIHZtID8gKE1hdGguYWJzKG1vdXNlWCAtIHZtLngpIDwgdm0ucmFkaXVzICsgdm0uaGl0UmFkaXVzKSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiB5UmFuZ2UobW91c2VZKSB7XG5cdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdHJldHVybiB2bSA/IChNYXRoLmFicyhtb3VzZVkgLSB2bS55KSA8IHZtLnJhZGl1cyArIHZtLmhpdFJhZGl1cykgOiBmYWxzZTtcbn1cblxudmFyIGVsZW1lbnRfcG9pbnQgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0aW5SYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB2bSA/ICgoTWF0aC5wb3cobW91c2VYIC0gdm0ueCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB2bS55LCAyKSkgPCBNYXRoLnBvdyh2bS5oaXRSYWRpdXMgKyB2bS5yYWRpdXMsIDIpKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGluTGFiZWxSYW5nZTogeFJhbmdlLFxuXHRpblhSYW5nZTogeFJhbmdlLFxuXHRpbllSYW5nZTogeVJhbmdlLFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54LFxuXHRcdFx0eTogdm0ueVxuXHRcdH07XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLl92aWV3LnJhZGl1cywgMik7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54LFxuXHRcdFx0eTogdm0ueSxcblx0XHRcdHBhZGRpbmc6IHZtLnJhZGl1cyArIHZtLmJvcmRlcldpZHRoXG5cdFx0fTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihjaGFydEFyZWEpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHBvaW50U3R5bGUgPSB2bS5wb2ludFN0eWxlO1xuXHRcdHZhciByb3RhdGlvbiA9IHZtLnJvdGF0aW9uO1xuXHRcdHZhciByYWRpdXMgPSB2bS5yYWRpdXM7XG5cdFx0dmFyIHggPSB2bS54O1xuXHRcdHZhciB5ID0gdm0ueTtcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgZGVmYXVsdENvbG9yID0gZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuXG5cdFx0aWYgKHZtLnNraXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDbGlwcGluZyBmb3IgUG9pbnRzLlxuXHRcdGlmIChjaGFydEFyZWEgPT09IHVuZGVmaW5lZCB8fCBoZWxwZXJzJDEuY2FudmFzLl9pc1BvaW50SW5BcmVhKHZtLCBjaGFydEFyZWEpKSB7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvciB8fCBkZWZhdWx0Q29sb3I7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkMih2bS5ib3JkZXJXaWR0aCwgZ2xvYmFsRGVmYXVsdHMuZWxlbWVudHMucG9pbnQuYm9yZGVyV2lkdGgpO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvciB8fCBkZWZhdWx0Q29sb3I7XG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmRyYXdQb2ludChjdHgsIHBvaW50U3R5bGUsIHJhZGl1cywgeCwgeSwgcm90YXRpb24pO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBkZWZhdWx0Q29sb3IkMiA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7XG5cdFx0cmVjdGFuZ2xlOiB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvciQyLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvciQyLFxuXHRcdFx0Ym9yZGVyU2tpcHBlZDogJ2JvdHRvbScsXG5cdFx0XHRib3JkZXJXaWR0aDogMFxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGlzVmVydGljYWwodm0pIHtcblx0cmV0dXJuIHZtICYmIHZtLndpZHRoICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSBiYXIge0NoYXJ0LkVsZW1lbnQuUmVjdGFuZ2xlfSB0aGUgYmFyXG4gKiBAcmV0dXJuIHtCb3VuZHN9IGJvdW5kcyBvZiB0aGUgYmFyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHModm0pIHtcblx0dmFyIHgxLCB4MiwgeTEsIHkyLCBoYWxmO1xuXG5cdGlmIChpc1ZlcnRpY2FsKHZtKSkge1xuXHRcdGhhbGYgPSB2bS53aWR0aCAvIDI7XG5cdFx0eDEgPSB2bS54IC0gaGFsZjtcblx0XHR4MiA9IHZtLnggKyBoYWxmO1xuXHRcdHkxID0gTWF0aC5taW4odm0ueSwgdm0uYmFzZSk7XG5cdFx0eTIgPSBNYXRoLm1heCh2bS55LCB2bS5iYXNlKTtcblx0fSBlbHNlIHtcblx0XHRoYWxmID0gdm0uaGVpZ2h0IC8gMjtcblx0XHR4MSA9IE1hdGgubWluKHZtLngsIHZtLmJhc2UpO1xuXHRcdHgyID0gTWF0aC5tYXgodm0ueCwgdm0uYmFzZSk7XG5cdFx0eTEgPSB2bS55IC0gaGFsZjtcblx0XHR5MiA9IHZtLnkgKyBoYWxmO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRsZWZ0OiB4MSxcblx0XHR0b3A6IHkxLFxuXHRcdHJpZ2h0OiB4Mixcblx0XHRib3R0b206IHkyXG5cdH07XG59XG5cbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XG5cdHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyU2tpcHBlZCh2bSkge1xuXHR2YXIgZWRnZSA9IHZtLmJvcmRlclNraXBwZWQ7XG5cdHZhciByZXMgPSB7fTtcblxuXHRpZiAoIWVkZ2UpIHtcblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0aWYgKHZtLmhvcml6b250YWwpIHtcblx0XHRpZiAodm0uYmFzZSA+IHZtLngpIHtcblx0XHRcdGVkZ2UgPSBzd2FwKGVkZ2UsICdsZWZ0JywgJ3JpZ2h0Jyk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHZtLmJhc2UgPCB2bS55KSB7XG5cdFx0ZWRnZSA9IHN3YXAoZWRnZSwgJ2JvdHRvbScsICd0b3AnKTtcblx0fVxuXG5cdHJlc1tlZGdlXSA9IHRydWU7XG5cdHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgodm0sIG1heFcsIG1heEgpIHtcblx0dmFyIHZhbHVlID0gdm0uYm9yZGVyV2lkdGg7XG5cdHZhciBza2lwID0gcGFyc2VCb3JkZXJTa2lwcGVkKHZtKTtcblx0dmFyIHQsIHIsIGIsIGw7XG5cblx0aWYgKGhlbHBlcnMkMS5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHR0ID0gK3ZhbHVlLnRvcCB8fCAwO1xuXHRcdHIgPSArdmFsdWUucmlnaHQgfHwgMDtcblx0XHRiID0gK3ZhbHVlLmJvdHRvbSB8fCAwO1xuXHRcdGwgPSArdmFsdWUubGVmdCB8fCAwO1xuXHR9IGVsc2Uge1xuXHRcdHQgPSByID0gYiA9IGwgPSArdmFsdWUgfHwgMDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0dDogc2tpcC50b3AgfHwgKHQgPCAwKSA/IDAgOiB0ID4gbWF4SCA/IG1heEggOiB0LFxuXHRcdHI6IHNraXAucmlnaHQgfHwgKHIgPCAwKSA/IDAgOiByID4gbWF4VyA/IG1heFcgOiByLFxuXHRcdGI6IHNraXAuYm90dG9tIHx8IChiIDwgMCkgPyAwIDogYiA+IG1heEggPyBtYXhIIDogYixcblx0XHRsOiBza2lwLmxlZnQgfHwgKGwgPCAwKSA/IDAgOiBsID4gbWF4VyA/IG1heFcgOiBsXG5cdH07XG59XG5cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHModm0pIHtcblx0dmFyIGJvdW5kcyA9IGdldEJhckJvdW5kcyh2bSk7XG5cdHZhciB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuXHR2YXIgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG5cdHZhciBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKHZtLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXG5cdHJldHVybiB7XG5cdFx0b3V0ZXI6IHtcblx0XHRcdHg6IGJvdW5kcy5sZWZ0LFxuXHRcdFx0eTogYm91bmRzLnRvcCxcblx0XHRcdHc6IHdpZHRoLFxuXHRcdFx0aDogaGVpZ2h0XG5cdFx0fSxcblx0XHRpbm5lcjoge1xuXHRcdFx0eDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcblx0XHRcdHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcblx0XHRcdHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcblx0XHRcdGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmJcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGluUmFuZ2Uodm0sIHgsIHkpIHtcblx0dmFyIHNraXBYID0geCA9PT0gbnVsbDtcblx0dmFyIHNraXBZID0geSA9PT0gbnVsbDtcblx0dmFyIGJvdW5kcyA9ICF2bSB8fCAoc2tpcFggJiYgc2tpcFkpID8gZmFsc2UgOiBnZXRCYXJCb3VuZHModm0pO1xuXG5cdHJldHVybiBib3VuZHNcblx0XHQmJiAoc2tpcFggfHwgeCA+PSBib3VuZHMubGVmdCAmJiB4IDw9IGJvdW5kcy5yaWdodClcblx0XHQmJiAoc2tpcFkgfHwgeSA+PSBib3VuZHMudG9wICYmIHkgPD0gYm91bmRzLmJvdHRvbSk7XG59XG5cbnZhciBlbGVtZW50X3JlY3RhbmdsZSA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIHJlY3RzID0gYm91bmRpbmdSZWN0cyh2bSk7XG5cdFx0dmFyIG91dGVyID0gcmVjdHMub3V0ZXI7XG5cdFx0dmFyIGlubmVyID0gcmVjdHMuaW5uZXI7XG5cblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5maWxsUmVjdChvdXRlci54LCBvdXRlci55LCBvdXRlci53LCBvdXRlci5oKTtcblxuXHRcdGlmIChvdXRlci53ID09PSBpbm5lci53ICYmIG91dGVyLmggPT09IGlubmVyLmgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdChvdXRlci54LCBvdXRlci55LCBvdXRlci53LCBvdXRlci5oKTtcblx0XHRjdHguY2xpcCgpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5ib3JkZXJDb2xvcjtcblx0XHRjdHgucmVjdChpbm5lci54LCBpbm5lci55LCBpbm5lci53LCBpbm5lci5oKTtcblx0XHRjdHguZmlsbCgnZXZlbm9kZCcpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH0sXG5cblx0aGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB2bS5iYXNlIC0gdm0ueTtcblx0fSxcblxuXHRpblJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdHJldHVybiBpblJhbmdlKHRoaXMuX3ZpZXcsIG1vdXNlWCwgbW91c2VZKTtcblx0fSxcblxuXHRpbkxhYmVsUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gaXNWZXJ0aWNhbCh2bSlcblx0XHRcdD8gaW5SYW5nZSh2bSwgbW91c2VYLCBudWxsKVxuXHRcdFx0OiBpblJhbmdlKHZtLCBudWxsLCBtb3VzZVkpO1xuXHR9LFxuXG5cdGluWFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBtb3VzZVgsIG51bGwpO1xuXHR9LFxuXG5cdGluWVJhbmdlOiBmdW5jdGlvbihtb3VzZVkpIHtcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBudWxsLCBtb3VzZVkpO1xuXHR9LFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciB4LCB5O1xuXHRcdGlmIChpc1ZlcnRpY2FsKHZtKSkge1xuXHRcdFx0eCA9IHZtLng7XG5cdFx0XHR5ID0gKHZtLnkgKyB2bS5iYXNlKSAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSAodm0ueCArIHZtLmJhc2UpIC8gMjtcblx0XHRcdHkgPSB2bS55O1xuXHRcdH1cblxuXHRcdHJldHVybiB7eDogeCwgeTogeX07XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdHJldHVybiBpc1ZlcnRpY2FsKHZtKVxuXHRcdFx0PyB2bS53aWR0aCAqIE1hdGguYWJzKHZtLnkgLSB2bS5iYXNlKVxuXHRcdFx0OiB2bS5oZWlnaHQgKiBNYXRoLmFicyh2bS54IC0gdm0uYmFzZSk7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54LFxuXHRcdFx0eTogdm0ueVxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgZWxlbWVudHMgPSB7fTtcbnZhciBBcmMgPSBlbGVtZW50X2FyYztcbnZhciBMaW5lID0gZWxlbWVudF9saW5lO1xudmFyIFBvaW50ID0gZWxlbWVudF9wb2ludDtcbnZhciBSZWN0YW5nbGUgPSBlbGVtZW50X3JlY3RhbmdsZTtcbmVsZW1lbnRzLkFyYyA9IEFyYztcbmVsZW1lbnRzLkxpbmUgPSBMaW5lO1xuZWxlbWVudHMuUG9pbnQgPSBQb2ludDtcbmVsZW1lbnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcblxudmFyIHJlc29sdmUkMSA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnYmFyJywge1xuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdsYWJlbCdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdjYXRlZ29yeScsXG5cdFx0XHRjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcblx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOSxcblx0XHRcdG9mZnNldDogdHJ1ZSxcblx0XHRcdGdyaWRMaW5lczoge1xuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcblx0XHRcdH1cblx0XHR9XSxcblxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcidcblx0XHR9XVxuXHR9XG59KTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgXCJvcHRpbWFsXCIgc2FtcGxlIHNpemUgdG8gbWFpbnRhaW4gYmFycyBlcXVhbGx5IHNpemVkIHdoaWxlIHByZXZlbnRpbmcgb3ZlcmxhcC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKHNjYWxlLCBwaXhlbHMpIHtcblx0dmFyIG1pbiA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpID8gc2NhbGUud2lkdGggOiBzY2FsZS5oZWlnaHQ7XG5cdHZhciB0aWNrcyA9IHNjYWxlLmdldFRpY2tzKCk7XG5cdHZhciBwcmV2LCBjdXJyLCBpLCBpbGVuO1xuXG5cdGZvciAoaSA9IDEsIGlsZW4gPSBwaXhlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0bWluID0gTWF0aC5taW4obWluLCBNYXRoLmFicyhwaXhlbHNbaV0gLSBwaXhlbHNbaSAtIDFdKSk7XG5cdH1cblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0Y3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcblx0XHRtaW4gPSBpID4gMCA/IE1hdGgubWluKG1pbiwgY3VyciAtIHByZXYpIDogbWluO1xuXHRcdHByZXYgPSBjdXJyO1xuXHR9XG5cblx0cmV0dXJuIG1pbjtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBcImlkZWFsXCIgY2F0ZWdvcnkgYmFzZWQgb24gdGhlIGFic29sdXRlIGJhciB0aGlja25lc3Mgb3IsIGlmIHVuZGVmaW5lZCBvciBudWxsLFxuICogdXNlcyB0aGUgc21hbGxlc3QgaW50ZXJ2YWwgKHNlZSBjb21wdXRlTWluU2FtcGxlU2l6ZSkgdGhhdCBwcmV2ZW50cyBiYXIgb3ZlcmxhcHBpbmcuIFRoaXNcbiAqIG1vZGUgY3VycmVudGx5IGFsd2F5cyBnZW5lcmF0ZXMgYmFycyBlcXVhbGx5IHNpemVkICh1bnRpbCB3ZSBpbnRyb2R1Y2Ugc2NyaXB0YWJsZSBvcHRpb25zPykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKSB7XG5cdHZhciB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcblx0dmFyIGNvdW50ID0gcnVsZXIuc3RhY2tDb3VudDtcblx0dmFyIGN1cnIgPSBydWxlci5waXhlbHNbaW5kZXhdO1xuXHR2YXIgc2l6ZSwgcmF0aW87XG5cblx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcblx0XHRzaXplID0gcnVsZXIubWluICogb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG5cdFx0cmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gV2hlbiBiYXIgdGhpY2tuZXNzIGlzIGVuZm9yY2VkLCBjYXRlZ29yeSBhbmQgYmFyIHBlcmNlbnRhZ2VzIGFyZSBpZ25vcmVkLlxuXHRcdC8vIE5vdGUoU0IpOiB3ZSBjb3VsZCBhZGQgc3VwcG9ydCBmb3IgcmVsYXRpdmUgYmFyIHRoaWNrbmVzcyAoZS5nLiBiYXJUaGlja25lc3M6ICc1MCUnKVxuXHRcdC8vIGFuZCBkZXByZWNhdGUgYmFyUGVyY2VudGFnZSBzaW5jZSB0aGlzIHZhbHVlIGlzIGlnbm9yZWQgd2hlbiB0aGlja25lc3MgaXMgYWJzb2x1dGUuXG5cdFx0c2l6ZSA9IHRoaWNrbmVzcyAqIGNvdW50O1xuXHRcdHJhdGlvID0gMTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Y2h1bms6IHNpemUgLyBjb3VudCxcblx0XHRyYXRpbzogcmF0aW8sXG5cdFx0c3RhcnQ6IGN1cnIgLSAoc2l6ZSAvIDIpXG5cdH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJvcHRpbWFsXCIgY2F0ZWdvcnkgdGhhdCBnbG9iYWxseSBhcnJhbmdlcyBiYXJzIHNpZGUgYnkgc2lkZSAobm8gZ2FwIHdoZW5cbiAqIHBlcmNlbnRhZ2Ugb3B0aW9ucyBhcmUgMSksIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBhbmQgZm9sbG93aW5nIGNhdGVnb3JpZXMuIFRoaXMgbW9kZVxuICogZ2VuZXJhdGVzIGJhcnMgd2l0aCBkaWZmZXJlbnQgd2lkdGhzIHdoZW4gZGF0YSBhcmUgbm90IGV2ZW5seSBzcGFjZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucykge1xuXHR2YXIgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuXHR2YXIgY3VyciA9IHBpeGVsc1tpbmRleF07XG5cdHZhciBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xuXHR2YXIgbmV4dCA9IGluZGV4IDwgcGl4ZWxzLmxlbmd0aCAtIDEgPyBwaXhlbHNbaW5kZXggKyAxXSA6IG51bGw7XG5cdHZhciBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG5cdHZhciBzdGFydCwgc2l6ZTtcblxuXHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdC8vIGZpcnN0IGRhdGE6IGl0cyBzaXplIGlzIGRvdWJsZSBiYXNlZCBvbiB0aGUgbmV4dCBwb2ludCBvcixcblx0XHQvLyBpZiBpdCdzIGFsc28gdGhlIGxhc3QgZGF0YSwgd2UgdXNlIHRoZSBzY2FsZSBzaXplLlxuXHRcdHByZXYgPSBjdXJyIC0gKG5leHQgPT09IG51bGwgPyBydWxlci5lbmQgLSBydWxlci5zdGFydCA6IG5leHQgLSBjdXJyKTtcblx0fVxuXG5cdGlmIChuZXh0ID09PSBudWxsKSB7XG5cdFx0Ly8gbGFzdCBkYXRhOiBpdHMgc2l6ZSBpcyBhbHNvIGRvdWJsZSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcG9pbnQuXG5cdFx0bmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcblx0fVxuXG5cdHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XG5cdHNpemUgPSBNYXRoLmFicyhuZXh0IC0gcHJldikgLyAyICogcGVyY2VudDtcblxuXHRyZXR1cm4ge1xuXHRcdGNodW5rOiBzaXplIC8gcnVsZXIuc3RhY2tDb3VudCxcblx0XHRyYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxuXHRcdHN0YXJ0OiBzdGFydFxuXHR9O1xufVxuXG52YXIgY29udHJvbGxlcl9iYXIgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5SZWN0YW5nbGUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YTtcblxuXHRcdGNvcmVfZGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cblx0XHRtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdG1ldGEuc3RhY2sgPSBtZS5nZXREYXRhc2V0KCkuc3RhY2s7XG5cdFx0bWV0YS5iYXIgPSB0cnVlO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciByZWN0cyA9IG1lLmdldE1ldGEoKS5kYXRhO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0bWUuX3J1bGVyID0gbWUuZ2V0UnVsZXIoKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSByZWN0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocmVjdHNbaV0sIGksIHJlc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhyZWN0YW5nbGUsIGluZGV4KTtcblxuXHRcdHJlY3RhbmdsZS5feFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xuXHRcdHJlY3RhbmdsZS5feVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHJlY3RhbmdsZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0cmVjdGFuZ2xlLl9pbmRleCA9IGluZGV4O1xuXHRcdHJlY3RhbmdsZS5fbW9kZWwgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJTa2lwcGVkOiBvcHRpb25zLmJvcmRlclNraXBwZWQsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdGRhdGFzZXRMYWJlbDogZGF0YXNldC5sYWJlbCxcblx0XHRcdGxhYmVsOiBtZS5jaGFydC5kYXRhLmxhYmVsc1tpbmRleF1cblx0XHR9O1xuXG5cdFx0bWUuX3VwZGF0ZUVsZW1lbnRHZW9tZXRyeShyZWN0YW5nbGUsIGluZGV4LCByZXNldCk7XG5cblx0XHRyZWN0YW5nbGUucGl2b3QoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF91cGRhdGVFbGVtZW50R2VvbWV0cnk6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbW9kZWwgPSByZWN0YW5nbGUuX21vZGVsO1xuXHRcdHZhciB2c2NhbGUgPSBtZS5fZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdHZhciBiYXNlID0gdnNjYWxlLmdldEJhc2VQaXhlbCgpO1xuXHRcdHZhciBob3Jpem9udGFsID0gdnNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBydWxlciA9IG1lLl9ydWxlciB8fCBtZS5nZXRSdWxlcigpO1xuXHRcdHZhciB2cGl4ZWxzID0gbWUuY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMobWUuaW5kZXgsIGluZGV4KTtcblx0XHR2YXIgaXBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKG1lLmluZGV4LCBpbmRleCwgcnVsZXIpO1xuXG5cdFx0bW9kZWwuaG9yaXpvbnRhbCA9IGhvcml6b250YWw7XG5cdFx0bW9kZWwuYmFzZSA9IHJlc2V0ID8gYmFzZSA6IHZwaXhlbHMuYmFzZTtcblx0XHRtb2RlbC54ID0gaG9yaXpvbnRhbCA/IHJlc2V0ID8gYmFzZSA6IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyO1xuXHRcdG1vZGVsLnkgPSBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmhlYWQ7XG5cdFx0bW9kZWwuaGVpZ2h0ID0gaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IHVuZGVmaW5lZDtcblx0XHRtb2RlbC53aWR0aCA9IGhvcml6b250YWwgPyB1bmRlZmluZWQgOiBpcGl4ZWxzLnNpemU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xhc3RdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgbGlzdCBvZiBzdGFjayBJRHNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRTdGFja3M6IGZ1bmN0aW9uKGxhc3QpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRJbmRleFNjYWxlKCk7XG5cdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG5cdFx0dmFyIGlsZW4gPSBsYXN0ID09PSB1bmRlZmluZWQgPyBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCA6IGxhc3QgKyAxO1xuXHRcdHZhciBzdGFja3MgPSBbXTtcblx0XHR2YXIgaSwgbWV0YTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdGlmIChtZXRhLmJhciAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpICYmXG5cdFx0XHRcdChzdGFja2VkID09PSBmYWxzZSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdHJ1ZSAmJiBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEpIHx8XG5cdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgKG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEpKSkpIHtcblx0XHRcdFx0c3RhY2tzLnB1c2gobWV0YS5zdGFjayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0YWNrcztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIG51bWJlciBvZiBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFN0YWNrQ291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRTdGFja3MoKS5sZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFzZXRJbmRleF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3RhY2sgaW5kZXhcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFN0YWNrSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgbmFtZSkge1xuXHRcdHZhciBzdGFja3MgPSB0aGlzLl9nZXRTdGFja3MoZGF0YXNldEluZGV4KTtcblx0XHR2YXIgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0PyBzdGFja3MuaW5kZXhPZihuYW1lKVxuXHRcdFx0OiAtMTsgLy8gaW5kZXhPZiByZXR1cm5zIC0xIGlmIGVsZW1lbnQgaXMgbm90IHByZXNlbnRcblxuXHRcdHJldHVybiAoaW5kZXggPT09IC0xKVxuXHRcdFx0PyBzdGFja3MubGVuZ3RoIC0gMVxuXHRcdFx0OiBpbmRleDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFJ1bGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRJbmRleFNjYWxlKCk7XG5cdFx0dmFyIHN0YWNrQ291bnQgPSBtZS5nZXRTdGFja0NvdW50KCk7XG5cdFx0dmFyIGRhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgc3RhcnQgPSBpc0hvcml6b250YWwgPyBzY2FsZS5sZWZ0IDogc2NhbGUudG9wO1xuXHRcdHZhciBlbmQgPSBzdGFydCArIChpc0hvcml6b250YWwgPyBzY2FsZS53aWR0aCA6IHNjYWxlLmhlaWdodCk7XG5cdFx0dmFyIHBpeGVscyA9IFtdO1xuXHRcdHZhciBpLCBpbGVuLCBtaW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbWUuZ2V0TWV0YSgpLmRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRwaXhlbHMucHVzaChzY2FsZS5nZXRQaXhlbEZvclZhbHVlKG51bGwsIGksIGRhdGFzZXRJbmRleCkpO1xuXHRcdH1cblxuXHRcdG1pbiA9IGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHNjYWxlLm9wdGlvbnMuYmFyVGhpY2tuZXNzKVxuXHRcdFx0PyBjb21wdXRlTWluU2FtcGxlU2l6ZShzY2FsZSwgcGl4ZWxzKVxuXHRcdFx0OiAtMTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRtaW46IG1pbixcblx0XHRcdHBpeGVsczogcGl4ZWxzLFxuXHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0ZW5kOiBlbmQsXG5cdFx0XHRzdGFja0NvdW50OiBzdGFja0NvdW50LFxuXHRcdFx0c2NhbGU6IHNjYWxlXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogTm90ZTogcGl4ZWwgdmFsdWVzIGFyZSBub3QgY2xhbXBlZCB0byB0aGUgc2NhbGUgYXJlYS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciB2YWx1ZSA9ICtzY2FsZS5nZXRSaWdodFZhbHVlKGRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHRcdHZhciBtaW5CYXJMZW5ndGggPSBzY2FsZS5vcHRpb25zLm1pbkJhckxlbmd0aDtcblx0XHR2YXIgc3RhY2tlZCA9IHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcblx0XHR2YXIgc3RhY2sgPSBtZXRhLnN0YWNrO1xuXHRcdHZhciBzdGFydCA9IDA7XG5cdFx0dmFyIGksIGltZXRhLCBpdmFsdWUsIGJhc2UsIGhlYWQsIHNpemU7XG5cblx0XHRpZiAoc3RhY2tlZCB8fCAoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIHN0YWNrICE9PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcblx0XHRcdFx0aW1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblxuXHRcdFx0XHRpZiAoaW1ldGEuYmFyICYmXG5cdFx0XHRcdFx0aW1ldGEuc3RhY2sgPT09IHN0YWNrICYmXG5cdFx0XHRcdFx0aW1ldGEuY29udHJvbGxlci5fZ2V0VmFsdWVTY2FsZUlkKCkgPT09IHNjYWxlLmlkICYmXG5cdFx0XHRcdFx0Y2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXG5cdFx0XHRcdFx0aXZhbHVlID0gK3NjYWxlLmdldFJpZ2h0VmFsdWUoZGF0YXNldHNbaV0uZGF0YVtpbmRleF0pO1xuXHRcdFx0XHRcdGlmICgodmFsdWUgPCAwICYmIGl2YWx1ZSA8IDApIHx8ICh2YWx1ZSA+PSAwICYmIGl2YWx1ZSA+IDApKSB7XG5cdFx0XHRcdFx0XHRzdGFydCArPSBpdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YmFzZSA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQpO1xuXHRcdGhlYWQgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgdmFsdWUpO1xuXHRcdHNpemUgPSBoZWFkIC0gYmFzZTtcblxuXHRcdGlmIChtaW5CYXJMZW5ndGggIT09IHVuZGVmaW5lZCAmJiBNYXRoLmFicyhzaXplKSA8IG1pbkJhckxlbmd0aCkge1xuXHRcdFx0c2l6ZSA9IG1pbkJhckxlbmd0aDtcblx0XHRcdGlmICh2YWx1ZSA+PSAwICYmICFpc0hvcml6b250YWwgfHwgdmFsdWUgPCAwICYmIGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRoZWFkID0gYmFzZSAtIG1pbkJhckxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhlYWQgPSBiYXNlICsgbWluQmFyTGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0YmFzZTogYmFzZSxcblx0XHRcdGhlYWQ6IGhlYWQsXG5cdFx0XHRjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjYWxjdWxhdGVCYXJJbmRleFBpeGVsczogZnVuY3Rpb24oZGF0YXNldEluZGV4LCBpbmRleCwgcnVsZXIpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gcnVsZXIuc2NhbGUub3B0aW9ucztcblx0XHR2YXIgcmFuZ2UgPSBvcHRpb25zLmJhclRoaWNrbmVzcyA9PT0gJ2ZsZXgnXG5cdFx0XHQ/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKVxuXHRcdFx0OiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKTtcblxuXHRcdHZhciBzdGFja0luZGV4ID0gbWUuZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG1lLmdldE1ldGEoKS5zdGFjayk7XG5cdFx0dmFyIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcblx0XHR2YXIgc2l6ZSA9IE1hdGgubWluKFxuXHRcdFx0aGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubWF4QmFyVGhpY2tuZXNzLCBJbmZpbml0eSksXG5cdFx0XHRyYW5nZS5jaHVuayAqIHJhbmdlLnJhdGlvKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcblx0XHRcdGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXG5cdFx0XHRzaXplOiBzaXplXG5cdFx0fTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRWYWx1ZVNjYWxlKCk7XG5cdFx0dmFyIHJlY3RzID0gbWUuZ2V0TWV0YSgpLmRhdGE7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGlsZW4gPSByZWN0cy5sZW5ndGg7XG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0aGVscGVycyQxLmNhbnZhcy5jbGlwQXJlYShjaGFydC5jdHgsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKCFpc05hTihzY2FsZS5nZXRSaWdodFZhbHVlKGRhdGFzZXQuZGF0YVtpXSkpKSB7XG5cdFx0XHRcdHJlY3RzW2ldLmRyYXcoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY2hhcnQuY3R4KTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlRWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGRhdGFzZXQgPSBkYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IHJlY3RhbmdsZS5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLnJlY3RhbmdsZTtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlclNraXBwZWQnLFxuXHRcdFx0J2JvcmRlcldpZHRoJ1xuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkMShbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH1cbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkMyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcbnZhciByZXNvbHZlJDIgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2J1YmJsZScsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsIC8vIGJ1YmJsZSBzaG91bGQgcHJvYmFibHkgdXNlIGEgbGluZWFyIHNjYWxlIGJ5IGRlZmF1bHRcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJyxcblx0XHRcdGlkOiAneC1heGlzLTAnIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0Jyxcblx0XHRcdGlkOiAneS1heGlzLTAnXG5cdFx0fV1cblx0fSxcblxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBUaXRsZSBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2Ugd2UgZm9ybWF0IHRoZSBkYXRhIGFzIGEgcG9pbnRcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBkYXRhc2V0TGFiZWwgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcblx0XHRcdFx0dmFyIGRhdGFQb2ludCA9IGRhdGEuZGF0YXNldHNbaXRlbS5kYXRhc2V0SW5kZXhdLmRhdGFbaXRlbS5pbmRleF07XG5cdFx0XHRcdHJldHVybiBkYXRhc2V0TGFiZWwgKyAnOiAoJyArIGl0ZW0ueExhYmVsICsgJywgJyArIGl0ZW0ueUxhYmVsICsgJywgJyArIGRhdGFQb2ludC5yICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX2J1YmJsZSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGE7XG5cblx0XHQvLyBVcGRhdGUgUG9pbnRzXG5cdFx0aGVscGVycyQxLmVhY2gocG9pbnRzLCBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGluZGV4LCByZXNldCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIHhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHR2YXIgeVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhwb2ludCwgaW5kZXgpO1xuXHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGFbaW5kZXhdO1xuXHRcdHZhciBkc0luZGV4ID0gbWUuaW5kZXg7XG5cblx0XHR2YXIgeCA9IHJlc2V0ID8geFNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogeFNjYWxlLmdldFBpeGVsRm9yVmFsdWUodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gZGF0YSA6IE5hTiwgaW5kZXgsIGRzSW5kZXgpO1xuXHRcdHZhciB5ID0gcmVzZXQgPyB5U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShkYXRhLCBpbmRleCwgZHNJbmRleCk7XG5cblx0XHRwb2ludC5feFNjYWxlID0geFNjYWxlO1xuXHRcdHBvaW50Ll95U2NhbGUgPSB5U2NhbGU7XG5cdFx0cG9pbnQuX29wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHBvaW50Ll9kYXRhc2V0SW5kZXggPSBkc0luZGV4O1xuXHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xuXHRcdHBvaW50Ll9tb2RlbCA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1cyxcblx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuXHRcdFx0cmFkaXVzOiByZXNldCA/IDAgOiBvcHRpb25zLnJhZGl1cyxcblx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuXHRcdFx0eDogeCxcblx0XHRcdHk6IHksXG5cdFx0fTtcblxuXHRcdHBvaW50LnBpdm90KCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gcG9pbnQuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblxuXHRcdHBvaW50LiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQzKG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDMob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDMob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0XHRtb2RlbC5yYWRpdXMgPSBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaG92ZXJSYWRpdXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGRhdGFzZXQgPSBkYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQ7XG5cdFx0dmFyIGRhdGEgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2hvdmVyQmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdob3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdCdob3ZlckJvcmRlcldpZHRoJyxcblx0XHRcdCdob3ZlclJhZGl1cycsXG5cdFx0XHQnaGl0UmFkaXVzJyxcblx0XHRcdCdwb2ludFN0eWxlJyxcblx0XHRcdCdyb3RhdGlvbidcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDIoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHR9XG5cblx0XHQvLyBDdXN0b20gcmFkaXVzIHJlc29sdXRpb25cblx0XHR2YWx1ZXMucmFkaXVzID0gcmVzb2x2ZSQyKFtcblx0XHRcdGN1c3RvbS5yYWRpdXMsXG5cdFx0XHRkYXRhID8gZGF0YS5yIDogdW5kZWZpbmVkLFxuXHRcdFx0ZGF0YXNldC5yYWRpdXMsXG5cdFx0XHRvcHRpb25zLnJhZGl1c1xuXHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH1cbn0pO1xuXG52YXIgcmVzb2x2ZSQzID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcbnZhciB2YWx1ZU9yRGVmYXVsdCQ0ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2RvdWdobnV0Jywge1xuXHRhbmltYXRpb246IHtcblx0XHQvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgRG91Z2hudXRcblx0XHRhbmltYXRlUm90YXRlOiB0cnVlLFxuXHRcdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHdlIGFuaW1hdGUgc2NhbGluZyB0aGUgRG91Z2hudXQgZnJvbSB0aGUgY2VudHJlXG5cdFx0YW5pbWF0ZVNjYWxlOiBmYWxzZVxuXHR9LFxuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdzaW5nbGUnXG5cdH0sXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0ZXh0ID0gW107XG5cdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xuXG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xuXG5cdFx0aWYgKGRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgZGF0YXNldHNbMF0uYmFja2dyb3VuZENvbG9yW2ldICsgJ1wiPjwvc3Bhbj4nKTtcblx0XHRcdFx0aWYgKGxhYmVsc1tpXSkge1xuXHRcdFx0XHRcdHRleHQucHVzaChsYWJlbHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRleHQucHVzaCgnPC9saT4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdH0sXG5cdGxlZ2VuZDoge1xuXHRcdGxhYmVsczoge1xuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHRcdFx0aWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcblx0XHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG5cdFx0XHRcdFx0XHR2YXIgZHMgPSBkYXRhLmRhdGFzZXRzWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGFyYyA9IG1ldGEuZGF0YVtpXTtcblx0XHRcdFx0XHRcdHZhciBjdXN0b20gPSBhcmMgJiYgYXJjLmN1c3RvbSB8fCB7fTtcblx0XHRcdFx0XHRcdHZhciBhcmNPcHRzID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmM7XG5cdFx0XHRcdFx0XHR2YXIgZmlsbCA9IHJlc29sdmUkMyhbY3VzdG9tLmJhY2tncm91bmRDb2xvciwgZHMuYmFja2dyb3VuZENvbG9yLCBhcmNPcHRzLmJhY2tncm91bmRDb2xvcl0sIHVuZGVmaW5lZCwgaSk7XG5cdFx0XHRcdFx0XHR2YXIgc3Ryb2tlID0gcmVzb2x2ZSQzKFtjdXN0b20uYm9yZGVyQ29sb3IsIGRzLmJvcmRlckNvbG9yLCBhcmNPcHRzLmJvcmRlckNvbG9yXSwgdW5kZWZpbmVkLCBpKTtcblx0XHRcdFx0XHRcdHZhciBidyA9IHJlc29sdmUkMyhbY3VzdG9tLmJvcmRlcldpZHRoLCBkcy5ib3JkZXJXaWR0aCwgYXJjT3B0cy5ib3JkZXJXaWR0aF0sIHVuZGVmaW5lZCwgaSk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHRleHQ6IGxhYmVsLFxuXHRcdFx0XHRcdFx0XHRmaWxsU3R5bGU6IGZpbGwsXG5cdFx0XHRcdFx0XHRcdHN0cm9rZVN0eWxlOiBzdHJva2UsXG5cdFx0XHRcdFx0XHRcdGxpbmVXaWR0aDogYncsXG5cdFx0XHRcdFx0XHRcdGhpZGRlbjogaXNOYU4oZHMuZGF0YVtpXSkgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbixcblxuXHRcdFx0XHRcdFx0XHQvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cblx0XHRcdFx0XHRcdFx0aW5kZXg6IGlcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmluZGV4O1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblx0XHRcdHZhciBpLCBpbGVuLCBtZXRhO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdC8vIHRvZ2dsZSB2aXNpYmlsaXR5IG9mIGluZGV4IGlmIGV4aXN0c1xuXHRcdFx0XHRpZiAobWV0YS5kYXRhW2luZGV4XSkge1xuXHRcdFx0XHRcdG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuID0gIW1ldGEuZGF0YVtpbmRleF0uaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnVwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG5cdGN1dG91dFBlcmNlbnRhZ2U6IDUwLFxuXG5cdC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG5cdHJvdGF0aW9uOiBNYXRoLlBJICogLTAuNSxcblxuXHQvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG5cdGNpcmN1bWZlcmVuY2U6IE1hdGguUEkgKiAyLjAsXG5cblx0Ly8gTmVlZCB0byBvdmVycmlkZSB0aGVzZSB0byBnaXZlIGEgbmljZSBkZWZhdWx0XG5cdHRvb2x0aXBzOiB7XG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGRhdGEpIHtcblx0XHRcdFx0dmFyIGRhdGFMYWJlbCA9IGRhdGEubGFiZWxzW3Rvb2x0aXBJdGVtLmluZGV4XTtcblx0XHRcdFx0dmFyIHZhbHVlID0gJzogJyArIGRhdGEuZGF0YXNldHNbdG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4XS5kYXRhW3Rvb2x0aXBJdGVtLmluZGV4XTtcblxuXHRcdFx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkoZGF0YUxhYmVsKSkge1xuXHRcdFx0XHRcdC8vIHNob3cgdmFsdWUgb24gZmlyc3QgbGluZSBvZiBtdWx0aWxpbmUgbGFiZWxcblx0XHRcdFx0XHQvLyBuZWVkIHRvIGNsb25lIGJlY2F1c2Ugd2UgYXJlIGNoYW5naW5nIHRoZSB2YWx1ZVxuXHRcdFx0XHRcdGRhdGFMYWJlbCA9IGRhdGFMYWJlbC5zbGljZSgpO1xuXHRcdFx0XHRcdGRhdGFMYWJlbFswXSArPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhTGFiZWwgKz0gdmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZGF0YUxhYmVsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX2RvdWdobnV0ID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuQXJjLFxuXG5cdGxpbmtTY2FsZXM6IGhlbHBlcnMkMS5ub29wLFxuXG5cdC8vIEdldCBpbmRleCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cy4gVGhpcyBhbGxvd3MgZGV0ZXJtaW5pbmcgdGhlIGlubmVyIGFuZCBvdXRlciByYWRpdXMgY29ycmVjdGx5XG5cdGdldFJpbmdJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIHJpbmdJbmRleCA9IDA7XG5cblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFzZXRJbmRleDsgKytqKSB7XG5cdFx0XHRpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGopKSB7XG5cdFx0XHRcdCsrcmluZ0luZGV4O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByaW5nSW5kZXg7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGF2YWlsYWJsZVdpZHRoID0gY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQ7XG5cdFx0dmFyIGF2YWlsYWJsZUhlaWdodCA9IGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wO1xuXHRcdHZhciBtaW5TaXplID0gTWF0aC5taW4oYXZhaWxhYmxlV2lkdGgsIGF2YWlsYWJsZUhlaWdodCk7XG5cdFx0dmFyIG9mZnNldCA9IHt4OiAwLCB5OiAwfTtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgYXJjcyA9IG1ldGEuZGF0YTtcblx0XHR2YXIgY3V0b3V0UGVyY2VudGFnZSA9IG9wdHMuY3V0b3V0UGVyY2VudGFnZTtcblx0XHR2YXIgY2lyY3VtZmVyZW5jZSA9IG9wdHMuY2lyY3VtZmVyZW5jZTtcblx0XHR2YXIgY2hhcnRXZWlnaHQgPSBtZS5fZ2V0UmluZ1dlaWdodChtZS5pbmRleCk7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHQvLyBJZiB0aGUgY2hhcnQncyBjaXJjdW1mZXJlbmNlIGlzbid0IGEgZnVsbCBjaXJjbGUsIGNhbGN1bGF0ZSBtaW5TaXplIGFzIGEgcmF0aW8gb2YgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYXJjXG5cdFx0aWYgKGNpcmN1bWZlcmVuY2UgPCBNYXRoLlBJICogMi4wKSB7XG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb24gJSAoTWF0aC5QSSAqIDIuMCk7XG5cdFx0XHRzdGFydEFuZ2xlICs9IE1hdGguUEkgKiAyLjAgKiAoc3RhcnRBbmdsZSA+PSBNYXRoLlBJID8gLTEgOiBzdGFydEFuZ2xlIDwgLU1hdGguUEkgPyAxIDogMCk7XG5cdFx0XHR2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcblx0XHRcdHZhciBzdGFydCA9IHt4OiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgeTogTWF0aC5zaW4oc3RhcnRBbmdsZSl9O1xuXHRcdFx0dmFyIGVuZCA9IHt4OiBNYXRoLmNvcyhlbmRBbmdsZSksIHk6IE1hdGguc2luKGVuZEFuZ2xlKX07XG5cdFx0XHR2YXIgY29udGFpbnMwID0gKHN0YXJ0QW5nbGUgPD0gMCAmJiBlbmRBbmdsZSA+PSAwKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMi4wICYmIE1hdGguUEkgKiAyLjAgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIGNvbnRhaW5zOTAgPSAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMC41ICYmIE1hdGguUEkgKiAwLjUgPD0gZW5kQW5nbGUpIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgKiAyLjUgJiYgTWF0aC5QSSAqIDIuNSA8PSBlbmRBbmdsZSk7XG5cdFx0XHR2YXIgY29udGFpbnMxODAgPSAoc3RhcnRBbmdsZSA8PSAtTWF0aC5QSSAmJiAtTWF0aC5QSSA8PSBlbmRBbmdsZSkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAmJiBNYXRoLlBJIDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciBjb250YWluczI3MCA9IChzdGFydEFuZ2xlIDw9IC1NYXRoLlBJICogMC41ICYmIC1NYXRoLlBJICogMC41IDw9IGVuZEFuZ2xlKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMS41ICYmIE1hdGguUEkgKiAxLjUgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIGN1dG91dCA9IGN1dG91dFBlcmNlbnRhZ2UgLyAxMDAuMDtcblx0XHRcdHZhciBtaW4gPSB7eDogY29udGFpbnMxODAgPyAtMSA6IE1hdGgubWluKHN0YXJ0LnggKiAoc3RhcnQueCA8IDAgPyAxIDogY3V0b3V0KSwgZW5kLnggKiAoZW5kLnggPCAwID8gMSA6IGN1dG91dCkpLCB5OiBjb250YWluczI3MCA/IC0xIDogTWF0aC5taW4oc3RhcnQueSAqIChzdGFydC55IDwgMCA/IDEgOiBjdXRvdXQpLCBlbmQueSAqIChlbmQueSA8IDAgPyAxIDogY3V0b3V0KSl9O1xuXHRcdFx0dmFyIG1heCA9IHt4OiBjb250YWluczAgPyAxIDogTWF0aC5tYXgoc3RhcnQueCAqIChzdGFydC54ID4gMCA/IDEgOiBjdXRvdXQpLCBlbmQueCAqIChlbmQueCA+IDAgPyAxIDogY3V0b3V0KSksIHk6IGNvbnRhaW5zOTAgPyAxIDogTWF0aC5tYXgoc3RhcnQueSAqIChzdGFydC55ID4gMCA/IDEgOiBjdXRvdXQpLCBlbmQueSAqIChlbmQueSA+IDAgPyAxIDogY3V0b3V0KSl9O1xuXHRcdFx0dmFyIHNpemUgPSB7d2lkdGg6IChtYXgueCAtIG1pbi54KSAqIDAuNSwgaGVpZ2h0OiAobWF4LnkgLSBtaW4ueSkgKiAwLjV9O1xuXHRcdFx0bWluU2l6ZSA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoIC8gc2l6ZS53aWR0aCwgYXZhaWxhYmxlSGVpZ2h0IC8gc2l6ZS5oZWlnaHQpO1xuXHRcdFx0b2Zmc2V0ID0ge3g6IChtYXgueCArIG1pbi54KSAqIC0wLjUsIHk6IChtYXgueSArIG1pbi55KSAqIC0wLjV9O1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0YXJjc1tpXS5fb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMoYXJjc1tpXSwgaSk7XG5cdFx0fVxuXG5cdFx0Y2hhcnQuYm9yZGVyV2lkdGggPSBtZS5nZXRNYXhCb3JkZXJXaWR0aCgpO1xuXHRcdGNoYXJ0Lm91dGVyUmFkaXVzID0gTWF0aC5tYXgoKG1pblNpemUgLSBjaGFydC5ib3JkZXJXaWR0aCkgLyAyLCAwKTtcblx0XHRjaGFydC5pbm5lclJhZGl1cyA9IE1hdGgubWF4KGN1dG91dFBlcmNlbnRhZ2UgPyAoY2hhcnQub3V0ZXJSYWRpdXMgLyAxMDApICogKGN1dG91dFBlcmNlbnRhZ2UpIDogMCwgMCk7XG5cdFx0Y2hhcnQucmFkaXVzTGVuZ3RoID0gKGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQuaW5uZXJSYWRpdXMpIC8gKG1lLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkgfHwgMSk7XG5cdFx0Y2hhcnQub2Zmc2V0WCA9IG9mZnNldC54ICogY2hhcnQub3V0ZXJSYWRpdXM7XG5cdFx0Y2hhcnQub2Zmc2V0WSA9IG9mZnNldC55ICogY2hhcnQub3V0ZXJSYWRpdXM7XG5cblx0XHRtZXRhLnRvdGFsID0gbWUuY2FsY3VsYXRlVG90YWwoKTtcblxuXHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGggKiBtZS5fZ2V0UmluZ1dlaWdodE9mZnNldChtZS5pbmRleCk7XG5cdFx0bWUuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChtZS5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmNzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGFyYywgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuXHRcdHZhciBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG5cdFx0dmFyIGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcblx0XHR2YXIgc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb247IC8vIG5vbiByZXNldCBjYXNlIGhhbmRsZWQgbGF0ZXJcblx0XHR2YXIgZW5kQW5nbGUgPSBvcHRzLnJvdGF0aW9uOyAvLyBub24gcmVzZXQgY2FzZSBoYW5kbGVkIGxhdGVyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyAwIDogYXJjLmhpZGRlbiA/IDAgOiBtZS5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKGRhdGFzZXQuZGF0YVtpbmRleF0pICogKG9wdHMuY2lyY3VtZmVyZW5jZSAvICgyLjAgKiBNYXRoLlBJKSk7XG5cdFx0dmFyIGlubmVyUmFkaXVzID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogbWUuaW5uZXJSYWRpdXM7XG5cdFx0dmFyIG91dGVyUmFkaXVzID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogbWUub3V0ZXJSYWRpdXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnMgfHwge307XG5cblx0XHRoZWxwZXJzJDEuZXh0ZW5kKGFyYywge1xuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRfaW5kZXg6IGluZGV4LFxuXG5cdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdFx0X21vZGVsOiB7XG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdFx0Ym9yZGVyQWxpZ246IG9wdGlvbnMuYm9yZGVyQWxpZ24sXG5cdFx0XHRcdHg6IGNlbnRlclggKyBjaGFydC5vZmZzZXRYLFxuXHRcdFx0XHR5OiBjZW50ZXJZICsgY2hhcnQub2Zmc2V0WSxcblx0XHRcdFx0c3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcblx0XHRcdFx0ZW5kQW5nbGU6IGVuZEFuZ2xlLFxuXHRcdFx0XHRjaXJjdW1mZXJlbmNlOiBjaXJjdW1mZXJlbmNlLFxuXHRcdFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG5cdFx0XHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcblx0XHRcdFx0bGFiZWw6IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5sYWJlbCwgaW5kZXgsIGNoYXJ0LmRhdGEubGFiZWxzW2luZGV4XSlcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHZhciBtb2RlbCA9IGFyYy5fbW9kZWw7XG5cblx0XHQvLyBTZXQgY29ycmVjdCBhbmdsZXMgaWYgbm90IHJlc2V0dGluZ1xuXHRcdGlmICghcmVzZXQgfHwgIWFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuXHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bW9kZWwuc3RhcnRBbmdsZSA9IG1lLmdldE1ldGEoKS5kYXRhW2luZGV4IC0gMV0uX21vZGVsLmVuZEFuZ2xlO1xuXHRcdFx0fVxuXG5cdFx0XHRtb2RlbC5lbmRBbmdsZSA9IG1vZGVsLnN0YXJ0QW5nbGUgKyBtb2RlbC5jaXJjdW1mZXJlbmNlO1xuXHRcdH1cblxuXHRcdGFyYy5waXZvdCgpO1xuXHR9LFxuXG5cdGNhbGN1bGF0ZVRvdGFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIHRvdGFsID0gMDtcblx0XHR2YXIgdmFsdWU7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChtZXRhLmRhdGEsIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cdFx0XHR2YWx1ZSA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSAmJiAhZWxlbWVudC5oaWRkZW4pIHtcblx0XHRcdFx0dG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0LyogaWYgKHRvdGFsID09PSAwKSB7XG5cdFx0XHR0b3RhbCA9IE5hTjtcblx0XHR9Ki9cblxuXHRcdHJldHVybiB0b3RhbDtcblx0fSxcblxuXHRjYWxjdWxhdGVDaXJjdW1mZXJlbmNlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciB0b3RhbCA9IHRoaXMuZ2V0TWV0YSgpLnRvdGFsO1xuXHRcdGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIChNYXRoLlBJICogMi4wKSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIGdldHMgdGhlIG1heCBib3JkZXIgb3IgaG92ZXIgd2lkdGggdG8gcHJvcGVybHkgc2NhbGUgcGllIGNoYXJ0c1xuXHRnZXRNYXhCb3JkZXJXaWR0aDogZnVuY3Rpb24oYXJjcykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1heCA9IDA7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGksIGlsZW4sIG1ldGEsIGFyYywgY29udHJvbGxlciwgb3B0aW9ucywgYm9yZGVyV2lkdGgsIGhvdmVyV2lkdGg7XG5cblx0XHRpZiAoIWFyY3MpIHtcblx0XHRcdC8vIEZpbmQgdGhlIG91dG1vc3QgdmlzaWJsZSBkYXRhc2V0XG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdFx0YXJjcyA9IG1ldGEuZGF0YTtcblx0XHRcdFx0XHRpZiAoaSAhPT0gbWUuaW5kZXgpIHtcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFhcmNzKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyYyA9IGFyY3NbaV07XG5cdFx0XHRvcHRpb25zID0gY29udHJvbGxlciA/IGNvbnRyb2xsZXIuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhhcmMsIGkpIDogYXJjLl9vcHRpb25zO1xuXHRcdFx0aWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcblx0XHRcdFx0Ym9yZGVyV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuXHRcdFx0XHRob3ZlcldpZHRoID0gb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoO1xuXG5cdFx0XHRcdG1heCA9IGJvcmRlcldpZHRoID4gbWF4ID8gYm9yZGVyV2lkdGggOiBtYXg7XG5cdFx0XHRcdG1heCA9IGhvdmVyV2lkdGggPiBtYXggPyBob3ZlcldpZHRoIDogbWF4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWF4O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihhcmMpIHtcblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRhcmMuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ0KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ0KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihhcmMsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgY3VzdG9tID0gYXJjLmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2JvcmRlckFsaWduJyxcblx0XHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQzKFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHJhZGl1cyBsZW5ndGggb2Zmc2V0IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzIHdlaWdodHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFJpbmdXZWlnaHRPZmZzZXQ6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcblx0XHRcdGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0cmluZ1dlaWdodE9mZnNldCArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KGkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFJpbmdXZWlnaHQ6IGZ1bmN0aW9uKGRhdGFTZXRJbmRleCkge1xuXHRcdHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCQ0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhU2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdW0gb2YgYWxsIHZpc2liaWxlIGRhdGEgc2V0IHdlaWdodHMuICBUaGlzIHZhbHVlIGNhbiBiZSAwLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpO1xuXHR9XG59KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdob3Jpem9udGFsQmFyJywge1xuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdpbmRleCcsXG5cdFx0YXhpczogJ3knXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJ1xuXHRcdH1dLFxuXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0Jyxcblx0XHRcdGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuXHRcdFx0YmFyUGVyY2VudGFnZTogMC45LFxuXHRcdFx0b2Zmc2V0OiB0cnVlLFxuXHRcdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRcdG9mZnNldEdyaWRMaW5lczogdHJ1ZVxuXHRcdFx0fVxuXHRcdH1dXG5cdH0sXG5cblx0ZWxlbWVudHM6IHtcblx0XHRyZWN0YW5nbGU6IHtcblx0XHRcdGJvcmRlclNraXBwZWQ6ICdsZWZ0J1xuXHRcdH1cblx0fSxcblxuXHR0b29sdGlwczoge1xuXHRcdG1vZGU6ICdpbmRleCcsXG5cdFx0YXhpczogJ3knXG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9ob3Jpem9udGFsQmFyID0gY29udHJvbGxlcl9iYXIuZXh0ZW5kKHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0VmFsdWVTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueEF4aXNJRDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS55QXhpc0lEO1xuXHR9XG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDUgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgcmVzb2x2ZSQ0ID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcbnZhciBpc1BvaW50SW5BcmVhID0gaGVscGVycyQxLmNhbnZhcy5faXNQb2ludEluQXJlYTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdsaW5lJywge1xuXHRzaG93TGluZXM6IHRydWUsXG5cdHNwYW5HYXBzOiBmYWxzZSxcblxuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdsYWJlbCdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdjYXRlZ29yeScsXG5cdFx0XHRpZDogJ3gtYXhpcy0wJ1xuXHRcdH1dLFxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRpZDogJ3ktYXhpcy0wJ1xuXHRcdH1dXG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBsaW5lRW5hYmxlZChkYXRhc2V0LCBvcHRpb25zKSB7XG5cdHJldHVybiB2YWx1ZU9yRGVmYXVsdCQ1KGRhdGFzZXQuc2hvd0xpbmUsIG9wdGlvbnMuc2hvd0xpbmVzKTtcbn1cblxudmFyIGNvbnRyb2xsZXJfbGluZSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRkYXRhc2V0RWxlbWVudFR5cGU6IGVsZW1lbnRzLkxpbmUsXG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgbGluZSA9IG1ldGEuZGF0YXNldDtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBzY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgc2hvd0xpbmUgPSBsaW5lRW5hYmxlZChkYXRhc2V0LCBtZS5jaGFydC5vcHRpb25zKTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdC8vIFVwZGF0ZSBMaW5lXG5cdFx0aWYgKHNob3dMaW5lKSB7XG5cdFx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0XHRpZiAoKGRhdGFzZXQudGVuc2lvbiAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YXNldC5saW5lVGVuc2lvbiA9PT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0XHRkYXRhc2V0LmxpbmVUZW5zaW9uID0gZGF0YXNldC50ZW5zaW9uO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRsaW5lLl9zY2FsZSA9IHNjYWxlO1xuXHRcdFx0bGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0XHQvLyBEYXRhXG5cdFx0XHRsaW5lLl9jaGlsZHJlbiA9IHBvaW50cztcblx0XHRcdC8vIE1vZGVsXG5cdFx0XHRsaW5lLl9tb2RlbCA9IG1lLl9yZXNvbHZlTGluZU9wdGlvbnMobGluZSk7XG5cblx0XHRcdGxpbmUucGl2b3QoKTtcblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgUG9pbnRzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnRzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXG5cdFx0aWYgKHNob3dMaW5lICYmIGxpbmUuX21vZGVsLnRlbnNpb24gIT09IDApIHtcblx0XHRcdG1lLnVwZGF0ZUJlemllckNvbnRyb2xQb2ludHMoKTtcblx0XHR9XG5cblx0XHQvLyBOb3cgcGl2b3QgdGhlIHBvaW50IGZvciBhbmltYXRpb25cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cG9pbnRzW2ldLnBpdm90KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGRhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdHZhciB2YWx1ZSA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG5cdFx0dmFyIHlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHR2YXIgeFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xuXHRcdHZhciBsaW5lTW9kZWwgPSBtZXRhLmRhdGFzZXQuX21vZGVsO1xuXHRcdHZhciB4LCB5O1xuXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZVBvaW50T3B0aW9ucyhwb2ludCwgaW5kZXgpO1xuXG5cdFx0eCA9IHhTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSA6IE5hTiwgaW5kZXgsIGRhdGFzZXRJbmRleCk7XG5cdFx0eSA9IHJlc2V0ID8geVNjYWxlLmdldEJhc2VQaXhlbCgpIDogbWUuY2FsY3VsYXRlUG9pbnRZKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KTtcblxuXHRcdC8vIFV0aWxpdHlcblx0XHRwb2ludC5feFNjYWxlID0geFNjYWxlO1xuXHRcdHBvaW50Ll95U2NhbGUgPSB5U2NhbGU7XG5cdFx0cG9pbnQuX29wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHBvaW50Ll9kYXRhc2V0SW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XG5cblx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdHBvaW50Ll9tb2RlbCA9IHtcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5LFxuXHRcdFx0c2tpcDogY3VzdG9tLnNraXAgfHwgaXNOYU4oeCkgfHwgaXNOYU4oeSksXG5cdFx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0XHRyYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxuXHRcdFx0cG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuXHRcdFx0cm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdHRlbnNpb246IHZhbHVlT3JEZWZhdWx0JDUoY3VzdG9tLnRlbnNpb24sIGxpbmVNb2RlbCA/IGxpbmVNb2RlbC50ZW5zaW9uIDogMCksXG5cdFx0XHRzdGVwcGVkTGluZTogbGluZU1vZGVsID8gbGluZU1vZGVsLnN0ZXBwZWRMaW5lIDogZmFsc2UsXG5cdFx0XHQvLyBUb29sdGlwXG5cdFx0XHRoaXRSYWRpdXM6IG9wdGlvbnMuaGl0UmFkaXVzXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlUG9pbnRPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBjaGFydC5kYXRhLmRhdGFzZXRzW21lLmluZGV4XTtcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50O1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIEVMRU1FTlRfT1BUSU9OUyA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogJ3BvaW50QmFja2dyb3VuZENvbG9yJyxcblx0XHRcdGJvcmRlckNvbG9yOiAncG9pbnRCb3JkZXJDb2xvcicsXG5cdFx0XHRib3JkZXJXaWR0aDogJ3BvaW50Qm9yZGVyV2lkdGgnLFxuXHRcdFx0aGl0UmFkaXVzOiAncG9pbnRIaXRSYWRpdXMnLFxuXHRcdFx0aG92ZXJCYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEhvdmVyQmFja2dyb3VuZENvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyQ29sb3I6ICdwb2ludEhvdmVyQm9yZGVyQ29sb3InLFxuXHRcdFx0aG92ZXJCb3JkZXJXaWR0aDogJ3BvaW50SG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XHRob3ZlclJhZGl1czogJ3BvaW50SG92ZXJSYWRpdXMnLFxuXHRcdFx0cG9pbnRTdHlsZTogJ3BvaW50U3R5bGUnLFxuXHRcdFx0cmFkaXVzOiAncG9pbnRSYWRpdXMnLFxuXHRcdFx0cm90YXRpb246ICdwb2ludFJvdGF0aW9uJ1xuXHRcdH07XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhFTEVNRU5UX09QVElPTlMpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDQoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtFTEVNRU5UX09QVElPTlNba2V5XV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlTGluZU9wdGlvbnM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgZWxlbWVudE9wdGlvbnMgPSBvcHRpb25zLmVsZW1lbnRzLmxpbmU7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ2FwU3R5bGUnLFxuXHRcdFx0J2JvcmRlckRhc2gnLFxuXHRcdFx0J2JvcmRlckRhc2hPZmZzZXQnLFxuXHRcdFx0J2JvcmRlckpvaW5TdHlsZScsXG5cdFx0XHQnZmlsbCcsXG5cdFx0XHQnY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSdcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDQoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRlbGVtZW50T3B0aW9uc1trZXldXG5cdFx0XHRdKTtcblx0XHR9XG5cblx0XHQvLyBUaGUgZGVmYXVsdCBiZWhhdmlvciBvZiBsaW5lcyBpcyB0byBicmVhayBhdCBudWxsIHZhbHVlcywgYWNjb3JkaW5nXG5cdFx0Ly8gdG8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI0MzUjaXNzdWVjb21tZW50LTIxNjcxODE1OFxuXHRcdC8vIFRoaXMgb3B0aW9uIGdpdmVzIGxpbmVzIHRoZSBhYmlsaXR5IHRvIHNwYW4gZ2Fwc1xuXHRcdHZhbHVlcy5zcGFuR2FwcyA9IHZhbHVlT3JEZWZhdWx0JDUoZGF0YXNldC5zcGFuR2Fwcywgb3B0aW9ucy5zcGFuR2Fwcyk7XG5cdFx0dmFsdWVzLnRlbnNpb24gPSB2YWx1ZU9yRGVmYXVsdCQ1KGRhdGFzZXQubGluZVRlbnNpb24sIGVsZW1lbnRPcHRpb25zLnRlbnNpb24pO1xuXHRcdHZhbHVlcy5zdGVwcGVkTGluZSA9IHJlc29sdmUkNChbY3VzdG9tLnN0ZXBwZWRMaW5lLCBkYXRhc2V0LnN0ZXBwZWRMaW5lLCBlbGVtZW50T3B0aW9ucy5zdGVwcGVkXSk7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdGNhbGN1bGF0ZVBvaW50WTogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0dmFyIHN1bVBvcyA9IDA7XG5cdFx0dmFyIHN1bU5lZyA9IDA7XG5cdFx0dmFyIGksIGRzLCBkc01ldGE7XG5cblx0XHRpZiAoeVNjYWxlLm9wdGlvbnMuc3RhY2tlZCkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgaSsrKSB7XG5cdFx0XHRcdGRzID0gY2hhcnQuZGF0YS5kYXRhc2V0c1tpXTtcblx0XHRcdFx0ZHNNZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdGlmIChkc01ldGEudHlwZSA9PT0gJ2xpbmUnICYmIGRzTWV0YS55QXhpc0lEID09PSB5U2NhbGUuaWQgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRcdHZhciBzdGFja2VkUmlnaHRWYWx1ZSA9IE51bWJlcih5U2NhbGUuZ2V0UmlnaHRWYWx1ZShkcy5kYXRhW2luZGV4XSkpO1xuXHRcdFx0XHRcdGlmIChzdGFja2VkUmlnaHRWYWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdHN1bU5lZyArPSBzdGFja2VkUmlnaHRWYWx1ZSB8fCAwO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdW1Qb3MgKz0gc3RhY2tlZFJpZ2h0VmFsdWUgfHwgMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHJpZ2h0VmFsdWUgPSBOdW1iZXIoeVNjYWxlLmdldFJpZ2h0VmFsdWUodmFsdWUpKTtcblx0XHRcdGlmIChyaWdodFZhbHVlIDwgMCkge1xuXHRcdFx0XHRyZXR1cm4geVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3VtTmVnICsgcmlnaHRWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3VtUG9zICsgcmlnaHRWYWx1ZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcblx0fSxcblxuXHR1cGRhdGVCZXppZXJDb250cm9sUG9pbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBsaW5lTW9kZWwgPSBtZXRhLmRhdGFzZXQuX21vZGVsO1xuXHRcdHZhciBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0dmFyIGksIGlsZW4sIG1vZGVsLCBjb250cm9sUG9pbnRzO1xuXG5cdFx0Ly8gT25seSBjb25zaWRlciBwb2ludHMgdGhhdCBhcmUgZHJhd24gaW4gY2FzZSB0aGUgc3BhbkdhcHMgb3B0aW9uIGlzIHVzZWRcblx0XHRpZiAobGluZU1vZGVsLnNwYW5HYXBzKSB7XG5cdFx0XHRwb2ludHMgPSBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHB0KSB7XG5cdFx0XHRcdHJldHVybiAhcHQuX21vZGVsLnNraXA7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG5cdFx0fVxuXG5cdFx0aWYgKGxpbmVNb2RlbC5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG5cdFx0XHRoZWxwZXJzJDEuc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XG5cdFx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzJDEuc3BsaW5lQ3VydmUoXG5cdFx0XHRcdFx0aGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGkpLl9tb2RlbCxcblx0XHRcdFx0XHRtb2RlbCxcblx0XHRcdFx0XHRoZWxwZXJzJDEubmV4dEl0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXG5cdFx0XHRcdFx0bGluZU1vZGVsLnRlbnNpb25cblx0XHRcdFx0KTtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMubGluZS5jYXBCZXppZXJQb2ludHMpIHtcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcblx0XHRcdFx0aWYgKGlzUG9pbnRJbkFyZWEobW9kZWwsIGFyZWEpKSB7XG5cdFx0XHRcdFx0aWYgKGkgPiAwICYmIGlzUG9pbnRJbkFyZWEocG9pbnRzW2kgLSAxXS5fbW9kZWwsIGFyZWEpKSB7XG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGkgPCBwb2ludHMubGVuZ3RoIC0gMSAmJiBpc1BvaW50SW5BcmVhKHBvaW50c1tpICsgMV0uX21vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50TmV4dFgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnROZXh0WSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBpbGVuID0gcG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaGFsZkJvcmRlcldpZHRoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGlmIChsaW5lRW5hYmxlZChtZS5nZXREYXRhc2V0KCksIGNoYXJ0Lm9wdGlvbnMpKSB7XG5cdFx0XHRoYWxmQm9yZGVyV2lkdGggPSAobWV0YS5kYXRhc2V0Ll9tb2RlbC5ib3JkZXJXaWR0aCB8fCAwKSAvIDI7XG5cblx0XHRcdGhlbHBlcnMkMS5jYW52YXMuY2xpcEFyZWEoY2hhcnQuY3R4LCB7XG5cdFx0XHRcdGxlZnQ6IGFyZWEubGVmdCxcblx0XHRcdFx0cmlnaHQ6IGFyZWEucmlnaHQsXG5cdFx0XHRcdHRvcDogYXJlYS50b3AgLSBoYWxmQm9yZGVyV2lkdGgsXG5cdFx0XHRcdGJvdHRvbTogYXJlYS5ib3R0b20gKyBoYWxmQm9yZGVyV2lkdGhcblx0XHRcdH0pO1xuXG5cdFx0XHRtZXRhLmRhdGFzZXQuZHJhdygpO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY2hhcnQuY3R4KTtcblx0XHR9XG5cblx0XHQvLyBEcmF3IHRoZSBwb2ludHNcblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cG9pbnRzW2ldLmRyYXcoYXJlYSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ1KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ1KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0bW9kZWwucmFkaXVzID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyUmFkaXVzLCBvcHRpb25zLnJhZGl1cyk7XG5cdH0sXG59KTtcblxudmFyIHJlc29sdmUkNSA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncG9sYXJBcmVhJywge1xuXHRzY2FsZToge1xuXHRcdHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuXHRcdGFuZ2xlTGluZXM6IHtcblx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0fSxcblx0XHRncmlkTGluZXM6IHtcblx0XHRcdGNpcmN1bGFyOiB0cnVlXG5cdFx0fSxcblx0XHRwb2ludExhYmVsczoge1xuXHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHR9LFxuXHRcdHRpY2tzOiB7XG5cdFx0XHRiZWdpbkF0WmVybzogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnRcblx0YW5pbWF0aW9uOiB7XG5cdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcblx0XHRhbmltYXRlU2NhbGU6IHRydWVcblx0fSxcblxuXHRzdGFydEFuZ2xlOiAtMC41ICogTWF0aC5QSSxcblx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHRleHQgPSBbXTtcblx0XHR0ZXh0LnB1c2goJzx1bCBjbGFzcz1cIicgKyBjaGFydC5pZCArICctbGVnZW5kXCI+Jyk7XG5cblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XG5cblx0XHRpZiAoZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRzWzBdLmRhdGEubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dGV4dC5wdXNoKCc8bGk+PHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBkYXRhc2V0c1swXS5iYWNrZ3JvdW5kQ29sb3JbaV0gKyAnXCI+PC9zcGFuPicpO1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldKSB7XG5cdFx0XHRcdFx0dGV4dC5wdXNoKGxhYmVsc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGV4dC5wdXNoKCc8L2xpPicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRleHQucHVzaCgnPC91bD4nKTtcblx0XHRyZXR1cm4gdGV4dC5qb2luKCcnKTtcblx0fSxcblx0bGVnZW5kOiB7XG5cdFx0bGFiZWxzOiB7XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzLm1hcChmdW5jdGlvbihsYWJlbCwgaSkge1xuXHRcdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcblx0XHRcdFx0XHRcdHZhciBkcyA9IGRhdGEuZGF0YXNldHNbMF07XG5cdFx0XHRcdFx0XHR2YXIgYXJjID0gbWV0YS5kYXRhW2ldO1xuXHRcdFx0XHRcdFx0dmFyIGN1c3RvbSA9IGFyYy5jdXN0b20gfHwge307XG5cdFx0XHRcdFx0XHR2YXIgYXJjT3B0cyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdFx0XHRcdFx0dmFyIGZpbGwgPSByZXNvbHZlJDUoW2N1c3RvbS5iYWNrZ3JvdW5kQ29sb3IsIGRzLmJhY2tncm91bmRDb2xvciwgYXJjT3B0cy5iYWNrZ3JvdW5kQ29sb3JdLCB1bmRlZmluZWQsIGkpO1xuXHRcdFx0XHRcdFx0dmFyIHN0cm9rZSA9IHJlc29sdmUkNShbY3VzdG9tLmJvcmRlckNvbG9yLCBkcy5ib3JkZXJDb2xvciwgYXJjT3B0cy5ib3JkZXJDb2xvcl0sIHVuZGVmaW5lZCwgaSk7XG5cdFx0XHRcdFx0XHR2YXIgYncgPSByZXNvbHZlJDUoW2N1c3RvbS5ib3JkZXJXaWR0aCwgZHMuYm9yZGVyV2lkdGgsIGFyY09wdHMuYm9yZGVyV2lkdGhdLCB1bmRlZmluZWQsIGkpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcblx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBmaWxsLFxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3Ryb2tlLFxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGJ3LFxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRzLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXG5cblx0XHRcdFx0XHRcdFx0Ly8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5pbmRleDtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiA9ICFtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Y2hhcnQudXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKGl0ZW0sIGRhdGEpIHtcblx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzW2l0ZW0uaW5kZXhdICsgJzogJyArIGl0ZW0ueUxhYmVsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX3BvbGFyQXJlYSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLkFyYyxcblxuXHRsaW5rU2NhbGVzOiBoZWxwZXJzJDEubm9vcCxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgc3RhcnQgPSBtZS5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcblx0XHR2YXIgc3RhcnRzID0gbWUuX3N0YXJ0cyA9IFtdO1xuXHRcdHZhciBhbmdsZXMgPSBtZS5fYW5nbGVzID0gW107XG5cdFx0dmFyIGFyY3MgPSBtZXRhLmRhdGE7XG5cdFx0dmFyIGksIGlsZW4sIGFuZ2xlO1xuXG5cdFx0bWUuX3VwZGF0ZVJhZGl1cygpO1xuXG5cdFx0bWV0YS5jb3VudCA9IG1lLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldC5kYXRhLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuXHRcdFx0c3RhcnRzW2ldID0gc3RhcnQ7XG5cdFx0XHRhbmdsZSA9IG1lLl9jb21wdXRlQW5nbGUoaSk7XG5cdFx0XHRhbmdsZXNbaV0gPSBhbmdsZTtcblx0XHRcdHN0YXJ0ICs9IGFuZ2xlO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0YXJjc1tpXS5fb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMoYXJjc1tpXSwgaSk7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KGFyY3NbaV0sIGksIHJlc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdXBkYXRlUmFkaXVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIG9wdHMgPSBjaGFydC5vcHRpb25zO1xuXHRcdHZhciBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcblxuXHRcdGNoYXJ0Lm91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuXHRcdGNoYXJ0LmlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKGNoYXJ0Lm91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG5cdFx0Y2hhcnQucmFkaXVzTGVuZ3RoID0gKGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQuaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuXG5cdFx0bWUub3V0ZXJSYWRpdXMgPSBjaGFydC5vdXRlclJhZGl1cyAtIChjaGFydC5yYWRpdXNMZW5ndGggKiBtZS5pbmRleCk7XG5cdFx0bWUuaW5uZXJSYWRpdXMgPSBtZS5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aDtcblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG9wdHMgPSBjaGFydC5vcHRpb25zO1xuXHRcdHZhciBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG5cdFx0dmFyIHNjYWxlID0gY2hhcnQuc2NhbGU7XG5cdFx0dmFyIGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzO1xuXG5cdFx0dmFyIGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuXHRcdHZhciBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcblxuXHRcdC8vIHZhciBuZWdIYWxmUEkgPSAtMC41ICogTWF0aC5QSTtcblx0XHR2YXIgZGF0YXNldFN0YXJ0QW5nbGUgPSBvcHRzLnN0YXJ0QW5nbGU7XG5cdFx0dmFyIGRpc3RhbmNlID0gYXJjLmhpZGRlbiA/IDAgOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShkYXRhc2V0LmRhdGFbaW5kZXhdKTtcblx0XHR2YXIgc3RhcnRBbmdsZSA9IG1lLl9zdGFydHNbaW5kZXhdO1xuXHRcdHZhciBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoYXJjLmhpZGRlbiA/IDAgOiBtZS5fYW5nbGVzW2luZGV4XSk7XG5cblx0XHR2YXIgcmVzZXRSYWRpdXMgPSBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSA/IDAgOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShkYXRhc2V0LmRhdGFbaW5kZXhdKTtcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucyB8fCB7fTtcblxuXHRcdGhlbHBlcnMkMS5leHRlbmQoYXJjLCB7XG5cdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdF9pbmRleDogaW5kZXgsXG5cdFx0XHRfc2NhbGU6IHNjYWxlLFxuXG5cdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdFx0X21vZGVsOiB7XG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdFx0Ym9yZGVyQWxpZ246IG9wdGlvbnMuYm9yZGVyQWxpZ24sXG5cdFx0XHRcdHg6IGNlbnRlclgsXG5cdFx0XHRcdHk6IGNlbnRlclksXG5cdFx0XHRcdGlubmVyUmFkaXVzOiAwLFxuXHRcdFx0XHRvdXRlclJhZGl1czogcmVzZXQgPyByZXNldFJhZGl1cyA6IGRpc3RhbmNlLFxuXHRcdFx0XHRzdGFydEFuZ2xlOiByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyBkYXRhc2V0U3RhcnRBbmdsZSA6IHN0YXJ0QW5nbGUsXG5cdFx0XHRcdGVuZEFuZ2xlOiByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyBkYXRhc2V0U3RhcnRBbmdsZSA6IGVuZEFuZ2xlLFxuXHRcdFx0XHRsYWJlbDogaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdChsYWJlbHMsIGluZGV4LCBsYWJlbHNbaW5kZXhdKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXJjLnBpdm90KCk7XG5cdH0sXG5cblx0Y291bnRWaXNpYmxlRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdFx0aWYgKCFpc05hTihkYXRhc2V0LmRhdGFbaW5kZXhdKSAmJiAhZWxlbWVudC5oaWRkZW4pIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBjb3VudDtcblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXHRcdHZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuXHRcdGFyYy4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlRWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKGFyYywgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBjdXN0b20gPSBhcmMuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmM7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0XHQnYm9yZGVyQWxpZ24nLFxuXHRcdFx0J2hvdmVyQmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdob3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdCdob3ZlckJvcmRlcldpZHRoJyxcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDUoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NvbXB1dGVBbmdsZTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjb3VudCA9IHRoaXMuZ2V0TWV0YSgpLmNvdW50O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXG5cdFx0aWYgKGlzTmFOKGRhdGFzZXQuZGF0YVtpbmRleF0pIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBtZS5jaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHRyZXR1cm4gcmVzb2x2ZSQ1KFtcblx0XHRcdG1lLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjLmFuZ2xlLFxuXHRcdFx0KDIgKiBNYXRoLlBJKSAvIGNvdW50XG5cdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHR9XG59KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdwaWUnLCBoZWxwZXJzJDEuY2xvbmUoY29yZV9kZWZhdWx0cy5kb3VnaG51dCkpO1xuY29yZV9kZWZhdWx0cy5fc2V0KCdwaWUnLCB7XG5cdGN1dG91dFBlcmNlbnRhZ2U6IDBcbn0pO1xuXG4vLyBQaWUgY2hhcnRzIGFyZSBEb3VnaG51dCBjaGFydCB3aXRoIGRpZmZlcmVudCBkZWZhdWx0c1xudmFyIGNvbnRyb2xsZXJfcGllID0gY29udHJvbGxlcl9kb3VnaG51dDtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDYgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgcmVzb2x2ZSQ2ID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdyYWRhcicsIHtcblx0c2NhbGU6IHtcblx0XHR0eXBlOiAncmFkaWFsTGluZWFyJ1xuXHR9LFxuXHRlbGVtZW50czoge1xuXHRcdGxpbmU6IHtcblx0XHRcdHRlbnNpb246IDAgLy8gbm8gYmV6aWVyIGluIHJhZGFyXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfcmFkYXIgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YXNldEVsZW1lbnRUeXBlOiBlbGVtZW50cy5MaW5lLFxuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0bGlua1NjYWxlczogaGVscGVycyQxLm5vb3AsXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgc2NhbGUgPSBtZS5jaGFydC5zY2FsZTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdC8vIENvbXBhdGliaWxpdHk6IElmIHRoZSBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIHdpdGggb25seSB0aGUgb2xkIG5hbWUsIHVzZSB0aG9zZSB2YWx1ZXNcblx0XHRpZiAoKGRhdGFzZXQudGVuc2lvbiAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YXNldC5saW5lVGVuc2lvbiA9PT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0ZGF0YXNldC5saW5lVGVuc2lvbiA9IGRhdGFzZXQudGVuc2lvbjtcblx0XHR9XG5cblx0XHQvLyBVdGlsaXR5XG5cdFx0bGluZS5fc2NhbGUgPSBzY2FsZTtcblx0XHRsaW5lLl9kYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHQvLyBEYXRhXG5cdFx0bGluZS5fY2hpbGRyZW4gPSBwb2ludHM7XG5cdFx0bGluZS5fbG9vcCA9IHRydWU7XG5cdFx0Ly8gTW9kZWxcblx0XHRsaW5lLl9tb2RlbCA9IG1lLl9yZXNvbHZlTGluZU9wdGlvbnMobGluZSk7XG5cblx0XHRsaW5lLnBpdm90KCk7XG5cblx0XHQvLyBVcGRhdGUgUG9pbnRzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnRzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIGJlemllciBjb250cm9sIHBvaW50c1xuXHRcdG1lLnVwZGF0ZUJlemllckNvbnRyb2xQb2ludHMoKTtcblxuXHRcdC8vIE5vdyBwaXZvdCB0aGUgcG9pbnQgZm9yIGFuaW1hdGlvblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRwb2ludHNbaV0ucGl2b3QoKTtcblx0XHR9XG5cdH0sXG5cblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgc2NhbGUgPSBtZS5jaGFydC5zY2FsZTtcblx0XHR2YXIgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCwgZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZVBvaW50T3B0aW9ucyhwb2ludCwgaW5kZXgpO1xuXHRcdHZhciBsaW5lTW9kZWwgPSBtZS5nZXRNZXRhKCkuZGF0YXNldC5fbW9kZWw7XG5cdFx0dmFyIHggPSByZXNldCA/IHNjYWxlLnhDZW50ZXIgOiBwb2ludFBvc2l0aW9uLng7XG5cdFx0dmFyIHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG5cblx0XHQvLyBVdGlsaXR5XG5cdFx0cG9pbnQuX3NjYWxlID0gc2NhbGU7XG5cdFx0cG9pbnQuX29wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHBvaW50Ll9kYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHRwb2ludC5faW5kZXggPSBpbmRleDtcblxuXHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0cG9pbnQuX21vZGVsID0ge1xuXHRcdFx0eDogeCwgLy8gdmFsdWUgbm90IHVzZWQgaW4gZGF0YXNldCBzY2FsZSwgYnV0IHdlIHdhbnQgYSBjb25zaXN0ZW50IEFQSSBiZXR3ZWVuIHNjYWxlc1xuXHRcdFx0eTogeSxcblx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuXHRcdFx0Ly8gQXBwZWFyYW5jZVxuXHRcdFx0cmFkaXVzOiBvcHRpb25zLnJhZGl1cyxcblx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHR0ZW5zaW9uOiB2YWx1ZU9yRGVmYXVsdCQ2KGN1c3RvbS50ZW5zaW9uLCBsaW5lTW9kZWwgPyBsaW5lTW9kZWwudGVuc2lvbiA6IDApLFxuXG5cdFx0XHQvLyBUb29sdGlwXG5cdFx0XHRoaXRSYWRpdXM6IG9wdGlvbnMuaGl0UmFkaXVzXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlUG9pbnRPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBjaGFydC5kYXRhLmRhdGFzZXRzW21lLmluZGV4XTtcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50O1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIEVMRU1FTlRfT1BUSU9OUyA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogJ3BvaW50QmFja2dyb3VuZENvbG9yJyxcblx0XHRcdGJvcmRlckNvbG9yOiAncG9pbnRCb3JkZXJDb2xvcicsXG5cdFx0XHRib3JkZXJXaWR0aDogJ3BvaW50Qm9yZGVyV2lkdGgnLFxuXHRcdFx0aGl0UmFkaXVzOiAncG9pbnRIaXRSYWRpdXMnLFxuXHRcdFx0aG92ZXJCYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEhvdmVyQmFja2dyb3VuZENvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyQ29sb3I6ICdwb2ludEhvdmVyQm9yZGVyQ29sb3InLFxuXHRcdFx0aG92ZXJCb3JkZXJXaWR0aDogJ3BvaW50SG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XHRob3ZlclJhZGl1czogJ3BvaW50SG92ZXJSYWRpdXMnLFxuXHRcdFx0cG9pbnRTdHlsZTogJ3BvaW50U3R5bGUnLFxuXHRcdFx0cmFkaXVzOiAncG9pbnRSYWRpdXMnLFxuXHRcdFx0cm90YXRpb246ICdwb2ludFJvdGF0aW9uJ1xuXHRcdH07XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhFTEVNRU5UX09QVElPTlMpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDYoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtFTEVNRU5UX09QVElPTlNba2V5XV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlTGluZU9wdGlvbnM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlckNhcFN0eWxlJyxcblx0XHRcdCdib3JkZXJEYXNoJyxcblx0XHRcdCdib3JkZXJEYXNoT2Zmc2V0Jyxcblx0XHRcdCdib3JkZXJKb2luU3R5bGUnLFxuXHRcdFx0J2ZpbGwnXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ2KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdKTtcblx0XHR9XG5cblx0XHR2YWx1ZXMudGVuc2lvbiA9IHZhbHVlT3JEZWZhdWx0JDYoZGF0YXNldC5saW5lVGVuc2lvbiwgb3B0aW9ucy50ZW5zaW9uKTtcblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgYXJlYSA9IG1lLmNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpLCBpbGVuLCBtb2RlbCwgY29udHJvbFBvaW50cztcblxuXHRcdGZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdCwgbWluLCBtYXgpIHtcblx0XHRcdHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xuXHRcdFx0Y29udHJvbFBvaW50cyA9IGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZShcblx0XHRcdFx0aGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGksIHRydWUpLl9tb2RlbCxcblx0XHRcdFx0bW9kZWwsXG5cdFx0XHRcdGhlbHBlcnMkMS5uZXh0SXRlbShwb2ludHMsIGksIHRydWUpLl9tb2RlbCxcblx0XHRcdFx0bW9kZWwudGVuc2lvblxuXHRcdFx0KTtcblxuXHRcdFx0Ly8gUHJldmVudCB0aGUgYmV6aWVyIGdvaW5nIG91dHNpZGUgb2YgdGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhcblx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IGNhcENvbnRyb2xQb2ludChjb250cm9sUG9pbnRzLnByZXZpb3VzLngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5wcmV2aW91cy55LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5uZXh0LngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNhcENvbnRyb2xQb2ludChjb250cm9sUG9pbnRzLm5leHQueSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHR9XG5cdH0sXG5cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0cG9pbnQuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHRcdHJhZGl1czogbW9kZWwucmFkaXVzXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHRcdG1vZGVsLnJhZGl1cyA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlclJhZGl1cywgb3B0aW9ucy5yYWRpdXMpO1xuXHR9XG59KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdzY2F0dGVyJywge1xuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdzaW5nbGUnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHRpZDogJ3gtYXhpcy0xJywgICAgLy8gbmVlZCBhbiBJRCBzbyBkYXRhc2V0cyBjYW4gcmVmZXJlbmNlIHRoZSBzY2FsZVxuXHRcdFx0dHlwZTogJ2xpbmVhcicsICAgIC8vIHNjYXR0ZXIgc2hvdWxkIG5vdCB1c2UgYSBjYXRlZ29yeSBheGlzXG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbSdcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdGlkOiAneS1heGlzLTEnLFxuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRwb3NpdGlvbjogJ2xlZnQnXG5cdFx0fV1cblx0fSxcblxuXHRzaG93TGluZXM6IGZhbHNlLFxuXG5cdHRvb2x0aXBzOiB7XG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJzsgICAgIC8vIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3Igc2NhdHRlciBzaW5jZSBkYXRhIGFyZSBmb3JtYXR0ZWQgYXMgYSBwb2ludFxuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiAnKCcgKyBpdGVtLnhMYWJlbCArICcsICcgKyBpdGVtLnlMYWJlbCArICcpJztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBTY2F0dGVyIGNoYXJ0cyB1c2UgbGluZSBjb250cm9sbGVyc1xudmFyIGNvbnRyb2xsZXJfc2NhdHRlciA9IGNvbnRyb2xsZXJfbGluZTtcblxuLy8gTk9URSBleHBvcnQgYSBtYXAgaW4gd2hpY2ggdGhlIGtleSByZXByZXNlbnRzIHRoZSBjb250cm9sbGVyIHR5cGUsIG5vdFxuLy8gdGhlIGNsYXNzLCBhbmQgc28gbXVzdCBiZSBDYW1lbENhc2UgaW4gb3JkZXIgdG8gYmUgY29ycmVjdGx5IHJldHJpZXZlZFxuLy8gYnkgdGhlIGNvbnRyb2xsZXIgaW4gY29yZS5jb250cm9sbGVyLmpzIChgY29udHJvbGxlcnNbbWV0YS50eXBlXWApLlxuXG52YXIgY29udHJvbGxlcnMgPSB7XG5cdGJhcjogY29udHJvbGxlcl9iYXIsXG5cdGJ1YmJsZTogY29udHJvbGxlcl9idWJibGUsXG5cdGRvdWdobnV0OiBjb250cm9sbGVyX2RvdWdobnV0LFxuXHRob3Jpem9udGFsQmFyOiBjb250cm9sbGVyX2hvcml6b250YWxCYXIsXG5cdGxpbmU6IGNvbnRyb2xsZXJfbGluZSxcblx0cG9sYXJBcmVhOiBjb250cm9sbGVyX3BvbGFyQXJlYSxcblx0cGllOiBjb250cm9sbGVyX3BpZSxcblx0cmFkYXI6IGNvbnRyb2xsZXJfcmFkYXIsXG5cdHNjYXR0ZXI6IGNvbnRyb2xsZXJfc2NhdHRlclxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHJlbGF0aXZlIHBvc2l0aW9uIGZvciBhbiBldmVudFxuICogQHBhcmFtIHtFdmVudHxJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGdldCB0aGUgcG9zaXRpb24gZm9yXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydFxuICogQHJldHVybnMge29iamVjdH0gdGhlIGV2ZW50IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpIHtcblx0aWYgKGUubmF0aXZlKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IGUueCxcblx0XHRcdHk6IGUueVxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gaGVscGVycyQxLmdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB0cmF2ZXJzZSBhbGwgb2YgdGhlIHZpc2libGUgZWxlbWVudHMgaW4gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIHRoZSBjYWxsYmFjayB0byBleGVjdXRlIGZvciBlYWNoIHZpc2libGUgaXRlbVxuICovXG5mdW5jdGlvbiBwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgaGFuZGxlcikge1xuXHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHR2YXIgbWV0YSwgaSwgaiwgaWxlbiwgamxlbjtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aWYgKCFjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0Zm9yIChqID0gMCwgamxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdHZhciBlbGVtZW50ID0gbWV0YS5kYXRhW2pdO1xuXHRcdFx0aWYgKCFlbGVtZW50Ll92aWV3LnNraXApIHtcblx0XHRcdFx0aGFuZGxlcihlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgZXZlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Q2hhcnRFbGVtZW50W119IGl0ZW1zIC0gZWxlbWVudHMgdG8gZmlsdGVyXG4gKiBAcGFyYW0ge29iamVjdH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xuICogQHJldHVybiB7Q2hhcnRFbGVtZW50W119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikge1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblxuXHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gY29uc2lkZXJpbmcgYWxsIHZpc2libGUgaXRlbXMgaW4gdGVoIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7b2JqZWN0fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludGVyc2VjdCAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaXN0YW5jZU1ldHJpYyAtIGZ1bmN0aW9uIHRvIHByb3ZpZGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzXG4gKiBAcmV0dXJuIHtDaGFydEVsZW1lbnRbXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgaW50ZXJzZWN0LCBkaXN0YW5jZU1ldHJpYykge1xuXHR2YXIgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdHZhciBuZWFyZXN0SXRlbXMgPSBbXTtcblxuXHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdGlmIChpbnRlcnNlY3QgJiYgIWVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KCk7XG5cdFx0dmFyIGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG5cdFx0aWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdG5lYXJlc3RJdGVtcyA9IFtlbGVtZW50XTtcblx0XHRcdG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0fSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcblx0XHRcdC8vIENhbiBoYXZlIG11bHRpcGxlIGl0ZW1zIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGluIHdoaWNoIGNhc2Ugd2Ugc29ydCBieSBzaXplXG5cdFx0XHRuZWFyZXN0SXRlbXMucHVzaChlbGVtZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBuZWFyZXN0SXRlbXM7XG59XG5cbi8qKlxuICogR2V0IGEgZGlzdGFuY2UgbWV0cmljIGZ1bmN0aW9uIGZvciB0d28gcG9pbnRzIGJhc2VkIG9uIHRoZVxuICogYXhpcyBtb2RlIHNldHRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5XG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG5cdHZhciB1c2VYID0gYXhpcy5pbmRleE9mKCd4JykgIT09IC0xO1xuXHR2YXIgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcblxuXHRyZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcblx0XHR2YXIgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcblx0XHR2YXIgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gaW5kZXhNb2RlKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHQvLyBEZWZhdWx0IGF4aXMgZm9yIGluZGV4IG1vZGUgaXMgJ3gnIHRvIG1hdGNoIG9sZCBiZWhhdmlvdXJcblx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4Jztcblx0dmFyIGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKG9wdGlvbnMuYXhpcyk7XG5cdHZhciBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0ID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGZhbHNlLCBkaXN0YW5jZU1ldHJpYyk7XG5cdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdGlmICghaXRlbXMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0Y2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkpIHtcblx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdHZhciBlbGVtZW50ID0gbWV0YS5kYXRhW2l0ZW1zWzBdLl9pbmRleF07XG5cblx0XHRcdC8vIGRvbid0IGNvdW50IGl0ZW1zIHRoYXQgYXJlIHNraXBwZWQgKG51bGwgZGF0YSlcblx0XHRcdGlmIChlbGVtZW50ICYmICFlbGVtZW50Ll92aWV3LnNraXApIHtcblx0XHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIElJbnRlcmFjdGlvbk9wdGlvbnNcbiAqL1xuLyoqXG4gKiBJZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb2ludFxuICogQG5hbWUgSUludGVyZmFjZU9wdGlvbnMjYm9vbGVhblxuICogQHR5cGUgQm9vbGVhblxuICovXG5cbi8qKlxuICogQ29udGFpbnMgaW50ZXJhY3Rpb24gcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuSW50ZXJhY3Rpb25cbiAqL1xudmFyIGNvcmVfaW50ZXJhY3Rpb24gPSB7XG5cdC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZGlmZmVyZW50IG1vZGVzXG5cdG1vZGVzOiB7XG5cdFx0c2luZ2xlOiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSBbXTtcblxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW1lbnRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGVsZW1lbnRzLnNsaWNlKDAsIDEpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMubGFiZWxcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0bGFiZWw6IGluZGV4TW9kZSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXguIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBtb2RlIGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXggYXMgdGhhdCBpdGVtXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmluZGV4XG5cdFx0ICogQHNpbmNlIHYyLjQuMFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2UgZHVyaW5nIGludGVyYWN0aW9uXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdGluZGV4OiBpbmRleE1vZGUsXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGluIHRoZSBzYW1lIGRhdGFzZXQuIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGluIHRoYXQgZGF0YXNldFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5kYXRhc2V0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZSBkdXJpbmcgaW50ZXJhY3Rpb25cblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0ZGF0YXNldDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG5cdFx0XHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcblx0XHRcdHZhciBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0ID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGZhbHNlLCBkaXN0YW5jZU1ldHJpYyk7XG5cblx0XHRcdGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGl0ZW1zID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uX2RhdGFzZXRJbmRleCkuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueC1heGlzXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjQuMC4gVXNlIGluZGV4IG1vZGUgYW5kIGludGVyc2VjdCA9PSB0cnVlXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0J3gtYXhpcyc6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhNb2RlKGNoYXJ0LCBlLCB7aW50ZXJzZWN0OiBmYWxzZX0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQb2ludCBtb2RlIHJldHVybnMgYWxsIGVsZW1lbnRzIHRoYXQgaGl0IHRlc3QgYmFzZWQgb24gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdFx0ICogb2YgdGhlIGV2ZW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdHBvaW50OiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHRyZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogbmVhcmVzdCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnQgY2xvc2VzdCB0byB0aGUgcG9pbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRuZWFyZXN0OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHRvcHRpb25zLmF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5Jztcblx0XHRcdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xuXHRcdFx0cmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIG9wdGlvbnMuaW50ZXJzZWN0LCBkaXN0YW5jZU1ldHJpYyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIHggbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHggY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHR4OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRcdHZhciBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5pblhSYW5nZShwb3NpdGlvbi54KSkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c0l0ZW0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcblx0XHRcdC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcblx0XHRcdGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcblx0XHRcdFx0aXRlbXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogeSBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnlcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdHk6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdFx0dmFyIGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LmluWVJhbmdlKHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0aXRlbXMucHVzaChlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRpbnRlcnNlY3RzSXRlbSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuXHRcdFx0Ly8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xuXHRcdFx0aWYgKG9wdGlvbnMuaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuXHRcdFx0XHRpdGVtcyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH1cblx0fVxufTtcblxuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcblx0cmV0dXJuIGhlbHBlcnMkMS53aGVyZShhcnJheSwgZnVuY3Rpb24odikge1xuXHRcdHJldHVybiB2LnBvc2l0aW9uID09PSBwb3NpdGlvbjtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuXHRhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpIHtcblx0XHR2Ll90bXBJbmRleF8gPSBpO1xuXHRcdHJldHVybiB2O1xuXHR9KTtcblx0YXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0dmFyIHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuXHRcdHZhciB2MSA9IHJldmVyc2UgPyBhIDogYjtcblx0XHRyZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgP1xuXHRcdFx0djAuX3RtcEluZGV4XyAtIHYxLl90bXBJbmRleF8gOlxuXHRcdFx0djAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuXHR9KTtcblx0YXJyYXkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG5cdFx0ZGVsZXRlIHYuX3RtcEluZGV4Xztcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRNYXhQYWRkaW5nKGJveGVzKSB7XG5cdHZhciB0b3AgPSAwO1xuXHR2YXIgbGVmdCA9IDA7XG5cdHZhciBib3R0b20gPSAwO1xuXHR2YXIgcmlnaHQgPSAwO1xuXHRoZWxwZXJzJDEuZWFjaChib3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0aWYgKGJveC5nZXRQYWRkaW5nKSB7XG5cdFx0XHR2YXIgYm94UGFkZGluZyA9IGJveC5nZXRQYWRkaW5nKCk7XG5cdFx0XHR0b3AgPSBNYXRoLm1heCh0b3AsIGJveFBhZGRpbmcudG9wKTtcblx0XHRcdGxlZnQgPSBNYXRoLm1heChsZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuXHRcdFx0Ym90dG9tID0gTWF0aC5tYXgoYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XG5cdFx0XHRyaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4ge1xuXHRcdHRvcDogdG9wLFxuXHRcdGxlZnQ6IGxlZnQsXG5cdFx0Ym90dG9tOiBib3R0b20sXG5cdFx0cmlnaHQ6IHJpZ2h0XG5cdH07XG59XG5cbmZ1bmN0aW9uIGFkZFNpemVCeVBvc2l0aW9uKGJveGVzLCBzaXplKSB7XG5cdGhlbHBlcnMkMS5lYWNoKGJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRzaXplW2JveC5wb3NpdGlvbl0gKz0gYm94LmlzSG9yaXpvbnRhbCgpID8gYm94LmhlaWdodCA6IGJveC53aWR0aDtcblx0fSk7XG59XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRsYXlvdXQ6IHtcblx0XHRwYWRkaW5nOiB7XG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRyaWdodDogMCxcblx0XHRcdGJvdHRvbTogMCxcblx0XHRcdGxlZnQ6IDBcblx0XHR9XG5cdH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgSUxheW91dEl0ZW1cbiAqIEBwcm9wIHtzdHJpbmd9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBjaGFydCBsYXlvdXQuIFBvc3NpYmxlIHZhbHVlcyBhcmVcbiAqICdsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCBhbmQgJ2NoYXJ0QXJlYSdcbiAqIEBwcm9wIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQgdXNlZCB0byBzb3J0IHRoZSBpdGVtLiBIaWdoZXIgd2VpZ2h0cyBhcmUgZnVydGhlciBhd2F5IGZyb20gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwcm9wIHtib29sZWFufSBmdWxsV2lkdGggLSBpZiB0cnVlLCBhbmQgdGhlIGl0ZW0gaXMgaG9yaXpvbnRhbCwgdGhlbiBwdXNoIHZlcnRpY2FsIGJveGVzIGRvd25cbiAqIEBwcm9wIHtmdW5jdGlvbn0gaXNIb3Jpem9udGFsIC0gcmV0dXJucyB0cnVlIGlmIHRoZSBsYXlvdXQgaXRlbSBpcyBob3Jpem9udGFsIChpZS4gdG9wIG9yIGJvdHRvbSlcbiAqIEBwcm9wIHtmdW5jdGlvbn0gdXBkYXRlIC0gVGFrZXMgdHdvIHBhcmFtZXRlcnM6IHdpZHRoIGFuZCBoZWlnaHQuIFJldHVybnMgc2l6ZSBvZiBpdGVtXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGdldFBhZGRpbmcgLSAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBwYWRkaW5nIG9uIHRoZSBlZGdlc1xuICogQHByb3Age251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXG4gKiBAcHJvcCB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gbGVmdCAtIExlZnQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gdG9wIC0gVG9wIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHJpZ2h0IC0gUmlnaHQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gYm90dG9tIC0gQm90dG9tIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqL1xuXG4vLyBUaGUgbGF5b3V0IHNlcnZpY2UgaXMgdmVyeSBzZWxmIGV4cGxhbmF0b3J5LiAgSXQncyByZXNwb25zaWJsZSBmb3IgdGhlIGxheW91dCB3aXRoaW4gYSBjaGFydC5cbi8vIFNjYWxlcywgTGVnZW5kcyBhbmQgUGx1Z2lucyBhbGwgcmVseSBvbiB0aGUgbGF5b3V0IHNlcnZpY2UgYW5kIGNhbiBlYXNpbHkgcmVnaXN0ZXIgdG8gYmUgcGxhY2VkIGFueXdoZXJlIHRoZXkgbmVlZFxuLy8gSXQgaXMgdGhpcyBzZXJ2aWNlJ3MgcmVzcG9uc2liaWxpdHkgb2YgY2Fycnlpbmcgb3V0IHRoYXQgbGF5b3V0LlxudmFyIGNvcmVfbGF5b3V0cyA9IHtcblx0ZGVmYXVsdHM6IHt9LFxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIGJveCB0byBhIGNoYXJ0LlxuXHQgKiBBIGJveCBpcyBzaW1wbHkgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0IHRoYXQgcmVxdWlyZXMgbGF5b3V0LiBlZy4gU2NhbGVzLCBMZWdlbmQsIFRpdGxlLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byB1c2Vcblx0ICogQHBhcmFtIHtJTGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGFkZCB0byBiZSBsYXllZCBvdXRcblx0ICovXG5cdGFkZEJveDogZnVuY3Rpb24oY2hhcnQsIGl0ZW0pIHtcblx0XHRpZiAoIWNoYXJ0LmJveGVzKSB7XG5cdFx0XHRjaGFydC5ib3hlcyA9IFtdO1xuXHRcdH1cblxuXHRcdC8vIGluaXRpYWxpemUgaXRlbSB3aXRoIGRlZmF1bHQgdmFsdWVzXG5cdFx0aXRlbS5mdWxsV2lkdGggPSBpdGVtLmZ1bGxXaWR0aCB8fCBmYWxzZTtcblx0XHRpdGVtLnBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbiB8fCAndG9wJztcblx0XHRpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XG5cblx0XHRjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBsYXlvdXRJdGVtIGZyb20gYSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byByZW1vdmUgdGhlIGJveCBmcm9tXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGxheW91dEl0ZW0gLSB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGF5b3V0XG5cdCAqL1xuXHRyZW1vdmVCb3g6IGZ1bmN0aW9uKGNoYXJ0LCBsYXlvdXRJdGVtKSB7XG5cdFx0dmFyIGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0Y2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgKG9yIHVwZGF0ZXMpIG9wdGlvbnMgb24gdGhlIGdpdmVuIGBpdGVtYC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgaW4gd2hpY2ggdGhlIGl0ZW0gbGl2ZXMgKG9yIHdpbGwgYmUgYWRkZWQgdG8pXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBjb25maWd1cmUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHRoZSBuZXcgaXRlbSBvcHRpb25zLlxuXHQgKi9cblx0Y29uZmlndXJlOiBmdW5jdGlvbihjaGFydCwgaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBwcm9wcyA9IFsnZnVsbFdpZHRoJywgJ3Bvc2l0aW9uJywgJ3dlaWdodCddO1xuXHRcdHZhciBpbGVuID0gcHJvcHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgcHJvcDtcblxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbaV07XG5cdFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRpdGVtW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZpdHMgYm94ZXMgb2YgdGhlIGdpdmVuIGNoYXJ0IGludG8gdGhlIGdpdmVuIHNpemUgYnkgaGF2aW5nIGVhY2ggYm94IG1lYXN1cmUgaXRzZWxmXG5cdCAqIHRoZW4gcnVubmluZyBhIGZpdHRpbmcgYWxnb3JpdGhtXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCB0byBmaXQgaW50b1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCB0byBmaXQgaW50b1xuXHQgKi9cblx0dXBkYXRlOiBmdW5jdGlvbihjaGFydCwgd2lkdGgsIGhlaWdodCkge1xuXHRcdGlmICghY2hhcnQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbGF5b3V0T3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMubGF5b3V0IHx8IHt9O1xuXHRcdHZhciBwYWRkaW5nID0gaGVscGVycyQxLm9wdGlvbnMudG9QYWRkaW5nKGxheW91dE9wdGlvbnMucGFkZGluZyk7XG5cdFx0dmFyIGxlZnRQYWRkaW5nID0gcGFkZGluZy5sZWZ0O1xuXHRcdHZhciByaWdodFBhZGRpbmcgPSBwYWRkaW5nLnJpZ2h0O1xuXHRcdHZhciB0b3BQYWRkaW5nID0gcGFkZGluZy50b3A7XG5cdFx0dmFyIGJvdHRvbVBhZGRpbmcgPSBwYWRkaW5nLmJvdHRvbTtcblxuXHRcdHZhciBsZWZ0Qm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnbGVmdCcpO1xuXHRcdHZhciByaWdodEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ3JpZ2h0Jyk7XG5cdFx0dmFyIHRvcEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ3RvcCcpO1xuXHRcdHZhciBib3R0b21Cb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICdib3R0b20nKTtcblx0XHR2YXIgY2hhcnRBcmVhQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnY2hhcnRBcmVhJyk7XG5cblx0XHQvLyBTb3J0IGJveGVzIGJ5IHdlaWdodC4gQSBoaWdoZXIgd2VpZ2h0IGlzIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBjaGFydCBhcmVhXG5cdFx0c29ydEJ5V2VpZ2h0KGxlZnRCb3hlcywgdHJ1ZSk7XG5cdFx0c29ydEJ5V2VpZ2h0KHJpZ2h0Qm94ZXMsIGZhbHNlKTtcblx0XHRzb3J0QnlXZWlnaHQodG9wQm94ZXMsIHRydWUpO1xuXHRcdHNvcnRCeVdlaWdodChib3R0b21Cb3hlcywgZmFsc2UpO1xuXG5cdFx0dmFyIHZlcnRpY2FsQm94ZXMgPSBsZWZ0Qm94ZXMuY29uY2F0KHJpZ2h0Qm94ZXMpO1xuXHRcdHZhciBob3Jpem9udGFsQm94ZXMgPSB0b3BCb3hlcy5jb25jYXQoYm90dG9tQm94ZXMpO1xuXHRcdHZhciBvdXRlckJveGVzID0gdmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKTtcblxuXHRcdC8vIEVzc2VudGlhbGx5IHdlIG5vdyBoYXZlIGFueSBudW1iZXIgb2YgYm94ZXMgb24gZWFjaCBvZiB0aGUgNCBzaWRlcy5cblx0XHQvLyBPdXIgY2FudmFzIGxvb2tzIGxpa2UgdGhlIGZvbGxvd2luZy5cblx0XHQvLyBUaGUgYXJlYXMgTDEgYW5kIEwyIGFyZSB0aGUgbGVmdCBheGVzLiBSMSBpcyB0aGUgcmlnaHQgYXhpcywgVDEgaXMgdGhlIHRvcCBheGlzIGFuZFxuXHRcdC8vIEIxIGlzIHRoZSBib3R0b20gYXhpc1xuXHRcdC8vIFRoZXJlIGFyZSBhbHNvIDQgcXVhZHJhbnQtbGlrZSBsb2NhdGlvbnMgKGxlZnQgdG8gcmlnaHQgaW5zdGVhZCBvZiBjbG9ja3dpc2UpIHJlc2VydmVkIGZvciBjaGFydCBvdmVybGF5c1xuXHRcdC8vIFRoZXNlIGxvY2F0aW9ucyBhcmUgc2luZ2xlLWJveCBsb2NhdGlvbnMgb25seSwgd2hlbiB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBjaGFydEFyZWEgbG9jYXRpb24gdGhhdCBpcyBhbHJlYWR5IHRha2VuLFxuXHRcdC8vIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuXHRcdC8vXG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly8gfCAgICAgICAgICAgICAgICAgIFQxIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIFQyICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG5cdFx0Ly8gfCAgICB8ICAgIHwgQzEgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzIgfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfCBMMSB8IEwyIHwgICAgICAgICAgIENoYXJ0QXJlYSAoQzApICAgICAgICAgICAgfCBSMSB8XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwgQzMgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzQgfCAgICB8XG5cdFx0Ly8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIEIxICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly8gfCAgICAgICAgICAgICAgICAgIEIyIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly9cblx0XHQvLyBXaGF0IHdlIGRvIHRvIGZpbmQgdGhlIGJlc3Qgc2l6aW5nLCB3ZSBkbyB0aGUgZm9sbG93aW5nXG5cdFx0Ly8gMS4gRGV0ZXJtaW5lIHRoZSBtaW5pbXVtIHNpemUgb2YgdGhlIGNoYXJ0IGFyZWEuXG5cdFx0Ly8gMi4gU3BsaXQgdGhlIHJlbWFpbmluZyB3aWR0aCBlcXVhbGx5IGJldHdlZW4gZWFjaCB2ZXJ0aWNhbCBheGlzXG5cdFx0Ly8gMy4gU3BsaXQgdGhlIHJlbWFpbmluZyBoZWlnaHQgZXF1YWxseSBiZXR3ZWVuIGVhY2ggaG9yaXpvbnRhbCBheGlzXG5cdFx0Ly8gNC4gR2l2ZSBlYWNoIGxheW91dCB0aGUgbWF4aW11bSBzaXplIGl0IGNhbiBiZS4gVGhlIGxheW91dCB3aWxsIHJldHVybiBpdCdzIG1pbmltdW0gc2l6ZVxuXHRcdC8vIDUuIEFkanVzdCB0aGUgc2l6ZXMgb2YgZWFjaCBheGlzIGJhc2VkIG9uIGl0J3MgbWluaW11bSByZXBvcnRlZCBzaXplLlxuXHRcdC8vIDYuIFJlZml0IGVhY2ggYXhpc1xuXHRcdC8vIDcuIFBvc2l0aW9uIGVhY2ggYXhpcyBpbiB0aGUgZmluYWwgbG9jYXRpb25cblx0XHQvLyA4LiBUZWxsIHRoZSBjaGFydCB0aGUgZmluYWwgbG9jYXRpb24gb2YgdGhlIGNoYXJ0IGFyZWFcblx0XHQvLyA5LiBUZWxsIGFueSBheGVzIHRoYXQgb3ZlcmxheSB0aGUgY2hhcnQgYXJlYSB0aGUgcG9zaXRpb25zIG9mIHRoZSBjaGFydCBhcmVhXG5cblx0XHQvLyBTdGVwIDFcblx0XHR2YXIgY2hhcnRXaWR0aCA9IHdpZHRoIC0gbGVmdFBhZGRpbmcgLSByaWdodFBhZGRpbmc7XG5cdFx0dmFyIGNoYXJ0SGVpZ2h0ID0gaGVpZ2h0IC0gdG9wUGFkZGluZyAtIGJvdHRvbVBhZGRpbmc7XG5cdFx0dmFyIGNoYXJ0QXJlYVdpZHRoID0gY2hhcnRXaWR0aCAvIDI7IC8vIG1pbiA1MCVcblxuXHRcdC8vIFN0ZXAgMlxuXHRcdHZhciB2ZXJ0aWNhbEJveFdpZHRoID0gKHdpZHRoIC0gY2hhcnRBcmVhV2lkdGgpIC8gdmVydGljYWxCb3hlcy5sZW5ndGg7XG5cblx0XHQvLyBTdGVwIDNcblx0XHQvLyBUT0RPIHJlLWxpbWl0IGhvcml6b250YWwgYXhpcyBoZWlnaHQgKHRoaXMgbGltaXQgaGFzIGFmZmVjdGVkIG9ubHkgcGFkZGluZyBjYWxjdWxhdGlvbiBzaW5jZSBQUiAxODM3KVxuXHRcdC8vIHZhciBob3Jpem9udGFsQm94SGVpZ2h0ID0gKGhlaWdodCAtIGNoYXJ0QXJlYUhlaWdodCkgLyBob3Jpem9udGFsQm94ZXMubGVuZ3RoO1xuXG5cdFx0Ly8gU3RlcCA0XG5cdFx0dmFyIG1heENoYXJ0QXJlYVdpZHRoID0gY2hhcnRXaWR0aDtcblx0XHR2YXIgbWF4Q2hhcnRBcmVhSGVpZ2h0ID0gY2hhcnRIZWlnaHQ7XG5cdFx0dmFyIG91dGVyQm94U2l6ZXMgPSB7dG9wOiB0b3BQYWRkaW5nLCBsZWZ0OiBsZWZ0UGFkZGluZywgYm90dG9tOiBib3R0b21QYWRkaW5nLCByaWdodDogcmlnaHRQYWRkaW5nfTtcblx0XHR2YXIgbWluQm94U2l6ZXMgPSBbXTtcblx0XHR2YXIgbWF4UGFkZGluZztcblxuXHRcdGZ1bmN0aW9uIGdldE1pbmltdW1Cb3hTaXplKGJveCkge1xuXHRcdFx0dmFyIG1pblNpemU7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gYm94LmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdG1pblNpemUgPSBib3gudXBkYXRlKGJveC5mdWxsV2lkdGggPyBjaGFydFdpZHRoIDogbWF4Q2hhcnRBcmVhV2lkdGgsIGNoYXJ0SGVpZ2h0IC8gMik7XG5cdFx0XHRcdG1heENoYXJ0QXJlYUhlaWdodCAtPSBtaW5TaXplLmhlaWdodDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pblNpemUgPSBib3gudXBkYXRlKHZlcnRpY2FsQm94V2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCk7XG5cdFx0XHRcdG1heENoYXJ0QXJlYVdpZHRoIC09IG1pblNpemUud2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdG1pbkJveFNpemVzLnB1c2goe1xuXHRcdFx0XHRob3Jpem9udGFsOiBpc0hvcml6b250YWwsXG5cdFx0XHRcdHdpZHRoOiBtaW5TaXplLndpZHRoLFxuXHRcdFx0XHRib3g6IGJveCxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGhlbHBlcnMkMS5lYWNoKG91dGVyQm94ZXMsIGdldE1pbmltdW1Cb3hTaXplKTtcblxuXHRcdC8vIElmIGEgaG9yaXpvbnRhbCBib3ggaGFzIHBhZGRpbmcsIHdlIG1vdmUgdGhlIGxlZnQgYm94ZXMgb3ZlciB0byBhdm9pZCB1Z2x5IGNoYXJ0cyAoc2VlIGlzc3VlICMyNDc4KVxuXHRcdG1heFBhZGRpbmcgPSBmaW5kTWF4UGFkZGluZyhvdXRlckJveGVzKTtcblxuXHRcdC8vIEF0IHRoaXMgcG9pbnQsIG1heENoYXJ0QXJlYUhlaWdodCBhbmQgbWF4Q2hhcnRBcmVhV2lkdGggYXJlIHRoZSBzaXplIHRoZSBjaGFydCBhcmVhIGNvdWxkXG5cdFx0Ly8gYmUgaWYgdGhlIGF4ZXMgYXJlIGRyYXduIGF0IHRoZWlyIG1pbmltdW0gc2l6ZXMuXG5cdFx0Ly8gU3RlcHMgNSAmIDZcblxuXHRcdC8vIEZ1bmN0aW9uIHRvIGZpdCBhIGJveFxuXHRcdGZ1bmN0aW9uIGZpdEJveChib3gpIHtcblx0XHRcdHZhciBtaW5Cb3hTaXplID0gaGVscGVycyQxLmZpbmROZXh0V2hlcmUobWluQm94U2l6ZXMsIGZ1bmN0aW9uKG1pbkJveCkge1xuXHRcdFx0XHRyZXR1cm4gbWluQm94LmJveCA9PT0gYm94O1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChtaW5Cb3hTaXplKSB7XG5cdFx0XHRcdGlmIChtaW5Cb3hTaXplLmhvcml6b250YWwpIHtcblx0XHRcdFx0XHR2YXIgc2NhbGVNYXJnaW4gPSB7XG5cdFx0XHRcdFx0XHRsZWZ0OiBNYXRoLm1heChvdXRlckJveFNpemVzLmxlZnQsIG1heFBhZGRpbmcubGVmdCksXG5cdFx0XHRcdFx0XHRyaWdodDogTWF0aC5tYXgob3V0ZXJCb3hTaXplcy5yaWdodCwgbWF4UGFkZGluZy5yaWdodCksXG5cdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHRib3R0b206IDBcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgdXNlIG1pbiBzaXplIGhlcmUgYmVjYXVzZSBvZiBsYWJlbCByb3RhdGlvbi4gV2hlbiB0aGUgbGFiZWxzIGFyZSByb3RhdGVkLCB0aGVpciByb3RhdGlvbiBoaWdobHkgZGVwZW5kc1xuXHRcdFx0XHRcdC8vIG9uIHRoZSBtYXJnaW4uIFNvbWV0aW1lcyB0aGV5IG5lZWQgdG8gaW5jcmVhc2UgaW4gc2l6ZSBzbGlnaHRseVxuXHRcdFx0XHRcdGJveC51cGRhdGUoYm94LmZ1bGxXaWR0aCA/IGNoYXJ0V2lkdGggOiBtYXhDaGFydEFyZWFXaWR0aCwgY2hhcnRIZWlnaHQgLyAyLCBzY2FsZU1hcmdpbik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ym94LnVwZGF0ZShtaW5Cb3hTaXplLndpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlLCBhbmQgY2FsY3VsYXRlIHRoZSBsZWZ0IGFuZCByaWdodCBtYXJnaW5zIGZvciB0aGUgaG9yaXpvbnRhbCBib3hlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKHZlcnRpY2FsQm94ZXMsIGZpdEJveCk7XG5cdFx0YWRkU2l6ZUJ5UG9zaXRpb24odmVydGljYWxCb3hlcywgb3V0ZXJCb3hTaXplcyk7XG5cblx0XHQvLyBTZXQgdGhlIExlZnQgYW5kIFJpZ2h0IG1hcmdpbnMgZm9yIHRoZSBob3Jpem9udGFsIGJveGVzXG5cdFx0aGVscGVycyQxLmVhY2goaG9yaXpvbnRhbEJveGVzLCBmaXRCb3gpO1xuXHRcdGFkZFNpemVCeVBvc2l0aW9uKGhvcml6b250YWxCb3hlcywgb3V0ZXJCb3hTaXplcyk7XG5cblx0XHRmdW5jdGlvbiBmaW5hbEZpdFZlcnRpY2FsQm94KGJveCkge1xuXHRcdFx0dmFyIG1pbkJveFNpemUgPSBoZWxwZXJzJDEuZmluZE5leHRXaGVyZShtaW5Cb3hTaXplcywgZnVuY3Rpb24obWluU2l6ZSkge1xuXHRcdFx0XHRyZXR1cm4gbWluU2l6ZS5ib3ggPT09IGJveDtcblx0XHRcdH0pO1xuXG5cdFx0XHR2YXIgc2NhbGVNYXJnaW4gPSB7XG5cdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHR0b3A6IG91dGVyQm94U2l6ZXMudG9wLFxuXHRcdFx0XHRib3R0b206IG91dGVyQm94U2l6ZXMuYm90dG9tXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAobWluQm94U2l6ZSkge1xuXHRcdFx0XHRib3gudXBkYXRlKG1pbkJveFNpemUud2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCwgc2NhbGVNYXJnaW4pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIExldCB0aGUgbGVmdCBsYXlvdXQga25vdyB0aGUgZmluYWwgbWFyZ2luXG5cdFx0aGVscGVycyQxLmVhY2godmVydGljYWxCb3hlcywgZmluYWxGaXRWZXJ0aWNhbEJveCk7XG5cblx0XHQvLyBSZWNhbGN1bGF0ZSBiZWNhdXNlIHRoZSBzaXplIG9mIGVhY2ggbGF5b3V0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbGlnaHRseSBkdWUgdG8gdGhlIG1hcmdpbnMgKGxhYmVsIHJvdGF0aW9uIGZvciBpbnN0YW5jZSlcblx0XHRvdXRlckJveFNpemVzID0ge3RvcDogdG9wUGFkZGluZywgbGVmdDogbGVmdFBhZGRpbmcsIGJvdHRvbTogYm90dG9tUGFkZGluZywgcmlnaHQ6IHJpZ2h0UGFkZGluZ307XG5cdFx0YWRkU2l6ZUJ5UG9zaXRpb24ob3V0ZXJCb3hlcywgb3V0ZXJCb3hTaXplcyk7XG5cblx0XHQvLyBXZSBtYXkgYmUgYWRkaW5nIHNvbWUgcGFkZGluZyB0byBhY2NvdW50IGZvciByb3RhdGVkIHggYXhpcyBsYWJlbHNcblx0XHR2YXIgbGVmdFBhZGRpbmdBZGRpdGlvbiA9IE1hdGgubWF4KG1heFBhZGRpbmcubGVmdCAtIG91dGVyQm94U2l6ZXMubGVmdCwgMCk7XG5cdFx0b3V0ZXJCb3hTaXplcy5sZWZ0ICs9IGxlZnRQYWRkaW5nQWRkaXRpb247XG5cdFx0b3V0ZXJCb3hTaXplcy5yaWdodCArPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0IC0gb3V0ZXJCb3hTaXplcy5yaWdodCwgMCk7XG5cblx0XHR2YXIgdG9wUGFkZGluZ0FkZGl0aW9uID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AgLSBvdXRlckJveFNpemVzLnRvcCwgMCk7XG5cdFx0b3V0ZXJCb3hTaXplcy50b3AgKz0gdG9wUGFkZGluZ0FkZGl0aW9uO1xuXHRcdG91dGVyQm94U2l6ZXMuYm90dG9tICs9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tIC0gb3V0ZXJCb3hTaXplcy5ib3R0b20sIDApO1xuXG5cdFx0Ly8gRmlndXJlIG91dCBpZiBvdXIgY2hhcnQgYXJlYSBjaGFuZ2VkLiBUaGlzIHdvdWxkIG9jY3VyIGlmIHRoZSBkYXRhc2V0IGxheW91dCBsYWJlbCByb3RhdGlvblxuXHRcdC8vIGNoYW5nZWQgZHVlIHRvIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGUgbWFyZ2lucyBpbiBzdGVwIDYuIFNpbmNlIHdlIGNhbiBvbmx5IGdldCBiaWdnZXIsIHRoaXMgaXMgc2FmZSB0byBkb1xuXHRcdC8vIHdpdGhvdXQgY2FsbGluZyBgZml0YCBhZ2FpblxuXHRcdHZhciBuZXdNYXhDaGFydEFyZWFIZWlnaHQgPSBoZWlnaHQgLSBvdXRlckJveFNpemVzLnRvcCAtIG91dGVyQm94U2l6ZXMuYm90dG9tO1xuXHRcdHZhciBuZXdNYXhDaGFydEFyZWFXaWR0aCA9IHdpZHRoIC0gb3V0ZXJCb3hTaXplcy5sZWZ0IC0gb3V0ZXJCb3hTaXplcy5yaWdodDtcblxuXHRcdGlmIChuZXdNYXhDaGFydEFyZWFXaWR0aCAhPT0gbWF4Q2hhcnRBcmVhV2lkdGggfHwgbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0ICE9PSBtYXhDaGFydEFyZWFIZWlnaHQpIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKHZlcnRpY2FsQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHRib3guaGVpZ2h0ID0gbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXHRcdFx0fSk7XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGhvcml6b250YWxCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdGlmICghYm94LmZ1bGxXaWR0aCkge1xuXHRcdFx0XHRcdGJveC53aWR0aCA9IG5ld01heENoYXJ0QXJlYVdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0bWF4Q2hhcnRBcmVhSGVpZ2h0ID0gbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXHRcdFx0bWF4Q2hhcnRBcmVhV2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHR9XG5cblx0XHQvLyBTdGVwIDcgLSBQb3NpdGlvbiB0aGUgYm94ZXNcblx0XHR2YXIgbGVmdCA9IGxlZnRQYWRkaW5nICsgbGVmdFBhZGRpbmdBZGRpdGlvbjtcblx0XHR2YXIgdG9wID0gdG9wUGFkZGluZyArIHRvcFBhZGRpbmdBZGRpdGlvbjtcblxuXHRcdGZ1bmN0aW9uIHBsYWNlQm94KGJveCkge1xuXHRcdFx0aWYgKGJveC5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRib3gubGVmdCA9IGJveC5mdWxsV2lkdGggPyBsZWZ0UGFkZGluZyA6IG91dGVyQm94U2l6ZXMubGVmdDtcblx0XHRcdFx0Ym94LnJpZ2h0ID0gYm94LmZ1bGxXaWR0aCA/IHdpZHRoIC0gcmlnaHRQYWRkaW5nIDogb3V0ZXJCb3hTaXplcy5sZWZ0ICsgbWF4Q2hhcnRBcmVhV2lkdGg7XG5cdFx0XHRcdGJveC50b3AgPSB0b3A7XG5cdFx0XHRcdGJveC5ib3R0b20gPSB0b3AgKyBib3guaGVpZ2h0O1xuXG5cdFx0XHRcdC8vIE1vdmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHR0b3AgPSBib3guYm90dG9tO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGJveC5sZWZ0ID0gbGVmdDtcblx0XHRcdFx0Ym94LnJpZ2h0ID0gbGVmdCArIGJveC53aWR0aDtcblx0XHRcdFx0Ym94LnRvcCA9IG91dGVyQm94U2l6ZXMudG9wO1xuXHRcdFx0XHRib3guYm90dG9tID0gb3V0ZXJCb3hTaXplcy50b3AgKyBtYXhDaGFydEFyZWFIZWlnaHQ7XG5cblx0XHRcdFx0Ly8gTW92ZSB0byBuZXh0IHBvaW50XG5cdFx0XHRcdGxlZnQgPSBib3gucmlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmVhY2gobGVmdEJveGVzLmNvbmNhdCh0b3BCb3hlcyksIHBsYWNlQm94KTtcblxuXHRcdC8vIEFjY291bnQgZm9yIGNoYXJ0IHdpZHRoIGFuZCBoZWlnaHRcblx0XHRsZWZ0ICs9IG1heENoYXJ0QXJlYVdpZHRoO1xuXHRcdHRvcCArPSBtYXhDaGFydEFyZWFIZWlnaHQ7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChyaWdodEJveGVzLCBwbGFjZUJveCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm90dG9tQm94ZXMsIHBsYWNlQm94KTtcblxuXHRcdC8vIFN0ZXAgOFxuXHRcdGNoYXJ0LmNoYXJ0QXJlYSA9IHtcblx0XHRcdGxlZnQ6IG91dGVyQm94U2l6ZXMubGVmdCxcblx0XHRcdHRvcDogb3V0ZXJCb3hTaXplcy50b3AsXG5cdFx0XHRyaWdodDogb3V0ZXJCb3hTaXplcy5sZWZ0ICsgbWF4Q2hhcnRBcmVhV2lkdGgsXG5cdFx0XHRib3R0b206IG91dGVyQm94U2l6ZXMudG9wICsgbWF4Q2hhcnRBcmVhSGVpZ2h0XG5cdFx0fTtcblxuXHRcdC8vIFN0ZXAgOVxuXHRcdGhlbHBlcnMkMS5lYWNoKGNoYXJ0QXJlYUJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdGJveC5sZWZ0ID0gY2hhcnQuY2hhcnRBcmVhLmxlZnQ7XG5cdFx0XHRib3gudG9wID0gY2hhcnQuY2hhcnRBcmVhLnRvcDtcblx0XHRcdGJveC5yaWdodCA9IGNoYXJ0LmNoYXJ0QXJlYS5yaWdodDtcblx0XHRcdGJveC5ib3R0b20gPSBjaGFydC5jaGFydEFyZWEuYm90dG9tO1xuXG5cdFx0XHRib3gudXBkYXRlKG1heENoYXJ0QXJlYVdpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQpO1xuXHRcdH0pO1xuXHR9XG59O1xuXG4vKipcbiAqIFBsYXRmb3JtIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIChtaW5pbWFsKS5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTkxI2lzc3VlY29tbWVudC0zMTk1NzU5MzlcbiAqL1xuXG52YXIgcGxhdGZvcm1fYmFzaWMgPSB7XG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYgKGl0ZW0gJiYgaXRlbS5jYW52YXMpIHtcblx0XHRcdC8vIFN1cHBvcnQgZm9yIGFueSBvYmplY3QgYXNzb2NpYXRlZCB0byBhIGNhbnZhcyAoaW5jbHVkaW5nIGEgY29udGV4dDJkKVxuXHRcdFx0aXRlbSA9IGl0ZW0uY2FudmFzO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuXHR9XG59O1xuXG52YXIgcGxhdGZvcm1fZG9tID0gXCIvKlxcbiAqIERPTSBlbGVtZW50IHJlbmRlcmluZyBkZXRlY3Rpb25cXG4gKiBodHRwczovL2Rhdmlkd2Fsc2gubmFtZS9kZXRlY3Qtbm9kZS1pbnNlcnRpb25cXG4gKi9cXG5Aa2V5ZnJhbWVzIGNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbiB7XFxuXFx0ZnJvbSB7IG9wYWNpdHk6IDAuOTk7IH1cXG5cXHR0byB7IG9wYWNpdHk6IDE7IH1cXG59XFxuXFxuLmNoYXJ0anMtcmVuZGVyLW1vbml0b3Ige1xcblxcdGFuaW1hdGlvbjogY2hhcnRqcy1yZW5kZXItYW5pbWF0aW9uIDAuMDAxcztcXG59XFxuXFxuLypcXG4gKiBET00gZWxlbWVudCByZXNpemluZyBkZXRlY3Rpb25cXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllc1xcbiAqL1xcbi5jaGFydGpzLXNpemUtbW9uaXRvcixcXG4uY2hhcnRqcy1zaXplLW1vbml0b3ItZXhwYW5kLFxcbi5jaGFydGpzLXNpemUtbW9uaXRvci1zaHJpbmsge1xcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHRkaXJlY3Rpb246IGx0cjtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG5cXHRyaWdodDogMDtcXG5cXHRib3R0b206IDA7XFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXG5cXHR2aXNpYmlsaXR5OiBoaWRkZW47XFxuXFx0ei1pbmRleDogLTE7XFxufVxcblxcbi5jaGFydGpzLXNpemUtbW9uaXRvci1leHBhbmQgPiBkaXYge1xcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHR3aWR0aDogMTAwMDAwMHB4O1xcblxcdGhlaWdodDogMTAwMDAwMHB4O1xcblxcdGxlZnQ6IDA7XFxuXFx0dG9wOiAwO1xcbn1cXG5cXG4uY2hhcnRqcy1zaXplLW1vbml0b3Itc2hyaW5rID4gZGl2IHtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0d2lkdGg6IDIwMCU7XFxuXFx0aGVpZ2h0OiAyMDAlO1xcblxcdGxlZnQ6IDA7XFxuXFx0dG9wOiAwO1xcbn1cXG5cIjtcblxudmFyIHBsYXRmb3JtX2RvbSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuZGVmYXVsdDogcGxhdGZvcm1fZG9tXG59KTtcblxuZnVuY3Rpb24gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZSAobikge1xuXHRyZXR1cm4gbiAmJiBuLmRlZmF1bHQgfHwgbjtcbn1cblxudmFyIHN0eWxlc2hlZXQgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKHBsYXRmb3JtX2RvbSQxKTtcblxudmFyIEVYUEFORE9fS0VZID0gJyRjaGFydGpzJztcbnZhciBDU1NfUFJFRklYID0gJ2NoYXJ0anMtJztcbnZhciBDU1NfU0laRV9NT05JVE9SID0gQ1NTX1BSRUZJWCArICdzaXplLW1vbml0b3InO1xudmFyIENTU19SRU5ERVJfTU9OSVRPUiA9IENTU19QUkVGSVggKyAncmVuZGVyLW1vbml0b3InO1xudmFyIENTU19SRU5ERVJfQU5JTUFUSU9OID0gQ1NTX1BSRUZJWCArICdyZW5kZXItYW5pbWF0aW9uJztcbnZhciBBTklNQVRJT05fU1RBUlRfRVZFTlRTID0gWydhbmltYXRpb25zdGFydCcsICd3ZWJraXRBbmltYXRpb25TdGFydCddO1xuXG4vKipcbiAqIERPTSBldmVudCB0eXBlcyAtPiBDaGFydC5qcyBldmVudCB0eXBlcy5cbiAqIE5vdGU6IG9ubHkgZXZlbnRzIHdpdGggZGlmZmVyZW50IHR5cGVzIGFyZSBtYXBwZWQuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50c1xuICovXG52YXIgRVZFTlRfVFlQRVMgPSB7XG5cdHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuXHR0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuXHR0b3VjaGVuZDogJ21vdXNldXAnLFxuXHRwb2ludGVyZW50ZXI6ICdtb3VzZWVudGVyJyxcblx0cG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxuXHRwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXG5cdHBvaW50ZXJ1cDogJ21vdXNldXAnLFxuXHRwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXG5cdHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcbn07XG5cbi8qKlxuICogVGhlIFwidXNlZFwiIHNpemUgaXMgdGhlIGZpbmFsIHZhbHVlIG9mIGEgZGltZW5zaW9uIHByb3BlcnR5IGFmdGVyIGFsbCBjYWxjdWxhdGlvbnMgaGF2ZVxuICogYmVlbiBwZXJmb3JtZWQuIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIGBlbGVtZW50YCBidXQgcmV0dXJucyB1bmRlZmluZWRcbiAqIGlmIHRoZSBjb21wdXRlZCBzdHlsZSBpcyBub3QgZXhwcmVzc2VkIGluIHBpeGVscy4gVGhhdCBjYW4gaGFwcGVuIGluIHNvbWUgY2FzZXMgd2hlcmVcbiAqIGBlbGVtZW50YCBoYXMgYSBzaXplIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgYW5kIHRoaXMgbGFzdCBvbmUgaXMgbm90IHlldCBkaXNwbGF5ZWQsXG4gKiBmb3IgZXhhbXBsZSBiZWNhdXNlIG9mIGBkaXNwbGF5OiBub25lYCBvbiBhIHBhcmVudCBub2RlLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdXNlZF92YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gU2l6ZSBpbiBwaXhlbHMgb3IgdW5kZWZpbmVkIGlmIHVua25vd24uXG4gKi9cbmZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuXHR2YXIgdmFsdWUgPSBoZWxwZXJzJDEuZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuXHR2YXIgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuXHRyZXR1cm4gbWF0Y2hlcyA/IE51bWJlcihtYXRjaGVzWzFdKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIHN0eWxlIGFuZCByZW5kZXIgc2l6ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2FudmFzIGRpc3BsYXkgc2l6ZSxcbiAqIHNpbmNlIHJlc3BvbnNpdmVuZXNzIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRyb2xsZXIucmVzaXplKCkgbWV0aG9kLiBUaGUgY29uZmlnIGlzIHVzZWRcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cbiAqL1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGNvbmZpZykge1xuXHR2YXIgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG5cblx0Ly8gTk9URShTQikgY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAhPT0gY2FudmFzLndpZHRoOiBpbiB0aGUgZmlyc3QgY2FzZSBpdFxuXHQvLyByZXR1cm5zIG51bGwgb3IgJycgaWYgbm8gZXhwbGljaXQgdmFsdWUgaGFzIGJlZW4gc2V0IHRvIHRoZSBjYW52YXMgYXR0cmlidXRlLlxuXHR2YXIgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG5cdHZhciByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG5cblx0Ly8gQ2hhcnQuanMgbW9kaWZpZXMgc29tZSBjYW52YXMgdmFsdWVzIHRoYXQgd2Ugd2FudCB0byByZXN0b3JlIG9uIGRlc3Ryb3lcblx0Y2FudmFzW0VYUEFORE9fS0VZXSA9IHtcblx0XHRpbml0aWFsOiB7XG5cdFx0XHRoZWlnaHQ6IHJlbmRlckhlaWdodCxcblx0XHRcdHdpZHRoOiByZW5kZXJXaWR0aCxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGRpc3BsYXk6IHN0eWxlLmRpc3BsYXksXG5cdFx0XHRcdGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuXHRcdFx0XHR3aWR0aDogc3R5bGUud2lkdGhcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gRm9yY2UgY2FudmFzIHRvIGRpc3BsYXkgYXMgYmxvY2sgdG8gYXZvaWQgZXh0cmEgc3BhY2UgY2F1c2VkIGJ5IGlubGluZVxuXHQvLyBlbGVtZW50cywgd2hpY2ggd291bGQgaW50ZXJmZXJlIHdpdGggdGhlIHJlc3BvbnNpdmUgcmVzaXplIHByb2Nlc3MuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNTM4XG5cdHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG5cblx0aWYgKHJlbmRlcldpZHRoID09PSBudWxsIHx8IHJlbmRlcldpZHRoID09PSAnJykge1xuXHRcdHZhciBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcblx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRpZiAocmVuZGVySGVpZ2h0ID09PSBudWxsIHx8IHJlbmRlckhlaWdodCA9PT0gJycpIHtcblx0XHRpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcblx0XHRcdC8vIElmIG5vIGV4cGxpY2l0IHJlbmRlciBoZWlnaHQgYW5kIHN0eWxlIGhlaWdodCwgbGV0J3MgYXBwbHkgdGhlIGFzcGVjdCByYXRpbyxcblx0XHRcdC8vIHdoaWNoIG9uZSBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIGJ1dCBhbHNvIGJ5IGNoYXJ0cyBhcyBkZWZhdWx0IG9wdGlvblxuXHRcdFx0Ly8gKGkuZS4gb3B0aW9ucy5hc3BlY3RSYXRpbykuIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBjYW52YXMgYXNwZWN0IHJhdGlvIG9mIDIuXG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGNvbmZpZy5vcHRpb25zLmFzcGVjdFJhdGlvIHx8IDIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcblx0XHRcdGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2FudmFzO1xufVxuXG4vKipcbiAqIERldGVjdHMgc3VwcG9ydCBmb3Igb3B0aW9ucyBvYmplY3QgYXJndW1lbnQgaW4gYWRkRXZlbnRMaXN0ZW5lci5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgc3VwcG9ydHMgPSBmYWxzZTtcblx0dHJ5IHtcblx0XHR2YXIgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2V0dGVyLXJldHVyblxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3VwcG9ydHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlJywgbnVsbCwgb3B0aW9ucyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG5cdH1cblx0cmV0dXJuIHN1cHBvcnRzO1xufSgpKTtcblxuLy8gRGVmYXVsdCBwYXNzaXZlIHRvIHRydWUgYXMgZXhwZWN0ZWQgYnkgQ2hyb21lIGZvciAndG91Y2hzdGFydCcgYW5kICd0b3VjaGVuZCcgZXZlbnRzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQyODdcbnZhciBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcblx0bm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgeCwgeSwgbmF0aXZlRXZlbnQpIHtcblx0cmV0dXJuIHtcblx0XHR0eXBlOiB0eXBlLFxuXHRcdGNoYXJ0OiBjaGFydCxcblx0XHRuYXRpdmU6IG5hdGl2ZUV2ZW50IHx8IG51bGwsXG5cdFx0eDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG5cdFx0eTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG5cdH07XG59XG5cbmZ1bmN0aW9uIGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpIHtcblx0dmFyIHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuXHR2YXIgcG9zID0gaGVscGVycyQxLmdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcblx0cmV0dXJuIGNyZWF0ZUV2ZW50KHR5cGUsIGNoYXJ0LCBwb3MueCwgcG9zLnksIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gdGhyb3R0bGVkKGZuLCB0aGlzQXJnKSB7XG5cdHZhciB0aWNraW5nID0gZmFsc2U7XG5cdHZhciBhcmdzID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdHRoaXNBcmcgPSB0aGlzQXJnIHx8IHRoaXM7XG5cblx0XHRpZiAoIXRpY2tpbmcpIHtcblx0XHRcdHRpY2tpbmcgPSB0cnVlO1xuXHRcdFx0aGVscGVycyQxLnJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aWNraW5nID0gZmFsc2U7XG5cdFx0XHRcdGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEaXYoY2xzKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRlbC5jbGFzc05hbWUgPSBjbHMgfHwgJyc7XG5cdHJldHVybiBlbDtcbn1cblxuLy8gSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXNcbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZXIoaGFuZGxlcikge1xuXHR2YXIgbWF4U2l6ZSA9IDEwMDAwMDA7XG5cblx0Ly8gTk9URShTQikgRG9uJ3QgdXNlIGlubmVySFRNTCBiZWNhdXNlIGl0IGNvdWxkIGJlIGNvbnNpZGVyZWQgdW5zYWZlLlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTkwMlxuXHR2YXIgcmVzaXplciA9IGNyZWF0ZURpdihDU1NfU0laRV9NT05JVE9SKTtcblx0dmFyIGV4cGFuZCA9IGNyZWF0ZURpdihDU1NfU0laRV9NT05JVE9SICsgJy1leHBhbmQnKTtcblx0dmFyIHNocmluayA9IGNyZWF0ZURpdihDU1NfU0laRV9NT05JVE9SICsgJy1zaHJpbmsnKTtcblxuXHRleHBhbmQuYXBwZW5kQ2hpbGQoY3JlYXRlRGl2KCkpO1xuXHRzaHJpbmsuYXBwZW5kQ2hpbGQoY3JlYXRlRGl2KCkpO1xuXG5cdHJlc2l6ZXIuYXBwZW5kQ2hpbGQoZXhwYW5kKTtcblx0cmVzaXplci5hcHBlbmRDaGlsZChzaHJpbmspO1xuXHRyZXNpemVyLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdGV4cGFuZC5zY3JvbGxMZWZ0ID0gbWF4U2l6ZTtcblx0XHRleHBhbmQuc2Nyb2xsVG9wID0gbWF4U2l6ZTtcblx0XHRzaHJpbmsuc2Nyb2xsTGVmdCA9IG1heFNpemU7XG5cdFx0c2hyaW5rLnNjcm9sbFRvcCA9IG1heFNpemU7XG5cdH07XG5cblx0dmFyIG9uU2Nyb2xsID0gZnVuY3Rpb24oKSB7XG5cdFx0cmVzaXplci5fcmVzZXQoKTtcblx0XHRoYW5kbGVyKCk7XG5cdH07XG5cblx0YWRkTGlzdGVuZXIoZXhwYW5kLCAnc2Nyb2xsJywgb25TY3JvbGwuYmluZChleHBhbmQsICdleHBhbmQnKSk7XG5cdGFkZExpc3RlbmVyKHNocmluaywgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoc2hyaW5rLCAnc2hyaW5rJykpO1xuXG5cdHJldHVybiByZXNpemVyO1xufVxuXG4vLyBodHRwczovL2Rhdmlkd2Fsc2gubmFtZS9kZXRlY3Qtbm9kZS1pbnNlcnRpb25cbmZ1bmN0aW9uIHdhdGNoRm9yUmVuZGVyKG5vZGUsIGhhbmRsZXIpIHtcblx0dmFyIGV4cGFuZG8gPSBub2RlW0VYUEFORE9fS0VZXSB8fCAobm9kZVtFWFBBTkRPX0tFWV0gPSB7fSk7XG5cdHZhciBwcm94eSA9IGV4cGFuZG8ucmVuZGVyUHJveHkgPSBmdW5jdGlvbihlKSB7XG5cdFx0aWYgKGUuYW5pbWF0aW9uTmFtZSA9PT0gQ1NTX1JFTkRFUl9BTklNQVRJT04pIHtcblx0XHRcdGhhbmRsZXIoKTtcblx0XHR9XG5cdH07XG5cblx0aGVscGVycyQxLmVhY2goQU5JTUFUSU9OX1NUQVJUX0VWRU5UUywgZnVuY3Rpb24odHlwZSkge1xuXHRcdGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcblx0fSk7XG5cblx0Ly8gIzQ3Mzc6IENocm9tZSBtaWdodCBza2lwIHRoZSBDU1MgYW5pbWF0aW9uIHdoZW4gdGhlIENTU19SRU5ERVJfTU9OSVRPUiBjbGFzc1xuXHQvLyBpcyByZW1vdmVkIHRoZW4gYWRkZWQgYmFjayBpbW1lZGlhdGVseSAoc2FtZSBhbmltYXRpb24gZnJhbWU/KS4gQWNjZXNzaW5nIHRoZVxuXHQvLyBgb2Zmc2V0UGFyZW50YCBwcm9wZXJ0eSB3aWxsIGZvcmNlIGEgcmVmbG93IGFuZCByZS1ldmFsdWF0ZSB0aGUgQ1NTIGFuaW1hdGlvbi5cblx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzVkNTJmYjA4MWIzNTcwYzgxZTNhI2JveC1tZXRyaWNzXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80NzM3XG5cdGV4cGFuZG8ucmVmbG93ID0gISFub2RlLm9mZnNldFBhcmVudDtcblxuXHRub2RlLmNsYXNzTGlzdC5hZGQoQ1NTX1JFTkRFUl9NT05JVE9SKTtcbn1cblxuZnVuY3Rpb24gdW53YXRjaEZvclJlbmRlcihub2RlKSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwge307XG5cdHZhciBwcm94eSA9IGV4cGFuZG8ucmVuZGVyUHJveHk7XG5cblx0aWYgKHByb3h5KSB7XG5cdFx0aGVscGVycyQxLmVhY2goQU5JTUFUSU9OX1NUQVJUX0VWRU5UUywgZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0cmVtb3ZlTGlzdGVuZXIobm9kZSwgdHlwZSwgcHJveHkpO1xuXHRcdH0pO1xuXG5cdFx0ZGVsZXRlIGV4cGFuZG8ucmVuZGVyUHJveHk7XG5cdH1cblxuXHRub2RlLmNsYXNzTGlzdC5yZW1vdmUoQ1NTX1JFTkRFUl9NT05JVE9SKTtcbn1cblxuZnVuY3Rpb24gYWRkUmVzaXplTGlzdGVuZXIobm9kZSwgbGlzdGVuZXIsIGNoYXJ0KSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwgKG5vZGVbRVhQQU5ET19LRVldID0ge30pO1xuXG5cdC8vIExldCdzIGtlZXAgdHJhY2sgb2YgdGhpcyBhZGRlZCByZXNpemVyIGFuZCB0aHVzIGF2b2lkIERPTSBxdWVyeSB3aGVuIHJlbW92aW5nIGl0LlxuXHR2YXIgcmVzaXplciA9IGV4cGFuZG8ucmVzaXplciA9IGNyZWF0ZVJlc2l6ZXIodGhyb3R0bGVkKGZ1bmN0aW9uKCkge1xuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcblx0XHRcdHZhciBjb250YWluZXIgPSBjaGFydC5vcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgbm9kZS5wYXJlbnROb2RlO1xuXHRcdFx0dmFyIHcgPSBjb250YWluZXIgPyBjb250YWluZXIuY2xpZW50V2lkdGggOiAwO1xuXHRcdFx0bGlzdGVuZXIoY3JlYXRlRXZlbnQoJ3Jlc2l6ZScsIGNoYXJ0KSk7XG5cdFx0XHRpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5jbGllbnRXaWR0aCA8IHcgJiYgY2hhcnQuY2FudmFzKSB7XG5cdFx0XHRcdC8vIElmIHRoZSBjb250YWluZXIgc2l6ZSBzaHJhbmsgZHVyaW5nIGNoYXJ0IHJlc2l6ZSwgbGV0J3MgYXNzdW1lXG5cdFx0XHRcdC8vIHNjcm9sbGJhciBhcHBlYXJlZC4gU28gd2UgcmVzaXplIGFnYWluIHdpdGggdGhlIHNjcm9sbGJhciB2aXNpYmxlIC1cblx0XHRcdFx0Ly8gZWZmZWN0aXZlbHkgbWFraW5nIGNoYXJ0IHNtYWxsZXIgYW5kIHRoZSBzY3JvbGxiYXIgaGlkZGVuIGFnYWluLlxuXHRcdFx0XHQvLyBCZWNhdXNlIHdlIGFyZSBpbnNpZGUgYHRocm90dGxlZGAsIGFuZCBjdXJyZW50bHkgYHRpY2tpbmdgLCBzY3JvbGxcblx0XHRcdFx0Ly8gZXZlbnRzIGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIHdob2xlIDIgcmVzaXplIHByb2Nlc3MuXG5cdFx0XHRcdC8vIElmIHdlIGFzc3VtZWQgd3JvbmcgYW5kIHNvbWV0aGluZyBlbHNlIGhhcHBlbmVkLCB3ZSBhcmUgcmVzaXppbmdcblx0XHRcdFx0Ly8gdHdpY2UgaW4gYSBmcmFtZSAocG90ZW50aWFsIHBlcmZvcm1hbmNlIGlzc3VlKVxuXHRcdFx0XHRsaXN0ZW5lcihjcmVhdGVFdmVudCgncmVzaXplJywgY2hhcnQpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pKTtcblxuXHQvLyBUaGUgcmVzaXplciBuZWVkcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZSBwYXJlbnQsIHNvIHdlIGZpcnN0IG5lZWQgdG8gYmVcblx0Ly8gc3VyZSB0aGF0IGBub2RlYCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NIGJlZm9yZSBpbmplY3RpbmcgdGhlIHJlc2l6ZXIgZWxlbWVudC5cblx0d2F0Y2hGb3JSZW5kZXIobm9kZSwgZnVuY3Rpb24oKSB7XG5cdFx0aWYgKGV4cGFuZG8ucmVzaXplcikge1xuXHRcdFx0dmFyIGNvbnRhaW5lciA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdGlmIChjb250YWluZXIgJiYgY29udGFpbmVyICE9PSByZXNpemVyLnBhcmVudE5vZGUpIHtcblx0XHRcdFx0Y29udGFpbmVyLmluc2VydEJlZm9yZShyZXNpemVyLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBjb250YWluZXIgc2l6ZSBtaWdodCBoYXZlIGNoYW5nZWQsIGxldCdzIHJlc2V0IHRoZSByZXNpemVyIHN0YXRlLlxuXHRcdFx0cmVzaXplci5fcmVzZXQoKTtcblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVSZXNpemVMaXN0ZW5lcihub2RlKSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwge307XG5cdHZhciByZXNpemVyID0gZXhwYW5kby5yZXNpemVyO1xuXG5cdGRlbGV0ZSBleHBhbmRvLnJlc2l6ZXI7XG5cdHVud2F0Y2hGb3JSZW5kZXIobm9kZSk7XG5cblx0aWYgKHJlc2l6ZXIgJiYgcmVzaXplci5wYXJlbnROb2RlKSB7XG5cdFx0cmVzaXplci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJlc2l6ZXIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGluamVjdENTUyhwbGF0Zm9ybSwgY3NzKSB7XG5cdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTIyMTM5XG5cdHZhciBzdHlsZSA9IHBsYXRmb3JtLl9zdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXHRpZiAoIXBsYXRmb3JtLl9zdHlsZSkge1xuXHRcdHBsYXRmb3JtLl9zdHlsZSA9IHN0eWxlO1xuXHRcdGNzcyA9ICcvKiBDaGFydC5qcyAqL1xcbicgKyBjc3M7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG5cdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH1cblxuXHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbn1cblxudmFyIHBsYXRmb3JtX2RvbSQyID0ge1xuXHQvKipcblx0ICogV2hlbiBgdHJ1ZWAsIHByZXZlbnRzIHRoZSBhdXRvbWF0aWMgaW5qZWN0aW9uIG9mIHRoZSBzdHlsZXNoZWV0IHJlcXVpcmVkIHRvXG5cdCAqIGNvcnJlY3RseSBkZXRlY3Qgd2hlbiB0aGUgY2hhcnQgaXMgYWRkZWQgdG8gdGhlIERPTSBhbmQgdGhlbiByZXNpemVkLiBUaGlzXG5cdCAqIHN3aXRjaCBoYXMgYmVlbiBhZGRlZCB0byBhbGxvdyBleHRlcm5hbCBzdHlsZXNoZWV0IChgZGlzdC9DaGFydCgubWluKT8uanNgKVxuXHQgKiB0byBiZSBtYW51YWxseSBpbXBvcnRlZCB0byBtYWtlIHRoaXMgbGlicmFyeSBjb21wYXRpYmxlIHdpdGggYW55IENTUC5cblx0ICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MjA4XG5cdCAqL1xuXHRkaXNhYmxlQ1NTSW5qZWN0aW9uOiBmYWxzZSxcblxuXHQvKipcblx0ICogVGhpcyBwcm9wZXJ0eSBob2xkcyB3aGV0aGVyIHRoaXMgcGxhdGZvcm0gaXMgZW5hYmxlZCBmb3IgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG5cdCAqIEN1cnJlbnRseSB1c2VkIGJ5IHBsYXRmb3JtLmpzIHRvIHNlbGVjdCB0aGUgcHJvcGVyIGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2VuYWJsZWQ6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZW5zdXJlTG9hZGVkOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcblxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MjA4XG5cdFx0aWYgKCF0aGlzLmRpc2FibGVDU1NJbmplY3Rpb24pIHtcblx0XHRcdGluamVjdENTUyh0aGlzLCBzdHlsZXNoZWV0KTtcblx0XHR9XG5cdH0sXG5cblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKGl0ZW0sIGNvbmZpZykge1xuXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcblx0XHR9IGVsc2UgaWYgKGl0ZW0ubGVuZ3RoKSB7XG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhcnJheSBiYXNlZCBxdWVyaWVzIChzdWNoIGFzIGpRdWVyeSlcblx0XHRcdGl0ZW0gPSBpdGVtWzBdO1xuXHRcdH1cblxuXHRcdGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcblx0XHRcdGl0ZW0gPSBpdGVtLmNhbnZhcztcblx0XHR9XG5cblx0XHQvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG5cdFx0Ly8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuXHRcdHZhciBjb250ZXh0ID0gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpO1xuXG5cdFx0Ly8gTG9hZCBwbGF0Zm9ybSByZXNvdXJjZXMgb24gZmlyc3QgY2hhcnQgY3JlYXRpb24sIHRvIG1ha2UgcG9zc2libGUgdG8gY2hhbmdlXG5cdFx0Ly8gcGxhdGZvcm0gb3B0aW9ucyBhZnRlciBpbXBvcnRpbmcgdGhlIGxpYnJhcnkgKGUuZy4gYGRpc2FibGVDU1NJbmplY3Rpb25gKS5cblx0XHR0aGlzLl9lbnN1cmVMb2FkZWQoKTtcblxuXHRcdC8vIGBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50L0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgZmFpbHMgd2hlbiB0aGUgaXRlbSBpc1xuXHRcdC8vIGluc2lkZSBhbiBpZnJhbWUgb3Igd2hlbiBydW5uaW5nIGluIGEgcHJvdGVjdGVkIGVudmlyb25tZW50LiBXZSBjb3VsZCBndWVzcyB0aGVcblx0XHQvLyB0eXBlcyBmcm9tIHRoZWlyIHRvU3RyaW5nKCkgdmFsdWUgYnV0IGxldCdzIGtlZXAgdGhpbmdzIGZsZXhpYmxlIGFuZCBhc3N1bWUgaXQnc1xuXHRcdC8vIGEgc3VmZmljaWVudCBjb25kaXRpb24gaWYgdGhlIGl0ZW0gaGFzIGEgY29udGV4dDJEIHdoaWNoIGhhcyBpdGVtIGFzIGBjYW52YXNgLlxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE1MlxuXHRcdGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBpdGVtKSB7XG5cdFx0XHRpbml0Q2FudmFzKGl0ZW0sIGNvbmZpZyk7XG5cdFx0XHRyZXR1cm4gY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRyZWxlYXNlQ29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdHZhciBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcblx0XHRpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW5pdGlhbCA9IGNhbnZhc1tFWFBBTkRPX0tFWV0uaW5pdGlhbDtcblx0XHRbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuXHRcdFx0dmFyIHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcblx0XHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcblx0XHRcdFx0Y2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aGVscGVycyQxLmVhY2goaW5pdGlhbC5zdHlsZSB8fCB7fSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0Y2FudmFzLnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHR9KTtcblxuXHRcdC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxuXHRcdC8vIHdlIGNhbid0IHVzZSBzYXZlKCkgYW5kIHJlc3RvcmUoKSB0byByZXN0b3JlIHRoZSBpbml0aWFsIHN0YXRlLiBTbyBtYWtlIHN1cmUgdGhhdCBhdFxuXHRcdC8vIGxlYXN0IHRoZSBjYW52YXMgY29udGV4dCBpcyByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBieSBzZXR0aW5nIHRoZSBjYW52YXMgd2lkdGguXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cblx0XHRkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcblx0fSxcblxuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdGlmICh0eXBlID09PSAncmVzaXplJykge1xuXHRcdFx0Ly8gTm90ZTogdGhlIHJlc2l6ZSBldmVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFsbCBicm93c2Vycy5cblx0XHRcdGFkZFJlc2l6ZUxpc3RlbmVyKGNhbnZhcywgbGlzdGVuZXIsIGNoYXJ0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZXhwYW5kbyA9IGxpc3RlbmVyW0VYUEFORE9fS0VZXSB8fCAobGlzdGVuZXJbRVhQQU5ET19LRVldID0ge30pO1xuXHRcdHZhciBwcm94aWVzID0gZXhwYW5kby5wcm94aWVzIHx8IChleHBhbmRvLnByb3hpZXMgPSB7fSk7XG5cdFx0dmFyIHByb3h5ID0gcHJveGllc1tjaGFydC5pZCArICdfJyArIHR5cGVdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGxpc3RlbmVyKGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpKTtcblx0XHR9O1xuXG5cdFx0YWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG5cdH0sXG5cblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblx0XHRpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcblx0XHRcdC8vIE5vdGU6IHRoZSByZXNpemUgZXZlbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBhbGwgYnJvd3NlcnMuXG5cdFx0XHRyZW1vdmVSZXNpemVMaXN0ZW5lcihjYW52YXMpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBleHBhbmRvID0gbGlzdGVuZXJbRVhQQU5ET19LRVldIHx8IHt9O1xuXHRcdHZhciBwcm94aWVzID0gZXhwYW5kby5wcm94aWVzIHx8IHt9O1xuXHRcdHZhciBwcm94eSA9IHByb3hpZXNbY2hhcnQuaWQgKyAnXycgKyB0eXBlXTtcblx0XHRpZiAoIXByb3h5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmVtb3ZlTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG5cdH1cbn07XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLlxuICogRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhIDcsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5hZGRFdmVudFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycyQxLmFkZEV2ZW50ID0gYWRkTGlzdGVuZXI7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyIGluc3RlYWQuXG4gKiBFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyIGNvbXBhdGliaWxpdHk6IENocm9tZSwgT3BlcmEgNywgU2FmYXJpLCBGRjEuNSssIElFOStcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L3JlbW92ZUV2ZW50TGlzdGVuZXJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLnJlbW92ZUV2ZW50XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzJDEucmVtb3ZlRXZlbnQgPSByZW1vdmVMaXN0ZW5lcjtcblxuLy8gQFRPRE8gTWFrZSBwb3NzaWJsZSB0byBzZWxlY3QgYW5vdGhlciBwbGF0Zm9ybSBhdCBidWlsZCB0aW1lLlxudmFyIGltcGxlbWVudGF0aW9uID0gcGxhdGZvcm1fZG9tJDIuX2VuYWJsZWQgPyBwbGF0Zm9ybV9kb20kMiA6IHBsYXRmb3JtX2Jhc2ljO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQucGxhdGZvcm1cbiAqIEBzZWUgaHR0cHM6Ly9jaGFydGpzLmdpdGJvb2tzLmlvL3Byb3Bvc2Fscy9jb250ZW50L1BsYXRmb3JtLmh0bWxcbiAqIEBzaW5jZSAyLjQuMFxuICovXG52YXIgcGxhdGZvcm0gPSBoZWxwZXJzJDEuZXh0ZW5kKHtcblx0LyoqXG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGNvbnN0cnVjdGlvbiB0aW1lLCByZXR1cm5zIGEgY29udGV4dDJkIGluc3RhbmNlIGltcGxlbWVudGluZ1xuXHQgKiB0aGUgW1czQyBDYW52YXMgMkQgQ29udGV4dCBBUEkgc3RhbmRhcmRde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvfS5cblx0ICogQHBhcmFtIHsqfSBpdGVtIC0gVGhlIG5hdGl2ZSBpdGVtIGZyb20gd2hpY2ggdG8gYWNxdWlyZSBjb250ZXh0IChwbGF0Zm9ybSBzcGVjaWZpYylcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgY2hhcnQgb3B0aW9uc1xuXHQgKiBAcmV0dXJucyB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0MmQgaW5zdGFuY2Vcblx0ICovXG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgZGVzdHJ1Y3Rpb24gdGltZSwgcmVsZWFzZXMgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZXh0XG5cdCAqIHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgdGhlIGFjcXVpcmVDb250ZXh0KCkgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0MmQgaW5zdGFuY2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1ldGhvZCBzdWNjZWVkZWQsIGVsc2UgZmFsc2Vcblx0ICovXG5cdHJlbGVhc2VDb250ZXh0OiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBvbiB0aGUgZ2l2ZW4gY2hhcnQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byBsaXN0ZW4gZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgSUV2ZW50fSkgdHlwZSB0byBsaXN0ZW4gZm9yXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gUmVjZWl2ZXMgYSBub3RpZmljYXRpb24gKGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHNcblx0ICogdGhlIHtAbGluayBJRXZlbnR9IGludGVyZmFjZSkgd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzLlxuXHQgKi9cblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFkZEV2ZW50TGlzdGVuZXIuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgSUV2ZW50fSkgdHlwZSB0byByZW1vdmVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cblx0ICovXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cblxufSwgaW1wbGVtZW50YXRpb24pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0cGx1Z2luczoge31cbn0pO1xuXG4vKipcbiAqIFRoZSBwbHVnaW4gc2VydmljZSBzaW5nbGV0b25cbiAqIEBuYW1lc3BhY2UgQ2hhcnQucGx1Z2luc1xuICogQHNpbmNlIDIuMS4wXG4gKi9cbnZhciBjb3JlX3BsdWdpbnMgPSB7XG5cdC8qKlxuXHQgKiBHbG9iYWxseSByZWdpc3RlcmVkIHBsdWdpbnMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcGx1Z2luczogW10sXG5cblx0LyoqXG5cdCAqIFRoaXMgaWRlbnRpZmllciBpcyB1c2VkIHRvIGludmFsaWRhdGUgdGhlIGRlc2NyaXB0b3JzIGNhY2hlIGF0dGFjaGVkIHRvIGVhY2ggY2hhcnRcblx0ICogd2hlbiBhIGdsb2JhbCBwbHVnaW4gaXMgcmVnaXN0ZXJlZCBvciB1bnJlZ2lzdGVyZWQuIEluIHRoaXMgY2FzZSwgdGhlIGNhY2hlIElEIGlzXG5cdCAqIGluY3JlbWVudGVkIGFuZCBkZXNjcmlwdG9ycyBhcmUgcmVnZW5lcmF0ZWQgZHVyaW5nIGZvbGxvd2luZyBBUEkgY2FsbHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY2FjaGVJZDogMCxcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBwbHVnaW4ocykgaWYgbm90IGFscmVhZHkgcmVnaXN0ZXJlZC5cblx0ICogQHBhcmFtIHtJUGx1Z2luW118SVBsdWdpbn0gcGx1Z2lucyBwbHVnaW4gaW5zdGFuY2UocykuXG5cdCAqL1xuXHRyZWdpc3RlcjogZnVuY3Rpb24ocGx1Z2lucykge1xuXHRcdHZhciBwID0gdGhpcy5fcGx1Z2lucztcblx0XHQoW10pLmNvbmNhdChwbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0aWYgKHAuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuXHRcdFx0XHRwLnB1c2gocGx1Z2luKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuX2NhY2hlSWQrKztcblx0fSxcblxuXHQvKipcblx0ICogVW5yZWdpc3RlcnMgdGhlIGdpdmVuIHBsdWdpbihzKSBvbmx5IGlmIHJlZ2lzdGVyZWQuXG5cdCAqIEBwYXJhbSB7SVBsdWdpbltdfElQbHVnaW59IHBsdWdpbnMgcGx1Z2luIGluc3RhbmNlKHMpLlxuXHQgKi9cblx0dW5yZWdpc3RlcjogZnVuY3Rpb24ocGx1Z2lucykge1xuXHRcdHZhciBwID0gdGhpcy5fcGx1Z2lucztcblx0XHQoW10pLmNvbmNhdChwbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0dmFyIGlkeCA9IHAuaW5kZXhPZihwbHVnaW4pO1xuXHRcdFx0aWYgKGlkeCAhPT0gLTEpIHtcblx0XHRcdFx0cC5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuX2NhY2hlSWQrKztcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCByZWdpc3RlcmVkIHBsdWdpbnMuXG5cdCAqIEBzaW5jZSAyLjEuNVxuXHQgKi9cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3BsdWdpbnMgPSBbXTtcblx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiByZWdpc3RlcmVkIHBsdWdpbnM/XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqIEBzaW5jZSAyLjEuNVxuXHQgKi9cblx0Y291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wbHVnaW5zLmxlbmd0aDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBwbHVnaW4gaW5zdGFuY2VzLlxuXHQgKiBAcmV0dXJucyB7SVBsdWdpbltdfSBhcnJheSBvZiBwbHVnaW4gb2JqZWN0cy5cblx0ICogQHNpbmNlIDIuMS41XG5cdCAqL1xuXHRnZXRBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wbHVnaW5zO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgZm9yIGBjaGFydGAgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UgZm9yIHdoaWNoIHBsdWdpbnMgc2hvdWxkIGJlIGNhbGxlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBhbnkgb2YgdGhlIHBsdWdpbnMgcmV0dXJuIGZhbHNlLCBlbHNlIHJldHVybnMgdHJ1ZS5cblx0ICovXG5cdG5vdGlmeTogZnVuY3Rpb24oY2hhcnQsIGhvb2ssIGFyZ3MpIHtcblx0XHR2YXIgZGVzY3JpcHRvcnMgPSB0aGlzLmRlc2NyaXB0b3JzKGNoYXJ0KTtcblx0XHR2YXIgaWxlbiA9IGRlc2NyaXB0b3JzLmxlbmd0aDtcblx0XHR2YXIgaSwgZGVzY3JpcHRvciwgcGx1Z2luLCBwYXJhbXMsIG1ldGhvZDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yc1tpXTtcblx0XHRcdHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuXHRcdFx0bWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuXHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cGFyYW1zID0gW2NoYXJ0XS5jb25jYXQoYXJncyB8fCBbXSk7XG5cdFx0XHRcdHBhcmFtcy5wdXNoKGRlc2NyaXB0b3Iub3B0aW9ucyk7XG5cdFx0XHRcdGlmIChtZXRob2QuYXBwbHkocGx1Z2luLCBwYXJhbXMpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGRlc2NyaXB0b3JzIG9mIGVuYWJsZWQgcGx1Z2lucyBmb3IgdGhlIGdpdmVuIGNoYXJ0LlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0W119IFt7IHBsdWdpbiwgb3B0aW9ucyB9XVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZGVzY3JpcHRvcnM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIGNhY2hlID0gY2hhcnQuJHBsdWdpbnMgfHwgKGNoYXJ0LiRwbHVnaW5zID0ge30pO1xuXHRcdGlmIChjYWNoZS5pZCA9PT0gdGhpcy5fY2FjaGVJZCkge1xuXHRcdFx0cmV0dXJuIGNhY2hlLmRlc2NyaXB0b3JzO1xuXHRcdH1cblxuXHRcdHZhciBwbHVnaW5zID0gW107XG5cdFx0dmFyIGRlc2NyaXB0b3JzID0gW107XG5cdFx0dmFyIGNvbmZpZyA9IChjaGFydCAmJiBjaGFydC5jb25maWcpIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gKGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMpIHx8IHt9O1xuXG5cdFx0dGhpcy5fcGx1Z2lucy5jb25jYXQoY29uZmlnLnBsdWdpbnMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHR2YXIgaWR4ID0gcGx1Z2lucy5pbmRleE9mKHBsdWdpbik7XG5cdFx0XHRpZiAoaWR4ICE9PSAtMSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpZCA9IHBsdWdpbi5pZDtcblx0XHRcdHZhciBvcHRzID0gb3B0aW9uc1tpZF07XG5cdFx0XHRpZiAob3B0cyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0cyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRvcHRzID0gaGVscGVycyQxLmNsb25lKGNvcmVfZGVmYXVsdHMuZ2xvYmFsLnBsdWdpbnNbaWRdKTtcblx0XHRcdH1cblxuXHRcdFx0cGx1Z2lucy5wdXNoKHBsdWdpbik7XG5cdFx0XHRkZXNjcmlwdG9ycy5wdXNoKHtcblx0XHRcdFx0cGx1Z2luOiBwbHVnaW4sXG5cdFx0XHRcdG9wdGlvbnM6IG9wdHMgfHwge31cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Y2FjaGUuZGVzY3JpcHRvcnMgPSBkZXNjcmlwdG9ycztcblx0XHRjYWNoZS5pZCA9IHRoaXMuX2NhY2hlSWQ7XG5cdFx0cmV0dXJuIGRlc2NyaXB0b3JzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbnZhbGlkYXRlcyBjYWNoZSBmb3IgdGhlIGdpdmVuIGNoYXJ0OiBkZXNjcmlwdG9ycyBob2xkIGEgcmVmZXJlbmNlIG9uIHBsdWdpbiBvcHRpb24sXG5cdCAqIGJ1dCBpbiBzb21lIGNhc2VzLCB0aGlzIHJlZmVyZW5jZSBjYW4gYmUgY2hhbmdlZCBieSB0aGUgdXNlciB3aGVuIHVwZGF0aW5nIG9wdGlvbnMuXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9pbnZhbGlkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdGRlbGV0ZSBjaGFydC4kcGx1Z2lucztcblx0fVxufTtcblxudmFyIGNvcmVfc2NhbGVTZXJ2aWNlID0ge1xuXHQvLyBTY2FsZSByZWdpc3RyYXRpb24gb2JqZWN0LiBFeHRlbnNpb25zIGNhbiByZWdpc3RlciBuZXcgc2NhbGUgdHlwZXMgKHN1Y2ggYXMgbG9nIG9yIERCIHNjYWxlcykgYW5kIHRoZW5cblx0Ly8gdXNlIHRoZSBuZXcgY2hhcnQgb3B0aW9ucyB0byBncmFiIHRoZSBjb3JyZWN0IHNjYWxlXG5cdGNvbnN0cnVjdG9yczoge30sXG5cdC8vIFVzZSBhIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBzbyB0aGF0IHdlIGNhbiBtb3ZlIHRvIGFuIEVTNiBtYXAgd2hlbiB3ZSBubyBsb25nZXIgbmVlZCB0byBzdXBwb3J0XG5cdC8vIG9sZCBicm93c2Vyc1xuXG5cdC8vIFNjYWxlIGNvbmZpZyBkZWZhdWx0c1xuXHRkZWZhdWx0czoge30sXG5cdHJlZ2lzdGVyU2NhbGVUeXBlOiBmdW5jdGlvbih0eXBlLCBzY2FsZUNvbnN0cnVjdG9yLCBzY2FsZURlZmF1bHRzKSB7XG5cdFx0dGhpcy5jb25zdHJ1Y3RvcnNbdHlwZV0gPSBzY2FsZUNvbnN0cnVjdG9yO1xuXHRcdHRoaXMuZGVmYXVsdHNbdHlwZV0gPSBoZWxwZXJzJDEuY2xvbmUoc2NhbGVEZWZhdWx0cyk7XG5cdH0sXG5cdGdldFNjYWxlQ29uc3RydWN0b3I6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcnMuaGFzT3duUHJvcGVydHkodHlwZSkgPyB0aGlzLmNvbnN0cnVjdG9yc1t0eXBlXSA6IHVuZGVmaW5lZDtcblx0fSxcblx0Z2V0U2NhbGVEZWZhdWx0czogZnVuY3Rpb24odHlwZSkge1xuXHRcdC8vIFJldHVybiB0aGUgc2NhbGUgZGVmYXVsdHMgbWVyZ2VkIHdpdGggdGhlIGdsb2JhbCBzZXR0aW5ncyBzbyB0aGF0IHdlIGFsd2F5cyB1c2UgdGhlIGxhdGVzdCBvbmVzXG5cdFx0cmV0dXJuIHRoaXMuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkodHlwZSkgPyBoZWxwZXJzJDEubWVyZ2Uoe30sIFtjb3JlX2RlZmF1bHRzLnNjYWxlLCB0aGlzLmRlZmF1bHRzW3R5cGVdXSkgOiB7fTtcblx0fSxcblx0dXBkYXRlU2NhbGVEZWZhdWx0czogZnVuY3Rpb24odHlwZSwgYWRkaXRpb25zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAobWUuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcblx0XHRcdG1lLmRlZmF1bHRzW3R5cGVdID0gaGVscGVycyQxLmV4dGVuZChtZS5kZWZhdWx0c1t0eXBlXSwgYWRkaXRpb25zKTtcblx0XHR9XG5cdH0sXG5cdGFkZFNjYWxlc1RvTGF5b3V0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdC8vIEFkZHMgZWFjaCBzY2FsZSB0byB0aGUgY2hhcnQuYm94ZXMgYXJyYXkgdG8gYmUgc2l6ZWQgYWNjb3JkaW5nbHlcblx0XHRoZWxwZXJzJDEuZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG5cdFx0XHQvLyBTZXQgSUxheW91dEl0ZW0gcGFyYW1ldGVycyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdHNjYWxlLmZ1bGxXaWR0aCA9IHNjYWxlLm9wdGlvbnMuZnVsbFdpZHRoO1xuXHRcdFx0c2NhbGUucG9zaXRpb24gPSBzY2FsZS5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdFx0c2NhbGUud2VpZ2h0ID0gc2NhbGUub3B0aW9ucy53ZWlnaHQ7XG5cdFx0XHRjb3JlX2xheW91dHMuYWRkQm94KGNoYXJ0LCBzY2FsZSk7XG5cdFx0fSk7XG5cdH1cbn07XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ3ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0dG9vbHRpcHM6IHtcblx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdGN1c3RvbTogbnVsbCxcblx0XHRtb2RlOiAnbmVhcmVzdCcsXG5cdFx0cG9zaXRpb246ICdhdmVyYWdlJyxcblx0XHRpbnRlcnNlY3Q6IHRydWUsXG5cdFx0YmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcblx0XHR0aXRsZUZvbnRTdHlsZTogJ2JvbGQnLFxuXHRcdHRpdGxlU3BhY2luZzogMixcblx0XHR0aXRsZU1hcmdpbkJvdHRvbTogNixcblx0XHR0aXRsZUZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdHRpdGxlQWxpZ246ICdsZWZ0Jyxcblx0XHRib2R5U3BhY2luZzogMixcblx0XHRib2R5Rm9udENvbG9yOiAnI2ZmZicsXG5cdFx0Ym9keUFsaWduOiAnbGVmdCcsXG5cdFx0Zm9vdGVyRm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0Zm9vdGVyU3BhY2luZzogMixcblx0XHRmb290ZXJNYXJnaW5Ub3A6IDYsXG5cdFx0Zm9vdGVyRm9udENvbG9yOiAnI2ZmZicsXG5cdFx0Zm9vdGVyQWxpZ246ICdsZWZ0Jyxcblx0XHR5UGFkZGluZzogNixcblx0XHR4UGFkZGluZzogNixcblx0XHRjYXJldFBhZGRpbmc6IDIsXG5cdFx0Y2FyZXRTaXplOiA1LFxuXHRcdGNvcm5lclJhZGl1czogNixcblx0XHRtdWx0aUtleUJhY2tncm91bmQ6ICcjZmZmJyxcblx0XHRkaXNwbGF5Q29sb3JzOiB0cnVlLFxuXHRcdGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG5cdFx0Ym9yZGVyV2lkdGg6IDAsXG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGJlZm9yZVRpdGxlOiBoZWxwZXJzJDEubm9vcCxcblx0XHRcdHRpdGxlOiBmdW5jdGlvbih0b29sdGlwSXRlbXMsIGRhdGEpIHtcblx0XHRcdFx0dmFyIHRpdGxlID0gJyc7XG5cdFx0XHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcblx0XHRcdFx0dmFyIGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcblxuXHRcdFx0XHRpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcblx0XHRcdFx0XHRpZiAoaXRlbS5sYWJlbCkge1xuXHRcdFx0XHRcdFx0dGl0bGUgPSBpdGVtLmxhYmVsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaXRlbS54TGFiZWwpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS54TGFiZWw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmluZGV4IDwgbGFiZWxDb3VudCkge1xuXHRcdFx0XHRcdFx0dGl0bGUgPSBsYWJlbHNbaXRlbS5pbmRleF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRpdGxlO1xuXHRcdFx0fSxcblx0XHRcdGFmdGVyVGl0bGU6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGJlZm9yZUJvZHk6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRcdFx0YmVmb3JlTGFiZWw6IGhlbHBlcnMkMS5ub29wLFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBsYWJlbCA9IGRhdGEuZGF0YXNldHNbdG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcblxuXHRcdFx0XHRpZiAobGFiZWwpIHtcblx0XHRcdFx0XHRsYWJlbCArPSAnOiAnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodG9vbHRpcEl0ZW0udmFsdWUpKSB7XG5cdFx0XHRcdFx0bGFiZWwgKz0gdG9vbHRpcEl0ZW0udmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGFiZWwgKz0gdG9vbHRpcEl0ZW0ueUxhYmVsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBsYWJlbDtcblx0XHRcdH0sXG5cdFx0XHRsYWJlbENvbG9yOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgY2hhcnQpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIgYWN0aXZlRWxlbWVudCA9IG1ldGEuZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XG5cdFx0XHRcdHZhciB2aWV3ID0gYWN0aXZlRWxlbWVudC5fdmlldztcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogdmlldy5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHZpZXcuYmFja2dyb3VuZENvbG9yXG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWxUZXh0Q29sb3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fb3B0aW9ucy5ib2R5Rm9udENvbG9yO1xuXHRcdFx0fSxcblx0XHRcdGFmdGVyTGFiZWw6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGFmdGVyQm9keTogaGVscGVycyQxLm5vb3AsXG5cblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuXHRcdFx0YmVmb3JlRm9vdGVyOiBoZWxwZXJzJDEubm9vcCxcblx0XHRcdGZvb3RlcjogaGVscGVycyQxLm5vb3AsXG5cdFx0XHRhZnRlckZvb3RlcjogaGVscGVycyQxLm5vb3Bcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgcG9zaXRpb25lcnMgPSB7XG5cdC8qKlxuXHQgKiBBdmVyYWdlIG1vZGUgcGxhY2VzIHRoZSB0b29sdGlwIGF0IHRoZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50cyBzaG93blxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVycy5hdmVyYWdlXG5cdCAqIEBwYXJhbSBlbGVtZW50cyB7Q2hhcnRFbGVtZW50W119IHRoZSBlbGVtZW50cyBiZWluZyBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXBcblx0ICogQHJldHVybnMge29iamVjdH0gdG9vbHRpcCBwb3NpdGlvblxuXHQgKi9cblx0YXZlcmFnZTogZnVuY3Rpb24oZWxlbWVudHMpIHtcblx0XHRpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBpLCBsZW47XG5cdFx0dmFyIHggPSAwO1xuXHRcdHZhciB5ID0gMDtcblx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdHZhciBlbCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcblx0XHRcdFx0dmFyIHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuXHRcdFx0XHR4ICs9IHBvcy54O1xuXHRcdFx0XHR5ICs9IHBvcy55O1xuXHRcdFx0XHQrK2NvdW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4IC8gY291bnQsXG5cdFx0XHR5OiB5IC8gY291bnRcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0b29sdGlwIHBvc2l0aW9uIG5lYXJlc3Qgb2YgdGhlIGl0ZW0gbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb25cblx0ICogQGZ1bmN0aW9uIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMubmVhcmVzdFxuXHQgKiBAcGFyYW0gZWxlbWVudHMge0NoYXJ0LkVsZW1lbnRbXX0gdGhlIHRvb2x0aXAgZWxlbWVudHNcblx0ICogQHBhcmFtIGV2ZW50UG9zaXRpb24ge29iamVjdH0gdGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCBpbiBjYW52YXMgY29vcmRpbmF0ZXNcblx0ICogQHJldHVybnMge29iamVjdH0gdGhlIHRvb2x0aXAgcG9zaXRpb25cblx0ICovXG5cdG5lYXJlc3Q6IGZ1bmN0aW9uKGVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG5cdFx0dmFyIHggPSBldmVudFBvc2l0aW9uLng7XG5cdFx0dmFyIHkgPSBldmVudFBvc2l0aW9uLnk7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdHZhciBpLCBsZW4sIG5lYXJlc3RFbGVtZW50O1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdHZhciBlbCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcblx0XHRcdFx0dmFyIGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG5cdFx0XHRcdHZhciBkID0gaGVscGVycyQxLmRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuXG5cdFx0XHRcdGlmIChkIDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IGQ7XG5cdFx0XHRcdFx0bmVhcmVzdEVsZW1lbnQgPSBlbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChuZWFyZXN0RWxlbWVudCkge1xuXHRcdFx0dmFyIHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG5cdFx0XHR4ID0gdHAueDtcblx0XHRcdHkgPSB0cC55O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeVxuXHRcdH07XG5cdH1cbn07XG5cbi8vIEhlbHBlciB0byBwdXNoIG9yIGNvbmNhdCBiYXNlZCBvbiBpZiB0aGUgMm5kIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvciBub3RcbmZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcblx0aWYgKHRvUHVzaCkge1xuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0b1B1c2gpKSB7XG5cdFx0XHQvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJhc2UucHVzaCh0b1B1c2gpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBiYXNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2Ygc3RyaW5ncyBzcGxpdCBieSBuZXdsaW5lXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3BsaXQgYnkgbmV3bGluZS5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gdmFsdWUgaWYgbmV3bGluZSBwcmVzZW50IC0gUmV0dXJuZWQgZnJvbSBTdHJpbmcgc3BsaXQoKSBtZXRob2RcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuXHRpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcblx0XHRyZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcblx0fVxuXHRyZXR1cm4gc3RyO1xufVxuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdG8gY3JlYXRlIGEgdG9vbHRpcCBpdGVtIG1vZGVsXG4gKiBAcGFyYW0gZWxlbWVudCAtIHRoZSBjaGFydCBlbGVtZW50IChwb2ludCwgYXJjLCBiYXIpIHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBpdGVtIGZvclxuICogQHJldHVybiBuZXcgdG9vbHRpcCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGVsZW1lbnQpIHtcblx0dmFyIHhTY2FsZSA9IGVsZW1lbnQuX3hTY2FsZTtcblx0dmFyIHlTY2FsZSA9IGVsZW1lbnQuX3lTY2FsZSB8fCBlbGVtZW50Ll9zY2FsZTsgLy8gaGFuZGxlIHJhZGFyIHx8IHBvbGFyQXJlYSBjaGFydHNcblx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XG5cdHZhciBkYXRhc2V0SW5kZXggPSBlbGVtZW50Ll9kYXRhc2V0SW5kZXg7XG5cdHZhciBjb250cm9sbGVyID0gZWxlbWVudC5fY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuXHR2YXIgaW5kZXhTY2FsZSA9IGNvbnRyb2xsZXIuX2dldEluZGV4U2NhbGUoKTtcblx0dmFyIHZhbHVlU2NhbGUgPSBjb250cm9sbGVyLl9nZXRWYWx1ZVNjYWxlKCk7XG5cblx0cmV0dXJuIHtcblx0XHR4TGFiZWw6IHhTY2FsZSA/IHhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0eUxhYmVsOiB5U2NhbGUgPyB5U2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdGxhYmVsOiBpbmRleFNjYWxlID8gJycgKyBpbmRleFNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcblx0XHR2YWx1ZTogdmFsdWVTY2FsZSA/ICcnICsgdmFsdWVTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0aW5kZXg6IGluZGV4LFxuXHRcdGRhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LFxuXHRcdHg6IGVsZW1lbnQuX21vZGVsLngsXG5cdFx0eTogZWxlbWVudC5fbW9kZWwueVxuXHR9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIHJlc2V0IG1vZGVsIGZvciB0aGUgdG9vbHRpcFxuICogQHBhcmFtIHRvb2x0aXBPcHRzIHtvYmplY3R9IHRoZSB0b29sdGlwIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0QmFzZU1vZGVsKHRvb2x0aXBPcHRzKSB7XG5cdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXG5cdHJldHVybiB7XG5cdFx0Ly8gUG9zaXRpb25pbmdcblx0XHR4UGFkZGluZzogdG9vbHRpcE9wdHMueFBhZGRpbmcsXG5cdFx0eVBhZGRpbmc6IHRvb2x0aXBPcHRzLnlQYWRkaW5nLFxuXHRcdHhBbGlnbjogdG9vbHRpcE9wdHMueEFsaWduLFxuXHRcdHlBbGlnbjogdG9vbHRpcE9wdHMueUFsaWduLFxuXG5cdFx0Ly8gQm9keVxuXHRcdGJvZHlGb250Q29sb3I6IHRvb2x0aXBPcHRzLmJvZHlGb250Q29sb3IsXG5cdFx0X2JvZHlGb250RmFtaWx5OiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLmJvZHlGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0X2JvZHlGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuYm9keUZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXG5cdFx0X2JvZHlBbGlnbjogdG9vbHRpcE9wdHMuYm9keUFsaWduLFxuXHRcdGJvZHlGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5ib2R5Rm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0Ym9keVNwYWNpbmc6IHRvb2x0aXBPcHRzLmJvZHlTcGFjaW5nLFxuXG5cdFx0Ly8gVGl0bGVcblx0XHR0aXRsZUZvbnRDb2xvcjogdG9vbHRpcE9wdHMudGl0bGVGb250Q29sb3IsXG5cdFx0X3RpdGxlRm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy50aXRsZUZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRfdGl0bGVGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMudGl0bGVGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdHRpdGxlRm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMudGl0bGVGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRfdGl0bGVBbGlnbjogdG9vbHRpcE9wdHMudGl0bGVBbGlnbixcblx0XHR0aXRsZVNwYWNpbmc6IHRvb2x0aXBPcHRzLnRpdGxlU3BhY2luZyxcblx0XHR0aXRsZU1hcmdpbkJvdHRvbTogdG9vbHRpcE9wdHMudGl0bGVNYXJnaW5Cb3R0b20sXG5cblx0XHQvLyBGb290ZXJcblx0XHRmb290ZXJGb250Q29sb3I6IHRvb2x0aXBPcHRzLmZvb3RlckZvbnRDb2xvcixcblx0XHRfZm9vdGVyRm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5mb290ZXJGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0X2Zvb3RlckZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5mb290ZXJGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdGZvb3RlckZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLmZvb3RlckZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpLFxuXHRcdF9mb290ZXJBbGlnbjogdG9vbHRpcE9wdHMuZm9vdGVyQWxpZ24sXG5cdFx0Zm9vdGVyU3BhY2luZzogdG9vbHRpcE9wdHMuZm9vdGVyU3BhY2luZyxcblx0XHRmb290ZXJNYXJnaW5Ub3A6IHRvb2x0aXBPcHRzLmZvb3Rlck1hcmdpblRvcCxcblxuXHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRjYXJldFNpemU6IHRvb2x0aXBPcHRzLmNhcmV0U2l6ZSxcblx0XHRjb3JuZXJSYWRpdXM6IHRvb2x0aXBPcHRzLmNvcm5lclJhZGl1cyxcblx0XHRiYWNrZ3JvdW5kQ29sb3I6IHRvb2x0aXBPcHRzLmJhY2tncm91bmRDb2xvcixcblx0XHRvcGFjaXR5OiAwLFxuXHRcdGxlZ2VuZENvbG9yQmFja2dyb3VuZDogdG9vbHRpcE9wdHMubXVsdGlLZXlCYWNrZ3JvdW5kLFxuXHRcdGRpc3BsYXlDb2xvcnM6IHRvb2x0aXBPcHRzLmRpc3BsYXlDb2xvcnMsXG5cdFx0Ym9yZGVyQ29sb3I6IHRvb2x0aXBPcHRzLmJvcmRlckNvbG9yLFxuXHRcdGJvcmRlcldpZHRoOiB0b29sdGlwT3B0cy5ib3JkZXJXaWR0aFxuXHR9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdG9vbHRpcFxuICovXG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBtb2RlbCkge1xuXHR2YXIgY3R4ID0gdG9vbHRpcC5fY2hhcnQuY3R4O1xuXG5cdHZhciBoZWlnaHQgPSBtb2RlbC55UGFkZGluZyAqIDI7IC8vIFRvb2x0aXAgUGFkZGluZ1xuXHR2YXIgd2lkdGggPSAwO1xuXG5cdC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxuXHR2YXIgYm9keSA9IG1vZGVsLmJvZHk7XG5cdHZhciBjb21iaW5lZEJvZHlMZW5ndGggPSBib2R5LnJlZHVjZShmdW5jdGlvbihjb3VudCwgYm9keUl0ZW0pIHtcblx0XHRyZXR1cm4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoO1xuXHR9LCAwKTtcblx0Y29tYmluZWRCb2R5TGVuZ3RoICs9IG1vZGVsLmJlZm9yZUJvZHkubGVuZ3RoICsgbW9kZWwuYWZ0ZXJCb2R5Lmxlbmd0aDtcblxuXHR2YXIgdGl0bGVMaW5lQ291bnQgPSBtb2RlbC50aXRsZS5sZW5ndGg7XG5cdHZhciBmb290ZXJMaW5lQ291bnQgPSBtb2RlbC5mb290ZXIubGVuZ3RoO1xuXHR2YXIgdGl0bGVGb250U2l6ZSA9IG1vZGVsLnRpdGxlRm9udFNpemU7XG5cdHZhciBib2R5Rm9udFNpemUgPSBtb2RlbC5ib2R5Rm9udFNpemU7XG5cdHZhciBmb290ZXJGb250U2l6ZSA9IG1vZGVsLmZvb3RlckZvbnRTaXplO1xuXG5cdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udFNpemU7IC8vIFRpdGxlIExpbmVzXG5cdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCA/ICh0aXRsZUxpbmVDb3VudCAtIDEpICogbW9kZWwudGl0bGVTcGFjaW5nIDogMDsgLy8gVGl0bGUgTGluZSBTcGFjaW5nXG5cdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCA/IG1vZGVsLnRpdGxlTWFyZ2luQm90dG9tIDogMDsgLy8gVGl0bGUncyBib3R0b20gTWFyZ2luXG5cdGhlaWdodCArPSBjb21iaW5lZEJvZHlMZW5ndGggKiBib2R5Rm9udFNpemU7IC8vIEJvZHkgTGluZXNcblx0aGVpZ2h0ICs9IGNvbWJpbmVkQm9keUxlbmd0aCA/IChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG1vZGVsLmJvZHlTcGFjaW5nIDogMDsgLy8gQm9keSBMaW5lIFNwYWNpbmdcblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IG1vZGVsLmZvb3Rlck1hcmdpblRvcCA6IDA7IC8vIEZvb3RlciBNYXJnaW5cblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCAqIChmb290ZXJGb250U2l6ZSk7IC8vIEZvb3RlciBMaW5lc1xuXHRoZWlnaHQgKz0gZm9vdGVyTGluZUNvdW50ID8gKGZvb3RlckxpbmVDb3VudCAtIDEpICogbW9kZWwuZm9vdGVyU3BhY2luZyA6IDA7IC8vIEZvb3RlciBMaW5lIFNwYWNpbmdcblxuXHQvLyBUaXRsZSB3aWR0aFxuXHR2YXIgd2lkdGhQYWRkaW5nID0gMDtcblx0dmFyIG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuXHR9O1xuXG5cdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcodGl0bGVGb250U2l6ZSwgbW9kZWwuX3RpdGxlRm9udFN0eWxlLCBtb2RlbC5fdGl0bGVGb250RmFtaWx5KTtcblx0aGVscGVycyQxLmVhY2gobW9kZWwudGl0bGUsIG1heExpbmVXaWR0aCk7XG5cblx0Ly8gQm9keSB3aWR0aFxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGJvZHlGb250U2l6ZSwgbW9kZWwuX2JvZHlGb250U3R5bGUsIG1vZGVsLl9ib2R5Rm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLmJlZm9yZUJvZHkuY29uY2F0KG1vZGVsLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG5cblx0Ly8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIHdpZHRoIGR1ZSB0byB0aGUgY29sb3IgYm94XG5cdHdpZHRoUGFkZGluZyA9IG1vZGVsLmRpc3BsYXlDb2xvcnMgPyAoYm9keUZvbnRTaXplICsgMikgOiAwO1xuXHRoZWxwZXJzJDEuZWFjaChib2R5LCBmdW5jdGlvbihib2R5SXRlbSkge1xuXHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcblx0fSk7XG5cblx0Ly8gUmVzZXQgYmFjayB0byAwXG5cdHdpZHRoUGFkZGluZyA9IDA7XG5cblx0Ly8gRm9vdGVyIHdpZHRoXG5cdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcoZm9vdGVyRm9udFNpemUsIG1vZGVsLl9mb290ZXJGb250U3R5bGUsIG1vZGVsLl9mb290ZXJGb250RmFtaWx5KTtcblx0aGVscGVycyQxLmVhY2gobW9kZWwuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEFkZCBwYWRkaW5nXG5cdHdpZHRoICs9IDIgKiBtb2RlbC54UGFkZGluZztcblxuXHRyZXR1cm4ge1xuXHRcdHdpZHRoOiB3aWR0aCxcblx0XHRoZWlnaHQ6IGhlaWdodFxuXHR9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGFsaWdubWVudCBvZiBhIHRvb2x0aXAgZ2l2ZW4gdGhlIHNpemVcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KHRvb2x0aXAsIHNpemUpIHtcblx0dmFyIG1vZGVsID0gdG9vbHRpcC5fbW9kZWw7XG5cdHZhciBjaGFydCA9IHRvb2x0aXAuX2NoYXJ0O1xuXHR2YXIgY2hhcnRBcmVhID0gdG9vbHRpcC5fY2hhcnQuY2hhcnRBcmVhO1xuXHR2YXIgeEFsaWduID0gJ2NlbnRlcic7XG5cdHZhciB5QWxpZ24gPSAnY2VudGVyJztcblxuXHRpZiAobW9kZWwueSA8IHNpemUuaGVpZ2h0KSB7XG5cdFx0eUFsaWduID0gJ3RvcCc7XG5cdH0gZWxzZSBpZiAobW9kZWwueSA+IChjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodCkpIHtcblx0XHR5QWxpZ24gPSAnYm90dG9tJztcblx0fVxuXG5cdHZhciBsZiwgcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgbGVmdCwgcmlnaHQgYWxpZ25tZW50XG5cdHZhciBvbGYsIG9yZjsgLy8gZnVuY3Rpb25zIHRvIGRldGVybWluZSBpZiBsZWZ0L3JpZ2h0IGFsaWdubWVudCBjYXVzZXMgdG9vbHRpcCB0byBnbyBvdXRzaWRlIGNoYXJ0XG5cdHZhciB5ZjsgLy8gZnVuY3Rpb24gdG8gZ2V0IHRoZSB5IGFsaWdubWVudCBpZiB0aGUgdG9vbHRpcCBnb2VzIG91dHNpZGUgb2YgdGhlIGxlZnQgb3IgcmlnaHQgZWRnZXNcblx0dmFyIG1pZFggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcblx0dmFyIG1pZFkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcblxuXHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuXHRcdGxmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPD0gbWlkWDtcblx0XHR9O1xuXHRcdHJmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPiBtaWRYO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0bGYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4geCA8PSAoc2l6ZS53aWR0aCAvIDIpO1xuXHRcdH07XG5cdFx0cmYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4geCA+PSAoY2hhcnQud2lkdGggLSAoc2l6ZS53aWR0aCAvIDIpKTtcblx0XHR9O1xuXHR9XG5cblx0b2xmID0gZnVuY3Rpb24oeCkge1xuXHRcdHJldHVybiB4ICsgc2l6ZS53aWR0aCArIG1vZGVsLmNhcmV0U2l6ZSArIG1vZGVsLmNhcmV0UGFkZGluZyA+IGNoYXJ0LndpZHRoO1xuXHR9O1xuXHRvcmYgPSBmdW5jdGlvbih4KSB7XG5cdFx0cmV0dXJuIHggLSBzaXplLndpZHRoIC0gbW9kZWwuY2FyZXRTaXplIC0gbW9kZWwuY2FyZXRQYWRkaW5nIDwgMDtcblx0fTtcblx0eWYgPSBmdW5jdGlvbih5KSB7XG5cdFx0cmV0dXJuIHkgPD0gbWlkWSA/ICd0b3AnIDogJ2JvdHRvbSc7XG5cdH07XG5cblx0aWYgKGxmKG1vZGVsLngpKSB7XG5cdFx0eEFsaWduID0gJ2xlZnQnO1xuXG5cdFx0Ly8gSXMgdG9vbHRpcCB0b28gd2lkZSBhbmQgZ29lcyBvdmVyIHRoZSByaWdodCBzaWRlIG9mIHRoZSBjaGFydC4/XG5cdFx0aWYgKG9sZihtb2RlbC54KSkge1xuXHRcdFx0eEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHR5QWxpZ24gPSB5Zihtb2RlbC55KTtcblx0XHR9XG5cdH0gZWxzZSBpZiAocmYobW9kZWwueCkpIHtcblx0XHR4QWxpZ24gPSAncmlnaHQnO1xuXG5cdFx0Ly8gSXMgdG9vbHRpcCB0b28gd2lkZSBhbmQgZ29lcyBvdXRzaWRlIGxlZnQgZWRnZSBvZiBjYW52YXM/XG5cdFx0aWYgKG9yZihtb2RlbC54KSkge1xuXHRcdFx0eEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHR5QWxpZ24gPSB5Zihtb2RlbC55KTtcblx0XHR9XG5cdH1cblxuXHR2YXIgb3B0cyA9IHRvb2x0aXAuX29wdGlvbnM7XG5cdHJldHVybiB7XG5cdFx0eEFsaWduOiBvcHRzLnhBbGlnbiA/IG9wdHMueEFsaWduIDogeEFsaWduLFxuXHRcdHlBbGlnbjogb3B0cy55QWxpZ24gPyBvcHRzLnlBbGlnbiA6IHlBbGlnblxuXHR9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGxvY2F0aW9uIGEgdG9vbHRpcCBuZWVkcyB0byBiZSBwbGFjZWQgYXQgZ2l2ZW4gdGhlIGluaXRpYWwgcG9zaXRpb24gKHZpYSB0aGUgdm0pIGFuZCB0aGUgc2l6ZSBhbmQgYWxpZ25tZW50XG4gKi9cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludCh2bSwgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuXHQvLyBCYWNrZ3JvdW5kIFBvc2l0aW9uXG5cdHZhciB4ID0gdm0ueDtcblx0dmFyIHkgPSB2bS55O1xuXG5cdHZhciBjYXJldFNpemUgPSB2bS5jYXJldFNpemU7XG5cdHZhciBjYXJldFBhZGRpbmcgPSB2bS5jYXJldFBhZGRpbmc7XG5cdHZhciBjb3JuZXJSYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XG5cdHZhciB4QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuXHR2YXIgeUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcblx0dmFyIHBhZGRpbmdBbmRTaXplID0gY2FyZXRTaXplICsgY2FyZXRQYWRkaW5nO1xuXHR2YXIgcmFkaXVzQW5kUGFkZGluZyA9IGNvcm5lclJhZGl1cyArIGNhcmV0UGFkZGluZztcblxuXHRpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0eCAtPSBzaXplLndpZHRoO1xuXHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHR4IC09IChzaXplLndpZHRoIC8gMik7XG5cdFx0aWYgKHggKyBzaXplLndpZHRoID4gY2hhcnQud2lkdGgpIHtcblx0XHRcdHggPSBjaGFydC53aWR0aCAtIHNpemUud2lkdGg7XG5cdFx0fVxuXHRcdGlmICh4IDwgMCkge1xuXHRcdFx0eCA9IDA7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHR5ICs9IHBhZGRpbmdBbmRTaXplO1xuXHR9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcblx0XHR5IC09IHNpemUuaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG5cdH0gZWxzZSB7XG5cdFx0eSAtPSAoc2l6ZS5oZWlnaHQgLyAyKTtcblx0fVxuXG5cdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHR4ICs9IHBhZGRpbmdBbmRTaXplO1xuXHRcdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHR4IC09IHBhZGRpbmdBbmRTaXplO1xuXHRcdH1cblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdHggLT0gcmFkaXVzQW5kUGFkZGluZztcblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHR4ICs9IHJhZGl1c0FuZFBhZGRpbmc7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHg6IHgsXG5cdFx0eTogeVxuXHR9O1xufVxuXG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh2bSwgYWxpZ24pIHtcblx0cmV0dXJuIGFsaWduID09PSAnY2VudGVyJ1xuXHRcdD8gdm0ueCArIHZtLndpZHRoIC8gMlxuXHRcdDogYWxpZ24gPT09ICdyaWdodCdcblx0XHRcdD8gdm0ueCArIHZtLndpZHRoIC0gdm0ueFBhZGRpbmdcblx0XHRcdDogdm0ueCArIHZtLnhQYWRkaW5nO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBidWlsZCBiZWZvcmUgYW5kIGFmdGVyIGJvZHkgbGluZXNcbiAqL1xuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcblx0cmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuXG52YXIgZXhwb3J0cyQzID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX21vZGVsID0gZ2V0QmFzZU1vZGVsKHRoaXMuX29wdGlvbnMpO1xuXHRcdHRoaXMuX2xhc3RBY3RpdmUgPSBbXTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIHRpdGxlXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdGdldFRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUuX29wdGlvbnM7XG5cdFx0dmFyIGNhbGxiYWNrcyA9IG9wdHMuY2FsbGJhY2tzO1xuXG5cdFx0dmFyIGJlZm9yZVRpdGxlID0gY2FsbGJhY2tzLmJlZm9yZVRpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdHZhciB0aXRsZSA9IGNhbGxiYWNrcy50aXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgYWZ0ZXJUaXRsZSA9IGNhbGxiYWNrcy5hZnRlclRpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0dmFyIGxpbmVzID0gW107XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlVGl0bGUpKTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyh0aXRsZSkpO1xuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyVGl0bGUpKTtcblxuXHRcdHJldHVybiBsaW5lcztcblx0fSxcblxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRCZWZvcmVCb2R5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXModGhpcy5fb3B0aW9ucy5jYWxsYmFja3MuYmVmb3JlQm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0fSxcblxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRCb2R5OiBmdW5jdGlvbih0b29sdGlwSXRlbXMsIGRhdGEpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjYWxsYmFja3MgPSBtZS5fb3B0aW9ucy5jYWxsYmFja3M7XG5cdFx0dmFyIGJvZHlJdGVtcyA9IFtdO1xuXG5cdFx0aGVscGVycyQxLmVhY2godG9vbHRpcEl0ZW1zLCBmdW5jdGlvbih0b29sdGlwSXRlbSkge1xuXHRcdFx0dmFyIGJvZHlJdGVtID0ge1xuXHRcdFx0XHRiZWZvcmU6IFtdLFxuXHRcdFx0XHRsaW5lczogW10sXG5cdFx0XHRcdGFmdGVyOiBbXVxuXHRcdFx0fTtcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIHNwbGl0TmV3bGluZXMoY2FsbGJhY2tzLmJlZm9yZUxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSkpO1xuXHRcdFx0cHVzaE9yQ29uY2F0KGJvZHlJdGVtLmxpbmVzLCBjYWxsYmFja3MubGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKTtcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhjYWxsYmFja3MuYWZ0ZXJMYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpKTtcblxuXHRcdFx0Ym9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGJvZHlJdGVtcztcblx0fSxcblxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRBZnRlckJvZHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyh0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5hZnRlckJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBmb290ZXIgYW5kIGJlZm9yZUZvb3RlciBhbmQgYWZ0ZXJGb290ZXIgbGluZXNcblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0Rm9vdGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjYWxsYmFja3MgPSBtZS5fb3B0aW9ucy5jYWxsYmFja3M7XG5cblx0XHR2YXIgYmVmb3JlRm9vdGVyID0gY2FsbGJhY2tzLmJlZm9yZUZvb3Rlci5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgZm9vdGVyID0gY2FsbGJhY2tzLmZvb3Rlci5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgYWZ0ZXJGb290ZXIgPSBjYWxsYmFja3MuYWZ0ZXJGb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cblx0XHR2YXIgbGluZXMgPSBbXTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuXG5cdFx0cmV0dXJuIGxpbmVzO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oY2hhbmdlZCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5fb3B0aW9ucztcblxuXHRcdC8vIE5lZWQgdG8gcmVnZW5lcmF0ZSB0aGUgbW9kZWwgYmVjYXVzZSBpdHMgZmFzdGVyIHRoYW4gdXNpbmcgZXh0ZW5kIGFuZCBpdCBpcyBuZWNlc3NhcnkgZHVlIHRvIHRoZSBvcHRpbWl6YXRpb24gaW4gQ2hhcnQuRWxlbWVudC50cmFuc2l0aW9uXG5cdFx0Ly8gdGhhdCBkb2VzIF92aWV3ID0gX21vZGVsIGlmIGVhc2UgPT09IDEuIFRoaXMgY2F1c2VzIHRoZSAybmQgdG9vbHRpcCB1cGRhdGUgdG8gc2V0IHByb3BlcnRpZXMgaW4gYm90aCB0aGUgdmlldyBhbmQgbW9kZWwgYXQgdGhlIHNhbWUgdGltZVxuXHRcdC8vIHdoaWNoIGJyZWFrcyBhbnkgYW5pbWF0aW9ucy5cblx0XHR2YXIgZXhpc3RpbmdNb2RlbCA9IG1lLl9tb2RlbDtcblx0XHR2YXIgbW9kZWwgPSBtZS5fbW9kZWwgPSBnZXRCYXNlTW9kZWwob3B0cyk7XG5cdFx0dmFyIGFjdGl2ZSA9IG1lLl9hY3RpdmU7XG5cblx0XHR2YXIgZGF0YSA9IG1lLl9kYXRhO1xuXG5cdFx0Ly8gSW4gdGhlIGNhc2Ugd2hlcmUgYWN0aXZlLmxlbmd0aCA9PT0gMCB3ZSBuZWVkIHRvIGtlZXAgdGhlc2UgYXQgZXhpc3RpbmcgdmFsdWVzIGZvciBnb29kIGFuaW1hdGlvbnNcblx0XHR2YXIgYWxpZ25tZW50ID0ge1xuXHRcdFx0eEFsaWduOiBleGlzdGluZ01vZGVsLnhBbGlnbixcblx0XHRcdHlBbGlnbjogZXhpc3RpbmdNb2RlbC55QWxpZ25cblx0XHR9O1xuXHRcdHZhciBiYWNrZ3JvdW5kUG9pbnQgPSB7XG5cdFx0XHR4OiBleGlzdGluZ01vZGVsLngsXG5cdFx0XHR5OiBleGlzdGluZ01vZGVsLnlcblx0XHR9O1xuXHRcdHZhciB0b29sdGlwU2l6ZSA9IHtcblx0XHRcdHdpZHRoOiBleGlzdGluZ01vZGVsLndpZHRoLFxuXHRcdFx0aGVpZ2h0OiBleGlzdGluZ01vZGVsLmhlaWdodFxuXHRcdH07XG5cdFx0dmFyIHRvb2x0aXBQb3NpdGlvbiA9IHtcblx0XHRcdHg6IGV4aXN0aW5nTW9kZWwuY2FyZXRYLFxuXHRcdFx0eTogZXhpc3RpbmdNb2RlbC5jYXJldFlcblx0XHR9O1xuXG5cdFx0dmFyIGksIGxlbjtcblxuXHRcdGlmIChhY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRtb2RlbC5vcGFjaXR5ID0gMTtcblxuXHRcdFx0dmFyIGxhYmVsQ29sb3JzID0gW107XG5cdFx0XHR2YXIgbGFiZWxUZXh0Q29sb3JzID0gW107XG5cdFx0XHR0b29sdGlwUG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRzLnBvc2l0aW9uXS5jYWxsKG1lLCBhY3RpdmUsIG1lLl9ldmVudFBvc2l0aW9uKTtcblxuXHRcdFx0dmFyIHRvb2x0aXBJdGVtcyA9IFtdO1xuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHRcdHRvb2x0aXBJdGVtcy5wdXNoKGNyZWF0ZVRvb2x0aXBJdGVtKGFjdGl2ZVtpXSkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIGZpbHRlciBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuXHRcdFx0aWYgKG9wdHMuZmlsdGVyKSB7XG5cdFx0XHRcdHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoZnVuY3Rpb24oYSkge1xuXHRcdFx0XHRcdHJldHVybiBvcHRzLmZpbHRlcihhLCBkYXRhKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGEgc29ydGluZyBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuXHRcdFx0aWYgKG9wdHMuaXRlbVNvcnQpIHtcblx0XHRcdFx0dG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdHJldHVybiBvcHRzLml0ZW1Tb3J0KGEsIGIsIGRhdGEpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGNvbG9ycyBmb3IgYm94ZXNcblx0XHRcdGhlbHBlcnMkMS5lYWNoKHRvb2x0aXBJdGVtcywgZnVuY3Rpb24odG9vbHRpcEl0ZW0pIHtcblx0XHRcdFx0bGFiZWxDb2xvcnMucHVzaChvcHRzLmNhbGxiYWNrcy5sYWJlbENvbG9yLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBtZS5fY2hhcnQpKTtcblx0XHRcdFx0bGFiZWxUZXh0Q29sb3JzLnB1c2gob3B0cy5jYWxsYmFja3MubGFiZWxUZXh0Q29sb3IuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIG1lLl9jaGFydCkpO1xuXHRcdFx0fSk7XG5cblxuXHRcdFx0Ly8gQnVpbGQgdGhlIFRleHQgTGluZXNcblx0XHRcdG1vZGVsLnRpdGxlID0gbWUuZ2V0VGl0bGUodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdG1vZGVsLmJlZm9yZUJvZHkgPSBtZS5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRtb2RlbC5ib2R5ID0gbWUuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuYWZ0ZXJCb2R5ID0gbWUuZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRtb2RlbC5mb290ZXIgPSBtZS5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblxuXHRcdFx0Ly8gSW5pdGlhbCBwb3NpdGlvbmluZyBhbmQgY29sb3JzXG5cdFx0XHRtb2RlbC54ID0gdG9vbHRpcFBvc2l0aW9uLng7XG5cdFx0XHRtb2RlbC55ID0gdG9vbHRpcFBvc2l0aW9uLnk7XG5cdFx0XHRtb2RlbC5jYXJldFBhZGRpbmcgPSBvcHRzLmNhcmV0UGFkZGluZztcblx0XHRcdG1vZGVsLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG5cdFx0XHRtb2RlbC5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG5cblx0XHRcdC8vIGRhdGEgcG9pbnRzXG5cdFx0XHRtb2RlbC5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuXG5cdFx0XHQvLyBXZSBuZWVkIHRvIGRldGVybWluZSBhbGlnbm1lbnQgb2YgdGhlIHRvb2x0aXBcblx0XHRcdHRvb2x0aXBTaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgbW9kZWwpO1xuXHRcdFx0YWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMsIHRvb2x0aXBTaXplKTtcblx0XHRcdC8vIEZpbmFsIFNpemUgYW5kIFBvc2l0aW9uXG5cdFx0XHRiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQobW9kZWwsIHRvb2x0aXBTaXplLCBhbGlnbm1lbnQsIG1lLl9jaGFydCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1vZGVsLm9wYWNpdHkgPSAwO1xuXHRcdH1cblxuXHRcdG1vZGVsLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG5cdFx0bW9kZWwueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcblx0XHRtb2RlbC54ID0gYmFja2dyb3VuZFBvaW50Lng7XG5cdFx0bW9kZWwueSA9IGJhY2tncm91bmRQb2ludC55O1xuXHRcdG1vZGVsLndpZHRoID0gdG9vbHRpcFNpemUud2lkdGg7XG5cdFx0bW9kZWwuaGVpZ2h0ID0gdG9vbHRpcFNpemUuaGVpZ2h0O1xuXG5cdFx0Ly8gUG9pbnQgd2hlcmUgdGhlIGNhcmV0IG9uIHRoZSB0b29sdGlwIHBvaW50cyB0b1xuXHRcdG1vZGVsLmNhcmV0WCA9IHRvb2x0aXBQb3NpdGlvbi54O1xuXHRcdG1vZGVsLmNhcmV0WSA9IHRvb2x0aXBQb3NpdGlvbi55O1xuXG5cdFx0bWUuX21vZGVsID0gbW9kZWw7XG5cblx0XHRpZiAoY2hhbmdlZCAmJiBvcHRzLmN1c3RvbSkge1xuXHRcdFx0b3B0cy5jdXN0b20uY2FsbChtZSwgbW9kZWwpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZTtcblx0fSxcblxuXHRkcmF3Q2FyZXQ6IGZ1bmN0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgY2FyZXRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIHZtKTtcblxuXHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG5cdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcblx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuXHR9LFxuXHRnZXRDYXJldFBvc2l0aW9uOiBmdW5jdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIHZtKSB7XG5cdFx0dmFyIHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG5cdFx0dmFyIGNhcmV0U2l6ZSA9IHZtLmNhcmV0U2l6ZTtcblx0XHR2YXIgY29ybmVyUmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXHRcdHZhciB4QWxpZ24gPSB2bS54QWxpZ247XG5cdFx0dmFyIHlBbGlnbiA9IHZtLnlBbGlnbjtcblx0XHR2YXIgcHRYID0gdG9vbHRpcFBvaW50Lng7XG5cdFx0dmFyIHB0WSA9IHRvb2x0aXBQb2ludC55O1xuXHRcdHZhciB3aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuXG5cdFx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdFx0eDEgPSBwdFg7XG5cdFx0XHRcdHgyID0geDEgLSBjYXJldFNpemU7XG5cdFx0XHRcdHgzID0geDE7XG5cblx0XHRcdFx0eTEgPSB5MiArIGNhcmV0U2l6ZTtcblx0XHRcdFx0eTMgPSB5MiAtIGNhcmV0U2l6ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHgxID0gcHRYICsgd2lkdGg7XG5cdFx0XHRcdHgyID0geDEgKyBjYXJldFNpemU7XG5cdFx0XHRcdHgzID0geDE7XG5cblx0XHRcdFx0eTEgPSB5MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eTMgPSB5MiArIGNhcmV0U2l6ZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdHgyID0gcHRYICsgY29ybmVyUmFkaXVzICsgKGNhcmV0U2l6ZSk7XG5cdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XG5cdFx0XHRcdHgzID0geDIgKyBjYXJldFNpemU7XG5cdFx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0XHR4MiA9IHB0WCArIHdpZHRoIC0gY29ybmVyUmFkaXVzIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eDIgPSB2bS5jYXJldFg7XG5cdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XG5cdFx0XHRcdHgzID0geDIgKyBjYXJldFNpemU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoeUFsaWduID09PSAndG9wJykge1xuXHRcdFx0XHR5MSA9IHB0WTtcblx0XHRcdFx0eTIgPSB5MSAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eTMgPSB5MTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHkxID0gcHRZICsgaGVpZ2h0O1xuXHRcdFx0XHR5MiA9IHkxICsgY2FyZXRTaXplO1xuXHRcdFx0XHR5MyA9IHkxO1xuXHRcdFx0XHQvLyBpbnZlcnQgZHJhd2luZyBvcmRlclxuXHRcdFx0XHR2YXIgdG1wID0geDM7XG5cdFx0XHRcdHgzID0geDE7XG5cdFx0XHRcdHgxID0gdG1wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4ge3gxOiB4MSwgeDI6IHgyLCB4MzogeDMsIHkxOiB5MSwgeTI6IHkyLCB5MzogeTN9O1xuXHR9LFxuXG5cdGRyYXdUaXRsZTogZnVuY3Rpb24ocHQsIHZtLCBjdHgpIHtcblx0XHR2YXIgdGl0bGUgPSB2bS50aXRsZTtcblxuXHRcdGlmICh0aXRsZS5sZW5ndGgpIHtcblx0XHRcdHB0LnggPSBnZXRBbGlnbmVkWCh2bSwgdm0uX3RpdGxlQWxpZ24pO1xuXG5cdFx0XHRjdHgudGV4dEFsaWduID0gdm0uX3RpdGxlQWxpZ247XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cblx0XHRcdHZhciB0aXRsZUZvbnRTaXplID0gdm0udGl0bGVGb250U2l6ZTtcblx0XHRcdHZhciB0aXRsZVNwYWNpbmcgPSB2bS50aXRsZVNwYWNpbmc7XG5cblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS50aXRsZUZvbnRDb2xvcjtcblx0XHRcdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcodGl0bGVGb250U2l6ZSwgdm0uX3RpdGxlRm9udFN0eWxlLCB2bS5fdGl0bGVGb250RmFtaWx5KTtcblxuXHRcdFx0dmFyIGksIGxlbjtcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IHRpdGxlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcHQueCwgcHQueSk7XG5cdFx0XHRcdHB0LnkgKz0gdGl0bGVGb250U2l6ZSArIHRpdGxlU3BhY2luZzsgLy8gTGluZSBIZWlnaHQgYW5kIHNwYWNpbmdcblxuXHRcdFx0XHRpZiAoaSArIDEgPT09IHRpdGxlLmxlbmd0aCkge1xuXHRcdFx0XHRcdHB0LnkgKz0gdm0udGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7IC8vIElmIExhc3QsIGFkZCBtYXJnaW4sIHJlbW92ZSBzcGFjaW5nXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZHJhd0JvZHk6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XG5cdFx0dmFyIGJvZHlGb250U2l6ZSA9IHZtLmJvZHlGb250U2l6ZTtcblx0XHR2YXIgYm9keVNwYWNpbmcgPSB2bS5ib2R5U3BhY2luZztcblx0XHR2YXIgYm9keUFsaWduID0gdm0uX2JvZHlBbGlnbjtcblx0XHR2YXIgYm9keSA9IHZtLmJvZHk7XG5cdFx0dmFyIGRyYXdDb2xvckJveGVzID0gdm0uZGlzcGxheUNvbG9ycztcblx0XHR2YXIgbGFiZWxDb2xvcnMgPSB2bS5sYWJlbENvbG9ycztcblx0XHR2YXIgeExpbmVQYWRkaW5nID0gMDtcblx0XHR2YXIgY29sb3JYID0gZHJhd0NvbG9yQm94ZXMgPyBnZXRBbGlnbmVkWCh2bSwgJ2xlZnQnKSA6IDA7XG5cdFx0dmFyIHRleHRDb2xvcjtcblxuXHRcdGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXHRcdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcoYm9keUZvbnRTaXplLCB2bS5fYm9keUZvbnRTdHlsZSwgdm0uX2JvZHlGb250RmFtaWx5KTtcblxuXHRcdHB0LnggPSBnZXRBbGlnbmVkWCh2bSwgYm9keUFsaWduKTtcblxuXHRcdC8vIEJlZm9yZSBCb2R5XG5cdFx0dmFyIGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuXHRcdFx0Y3R4LmZpbGxUZXh0KGxpbmUsIHB0LnggKyB4TGluZVBhZGRpbmcsIHB0LnkpO1xuXHRcdFx0cHQueSArPSBib2R5Rm9udFNpemUgKyBib2R5U3BhY2luZztcblx0XHR9O1xuXG5cdFx0Ly8gQmVmb3JlIGJvZHkgbGluZXNcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYm9keUZvbnRDb2xvcjtcblx0XHRoZWxwZXJzJDEuZWFjaCh2bS5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG5cblx0XHR4TGluZVBhZGRpbmcgPSBkcmF3Q29sb3JCb3hlcyAmJiBib2R5QWxpZ24gIT09ICdyaWdodCdcblx0XHRcdD8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib2R5Rm9udFNpemUgLyAyICsgMSkgOiAoYm9keUZvbnRTaXplICsgMilcblx0XHRcdDogMDtcblxuXHRcdC8vIERyYXcgYm9keSBsaW5lcyBub3dcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5LCBmdW5jdGlvbihib2R5SXRlbSwgaSkge1xuXHRcdFx0dGV4dENvbG9yID0gdm0ubGFiZWxUZXh0Q29sb3JzW2ldO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5saW5lcywgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHQvLyBEcmF3IExlZ2VuZC1saWtlIGJveGVzIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoZHJhd0NvbG9yQm94ZXMpIHtcblx0XHRcdFx0XHQvLyBGaWxsIGEgd2hpdGUgcmVjdCBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5sZWdlbmRDb2xvckJhY2tncm91bmQ7XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KGNvbG9yWCwgcHQueSwgYm9keUZvbnRTaXplLCBib2R5Rm9udFNpemUpO1xuXG5cdFx0XHRcdFx0Ly8gQm9yZGVyXG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDE7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnNbaV0uYm9yZGVyQ29sb3I7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVJlY3QoY29sb3JYLCBwdC55LCBib2R5Rm9udFNpemUsIGJvZHlGb250U2l6ZSk7XG5cblx0XHRcdFx0XHQvLyBJbm5lciBzcXVhcmVcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnNbaV0uYmFja2dyb3VuZENvbG9yO1xuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChjb2xvclggKyAxLCBwdC55ICsgMSwgYm9keUZvbnRTaXplIC0gMiwgYm9keUZvbnRTaXplIC0gMik7XG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZpbGxMaW5lT2ZUZXh0KGxpbmUpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG5cdFx0fSk7XG5cblx0XHQvLyBSZXNldCBiYWNrIHRvIDAgZm9yIGFmdGVyIGJvZHlcblx0XHR4TGluZVBhZGRpbmcgPSAwO1xuXG5cdFx0Ly8gQWZ0ZXIgYm9keSBsaW5lc1xuXHRcdGhlbHBlcnMkMS5lYWNoKHZtLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXHRcdHB0LnkgLT0gYm9keVNwYWNpbmc7IC8vIFJlbW92ZSBsYXN0IGJvZHkgc3BhY2luZ1xuXHR9LFxuXG5cdGRyYXdGb290ZXI6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XG5cdFx0dmFyIGZvb3RlciA9IHZtLmZvb3RlcjtcblxuXHRcdGlmIChmb290ZXIubGVuZ3RoKSB7XG5cdFx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIHZtLl9mb290ZXJBbGlnbik7XG5cdFx0XHRwdC55ICs9IHZtLmZvb3Rlck1hcmdpblRvcDtcblxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IHZtLl9mb290ZXJBbGlnbjtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmZvb3RlckZvbnRDb2xvcjtcblx0XHRcdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcodm0uZm9vdGVyRm9udFNpemUsIHZtLl9mb290ZXJGb250U3R5bGUsIHZtLl9mb290ZXJGb250RmFtaWx5KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goZm9vdGVyLCBmdW5jdGlvbihsaW5lKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBwdC54LCBwdC55KTtcblx0XHRcdFx0cHQueSArPSB2bS5mb290ZXJGb250U2l6ZSArIHZtLmZvb3RlclNwYWNpbmc7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhd0JhY2tncm91bmQ6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4LCB0b29sdGlwU2l6ZSkge1xuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoO1xuXHRcdHZhciB4QWxpZ24gPSB2bS54QWxpZ247XG5cdFx0dmFyIHlBbGlnbiA9IHZtLnlBbGlnbjtcblx0XHR2YXIgeCA9IHB0Lng7XG5cdFx0dmFyIHkgPSBwdC55O1xuXHRcdHZhciB3aWR0aCA9IHRvb2x0aXBTaXplLndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSB0b29sdGlwU2l6ZS5oZWlnaHQ7XG5cdFx0dmFyIHJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuXHRcdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdH1cblx0XHRjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHR9XG5cdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcblx0XHRpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHR9XG5cdFx0Y3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHR9XG5cdFx0Y3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRjdHguZmlsbCgpO1xuXG5cdFx0aWYgKHZtLmJvcmRlcldpZHRoID4gMCkge1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cblx0XHRpZiAodm0ub3BhY2l0eSA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0b29sdGlwU2l6ZSA9IHtcblx0XHRcdHdpZHRoOiB2bS53aWR0aCxcblx0XHRcdGhlaWdodDogdm0uaGVpZ2h0XG5cdFx0fTtcblx0XHR2YXIgcHQgPSB7XG5cdFx0XHR4OiB2bS54LFxuXHRcdFx0eTogdm0ueVxuXHRcdH07XG5cblx0XHQvLyBJRTExL0VkZ2UgZG9lcyBub3QgbGlrZSB2ZXJ5IHNtYWxsIG9wYWNpdGllcywgc28gc25hcCB0byAwXG5cdFx0dmFyIG9wYWNpdHkgPSBNYXRoLmFicyh2bS5vcGFjaXR5IDwgMWUtMykgPyAwIDogdm0ub3BhY2l0eTtcblxuXHRcdC8vIFRydXRoeS9mYWxzZXkgdmFsdWUgZm9yIGVtcHR5IHRvb2x0aXBcblx0XHR2YXIgaGFzVG9vbHRpcENvbnRlbnQgPSB2bS50aXRsZS5sZW5ndGggfHwgdm0uYmVmb3JlQm9keS5sZW5ndGggfHwgdm0uYm9keS5sZW5ndGggfHwgdm0uYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB2bS5mb290ZXIubGVuZ3RoO1xuXG5cdFx0aWYgKHRoaXMuX29wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cblx0XHRcdC8vIERyYXcgQmFja2dyb3VuZFxuXHRcdFx0dGhpcy5kcmF3QmFja2dyb3VuZChwdCwgdm0sIGN0eCwgdG9vbHRpcFNpemUpO1xuXG5cdFx0XHQvLyBEcmF3IFRpdGxlLCBCb2R5LCBhbmQgRm9vdGVyXG5cdFx0XHRwdC55ICs9IHZtLnlQYWRkaW5nO1xuXG5cdFx0XHQvLyBUaXRsZXNcblx0XHRcdHRoaXMuZHJhd1RpdGxlKHB0LCB2bSwgY3R4KTtcblxuXHRcdFx0Ly8gQm9keVxuXHRcdFx0dGhpcy5kcmF3Qm9keShwdCwgdm0sIGN0eCk7XG5cblx0XHRcdC8vIEZvb3RlclxuXHRcdFx0dGhpcy5kcmF3Rm9vdGVyKHB0LCB2bSwgY3R4KTtcblxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0b29sdGlwIGNoYW5nZWRcblx0ICovXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9vcHRpb25zO1xuXHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cblx0XHRtZS5fbGFzdEFjdGl2ZSA9IG1lLl9sYXN0QWN0aXZlIHx8IFtdO1xuXG5cdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIHRvb2x0aXBzXG5cdFx0aWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuXHRcdFx0bWUuX2FjdGl2ZSA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5fYWN0aXZlID0gbWUuX2NoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcblx0XHRjaGFuZ2VkID0gIWhlbHBlcnMkMS5hcnJheUVxdWFscyhtZS5fYWN0aXZlLCBtZS5fbGFzdEFjdGl2ZSk7XG5cblx0XHQvLyBPbmx5IGhhbmRsZSB0YXJnZXQgZXZlbnQgb24gdG9vbHRpcCBjaGFuZ2Vcblx0XHRpZiAoY2hhbmdlZCkge1xuXHRcdFx0bWUuX2xhc3RBY3RpdmUgPSBtZS5fYWN0aXZlO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuY3VzdG9tKSB7XG5cdFx0XHRcdG1lLl9ldmVudFBvc2l0aW9uID0ge1xuXHRcdFx0XHRcdHg6IGUueCxcblx0XHRcdFx0XHR5OiBlLnlcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRtZS51cGRhdGUodHJ1ZSk7XG5cdFx0XHRcdG1lLnBpdm90KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdH1cbn0pO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVyc1xuICovXG52YXIgcG9zaXRpb25lcnNfMSA9IHBvc2l0aW9uZXJzO1xuXG52YXIgY29yZV90b29sdGlwID0gZXhwb3J0cyQzO1xuY29yZV90b29sdGlwLnBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnNfMTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDggPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge30sXG5cdGV2ZW50czogW1xuXHRcdCdtb3VzZW1vdmUnLFxuXHRcdCdtb3VzZW91dCcsXG5cdFx0J2NsaWNrJyxcblx0XHQndG91Y2hzdGFydCcsXG5cdFx0J3RvdWNobW92ZSdcblx0XSxcblx0aG92ZXI6IHtcblx0XHRvbkhvdmVyOiBudWxsLFxuXHRcdG1vZGU6ICduZWFyZXN0Jyxcblx0XHRpbnRlcnNlY3Q6IHRydWUsXG5cdFx0YW5pbWF0aW9uRHVyYXRpb246IDQwMFxuXHR9LFxuXHRvbkNsaWNrOiBudWxsLFxuXHRtYWludGFpbkFzcGVjdFJhdGlvOiB0cnVlLFxuXHRyZXNwb25zaXZlOiB0cnVlLFxuXHRyZXNwb25zaXZlQW5pbWF0aW9uRHVyYXRpb246IDBcbn0pO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBnaXZlbiBjb25maWcgb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGBzY2FsZXNgIG9wdGlvblxuICogYnkgaW5jb3Jwb3JhdGluZyBzY2FsZSBkZWZhdWx0cyBpbiBgeEF4ZXNgIGFuZCBgeUF4ZXNgIGFycmF5IGl0ZW1zLCB0aGVuXG4gKiByZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSByZXN1bHQsIHRodXMgZG9lc24ndCBhbHRlciBpbnB1dHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoLyogY29uZmlnIG9iamVjdHMgLi4uICovKSB7XG5cdHJldHVybiBoZWxwZXJzJDEubWVyZ2Uoe30sIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwge1xuXHRcdG1lcmdlcjogZnVuY3Rpb24oa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0aWYgKGtleSA9PT0gJ3hBeGVzJyB8fCBrZXkgPT09ICd5QXhlcycpIHtcblx0XHRcdFx0dmFyIHNsZW4gPSBzb3VyY2Vba2V5XS5sZW5ndGg7XG5cdFx0XHRcdHZhciBpLCB0eXBlLCBzY2FsZTtcblxuXHRcdFx0XHRpZiAoIXRhcmdldFtrZXldKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzbGVuOyArK2kpIHtcblx0XHRcdFx0XHRzY2FsZSA9IHNvdXJjZVtrZXldW2ldO1xuXHRcdFx0XHRcdHR5cGUgPSB2YWx1ZU9yRGVmYXVsdCQ4KHNjYWxlLnR5cGUsIGtleSA9PT0gJ3hBeGVzJyA/ICdjYXRlZ29yeScgOiAnbGluZWFyJyk7XG5cblx0XHRcdFx0XHRpZiAoaSA+PSB0YXJnZXRba2V5XS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtrZXldLnB1c2goe30pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICghdGFyZ2V0W2tleV1baV0udHlwZSB8fCAoc2NhbGUudHlwZSAmJiBzY2FsZS50eXBlICE9PSB0YXJnZXRba2V5XVtpXS50eXBlKSkge1xuXHRcdFx0XHRcdFx0Ly8gbmV3L3VudHlwZWQgc2NhbGUgb3IgdHlwZSBjaGFuZ2VkOiBsZXQncyBhcHBseSB0aGUgbmV3IGRlZmF1bHRzXG5cdFx0XHRcdFx0XHQvLyB0aGVuIG1lcmdlIHNvdXJjZSBzY2FsZSB0byBjb3JyZWN0bHkgb3ZlcndyaXRlIHRoZSBkZWZhdWx0cy5cblx0XHRcdFx0XHRcdGhlbHBlcnMkMS5tZXJnZSh0YXJnZXRba2V5XVtpXSwgW2NvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHModHlwZSksIHNjYWxlXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHNjYWxlcyB0eXBlIGFyZSB0aGUgc2FtZVxuXHRcdFx0XHRcdFx0aGVscGVycyQxLm1lcmdlKHRhcmdldFtrZXldW2ldLCBzY2FsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoZWxwZXJzJDEuX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBnaXZlbiBjb25maWcgb2JqZWN0cyBhcyB0aGUgcm9vdCBvcHRpb25zIGJ5IGhhbmRsaW5nXG4gKiBkZWZhdWx0IHNjYWxlIG9wdGlvbnMgZm9yIHRoZSBgc2NhbGVzYCBhbmQgYHNjYWxlYCBwcm9wZXJ0aWVzLCB0aGVuIHJldHVybnNcbiAqIGEgZGVlcCBjb3B5IG9mIHRoZSByZXN1bHQsIHRodXMgZG9lc24ndCBhbHRlciBpbnB1dHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKC8qIGNvbmZpZyBvYmplY3RzIC4uLiAqLykge1xuXHRyZXR1cm4gaGVscGVycyQxLm1lcmdlKHt9LCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIHtcblx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRcdHZhciB0dmFsID0gdGFyZ2V0W2tleV0gfHwge307XG5cdFx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0XHRpZiAoa2V5ID09PSAnc2NhbGVzJykge1xuXHRcdFx0XHQvLyBzY2FsZSBjb25maWcgbWVyZ2luZyBpcyBjb21wbGV4LiBBZGQgb3VyIG93biBmdW5jdGlvbiBoZXJlIGZvciB0aGF0XG5cdFx0XHRcdHRhcmdldFtrZXldID0gbWVyZ2VTY2FsZUNvbmZpZyh0dmFsLCBzdmFsKTtcblx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc2NhbGUnKSB7XG5cdFx0XHRcdC8vIHVzZWQgaW4gcG9sYXIgYXJlYSAmIHJhZGFyIGNoYXJ0cyBzaW5jZSB0aGVyZSBpcyBvbmx5IG9uZSBzY2FsZVxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMkMS5tZXJnZSh0dmFsLCBbY29yZV9zY2FsZVNlcnZpY2UuZ2V0U2NhbGVEZWZhdWx0cyhzdmFsLnR5cGUpLCBzdmFsXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoZWxwZXJzJDEuX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gRG8gTk9UIHVzZSBtZXJnZUNvbmZpZyBmb3IgdGhlIGRhdGEgb2JqZWN0IGJlY2F1c2UgdGhpcyBtZXRob2QgbWVyZ2VzIGFycmF5c1xuXHQvLyBhbmQgc28gd291bGQgY2hhbmdlIHJlZmVyZW5jZXMgdG8gbGFiZWxzIGFuZCBkYXRhc2V0cywgcHJldmVudGluZyBkYXRhIHVwZGF0ZXMuXG5cdHZhciBkYXRhID0gY29uZmlnLmRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcblx0ZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG5cdGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG5cblx0Y29uZmlnLm9wdGlvbnMgPSBtZXJnZUNvbmZpZyhcblx0XHRjb3JlX2RlZmF1bHRzLmdsb2JhbCxcblx0XHRjb3JlX2RlZmF1bHRzW2NvbmZpZy50eXBlXSxcblx0XHRjb25maWcub3B0aW9ucyB8fCB7fSk7XG5cblx0cmV0dXJuIGNvbmZpZztcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29uZmlnKGNoYXJ0KSB7XG5cdHZhciBuZXdPcHRpb25zID0gY2hhcnQub3B0aW9ucztcblxuXHRoZWxwZXJzJDEuZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG5cdFx0Y29yZV9sYXlvdXRzLnJlbW92ZUJveChjaGFydCwgc2NhbGUpO1xuXHR9KTtcblxuXHRuZXdPcHRpb25zID0gbWVyZ2VDb25maWcoXG5cdFx0Y29yZV9kZWZhdWx0cy5nbG9iYWwsXG5cdFx0Y29yZV9kZWZhdWx0c1tjaGFydC5jb25maWcudHlwZV0sXG5cdFx0bmV3T3B0aW9ucyk7XG5cblx0Y2hhcnQub3B0aW9ucyA9IGNoYXJ0LmNvbmZpZy5vcHRpb25zID0gbmV3T3B0aW9ucztcblx0Y2hhcnQuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuXHRjaGFydC5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG5cblx0Ly8gVG9vbHRpcFxuXHRjaGFydC50b29sdGlwLl9vcHRpb25zID0gbmV3T3B0aW9ucy50b29sdGlwcztcblx0Y2hhcnQudG9vbHRpcC5pbml0aWFsaXplKCk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uKSB7XG5cdHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nO1xufVxuXG52YXIgQ2hhcnQgPSBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0dGhpcy5jb25zdHJ1Y3QoaXRlbSwgY29uZmlnKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5oZWxwZXJzJDEuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBDaGFydCAqLyB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y29uc3RydWN0OiBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Y29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuXG5cdFx0dmFyIGNvbnRleHQgPSBwbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChpdGVtLCBjb25maWcpO1xuXHRcdHZhciBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuXHRcdHZhciBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcblx0XHR2YXIgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuXG5cdFx0bWUuaWQgPSBoZWxwZXJzJDEudWlkKCk7XG5cdFx0bWUuY3R4ID0gY29udGV4dDtcblx0XHRtZS5jYW52YXMgPSBjYW52YXM7XG5cdFx0bWUuY29uZmlnID0gY29uZmlnO1xuXHRcdG1lLndpZHRoID0gd2lkdGg7XG5cdFx0bWUuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdG1lLmFzcGVjdFJhdGlvID0gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuXHRcdG1lLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBDaGFydCBhbmQgQ2hhcnQuQ29udHJvbGxlciBoYXZlIGJlZW4gbWVyZ2VkLFxuXHRcdCAqIHRoZSBcImluc3RhbmNlXCIgc3RpbGwgbmVlZCB0byBiZSBkZWZpbmVkIHNpbmNlIGl0IG1pZ2h0IGJlIGNhbGxlZCBmcm9tIHBsdWdpbnMuXG5cdFx0ICogQHByb3AgQ2hhcnQjY2hhcnRcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0bWUuY2hhcnQgPSBtZTtcblx0XHRtZS5jb250cm9sbGVyID0gbWU7IC8vIGNoYXJ0LmNoYXJ0LmNvbnRyb2xsZXIgI2luY2VwdGlvblxuXG5cdFx0Ly8gQWRkIHRoZSBjaGFydCBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuXHRcdENoYXJ0Lmluc3RhbmNlc1ttZS5pZF0gPSBtZTtcblxuXHRcdC8vIERlZmluZSBhbGlhcyB0byB0aGUgY29uZmlnIGRhdGE6IGBjaGFydC5kYXRhID09PSBjaGFydC5jb25maWcuZGF0YWBcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdkYXRhJywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1lLmNvbmZpZy5kYXRhO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0bWUuY29uZmlnLmRhdGEgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG5cdFx0XHQvLyBUaGUgZ2l2ZW4gaXRlbSBpcyBub3QgYSBjb21wYXRpYmxlIGNvbnRleHQyZCBlbGVtZW50LCBsZXQncyByZXR1cm4gYmVmb3JlIGZpbmFsaXppbmdcblx0XHRcdC8vIHRoZSBjaGFydCBpbml0aWFsaXphdGlvbiBidXQgYWZ0ZXIgc2V0dGluZyBiYXNpYyBjaGFydCAvIGNvbnRyb2xsZXIgcHJvcGVydGllcyB0aGF0XG5cdFx0XHQvLyBjYW4gaGVscCB0byBmaWd1cmUgb3V0IHRoYXQgdGhlIGNoYXJ0IGlzIG5vdCB2YWxpZCAoZS5nIGNoYXJ0LmNhbnZhcyAhPT0gbnVsbCk7XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG1lLmluaXRpYWxpemUoKTtcblx0XHRtZS51cGRhdGUoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHQvLyBCZWZvcmUgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUluaXQnKTtcblxuXHRcdGhlbHBlcnMkMS5yZXRpbmFTY2FsZShtZSwgbWUub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuXHRcdG1lLmJpbmRFdmVudHMoKTtcblxuXHRcdGlmIChtZS5vcHRpb25zLnJlc3BvbnNpdmUpIHtcblx0XHRcdC8vIEluaXRpYWwgcmVzaXplIGJlZm9yZSBjaGFydCBkcmF3cyAobXVzdCBiZSBzaWxlbnQgdG8gcHJlc2VydmUgaW5pdGlhbCBhbmltYXRpb25zKS5cblx0XHRcdG1lLnJlc2l6ZSh0cnVlKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgc2NhbGVzIGhhdmUgSURzIGFuZCBhcmUgYnVpbHQgYmVmb3JlIHdlIGJ1aWxkIGFueSBjb250cm9sbGVycy5cblx0XHRtZS5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG5cdFx0bWUuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuXHRcdG1lLmluaXRUb29sVGlwKCk7XG5cblx0XHQvLyBBZnRlciBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJJbml0Jyk7XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMuY2xlYXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gU3RvcHMgYW55IGN1cnJlbnQgYW5pbWF0aW9uIGxvb3Agb2NjdXJyaW5nXG5cdFx0Y29yZV9hbmltYXRpb25zLmNhbmNlbEFuaW1hdGlvbih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZXNpemU6IGZ1bmN0aW9uKHNpbGVudCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBjYW52YXMgPSBtZS5jYW52YXM7XG5cdFx0dmFyIGFzcGVjdFJhdGlvID0gKG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBtZS5hc3BlY3RSYXRpbykgfHwgbnVsbDtcblxuXHRcdC8vIHRoZSBjYW52YXMgcmVuZGVyIHdpZHRoIGFuZCBoZWlnaHQgd2lsbCBiZSBjYXN0ZWQgdG8gaW50ZWdlcnMgc28gbWFrZSBzdXJlIHRoYXRcblx0XHQvLyB0aGUgY2FudmFzIGRpc3BsYXkgc3R5bGUgdXNlcyB0aGUgc2FtZSBpbnRlZ2VyIHZhbHVlcyB0byBhdm9pZCBibHVycmluZyBlZmZlY3QuXG5cblx0XHQvLyBTZXQgdG8gMCBpbnN0ZWFkIG9mIGNhbnZhcy5zaXplIGJlY2F1c2UgdGhlIHNpemUgZGVmYXVsdHMgdG8gMzAweDE1MCBpZiB0aGUgZWxlbWVudCBpcyBjb2xsYXBzZWRcblx0XHR2YXIgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5nZXRNYXhpbXVtV2lkdGgoY2FudmFzKSkpO1xuXHRcdHZhciBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGFzcGVjdFJhdGlvID8gbmV3V2lkdGggLyBhc3BlY3RSYXRpbyA6IGhlbHBlcnMkMS5nZXRNYXhpbXVtSGVpZ2h0KGNhbnZhcykpKTtcblxuXHRcdGlmIChtZS53aWR0aCA9PT0gbmV3V2lkdGggJiYgbWUuaGVpZ2h0ID09PSBuZXdIZWlnaHQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjYW52YXMud2lkdGggPSBtZS53aWR0aCA9IG5ld1dpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBtZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XG5cdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gbmV3V2lkdGggKyAncHgnO1xuXHRcdGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyAncHgnO1xuXG5cdFx0aGVscGVycyQxLnJldGluYVNjYWxlKG1lLCBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0aWYgKCFzaWxlbnQpIHtcblx0XHRcdC8vIE5vdGlmeSBhbnkgcGx1Z2lucyBhYm91dCB0aGUgcmVzaXplXG5cdFx0XHR2YXIgbmV3U2l6ZSA9IHt3aWR0aDogbmV3V2lkdGgsIGhlaWdodDogbmV3SGVpZ2h0fTtcblx0XHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdyZXNpemUnLCBbbmV3U2l6ZV0pO1xuXG5cdFx0XHQvLyBOb3RpZnkgb2YgcmVzaXplXG5cdFx0XHRpZiAob3B0aW9ucy5vblJlc2l6ZSkge1xuXHRcdFx0XHRvcHRpb25zLm9uUmVzaXplKG1lLCBuZXdTaXplKTtcblx0XHRcdH1cblxuXHRcdFx0bWUuc3RvcCgpO1xuXHRcdFx0bWUudXBkYXRlKHtcblx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMucmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0ZW5zdXJlU2NhbGVzSGF2ZUlEczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0dmFyIHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcblx0XHR2YXIgc2NhbGVPcHRpb25zID0gb3B0aW9ucy5zY2FsZTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHNjYWxlc09wdGlvbnMueEF4ZXMsIGZ1bmN0aW9uKHhBeGlzT3B0aW9ucywgaW5kZXgpIHtcblx0XHRcdHhBeGlzT3B0aW9ucy5pZCA9IHhBeGlzT3B0aW9ucy5pZCB8fCAoJ3gtYXhpcy0nICsgaW5kZXgpO1xuXHRcdH0pO1xuXG5cdFx0aGVscGVycyQxLmVhY2goc2NhbGVzT3B0aW9ucy55QXhlcywgZnVuY3Rpb24oeUF4aXNPcHRpb25zLCBpbmRleCkge1xuXHRcdFx0eUF4aXNPcHRpb25zLmlkID0geUF4aXNPcHRpb25zLmlkIHx8ICgneS1heGlzLScgKyBpbmRleCk7XG5cdFx0fSk7XG5cblx0XHRpZiAoc2NhbGVPcHRpb25zKSB7XG5cdFx0XHRzY2FsZU9wdGlvbnMuaWQgPSBzY2FsZU9wdGlvbnMuaWQgfHwgJ3NjYWxlJztcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEJ1aWxkcyBhIG1hcCBvZiBzY2FsZSBJRCB0byBzY2FsZSBvYmplY3QgZm9yIGZ1dHVyZSBsb29rdXAuXG5cdCAqL1xuXHRidWlsZE9yVXBkYXRlU2NhbGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgc2NhbGVzID0gbWUuc2NhbGVzIHx8IHt9O1xuXHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdHZhciB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBpZCkge1xuXHRcdFx0b2JqW2lkXSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LCB7fSk7XG5cblx0XHRpZiAob3B0aW9ucy5zY2FsZXMpIHtcblx0XHRcdGl0ZW1zID0gaXRlbXMuY29uY2F0KFxuXHRcdFx0XHQob3B0aW9ucy5zY2FsZXMueEF4ZXMgfHwgW10pLm1hcChmdW5jdGlvbih4QXhpc09wdGlvbnMpIHtcblx0XHRcdFx0XHRyZXR1cm4ge29wdGlvbnM6IHhBeGlzT3B0aW9ucywgZHR5cGU6ICdjYXRlZ29yeScsIGRwb3NpdGlvbjogJ2JvdHRvbSd9O1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnlBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeUF4aXNPcHRpb25zKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtvcHRpb25zOiB5QXhpc09wdGlvbnMsIGR0eXBlOiAnbGluZWFyJywgZHBvc2l0aW9uOiAnbGVmdCd9O1xuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zY2FsZSkge1xuXHRcdFx0aXRlbXMucHVzaCh7XG5cdFx0XHRcdG9wdGlvbnM6IG9wdGlvbnMuc2NhbGUsXG5cdFx0XHRcdGR0eXBlOiAncmFkaWFsTGluZWFyJyxcblx0XHRcdFx0aXNEZWZhdWx0OiB0cnVlLFxuXHRcdFx0XHRkcG9zaXRpb246ICdjaGFydEFyZWEnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRoZWxwZXJzJDEuZWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0dmFyIHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcblx0XHRcdHZhciBpZCA9IHNjYWxlT3B0aW9ucy5pZDtcblx0XHRcdHZhciBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdCQ4KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcblxuXHRcdFx0aWYgKHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbikgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuXHRcdFx0XHRzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlZFtpZF0gPSB0cnVlO1xuXHRcdFx0dmFyIHNjYWxlID0gbnVsbDtcblx0XHRcdGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcblx0XHRcdFx0c2NhbGUgPSBzY2FsZXNbaWRdO1xuXHRcdFx0XHRzY2FsZS5vcHRpb25zID0gc2NhbGVPcHRpb25zO1xuXHRcdFx0XHRzY2FsZS5jdHggPSBtZS5jdHg7XG5cdFx0XHRcdHNjYWxlLmNoYXJ0ID0gbWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc2NhbGVDbGFzcyA9IGNvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlQ29uc3RydWN0b3Ioc2NhbGVUeXBlKTtcblx0XHRcdFx0aWYgKCFzY2FsZUNsYXNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuXHRcdFx0XHRcdGlkOiBpZCxcblx0XHRcdFx0XHR0eXBlOiBzY2FsZVR5cGUsXG5cdFx0XHRcdFx0b3B0aW9uczogc2NhbGVPcHRpb25zLFxuXHRcdFx0XHRcdGN0eDogbWUuY3R4LFxuXHRcdFx0XHRcdGNoYXJ0OiBtZVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuXHRcdFx0fVxuXG5cdFx0XHRzY2FsZS5tZXJnZVRpY2tzT3B0aW9ucygpO1xuXG5cdFx0XHQvLyBUT0RPKFNCKTogSSB0aGluayB3ZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyBjdXN0b20gY2FzZSAob3B0aW9ucy5zY2FsZSlcblx0XHRcdC8vIGFuZCBjb25zaWRlciBpdCBhcyBhIHJlZ3VsYXIgc2NhbGUgcGFydCBvZiB0aGUgXCJzY2FsZXNcIlwiIG1hcCBvbmx5ISBUaGlzIHdvdWxkXG5cdFx0XHQvLyBtYWtlIHRoZSBsb2dpYyBlYXNpZXIgYW5kIHJlbW92ZSBzb21lIHVzZWxlc3M/IGN1c3RvbSBjb2RlLlxuXHRcdFx0aWYgKGl0ZW0uaXNEZWZhdWx0KSB7XG5cdFx0XHRcdG1lLnNjYWxlID0gc2NhbGU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Ly8gY2xlYXIgdXAgZGlzY2FyZGVkIHNjYWxlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKHVwZGF0ZWQsIGZ1bmN0aW9uKGhhc1VwZGF0ZWQsIGlkKSB7XG5cdFx0XHRpZiAoIWhhc1VwZGF0ZWQpIHtcblx0XHRcdFx0ZGVsZXRlIHNjYWxlc1tpZF07XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRtZS5zY2FsZXMgPSBzY2FsZXM7XG5cblx0XHRjb3JlX3NjYWxlU2VydmljZS5hZGRTY2FsZXNUb0xheW91dCh0aGlzKTtcblx0fSxcblxuXHRidWlsZE9yVXBkYXRlQ29udHJvbGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG5ld0NvbnRyb2xsZXJzID0gW107XG5cblx0XHRoZWxwZXJzJDEuZWFjaChtZS5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdHZhciB0eXBlID0gZGF0YXNldC50eXBlIHx8IG1lLmNvbmZpZy50eXBlO1xuXG5cdFx0XHRpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xuXHRcdFx0XHRtZS5kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0bWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHR9XG5cdFx0XHRtZXRhLnR5cGUgPSB0eXBlO1xuXG5cdFx0XHRpZiAobWV0YS5jb250cm9sbGVyKSB7XG5cdFx0XHRcdG1ldGEuY29udHJvbGxlci51cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIENvbnRyb2xsZXJDbGFzcyA9IGNvbnRyb2xsZXJzW21ldGEudHlwZV07XG5cdFx0XHRcdGlmIChDb250cm9sbGVyQ2xhc3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignXCInICsgbWV0YS50eXBlICsgJ1wiIGlzIG5vdCBhIGNoYXJ0IHR5cGUuJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKG1lLCBkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG5cdFx0XHR9XG5cdFx0fSwgbWUpO1xuXG5cdFx0cmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgZWxlbWVudHMgb2YgYWxsIGRhdGFzZXRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZXNldEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG5cdFx0fSwgbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJlc2V0cyB0aGUgY2hhcnQgYmFjayB0byBpdCdzIHN0YXRlIGJlZm9yZSB0aGUgaW5pdGlhbCBhbmltYXRpb25cblx0Ki9cblx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVzZXRFbGVtZW50cygpO1xuXHRcdHRoaXMudG9vbHRpcC5pbml0aWFsaXplKCk7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKCFjb25maWcgfHwgdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRjb25maWcgPSB7XG5cdFx0XHRcdGR1cmF0aW9uOiBjb25maWcsXG5cdFx0XHRcdGxhenk6IGFyZ3VtZW50c1sxXVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR1cGRhdGVDb25maWcobWUpO1xuXG5cdFx0Ly8gcGx1Z2lucyBvcHRpb25zIHJlZmVyZW5jZXMgbWlnaHQgaGF2ZSBjaGFuZ2UsIGxldCdzIGludmFsaWRhdGUgdGhlIGNhY2hlXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzUxMTEjaXNzdWVjb21tZW50LTM1NTkzNDE2N1xuXHRcdGNvcmVfcGx1Z2lucy5faW52YWxpZGF0ZShtZSk7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZVVwZGF0ZScpID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEluIGNhc2UgdGhlIGVudGlyZSBkYXRhIG9iamVjdCBjaGFuZ2VkXG5cdFx0bWUudG9vbHRpcC5fZGF0YSA9IG1lLmRhdGE7XG5cblx0XHQvLyBNYWtlIHN1cmUgZGF0YXNldCBjb250cm9sbGVycyBhcmUgdXBkYXRlZCBhbmQgbmV3IGNvbnRyb2xsZXJzIGFyZSByZXNldFxuXHRcdHZhciBuZXdDb250cm9sbGVycyA9IG1lLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIGhhdmUgY29ycmVjdCBtZXRhIGRhdGEgY291bnRzXG5cdFx0aGVscGVycyQxLmVhY2gobWUuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKCk7XG5cdFx0fSwgbWUpO1xuXG5cdFx0bWUudXBkYXRlTGF5b3V0KCk7XG5cblx0XHQvLyBDYW4gb25seSByZXNldCB0aGUgbmV3IGNvbnRyb2xsZXJzIGFmdGVyIHRoZSBzY2FsZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcblx0XHRpZiAobWUub3B0aW9ucy5hbmltYXRpb24gJiYgbWUub3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24pIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKG5ld0NvbnRyb2xsZXJzLCBmdW5jdGlvbihjb250cm9sbGVyKSB7XG5cdFx0XHRcdGNvbnRyb2xsZXIucmVzZXQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdG1lLnVwZGF0ZURhdGFzZXRzKCk7XG5cblx0XHQvLyBOZWVkIHRvIHJlc2V0IHRvb2x0aXAgaW4gY2FzZSBpdCBpcyBkaXNwbGF5ZWQgd2l0aCBlbGVtZW50cyB0aGF0IGFyZSByZW1vdmVkXG5cdFx0Ly8gYWZ0ZXIgdXBkYXRlLlxuXHRcdG1lLnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xuXG5cdFx0Ly8gTGFzdCBhY3RpdmUgY29udGFpbnMgaXRlbXMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgaW4gdGhlIHRvb2x0aXAuXG5cdFx0Ly8gV2hlbiB3ZSByZXNldCB0aGUgdG9vbHRpcCwgd2UgbmVlZCB0byBjbGVhciBpdFxuXHRcdG1lLmxhc3RBY3RpdmUgPSBbXTtcblxuXHRcdC8vIERvIHRoaXMgYmVmb3JlIHJlbmRlciBzbyB0aGF0IGFueSBwbHVnaW5zIHRoYXQgbmVlZCBmaW5hbCBzY2FsZSB1cGRhdGVzIGNhbiB1c2UgaXRcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJVcGRhdGUnKTtcblxuXHRcdGlmIChtZS5fYnVmZmVyZWRSZW5kZXIpIHtcblx0XHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSB7XG5cdFx0XHRcdGR1cmF0aW9uOiBjb25maWcuZHVyYXRpb24sXG5cdFx0XHRcdGVhc2luZzogY29uZmlnLmVhc2luZyxcblx0XHRcdFx0bGF6eTogY29uZmlnLmxhenlcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLnJlbmRlcihjb25maWcpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY2hhcnQgbGF5b3V0IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVMYXlvdXRgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckxheW91dGAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUxheW91dCcpID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvcmVfbGF5b3V0cy51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG5cdFx0LyoqXG5cdFx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBgYWZ0ZXJMYXlvdXRgIGluc3RlYWQuXG5cdFx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyU2NhbGVVcGRhdGVcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNS4wXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyU2NhbGVVcGRhdGUnKTtcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJMYXlvdXQnKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlcyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzVXBkYXRlYFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c1VwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVEYXRhc2V0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldHNVcGRhdGUnKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVEYXRhc2V0KGkpO1xuXHRcdH1cblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRzVXBkYXRlJyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVEYXRhc2V0OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0dmFyIGFyZ3MgPSB7XG5cdFx0XHRtZXRhOiBtZXRhLFxuXHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0fTtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldFVwZGF0ZScsIFthcmdzXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bWV0YS5jb250cm9sbGVyLnVwZGF0ZSgpO1xuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldFVwZGF0ZScsIFthcmdzXSk7XG5cdH0sXG5cblx0cmVuZGVyOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKCFjb25maWcgfHwgdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRjb25maWcgPSB7XG5cdFx0XHRcdGR1cmF0aW9uOiBjb25maWcsXG5cdFx0XHRcdGxhenk6IGFyZ3VtZW50c1sxXVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IG1lLm9wdGlvbnMuYW5pbWF0aW9uO1xuXHRcdHZhciBkdXJhdGlvbiA9IHZhbHVlT3JEZWZhdWx0JDgoY29uZmlnLmR1cmF0aW9uLCBhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMuZHVyYXRpb24pO1xuXHRcdHZhciBsYXp5ID0gY29uZmlnLmxhenk7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZVJlbmRlcicpID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvbkNvbXBsZXRlID0gZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJSZW5kZXInKTtcblx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2FuaW1hdGlvbl0sIG1lKTtcblx0XHR9O1xuXG5cdFx0aWYgKGFuaW1hdGlvbk9wdGlvbnMgJiYgZHVyYXRpb24pIHtcblx0XHRcdHZhciBhbmltYXRpb24gPSBuZXcgY29yZV9hbmltYXRpb24oe1xuXHRcdFx0XHRudW1TdGVwczogZHVyYXRpb24gLyAxNi42NiwgLy8gNjAgZnBzXG5cdFx0XHRcdGVhc2luZzogY29uZmlnLmVhc2luZyB8fCBhbmltYXRpb25PcHRpb25zLmVhc2luZyxcblxuXHRcdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKGNoYXJ0LCBhbmltYXRpb25PYmplY3QpIHtcblx0XHRcdFx0XHR2YXIgZWFzaW5nRnVuY3Rpb24gPSBoZWxwZXJzJDEuZWFzaW5nLmVmZmVjdHNbYW5pbWF0aW9uT2JqZWN0LmVhc2luZ107XG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRTdGVwID0gYW5pbWF0aW9uT2JqZWN0LmN1cnJlbnRTdGVwO1xuXHRcdFx0XHRcdHZhciBzdGVwRGVjaW1hbCA9IGN1cnJlbnRTdGVwIC8gYW5pbWF0aW9uT2JqZWN0Lm51bVN0ZXBzO1xuXG5cdFx0XHRcdFx0Y2hhcnQuZHJhdyhlYXNpbmdGdW5jdGlvbihzdGVwRGVjaW1hbCksIHN0ZXBEZWNpbWFsLCBjdXJyZW50U3RlcCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0b25BbmltYXRpb25Qcm9ncmVzczogYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLFxuXHRcdFx0XHRvbkFuaW1hdGlvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG5cdFx0XHR9KTtcblxuXHRcdFx0Y29yZV9hbmltYXRpb25zLmFkZEFuaW1hdGlvbihtZSwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgbGF6eSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmRyYXcoKTtcblxuXHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNzgxXG5cdFx0XHRvbkNvbXBsZXRlKG5ldyBjb3JlX2FuaW1hdGlvbih7bnVtU3RlcHM6IDAsIGNoYXJ0OiBtZX0pKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0bWUuY2xlYXIoKTtcblxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihlYXNpbmdWYWx1ZSkpIHtcblx0XHRcdGVhc2luZ1ZhbHVlID0gMTtcblx0XHR9XG5cblx0XHRtZS50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblxuXHRcdGlmIChtZS53aWR0aCA8PSAwIHx8IG1lLmhlaWdodCA8PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEcmF3JywgW2Vhc2luZ1ZhbHVlXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRHJhdyBhbGwgdGhlIHNjYWxlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdGJveC5kcmF3KG1lLmNoYXJ0QXJlYSk7XG5cdFx0fSwgbWUpO1xuXG5cdFx0bWUuZHJhd0RhdGFzZXRzKGVhc2luZ1ZhbHVlKTtcblx0XHRtZS5fZHJhd1Rvb2x0aXAoZWFzaW5nVmFsdWUpO1xuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRHJhdycsIFtlYXNpbmdWYWx1ZV0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSAobWUuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAobWUuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRtZS5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLnRvb2x0aXAudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXdzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNEcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c0RyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZHJhd0RhdGFzZXRzOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRzRHJhdycsIFtlYXNpbmdWYWx1ZV0pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERyYXcgZGF0YXNldHMgcmV2ZXJzZWQgdG8gc3VwcG9ydCBwcm9wZXIgbGluZSBzdGFja2luZ1xuXHRcdGZvciAodmFyIGkgPSAobWUuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0XHRcdGlmIChtZS5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdG1lLmRyYXdEYXRhc2V0KGksIGVhc2luZ1ZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKTtcblx0fSxcblxuXHQvKipcblx0ICogRHJhd3MgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldERyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXREcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRyYXdEYXRhc2V0OiBmdW5jdGlvbihpbmRleCwgZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXHRcdHZhciBhcmdzID0ge1xuXHRcdFx0bWV0YTogbWV0YSxcblx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdGVhc2luZ1ZhbHVlOiBlYXNpbmdWYWx1ZVxuXHRcdH07XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXREcmF3JywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRtZXRhLmNvbnRyb2xsZXIuZHJhdyhlYXNpbmdWYWx1ZSk7XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0RHJhdycsIFthcmdzXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXdzIHRvb2x0aXAgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZVRvb2x0aXBEcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJUb29sdGlwRHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZHJhd1Rvb2x0aXA6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdG9vbHRpcCA9IG1lLnRvb2x0aXA7XG5cdFx0dmFyIGFyZ3MgPSB7XG5cdFx0XHR0b29sdGlwOiB0b29sdGlwLFxuXHRcdFx0ZWFzaW5nVmFsdWU6IGVhc2luZ1ZhbHVlXG5cdFx0fTtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlVG9vbHRpcERyYXcnLCBbYXJnc10pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRvb2x0aXAuZHJhdygpO1xuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVG9vbHRpcERyYXcnLCBbYXJnc10pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNpbmdsZSBlbGVtZW50IHRoYXQgd2FzIGNsaWNrZWQgb25cblx0ICogQHJldHVybiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YXNldCBpbmRleCBhbmQgZWxlbWVudCBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgZWxlbWVudC4gQWxzbyBjb250YWlucyB0aGUgcmVjdGFuZ2xlIHRoYXQgd2FzIGRyYXdcblx0ICovXG5cdGdldEVsZW1lbnRBdEV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMuc2luZ2xlKHRoaXMsIGUpO1xuXHR9LFxuXG5cdGdldEVsZW1lbnRzQXRFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLmxhYmVsKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0fSxcblxuXHRnZXRFbGVtZW50c0F0WEF4aXM6IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlc1sneC1heGlzJ10odGhpcywgZSwge2ludGVyc2VjdDogdHJ1ZX0pO1xuXHR9LFxuXG5cdGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGU6IGZ1bmN0aW9uKGUsIG1vZGUsIG9wdGlvbnMpIHtcblx0XHR2YXIgbWV0aG9kID0gY29yZV9pbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcblx0XHRpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gW107XG5cdH0sXG5cblx0Z2V0RGF0YXNldEF0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlcy5kYXRhc2V0KHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0fSxcblxuXHRnZXREYXRhc2V0TWV0YTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgZGF0YXNldCA9IG1lLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcblx0XHRpZiAoIWRhdGFzZXQuX21ldGEpIHtcblx0XHRcdGRhdGFzZXQuX21ldGEgPSB7fTtcblx0XHR9XG5cblx0XHR2YXIgbWV0YSA9IGRhdGFzZXQuX21ldGFbbWUuaWRdO1xuXHRcdGlmICghbWV0YSkge1xuXHRcdFx0bWV0YSA9IGRhdGFzZXQuX21ldGFbbWUuaWRdID0ge1xuXHRcdFx0XHR0eXBlOiBudWxsLFxuXHRcdFx0XHRkYXRhOiBbXSxcblx0XHRcdFx0ZGF0YXNldDogbnVsbCxcblx0XHRcdFx0Y29udHJvbGxlcjogbnVsbCxcblx0XHRcdFx0aGlkZGVuOiBudWxsLFx0XHRcdC8vIFNlZSBpc0RhdGFzZXRWaXNpYmxlKCkgY29tbWVudFxuXHRcdFx0XHR4QXhpc0lEOiBudWxsLFxuXHRcdFx0XHR5QXhpc0lEOiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBtZXRhO1xuXHR9LFxuXG5cdGdldFZpc2libGVEYXRhc2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb3VudCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAodGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjb3VudDtcblx0fSxcblxuXHRpc0RhdGFzZXRWaXNpYmxlOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuXHRcdC8vIG1ldGEuaGlkZGVuIGlzIGEgcGVyIGNoYXJ0IGRhdGFzZXQgaGlkZGVuIGZsYWcgb3ZlcnJpZGUgd2l0aCAzIHN0YXRlczogaWYgdHJ1ZSBvciBmYWxzZSxcblx0XHQvLyB0aGUgZGF0YXNldC5oaWRkZW4gdmFsdWUgaXMgaWdub3JlZCwgZWxzZSBpZiBudWxsLCB0aGUgZGF0YXNldCBoaWRkZW4gc3RhdGUgaXMgcmV0dXJuZWQuXG5cdFx0cmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIXRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmhpZGRlbjtcblx0fSxcblxuXHRnZW5lcmF0ZUxlZ2VuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5sZWdlbmRDYWxsYmFjayh0aGlzKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRlc3Ryb3lEYXRhc2V0TWV0YTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIGlkID0gdGhpcy5pZDtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuXHRcdHZhciBtZXRhID0gZGF0YXNldC5fbWV0YSAmJiBkYXRhc2V0Ll9tZXRhW2lkXTtcblxuXHRcdGlmIChtZXRhKSB7XG5cdFx0XHRtZXRhLmNvbnRyb2xsZXIuZGVzdHJveSgpO1xuXHRcdFx0ZGVsZXRlIGRhdGFzZXQuX21ldGFbaWRdO1xuXHRcdH1cblx0fSxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjYW52YXMgPSBtZS5jYW52YXM7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRtZS5zdG9wKCk7XG5cblx0XHQvLyBkYXRhc2V0IGNvbnRyb2xsZXJzIG5lZWQgdG8gY2xlYW51cCBhc3NvY2lhdGVkIGRhdGFcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLmRlc3Ryb3lEYXRhc2V0TWV0YShpKTtcblx0XHR9XG5cblx0XHRpZiAoY2FudmFzKSB7XG5cdFx0XHRtZS51bmJpbmRFdmVudHMoKTtcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMuY2xlYXIobWUpO1xuXHRcdFx0cGxhdGZvcm0ucmVsZWFzZUNvbnRleHQobWUuY3R4KTtcblx0XHRcdG1lLmNhbnZhcyA9IG51bGw7XG5cdFx0XHRtZS5jdHggPSBudWxsO1xuXHRcdH1cblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdkZXN0cm95Jyk7XG5cblx0XHRkZWxldGUgQ2hhcnQuaW5zdGFuY2VzW21lLmlkXTtcblx0fSxcblxuXHR0b0Jhc2U2NEltYWdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdGluaXRUb29sVGlwOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLnRvb2x0aXAgPSBuZXcgY29yZV90b29sdGlwKHtcblx0XHRcdF9jaGFydDogbWUsXG5cdFx0XHRfY2hhcnRJbnN0YW5jZTogbWUsIC8vIGRlcHJlY2F0ZWQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRcdF9kYXRhOiBtZS5kYXRhLFxuXHRcdFx0X29wdGlvbnM6IG1lLm9wdGlvbnMudG9vbHRpcHNcblx0XHR9LCBtZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRiaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsaXN0ZW5lcnMgPSBtZS5fbGlzdGVuZXJzID0ge307XG5cdFx0dmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRtZS5ldmVudEhhbmRsZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLm9wdGlvbnMuZXZlbnRzLCBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKG1lLCB0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcblx0XHR9KTtcblxuXHRcdC8vIEVsZW1lbnRzIHVzZWQgdG8gZGV0ZWN0IHNpemUgY2hhbmdlIHNob3VsZCBub3QgYmUgaW5qZWN0ZWQgZm9yIG5vbiByZXNwb25zaXZlIGNoYXJ0cy5cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIyMTBcblx0XHRpZiAobWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XG5cdFx0XHRsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtZS5yZXNpemUoKTtcblx0XHRcdH07XG5cblx0XHRcdHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIobWUsICdyZXNpemUnLCBsaXN0ZW5lcik7XG5cdFx0XHRsaXN0ZW5lcnMucmVzaXplID0gbGlzdGVuZXI7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dW5iaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsaXN0ZW5lcnMgPSBtZS5fbGlzdGVuZXJzO1xuXHRcdGlmICghbGlzdGVuZXJzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIG1lLl9saXN0ZW5lcnM7XG5cdFx0aGVscGVycyQxLmVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lciwgdHlwZSkge1xuXHRcdFx0cGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHVwZGF0ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnRzLCBtb2RlLCBlbmFibGVkKSB7XG5cdFx0dmFyIG1ldGhvZCA9IGVuYWJsZWQgPyAnc2V0SG92ZXJTdHlsZScgOiAncmVtb3ZlSG92ZXJTdHlsZSc7XG5cdFx0dmFyIGVsZW1lbnQsIGksIGlsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRlbGVtZW50ID0gZWxlbWVudHNbaV07XG5cdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmdldERhdGFzZXRNZXRhKGVsZW1lbnQuX2RhdGFzZXRJbmRleCkuY29udHJvbGxlclttZXRob2RdKGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGV2ZW50SGFuZGxlcjogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRvb2x0aXAgPSBtZS50b29sdGlwO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVFdmVudCcsIFtlXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQnVmZmVyIGFueSB1cGRhdGUgY2FsbHMgc28gdGhhdCByZW5kZXJzIGRvIG5vdCBvY2N1clxuXHRcdG1lLl9idWZmZXJlZFJlbmRlciA9IHRydWU7XG5cdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cblx0XHR2YXIgY2hhbmdlZCA9IG1lLmhhbmRsZUV2ZW50KGUpO1xuXHRcdC8vIGZvciBzbW9vdGggdG9vbHRpcCBhbmltYXRpb25zIGlzc3VlICM0OTg5XG5cdFx0Ly8gdGhlIHRvb2x0aXAgc2hvdWxkIGJlIHRoZSBzb3VyY2Ugb2YgY2hhbmdlXG5cdFx0Ly8gQW5pbWF0aW9uIGNoZWNrIHdvcmthcm91bmQ6XG5cdFx0Ly8gdG9vbHRpcC5fc3RhcnQgd2lsbCBiZSBudWxsIHdoZW4gdG9vbHRpcCBpc24ndCBhbmltYXRpbmdcblx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0Y2hhbmdlZCA9IHRvb2x0aXAuX3N0YXJ0XG5cdFx0XHRcdD8gdG9vbHRpcC5oYW5kbGVFdmVudChlKVxuXHRcdFx0XHQ6IGNoYW5nZWQgfCB0b29sdGlwLmhhbmRsZUV2ZW50KGUpO1xuXHRcdH1cblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckV2ZW50JywgW2VdKTtcblxuXHRcdHZhciBidWZmZXJlZFJlcXVlc3QgPSBtZS5fYnVmZmVyZWRSZXF1ZXN0O1xuXHRcdGlmIChidWZmZXJlZFJlcXVlc3QpIHtcblx0XHRcdC8vIElmIHdlIGhhdmUgYW4gdXBkYXRlIHRoYXQgd2FzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBkbyBhIG5vcm1hbCByZW5kZXJcblx0XHRcdG1lLnJlbmRlcihidWZmZXJlZFJlcXVlc3QpO1xuXHRcdH0gZWxzZSBpZiAoY2hhbmdlZCAmJiAhbWUuYW5pbWF0aW5nKSB7XG5cdFx0XHQvLyBJZiBlbnRlcmluZywgbGVhdmluZywgb3IgY2hhbmdpbmcgZWxlbWVudHMsIGFuaW1hdGUgdGhlIGNoYW5nZSB2aWEgcGl2b3Rcblx0XHRcdG1lLnN0b3AoKTtcblxuXHRcdFx0Ly8gV2Ugb25seSBuZWVkIHRvIHJlbmRlciBhdCB0aGlzIHBvaW50LiBVcGRhdGluZyB3aWxsIGNhdXNlIHNjYWxlcyB0byBiZVxuXHRcdFx0Ly8gcmVjb21wdXRlZCBnZW5lcmF0aW5nIGZsaWNrZXIgJiB1c2luZyBtb3JlIG1lbW9yeSB0aGFuIG5lY2Vzc2FyeS5cblx0XHRcdG1lLnJlbmRlcih7XG5cdFx0XHRcdGR1cmF0aW9uOiBtZS5vcHRpb25zLmhvdmVyLmFuaW1hdGlvbkR1cmF0aW9uLFxuXHRcdFx0XHRsYXp5OiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSBmYWxzZTtcblx0XHRtZS5fYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdHJldHVybiBtZTtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCB0aGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNoYXJ0IG5lZWRzIHRvIHJlLXJlbmRlclxuXHQgKi9cblx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucyB8fCB7fTtcblx0XHR2YXIgaG92ZXJPcHRpb25zID0gb3B0aW9ucy5ob3Zlcjtcblx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0bWUubGFzdEFjdGl2ZSA9IG1lLmxhc3RBY3RpdmUgfHwgW107XG5cblx0XHQvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgaG92ZXIgYW5kIHRvb2x0aXBzXG5cdFx0aWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuXHRcdFx0bWUuYWN0aXZlID0gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmFjdGl2ZSA9IG1lLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgaG92ZXJPcHRpb25zLm1vZGUsIGhvdmVyT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Ly8gSW52b2tlIG9uSG92ZXIgaG9va1xuXHRcdC8vIE5lZWQgdG8gY2FsbCB3aXRoIG5hdGl2ZSBldmVudCBoZXJlIHRvIG5vdCBicmVhayBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayhvcHRpb25zLm9uSG92ZXIgfHwgb3B0aW9ucy5ob3Zlci5vbkhvdmVyLCBbZS5uYXRpdmUsIG1lLmFjdGl2ZV0sIG1lKTtcblxuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdGlmIChvcHRpb25zLm9uQ2xpY2spIHtcblx0XHRcdFx0Ly8gVXNlIGUubmF0aXZlIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdGlvbnMub25DbGljay5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUuYWN0aXZlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgc3R5bGluZyBmb3IgbGFzdCBhY3RpdmUgKGV2ZW4gaWYgaXQgbWF5IHN0aWxsIGJlIGFjdGl2ZSlcblx0XHRpZiAobWUubGFzdEFjdGl2ZS5sZW5ndGgpIHtcblx0XHRcdG1lLnVwZGF0ZUhvdmVyU3R5bGUobWUubGFzdEFjdGl2ZSwgaG92ZXJPcHRpb25zLm1vZGUsIGZhbHNlKTtcblx0XHR9XG5cblx0XHQvLyBCdWlsdCBpbiBob3ZlciBzdHlsaW5nXG5cdFx0aWYgKG1lLmFjdGl2ZS5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcblx0XHRcdG1lLnVwZGF0ZUhvdmVyU3R5bGUobWUuYWN0aXZlLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Y2hhbmdlZCA9ICFoZWxwZXJzJDEuYXJyYXlFcXVhbHMobWUuYWN0aXZlLCBtZS5sYXN0QWN0aXZlKTtcblxuXHRcdC8vIFJlbWVtYmVyIExhc3QgQWN0aXZlc1xuXHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5hY3RpdmU7XG5cblx0XHRyZXR1cm4gY2hhbmdlZDtcblx0fVxufSk7XG5cbi8qKlxuICogTk9URShTQikgV2UgYWN0dWFsbHkgZG9uJ3QgdXNlIHRoaXMgY29udGFpbmVyIGFueW1vcmUgYnV0IHdlIG5lZWQgdG8ga2VlcCBpdFxuICogZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIFRob3VnaCwgaXQgY2FuIHN0aWxsIGJlIHVzZWZ1bCBmb3IgcGx1Z2lucyB0aGF0XG4gKiB3b3VsZCBuZWVkIHRvIHdvcmsgb24gbXVsdGlwbGUgY2hhcnRzPyFcbiAqL1xuQ2hhcnQuaW5zdGFuY2VzID0ge307XG5cbnZhciBjb3JlX2NvbnRyb2xsZXIgPSBDaGFydDtcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydCBpbnN0ZWFkLlxuICogQGNsYXNzIENoYXJ0LkNvbnRyb2xsZXJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5DaGFydC5Db250cm9sbGVyID0gQ2hhcnQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZS5cbiAqIEBuYW1lc3BhY2UgQ2hhcnRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5DaGFydC50eXBlcyA9IHt9O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuY29uZmlnTWVyZ2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5jb25maWdNZXJnZSA9IG1lcmdlQ29uZmlnO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuc2NhbGVNZXJnZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycyQxLnNjYWxlTWVyZ2UgPSBtZXJnZVNjYWxlQ29uZmlnO1xuXG52YXIgY29yZV9oZWxwZXJzID0gZnVuY3Rpb24oKSB7XG5cblx0Ly8gLS0gQmFzaWMganMgdXRpbGl0eSBtZXRob2RzXG5cblx0aGVscGVycyQxLndoZXJlID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgZmlsdGVyQ2FsbGJhY2spIHtcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkoY29sbGVjdGlvbikgJiYgQXJyYXkucHJvdG90eXBlLmZpbHRlcikge1xuXHRcdFx0cmV0dXJuIGNvbGxlY3Rpb24uZmlsdGVyKGZpbHRlckNhbGxiYWNrKTtcblx0XHR9XG5cdFx0dmFyIGZpbHRlcmVkID0gW107XG5cblx0XHRoZWxwZXJzJDEuZWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoZmlsdGVyQ2FsbGJhY2soaXRlbSkpIHtcblx0XHRcdFx0ZmlsdGVyZWQucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBmaWx0ZXJlZDtcblx0fTtcblx0aGVscGVycyQxLmZpbmRJbmRleCA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXggP1xuXHRcdGZ1bmN0aW9uKGFycmF5LCBjYWxsYmFjaywgc2NvcGUpIHtcblx0XHRcdHJldHVybiBhcnJheS5maW5kSW5kZXgoY2FsbGJhY2ssIHNjb3BlKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG5cdFx0XHRzY29wZSA9IHNjb3BlID09PSB1bmRlZmluZWQgPyBhcnJheSA6IHNjb3BlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0aWYgKGNhbGxiYWNrLmNhbGwoc2NvcGUsIGFycmF5W2ldLCBpLCBhcnJheSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH07XG5cdGhlbHBlcnMkMS5maW5kTmV4dFdoZXJlID0gZnVuY3Rpb24oYXJyYXlUb1NlYXJjaCwgZmlsdGVyQ2FsbGJhY2ssIHN0YXJ0SW5kZXgpIHtcblx0XHQvLyBEZWZhdWx0IHRvIHN0YXJ0IG9mIHRoZSBhcnJheVxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzdGFydEluZGV4KSkge1xuXHRcdFx0c3RhcnRJbmRleCA9IC0xO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gc3RhcnRJbmRleCArIDE7IGkgPCBhcnJheVRvU2VhcmNoLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY3VycmVudEl0ZW0gPSBhcnJheVRvU2VhcmNoW2ldO1xuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGN1cnJlbnRJdGVtKSkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudEl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRoZWxwZXJzJDEuZmluZFByZXZpb3VzV2hlcmUgPSBmdW5jdGlvbihhcnJheVRvU2VhcmNoLCBmaWx0ZXJDYWxsYmFjaywgc3RhcnRJbmRleCkge1xuXHRcdC8vIERlZmF1bHQgdG8gZW5kIG9mIHRoZSBhcnJheVxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzdGFydEluZGV4KSkge1xuXHRcdFx0c3RhcnRJbmRleCA9IGFycmF5VG9TZWFyY2gubGVuZ3RoO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gc3RhcnRJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgY3VycmVudEl0ZW0gPSBhcnJheVRvU2VhcmNoW2ldO1xuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGN1cnJlbnRJdGVtKSkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudEl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIC0tIE1hdGggbWV0aG9kc1xuXHRoZWxwZXJzJDEuaXNOdW1iZXIgPSBmdW5jdGlvbihuKSB7XG5cdFx0cmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcblx0fTtcblx0aGVscGVycyQxLmFsbW9zdEVxdWFscyA9IGZ1bmN0aW9uKHgsIHksIGVwc2lsb24pIHtcblx0XHRyZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgZXBzaWxvbjtcblx0fTtcblx0aGVscGVycyQxLmFsbW9zdFdob2xlID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xuXHRcdHZhciByb3VuZGVkID0gTWF0aC5yb3VuZCh4KTtcblx0XHRyZXR1cm4gKCgocm91bmRlZCAtIGVwc2lsb24pIDwgeCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPiB4KSk7XG5cdH07XG5cdGhlbHBlcnMkMS5tYXggPSBmdW5jdGlvbihhcnJheSkge1xuXHRcdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24obWF4LCB2YWx1ZSkge1xuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KG1heCwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1heDtcblx0XHR9LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuXHR9O1xuXHRoZWxwZXJzJDEubWluID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKG1pbiwgdmFsdWUpIHtcblx0XHRcdGlmICghaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLm1pbihtaW4sIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtaW47XG5cdFx0fSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcblx0fTtcblx0aGVscGVycyQxLnNpZ24gPSBNYXRoLnNpZ24gP1xuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiBNYXRoLnNpZ24oeCk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0eCA9ICt4OyAvLyBjb252ZXJ0IHRvIGEgbnVtYmVyXG5cdFx0XHRpZiAoeCA9PT0gMCB8fCBpc05hTih4KSkge1xuXHRcdFx0XHRyZXR1cm4geDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB4ID4gMCA/IDEgOiAtMTtcblx0XHR9O1xuXHRoZWxwZXJzJDEubG9nMTAgPSBNYXRoLmxvZzEwID9cblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5sb2cxMCh4KTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHR2YXIgZXhwb25lbnQgPSBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFOyAvLyBNYXRoLkxPRzEwRSA9IDEgLyBNYXRoLkxOMTAuXG5cdFx0XHQvLyBDaGVjayBmb3Igd2hvbGUgcG93ZXJzIG9mIDEwLFxuXHRcdFx0Ly8gd2hpY2ggZHVlIHRvIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9yIHNob3VsZCBiZSBjb3JyZWN0ZWQuXG5cdFx0XHR2YXIgcG93ZXJPZjEwID0gTWF0aC5yb3VuZChleHBvbmVudCk7XG5cdFx0XHR2YXIgaXNQb3dlck9mMTAgPSB4ID09PSBNYXRoLnBvdygxMCwgcG93ZXJPZjEwKTtcblxuXHRcdFx0cmV0dXJuIGlzUG93ZXJPZjEwID8gcG93ZXJPZjEwIDogZXhwb25lbnQ7XG5cdFx0fTtcblx0aGVscGVycyQxLnRvUmFkaWFucyA9IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcblx0XHRyZXR1cm4gZGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcblx0fTtcblx0aGVscGVycyQxLnRvRGVncmVlcyA9IGZ1bmN0aW9uKHJhZGlhbnMpIHtcblx0XHRyZXR1cm4gcmFkaWFucyAqICgxODAgLyBNYXRoLlBJKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG5cdCAqIGkuZS4gdGhlIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIE51bWJlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBBIG51bWJlci5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhlbHBlcnMkMS5fZGVjaW1hbFBsYWNlcyA9IGZ1bmN0aW9uKHgpIHtcblx0XHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh4KSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgZSA9IDE7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcblx0XHRcdGUgKj0gMTA7XG5cdFx0XHRwKys7XG5cdFx0fVxuXHRcdHJldHVybiBwO1xuXHR9O1xuXG5cdC8vIEdldHMgdGhlIGFuZ2xlIGZyb20gdmVydGljYWwgdXByaWdodCB0byB0aGUgcG9pbnQgYWJvdXQgYSBjZW50cmUuXG5cdGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCA9IGZ1bmN0aW9uKGNlbnRyZVBvaW50LCBhbmdsZVBvaW50KSB7XG5cdFx0dmFyIGRpc3RhbmNlRnJvbVhDZW50ZXIgPSBhbmdsZVBvaW50LnggLSBjZW50cmVQb2ludC54O1xuXHRcdHZhciBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcblx0XHR2YXIgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuXG5cdFx0dmFyIGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcblxuXHRcdGlmIChhbmdsZSA8ICgtMC41ICogTWF0aC5QSSkpIHtcblx0XHRcdGFuZ2xlICs9IDIuMCAqIE1hdGguUEk7IC8vIG1ha2Ugc3VyZSB0aGUgcmV0dXJuZWQgYW5nbGUgaXMgaW4gdGhlIHJhbmdlIG9mICgtUEkvMiwgM1BJLzJdXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFuZ2xlOiBhbmdsZSxcblx0XHRcdGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcblx0XHR9O1xuXHR9O1xuXHRoZWxwZXJzJDEuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzID0gZnVuY3Rpb24ocHQxLCBwdDIpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHB0Mi54IC0gcHQxLngsIDIpICsgTWF0aC5wb3cocHQyLnkgLSBwdDEueSwgMikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXG5cdCAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmFsaWFzUGl4ZWxcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqL1xuXHRoZWxwZXJzJDEuYWxpYXNQaXhlbCA9IGZ1bmN0aW9uKHBpeGVsV2lkdGgpIHtcblx0XHRyZXR1cm4gKHBpeGVsV2lkdGggJSAyID09PSAwKSA/IDAgOiAwLjU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUgdG8gYXZvaWQgYW50aS1hbGlhc2luZyBibHVyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWwgLSBBIHBpeGVsIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGVsZW1lbnQuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aGVscGVycyQxLl9hbGlnblBpeGVsID0gZnVuY3Rpb24oY2hhcnQsIHBpeGVsLCB3aWR0aCkge1xuXHRcdHZhciBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG5cdFx0dmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xuXHR9O1xuXG5cdGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZSA9IGZ1bmN0aW9uKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG5cdFx0Ly8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXG5cdFx0Ly8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG5cblx0XHQvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYWxzbyByZXNwZWN0IFwic2tpcHBlZFwiIHBvaW50c1xuXG5cdFx0dmFyIHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xuXHRcdHZhciBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG5cdFx0dmFyIG5leHQgPSBhZnRlclBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGFmdGVyUG9pbnQ7XG5cblx0XHR2YXIgZDAxID0gTWF0aC5zcXJ0KE1hdGgucG93KGN1cnJlbnQueCAtIHByZXZpb3VzLngsIDIpICsgTWF0aC5wb3coY3VycmVudC55IC0gcHJldmlvdXMueSwgMikpO1xuXHRcdHZhciBkMTIgPSBNYXRoLnNxcnQoTWF0aC5wb3cobmV4dC54IC0gY3VycmVudC54LCAyKSArIE1hdGgucG93KG5leHQueSAtIGN1cnJlbnQueSwgMikpO1xuXG5cdFx0dmFyIHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuXHRcdHZhciBzMTIgPSBkMTIgLyAoZDAxICsgZDEyKTtcblxuXHRcdC8vIElmIGFsbCBwb2ludHMgYXJlIHRoZSBzYW1lLCBzMDEgJiBzMDIgd2lsbCBiZSBpbmZcblx0XHRzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcblx0XHRzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcblxuXHRcdHZhciBmYSA9IHQgKiBzMDE7IC8vIHNjYWxpbmcgZmFjdG9yIGZvciB0cmlhbmdsZSBUYVxuXHRcdHZhciBmYiA9IHQgKiBzMTI7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0cHJldmlvdXM6IHtcblx0XHRcdFx0eDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG5cdFx0XHRcdHk6IGN1cnJlbnQueSAtIGZhICogKG5leHQueSAtIHByZXZpb3VzLnkpXG5cdFx0XHR9LFxuXHRcdFx0bmV4dDoge1xuXHRcdFx0XHR4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcblx0XHRcdFx0eTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXHRoZWxwZXJzJDEuRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXHRoZWxwZXJzJDEuc3BsaW5lQ3VydmVNb25vdG9uZSA9IGZ1bmN0aW9uKHBvaW50cykge1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxuXHRcdC8vIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcblx0XHQvLyBiZXR3ZWVuIHRoZSBkYXRhc2V0IGRpc2NyZXRlIHBvaW50cyBkdWUgdG8gdGhlIGludGVycG9sYXRpb24uXG5cdFx0Ly8gU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxuXG5cdFx0dmFyIHBvaW50c1dpdGhUYW5nZW50cyA9IChwb2ludHMgfHwgW10pLm1hcChmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bW9kZWw6IHBvaW50Ll9tb2RlbCxcblx0XHRcdFx0ZGVsdGFLOiAwLFxuXHRcdFx0XHRtSzogMFxuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuXHRcdHZhciBwb2ludHNMZW4gPSBwb2ludHNXaXRoVGFuZ2VudHMubGVuZ3RoO1xuXHRcdHZhciBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50LCBwb2ludEFmdGVyO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuXHRcdFx0cG9pbnRDdXJyZW50ID0gcG9pbnRzV2l0aFRhbmdlbnRzW2ldO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRwb2ludEJlZm9yZSA9IGkgPiAwID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgLSAxXSA6IG51bGw7XG5cdFx0XHRwb2ludEFmdGVyID0gaSA8IHBvaW50c0xlbiAtIDEgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdIDogbnVsbDtcblx0XHRcdGlmIChwb2ludEFmdGVyICYmICFwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0dmFyIHNsb3BlRGVsdGFYID0gKHBvaW50QWZ0ZXIubW9kZWwueCAtIHBvaW50Q3VycmVudC5tb2RlbC54KTtcblxuXHRcdFx0XHQvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcblx0XHRcdFx0cG9pbnRDdXJyZW50LmRlbHRhSyA9IHNsb3BlRGVsdGFYICE9PSAwID8gKHBvaW50QWZ0ZXIubW9kZWwueSAtIHBvaW50Q3VycmVudC5tb2RlbC55KSAvIHNsb3BlRGVsdGFYIDogMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFwb2ludEJlZm9yZSB8fCBwb2ludEJlZm9yZS5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHR9IGVsc2UgaWYgKCFwb2ludEFmdGVyIHx8IHBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEJlZm9yZS5kZWx0YUs7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuc2lnbihwb2ludEJlZm9yZS5kZWx0YUspICE9PSB0aGlzLnNpZ24ocG9pbnRDdXJyZW50LmRlbHRhSykpIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IChwb2ludEJlZm9yZS5kZWx0YUsgKyBwb2ludEN1cnJlbnQuZGVsdGFLKSAvIDI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xuXHRcdHZhciBhbHBoYUssIGJldGFLLCB0YXVLLCBzcXVhcmVkTWFnbml0dWRlO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdHBvaW50QWZ0ZXIgPSBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwIHx8IHBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhlbHBlcnMkMS5hbG1vc3RFcXVhbHMocG9pbnRDdXJyZW50LmRlbHRhSywgMCwgdGhpcy5FUFNJTE9OKSkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEFmdGVyLm1LID0gMDtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGFscGhhSyA9IHBvaW50Q3VycmVudC5tSyAvIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHRiZXRhSyA9IHBvaW50QWZ0ZXIubUsgLyBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0c3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XG5cdFx0XHRpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcblx0XHRcdHBvaW50Q3VycmVudC5tSyA9IGFscGhhSyAqIHRhdUsgKiBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0cG9pbnRBZnRlci5tSyA9IGJldGFLICogdGF1SyAqIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZSBjb250cm9sIHBvaW50c1xuXHRcdHZhciBkZWx0YVg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XG5cdFx0XHRpZiAocG9pbnRDdXJyZW50Lm1vZGVsLnNraXApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHBvaW50QmVmb3JlID0gaSA+IDAgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSAtIDFdIDogbnVsbDtcblx0XHRcdHBvaW50QWZ0ZXIgPSBpIDwgcG9pbnRzTGVuIC0gMSA/IHBvaW50c1dpdGhUYW5nZW50c1tpICsgMV0gOiBudWxsO1xuXHRcdFx0aWYgKHBvaW50QmVmb3JlICYmICFwb2ludEJlZm9yZS5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGRlbHRhWCA9IChwb2ludEN1cnJlbnQubW9kZWwueCAtIHBvaW50QmVmb3JlLm1vZGVsLngpIC8gMztcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IHBvaW50Q3VycmVudC5tb2RlbC54IC0gZGVsdGFYO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gcG9pbnRDdXJyZW50Lm1vZGVsLnkgLSBkZWx0YVggKiBwb2ludEN1cnJlbnQubUs7XG5cdFx0XHR9XG5cdFx0XHRpZiAocG9pbnRBZnRlciAmJiAhcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGRlbHRhWCA9IChwb2ludEFmdGVyLm1vZGVsLnggLSBwb2ludEN1cnJlbnQubW9kZWwueCkgLyAzO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBwb2ludEN1cnJlbnQubW9kZWwueCArIGRlbHRhWDtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gcG9pbnRDdXJyZW50Lm1vZGVsLnkgKyBkZWx0YVggKiBwb2ludEN1cnJlbnQubUs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRoZWxwZXJzJDEubmV4dEl0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xuXHRcdGlmIChsb29wKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPj0gY29sbGVjdGlvbi5sZW5ndGggLSAxID8gY29sbGVjdGlvblswXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcblx0fTtcblx0aGVscGVycyQxLnByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGluZGV4LCBsb29wKSB7XG5cdFx0aWYgKGxvb3ApIHtcblx0XHRcdHJldHVybiBpbmRleCA8PSAwID8gY29sbGVjdGlvbltjb2xsZWN0aW9uLmxlbmd0aCAtIDFdIDogY29sbGVjdGlvbltpbmRleCAtIDFdO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bMF0gOiBjb2xsZWN0aW9uW2luZGV4IC0gMV07XG5cdH07XG5cdC8vIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXG5cdGhlbHBlcnMkMS5uaWNlTnVtID0gZnVuY3Rpb24ocmFuZ2UsIHJvdW5kKSB7XG5cdFx0dmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAocmFuZ2UpKTtcblx0XHR2YXIgZnJhY3Rpb24gPSByYW5nZSAvIE1hdGgucG93KDEwLCBleHBvbmVudCk7XG5cdFx0dmFyIG5pY2VGcmFjdGlvbjtcblxuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0aWYgKGZyYWN0aW9uIDwgMS41KSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDwgMykge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAyO1xuXHRcdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8IDcpIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gNTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDEwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMS4wKSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAxO1xuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMikge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gMjtcblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDUpIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDEwO1xuXHRcdH1cblxuXHRcdHJldHVybiBuaWNlRnJhY3Rpb24gKiBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuXHR9O1xuXHQvLyBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbCAtIGh0dHBzOi8vd3d3LnBhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cblx0aGVscGVycyQxLnJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHRmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG5cdFx0XHR9O1xuXHR9KCkpO1xuXHQvLyAtLSBET00gbWV0aG9kc1xuXHRoZWxwZXJzJDEuZ2V0UmVsYXRpdmVQb3NpdGlvbiA9IGZ1bmN0aW9uKGV2dCwgY2hhcnQpIHtcblx0XHR2YXIgbW91c2VYLCBtb3VzZVk7XG5cdFx0dmFyIGUgPSBldnQub3JpZ2luYWxFdmVudCB8fCBldnQ7XG5cdFx0dmFyIGNhbnZhcyA9IGV2dC50YXJnZXQgfHwgZXZ0LnNyY0VsZW1lbnQ7XG5cdFx0dmFyIGJvdW5kaW5nUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdHZhciB0b3VjaGVzID0gZS50b3VjaGVzO1xuXHRcdGlmICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0bW91c2VYID0gdG91Y2hlc1swXS5jbGllbnRYO1xuXHRcdFx0bW91c2VZID0gdG91Y2hlc1swXS5jbGllbnRZO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1vdXNlWCA9IGUuY2xpZW50WDtcblx0XHRcdG1vdXNlWSA9IGUuY2xpZW50WTtcblx0XHR9XG5cblx0XHQvLyBTY2FsZSBtb3VzZSBjb29yZGluYXRlcyBpbnRvIGNhbnZhcyBjb29yZGluYXRlc1xuXHRcdC8vIGJ5IGZvbGxvd2luZyB0aGUgcGF0dGVybiBsYWlkIG91dCBieSAnamVycnlqJyBpbiB0aGUgY29tbWVudHMgb2Zcblx0XHQvLyBodHRwczovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vYWR2YW5jZWQvaHRtbDUtY2FudmFzLW1vdXNlLWNvb3JkaW5hdGVzL1xuXHRcdHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctbGVmdCcpKTtcblx0XHR2YXIgcGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctdG9wJykpO1xuXHRcdHZhciBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLXJpZ2h0JykpO1xuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1ib3R0b20nKSk7XG5cdFx0dmFyIHdpZHRoID0gYm91bmRpbmdSZWN0LnJpZ2h0IC0gYm91bmRpbmdSZWN0LmxlZnQgLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodDtcblx0XHR2YXIgaGVpZ2h0ID0gYm91bmRpbmdSZWN0LmJvdHRvbSAtIGJvdW5kaW5nUmVjdC50b3AgLSBwYWRkaW5nVG9wIC0gcGFkZGluZ0JvdHRvbTtcblxuXHRcdC8vIFdlIGRpdmlkZSBieSB0aGUgY3VycmVudCBkZXZpY2UgcGl4ZWwgcmF0aW8sIGJlY2F1c2UgdGhlIGNhbnZhcyBpcyBzY2FsZWQgdXAgYnkgdGhhdCBhbW91bnQgaW4gZWFjaCBkaXJlY3Rpb24uIEhvd2V2ZXJcblx0XHQvLyB0aGUgYmFja2VuZCBtb2RlbCBpcyBpbiB1bnNjYWxlZCBjb29yZGluYXRlcy4gU2luY2Ugd2UgYXJlIGdvaW5nIHRvIGRlYWwgd2l0aCBvdXIgbW9kZWwgY29vcmRpbmF0ZXMsIHdlIGdvIGJhY2sgaGVyZVxuXHRcdG1vdXNlWCA9IE1hdGgucm91bmQoKG1vdXNlWCAtIGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFkZGluZ0xlZnQpIC8gKHdpZHRoKSAqIGNhbnZhcy53aWR0aCAvIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKTtcblx0XHRtb3VzZVkgPSBNYXRoLnJvdW5kKChtb3VzZVkgLSBib3VuZGluZ1JlY3QudG9wIC0gcGFkZGluZ1RvcCkgLyAoaGVpZ2h0KSAqIGNhbnZhcy5oZWlnaHQgLyBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogbW91c2VYLFxuXHRcdFx0eTogbW91c2VZXG5cdFx0fTtcblxuXHR9O1xuXG5cdC8vIFByaXZhdGUgaGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgbWF4LXdpZHRoL21heC1oZWlnaHQgdmFsdWVzIHRoYXQgbWF5IGJlIHBlcmNlbnRhZ2VzIGludG8gYSBudW1iZXJcblx0ZnVuY3Rpb24gcGFyc2VNYXhTdHlsZShzdHlsZVZhbHVlLCBub2RlLCBwYXJlbnRQcm9wZXJ0eSkge1xuXHRcdHZhciB2YWx1ZUluUGl4ZWxzO1xuXHRcdGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG5cblx0XHRcdGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcblx0XHRcdFx0Ly8gcGVyY2VudGFnZSAqIHNpemUgaW4gZGltZW5zaW9uXG5cdFx0XHRcdHZhbHVlSW5QaXhlbHMgPSB2YWx1ZUluUGl4ZWxzIC8gMTAwICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlSW5QaXhlbHM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY29udGFpbnMgYW4gZWZmZWN0aXZlIGNvbnN0cmFpbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0NvbnN0cmFpbmVkVmFsdWUodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJ25vbmUnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG1heCB3aWR0aCBvciBoZWlnaHQgb2YgdGhlIGdpdmVuIERPTSBub2RlIGluIGEgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxlIGZhc2hpb25cblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tTm9kZSAtIHRoZSBub2RlIHRvIGNoZWNrIHRoZSBjb25zdHJhaW50IG9uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtYXhTdHlsZSAtIHRoZSBzdHlsZSB0aGF0IGRlZmluZXMgdGhlIG1heGltdW0gZm9yIHRoZSBkaXJlY3Rpb24gd2UgYXJlIHVzaW5nICgnbWF4LXdpZHRoJyAvICdtYXgtaGVpZ2h0Jylcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBlcmNlbnRhZ2VQcm9wZXJ0eSAtIHByb3BlcnR5IG9mIHBhcmVudCB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyB3aWR0aCBhcyBhIHBlcmNlbnRhZ2Vcblx0ICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cubmF0aGFuYWVsam9uZXMuY29tL2Jsb2cvMjAxMy9yZWFkaW5nLW1heC13aWR0aC1jcm9zcy1icm93c2VyfVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCBtYXhTdHlsZSwgcGVyY2VudGFnZVByb3BlcnR5KSB7XG5cdFx0dmFyIHZpZXcgPSBkb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHR2YXIgcGFyZW50Tm9kZSA9IGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZShkb21Ob2RlKTtcblx0XHR2YXIgY29uc3RyYWluZWROb2RlID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpW21heFN0eWxlXTtcblx0XHR2YXIgY29uc3RyYWluZWRDb250YWluZXIgPSB2aWV3LmdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSlbbWF4U3R5bGVdO1xuXHRcdHZhciBoYXNDTm9kZSA9IGlzQ29uc3RyYWluZWRWYWx1ZShjb25zdHJhaW5lZE5vZGUpO1xuXHRcdHZhciBoYXNDQ29udGFpbmVyID0gaXNDb25zdHJhaW5lZFZhbHVlKGNvbnN0cmFpbmVkQ29udGFpbmVyKTtcblx0XHR2YXIgaW5maW5pdHkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cblx0XHRpZiAoaGFzQ05vZGUgfHwgaGFzQ0NvbnRhaW5lcikge1xuXHRcdFx0cmV0dXJuIE1hdGgubWluKFxuXHRcdFx0XHRoYXNDTm9kZSA/IHBhcnNlTWF4U3R5bGUoY29uc3RyYWluZWROb2RlLCBkb21Ob2RlLCBwZXJjZW50YWdlUHJvcGVydHkpIDogaW5maW5pdHksXG5cdFx0XHRcdGhhc0NDb250YWluZXIgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkQ29udGFpbmVyLCBwYXJlbnROb2RlLCBwZXJjZW50YWdlUHJvcGVydHkpIDogaW5maW5pdHkpO1xuXHRcdH1cblxuXHRcdHJldHVybiAnbm9uZSc7XG5cdH1cblx0Ly8gcmV0dXJucyBOdW1iZXIgb3IgdW5kZWZpbmVkIGlmIG5vIGNvbnN0cmFpbnRcblx0aGVscGVycyQxLmdldENvbnN0cmFpbnRXaWR0aCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHRyZXR1cm4gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCAnbWF4LXdpZHRoJywgJ2NsaWVudFdpZHRoJyk7XG5cdH07XG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XG5cdGhlbHBlcnMkMS5nZXRDb25zdHJhaW50SGVpZ2h0ID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHJldHVybiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsICdtYXgtaGVpZ2h0JywgJ2NsaWVudEhlaWdodCcpO1xuXHR9O1xuXHQvKipcblx0ICogQHByaXZhdGVcbiBcdCAqL1xuXHRoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcgPSBmdW5jdGlvbihjb250YWluZXIsIHBhZGRpbmcsIHBhcmVudERpbWVuc2lvbikge1xuXHRcdHBhZGRpbmcgPSBoZWxwZXJzJDEuZ2V0U3R5bGUoY29udGFpbmVyLCBwYWRkaW5nKTtcblxuXHRcdHJldHVybiBwYWRkaW5nLmluZGV4T2YoJyUnKSA+IC0xID8gcGFyZW50RGltZW5zaW9uICogcGFyc2VJbnQocGFkZGluZywgMTApIC8gMTAwIDogcGFyc2VJbnQocGFkZGluZywgMTApO1xuXHR9O1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZSA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXHRcdGlmIChwYXJlbnQgJiYgcGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuXHRcdFx0cGFyZW50ID0gcGFyZW50Lmhvc3Q7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJlbnQ7XG5cdH07XG5cdGhlbHBlcnMkMS5nZXRNYXhpbXVtV2lkdGggPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZShkb21Ob2RlKTtcblx0XHRpZiAoIWNvbnRhaW5lcikge1xuXHRcdFx0cmV0dXJuIGRvbU5vZGUuY2xpZW50V2lkdGg7XG5cdFx0fVxuXG5cdFx0dmFyIGNsaWVudFdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuXHRcdHZhciBwYWRkaW5nTGVmdCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLWxlZnQnLCBjbGllbnRXaWR0aCk7XG5cdFx0dmFyIHBhZGRpbmdSaWdodCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLXJpZ2h0JywgY2xpZW50V2lkdGgpO1xuXG5cdFx0dmFyIHcgPSBjbGllbnRXaWR0aCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xuXHRcdHZhciBjdyA9IGhlbHBlcnMkMS5nZXRDb25zdHJhaW50V2lkdGgoZG9tTm9kZSk7XG5cdFx0cmV0dXJuIGlzTmFOKGN3KSA/IHcgOiBNYXRoLm1pbih3LCBjdyk7XG5cdH07XG5cdGhlbHBlcnMkMS5nZXRNYXhpbXVtSGVpZ2h0ID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHZhciBjb250YWluZXIgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XG5cdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdHJldHVybiBkb21Ob2RlLmNsaWVudEhlaWdodDtcblx0XHR9XG5cblx0XHR2YXIgY2xpZW50SGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcblx0XHR2YXIgcGFkZGluZ1RvcCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLXRvcCcsIGNsaWVudEhlaWdodCk7XG5cdFx0dmFyIHBhZGRpbmdCb3R0b20gPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1ib3R0b20nLCBjbGllbnRIZWlnaHQpO1xuXG5cdFx0dmFyIGggPSBjbGllbnRIZWlnaHQgLSBwYWRkaW5nVG9wIC0gcGFkZGluZ0JvdHRvbTtcblx0XHR2YXIgY2ggPSBoZWxwZXJzJDEuZ2V0Q29uc3RyYWludEhlaWdodChkb21Ob2RlKTtcblx0XHRyZXR1cm4gaXNOYU4oY2gpID8gaCA6IE1hdGgubWluKGgsIGNoKTtcblx0fTtcblx0aGVscGVycyQxLmdldFN0eWxlID0gZnVuY3Rpb24oZWwsIHByb3BlcnR5KSB7XG5cdFx0cmV0dXJuIGVsLmN1cnJlbnRTdHlsZSA/XG5cdFx0XHRlbC5jdXJyZW50U3R5bGVbcHJvcGVydHldIDpcblx0XHRcdGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuXHR9O1xuXHRoZWxwZXJzJDEucmV0aW5hU2NhbGUgPSBmdW5jdGlvbihjaGFydCwgZm9yY2VSYXRpbykge1xuXHRcdHZhciBwaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcblx0XHRpZiAocGl4ZWxSYXRpbyA9PT0gMSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0dmFyIGhlaWdodCA9IGNoYXJ0LmhlaWdodDtcblx0XHR2YXIgd2lkdGggPSBjaGFydC53aWR0aDtcblxuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcblx0XHRjaGFydC5jdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cblx0XHQvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxuXHRcdC8vIG1ha2luZyB0aGUgY2hhcnQgdmlzdWFsbHkgYmlnZ2VyLCBzbyBsZXQncyBlbmZvcmNlIGl0IHRvIHRoZSBcImNvcnJlY3RcIiB2YWx1ZXMuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNTc1XG5cdFx0aWYgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpIHtcblx0XHRcdGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHRcdH1cblx0fTtcblx0Ly8gLS0gQ2FudmFzIG1ldGhvZHNcblx0aGVscGVycyQxLmZvbnRTdHJpbmcgPSBmdW5jdGlvbihwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xuXHRcdHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG5cdH07XG5cdGhlbHBlcnMkMS5sb25nZXN0VGV4dCA9IGZ1bmN0aW9uKGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcblx0XHRjYWNoZSA9IGNhY2hlIHx8IHt9O1xuXHRcdHZhciBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG5cdFx0dmFyIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcblxuXHRcdGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XG5cdFx0XHRkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuXHRcdFx0Z2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuXHRcdFx0Y2FjaGUuZm9udCA9IGZvbnQ7XG5cdFx0fVxuXG5cdFx0Y3R4LmZvbnQgPSBmb250O1xuXHRcdHZhciBsb25nZXN0ID0gMDtcblx0XHRoZWxwZXJzJDEuZWFjaChhcnJheU9mVGhpbmdzLCBmdW5jdGlvbih0aGluZykge1xuXHRcdFx0Ly8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG5cdFx0XHRpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiBoZWxwZXJzJDEuaXNBcnJheSh0aGluZykgIT09IHRydWUpIHtcblx0XHRcdFx0bG9uZ2VzdCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG5cdFx0XHR9IGVsc2UgaWYgKGhlbHBlcnMkMS5pc0FycmF5KHRoaW5nKSkge1xuXHRcdFx0XHQvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXRzIG1lYXN1cmUgZWFjaCBlbGVtZW50XG5cdFx0XHRcdC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cblx0XHRcdFx0aGVscGVycyQxLmVhY2godGhpbmcsIGZ1bmN0aW9uKG5lc3RlZFRoaW5nKSB7XG5cdFx0XHRcdFx0Ly8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG5cdFx0XHRcdFx0aWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWhlbHBlcnMkMS5pc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuXHRcdFx0XHRcdFx0bG9uZ2VzdCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHZhciBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG5cdFx0aWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuXHRcdFx0XHRkZWxldGUgZGF0YVtnY1tpXV07XG5cdFx0XHR9XG5cdFx0XHRnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9uZ2VzdDtcblx0fTtcblx0aGVscGVycyQxLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24oY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgc3RyaW5nKSB7XG5cdFx0dmFyIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcblx0XHRpZiAoIXRleHRXaWR0aCkge1xuXHRcdFx0dGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG5cdFx0XHRnYy5wdXNoKHN0cmluZyk7XG5cdFx0fVxuXHRcdGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG5cdFx0XHRsb25nZXN0ID0gdGV4dFdpZHRoO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9uZ2VzdDtcblx0fTtcblx0aGVscGVycyQxLm51bWJlck9mTGFiZWxMaW5lcyA9IGZ1bmN0aW9uKGFycmF5T2ZUaGluZ3MpIHtcblx0XHR2YXIgbnVtYmVyT2ZMaW5lcyA9IDE7XG5cdFx0aGVscGVycyQxLmVhY2goYXJyYXlPZlRoaW5ncywgZnVuY3Rpb24odGhpbmcpIHtcblx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aGluZykpIHtcblx0XHRcdFx0aWYgKHRoaW5nLmxlbmd0aCA+IG51bWJlck9mTGluZXMpIHtcblx0XHRcdFx0XHRudW1iZXJPZkxpbmVzID0gdGhpbmcubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIG51bWJlck9mTGluZXM7XG5cdH07XG5cblx0aGVscGVycyQxLmNvbG9yID0gIWNoYXJ0anNDb2xvciA/XG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0NvbG9yLmpzIG5vdCBmb3VuZCEnKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0LyogZ2xvYmFsIENhbnZhc0dyYWRpZW50ICovXG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCkge1xuXHRcdFx0XHR2YWx1ZSA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNoYXJ0anNDb2xvcih2YWx1ZSk7XG5cdFx0fTtcblxuXHRoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvciA9IGZ1bmN0aW9uKGNvbG9yVmFsdWUpIHtcblx0XHQvKiBnbG9iYWwgQ2FudmFzUGF0dGVybiAqL1xuXHRcdHJldHVybiAoY29sb3JWYWx1ZSBpbnN0YW5jZW9mIENhbnZhc1BhdHRlcm4gfHwgY29sb3JWYWx1ZSBpbnN0YW5jZW9mIENhbnZhc0dyYWRpZW50KSA/XG5cdFx0XHRjb2xvclZhbHVlIDpcblx0XHRcdGhlbHBlcnMkMS5jb2xvcihjb2xvclZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLnJnYlN0cmluZygpO1xuXHR9O1xufTtcblxuZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG5cdHRocm93IG5ldyBFcnJvcihcblx0XHQnVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBlaXRoZXIgbm8gYWRhcHRlciBjYW4gJyArXG5cdFx0J2JlIGZvdW5kIG9yIGFuIGluY29tcGxldGUgaW50ZWdyYXRpb24gd2FzIHByb3ZpZGVkLidcblx0KTtcbn1cblxuLyoqXG4gKiBEYXRlIGFkYXB0ZXIgKGN1cnJlbnQgdXNlZCBieSB0aGUgdGltZSBzY2FsZSlcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlXG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQ3VycmVudGx5IHN1cHBvcnRlZCB1bml0IHN0cmluZyB2YWx1ZXMuXG4gKiBAdHlwZWRlZiB7KCdtaWxsaXNlY29uZCd8J3NlY29uZCd8J21pbnV0ZSd8J2hvdXInfCdkYXknfCd3ZWVrJ3wnbW9udGgnfCdxdWFydGVyJ3wneWVhcicpfVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG5hbWUgVW5pdFxuICovXG5cbi8qKlxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIERhdGVBZGFwdGVyKG9wdGlvbnMpIHtcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbn1cblxuaGVscGVycyQxLmV4dGVuZChEYXRlQWRhcHRlci5wcm90b3R5cGUsIC8qKiBAbGVuZHMgRGF0ZUFkYXB0ZXIgKi8ge1xuXHQvKipcblx0ICogUmV0dXJucyBhIG1hcCBvZiB0aW1lIGZvcm1hdHMgZm9yIHRoZSBzdXBwb3J0ZWQgZm9ybWF0dGluZyB1bml0cyBkZWZpbmVkXG5cdCAqIGluIFVuaXQgYXMgd2VsbCBhcyAnZGF0ZXRpbWUnIHJlcHJlc2VudGluZyBhIGRldGFpbGVkIGRhdGUvdGltZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHt7c3RyaW5nOiBzdHJpbmd9fVxuXHQgKi9cblx0Zm9ybWF0czogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gYHZhbHVlYCBhbmQgcmV0dXJuIHRoZSBhc3NvY2lhdGVkIHRpbWVzdGFtcC5cblx0ICogQHBhcmFtIHthbnl9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHBhcnNlICh1c3VhbGx5IGNvbWVzIGZyb20gdGhlIGRhdGEpXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbZm9ybWF0XSAtIHRoZSBleHBlY3RlZCBkYXRhIGZvcm1hdFxuXHQgKiBAcmV0dXJucyB7KG51bWJlcnxudWxsKX1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRwYXJzZTogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRlIGluIHRoZSBzcGVjaWZpZWQgYGZvcm1hdGAgZm9yIGEgZ2l2ZW4gYHRpbWVzdGFtcGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgdGltZXN0YW1wIHRvIGZvcm1hdFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gdGhlIGRhdGUvdGltZSB0b2tlblxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0Zm9ybWF0OiBhYnN0cmFjdCxcblxuXHQvKipcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIGBhbW91bnRgIG9mIGB1bml0YCB0byB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IHRvIGFkZFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGFkZDogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBgdW5pdGAgYmV0d2VlbiB0aGUgZ2l2ZW4gdGltZXN0YW1wcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIHRoZSBpbnB1dCB0aW1lc3RhbXAgKHJlZmVyZW5jZSlcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIHRoZSB0aW1lc3RhbXAgdG8gc3Vic3RyYWN0XG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0ZGlmZjogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgc3RhcnQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dlZWtkYXldIC0gdGhlIElTTyBkYXkgb2YgdGhlIHdlZWsgd2l0aCAxIGJlaW5nIE1vbmRheVxuXHQgKiBhbmQgNyBiZWluZyBTdW5kYXkgKG9ubHkgbmVlZGVkIGlmIHBhcmFtICp1bml0KiBpcyBgaXNvV2Vla2ApLlxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdHN0YXJ0T2Y6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGVuZCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0ZW5kT2Y6IGFic3RyYWN0LFxuXG5cdC8vIERFUFJFQ0FUSU9OU1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3Igc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbCgpLFxuXHQgKiB0aGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBvbmx5IGJ5IHRoZSBtb21lbnQgYWRhcHRlci5cblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY3JlYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxufSk7XG5cbkRhdGVBZGFwdGVyLm92ZXJyaWRlID0gZnVuY3Rpb24obWVtYmVycykge1xuXHRoZWxwZXJzJDEuZXh0ZW5kKERhdGVBZGFwdGVyLnByb3RvdHlwZSwgbWVtYmVycyk7XG59O1xuXG52YXIgX2RhdGUgPSBEYXRlQWRhcHRlcjtcblxudmFyIGNvcmVfYWRhcHRlcnMgPSB7XG5cdF9kYXRlOiBfZGF0ZVxufTtcblxuLyoqXG4gKiBOYW1lc3BhY2UgdG8gaG9sZCBzdGF0aWMgdGljayBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrc1xuICovXG52YXIgY29yZV90aWNrcyA9IHtcblx0LyoqXG5cdCAqIE5hbWVzcGFjZSB0byBob2xkIGZvcm1hdHRlcnMgZm9yIGRpZmZlcmVudCB0eXBlcyBvZiB0aWNrc1xuXHQgKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnNcblx0ICovXG5cdGZvcm1hdHRlcnM6IHtcblx0XHQvKipcblx0XHQgKiBGb3JtYXR0ZXIgZm9yIHZhbHVlIGxhYmVsc1xuXHRcdCAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy52YWx1ZXNcblx0XHQgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGRpc3BsYXlcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW119IHRoZSBsYWJlbCB0byBkaXNwbGF5XG5cdFx0ICovXG5cdFx0dmFsdWVzOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGhlbHBlcnMkMS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogJycgKyB2YWx1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0dGVyIGZvciBsaW5lYXIgbnVtZXJpYyB0aWNrc1xuXHRcdCAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5saW5lYXJcblx0XHQgKiBAcGFyYW0gdGlja1ZhbHVlIHtudW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcblx0XHQgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuXHRcdCAqIEBwYXJhbSB0aWNrcyB7bnVtYmVyW119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXG5cdFx0ICovXG5cdFx0bGluZWFyOiBmdW5jdGlvbih0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBsb3RzIG9mIHRpY2tzLCBkb24ndCB1c2UgdGhlIG9uZXNcblx0XHRcdHZhciBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXSAtIHRpY2tzWzFdIDogdGlja3NbMV0gLSB0aWNrc1swXTtcblxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIG51bWJlciBsaWtlIDIuNSBhcyB0aGUgZGVsdGEsIGZpZ3VyZSBvdXQgaG93IG1hbnkgZGVjaW1hbCBwbGFjZXMgd2UgbmVlZFxuXHRcdFx0aWYgKE1hdGguYWJzKGRlbHRhKSA+IDEpIHtcblx0XHRcdFx0aWYgKHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XG5cdFx0XHRcdFx0Ly8gbm90IGFuIGludGVnZXJcblx0XHRcdFx0XHRkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbG9nRGVsdGEgPSBoZWxwZXJzJDEubG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcblx0XHRcdHZhciB0aWNrU3RyaW5nID0gJyc7XG5cblx0XHRcdGlmICh0aWNrVmFsdWUgIT09IDApIHtcblx0XHRcdFx0dmFyIG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdKSk7XG5cdFx0XHRcdGlmIChtYXhUaWNrIDwgMWUtNCkgeyAvLyBhbGwgdGlja3MgYXJlIHNtYWxsIG51bWJlcnM7IHVzZSBzY2llbnRpZmljIG5vdGF0aW9uXG5cdFx0XHRcdFx0dmFyIGxvZ1RpY2sgPSBoZWxwZXJzJDEubG9nMTAoTWF0aC5hYnModGlja1ZhbHVlKSk7XG5cdFx0XHRcdFx0dGlja1N0cmluZyA9IHRpY2tWYWx1ZS50b0V4cG9uZW50aWFsKE1hdGguZmxvb3IobG9nVGljaykgLSBNYXRoLmZsb29yKGxvZ0RlbHRhKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG51bURlY2ltYWwgPSAtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpO1xuXHRcdFx0XHRcdG51bURlY2ltYWwgPSBNYXRoLm1heChNYXRoLm1pbihudW1EZWNpbWFsLCAyMCksIDApOyAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xuXHRcdFx0XHRcdHRpY2tTdHJpbmcgPSB0aWNrVmFsdWUudG9GaXhlZChudW1EZWNpbWFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGlja1N0cmluZyA9ICcwJzsgLy8gbmV2ZXIgc2hvdyBkZWNpbWFsIHBsYWNlcyBmb3IgMFxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGlja1N0cmluZztcblx0XHR9LFxuXG5cdFx0bG9nYXJpdGhtaWM6IGZ1bmN0aW9uKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG5cdFx0XHR2YXIgcmVtYWluID0gdGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh0aWNrVmFsdWUpKSkpO1xuXG5cdFx0XHRpZiAodGlja1ZhbHVlID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAnMCc7XG5cdFx0XHR9IGVsc2UgaWYgKHJlbWFpbiA9PT0gMSB8fCByZW1haW4gPT09IDIgfHwgcmVtYWluID09PSA1IHx8IGluZGV4ID09PSAwIHx8IGluZGV4ID09PSB0aWNrcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdHJldHVybiB0aWNrVmFsdWUudG9FeHBvbmVudGlhbCgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0fVxufTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDkgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgdmFsdWVBdEluZGV4T3JEZWZhdWx0ID0gaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdzY2FsZScsIHtcblx0ZGlzcGxheTogdHJ1ZSxcblx0cG9zaXRpb246ICdsZWZ0Jyxcblx0b2Zmc2V0OiBmYWxzZSxcblxuXHQvLyBncmlkIGxpbmUgc2V0dGluZ3Ncblx0Z3JpZExpbmVzOiB7XG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXG5cdFx0bGluZVdpZHRoOiAxLFxuXHRcdGRyYXdCb3JkZXI6IHRydWUsXG5cdFx0ZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuXHRcdGRyYXdUaWNrczogdHJ1ZSxcblx0XHR0aWNrTWFya0xlbmd0aDogMTAsXG5cdFx0emVyb0xpbmVXaWR0aDogMSxcblx0XHR6ZXJvTGluZUNvbG9yOiAncmdiYSgwLDAsMCwwLjI1KScsXG5cdFx0emVyb0xpbmVCb3JkZXJEYXNoOiBbXSxcblx0XHR6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcblx0XHRvZmZzZXRHcmlkTGluZXM6IGZhbHNlLFxuXHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuXHR9LFxuXG5cdC8vIHNjYWxlIGxhYmVsXG5cdHNjYWxlTGFiZWw6IHtcblx0XHQvLyBkaXNwbGF5IHByb3BlcnR5XG5cdFx0ZGlzcGxheTogZmFsc2UsXG5cblx0XHQvLyBhY3R1YWwgbGFiZWxcblx0XHRsYWJlbFN0cmluZzogJycsXG5cblx0XHQvLyB0b3AvYm90dG9tIHBhZGRpbmdcblx0XHRwYWRkaW5nOiB7XG5cdFx0XHR0b3A6IDQsXG5cdFx0XHRib3R0b206IDRcblx0XHR9XG5cdH0sXG5cblx0Ly8gbGFiZWwgc2V0dGluZ3Ncblx0dGlja3M6IHtcblx0XHRiZWdpbkF0WmVybzogZmFsc2UsXG5cdFx0bWluUm90YXRpb246IDAsXG5cdFx0bWF4Um90YXRpb246IDUwLFxuXHRcdG1pcnJvcjogZmFsc2UsXG5cdFx0cGFkZGluZzogMCxcblx0XHRyZXZlcnNlOiBmYWxzZSxcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdGF1dG9Ta2lwOiB0cnVlLFxuXHRcdGF1dG9Ta2lwUGFkZGluZzogMCxcblx0XHRsYWJlbE9mZnNldDogMCxcblx0XHQvLyBXZSBwYXNzIHRocm91Z2ggYXJyYXlzIHRvIGJlIHJlbmRlcmVkIGFzIG11bHRpbGluZSBsYWJlbHMsIHdlIGNvbnZlcnQgT3RoZXJzIHRvIHN0cmluZ3MgaGVyZS5cblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcblx0XHRtaW5vcjoge30sXG5cdFx0bWFqb3I6IHt9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBsYWJlbHNGcm9tVGlja3ModGlja3MpIHtcblx0dmFyIGxhYmVscyA9IFtdO1xuXHR2YXIgaSwgaWxlbjtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0bGFiZWxzLnB1c2godGlja3NbaV0ubGFiZWwpO1xuXHR9XG5cblx0cmV0dXJuIGxhYmVscztcbn1cblxuZnVuY3Rpb24gZ2V0UGl4ZWxGb3JHcmlkTGluZShzY2FsZSwgaW5kZXgsIG9mZnNldEdyaWRMaW5lcykge1xuXHR2YXIgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KTtcblxuXHRpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG5cdFx0aWYgKHNjYWxlLmdldFRpY2tzKCkubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRsaW5lVmFsdWUgLT0gc2NhbGUuaXNIb3Jpem9udGFsKCkgP1xuXHRcdFx0XHRNYXRoLm1heChsaW5lVmFsdWUgLSBzY2FsZS5sZWZ0LCBzY2FsZS5yaWdodCAtIGxpbmVWYWx1ZSkgOlxuXHRcdFx0XHRNYXRoLm1heChsaW5lVmFsdWUgLSBzY2FsZS50b3AsIHNjYWxlLmJvdHRvbSAtIGxpbmVWYWx1ZSk7XG5cdFx0fSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0bGluZVZhbHVlIC09IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGluZVZhbHVlIC09IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaW5kZXggLSAxKSkgLyAyO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbGluZVZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlVGV4dFNpemUoY29udGV4dCwgdGljaywgZm9udCkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzQXJyYXkodGljaykgP1xuXHRcdGhlbHBlcnMkMS5sb25nZXN0VGV4dChjb250ZXh0LCBmb250LCB0aWNrKSA6XG5cdFx0Y29udGV4dC5tZWFzdXJlVGV4dCh0aWNrKS53aWR0aDtcbn1cblxudmFyIGNvcmVfc2NhbGUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0LyoqXG5cdCAqIEdldCB0aGUgcGFkZGluZyBuZWVkZWQgZm9yIHRoZSBzY2FsZVxuXHQgKiBAbWV0aG9kIGdldFBhZGRpbmdcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybnMge1BhZGRpbmd9IHRoZSBuZWNlc3NhcnkgcGFkZGluZ1xuXHQgKi9cblx0Z2V0UGFkZGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRyZXR1cm4ge1xuXHRcdFx0bGVmdDogbWUucGFkZGluZ0xlZnQgfHwgMCxcblx0XHRcdHRvcDogbWUucGFkZGluZ1RvcCB8fCAwLFxuXHRcdFx0cmlnaHQ6IG1lLnBhZGRpbmdSaWdodCB8fCAwLFxuXHRcdFx0Ym90dG9tOiBtZS5wYWRkaW5nQm90dG9tIHx8IDBcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzY2FsZSB0aWNrIG9iamVjdHMgKHtsYWJlbCwgbWFqb3J9KVxuXHQgKiBAc2luY2UgMi43XG5cdCAqL1xuXHRnZXRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RpY2tzO1xuXHR9LFxuXG5cdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5bGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblx0Ly8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIHNjYWxlIHR5cGVzLlxuXHQvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBzY2FsZSB0eXBlXG5cblx0bWVyZ2VUaWNrc09wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblx0XHRpZiAodGlja3MubWlub3IgPT09IGZhbHNlKSB7XG5cdFx0XHR0aWNrcy5taW5vciA9IHtcblx0XHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHRcdH07XG5cdFx0fVxuXHRcdGlmICh0aWNrcy5tYWpvciA9PT0gZmFsc2UpIHtcblx0XHRcdHRpY2tzLm1ham9yID0ge1xuXHRcdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0Zm9yICh2YXIga2V5IGluIHRpY2tzKSB7XG5cdFx0XHRpZiAoa2V5ICE9PSAnbWFqb3InICYmIGtleSAhPT0gJ21pbm9yJykge1xuXHRcdFx0XHRpZiAodHlwZW9mIHRpY2tzLm1pbm9yW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0dGlja3MubWlub3Jba2V5XSA9IHRpY2tzW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZiB0aWNrcy5tYWpvcltrZXldID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHRpY2tzLm1ham9yW2tleV0gPSB0aWNrc1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24obWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGksIGlsZW4sIGxhYmVscywgbGFiZWwsIHRpY2tzLCB0aWNrO1xuXG5cdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcblxuXHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0bWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXHRcdG1lLm1hcmdpbnMgPSBoZWxwZXJzJDEuZXh0ZW5kKHtcblx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRyaWdodDogMCxcblx0XHRcdHRvcDogMCxcblx0XHRcdGJvdHRvbTogMFxuXHRcdH0sIG1hcmdpbnMpO1xuXG5cdFx0bWUuX21heExhYmVsTGluZXMgPSAwO1xuXHRcdG1lLmxvbmdlc3RMYWJlbFdpZHRoID0gMDtcblx0XHRtZS5sb25nZXN0VGV4dENhY2hlID0gbWUubG9uZ2VzdFRleHRDYWNoZSB8fCB7fTtcblxuXHRcdC8vIERpbWVuc2lvbnNcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXG5cdFx0Ly8gRGF0YSBtaW4vbWF4XG5cdFx0bWUuYmVmb3JlRGF0YUxpbWl0cygpO1xuXHRcdG1lLmRldGVybWluZURhdGFMaW1pdHMoKTtcblx0XHRtZS5hZnRlckRhdGFMaW1pdHMoKTtcblxuXHRcdC8vIFRpY2tzIC0gYHRoaXMudGlja3NgIGlzIG5vdyBERVBSRUNBVEVEIVxuXHRcdC8vIEludGVybmFsIHRpY2tzIGFyZSBub3cgc3RvcmVkIGFzIG9iamVjdHMgaW4gdGhlIFBSSVZBVEUgYHRoaXMuX3RpY2tzYCBtZW1iZXJcblx0XHQvLyBhbmQgbXVzdCBub3QgYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBvdXRzaWRlIHRoaXMgY2xhc3MuIGB0aGlzLnRpY2tzYCBiZWluZ1xuXHRcdC8vIGFyb3VuZCBmb3IgbG9uZyB0aW1lIGFuZCBub3QgbWFya2VkIGFzIHByaXZhdGUsIHdlIGNhbid0IGNoYW5nZSBpdHMgc3RydWN0dXJlXG5cdFx0Ly8gd2l0aG91dCB1bmV4cGVjdGVkIGJyZWFraW5nIGNoYW5nZXMuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2NhbGUgdGlja3MsXG5cdFx0Ly8gdXNlIHNjYWxlLmdldFRpY2tzKCkgaW5zdGVhZC5cblxuXHRcdG1lLmJlZm9yZUJ1aWxkVGlja3MoKTtcblxuXHRcdC8vIE5ldyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIGJ1dCBmb3IgQkFDS1dBUkQgQ09NUEFULFxuXHRcdC8vIHdlIHN0aWxsIHN1cHBvcnQgbm8gcmV0dXJuIChgdGhpcy50aWNrc2AgaW50ZXJuYWxseSBzZXQgYnkgY2FsbGluZyB0aGlzIG1ldGhvZCkuXG5cdFx0dGlja3MgPSBtZS5idWlsZFRpY2tzKCkgfHwgW107XG5cblx0XHQvLyBBbGxvdyBtb2RpZmljYXRpb24gb2YgdGlja3MgaW4gY2FsbGJhY2suXG5cdFx0dGlja3MgPSBtZS5hZnRlckJ1aWxkVGlja3ModGlja3MpIHx8IHRpY2tzO1xuXG5cdFx0bWUuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG5cblx0XHQvLyBOZXcgaW1wbGVtZW50YXRpb25zIHNob3VsZCByZXR1cm4gdGhlIGZvcm1hdHRlZCB0aWNrIGxhYmVscyBidXQgZm9yIEJBQ0tXQVJEXG5cdFx0Ly8gQ09NUEFULCB3ZSBzdGlsbCBzdXBwb3J0IG5vIHJldHVybiAoYHRoaXMudGlja3NgIGludGVybmFsbHkgY2hhbmdlZCBieSBjYWxsaW5nXG5cdFx0Ly8gdGhpcyBtZXRob2QgYW5kIHN1cHBvc2VkIHRvIGNvbnRhaW4gb25seSBzdHJpbmcgdmFsdWVzKS5cblx0XHRsYWJlbHMgPSBtZS5jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykgfHwgbWUudGlja3M7XG5cblx0XHRtZS5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG5cdFx0bWUudGlja3MgPSBsYWJlbHM7ICAgLy8gQkFDS1dBUkQgQ09NUEFUSUJJTElUWVxuXG5cdFx0Ly8gSU1QT1JUQU5UOiBmcm9tIHRoaXMgcG9pbnQsIHdlIGNvbnNpZGVyIHRoYXQgYHRoaXMudGlja3NgIHdpbGwgTkVWRVIgY2hhbmdlIVxuXG5cdFx0Ly8gQkFDS1dBUkQgQ09NUEFUOiBzeW5jaHJvbml6ZSBgX3RpY2tzYCB3aXRoIGxhYmVscyAoc28gcG90ZW50aWFsbHkgYHRoaXMudGlja3NgKVxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRsYWJlbCA9IGxhYmVsc1tpXTtcblx0XHRcdHRpY2sgPSB0aWNrc1tpXTtcblx0XHRcdGlmICghdGljaykge1xuXHRcdFx0XHR0aWNrcy5wdXNoKHRpY2sgPSB7XG5cdFx0XHRcdFx0bGFiZWw6IGxhYmVsLFxuXHRcdFx0XHRcdG1ham9yOiBmYWxzZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRpY2subGFiZWwgPSBsYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS5fdGlja3MgPSB0aWNrcztcblxuXHRcdC8vIFRpY2sgUm90YXRpb25cblx0XHRtZS5iZWZvcmVDYWxjdWxhdGVUaWNrUm90YXRpb24oKTtcblx0XHRtZS5jYWxjdWxhdGVUaWNrUm90YXRpb24oKTtcblx0XHRtZS5hZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xuXHRcdC8vIEZpdFxuXHRcdG1lLmJlZm9yZUZpdCgpO1xuXHRcdG1lLmZpdCgpO1xuXHRcdG1lLmFmdGVyRml0KCk7XG5cdFx0Ly9cblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xuXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XG5cblx0fSxcblx0YWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly9cblxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG5cdH0sXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXHR9LFxuXHRhZnRlclNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vIERhdGEgbGltaXRzXG5cdGJlZm9yZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlRGF0YUxpbWl0cywgW3RoaXNdKTtcblx0fSxcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogaGVscGVycyQxLm5vb3AsXG5cdGFmdGVyRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckRhdGFMaW1pdHMsIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly9cblx0YmVmb3JlQnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVCdWlsZFRpY2tzLCBbdGhpc10pO1xuXHR9LFxuXHRidWlsZFRpY2tzOiBoZWxwZXJzJDEubm9vcCxcblx0YWZ0ZXJCdWlsZFRpY2tzOiBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gdGlja3MgaXMgZW1wdHkgZm9yIG9sZCBheGlzIGltcGxlbWVudGF0aW9ucyBoZXJlXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRpY2tzKSAmJiB0aWNrcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBoZWxwZXJzJDEuY2FsbGJhY2sobWUub3B0aW9ucy5hZnRlckJ1aWxkVGlja3MsIFttZSwgdGlja3NdKTtcblx0XHR9XG5cdFx0Ly8gU3VwcG9ydCBvbGQgaW1wbGVtZW50YXRpb25zICh0aGF0IG1vZGlmaWVkIGB0aGlzLnRpY2tzYCBkaXJlY3RseSBpbiBidWlsZFRpY2tzKVxuXHRcdG1lLnRpY2tzID0gaGVscGVycyQxLmNhbGxiYWNrKG1lLm9wdGlvbnMuYWZ0ZXJCdWlsZFRpY2tzLCBbbWUsIG1lLnRpY2tzXSkgfHwgbWUudGlja3M7XG5cdFx0cmV0dXJuIHRpY2tzO1xuXHR9LFxuXG5cdGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG5cdH0sXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIENvbnZlcnQgdGlja3MgdG8gc3RyaW5nc1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0bWUudGlja3MgPSBtZS50aWNrcy5tYXAodGlja09wdHMudXNlckNhbGxiYWNrIHx8IHRpY2tPcHRzLmNhbGxiYWNrLCB0aGlzKTtcblx0fSxcblx0YWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb246IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly9cblxuXHRiZWZvcmVDYWxjdWxhdGVUaWNrUm90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uLCBbdGhpc10pO1xuXHR9LFxuXHRjYWxjdWxhdGVUaWNrUm90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNvbnRleHQgPSBtZS5jdHg7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgbGFiZWxzID0gbGFiZWxzRnJvbVRpY2tzKG1lLl90aWNrcyk7XG5cblx0XHQvLyBHZXQgdGhlIHdpZHRoIG9mIGVhY2ggZ3JpZCBieSBjYWxjdWxhdGluZyB0aGUgZGlmZmVyZW5jZVxuXHRcdC8vIGJldHdlZW4geCBvZmZzZXRzIGJldHdlZW4gMCBhbmQgMS5cblx0XHR2YXIgdGlja0ZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHRpY2tPcHRzKTtcblx0XHRjb250ZXh0LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG5cblx0XHR2YXIgbGFiZWxSb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG5cblx0XHRpZiAobGFiZWxzLmxlbmd0aCAmJiBtZS5vcHRpb25zLmRpc3BsYXkgJiYgbWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdHZhciBvcmlnaW5hbExhYmVsV2lkdGggPSBoZWxwZXJzJDEubG9uZ2VzdFRleHQoY29udGV4dCwgdGlja0ZvbnQuc3RyaW5nLCBsYWJlbHMsIG1lLmxvbmdlc3RUZXh0Q2FjaGUpO1xuXHRcdFx0dmFyIGxhYmVsV2lkdGggPSBvcmlnaW5hbExhYmVsV2lkdGg7XG5cdFx0XHR2YXIgY29zUm90YXRpb24sIHNpblJvdGF0aW9uO1xuXG5cdFx0XHQvLyBBbGxvdyAzIHBpeGVscyB4MiBwYWRkaW5nIGVpdGhlciBzaWRlIGZvciBsYWJlbCByZWFkYWJpbGl0eVxuXHRcdFx0dmFyIHRpY2tXaWR0aCA9IG1lLmdldFBpeGVsRm9yVGljaygxKSAtIG1lLmdldFBpeGVsRm9yVGljaygwKSAtIDY7XG5cblx0XHRcdC8vIE1heCBsYWJlbCByb3RhdGlvbiBjYW4gYmUgc2V0IG9yIGRlZmF1bHQgdG8gOTAgLSBhbHNvIGFjdCBhcyBhIGxvb3AgY291bnRlclxuXHRcdFx0d2hpbGUgKGxhYmVsV2lkdGggPiB0aWNrV2lkdGggJiYgbGFiZWxSb3RhdGlvbiA8IHRpY2tPcHRzLm1heFJvdGF0aW9uKSB7XG5cdFx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKGxhYmVsUm90YXRpb24pO1xuXHRcdFx0XHRjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XG5cdFx0XHRcdHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcblxuXHRcdFx0XHRpZiAoc2luUm90YXRpb24gKiBvcmlnaW5hbExhYmVsV2lkdGggPiBtZS5tYXhIZWlnaHQpIHtcblx0XHRcdFx0XHQvLyBnbyBiYWNrIG9uZSBzdGVwXG5cdFx0XHRcdFx0bGFiZWxSb3RhdGlvbi0tO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGFiZWxSb3RhdGlvbisrO1xuXHRcdFx0XHRsYWJlbFdpZHRoID0gY29zUm90YXRpb24gKiBvcmlnaW5hbExhYmVsV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG5cdH0sXG5cdGFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlRml0OiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcblx0fSxcblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFJlc2V0XG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplID0ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9O1xuXG5cdFx0dmFyIGxhYmVscyA9IGxhYmVsc0Zyb21UaWNrcyhtZS5fdGlja3MpO1xuXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cdFx0dmFyIHNjYWxlTGFiZWxPcHRzID0gb3B0cy5zY2FsZUxhYmVsO1xuXHRcdHZhciBncmlkTGluZU9wdHMgPSBvcHRzLmdyaWRMaW5lcztcblx0XHR2YXIgZGlzcGxheSA9IG1lLl9pc1Zpc2libGUoKTtcblx0XHR2YXIgcG9zaXRpb24gPSBvcHRzLnBvc2l0aW9uO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdHZhciBwYXJzZUZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250O1xuXHRcdHZhciB0aWNrRm9udCA9IHBhcnNlRm9udCh0aWNrT3B0cyk7XG5cdFx0dmFyIHRpY2tNYXJrTGVuZ3RoID0gb3B0cy5ncmlkTGluZXMudGlja01hcmtMZW5ndGg7XG5cblx0XHQvLyBXaWR0aFxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdC8vIHN1YnRyYWN0IHRoZSBtYXJnaW5zIHRvIGxpbmUgdXAgd2l0aCB0aGUgY2hhcnRBcmVhIGlmIHdlIGFyZSBhIGZ1bGwgd2lkdGggc2NhbGVcblx0XHRcdG1pblNpemUud2lkdGggPSBtZS5pc0Z1bGxXaWR0aCgpID8gbWUubWF4V2lkdGggLSBtZS5tYXJnaW5zLmxlZnQgLSBtZS5tYXJnaW5zLnJpZ2h0IDogbWUubWF4V2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1pblNpemUud2lkdGggPSBkaXNwbGF5ICYmIGdyaWRMaW5lT3B0cy5kcmF3VGlja3MgPyB0aWNrTWFya0xlbmd0aCA6IDA7XG5cdFx0fVxuXG5cdFx0Ly8gaGVpZ2h0XG5cdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBkaXNwbGF5ICYmIGdyaWRMaW5lT3B0cy5kcmF3VGlja3MgPyB0aWNrTWFya0xlbmd0aCA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0fVxuXG5cdFx0Ly8gQXJlIHdlIHNob3dpbmcgYSB0aXRsZSBmb3IgdGhlIHNjYWxlP1xuXHRcdGlmIChzY2FsZUxhYmVsT3B0cy5kaXNwbGF5ICYmIGRpc3BsYXkpIHtcblx0XHRcdHZhciBzY2FsZUxhYmVsRm9udCA9IHBhcnNlRm9udChzY2FsZUxhYmVsT3B0cyk7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbFBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcoc2NhbGVMYWJlbE9wdHMucGFkZGluZyk7XG5cdFx0XHR2YXIgZGVsdGFIZWlnaHQgPSBzY2FsZUxhYmVsRm9udC5saW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcuaGVpZ2h0O1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ICs9IGRlbHRhSGVpZ2h0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluU2l6ZS53aWR0aCArPSBkZWx0YUhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEb24ndCBib3RoZXIgZml0dGluZyB0aGUgdGlja3MgaWYgd2UgYXJlIG5vdCBzaG93aW5nIHRoZSBsYWJlbHNcblx0XHRpZiAodGlja09wdHMuZGlzcGxheSAmJiBkaXNwbGF5KSB7XG5cdFx0XHR2YXIgbGFyZ2VzdFRleHRXaWR0aCA9IGhlbHBlcnMkMS5sb25nZXN0VGV4dChtZS5jdHgsIHRpY2tGb250LnN0cmluZywgbGFiZWxzLCBtZS5sb25nZXN0VGV4dENhY2hlKTtcblx0XHRcdHZhciB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzID0gaGVscGVycyQxLm51bWJlck9mTGFiZWxMaW5lcyhsYWJlbHMpO1xuXHRcdFx0dmFyIGxpbmVTcGFjZSA9IHRpY2tGb250LnNpemUgKiAwLjU7XG5cdFx0XHR2YXIgdGlja1BhZGRpbmcgPSBtZS5vcHRpb25zLnRpY2tzLnBhZGRpbmc7XG5cblx0XHRcdC8vIFN0b3JlIG1heCBudW1iZXIgb2YgbGluZXMgYW5kIHdpZGVzdCBsYWJlbCBmb3IgX2F1dG9Ta2lwXG5cdFx0XHRtZS5fbWF4TGFiZWxMaW5lcyA9IHRhbGxlc3RMYWJlbEhlaWdodEluTGluZXM7XG5cdFx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IGxhcmdlc3RUZXh0V2lkdGg7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0dmFyIGFuZ2xlUmFkaWFucyA9IGhlbHBlcnMkMS50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG5cdFx0XHRcdHZhciBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XG5cdFx0XHRcdHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cblx0XHRcdFx0Ly8gVE9ETyAtIGltcHJvdmUgdGhpcyBjYWxjdWxhdGlvblxuXHRcdFx0XHR2YXIgbGFiZWxIZWlnaHQgPSAoc2luUm90YXRpb24gKiBsYXJnZXN0VGV4dFdpZHRoKVxuXHRcdFx0XHRcdCsgKHRpY2tGb250LmxpbmVIZWlnaHQgKiB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzKVxuXHRcdFx0XHRcdCsgbGluZVNwYWNlOyAvLyBwYWRkaW5nXG5cblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbihtZS5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG5cblx0XHRcdFx0bWUuY3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG5cdFx0XHRcdHZhciBmaXJzdExhYmVsV2lkdGggPSBjb21wdXRlVGV4dFNpemUobWUuY3R4LCBsYWJlbHNbMF0sIHRpY2tGb250LnN0cmluZyk7XG5cdFx0XHRcdHZhciBsYXN0TGFiZWxXaWR0aCA9IGNvbXB1dGVUZXh0U2l6ZShtZS5jdHgsIGxhYmVsc1tsYWJlbHMubGVuZ3RoIC0gMV0sIHRpY2tGb250LnN0cmluZyk7XG5cdFx0XHRcdHZhciBvZmZzZXRMZWZ0ID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gbWUubGVmdDtcblx0XHRcdFx0dmFyIG9mZnNldFJpZ2h0ID0gbWUucmlnaHQgLSBtZS5nZXRQaXhlbEZvclRpY2sobGFiZWxzLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHR2YXIgcGFkZGluZ0xlZnQsIHBhZGRpbmdSaWdodDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhhdCBvdXIgdGlja3MgYXJlIGFsd2F5cyBpbnNpZGUgdGhlIGNhbnZhcy4gV2hlbiByb3RhdGVkLCB0aWNrcyBhcmUgcmlnaHQgYWxpZ25lZFxuXHRcdFx0XHQvLyB3aGljaCBtZWFucyB0aGF0IHRoZSByaWdodCBwYWRkaW5nIGlzIGRvbWluYXRlZCBieSB0aGUgZm9udCBoZWlnaHRcblx0XHRcdFx0aWYgKG1lLmxhYmVsUm90YXRpb24gIT09IDApIHtcblx0XHRcdFx0XHRwYWRkaW5nTGVmdCA9IHBvc2l0aW9uID09PSAnYm90dG9tJyA/IChjb3NSb3RhdGlvbiAqIGZpcnN0TGFiZWxXaWR0aCkgOiAoY29zUm90YXRpb24gKiBsaW5lU3BhY2UpO1xuXHRcdFx0XHRcdHBhZGRpbmdSaWdodCA9IHBvc2l0aW9uID09PSAnYm90dG9tJyA/IChjb3NSb3RhdGlvbiAqIGxpbmVTcGFjZSkgOiAoY29zUm90YXRpb24gKiBsYXN0TGFiZWxXaWR0aCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFkZGluZ0xlZnQgPSBmaXJzdExhYmVsV2lkdGggLyAyO1xuXHRcdFx0XHRcdHBhZGRpbmdSaWdodCA9IGxhc3RMYWJlbFdpZHRoIC8gMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZS5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCwgMCkgKyAzOyAvLyBhZGQgMyBweCB0byBtb3ZlIGF3YXkgZnJvbSBjYW52YXMgZWRnZXNcblx0XHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQsIDApICsgMztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEEgdmVydGljYWwgYXhpcyBpcyBtb3JlIGNvbnN0cmFpbmVkIGJ5IHRoZSB3aWR0aC4gTGFiZWxzIGFyZSB0aGVcblx0XHRcdFx0Ly8gZG9taW5hbnQgZmFjdG9yIGhlcmUsIHNvIGdldCB0aGF0IGxlbmd0aCBmaXJzdCBhbmQgYWNjb3VudCBmb3IgcGFkZGluZ1xuXHRcdFx0XHRpZiAodGlja09wdHMubWlycm9yKSB7XG5cdFx0XHRcdFx0bGFyZ2VzdFRleHRXaWR0aCA9IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdXNlIGxpbmVTcGFjZSBmb3IgY29uc2lzdGVuY3kgd2l0aCBob3Jpem9udGFsIGF4aXNcblx0XHRcdFx0XHQvLyB0aWNrUGFkZGluZyBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGhvcml6b250YWxcblx0XHRcdFx0XHRsYXJnZXN0VGV4dFdpZHRoICs9IHRpY2tQYWRkaW5nICsgbGluZVNwYWNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IE1hdGgubWluKG1lLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFyZ2VzdFRleHRXaWR0aCk7XG5cblx0XHRcdFx0bWUucGFkZGluZ1RvcCA9IHRpY2tGb250LnNpemUgLyAyO1xuXHRcdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gdGlja0ZvbnQuc2l6ZSAvIDI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUuaGFuZGxlTWFyZ2lucygpO1xuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgbWFyZ2lucyBhbmQgcGFkZGluZyBpbnRlcmFjdGlvbnNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhhbmRsZU1hcmdpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLm1hcmdpbnMpIHtcblx0XHRcdG1lLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgobWUucGFkZGluZ0xlZnQgLSBtZS5tYXJnaW5zLmxlZnQsIDApO1xuXHRcdFx0bWUucGFkZGluZ1RvcCA9IE1hdGgubWF4KG1lLnBhZGRpbmdUb3AgLSBtZS5tYXJnaW5zLnRvcCwgMCk7XG5cdFx0XHRtZS5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heChtZS5wYWRkaW5nUmlnaHQgLSBtZS5tYXJnaW5zLnJpZ2h0LCAwKTtcblx0XHRcdG1lLnBhZGRpbmdCb3R0b20gPSBNYXRoLm1heChtZS5wYWRkaW5nQm90dG9tIC0gbWUubWFyZ2lucy5ib3R0b20sIDApO1xuXHRcdH1cblx0fSxcblxuXHRhZnRlckZpdDogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcblx0fSxcblxuXHQvLyBTaGFyZWQgTWV0aG9kc1xuXHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG5cdH0sXG5cdGlzRnVsbFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5mdWxsV2lkdGgpO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgY29ycmVjdCB2YWx1ZS4gTmFOIGJhZCBpbnB1dHMsIElmIHRoZSB2YWx1ZSB0eXBlIGlzIG9iamVjdCBnZXQgdGhlIHggb3IgeSBiYXNlZCBvbiB3aGV0aGVyIHdlIGFyZSBob3Jpem9udGFsIG9yIG5vdFxuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbihyYXdWYWx1ZSkge1xuXHRcdC8vIE51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgZmlyc3Rcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYocmF3VmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gTmFOO1xuXHRcdH1cblx0XHQvLyBpc05hTihvYmplY3QpIHJldHVybnMgdHJ1ZSwgc28gbWFrZSBzdXJlIE5hTiBpcyBjaGVja2luZyBmb3IgYSBudW1iZXI7IERpc2NhcmQgSW5maW5pdGUgdmFsdWVzXG5cdFx0aWYgKCh0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInIHx8IHJhd1ZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUocmF3VmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gTmFOO1xuXHRcdH1cblx0XHQvLyBJZiBpdCBpcyBpbiBmYWN0IGFuIG9iamVjdCwgZGl2ZSBpbiBvbmUgbW9yZSBsZXZlbFxuXHRcdGlmIChyYXdWYWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0aWYgKHJhd1ZhbHVlLnggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAocmF3VmFsdWUueSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVmFsdWUgaXMgZ29vZCwgcmV0dXJuIGl0XG5cdFx0cmV0dXJuIHJhd1ZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgdmFsdWUgdG8gZGlzcGxheSBpbiB0aGUgdG9vbHRpcCBmb3IgdGhlIGRhdGEgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKiBAcGFyYW0gZGF0YXNldEluZGV4XG5cdCAqL1xuXHRnZXRMYWJlbEZvckluZGV4OiBoZWxwZXJzJDEubm9vcCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIGdpdmVuIGRhdGEgcG9pbnQuIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB2YWx1ZVxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICogQHBhcmFtIGRhdGFzZXRJbmRleFxuXHQgKi9cblx0Z2V0UGl4ZWxGb3JWYWx1ZTogaGVscGVycyQxLm5vb3AsXG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBkYXRhIHZhbHVlIGZyb20gYSBnaXZlbiBwaXhlbC4gVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBnZXRQaXhlbEZvclZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0gcGl4ZWxcblx0ICovXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGhlbHBlcnMkMS5ub29wLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgdGljayBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqL1xuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgaW5uZXJXaWR0aCA9IG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KTtcblx0XHRcdHZhciB0aWNrV2lkdGggPSBpbm5lcldpZHRoIC8gTWF0aC5tYXgoKG1lLl90aWNrcy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpKSwgMSk7XG5cdFx0XHR2YXIgcGl4ZWwgPSAodGlja1dpZHRoICogaW5kZXgpICsgbWUucGFkZGluZ0xlZnQ7XG5cblx0XHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdFx0cGl4ZWwgKz0gdGlja1dpZHRoIC8gMjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGZpbmFsVmFsID0gbWUubGVmdCArIHBpeGVsO1xuXHRcdFx0ZmluYWxWYWwgKz0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1hcmdpbnMubGVmdCA6IDA7XG5cdFx0XHRyZXR1cm4gZmluYWxWYWw7XG5cdFx0fVxuXHRcdHZhciBpbm5lckhlaWdodCA9IG1lLmhlaWdodCAtIChtZS5wYWRkaW5nVG9wICsgbWUucGFkZGluZ0JvdHRvbSk7XG5cdFx0cmV0dXJuIG1lLnRvcCArIChpbmRleCAqIChpbm5lckhlaWdodCAvIChtZS5fdGlja3MubGVuZ3RoIC0gMSkpKTtcblx0fSxcblxuXHQvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgYSBwZXJjZW50YWdlIG9mIHNjYWxlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKi9cblx0Z2V0UGl4ZWxGb3JEZWNpbWFsOiBmdW5jdGlvbihkZWNpbWFsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdHZhciBpbm5lcldpZHRoID0gbWUud2lkdGggLSAobWUucGFkZGluZ0xlZnQgKyBtZS5wYWRkaW5nUmlnaHQpO1xuXHRcdFx0dmFyIHZhbHVlT2Zmc2V0ID0gKGlubmVyV2lkdGggKiBkZWNpbWFsKSArIG1lLnBhZGRpbmdMZWZ0O1xuXG5cdFx0XHR2YXIgZmluYWxWYWwgPSBtZS5sZWZ0ICsgdmFsdWVPZmZzZXQ7XG5cdFx0XHRmaW5hbFZhbCArPSBtZS5pc0Z1bGxXaWR0aCgpID8gbWUubWFyZ2lucy5sZWZ0IDogMDtcblx0XHRcdHJldHVybiBmaW5hbFZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lLnRvcCArIChkZWNpbWFsICogbWUuaGVpZ2h0KTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcGl4ZWwgZm9yIHRoZSBtaW5pbXVtIGNoYXJ0IHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKi9cblx0Z2V0QmFzZVBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuXHR9LFxuXG5cdGdldEJhc2VWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWluID0gbWUubWluO1xuXHRcdHZhciBtYXggPSBtZS5tYXg7XG5cblx0XHRyZXR1cm4gbWUuYmVnaW5BdFplcm8gPyAwIDpcblx0XHRcdG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG5cdFx0XHRtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuXHRcdFx0MDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN1YnNldCBvZiB0aWNrcyB0byBiZSBwbG90dGVkIHRvIGF2b2lkIG92ZXJsYXBwaW5nIGxhYmVscy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9hdXRvU2tpcDogZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgb3B0aW9uVGlja3MgPSBtZS5vcHRpb25zLnRpY2tzLm1pbm9yO1xuXHRcdHZhciB0aWNrQ291bnQgPSB0aWNrcy5sZW5ndGg7XG5cdFx0dmFyIHNraXBSYXRpbyA9IGZhbHNlO1xuXHRcdHZhciBtYXhUaWNrcyA9IG9wdGlvblRpY2tzLm1heFRpY2tzTGltaXQ7XG5cblx0XHQvLyBUb3RhbCBzcGFjZSBuZWVkZWQgdG8gZGlzcGxheSBhbGwgdGlja3MuIEZpcnN0IGFuZCBsYXN0IHRpY2tzIGFyZVxuXHRcdC8vIGRyYXduIGFzIHRoZWlyIGNlbnRlciBhdCBlbmQgb2YgYXhpcywgc28gdGlja0NvdW50LTFcblx0XHR2YXIgdGlja3NMZW5ndGggPSBtZS5fdGlja1NpemUoKSAqICh0aWNrQ291bnQgLSAxKTtcblxuXHRcdC8vIEF4aXMgbGVuZ3RoXG5cdFx0dmFyIGF4aXNMZW5ndGggPSBpc0hvcml6b250YWxcblx0XHRcdD8gbWUud2lkdGggLSAobWUucGFkZGluZ0xlZnQgKyBtZS5wYWRkaW5nUmlnaHQpXG5cdFx0XHQ6IG1lLmhlaWdodCAtIChtZS5wYWRkaW5nVG9wICsgbWUuUGFkZGluZ0JvdHRvbSk7XG5cblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0dmFyIGksIHRpY2s7XG5cblx0XHRpZiAodGlja3NMZW5ndGggPiBheGlzTGVuZ3RoKSB7XG5cdFx0XHRza2lwUmF0aW8gPSAxICsgTWF0aC5mbG9vcih0aWNrc0xlbmd0aCAvIGF4aXNMZW5ndGgpO1xuXHRcdH1cblxuXHRcdC8vIGlmIHRoZXkgZGVmaW5lZCBhIG1heCBudW1iZXIgb2Ygb3B0aW9uVGlja3MsXG5cdFx0Ly8gaW5jcmVhc2Ugc2tpcFJhdGlvIHVudGlsIHRoYXQgbnVtYmVyIGlzIG1ldFxuXHRcdGlmICh0aWNrQ291bnQgPiBtYXhUaWNrcykge1xuXHRcdFx0c2tpcFJhdGlvID0gTWF0aC5tYXgoc2tpcFJhdGlvLCAxICsgTWF0aC5mbG9vcih0aWNrQ291bnQgLyBtYXhUaWNrcykpO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aWNrQ291bnQ7IGkrKykge1xuXHRcdFx0dGljayA9IHRpY2tzW2ldO1xuXG5cdFx0XHRpZiAoc2tpcFJhdGlvID4gMSAmJiBpICUgc2tpcFJhdGlvID4gMCkge1xuXHRcdFx0XHQvLyBsZWF2ZSB0aWNrIGluIHBsYWNlIGJ1dCBtYWtlIHN1cmUgaXQncyBub3QgZGlzcGxheWVkICgjNDYzNSlcblx0XHRcdFx0ZGVsZXRlIHRpY2subGFiZWw7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucHVzaCh0aWNrKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF90aWNrU2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcy5taW5vcjtcblxuXHRcdC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgYnkgbGFiZWwgaW4gYXhpcyBkaXJlY3Rpb24uXG5cdFx0dmFyIHJvdCA9IGhlbHBlcnMkMS50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG5cdFx0dmFyIGNvcyA9IE1hdGguYWJzKE1hdGguY29zKHJvdCkpO1xuXHRcdHZhciBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcblxuXHRcdHZhciBwYWRkaW5nID0gb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nIHx8IDA7XG5cdFx0dmFyIHcgPSAobWUubG9uZ2VzdExhYmVsV2lkdGggKyBwYWRkaW5nKSB8fCAwO1xuXG5cdFx0dmFyIHRpY2tGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRpb25UaWNrcyk7XG5cdFx0dmFyIGggPSAobWUuX21heExhYmVsTGluZXMgKiB0aWNrRm9udC5saW5lSGVpZ2h0ICsgcGFkZGluZykgfHwgMDtcblxuXHRcdC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgZm9yIDEgdGljayBpbiBheGlzIGRpcmVjdGlvbi5cblx0XHRyZXR1cm4gaXNIb3Jpem9udGFsXG5cdFx0XHQ/IGggKiBjb3MgPiB3ICogc2luID8gdyAvIGNvcyA6IGggLyBzaW5cblx0XHRcdDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9pc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRpc3BsYXkgPSBtZS5vcHRpb25zLmRpc3BsYXk7XG5cdFx0dmFyIGksIGlsZW4sIG1ldGE7XG5cblx0XHRpZiAoZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG5cdFx0XHRyZXR1cm4gISFkaXNwbGF5O1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gJ2F1dG8nLCB0aGUgc2NhbGUgaXMgdmlzaWJsZSBpZiBhdCBsZWFzdCBvbmUgYXNzb2NpYXRlZCBkYXRhc2V0IGlzIHZpc2libGUuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdGlmIChtZXRhLnhBeGlzSUQgPT09IG1lLmlkIHx8IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogQWN0dWFsbHkgZHJhdyB0aGUgc2NhbGUgb24gdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gY2hhcnRBcmVhIC0gdGhlIGFyZWEgb2YgdGhlIGNoYXJ0IHRvIGRyYXcgZnVsbCBncmlkIGxpbmVzIG9uXG5cdCAqL1xuXHRkcmF3OiBmdW5jdGlvbihjaGFydEFyZWEpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblxuXHRcdGlmICghbWUuX2lzVmlzaWJsZSgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGNvbnRleHQgPSBtZS5jdHg7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGRlZmF1bHRGb250Q29sb3IgPSBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udENvbG9yO1xuXHRcdHZhciBvcHRpb25UaWNrcyA9IG9wdGlvbnMudGlja3MubWlub3I7XG5cdFx0dmFyIG9wdGlvbk1ham9yVGlja3MgPSBvcHRpb25zLnRpY2tzLm1ham9yIHx8IG9wdGlvblRpY2tzO1xuXHRcdHZhciBncmlkTGluZXMgPSBvcHRpb25zLmdyaWRMaW5lcztcblx0XHR2YXIgc2NhbGVMYWJlbCA9IG9wdGlvbnMuc2NhbGVMYWJlbDtcblx0XHR2YXIgcG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuXG5cdFx0dmFyIGlzUm90YXRlZCA9IG1lLmxhYmVsUm90YXRpb24gIT09IDA7XG5cdFx0dmFyIGlzTWlycm9yZWQgPSBvcHRpb25UaWNrcy5taXJyb3I7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0dmFyIHBhcnNlRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQ7XG5cdFx0dmFyIHRpY2tzID0gb3B0aW9uVGlja3MuZGlzcGxheSAmJiBvcHRpb25UaWNrcy5hdXRvU2tpcCA/IG1lLl9hdXRvU2tpcChtZS5nZXRUaWNrcygpKSA6IG1lLmdldFRpY2tzKCk7XG5cdFx0dmFyIHRpY2tGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ5KG9wdGlvblRpY2tzLmZvbnRDb2xvciwgZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0dmFyIHRpY2tGb250ID0gcGFyc2VGb250KG9wdGlvblRpY2tzKTtcblx0XHR2YXIgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG5cdFx0dmFyIG1ham9yVGlja0ZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDkob3B0aW9uTWFqb3JUaWNrcy5mb250Q29sb3IsIGRlZmF1bHRGb250Q29sb3IpO1xuXHRcdHZhciBtYWpvclRpY2tGb250ID0gcGFyc2VGb250KG9wdGlvbk1ham9yVGlja3MpO1xuXHRcdHZhciB0aWNrUGFkZGluZyA9IG9wdGlvblRpY2tzLnBhZGRpbmc7XG5cdFx0dmFyIGxhYmVsT2Zmc2V0ID0gb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG5cblx0XHR2YXIgdGwgPSBncmlkTGluZXMuZHJhd1RpY2tzID8gZ3JpZExpbmVzLnRpY2tNYXJrTGVuZ3RoIDogMDtcblxuXHRcdHZhciBzY2FsZUxhYmVsRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkOShzY2FsZUxhYmVsLmZvbnRDb2xvciwgZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0dmFyIHNjYWxlTGFiZWxGb250ID0gcGFyc2VGb250KHNjYWxlTGFiZWwpO1xuXHRcdHZhciBzY2FsZUxhYmVsUGFkZGluZyA9IGhlbHBlcnMkMS5vcHRpb25zLnRvUGFkZGluZyhzY2FsZUxhYmVsLnBhZGRpbmcpO1xuXHRcdHZhciBsYWJlbFJvdGF0aW9uUmFkaWFucyA9IGhlbHBlcnMkMS50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG5cblx0XHR2YXIgaXRlbXNUb0RyYXcgPSBbXTtcblxuXHRcdHZhciBheGlzV2lkdGggPSBncmlkTGluZXMuZHJhd0JvcmRlciA/IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCAwLCAwKSA6IDA7XG5cdFx0dmFyIGFsaWduUGl4ZWwgPSBoZWxwZXJzJDEuX2FsaWduUGl4ZWw7XG5cdFx0dmFyIGJvcmRlclZhbHVlLCB0aWNrU3RhcnQsIHRpY2tFbmQ7XG5cblx0XHRpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLmJvdHRvbSwgYXhpc1dpZHRoKTtcblx0XHRcdHRpY2tTdGFydCA9IG1lLmJvdHRvbSAtIHRsO1xuXHRcdFx0dGlja0VuZCA9IGJvcmRlclZhbHVlIC0gYXhpc1dpZHRoIC8gMjtcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS50b3AsIGF4aXNXaWR0aCk7XG5cdFx0XHR0aWNrU3RhcnQgPSBib3JkZXJWYWx1ZSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHR0aWNrRW5kID0gbWUudG9wICsgdGw7XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLnJpZ2h0LCBheGlzV2lkdGgpO1xuXHRcdFx0dGlja1N0YXJ0ID0gbWUucmlnaHQgLSB0bDtcblx0XHRcdHRpY2tFbmQgPSBib3JkZXJWYWx1ZSAtIGF4aXNXaWR0aCAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25QaXhlbChjaGFydCwgbWUubGVmdCwgYXhpc1dpZHRoKTtcblx0XHRcdHRpY2tTdGFydCA9IGJvcmRlclZhbHVlICsgYXhpc1dpZHRoIC8gMjtcblx0XHRcdHRpY2tFbmQgPSBtZS5sZWZ0ICsgdGw7XG5cdFx0fVxuXG5cdFx0dmFyIGVwc2lsb24gPSAwLjAwMDAwMDE7IC8vIDAuMDAwMDAwMSBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBBY2N1bXVsYXRlZCBlcnJvci5cblxuXHRcdGhlbHBlcnMkMS5lYWNoKHRpY2tzLCBmdW5jdGlvbih0aWNrLCBpbmRleCkge1xuXHRcdFx0Ly8gYXV0b3NraXBwZXIgc2tpcHBlZCB0aGlzIHRpY2sgKCM0NjM1KVxuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRpY2subGFiZWwpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxhYmVsID0gdGljay5sYWJlbDtcblx0XHRcdHZhciBsaW5lV2lkdGgsIGxpbmVDb2xvciwgYm9yZGVyRGFzaCwgYm9yZGVyRGFzaE9mZnNldDtcblx0XHRcdGlmIChpbmRleCA9PT0gbWUuemVyb0xpbmVJbmRleCAmJiBvcHRpb25zLm9mZnNldCA9PT0gZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcykge1xuXHRcdFx0XHQvLyBEcmF3IHRoZSBmaXJzdCBpbmRleCBzcGVjaWFsbHlcblx0XHRcdFx0bGluZVdpZHRoID0gZ3JpZExpbmVzLnplcm9MaW5lV2lkdGg7XG5cdFx0XHRcdGxpbmVDb2xvciA9IGdyaWRMaW5lcy56ZXJvTGluZUNvbG9yO1xuXHRcdFx0XHRib3JkZXJEYXNoID0gZ3JpZExpbmVzLnplcm9MaW5lQm9yZGVyRGFzaCB8fCBbXTtcblx0XHRcdFx0Ym9yZGVyRGFzaE9mZnNldCA9IGdyaWRMaW5lcy56ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGluZVdpZHRoID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5saW5lV2lkdGgsIGluZGV4KTtcblx0XHRcdFx0bGluZUNvbG9yID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5jb2xvciwgaW5kZXgpO1xuXHRcdFx0XHRib3JkZXJEYXNoID0gZ3JpZExpbmVzLmJvcmRlckRhc2ggfHwgW107XG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBncmlkTGluZXMuYm9yZGVyRGFzaE9mZnNldCB8fCAwLjA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbW1vbiBwcm9wZXJ0aWVzXG5cdFx0XHR2YXIgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MiwgbGFiZWxYLCBsYWJlbFksIHRleHRPZmZzZXQsIHRleHRBbGlnbjtcblx0XHRcdHZhciBsYWJlbENvdW50ID0gaGVscGVycyQxLmlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcblx0XHRcdHZhciBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKG1lLCBpbmRleCwgZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcyk7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0dmFyIGxhYmVsWU9mZnNldCA9IHRsICsgdGlja1BhZGRpbmc7XG5cblx0XHRcdFx0aWYgKGxpbmVWYWx1ZSA8IG1lLmxlZnQgLSBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0bGluZUNvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHgxID0gdHgyID0geDEgPSB4MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcblx0XHRcdFx0dHkxID0gdGlja1N0YXJ0O1xuXHRcdFx0XHR0eTIgPSB0aWNrRW5kO1xuXHRcdFx0XHRsYWJlbFggPSBtZS5nZXRQaXhlbEZvclRpY2soaW5kZXgpICsgbGFiZWxPZmZzZXQ7IC8vIHggdmFsdWVzIGZvciBvcHRpb25UaWNrcyAobmVlZCB0byBjb25zaWRlciBvZmZzZXRMYWJlbCBvcHRpb24pXG5cblx0XHRcdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuXHRcdFx0XHRcdHkxID0gYWxpZ25QaXhlbChjaGFydCwgY2hhcnRBcmVhLnRvcCwgYXhpc1dpZHRoKSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHRcdFx0eTIgPSBjaGFydEFyZWEuYm90dG9tO1xuXHRcdFx0XHRcdHRleHRPZmZzZXQgPSAoKCFpc1JvdGF0ZWQgPyAwLjUgOiAxKSAtIGxhYmVsQ291bnQpICogbGluZUhlaWdodDtcblx0XHRcdFx0XHR0ZXh0QWxpZ24gPSAhaXNSb3RhdGVkID8gJ2NlbnRlcicgOiAnbGVmdCc7XG5cdFx0XHRcdFx0bGFiZWxZID0gbWUuYm90dG9tIC0gbGFiZWxZT2Zmc2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHkxID0gY2hhcnRBcmVhLnRvcDtcblx0XHRcdFx0XHR5MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS5ib3R0b20sIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuXHRcdFx0XHRcdHRleHRPZmZzZXQgPSAoIWlzUm90YXRlZCA/IDAuNSA6IDApICogbGluZUhlaWdodDtcblx0XHRcdFx0XHR0ZXh0QWxpZ24gPSAhaXNSb3RhdGVkID8gJ2NlbnRlcicgOiAncmlnaHQnO1xuXHRcdFx0XHRcdGxhYmVsWSA9IG1lLnRvcCArIGxhYmVsWU9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGxhYmVsWE9mZnNldCA9IChpc01pcnJvcmVkID8gMCA6IHRsKSArIHRpY2tQYWRkaW5nO1xuXG5cdFx0XHRcdGlmIChsaW5lVmFsdWUgPCBtZS50b3AgLSBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0bGluZUNvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHgxID0gdGlja1N0YXJ0O1xuXHRcdFx0XHR0eDIgPSB0aWNrRW5kO1xuXHRcdFx0XHR0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuXHRcdFx0XHRsYWJlbFkgPSBtZS5nZXRQaXhlbEZvclRpY2soaW5kZXgpICsgbGFiZWxPZmZzZXQ7XG5cdFx0XHRcdHRleHRPZmZzZXQgPSAoMSAtIGxhYmVsQ291bnQpICogbGluZUhlaWdodCAvIDI7XG5cblx0XHRcdFx0aWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcblx0XHRcdFx0XHR4MSA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS5sZWZ0LCBheGlzV2lkdGgpICsgYXhpc1dpZHRoIC8gMjtcblx0XHRcdFx0XHR4MiA9IGNoYXJ0QXJlYS5yaWdodDtcblx0XHRcdFx0XHR0ZXh0QWxpZ24gPSBpc01pcnJvcmVkID8gJ2xlZnQnIDogJ3JpZ2h0Jztcblx0XHRcdFx0XHRsYWJlbFggPSBtZS5yaWdodCAtIGxhYmVsWE9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuXHRcdFx0XHRcdHgyID0gYWxpZ25QaXhlbChjaGFydCwgY2hhcnRBcmVhLnJpZ2h0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcblx0XHRcdFx0XHR0ZXh0QWxpZ24gPSBpc01pcnJvcmVkID8gJ3JpZ2h0JyA6ICdsZWZ0Jztcblx0XHRcdFx0XHRsYWJlbFggPSBtZS5sZWZ0ICsgbGFiZWxYT2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGl0ZW1zVG9EcmF3LnB1c2goe1xuXHRcdFx0XHR0eDE6IHR4MSxcblx0XHRcdFx0dHkxOiB0eTEsXG5cdFx0XHRcdHR4MjogdHgyLFxuXHRcdFx0XHR0eTI6IHR5Mixcblx0XHRcdFx0eDE6IHgxLFxuXHRcdFx0XHR5MTogeTEsXG5cdFx0XHRcdHgyOiB4Mixcblx0XHRcdFx0eTI6IHkyLFxuXHRcdFx0XHRsYWJlbFg6IGxhYmVsWCxcblx0XHRcdFx0bGFiZWxZOiBsYWJlbFksXG5cdFx0XHRcdGdsV2lkdGg6IGxpbmVXaWR0aCxcblx0XHRcdFx0Z2xDb2xvcjogbGluZUNvbG9yLFxuXHRcdFx0XHRnbEJvcmRlckRhc2g6IGJvcmRlckRhc2gsXG5cdFx0XHRcdGdsQm9yZGVyRGFzaE9mZnNldDogYm9yZGVyRGFzaE9mZnNldCxcblx0XHRcdFx0cm90YXRpb246IC0xICogbGFiZWxSb3RhdGlvblJhZGlhbnMsXG5cdFx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdFx0bWFqb3I6IHRpY2subWFqb3IsXG5cdFx0XHRcdHRleHRPZmZzZXQ6IHRleHRPZmZzZXQsXG5cdFx0XHRcdHRleHRBbGlnbjogdGV4dEFsaWduXG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdC8vIERyYXcgYWxsIG9mIHRoZSB0aWNrIGxhYmVscywgdGljayBtYXJrcywgYW5kIGdyaWQgbGluZXMgYXQgdGhlIGNvcnJlY3QgcGxhY2VzXG5cdFx0aGVscGVycyQxLmVhY2goaXRlbXNUb0RyYXcsIGZ1bmN0aW9uKGl0ZW1Ub0RyYXcpIHtcblx0XHRcdHZhciBnbFdpZHRoID0gaXRlbVRvRHJhdy5nbFdpZHRoO1xuXHRcdFx0dmFyIGdsQ29sb3IgPSBpdGVtVG9EcmF3LmdsQ29sb3I7XG5cblx0XHRcdGlmIChncmlkTGluZXMuZGlzcGxheSAmJiBnbFdpZHRoICYmIGdsQ29sb3IpIHtcblx0XHRcdFx0Y29udGV4dC5zYXZlKCk7XG5cdFx0XHRcdGNvbnRleHQubGluZVdpZHRoID0gZ2xXaWR0aDtcblx0XHRcdFx0Y29udGV4dC5zdHJva2VTdHlsZSA9IGdsQ29sb3I7XG5cdFx0XHRcdGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG5cdFx0XHRcdFx0Y29udGV4dC5zZXRMaW5lRGFzaChpdGVtVG9EcmF3LmdsQm9yZGVyRGFzaCk7XG5cdFx0XHRcdFx0Y29udGV4dC5saW5lRGFzaE9mZnNldCA9IGl0ZW1Ub0RyYXcuZ2xCb3JkZXJEYXNoT2Zmc2V0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29udGV4dC5iZWdpblBhdGgoKTtcblxuXHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdUaWNrcykge1xuXHRcdFx0XHRcdGNvbnRleHQubW92ZVRvKGl0ZW1Ub0RyYXcudHgxLCBpdGVtVG9EcmF3LnR5MSk7XG5cdFx0XHRcdFx0Y29udGV4dC5saW5lVG8oaXRlbVRvRHJhdy50eDIsIGl0ZW1Ub0RyYXcudHkyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChncmlkTGluZXMuZHJhd09uQ2hhcnRBcmVhKSB7XG5cdFx0XHRcdFx0Y29udGV4dC5tb3ZlVG8oaXRlbVRvRHJhdy54MSwgaXRlbVRvRHJhdy55MSk7XG5cdFx0XHRcdFx0Y29udGV4dC5saW5lVG8oaXRlbVRvRHJhdy54MiwgaXRlbVRvRHJhdy55Mik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0XHRjb250ZXh0LnJlc3RvcmUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvblRpY2tzLmRpc3BsYXkpIHtcblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGRyYXcgdGV4dCBpbiB0aGUgY29ycmVjdCBjb2xvciBhbmQgZm9udFxuXHRcdFx0XHRjb250ZXh0LnNhdmUoKTtcblx0XHRcdFx0Y29udGV4dC50cmFuc2xhdGUoaXRlbVRvRHJhdy5sYWJlbFgsIGl0ZW1Ub0RyYXcubGFiZWxZKTtcblx0XHRcdFx0Y29udGV4dC5yb3RhdGUoaXRlbVRvRHJhdy5yb3RhdGlvbik7XG5cdFx0XHRcdGNvbnRleHQuZm9udCA9IGl0ZW1Ub0RyYXcubWFqb3IgPyBtYWpvclRpY2tGb250LnN0cmluZyA6IHRpY2tGb250LnN0cmluZztcblx0XHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSBpdGVtVG9EcmF3Lm1ham9yID8gbWFqb3JUaWNrRm9udENvbG9yIDogdGlja0ZvbnRDb2xvcjtcblx0XHRcdFx0Y29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdFx0Y29udGV4dC50ZXh0QWxpZ24gPSBpdGVtVG9EcmF3LnRleHRBbGlnbjtcblxuXHRcdFx0XHR2YXIgbGFiZWwgPSBpdGVtVG9EcmF3LmxhYmVsO1xuXHRcdFx0XHR2YXIgeSA9IGl0ZW1Ub0RyYXcudGV4dE9mZnNldDtcblx0XHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGxhYmVsKSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWwubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRcdC8vIFdlIGp1c3QgbWFrZSBzdXJlIHRoZSBtdWx0aWxpbmUgZWxlbWVudCBpcyBhIHN0cmluZyBoZXJlLi5cblx0XHRcdFx0XHRcdGNvbnRleHQuZmlsbFRleHQoJycgKyBsYWJlbFtpXSwgMCwgeSk7XG5cdFx0XHRcdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRleHQuZmlsbFRleHQobGFiZWwsIDAsIHkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRleHQucmVzdG9yZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKHNjYWxlTGFiZWwuZGlzcGxheSkge1xuXHRcdFx0Ly8gRHJhdyB0aGUgc2NhbGUgbGFiZWxcblx0XHRcdHZhciBzY2FsZUxhYmVsWDtcblx0XHRcdHZhciBzY2FsZUxhYmVsWTtcblx0XHRcdHZhciByb3RhdGlvbiA9IDA7XG5cdFx0XHR2YXIgaGFsZkxpbmVIZWlnaHQgPSBzY2FsZUxhYmVsRm9udC5saW5lSGVpZ2h0IC8gMjtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRzY2FsZUxhYmVsWCA9IG1lLmxlZnQgKyAoKG1lLnJpZ2h0IC0gbWUubGVmdCkgLyAyKTsgLy8gbWlkcG9pbnQgb2YgdGhlIHdpZHRoXG5cdFx0XHRcdHNjYWxlTGFiZWxZID0gcG9zaXRpb24gPT09ICdib3R0b20nXG5cdFx0XHRcdFx0PyBtZS5ib3R0b20gLSBoYWxmTGluZUhlaWdodCAtIHNjYWxlTGFiZWxQYWRkaW5nLmJvdHRvbVxuXHRcdFx0XHRcdDogbWUudG9wICsgaGFsZkxpbmVIZWlnaHQgKyBzY2FsZUxhYmVsUGFkZGluZy50b3A7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgaXNMZWZ0ID0gcG9zaXRpb24gPT09ICdsZWZ0Jztcblx0XHRcdFx0c2NhbGVMYWJlbFggPSBpc0xlZnRcblx0XHRcdFx0XHQ/IG1lLmxlZnQgKyBoYWxmTGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLnRvcFxuXHRcdFx0XHRcdDogbWUucmlnaHQgLSBoYWxmTGluZUhlaWdodCAtIHNjYWxlTGFiZWxQYWRkaW5nLnRvcDtcblx0XHRcdFx0c2NhbGVMYWJlbFkgPSBtZS50b3AgKyAoKG1lLmJvdHRvbSAtIG1lLnRvcCkgLyAyKTtcblx0XHRcdFx0cm90YXRpb24gPSBpc0xlZnQgPyAtMC41ICogTWF0aC5QSSA6IDAuNSAqIE1hdGguUEk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0Y29udGV4dC50cmFuc2xhdGUoc2NhbGVMYWJlbFgsIHNjYWxlTGFiZWxZKTtcblx0XHRcdGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcblx0XHRcdGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSBzY2FsZUxhYmVsRm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblx0XHRcdGNvbnRleHQuZm9udCA9IHNjYWxlTGFiZWxGb250LnN0cmluZztcblx0XHRcdGNvbnRleHQuZmlsbFRleHQoc2NhbGVMYWJlbC5sYWJlbFN0cmluZywgMCwgMCk7XG5cdFx0XHRjb250ZXh0LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHRpZiAoYXhpc1dpZHRoKSB7XG5cdFx0XHQvLyBEcmF3IHRoZSBsaW5lIGF0IHRoZSBlZGdlIG9mIHRoZSBheGlzXG5cdFx0XHR2YXIgZmlyc3RMaW5lV2lkdGggPSBheGlzV2lkdGg7XG5cdFx0XHR2YXIgbGFzdExpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCB0aWNrcy5sZW5ndGggLSAxLCAwKTtcblx0XHRcdHZhciB4MSwgeDIsIHkxLCB5MjtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHR4MSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLmxlZnQsIGZpcnN0TGluZVdpZHRoKSAtIGZpcnN0TGluZVdpZHRoIC8gMjtcblx0XHRcdFx0eDIgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcblx0XHRcdFx0eTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eTEgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS50b3AsIGZpcnN0TGluZVdpZHRoKSAtIGZpcnN0TGluZVdpZHRoIC8gMjtcblx0XHRcdFx0eTIgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5ib3R0b20sIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHgxID0geDIgPSBib3JkZXJWYWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGV4dC5saW5lV2lkdGggPSBheGlzV2lkdGg7XG5cdFx0XHRjb250ZXh0LnN0cm9rZVN0eWxlID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5jb2xvciwgMCk7XG5cdFx0XHRjb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y29udGV4dC5tb3ZlVG8oeDEsIHkxKTtcblx0XHRcdGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG5cdFx0XHRjb250ZXh0LnN0cm9rZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuXHRwb3NpdGlvbjogJ2JvdHRvbSdcbn07XG5cbnZhciBzY2FsZV9jYXRlZ29yeSA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0LyoqXG5cdCogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2V0IHRoZSBjb3JyZWN0IGxhYmVscy4gSWYgZGF0YS54TGFiZWxzIG9yIGRhdGEueUxhYmVscyBhcmUgZGVmaW5lZCwgdXNlIHRob3NlXG5cdCogZWxzZSBmYWxsIGJhY2sgdG8gZGF0YS5sYWJlbHNcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRMYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscztcblx0fSxcblxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcblx0XHRtZS5taW5JbmRleCA9IDA7XG5cdFx0bWUubWF4SW5kZXggPSBsYWJlbHMubGVuZ3RoIC0gMTtcblx0XHR2YXIgZmluZEluZGV4O1xuXG5cdFx0aWYgKG1lLm9wdGlvbnMudGlja3MubWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIHVzZXIgc3BlY2lmaWVkIG1pbiB2YWx1ZVxuXHRcdFx0ZmluZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWUub3B0aW9ucy50aWNrcy5taW4pO1xuXHRcdFx0bWUubWluSW5kZXggPSBmaW5kSW5kZXggIT09IC0xID8gZmluZEluZGV4IDogbWUubWluSW5kZXg7XG5cdFx0fVxuXG5cdFx0aWYgKG1lLm9wdGlvbnMudGlja3MubWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIHVzZXIgc3BlY2lmaWVkIG1heCB2YWx1ZVxuXHRcdFx0ZmluZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWUub3B0aW9ucy50aWNrcy5tYXgpO1xuXHRcdFx0bWUubWF4SW5kZXggPSBmaW5kSW5kZXggIT09IC0xID8gZmluZEluZGV4IDogbWUubWF4SW5kZXg7XG5cdFx0fVxuXG5cdFx0bWUubWluID0gbGFiZWxzW21lLm1pbkluZGV4XTtcblx0XHRtZS5tYXggPSBsYWJlbHNbbWUubWF4SW5kZXhdO1xuXHR9LFxuXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGxhYmVscyA9IG1lLmdldExhYmVscygpO1xuXHRcdC8vIElmIHdlIGFyZSB2aWV3aW5nIHNvbWUgc3Vic2V0IG9mIGxhYmVscywgc2xpY2UgdGhlIG9yaWdpbmFsIGFycmF5XG5cdFx0bWUudGlja3MgPSAobWUubWluSW5kZXggPT09IDAgJiYgbWUubWF4SW5kZXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtZS5taW5JbmRleCwgbWUubWF4SW5kZXggKyAxKTtcblx0fSxcblxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblxuXHRcdGlmIChjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuX2dldFZhbHVlU2NhbGVJZCgpID09PSBtZS5pZCkge1xuXHRcdFx0cmV0dXJuIG1lLmdldFJpZ2h0VmFsdWUoY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWUudGlja3NbaW5kZXggLSBtZS5taW5JbmRleF07XG5cdH0sXG5cblx0Ly8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuICBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9mZnNldCA9IG1lLm9wdGlvbnMub2Zmc2V0O1xuXHRcdC8vIDEgaXMgYWRkZWQgYmVjYXVzZSB3ZSBuZWVkIHRoZSBsZW5ndGggYnV0IHdlIGhhdmUgdGhlIGluZGV4ZXNcblx0XHR2YXIgb2Zmc2V0QW10ID0gTWF0aC5tYXgoKG1lLm1heEluZGV4ICsgMSAtIG1lLm1pbkluZGV4IC0gKG9mZnNldCA/IDAgOiAxKSksIDEpO1xuXG5cdFx0Ly8gSWYgdmFsdWUgaXMgYSBkYXRhIG9iamVjdCwgdGhlbiBpbmRleCBpcyB0aGUgaW5kZXggaW4gdGhlIGRhdGEgYXJyYXksXG5cdFx0Ly8gbm90IHRoZSBpbmRleCBvZiB0aGUgc2NhbGUuIFdlIG5lZWQgdG8gY2hhbmdlIHRoYXQuXG5cdFx0dmFyIHZhbHVlQ2F0ZWdvcnk7XG5cdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcblx0XHRcdHZhbHVlQ2F0ZWdvcnkgPSBtZS5pc0hvcml6b250YWwoKSA/IHZhbHVlLnggOiB2YWx1ZS55O1xuXHRcdH1cblx0XHRpZiAodmFsdWVDYXRlZ29yeSAhPT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGlzTmFOKGluZGV4KSkpIHtcblx0XHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcblx0XHRcdHZhbHVlID0gdmFsdWVDYXRlZ29yeSB8fCB2YWx1ZTtcblx0XHRcdHZhciBpZHggPSBsYWJlbHMuaW5kZXhPZih2YWx1ZSk7XG5cdFx0XHRpbmRleCA9IGlkeCAhPT0gLTEgPyBpZHggOiBpbmRleDtcblx0XHR9XG5cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdHZhciB2YWx1ZVdpZHRoID0gbWUud2lkdGggLyBvZmZzZXRBbXQ7XG5cdFx0XHR2YXIgd2lkdGhPZmZzZXQgPSAodmFsdWVXaWR0aCAqIChpbmRleCAtIG1lLm1pbkluZGV4KSk7XG5cblx0XHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdFx0d2lkdGhPZmZzZXQgKz0gKHZhbHVlV2lkdGggLyAyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lLmxlZnQgKyB3aWR0aE9mZnNldDtcblx0XHR9XG5cdFx0dmFyIHZhbHVlSGVpZ2h0ID0gbWUuaGVpZ2h0IC8gb2Zmc2V0QW10O1xuXHRcdHZhciBoZWlnaHRPZmZzZXQgPSAodmFsdWVIZWlnaHQgKiAoaW5kZXggLSBtZS5taW5JbmRleCkpO1xuXG5cdFx0aWYgKG9mZnNldCkge1xuXHRcdFx0aGVpZ2h0T2Zmc2V0ICs9ICh2YWx1ZUhlaWdodCAvIDIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZS50b3AgKyBoZWlnaHRPZmZzZXQ7XG5cdH0sXG5cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy50aWNrc1tpbmRleF0sIGluZGV4ICsgdGhpcy5taW5JbmRleCwgbnVsbCk7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG9mZnNldEFtdCA9IE1hdGgubWF4KChtZS5fdGlja3MubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSksIDEpO1xuXHRcdHZhciBob3J6ID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIHZhbHVlRGltZW5zaW9uID0gKGhvcnogPyBtZS53aWR0aCA6IG1lLmhlaWdodCkgLyBvZmZzZXRBbXQ7XG5cblx0XHRwaXhlbCAtPSBob3J6ID8gbWUubGVmdCA6IG1lLnRvcDtcblxuXHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdHBpeGVsIC09ICh2YWx1ZURpbWVuc2lvbiAvIDIpO1xuXHRcdH1cblxuXHRcdGlmIChwaXhlbCA8PSAwKSB7XG5cdFx0XHR2YWx1ZSA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlID0gTWF0aC5yb3VuZChwaXhlbCAvIHZhbHVlRGltZW5zaW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWUgKyBtZS5taW5JbmRleDtcblx0fSxcblxuXHRnZXRCYXNlUGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmJvdHRvbTtcblx0fVxufSk7XG5cbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xudmFyIF9kZWZhdWx0cyA9IGRlZmF1bHRDb25maWc7XG5zY2FsZV9jYXRlZ29yeS5fZGVmYXVsdHMgPSBfZGVmYXVsdHM7XG5cbnZhciBub29wID0gaGVscGVycyQxLm5vb3A7XG52YXIgaXNOdWxsT3JVbmRlZiA9IGhlbHBlcnMkMS5pc051bGxPclVuZGVmO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxpbmVhciB0aWNrc1xuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge251bWJlcltdfSBhcnJheSBvZiB0aWNrIHZhbHVlc1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcblx0dmFyIHRpY2tzID0gW107XG5cdC8vIFRvIGdldCBhIFwibmljZVwiIHZhbHVlIGZvciB0aGUgdGljayBzcGFjaW5nLCB3ZSB3aWxsIHVzZSB0aGUgYXBwcm9wcmlhdGVseSBuYW1lZFxuXHQvLyBcIm5pY2UgbnVtYmVyXCIgYWxnb3JpdGhtLiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNjg4MS9uaWNlLWxhYmVsLWFsZ29yaXRobS1mb3ItY2hhcnRzLXdpdGgtbWluaW11bS10aWNrc1xuXHQvLyBmb3IgZGV0YWlscy5cblxuXHR2YXIgTUlOX1NQQUNJTkcgPSAxZS0xNDtcblx0dmFyIHN0ZXBTaXplID0gZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcFNpemU7XG5cdHZhciB1bml0ID0gc3RlcFNpemUgfHwgMTtcblx0dmFyIG1heE51bVNwYWNlcyA9IGdlbmVyYXRpb25PcHRpb25zLm1heFRpY2tzIC0gMTtcblx0dmFyIG1pbiA9IGdlbmVyYXRpb25PcHRpb25zLm1pbjtcblx0dmFyIG1heCA9IGdlbmVyYXRpb25PcHRpb25zLm1heDtcblx0dmFyIHByZWNpc2lvbiA9IGdlbmVyYXRpb25PcHRpb25zLnByZWNpc2lvbjtcblx0dmFyIHJtaW4gPSBkYXRhUmFuZ2UubWluO1xuXHR2YXIgcm1heCA9IGRhdGFSYW5nZS5tYXg7XG5cdHZhciBzcGFjaW5nID0gaGVscGVycyQxLm5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heE51bVNwYWNlcyAvIHVuaXQpICogdW5pdDtcblx0dmFyIGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xuXG5cdC8vIEJleW9uZCBNSU5fU1BBQ0lORyBmbG9hdGluZyBwb2ludCBudW1iZXJzIGJlaW5nIHRvIGxvc2UgcHJlY2lzaW9uXG5cdC8vIHN1Y2ggdGhhdCB3ZSBjYW4ndCBkbyB0aGUgbWF0aCBuZWNlc3NhcnkgdG8gZ2VuZXJhdGUgdGlja3Ncblx0aWYgKHNwYWNpbmcgPCBNSU5fU1BBQ0lORyAmJiBpc051bGxPclVuZGVmKG1pbikgJiYgaXNOdWxsT3JVbmRlZihtYXgpKSB7XG5cdFx0cmV0dXJuIFtybWluLCBybWF4XTtcblx0fVxuXG5cdG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcblx0aWYgKG51bVNwYWNlcyA+IG1heE51bVNwYWNlcykge1xuXHRcdC8vIElmIHRoZSBjYWxjdWxhdGVkIG51bSBvZiBzcGFjZXMgZXhjZWVkcyBtYXhOdW1TcGFjZXMsIHJlY2FsY3VsYXRlIGl0XG5cdFx0c3BhY2luZyA9IGhlbHBlcnMkMS5uaWNlTnVtKG51bVNwYWNlcyAqIHNwYWNpbmcgLyBtYXhOdW1TcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG5cdH1cblxuXHRpZiAoc3RlcFNpemUgfHwgaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG5cdFx0Ly8gSWYgYSBwcmVjaXNpb24gaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIGZhY3RvciBiYXNlZCBvbiBzcGFjaW5nXG5cdFx0ZmFjdG9yID0gTWF0aC5wb3coMTAsIGhlbHBlcnMkMS5fZGVjaW1hbFBsYWNlcyhzcGFjaW5nKSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgcHJlY2lzaW9uLCByb3VuZCB0byB0aGF0IG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuXHRcdGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuXHRcdHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG5cdH1cblxuXHRuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xuXHRuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG5cblx0Ly8gSWYgbWluLCBtYXggYW5kIHN0ZXBTaXplIGlzIHNldCBhbmQgdGhleSBtYWtlIGFuIGV2ZW5seSBzcGFjZWQgc2NhbGUgdXNlIGl0LlxuXHRpZiAoc3RlcFNpemUpIHtcblx0XHQvLyBJZiB2ZXJ5IGNsb3NlIHRvIG91ciB3aG9sZSBudW1iZXIsIHVzZSBpdC5cblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYobWluKSAmJiBoZWxwZXJzJDEuYWxtb3N0V2hvbGUobWluIC8gc3BhY2luZywgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0XHRuaWNlTWluID0gbWluO1xuXHRcdH1cblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYobWF4KSAmJiBoZWxwZXJzJDEuYWxtb3N0V2hvbGUobWF4IC8gc3BhY2luZywgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0XHRuaWNlTWF4ID0gbWF4O1xuXHRcdH1cblx0fVxuXG5cdG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xuXHQvLyBJZiB2ZXJ5IGNsb3NlIHRvIG91ciByb3VuZGVkIHZhbHVlLCB1c2UgaXQuXG5cdGlmIChoZWxwZXJzJDEuYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcblx0XHRudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG5cdH0gZWxzZSB7XG5cdFx0bnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG5cdH1cblxuXHRuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3Rvcjtcblx0bmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG5cdHRpY2tzLnB1c2goaXNOdWxsT3JVbmRlZihtaW4pID8gbmljZU1pbiA6IG1pbik7XG5cdGZvciAodmFyIGogPSAxOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcblx0XHR0aWNrcy5wdXNoKE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yKTtcblx0fVxuXHR0aWNrcy5wdXNoKGlzTnVsbE9yVW5kZWYobWF4KSA/IG5pY2VNYXggOiBtYXgpO1xuXG5cdHJldHVybiB0aWNrcztcbn1cblxudmFyIHNjYWxlX2xpbmVhcmJhc2UgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XG5cdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiArdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS5nZXRSaWdodFZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuXHR9LFxuXG5cdGhhbmRsZVRpY2tSYW5nZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHQvLyBJZiB3ZSBhcmUgZm9yY2luZyBpdCB0byBiZWdpbiBhdCAwLCBidXQgMCB3aWxsIGFscmVhZHkgYmUgcmVuZGVyZWQgb24gdGhlIGNoYXJ0LFxuXHRcdC8vIGRvIG5vdGhpbmcgc2luY2UgdGhhdCB3b3VsZCBtYWtlIHRoZSBjaGFydCB3ZWlyZC4gSWYgdGhlIHVzZXIgcmVhbGx5IHdhbnRzIGEgd2VpcmQgY2hhcnRcblx0XHQvLyBheGlzLCB0aGV5IGNhbiBtYW51YWxseSBvdmVycmlkZSBpdFxuXHRcdGlmICh0aWNrT3B0cy5iZWdpbkF0WmVybykge1xuXHRcdFx0dmFyIG1pblNpZ24gPSBoZWxwZXJzJDEuc2lnbihtZS5taW4pO1xuXHRcdFx0dmFyIG1heFNpZ24gPSBoZWxwZXJzJDEuc2lnbihtZS5tYXgpO1xuXG5cdFx0XHRpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcblx0XHRcdFx0Ly8gbW92ZSB0aGUgdG9wIHVwIHRvIDBcblx0XHRcdFx0bWUubWF4ID0gMDtcblx0XHRcdH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcblx0XHRcdFx0Ly8gbW92ZSB0aGUgYm90dG9tIGRvd24gdG8gMFxuXHRcdFx0XHRtZS5taW4gPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBzZXRNaW4gPSB0aWNrT3B0cy5taW4gIT09IHVuZGVmaW5lZCB8fCB0aWNrT3B0cy5zdWdnZXN0ZWRNaW4gIT09IHVuZGVmaW5lZDtcblx0XHR2YXIgc2V0TWF4ID0gdGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWF4ICE9PSB1bmRlZmluZWQ7XG5cblx0XHRpZiAodGlja09wdHMubWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdG1lLm1pbiA9IHRpY2tPcHRzLm1pbjtcblx0XHR9IGVsc2UgaWYgKHRpY2tPcHRzLnN1Z2dlc3RlZE1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdG1lLm1pbiA9IHRpY2tPcHRzLnN1Z2dlc3RlZE1pbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1pbiA9IE1hdGgubWluKG1lLm1pbiwgdGlja09wdHMuc3VnZ2VzdGVkTWluKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdG1lLm1heCA9IHRpY2tPcHRzLm1heDtcblx0XHR9IGVsc2UgaWYgKHRpY2tPcHRzLnN1Z2dlc3RlZE1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRcdG1lLm1heCA9IHRpY2tPcHRzLnN1Z2dlc3RlZE1heDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1heCA9IE1hdGgubWF4KG1lLm1heCwgdGlja09wdHMuc3VnZ2VzdGVkTWF4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoc2V0TWluICE9PSBzZXRNYXgpIHtcblx0XHRcdC8vIFdlIHNldCB0aGUgbWluIG9yIHRoZSBtYXggYnV0IG5vdCBib3RoLlxuXHRcdFx0Ly8gU28gZW5zdXJlIHRoYXQgb3VyIHJhbmdlIGlzIGdvb2Rcblx0XHRcdC8vIEludmVydGVkIG9yIDAgbGVuZ3RoIHJhbmdlIGNhbiBoYXBwZW4gd2hlblxuXHRcdFx0Ly8gdGlja3MubWluIGlzIHNldCwgYW5kIG5vIGRhdGFzZXRzIGFyZSB2aXNpYmxlXG5cdFx0XHRpZiAobWUubWluID49IG1lLm1heCkge1xuXHRcdFx0XHRpZiAoc2V0TWluKSB7XG5cdFx0XHRcdFx0bWUubWF4ID0gbWUubWluICsgMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtZS5taW4gPSBtZS5tYXggLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1lLm1pbiA9PT0gbWUubWF4KSB7XG5cdFx0XHRtZS5tYXgrKztcblxuXHRcdFx0aWYgKCF0aWNrT3B0cy5iZWdpbkF0WmVybykge1xuXHRcdFx0XHRtZS5taW4tLTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0VGlja0xpbWl0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIHN0ZXBTaXplID0gdGlja09wdHMuc3RlcFNpemU7XG5cdFx0dmFyIG1heFRpY2tzTGltaXQgPSB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0O1xuXHRcdHZhciBtYXhUaWNrcztcblxuXHRcdGlmIChzdGVwU2l6ZSkge1xuXHRcdFx0bWF4VGlja3MgPSBNYXRoLmNlaWwobWUubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcihtZS5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXhUaWNrcyA9IG1lLl9jb21wdXRlVGlja0xpbWl0KCk7XG5cdFx0XHRtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcblx0XHR9XG5cblx0XHRpZiAobWF4VGlja3NMaW1pdCkge1xuXHRcdFx0bWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1heFRpY2tzO1xuXHR9LFxuXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHR9LFxuXG5cdGhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlczogbm9vcCxcblxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG5cdFx0Ly8gRmlndXJlIG91dCB3aGF0IHRoZSBtYXggbnVtYmVyIG9mIHRpY2tzIHdlIGNhbiBzdXBwb3J0IGl0IGlzIGJhc2VkIG9uIHRoZSBzaXplIG9mXG5cdFx0Ly8gdGhlIGF4aXMgYXJlYS4gRm9yIG5vdywgd2Ugc2F5IHRoYXQgdGhlIG1pbmltdW0gdGljayBzcGFjaW5nIGluIHBpeGVscyBtdXN0IGJlIDQwXG5cdFx0Ly8gV2UgYWxzbyBsaW1pdCB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgdG8gMTEgd2hpY2ggZ2l2ZXMgYSBuaWNlIDEwIHNxdWFyZXMgb25cblx0XHQvLyB0aGUgZ3JhcGguIE1ha2Ugc3VyZSB3ZSBhbHdheXMgaGF2ZSBhdCBsZWFzdCAyIHRpY2tzXG5cdFx0dmFyIG1heFRpY2tzID0gbWUuZ2V0VGlja0xpbWl0KCk7XG5cdFx0bWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG5cblx0XHR2YXIgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG5cdFx0XHRtYXhUaWNrczogbWF4VGlja3MsXG5cdFx0XHRtaW46IHRpY2tPcHRzLm1pbixcblx0XHRcdG1heDogdGlja09wdHMubWF4LFxuXHRcdFx0cHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG5cdFx0XHRzdGVwU2l6ZTogaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZpeGVkU3RlcFNpemUsIHRpY2tPcHRzLnN0ZXBTaXplKVxuXHRcdH07XG5cdFx0dmFyIHRpY2tzID0gbWUudGlja3MgPSBnZW5lcmF0ZVRpY2tzKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBtZSk7XG5cblx0XHRtZS5oYW5kbGVEaXJlY3Rpb25hbENoYW5nZXMoKTtcblxuXHRcdC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMgc2luY2Ugd2UgaGF2ZSBleHBhbmRlZCB0aGVcblx0XHQvLyByYW5nZSBvZiB0aGUgc2NhbGVcblx0XHRtZS5tYXggPSBoZWxwZXJzJDEubWF4KHRpY2tzKTtcblx0XHRtZS5taW4gPSBoZWxwZXJzJDEubWluKHRpY2tzKTtcblxuXHRcdGlmICh0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHR0aWNrcy5yZXZlcnNlKCk7XG5cblx0XHRcdG1lLnN0YXJ0ID0gbWUubWF4O1xuXHRcdFx0bWUuZW5kID0gbWUubWluO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5zdGFydCA9IG1lLm1pbjtcblx0XHRcdG1lLmVuZCA9IG1lLm1heDtcblx0XHR9XG5cdH0sXG5cblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0bWUudGlja3NBc051bWJlcnMgPSBtZS50aWNrcy5zbGljZSgpO1xuXHRcdG1lLnplcm9MaW5lSW5kZXggPSBtZS50aWNrcy5pbmRleE9mKDApO1xuXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XG5cdH1cbn0pO1xuXG52YXIgZGVmYXVsdENvbmZpZyQxID0ge1xuXHRwb3NpdGlvbjogJ2xlZnQnLFxuXHR0aWNrczoge1xuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdH1cbn07XG5cbnZhciBzY2FsZV9saW5lYXIgPSBzY2FsZV9saW5lYXJiYXNlLmV4dGVuZCh7XG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgREVGQVVMVF9NSU4gPSAwO1xuXHRcdHZhciBERUZBVUxUX01BWCA9IDE7XG5cblx0XHRmdW5jdGlvbiBJRE1hdGNoZXMobWV0YSkge1xuXHRcdFx0cmV0dXJuIGlzSG9yaXpvbnRhbCA/IG1ldGEueEF4aXNJRCA9PT0gbWUuaWQgOiBtZXRhLnlBeGlzSUQgPT09IG1lLmlkO1xuXHRcdH1cblxuXHRcdC8vIEZpcnN0IENhbGN1bGF0ZSB0aGUgcmFuZ2Vcblx0XHRtZS5taW4gPSBudWxsO1xuXHRcdG1lLm1heCA9IG51bGw7XG5cblx0XHR2YXIgaGFzU3RhY2tzID0gb3B0cy5zdGFja2VkO1xuXHRcdGlmIChoYXNTdGFja3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHRpZiAoaGFzU3RhY2tzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSAmJlxuXHRcdFx0XHRcdG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGhhc1N0YWNrcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChvcHRzLnN0YWNrZWQgfHwgaGFzU3RhY2tzKSB7XG5cdFx0XHR2YXIgdmFsdWVzUGVyU3RhY2sgPSB7fTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdHZhciBrZXkgPSBbXG5cdFx0XHRcdFx0bWV0YS50eXBlLFxuXHRcdFx0XHRcdC8vIHdlIGhhdmUgYSBzZXBhcmF0ZSBzdGFjayBmb3Igc3RhY2s9dW5kZWZpbmVkIGRhdGFzZXRzIHdoZW4gdGhlIG9wdHMuc3RhY2tlZCBpcyB1bmRlZmluZWRcblx0XHRcdFx0XHQoKG9wdHMuc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkgPyBkYXRhc2V0SW5kZXggOiAnJyksXG5cdFx0XHRcdFx0bWV0YS5zdGFja1xuXHRcdFx0XHRdLmpvaW4oJy4nKTtcblxuXHRcdFx0XHRpZiAodmFsdWVzUGVyU3RhY2tba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dmFsdWVzUGVyU3RhY2tba2V5XSA9IHtcblx0XHRcdFx0XHRcdHBvc2l0aXZlVmFsdWVzOiBbXSxcblx0XHRcdFx0XHRcdG5lZ2F0aXZlVmFsdWVzOiBbXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdG9yZSB0aGVzZSBwZXIgdHlwZVxuXHRcdFx0XHR2YXIgcG9zaXRpdmVWYWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldLnBvc2l0aXZlVmFsdWVzO1xuXHRcdFx0XHR2YXIgbmVnYXRpdmVWYWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldLm5lZ2F0aXZlVmFsdWVzO1xuXG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpKSB7XG5cdFx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlc1tpbmRleF0gPSBwb3NpdGl2ZVZhbHVlc1tpbmRleF0gfHwgMDtcblx0XHRcdFx0XHRcdG5lZ2F0aXZlVmFsdWVzW2luZGV4XSA9IG5lZ2F0aXZlVmFsdWVzW2luZGV4XSB8fCAwO1xuXG5cdFx0XHRcdFx0XHRpZiAob3B0cy5yZWxhdGl2ZVBvaW50cykge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlc1tpbmRleF0gPSAxMDA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlc1tpbmRleF0gKz0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlc1tpbmRleF0gKz0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh2YWx1ZXNQZXJTdGFjaywgZnVuY3Rpb24odmFsdWVzRm9yVHlwZSkge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdmFsdWVzRm9yVHlwZS5wb3NpdGl2ZVZhbHVlcy5jb25jYXQodmFsdWVzRm9yVHlwZS5uZWdhdGl2ZVZhbHVlcyk7XG5cdFx0XHRcdHZhciBtaW5WYWwgPSBoZWxwZXJzJDEubWluKHZhbHVlcyk7XG5cdFx0XHRcdHZhciBtYXhWYWwgPSBoZWxwZXJzJDEubWF4KHZhbHVlcyk7XG5cdFx0XHRcdG1lLm1pbiA9IG1lLm1pbiA9PT0gbnVsbCA/IG1pblZhbCA6IE1hdGgubWluKG1lLm1pbiwgbWluVmFsKTtcblx0XHRcdFx0bWUubWF4ID0gbWUubWF4ID09PSBudWxsID8gbWF4VmFsIDogTWF0aC5tYXgobWUubWF4LCBtYXhWYWwpO1xuXHRcdFx0fSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpKSB7XG5cdFx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IG1lLm1pbikge1xuXHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPiBtZS5tYXgpIHtcblx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdG1lLm1pbiA9IGlzRmluaXRlKG1lLm1pbikgJiYgIWlzTmFOKG1lLm1pbikgPyBtZS5taW4gOiBERUZBVUxUX01JTjtcblx0XHRtZS5tYXggPSBpc0Zpbml0ZShtZS5tYXgpICYmICFpc05hTihtZS5tYXgpID8gbWUubWF4IDogREVGQVVMVF9NQVg7XG5cblx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXgsIHRpY2tzLmJlZ2luQXRaZXJvXG5cdFx0dGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja0ZvbnQ7XG5cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdHJldHVybiBNYXRoLmNlaWwobWUud2lkdGggLyA0MCk7XG5cdFx0fVxuXHRcdHRpY2tGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChtZS5vcHRpb25zLnRpY2tzKTtcblx0XHRyZXR1cm4gTWF0aC5jZWlsKG1lLmhlaWdodCAvIHRpY2tGb250LmxpbmVIZWlnaHQpO1xuXHR9LFxuXG5cdC8vIENhbGxlZCBhZnRlciB0aGUgdGlja3MgYXJlIGJ1aWx0LiBXZSBuZWVkXG5cdGhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBXZSBhcmUgaW4gYSB2ZXJ0aWNhbCBvcmllbnRhdGlvbi4gVGhlIHRvcCB2YWx1ZSBpcyB0aGUgaGlnaGVzdC4gU28gcmV2ZXJzZSB0aGUgYXJyYXlcblx0XHRcdHRoaXMudGlja3MucmV2ZXJzZSgpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0cmV0dXJuICt0aGlzLmdldFJpZ2h0VmFsdWUodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHR9LFxuXG5cdC8vIFV0aWxzXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0Ly8gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBmaXQgaGFzIGJlZW4gcnVuIHNvIHRoYXRcblx0XHQvLyB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLnJpZ2h0LCBhbmQgdGhpcy5ib3R0b20gaGF2ZSBiZWVuIGRlZmluZWRcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBzdGFydCA9IG1lLnN0YXJ0O1xuXG5cdFx0dmFyIHJpZ2h0VmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0dmFyIHBpeGVsO1xuXHRcdHZhciByYW5nZSA9IG1lLmVuZCAtIHN0YXJ0O1xuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRwaXhlbCA9IG1lLmxlZnQgKyAobWUud2lkdGggLyByYW5nZSAqIChyaWdodFZhbHVlIC0gc3RhcnQpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGl4ZWwgPSBtZS5ib3R0b20gLSAobWUuaGVpZ2h0IC8gcmFuZ2UgKiAocmlnaHRWYWx1ZSAtIHN0YXJ0KSk7XG5cdFx0fVxuXHRcdHJldHVybiBwaXhlbDtcblx0fSxcblxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBpbm5lckRpbWVuc2lvbiA9IGlzSG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBvZmZzZXQgPSAoaXNIb3Jpem9udGFsID8gcGl4ZWwgLSBtZS5sZWZ0IDogbWUuYm90dG9tIC0gcGl4ZWwpIC8gaW5uZXJEaW1lbnNpb247XG5cdFx0cmV0dXJuIG1lLnN0YXJ0ICsgKChtZS5lbmQgLSBtZS5zdGFydCkgKiBvZmZzZXQpO1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja3NBc051bWJlcnNbaW5kZXhdKTtcblx0fVxufSk7XG5cbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xudmFyIF9kZWZhdWx0cyQxID0gZGVmYXVsdENvbmZpZyQxO1xuc2NhbGVfbGluZWFyLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQxO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkYSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsb2dhcml0aG1pYyB0aWNrc1xuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge251bWJlcltdfSBhcnJheSBvZiB0aWNrIHZhbHVlc1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzJDEoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuXHR2YXIgdGlja3MgPSBbXTtcblxuXHR2YXIgdGlja1ZhbCA9IHZhbHVlT3JEZWZhdWx0JGEoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAoZGF0YVJhbmdlLm1pbikpKSk7XG5cblx0dmFyIGVuZEV4cCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKGRhdGFSYW5nZS5tYXgpKTtcblx0dmFyIGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XG5cdHZhciBleHAsIHNpZ25pZmljYW5kO1xuXG5cdGlmICh0aWNrVmFsID09PSAwKSB7XG5cdFx0ZXhwID0gTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAoZGF0YVJhbmdlLm1pbk5vdFplcm8pKTtcblx0XHRzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IoZGF0YVJhbmdlLm1pbk5vdFplcm8gLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cblx0XHR0aWNrcy5wdXNoKHRpY2tWYWwpO1xuXHRcdHRpY2tWYWwgPSBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApO1xuXHR9IGVsc2Uge1xuXHRcdGV4cCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKHRpY2tWYWwpKTtcblx0XHRzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodGlja1ZhbCAvIE1hdGgucG93KDEwLCBleHApKTtcblx0fVxuXHR2YXIgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG5cblx0ZG8ge1xuXHRcdHRpY2tzLnB1c2godGlja1ZhbCk7XG5cblx0XHQrK3NpZ25pZmljYW5kO1xuXHRcdGlmIChzaWduaWZpY2FuZCA9PT0gMTApIHtcblx0XHRcdHNpZ25pZmljYW5kID0gMTtcblx0XHRcdCsrZXhwO1xuXHRcdFx0cHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xuXHRcdH1cblxuXHRcdHRpY2tWYWwgPSBNYXRoLnJvdW5kKHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuXHR9IHdoaWxlIChleHAgPCBlbmRFeHAgfHwgKGV4cCA9PT0gZW5kRXhwICYmIHNpZ25pZmljYW5kIDwgZW5kU2lnbmlmaWNhbmQpKTtcblxuXHR2YXIgbGFzdFRpY2sgPSB2YWx1ZU9yRGVmYXVsdCRhKGdlbmVyYXRpb25PcHRpb25zLm1heCwgdGlja1ZhbCk7XG5cdHRpY2tzLnB1c2gobGFzdFRpY2spO1xuXG5cdHJldHVybiB0aWNrcztcbn1cblxudmFyIGRlZmF1bHRDb25maWckMiA9IHtcblx0cG9zaXRpb246ICdsZWZ0JyxcblxuXHQvLyBsYWJlbCBzZXR0aW5nc1xuXHR0aWNrczoge1xuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWNcblx0fVxufTtcblxuLy8gVE9ETyh2Myk6IGNoYW5nZSB0aGlzIHRvIHBvc2l0aXZlT3JEZWZhdWx0XG5mdW5jdGlvbiBub25OZWdhdGl2ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG5cdHJldHVybiBoZWxwZXJzJDEuaXNGaW5pdGUodmFsdWUpICYmIHZhbHVlID49IDAgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxudmFyIHNjYWxlX2xvZ2FyaXRobWljID0gY29yZV9zY2FsZS5leHRlbmQoe1xuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0ZnVuY3Rpb24gSURNYXRjaGVzKG1ldGEpIHtcblx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgUmFuZ2Vcblx0XHRtZS5taW4gPSBudWxsO1xuXHRcdG1lLm1heCA9IG51bGw7XG5cdFx0bWUubWluTm90WmVybyA9IG51bGw7XG5cblx0XHR2YXIgaGFzU3RhY2tzID0gb3B0cy5zdGFja2VkO1xuXHRcdGlmIChoYXNTdGFja3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHRpZiAoaGFzU3RhY2tzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSAmJlxuXHRcdFx0XHRcdG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGhhc1N0YWNrcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChvcHRzLnN0YWNrZWQgfHwgaGFzU3RhY2tzKSB7XG5cdFx0XHR2YXIgdmFsdWVzUGVyU3RhY2sgPSB7fTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdHZhciBrZXkgPSBbXG5cdFx0XHRcdFx0bWV0YS50eXBlLFxuXHRcdFx0XHRcdC8vIHdlIGhhdmUgYSBzZXBhcmF0ZSBzdGFjayBmb3Igc3RhY2s9dW5kZWZpbmVkIGRhdGFzZXRzIHdoZW4gdGhlIG9wdHMuc3RhY2tlZCBpcyB1bmRlZmluZWRcblx0XHRcdFx0XHQoKG9wdHMuc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkgPyBkYXRhc2V0SW5kZXggOiAnJyksXG5cdFx0XHRcdFx0bWV0YS5zdGFja1xuXHRcdFx0XHRdLmpvaW4oJy4nKTtcblxuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZXNQZXJTdGFja1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHZhbHVlc1BlclN0YWNrW2tleV0gPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IHZhbHVlc1BlclN0YWNrW2tleV07XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHQvLyBpbnZhbGlkLCBoaWRkZW4gYW5kIG5lZ2F0aXZlIHZhbHVlcyBhcmUgaWdub3JlZFxuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiB8fCB2YWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFsdWVzW2luZGV4XSA9IHZhbHVlc1tpbmRleF0gfHwgMDtcblx0XHRcdFx0XHRcdHZhbHVlc1tpbmRleF0gKz0gdmFsdWU7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh2YWx1ZXNQZXJTdGFjaywgZnVuY3Rpb24odmFsdWVzRm9yVHlwZSkge1xuXHRcdFx0XHRpZiAodmFsdWVzRm9yVHlwZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIG1pblZhbCA9IGhlbHBlcnMkMS5taW4odmFsdWVzRm9yVHlwZSk7XG5cdFx0XHRcdFx0dmFyIG1heFZhbCA9IGhlbHBlcnMkMS5tYXgodmFsdWVzRm9yVHlwZSk7XG5cdFx0XHRcdFx0bWUubWluID0gbWUubWluID09PSBudWxsID8gbWluVmFsIDogTWF0aC5taW4obWUubWluLCBtaW5WYWwpO1xuXHRcdFx0XHRcdG1lLm1heCA9IG1lLm1heCA9PT0gbnVsbCA/IG1heFZhbCA6IE1hdGgubWF4KG1lLm1heCwgbWF4VmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpKSB7XG5cdFx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRcdC8vIGludmFsaWQsIGhpZGRlbiBhbmQgbmVnYXRpdmUgdmFsdWVzIGFyZSBpZ25vcmVkXG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuIHx8IHZhbHVlIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgbWUubWluKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+IG1lLm1heCkge1xuXHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICE9PSAwICYmIChtZS5taW5Ob3RaZXJvID09PSBudWxsIHx8IHZhbHVlIDwgbWUubWluTm90WmVybykpIHtcblx0XHRcdFx0XHRcdFx0bWUubWluTm90WmVybyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXhcblx0XHR0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcblx0fSxcblxuXHRoYW5kbGVUaWNrUmFuZ2VPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIERFRkFVTFRfTUlOID0gMTtcblx0XHR2YXIgREVGQVVMVF9NQVggPSAxMDtcblxuXHRcdG1lLm1pbiA9IG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHRpY2tPcHRzLm1pbiwgbWUubWluKTtcblx0XHRtZS5tYXggPSBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5tYXgsIG1lLm1heCk7XG5cblx0XHRpZiAobWUubWluID09PSBtZS5tYXgpIHtcblx0XHRcdGlmIChtZS5taW4gIT09IDAgJiYgbWUubWluICE9PSBudWxsKSB7XG5cdFx0XHRcdG1lLm1pbiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChtZS5taW4pKSAtIDEpO1xuXHRcdFx0XHRtZS5tYXggPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWF4KSkgKyAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1pbiA9IERFRkFVTFRfTUlOO1xuXHRcdFx0XHRtZS5tYXggPSBERUZBVUxUX01BWDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0bWUubWluID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1heCkpIC0gMSk7XG5cdFx0fVxuXHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdG1lLm1heCA9IG1lLm1pbiAhPT0gMFxuXHRcdFx0XHQ/IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChtZS5taW4pKSArIDEpXG5cdFx0XHRcdDogREVGQVVMVF9NQVg7XG5cdFx0fVxuXHRcdGlmIChtZS5taW5Ob3RaZXJvID09PSBudWxsKSB7XG5cdFx0XHRpZiAobWUubWluID4gMCkge1xuXHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gbWUubWluO1xuXHRcdFx0fSBlbHNlIGlmIChtZS5tYXggPCAxKSB7XG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWF4KSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUubWluTm90WmVybyA9IERFRkFVTFRfTUlOO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIHJldmVyc2UgPSAhbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHR2YXIgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG5cdFx0XHRtaW46IG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHRpY2tPcHRzLm1pbiksXG5cdFx0XHRtYXg6IG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHRpY2tPcHRzLm1heClcblx0XHR9O1xuXHRcdHZhciB0aWNrcyA9IG1lLnRpY2tzID0gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBtZSk7XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXG5cdFx0Ly8gcmFuZ2Ugb2YgdGhlIHNjYWxlXG5cdFx0bWUubWF4ID0gaGVscGVycyQxLm1heCh0aWNrcyk7XG5cdFx0bWUubWluID0gaGVscGVycyQxLm1pbih0aWNrcyk7XG5cblx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0cmV2ZXJzZSA9ICFyZXZlcnNlO1xuXHRcdFx0bWUuc3RhcnQgPSBtZS5tYXg7XG5cdFx0XHRtZS5lbmQgPSBtZS5taW47XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLnN0YXJ0ID0gbWUubWluO1xuXHRcdFx0bWUuZW5kID0gbWUubWF4O1xuXHRcdH1cblx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXHRcdH1cblx0fSxcblxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aWNrVmFsdWVzID0gdGhpcy50aWNrcy5zbGljZSgpO1xuXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbCh0aGlzKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIGNvcnJlY3QgdG9vbHRpcCBsYWJlbFxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0cmV0dXJuICt0aGlzLmdldFJpZ2h0VmFsdWUodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja1ZhbHVlc1tpbmRleF0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgdGljay5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIG1pbmltdW0gbm90IHplcm8gdmFsdWUuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZpcnN0IHRpY2sgdmFsdWUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0Rmlyc3RUaWNrVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIGV4cCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKHZhbHVlKSk7XG5cdFx0dmFyIHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcih2YWx1ZSAvIE1hdGgucG93KDEwLCBleHApKTtcblxuXHRcdHJldHVybiBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApO1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciByZXZlcnNlID0gdGlja09wdHMucmV2ZXJzZTtcblx0XHR2YXIgbG9nMTAgPSBoZWxwZXJzJDEubG9nMTA7XG5cdFx0dmFyIGZpcnN0VGlja1ZhbHVlID0gbWUuX2dldEZpcnN0VGlja1ZhbHVlKG1lLm1pbk5vdFplcm8pO1xuXHRcdHZhciBvZmZzZXQgPSAwO1xuXHRcdHZhciBpbm5lckRpbWVuc2lvbiwgcGl4ZWwsIHN0YXJ0LCBlbmQsIHNpZ247XG5cblx0XHR2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcblx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0c3RhcnQgPSBtZS5lbmQ7XG5cdFx0XHRlbmQgPSBtZS5zdGFydDtcblx0XHRcdHNpZ24gPSAtMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RhcnQgPSBtZS5zdGFydDtcblx0XHRcdGVuZCA9IG1lLmVuZDtcblx0XHRcdHNpZ24gPSAxO1xuXHRcdH1cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUud2lkdGg7XG5cdFx0XHRwaXhlbCA9IHJldmVyc2UgPyBtZS5yaWdodCA6IG1lLmxlZnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUuaGVpZ2h0O1xuXHRcdFx0c2lnbiAqPSAtMTsgLy8gaW52ZXJ0LCBzaW5jZSB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhcyBpcyBhdCBwaXhlbCAoMCwgMClcblx0XHRcdHBpeGVsID0gcmV2ZXJzZSA/IG1lLnRvcCA6IG1lLmJvdHRvbTtcblx0XHR9XG5cdFx0aWYgKHZhbHVlICE9PSBzdGFydCkge1xuXHRcdFx0aWYgKHN0YXJ0ID09PSAwKSB7IC8vIGluY2x1ZGUgemVybyB0aWNrXG5cdFx0XHRcdG9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JGEodGlja09wdHMuZm9udFNpemUsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHRcdGlubmVyRGltZW5zaW9uIC09IG9mZnNldDtcblx0XHRcdFx0c3RhcnQgPSBmaXJzdFRpY2tWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gMCkge1xuXHRcdFx0XHRvZmZzZXQgKz0gaW5uZXJEaW1lbnNpb24gLyAobG9nMTAoZW5kKSAtIGxvZzEwKHN0YXJ0KSkgKiAobG9nMTAodmFsdWUpIC0gbG9nMTAoc3RhcnQpKTtcblx0XHRcdH1cblx0XHRcdHBpeGVsICs9IHNpZ24gKiBvZmZzZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBwaXhlbDtcblx0fSxcblxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgcmV2ZXJzZSA9IHRpY2tPcHRzLnJldmVyc2U7XG5cdFx0dmFyIGxvZzEwID0gaGVscGVycyQxLmxvZzEwO1xuXHRcdHZhciBmaXJzdFRpY2tWYWx1ZSA9IG1lLl9nZXRGaXJzdFRpY2tWYWx1ZShtZS5taW5Ob3RaZXJvKTtcblx0XHR2YXIgaW5uZXJEaW1lbnNpb24sIHN0YXJ0LCBlbmQsIHZhbHVlO1xuXG5cdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdHN0YXJ0ID0gbWUuZW5kO1xuXHRcdFx0ZW5kID0gbWUuc3RhcnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXJ0ID0gbWUuc3RhcnQ7XG5cdFx0XHRlbmQgPSBtZS5lbmQ7XG5cdFx0fVxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0aW5uZXJEaW1lbnNpb24gPSBtZS53aWR0aDtcblx0XHRcdHZhbHVlID0gcmV2ZXJzZSA/IG1lLnJpZ2h0IC0gcGl4ZWwgOiBwaXhlbCAtIG1lLmxlZnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUuaGVpZ2h0O1xuXHRcdFx0dmFsdWUgPSByZXZlcnNlID8gcGl4ZWwgLSBtZS50b3AgOiBtZS5ib3R0b20gLSBwaXhlbDtcblx0XHR9XG5cdFx0aWYgKHZhbHVlICE9PSBzdGFydCkge1xuXHRcdFx0aWYgKHN0YXJ0ID09PSAwKSB7IC8vIGluY2x1ZGUgemVybyB0aWNrXG5cdFx0XHRcdHZhciBvZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCRhKHRpY2tPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdFx0XHR2YWx1ZSAtPSBvZmZzZXQ7XG5cdFx0XHRcdGlubmVyRGltZW5zaW9uIC09IG9mZnNldDtcblx0XHRcdFx0c3RhcnQgPSBmaXJzdFRpY2tWYWx1ZTtcblx0XHRcdH1cblx0XHRcdHZhbHVlICo9IGxvZzEwKGVuZCkgLSBsb2cxMChzdGFydCk7XG5cdFx0XHR2YWx1ZSAvPSBpbm5lckRpbWVuc2lvbjtcblx0XHRcdHZhbHVlID0gTWF0aC5wb3coMTAsIGxvZzEwKHN0YXJ0KSArIHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDIgPSBkZWZhdWx0Q29uZmlnJDI7XG5zY2FsZV9sb2dhcml0aG1pYy5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkMjtcblxudmFyIHZhbHVlT3JEZWZhdWx0JGIgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEgPSBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xudmFyIHJlc29sdmUkNyA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbnZhciBkZWZhdWx0Q29uZmlnJDMgPSB7XG5cdGRpc3BsYXk6IHRydWUsXG5cblx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSBzY2FsaW5nIHRoZSBjaGFydCBmcm9tIHRoZSBjZW50cmVcblx0YW5pbWF0ZTogdHJ1ZSxcblx0cG9zaXRpb246ICdjaGFydEFyZWEnLFxuXG5cdGFuZ2xlTGluZXM6IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcblx0XHRsaW5lV2lkdGg6IDEsXG5cdFx0Ym9yZGVyRGFzaDogW10sXG5cdFx0Ym9yZGVyRGFzaE9mZnNldDogMC4wXG5cdH0sXG5cblx0Z3JpZExpbmVzOiB7XG5cdFx0Y2lyY3VsYXI6IGZhbHNlXG5cdH0sXG5cblx0Ly8gbGFiZWwgc2V0dGluZ3Ncblx0dGlja3M6IHtcblx0XHQvLyBCb29sZWFuIC0gU2hvdyBhIGJhY2tkcm9wIHRvIHRoZSBzY2FsZSBsYWJlbFxuXHRcdHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuXG5cdFx0Ly8gU3RyaW5nIC0gVGhlIGNvbG91ciBvZiB0aGUgbGFiZWwgYmFja2Ryb3Bcblx0XHRiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwwLjc1KScsXG5cblx0XHQvLyBOdW1iZXIgLSBUaGUgYmFja2Ryb3AgcGFkZGluZyBhYm92ZSAmIGJlbG93IHRoZSBsYWJlbCBpbiBwaXhlbHNcblx0XHRiYWNrZHJvcFBhZGRpbmdZOiAyLFxuXG5cdFx0Ly8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgdG8gdGhlIHNpZGUgb2YgdGhlIGxhYmVsIGluIHBpeGVsc1xuXHRcdGJhY2tkcm9wUGFkZGluZ1g6IDIsXG5cblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxuXHR9LFxuXG5cdHBvaW50TGFiZWxzOiB7XG5cdFx0Ly8gQm9vbGVhbiAtIGlmIHRydWUsIHNob3cgcG9pbnQgbGFiZWxzXG5cdFx0ZGlzcGxheTogdHJ1ZSxcblxuXHRcdC8vIE51bWJlciAtIFBvaW50IGxhYmVsIGZvbnQgc2l6ZSBpbiBwaXhlbHNcblx0XHRmb250U2l6ZTogMTAsXG5cblx0XHQvLyBGdW5jdGlvbiAtIFVzZWQgdG8gY29udmVydCBwb2ludCBsYWJlbHNcblx0XHRjYWxsYmFjazogZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdHJldHVybiBsYWJlbDtcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGdldFZhbHVlQ291bnQoc2NhbGUpIHtcblx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuXHRyZXR1cm4gb3B0cy5hbmdsZUxpbmVzLmRpc3BsYXkgfHwgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5ID8gc2NhbGUuY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoIDogMDtcbn1cblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcblx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcblx0XHRyZXR1cm4gdmFsdWVPckRlZmF1bHQkYih0aWNrT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKSArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kgKiAyO1xuXHR9XG5cdHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgbGluZUhlaWdodCwgbGFiZWwpIHtcblx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGxhYmVsKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3OiBoZWxwZXJzJDEubG9uZ2VzdFRleHQoY3R4LCBjdHguZm9udCwgbGFiZWwpLFxuXHRcdFx0aDogbGFiZWwubGVuZ3RoICogbGluZUhlaWdodFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHc6IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGgsXG5cdFx0aDogbGluZUhlaWdodFxuXHR9O1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcblx0aWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcblx0XHRcdGVuZDogcG9zICsgKHNpemUgLyAyKVxuXHRcdH07XG5cdH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IHBvcyAtIHNpemUsXG5cdFx0XHRlbmQ6IHBvc1xuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0OiBwb3MsXG5cdFx0ZW5kOiBwb3MgKyBzaXplXG5cdH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpdCBhIHJhZGlhbCBsaW5lYXIgc2NhbGUgd2l0aCBwb2ludCBsYWJlbHNcbiAqL1xuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XG5cblx0Ly8gUmlnaHQsIHRoaXMgaXMgcmVhbGx5IGNvbmZ1c2luZyBhbmQgdGhlcmUgaXMgYSBsb3Qgb2YgbWF0aHMgZ29pbmcgb24gaGVyZVxuXHQvLyBUaGUgZ2lzdCBvZiB0aGUgcHJvYmxlbSBpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ubm5pY2svNjk2Y2M5YzU1ZjRiMGJlYjhmZTlcblx0Ly9cblx0Ly8gUmVhY3Rpb246IGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3Rvb211Y2hzY2llbmNlLmdpZlxuXHQvL1xuXHQvLyBTb2x1dGlvbjpcblx0Ly9cblx0Ly8gV2UgYXNzdW1lIHRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24gaXMgaGFsZiB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGF0IGZpcnN0XG5cdC8vIGF0IGVhY2ggaW5kZXggd2UgY2hlY2sgaWYgdGhlIHRleHQgb3ZlcmxhcHMuXG5cdC8vXG5cdC8vIFdoZXJlIGl0IGRvZXMsIHdlIHN0b3JlIHRoYXQgYW5nbGUgYW5kIHRoYXQgaW5kZXguXG5cdC8vXG5cdC8vIEFmdGVyIGZpbmRpbmcgdGhlIGxhcmdlc3QgaW5kZXggYW5kIGFuZ2xlIHdlIGNhbGN1bGF0ZSBob3cgbXVjaCB3ZSBuZWVkIHRvIHJlbW92ZVxuXHQvLyBmcm9tIHRoZSBzaGFwZSByYWRpdXMgdG8gbW92ZSB0aGUgcG9pbnQgaW53YXJkcyBieSB0aGF0IHguXG5cdC8vXG5cdC8vIFdlIGF2ZXJhZ2UgdGhlIGxlZnQgYW5kIHJpZ2h0IGRpc3RhbmNlcyB0byBnZXQgdGhlIG1heGltdW0gc2hhcGUgcmFkaXVzIHRoYXQgY2FuIGZpdCBpbiB0aGUgYm94XG5cdC8vIGFsb25nIHdpdGggbGFiZWxzLlxuXHQvL1xuXHQvLyBPbmNlIHdlIGhhdmUgdGhhdCwgd2UgY2FuIGZpbmQgdGhlIGNlbnRyZSBwb2ludCBmb3IgdGhlIGNoYXJ0LCBieSB0YWtpbmcgdGhlIHggdGV4dCBwcm90cnVzaW9uXG5cdC8vIG9uIGVhY2ggc2lkZSwgcmVtb3ZpbmcgdGhhdCBmcm9tIHRoZSBzaXplLCBoYWx2aW5nIGl0IGFuZCBhZGRpbmcgdGhlIGxlZnQgeCBwcm90cnVzaW9uIHdpZHRoLlxuXHQvL1xuXHQvLyBUaGlzIHdpbGwgbWVhbiB3ZSBoYXZlIGEgc2hhcGUgZml0dGVkIHRvIHRoZSBjYW52YXMsIGFzIGxhcmdlIGFzIGl0IGNhbiBiZSB3aXRoIHRoZSBsYWJlbHNcblx0Ly8gYW5kIHBvc2l0aW9uIGl0IGluIHRoZSBtb3N0IHNwYWNlIGVmZmljaWVudCBtYW5uZXJcblx0Ly9cblx0Ly8gaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMveWVhaHNjaWVuY2UuZ2lmXG5cblx0dmFyIHBsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQoc2NhbGUub3B0aW9ucy5wb2ludExhYmVscyk7XG5cblx0Ly8gR2V0IG1heGltdW0gcmFkaXVzIG9mIHRoZSBwb2x5Z29uLiBFaXRoZXIgaGFsZiB0aGUgaGVpZ2h0IChtaW51cyB0aGUgdGV4dCB3aWR0aCkgb3IgaGFsZiB0aGUgd2lkdGguXG5cdC8vIFVzZSB0aGlzIHRvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0ICsgY2hhbmdlLiAtIE1ha2Ugc3VyZSBML1IgcHJvdHJ1c2lvbiBpcyBhdCBsZWFzdCAwIHRvIHN0b3AgaXNzdWVzIHdpdGggY2VudHJlIHBvaW50c1xuXHR2YXIgZnVydGhlc3RMaW1pdHMgPSB7XG5cdFx0bDogMCxcblx0XHRyOiBzY2FsZS53aWR0aCxcblx0XHR0OiAwLFxuXHRcdGI6IHNjYWxlLmhlaWdodCAtIHNjYWxlLnBhZGRpbmdUb3Bcblx0fTtcblx0dmFyIGZ1cnRoZXN0QW5nbGVzID0ge307XG5cdHZhciBpLCB0ZXh0U2l6ZSwgcG9pbnRQb3NpdGlvbjtcblxuXHRzY2FsZS5jdHguZm9udCA9IHBsRm9udC5zdHJpbmc7XG5cdHNjYWxlLl9wb2ludExhYmVsU2l6ZXMgPSBbXTtcblxuXHR2YXIgdmFsdWVDb3VudCA9IGdldFZhbHVlQ291bnQoc2NhbGUpO1xuXHRmb3IgKGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG5cdFx0cG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyA1KTtcblx0XHR0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoc2NhbGUuY3R4LCBwbEZvbnQubGluZUhlaWdodCwgc2NhbGUucG9pbnRMYWJlbHNbaV0gfHwgJycpO1xuXHRcdHNjYWxlLl9wb2ludExhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcblxuXHRcdC8vIEFkZCBxdWFydGVyIGNpcmNsZSB0byBtYWtlIGRlZ3JlZSAwIG1lYW4gdG9wIG9mIGNpcmNsZVxuXHRcdHZhciBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xuXHRcdHZhciBhbmdsZSA9IGhlbHBlcnMkMS50b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSAlIDM2MDtcblx0XHR2YXIgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuXHRcdHZhciB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuXG5cdFx0aWYgKGhMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy5sKSB7XG5cdFx0XHRmdXJ0aGVzdExpbWl0cy5sID0gaExpbWl0cy5zdGFydDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLmwgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKGhMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMucikge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMuciA9IGhMaW1pdHMuZW5kO1xuXHRcdFx0ZnVydGhlc3RBbmdsZXMuciA9IGFuZ2xlUmFkaWFucztcblx0XHR9XG5cblx0XHRpZiAodkxpbWl0cy5zdGFydCA8IGZ1cnRoZXN0TGltaXRzLnQpIHtcblx0XHRcdGZ1cnRoZXN0TGltaXRzLnQgPSB2TGltaXRzLnN0YXJ0O1xuXHRcdFx0ZnVydGhlc3RBbmdsZXMudCA9IGFuZ2xlUmFkaWFucztcblx0XHR9XG5cblx0XHRpZiAodkxpbWl0cy5lbmQgPiBmdXJ0aGVzdExpbWl0cy5iKSB7XG5cdFx0XHRmdXJ0aGVzdExpbWl0cy5iID0gdkxpbWl0cy5lbmQ7XG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy5iID0gYW5nbGVSYWRpYW5zO1xuXHRcdH1cblx0fVxuXG5cdHNjYWxlLnNldFJlZHVjdGlvbnMoc2NhbGUuZHJhd2luZ0FyZWEsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcyk7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG5cdGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG5cdFx0cmV0dXJuICdjZW50ZXInO1xuXHR9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG5cdFx0cmV0dXJuICdsZWZ0Jztcblx0fVxuXG5cdHJldHVybiAncmlnaHQnO1xufVxuXG5mdW5jdGlvbiBmaWxsVGV4dChjdHgsIHRleHQsIHBvc2l0aW9uLCBsaW5lSGVpZ2h0KSB7XG5cdHZhciB5ID0gcG9zaXRpb24ueSArIGxpbmVIZWlnaHQgLyAyO1xuXHR2YXIgaSwgaWxlbjtcblxuXHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGV4dCkpIHtcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0W2ldLCBwb3NpdGlvbi54LCB5KTtcblx0XHRcdHkgKz0gbGluZUhlaWdodDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Y3R4LmZpbGxUZXh0KHRleHQsIHBvc2l0aW9uLngsIHkpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodChhbmdsZSwgdGV4dFNpemUsIHBvc2l0aW9uKSB7XG5cdGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuXHRcdHBvc2l0aW9uLnkgLT0gKHRleHRTaXplLmggLyAyKTtcblx0fSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG5cdFx0cG9zaXRpb24ueSAtPSB0ZXh0U2l6ZS5oO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSkge1xuXHR2YXIgY3R4ID0gc2NhbGUuY3R4O1xuXHR2YXIgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG5cdHZhciBhbmdsZUxpbmVPcHRzID0gb3B0cy5hbmdsZUxpbmVzO1xuXHR2YXIgZ3JpZExpbmVPcHRzID0gb3B0cy5ncmlkTGluZXM7XG5cdHZhciBwb2ludExhYmVsT3B0cyA9IG9wdHMucG9pbnRMYWJlbHM7XG5cdHZhciBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCRiKGFuZ2xlTGluZU9wdHMubGluZVdpZHRoLCBncmlkTGluZU9wdHMubGluZVdpZHRoKTtcblx0dmFyIGxpbmVDb2xvciA9IHZhbHVlT3JEZWZhdWx0JGIoYW5nbGVMaW5lT3B0cy5jb2xvciwgZ3JpZExpbmVPcHRzLmNvbG9yKTtcblx0dmFyIHRpY2tCYWNrZHJvcEhlaWdodCA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKTtcblxuXHRjdHguc2F2ZSgpO1xuXHRjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXHRjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XG5cdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRjdHguc2V0TGluZURhc2gocmVzb2x2ZSQ3KFthbmdsZUxpbmVPcHRzLmJvcmRlckRhc2gsIGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoLCBbXV0pKTtcblx0XHRjdHgubGluZURhc2hPZmZzZXQgPSByZXNvbHZlJDcoW2FuZ2xlTGluZU9wdHMuYm9yZGVyRGFzaE9mZnNldCwgZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQsIDAuMF0pO1xuXHR9XG5cblx0dmFyIG91dGVyRGlzdGFuY2UgPSBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXgpO1xuXG5cdC8vIFBvaW50IExhYmVsIEZvbnRcblx0dmFyIHBsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQocG9pbnRMYWJlbE9wdHMpO1xuXG5cdGN0eC5mb250ID0gcGxGb250LnN0cmluZztcblx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG5cdGZvciAodmFyIGkgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0aWYgKGFuZ2xlTGluZU9wdHMuZGlzcGxheSAmJiBsaW5lV2lkdGggJiYgbGluZUNvbG9yKSB7XG5cdFx0XHR2YXIgb3V0ZXJQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgb3V0ZXJEaXN0YW5jZSk7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIpO1xuXHRcdFx0Y3R4LmxpbmVUbyhvdXRlclBvc2l0aW9uLngsIG91dGVyUG9zaXRpb24ueSk7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHBvaW50TGFiZWxPcHRzLmRpc3BsYXkpIHtcblx0XHRcdC8vIEV4dHJhIHBpeGVscyBvdXQgZm9yIHNvbWUgbGFiZWwgc3BhY2luZ1xuXHRcdFx0dmFyIGV4dHJhID0gKGkgPT09IDAgPyB0aWNrQmFja2Ryb3BIZWlnaHQgLyAyIDogMCk7XG5cdFx0XHR2YXIgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyA1KTtcblxuXHRcdFx0Ly8gS2VlcCB0aGlzIGluIGxvb3Agc2luY2Ugd2UgbWF5IHN1cHBvcnQgYXJyYXkgcHJvcGVydGllcyBoZXJlXG5cdFx0XHR2YXIgcG9pbnRMYWJlbEZvbnRDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKHBvaW50TGFiZWxPcHRzLmZvbnRDb2xvciwgaSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gcG9pbnRMYWJlbEZvbnRDb2xvcjtcblxuXHRcdFx0dmFyIGFuZ2xlUmFkaWFucyA9IHNjYWxlLmdldEluZGV4QW5nbGUoaSk7XG5cdFx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzJDEudG9EZWdyZWVzKGFuZ2xlUmFkaWFucyk7XG5cdFx0XHRjdHgudGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuXHRcdFx0YWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0KGFuZ2xlLCBzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldLCBwb2ludExhYmVsUG9zaXRpb24pO1xuXHRcdFx0ZmlsbFRleHQoY3R4LCBzY2FsZS5wb2ludExhYmVsc1tpXSB8fCAnJywgcG9pbnRMYWJlbFBvc2l0aW9uLCBwbEZvbnQubGluZUhlaWdodCk7XG5cdFx0fVxuXHR9XG5cdGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgaW5kZXgpIHtcblx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcblx0dmFyIGNpcmN1bGFyID0gZ3JpZExpbmVPcHRzLmNpcmN1bGFyO1xuXHR2YXIgdmFsdWVDb3VudCA9IGdldFZhbHVlQ291bnQoc2NhbGUpO1xuXHR2YXIgbGluZUNvbG9yID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEoZ3JpZExpbmVPcHRzLmNvbG9yLCBpbmRleCAtIDEpO1xuXHR2YXIgbGluZVdpZHRoID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEoZ3JpZExpbmVPcHRzLmxpbmVXaWR0aCwgaW5kZXggLSAxKTtcblx0dmFyIHBvaW50UG9zaXRpb247XG5cblx0aWYgKCghY2lyY3VsYXIgJiYgIXZhbHVlQ291bnQpIHx8ICFsaW5lQ29sb3IgfHwgIWxpbmVXaWR0aCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGN0eC5zYXZlKCk7XG5cdGN0eC5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcblx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdGN0eC5zZXRMaW5lRGFzaChncmlkTGluZU9wdHMuYm9yZGVyRGFzaCB8fCBbXSk7XG5cdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xuXHR9XG5cblx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRpZiAoY2lyY3VsYXIpIHtcblx0XHQvLyBEcmF3IGNpcmN1bGFyIGFyY3MgYmV0d2VlbiB0aGUgcG9pbnRzXG5cdFx0Y3R4LmFyYyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcblx0fSBlbHNlIHtcblx0XHQvLyBEcmF3IHN0cmFpZ2h0IGxpbmVzIGNvbm5lY3RpbmcgZWFjaCBpbmRleFxuXHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XG5cdFx0Y3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG5cblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHRcdFx0cG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcblx0XHRcdGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXHRcdH1cblx0fVxuXHRjdHguY2xvc2VQYXRoKCk7XG5cdGN0eC5zdHJva2UoKTtcblx0Y3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyT3JaZXJvKHBhcmFtKSB7XG5cdHJldHVybiBoZWxwZXJzJDEuaXNOdW1iZXIocGFyYW0pID8gcGFyYW0gOiAwO1xufVxuXG52YXIgc2NhbGVfcmFkaWFsTGluZWFyID0gc2NhbGVfbGluZWFyYmFzZS5leHRlbmQoe1xuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblx0XHRtZS5wYWRkaW5nVG9wID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG1lLm9wdGlvbnMpIC8gMjtcblx0XHRtZS54Q2VudGVyID0gTWF0aC5mbG9vcihtZS53aWR0aCAvIDIpO1xuXHRcdG1lLnlDZW50ZXIgPSBNYXRoLmZsb29yKChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSAvIDIpO1xuXHRcdG1lLmRyYXdpbmdBcmVhID0gTWF0aC5taW4obWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCwgbWUud2lkdGgpIC8gMjtcblx0fSxcblxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdFx0dmFyIG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKGNoYXJ0LmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cblx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1pbiA9IE1hdGgubWluKHZhbHVlLCBtaW4pO1xuXHRcdFx0XHRcdG1heCA9IE1hdGgubWF4KHZhbHVlLCBtYXgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdG1lLm1pbiA9IChtaW4gPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA/IDAgOiBtaW4pO1xuXHRcdG1lLm1heCA9IChtYXggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA/IDAgOiBtYXgpO1xuXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4LCB0aWNrcy5iZWdpbkF0WmVyb1xuXHRcdG1lLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcblx0fSxcblxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG5cdH0sXG5cblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRzY2FsZV9saW5lYXJiYXNlLnByb3RvdHlwZS5jb252ZXJ0VGlja3NUb0xhYmVscy5jYWxsKG1lKTtcblxuXHRcdC8vIFBvaW50IGxhYmVsc1xuXHRcdG1lLnBvaW50TGFiZWxzID0gbWUuY2hhcnQuZGF0YS5sYWJlbHMubWFwKG1lLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIG1lKTtcblx0fSxcblxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0cmV0dXJuICt0aGlzLmdldFJpZ2h0VmFsdWUodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHR9LFxuXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuXHRcdFx0Zml0V2l0aFBvaW50TGFiZWxzKG1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgcmFkaXVzIHJlZHVjdGlvbnMgYW5kIGRldGVybWluZSBuZXcgcmFkaXVzIGFuZCBjZW50ZXIgcG9pbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNldFJlZHVjdGlvbnM6IGZ1bmN0aW9uKGxhcmdlc3RQb3NzaWJsZVJhZGl1cywgZnVydGhlc3RMaW1pdHMsIGZ1cnRoZXN0QW5nbGVzKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uTGVmdCA9IGZ1cnRoZXN0TGltaXRzLmwgLyBNYXRoLnNpbihmdXJ0aGVzdEFuZ2xlcy5sKTtcblx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBNYXRoLm1heChmdXJ0aGVzdExpbWl0cy5yIC0gbWUud2lkdGgsIDApIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMucik7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvblRvcCA9IC1mdXJ0aGVzdExpbWl0cy50IC8gTWF0aC5jb3MoZnVydGhlc3RBbmdsZXMudCk7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IC1NYXRoLm1heChmdXJ0aGVzdExpbWl0cy5iIC0gKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3ApLCAwKSAvIE1hdGguY29zKGZ1cnRoZXN0QW5nbGVzLmIpO1xuXG5cdFx0cmFkaXVzUmVkdWN0aW9uTGVmdCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25MZWZ0KTtcblx0XHRyYWRpdXNSZWR1Y3Rpb25SaWdodCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25SaWdodCk7XG5cdFx0cmFkaXVzUmVkdWN0aW9uVG9wID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvblRvcCk7XG5cdFx0cmFkaXVzUmVkdWN0aW9uQm90dG9tID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvbkJvdHRvbSk7XG5cblx0XHRtZS5kcmF3aW5nQXJlYSA9IE1hdGgubWluKFxuXHRcdFx0TWF0aC5mbG9vcihsYXJnZXN0UG9zc2libGVSYWRpdXMgLSAocmFkaXVzUmVkdWN0aW9uTGVmdCArIHJhZGl1c1JlZHVjdGlvblJpZ2h0KSAvIDIpLFxuXHRcdFx0TWF0aC5mbG9vcihsYXJnZXN0UG9zc2libGVSYWRpdXMgLSAocmFkaXVzUmVkdWN0aW9uVG9wICsgcmFkaXVzUmVkdWN0aW9uQm90dG9tKSAvIDIpKTtcblx0XHRtZS5zZXRDZW50ZXJQb2ludChyYWRpdXNSZWR1Y3Rpb25MZWZ0LCByYWRpdXNSZWR1Y3Rpb25SaWdodCwgcmFkaXVzUmVkdWN0aW9uVG9wLCByYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xuXHR9LFxuXG5cdHNldENlbnRlclBvaW50OiBmdW5jdGlvbihsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1heFJpZ2h0ID0gbWUud2lkdGggLSByaWdodE1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heExlZnQgPSBsZWZ0TW92ZW1lbnQgKyBtZS5kcmF3aW5nQXJlYTtcblx0XHR2YXIgbWF4VG9wID0gdG9wTW92ZW1lbnQgKyBtZS5kcmF3aW5nQXJlYTtcblx0XHR2YXIgbWF4Qm90dG9tID0gKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3ApIC0gYm90dG9tTW92ZW1lbnQgLSBtZS5kcmF3aW5nQXJlYTtcblxuXHRcdG1lLnhDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4TGVmdCArIG1heFJpZ2h0KSAvIDIpICsgbWUubGVmdCk7XG5cdFx0bWUueUNlbnRlciA9IE1hdGguZmxvb3IoKChtYXhUb3AgKyBtYXhCb3R0b20pIC8gMikgKyBtZS50b3AgKyBtZS5wYWRkaW5nVG9wKTtcblx0fSxcblxuXHRnZXRJbmRleEFuZ2xlOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBhbmdsZU11bHRpcGxpZXIgPSAoTWF0aC5QSSAqIDIpIC8gZ2V0VmFsdWVDb3VudCh0aGlzKTtcblx0XHR2YXIgc3RhcnRBbmdsZSA9IHRoaXMuY2hhcnQub3B0aW9ucyAmJiB0aGlzLmNoYXJ0Lm9wdGlvbnMuc3RhcnRBbmdsZSA/XG5cdFx0XHR0aGlzLmNoYXJ0Lm9wdGlvbnMuc3RhcnRBbmdsZSA6XG5cdFx0XHQwO1xuXG5cdFx0dmFyIHN0YXJ0QW5nbGVSYWRpYW5zID0gc3RhcnRBbmdsZSAqIE1hdGguUEkgKiAyIC8gMzYwO1xuXG5cdFx0Ly8gU3RhcnQgZnJvbSB0aGUgdG9wIGluc3RlYWQgb2YgcmlnaHQsIHNvIHJlbW92ZSBhIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXHRcdHJldHVybiBpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHN0YXJ0QW5nbGVSYWRpYW5zO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiAwOyAvLyBudWxsIGFsd2F5cyBpbiBjZW50ZXJcblx0XHR9XG5cblx0XHQvLyBUYWtlIGludG8gYWNjb3VudCBoYWxmIGZvbnQgc2l6ZSArIHRoZSB5UGFkZGluZyBvZiB0aGUgdG9wIHZhbHVlXG5cdFx0dmFyIHNjYWxpbmdGYWN0b3IgPSBtZS5kcmF3aW5nQXJlYSAvIChtZS5tYXggLSBtZS5taW4pO1xuXHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLnJldmVyc2UpIHtcblx0XHRcdHJldHVybiAobWUubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3Rvcjtcblx0XHR9XG5cdFx0cmV0dXJuICh2YWx1ZSAtIG1lLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuXHR9LFxuXG5cdGdldFBvaW50UG9zaXRpb246IGZ1bmN0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aGlzQW5nbGUgPSBtZS5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIChNYXRoLlBJIC8gMik7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IE1hdGguY29zKHRoaXNBbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyBtZS54Q2VudGVyLFxuXHRcdFx0eTogTWF0aC5zaW4odGhpc0FuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIG1lLnlDZW50ZXJcblx0XHR9O1xuXHR9LFxuXG5cdGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZTogZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuXHR9LFxuXG5cdGdldEJhc2VQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWluID0gbWUubWluO1xuXHRcdHZhciBtYXggPSBtZS5tYXg7XG5cblx0XHRyZXR1cm4gbWUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsXG5cdFx0XHRtZS5iZWdpbkF0WmVybyA/IDAgOlxuXHRcdFx0bWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcblx0XHRcdG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG5cdFx0XHQwKTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgZ3JpZExpbmVPcHRzID0gb3B0cy5ncmlkTGluZXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdGlmIChvcHRzLmRpc3BsYXkpIHtcblx0XHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcblx0XHRcdHZhciB0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQodGlja09wdHMpO1xuXG5cdFx0XHRpZiAob3B0cy5hbmdsZUxpbmVzLmRpc3BsYXkgfHwgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG5cdFx0XHRcdGRyYXdQb2ludExhYmVscyhtZSk7XG5cdFx0XHR9XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLnRpY2tzLCBmdW5jdGlvbihsYWJlbCwgaW5kZXgpIHtcblx0XHRcdFx0Ly8gRG9uJ3QgZHJhdyBhIGNlbnRyZSB2YWx1ZSAoaWYgaXQgaXMgbWluaW11bSlcblx0XHRcdFx0aWYgKGluZGV4ID4gMCB8fCB0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHRcdFx0dmFyIHlDZW50ZXJPZmZzZXQgPSBtZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShtZS50aWNrc0FzTnVtYmVyc1tpbmRleF0pO1xuXG5cdFx0XHRcdFx0Ly8gRHJhdyBjaXJjdWxhciBsaW5lcyBhcm91bmQgdGhlIHNjYWxlXG5cdFx0XHRcdFx0aWYgKGdyaWRMaW5lT3B0cy5kaXNwbGF5ICYmIGluZGV4ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRkcmF3UmFkaXVzTGluZShtZSwgZ3JpZExpbmVPcHRzLCB5Q2VudGVyT2Zmc2V0LCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRpY2tPcHRzLmRpc3BsYXkpIHtcblx0XHRcdFx0XHRcdHZhciB0aWNrRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkYih0aWNrT3B0cy5mb250Q29sb3IsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0XHRcdFx0Y3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG5cblx0XHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKG1lLnhDZW50ZXIsIG1lLnlDZW50ZXIpO1xuXHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcblxuXHRcdFx0XHRcdFx0aWYgKHRpY2tPcHRzLnNob3dMYWJlbEJhY2tkcm9wKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBsYWJlbFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tPcHRzLmJhY2tkcm9wQ29sb3I7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsUmVjdChcblx0XHRcdFx0XHRcdFx0XHQtbGFiZWxXaWR0aCAvIDIgLSB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdYLFxuXHRcdFx0XHRcdFx0XHRcdC15Q2VudGVyT2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZLFxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsV2lkdGggKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdYICogMixcblx0XHRcdFx0XHRcdFx0XHR0aWNrRm9udC5zaXplICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSAqIDJcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tGb250Q29sb3I7XG5cdFx0XHRcdFx0XHRjdHguZmlsbFRleHQobGFiZWwsIDAsIC15Q2VudGVyT2Zmc2V0KTtcblx0XHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMkMyA9IGRlZmF1bHRDb25maWckMztcbnNjYWxlX3JhZGlhbExpbmVhci5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkMztcblxudmFyIHZhbHVlT3JEZWZhdWx0JGMgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbi8vIEludGVnZXIgY29uc3RhbnRzIGFyZSBmcm9tIHRoZSBFUzYgc3BlYy5cbnZhciBNSU5fSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxO1xudmFyIE1BWF9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcblxudmFyIElOVEVSVkFMUyA9IHtcblx0bWlsbGlzZWNvbmQ6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMSxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAyMCwgNTAsIDEwMCwgMjUwLCA1MDBdXG5cdH0sXG5cdHNlY29uZDoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAxMDAwLFxuXHRcdHN0ZXBzOiBbMSwgMiwgNSwgMTAsIDE1LCAzMF1cblx0fSxcblx0bWludXRlOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDYwMDAwLFxuXHRcdHN0ZXBzOiBbMSwgMiwgNSwgMTAsIDE1LCAzMF1cblx0fSxcblx0aG91cjoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAzNjAwMDAwLFxuXHRcdHN0ZXBzOiBbMSwgMiwgMywgNiwgMTJdXG5cdH0sXG5cdGRheToge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiA4NjQwMDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDVdXG5cdH0sXG5cdHdlZWs6IHtcblx0XHRjb21tb246IGZhbHNlLFxuXHRcdHNpemU6IDYwNDgwMDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDMsIDRdXG5cdH0sXG5cdG1vbnRoOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDIuNjI4ZTksXG5cdFx0c3RlcHM6IFsxLCAyLCAzXVxuXHR9LFxuXHRxdWFydGVyOiB7XG5cdFx0Y29tbW9uOiBmYWxzZSxcblx0XHRzaXplOiA3Ljg4NGU5LFxuXHRcdHN0ZXBzOiBbMSwgMiwgMywgNF1cblx0fSxcblx0eWVhcjoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAzLjE1NGUxMFxuXHR9XG59O1xuXG52YXIgVU5JVFMgPSBPYmplY3Qua2V5cyhJTlRFUlZBTFMpO1xuXG5mdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuXHRyZXR1cm4gYSAtIGI7XG59XG5cbmZ1bmN0aW9uIGFycmF5VW5pcXVlKGl0ZW1zKSB7XG5cdHZhciBoYXNoID0ge307XG5cdHZhciBvdXQgPSBbXTtcblx0dmFyIGksIGlsZW4sIGl0ZW07XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRpZiAoIWhhc2hbaXRlbV0pIHtcblx0XHRcdGhhc2hbaXRlbV0gPSB0cnVlO1xuXHRcdFx0b3V0LnB1c2goaXRlbSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHt0aW1lLCBwb3N9IG9iamVjdHMgdXNlZCB0byBpbnRlcnBvbGF0ZSBhIHNwZWNpZmljIGB0aW1lYCBvciBwb3NpdGlvblxuICogKGBwb3NgKSBvbiB0aGUgc2NhbGUsIGJ5IHNlYXJjaGluZyBlbnRyaWVzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHJlcXVlc3RlZCB2YWx1ZS4gYHBvc2AgaXNcbiAqIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDE6IDAgYmVpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzY2FsZSAobGVmdCBvciB0b3ApIGFuZCAxIHRoZSBvdGhlclxuICogZXh0cmVtaXR5IChsZWZ0ICsgd2lkdGggb3IgdG9wICsgaGVpZ2h0KS4gTm90ZSB0aGF0IGl0IHdvdWxkIGJlIG1vcmUgb3B0aW1pemVkIHRvIGRpcmVjdGx5XG4gKiBzdG9yZSBwcmUtY29tcHV0ZWQgcGl4ZWxzLCBidXQgdGhlIHNjYWxlIGRpbWVuc2lvbnMgYXJlIG5vdCBndWFyYW50ZWVkIGF0IHRoZSB0aW1lIHdlIG5lZWRcbiAqIHRvIGNyZWF0ZSB0aGUgbG9va3VwIHRhYmxlLiBUaGUgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IHR3byBpdGVtczogbWluIGFuZCBtYXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gdGltZXN0YW1wcyAtIHRpbWVzdGFtcHMgc29ydGVkIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzdHJpYnV0aW9uIC0gSWYgJ2xpbmVhcicsIHRpbWVzdGFtcHMgd2lsbCBiZSBzcHJlYWQgbGluZWFybHkgYWxvbmcgdGhlIG1pblxuICogYW5kIG1heCByYW5nZSwgc28gYmFzaWNhbGx5LCB0aGUgdGFibGUgd2lsbCBjb250YWlucyBvbmx5IHR3byBpdGVtczoge21pbiwgMH0gYW5kIHttYXgsIDF9LlxuICogSWYgJ3NlcmllcycsIHRpbWVzdGFtcHMgd2lsbCBiZSBwb3NpdGlvbmVkIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci4gSW4gdGhpc1xuICogY2FzZSwgb25seSB0aW1lc3RhbXBzIHRoYXQgYnJlYWsgdGhlIHRpbWUgbGluZWFyaXR5IGFyZSByZWdpc3RlcmVkLCBtZWFuaW5nIHRoYXQgaW4gdGhlXG4gKiBiZXN0IGNhc2UsIGFsbCB0aW1lc3RhbXBzIGFyZSBsaW5lYXIsIHRoZSB0YWJsZSBjb250YWlucyBvbmx5IG1pbiBhbmQgbWF4LlxuICovXG5mdW5jdGlvbiBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMsIG1pbiwgbWF4LCBkaXN0cmlidXRpb24pIHtcblx0aWYgKGRpc3RyaWJ1dGlvbiA9PT0gJ2xpbmVhcicgfHwgIXRpbWVzdGFtcHMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHt0aW1lOiBtaW4sIHBvczogMH0sXG5cdFx0XHR7dGltZTogbWF4LCBwb3M6IDF9XG5cdFx0XTtcblx0fVxuXG5cdHZhciB0YWJsZSA9IFtdO1xuXHR2YXIgaXRlbXMgPSBbbWluXTtcblx0dmFyIGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0Y3VyciA9IHRpbWVzdGFtcHNbaV07XG5cdFx0aWYgKGN1cnIgPiBtaW4gJiYgY3VyciA8IG1heCkge1xuXHRcdFx0aXRlbXMucHVzaChjdXJyKTtcblx0XHR9XG5cdH1cblxuXHRpdGVtcy5wdXNoKG1heCk7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdG5leHQgPSBpdGVtc1tpICsgMV07XG5cdFx0cHJldiA9IGl0ZW1zW2kgLSAxXTtcblx0XHRjdXJyID0gaXRlbXNbaV07XG5cblx0XHQvLyBvbmx5IGFkZCBwb2ludHMgdGhhdCBicmVha3MgdGhlIHNjYWxlIGxpbmVhcml0eVxuXHRcdGlmIChwcmV2ID09PSB1bmRlZmluZWQgfHwgbmV4dCA9PT0gdW5kZWZpbmVkIHx8IE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG5cdFx0XHR0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRhYmxlO1xufVxuXG4vLyBAc2VlIGFkYXB0ZWQgZnJvbSBodHRwczovL3d3dy5hbnVqZ2FraGFyLmNvbS8yMDE0LzAzLzAxL2JpbmFyeS1zZWFyY2gtaW4tamF2YXNjcmlwdC9cbmZ1bmN0aW9uIGxvb2t1cCh0YWJsZSwga2V5LCB2YWx1ZSkge1xuXHR2YXIgbG8gPSAwO1xuXHR2YXIgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuXHR2YXIgbWlkLCBpMCwgaTE7XG5cblx0d2hpbGUgKGxvID49IDAgJiYgbG8gPD0gaGkpIHtcblx0XHRtaWQgPSAobG8gKyBoaSkgPj4gMTtcblx0XHRpMCA9IHRhYmxlW21pZCAtIDFdIHx8IG51bGw7XG5cdFx0aTEgPSB0YWJsZVttaWRdO1xuXG5cdFx0aWYgKCFpMCkge1xuXHRcdFx0Ly8gZ2l2ZW4gdmFsdWUgaXMgb3V0c2lkZSB0YWJsZSAoYmVmb3JlIGZpcnN0IGl0ZW0pXG5cdFx0XHRyZXR1cm4ge2xvOiBudWxsLCBoaTogaTF9O1xuXHRcdH0gZWxzZSBpZiAoaTFba2V5XSA8IHZhbHVlKSB7XG5cdFx0XHRsbyA9IG1pZCArIDE7XG5cdFx0fSBlbHNlIGlmIChpMFtrZXldID4gdmFsdWUpIHtcblx0XHRcdGhpID0gbWlkIC0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHtsbzogaTAsIGhpOiBpMX07XG5cdFx0fVxuXHR9XG5cblx0Ly8gZ2l2ZW4gdmFsdWUgaXMgb3V0c2lkZSB0YWJsZSAoYWZ0ZXIgbGFzdCBpdGVtKVxuXHRyZXR1cm4ge2xvOiBpMSwgaGk6IG51bGx9O1xufVxuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlcyB0aGUgZ2l2ZW4gc291cmNlIGB2YWx1ZWAgdXNpbmcgdGhlIHRhYmxlIGl0ZW1zIGBza2V5YCB2YWx1ZXMgYW5kXG4gKiByZXR1cm5zIHRoZSBhc3NvY2lhdGVkIGB0a2V5YCB2YWx1ZS4gRm9yIGV4YW1wbGUsIGludGVycG9sYXRlKHRhYmxlLCAndGltZScsIDQyLCAncG9zJylcbiAqIHJldHVybnMgdGhlIHBvc2l0aW9uIGZvciBhIHRpbWVzdGFtcCBlcXVhbCB0byA0Mi4gSWYgdmFsdWUgaXMgb3V0IG9mIGJvdW5kcywgdmFsdWVzIGF0XG4gKiBpbmRleCBbMCwgMV0gb3IgW24gLSAxLCBuXSBhcmUgdXNlZCBmb3IgdGhlIGludGVycG9sYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlJDEodGFibGUsIHNrZXksIHN2YWwsIHRrZXkpIHtcblx0dmFyIHJhbmdlID0gbG9va3VwKHRhYmxlLCBza2V5LCBzdmFsKTtcblxuXHQvLyBOb3RlOiB0aGUgbG9va3VwIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCAyIGl0ZW1zIChtaW4gYW5kIG1heClcblx0dmFyIHByZXYgPSAhcmFuZ2UubG8gPyB0YWJsZVswXSA6ICFyYW5nZS5oaSA/IHRhYmxlW3RhYmxlLmxlbmd0aCAtIDJdIDogcmFuZ2UubG87XG5cdHZhciBuZXh0ID0gIXJhbmdlLmxvID8gdGFibGVbMV0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAxXSA6IHJhbmdlLmhpO1xuXG5cdHZhciBzcGFuID0gbmV4dFtza2V5XSAtIHByZXZbc2tleV07XG5cdHZhciByYXRpbyA9IHNwYW4gPyAoc3ZhbCAtIHByZXZbc2tleV0pIC8gc3BhbiA6IDA7XG5cdHZhciBvZmZzZXQgPSAobmV4dFt0a2V5XSAtIHByZXZbdGtleV0pICogcmF0aW87XG5cblx0cmV0dXJuIHByZXZbdGtleV0gKyBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIHRvVGltZXN0YW1wKHNjYWxlLCBpbnB1dCkge1xuXHR2YXIgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnMudGltZTtcblx0dmFyIHBhcnNlciA9IG9wdGlvbnMucGFyc2VyO1xuXHR2YXIgZm9ybWF0ID0gcGFyc2VyIHx8IG9wdGlvbnMuZm9ybWF0O1xuXHR2YXIgdmFsdWUgPSBpbnB1dDtcblxuXHRpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcblx0fVxuXG5cdC8vIE9ubHkgcGFyc2UgaWYgaXRzIG5vdCBhIHRpbWVzdGFtcCBhbHJlYWR5XG5cdGlmICghaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSkge1xuXHRcdHZhbHVlID0gdHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZydcblx0XHRcdD8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgZm9ybWF0KVxuXHRcdFx0OiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcblx0fVxuXG5cdGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdHJldHVybiArdmFsdWU7XG5cdH1cblxuXHQvLyBMYWJlbHMgYXJlIGluIGFuIGluY29tcGF0aWJsZSBmb3JtYXQgYW5kIG5vIGBwYXJzZXJgIGhhcyBiZWVuIHByb3ZpZGVkLlxuXHQvLyBUaGUgdXNlciBtaWdodCBzdGlsbCB1c2UgdGhlIGRlcHJlY2F0ZWQgYGZvcm1hdGAgb3B0aW9uIGZvciBwYXJzaW5nLlxuXHRpZiAoIXBhcnNlciAmJiB0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFsdWUgPSBmb3JtYXQoaW5wdXQpO1xuXG5cdFx0Ly8gYGZvcm1hdGAgY291bGQgcmV0dXJuIHNvbWV0aGluZyBlbHNlIHRoYW4gYSB0aW1lc3RhbXAsIGlmIHNvLCBwYXJzZSBpdFxuXHRcdGlmICghaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xuXHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnMudGltZTtcblx0dmFyIHZhbHVlID0gdG9UaW1lc3RhbXAoc2NhbGUsIHNjYWxlLmdldFJpZ2h0VmFsdWUoaW5wdXQpKTtcblx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMucm91bmQpIHtcblx0XHR2YWx1ZSA9ICtzY2FsZS5fYWRhcHRlci5zdGFydE9mKHZhbHVlLCBvcHRpb25zLnJvdW5kKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdW5pdCB0byBza2lwIHRvIGJlIGFibGUgdG8gZGlzcGxheSB1cCB0byBgY2FwYWNpdHlgIG51bWJlciBvZiB0aWNrc1xuICogaW4gYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYG1pbmAgLyBgbWF4YCByYW5nZSBhbmQgcmVzcGVjdGluZyB0aGUgaW50ZXJ2YWwgc3RlcHMgY29uc3RyYWludHMuXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVN0ZXBTaXplKG1pbiwgbWF4LCB1bml0LCBjYXBhY2l0eSkge1xuXHR2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG5cdHZhciBpbnRlcnZhbCA9IElOVEVSVkFMU1t1bml0XTtcblx0dmFyIG1pbGxpc2Vjb25kcyA9IGludGVydmFsLnNpemU7XG5cdHZhciBzdGVwcyA9IGludGVydmFsLnN0ZXBzO1xuXHR2YXIgaSwgaWxlbiwgZmFjdG9yO1xuXG5cdGlmICghc3RlcHMpIHtcblx0XHRyZXR1cm4gTWF0aC5jZWlsKHJhbmdlIC8gKGNhcGFjaXR5ICogbWlsbGlzZWNvbmRzKSk7XG5cdH1cblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gc3RlcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0ZmFjdG9yID0gc3RlcHNbaV07XG5cdFx0aWYgKE1hdGguY2VpbChyYW5nZSAvIChtaWxsaXNlY29uZHMgKiBmYWN0b3IpKSA8PSBjYXBhY2l0eSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhY3Rvcjtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgcmVzdWx0cyBpbiBhbiBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXV0by1nZW5lcmF0ZWQgdGlja3NcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcblx0dmFyIGlsZW4gPSBVTklUUy5sZW5ndGg7XG5cdHZhciBpLCBpbnRlcnZhbCwgZmFjdG9yO1xuXG5cdGZvciAoaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG5cdFx0aW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuXHRcdGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHNbaW50ZXJ2YWwuc3RlcHMubGVuZ3RoIC0gMV0gOiBNQVhfSU5URUdFUjtcblxuXHRcdGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuXHRcdFx0cmV0dXJuIFVOSVRTW2ldO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBVTklUU1tpbGVuIC0gMV07XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHRvIGZvcm1hdCBhIHNldCBvZiB0aWNrcyB3aXRoXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCB0aWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcblx0dmFyIGlsZW4gPSBVTklUUy5sZW5ndGg7XG5cdHZhciBpLCB1bml0O1xuXG5cdGZvciAoaSA9IGlsZW4gLSAxOyBpID49IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGktLSkge1xuXHRcdHVuaXQgPSBVTklUU1tpXTtcblx0XHRpZiAoSU5URVJWQUxTW3VuaXRdLmNvbW1vbiAmJiBzY2FsZS5fYWRhcHRlci5kaWZmKG1heCwgbWluLCB1bml0KSA+PSB0aWNrcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB1bml0O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBVTklUU1ttaW5Vbml0ID8gVU5JVFMuaW5kZXhPZihtaW5Vbml0KSA6IDBdO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuXHRmb3IgKHZhciBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcblx0XHRcdHJldHVybiBVTklUU1tpXTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtYXhpbXVtIG9mIGBjYXBhY2l0eWAgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCByb3VuZGVkIHRvIHRoZVxuICogYG1pbm9yYCB1bml0LCBhbGlnbmVkIG9uIHRoZSBgbWFqb3JgIHVuaXQgYW5kIHVzaW5nIHRoZSBnaXZlbiBzY2FsZSB0aW1lIGBvcHRpb25zYC5cbiAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcbiAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGUoc2NhbGUsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuXHR2YXIgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG5cdHZhciB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcblx0dmFyIG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSk7XG5cdHZhciBtYWpvciA9IGRldGVybWluZU1ham9yVW5pdChtaW5vcik7XG5cdHZhciBzdGVwU2l6ZSA9IHZhbHVlT3JEZWZhdWx0JGModGltZU9wdHMuc3RlcFNpemUsIHRpbWVPcHRzLnVuaXRTdGVwU2l6ZSk7XG5cdHZhciB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcblx0dmFyIG1ham9yVGlja3NFbmFibGVkID0gb3B0aW9ucy50aWNrcy5tYWpvci5lbmFibGVkO1xuXHR2YXIgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbbWlub3JdO1xuXHR2YXIgZmlyc3QgPSBtaW47XG5cdHZhciBsYXN0ID0gbWF4O1xuXHR2YXIgdGlja3MgPSBbXTtcblx0dmFyIHRpbWU7XG5cblx0aWYgKCFzdGVwU2l6ZSkge1xuXHRcdHN0ZXBTaXplID0gZGV0ZXJtaW5lU3RlcFNpemUobWluLCBtYXgsIG1pbm9yLCBjYXBhY2l0eSk7XG5cdH1cblxuXHQvLyBGb3IgJ3dlZWsnIHVuaXQsIGhhbmRsZSB0aGUgZmlyc3QgZGF5IG9mIHdlZWsgb3B0aW9uXG5cdGlmICh3ZWVrZGF5KSB7XG5cdFx0Zmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuXHRcdGxhc3QgPSArYWRhcHRlci5zdGFydE9mKGxhc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG5cdH1cblxuXHQvLyBBbGlnbiBmaXJzdC9sYXN0IHRpY2tzIG9uIHVuaXRcblx0Zmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCB3ZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG5cdGxhc3QgPSArYWRhcHRlci5zdGFydE9mKGxhc3QsIHdlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcblxuXHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgbGFzdCB0aWNrIGluY2x1ZGUgbWF4XG5cdGlmIChsYXN0IDwgbWF4KSB7XG5cdFx0bGFzdCA9ICthZGFwdGVyLmFkZChsYXN0LCAxLCBtaW5vcik7XG5cdH1cblxuXHR0aW1lID0gZmlyc3Q7XG5cblx0aWYgKG1ham9yVGlja3NFbmFibGVkICYmIG1ham9yICYmICF3ZWVrZGF5ICYmICF0aW1lT3B0cy5yb3VuZCkge1xuXHRcdC8vIEFsaWduIHRoZSBmaXJzdCB0aWNrIG9uIHRoZSBwcmV2aW91cyBgbWlub3JgIHVuaXQgYWxpZ25lZCBvbiB0aGUgYG1ham9yYCB1bml0OlxuXHRcdC8vIHdlIGZpcnN0IGFsaWduZWQgdGltZSBvbiB0aGUgcHJldmlvdXMgYG1ham9yYCB1bml0IHRoZW4gYWRkIHRoZSBudW1iZXIgb2YgZnVsbFxuXHRcdC8vIHN0ZXBTaXplIHRoZXJlIGlzIGJldHdlZW4gZmlyc3QgYW5kIHRoZSBwcmV2aW91cyBtYWpvciB0aW1lLlxuXHRcdHRpbWUgPSArYWRhcHRlci5zdGFydE9mKHRpbWUsIG1ham9yKTtcblx0XHR0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIH5+KChmaXJzdCAtIHRpbWUpIC8gKGludGVydmFsLnNpemUgKiBzdGVwU2l6ZSkpICogc3RlcFNpemUsIG1pbm9yKTtcblx0fVxuXG5cdGZvciAoOyB0aW1lIDwgbGFzdDsgdGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCBzdGVwU2l6ZSwgbWlub3IpKSB7XG5cdFx0dGlja3MucHVzaCgrdGltZSk7XG5cdH1cblxuXHR0aWNrcy5wdXNoKCt0aW1lKTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBvZmZzZXRzIGZyb20gZWRnZXMgaW4gdGhlIGZvcm0gb2Yge3N0YXJ0LCBlbmR9XG4gKiB3aGVyZSBlYWNoIHZhbHVlIGlzIGEgcmVsYXRpdmUgd2lkdGggdG8gdGhlIHNjYWxlIGFuZCByYW5nZXMgYmV0d2VlbiAwIGFuZCAxLlxuICogVGhleSBhZGQgZXh0cmEgbWFyZ2lucyBvbiB0aGUgYm90aCBzaWRlcyBieSBzY2FsaW5nIGRvd24gdGhlIG9yaWdpbmFsIHNjYWxlLlxuICogT2Zmc2V0cyBhcmUgYWRkZWQgd2hlbiB0aGUgYG9mZnNldGAgb3B0aW9uIGlzIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKHRhYmxlLCB0aWNrcywgbWluLCBtYXgsIG9wdGlvbnMpIHtcblx0dmFyIHN0YXJ0ID0gMDtcblx0dmFyIGVuZCA9IDA7XG5cdHZhciBmaXJzdCwgbGFzdDtcblxuXHRpZiAob3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG5cdFx0aWYgKCFvcHRpb25zLnRpbWUubWluKSB7XG5cdFx0XHRmaXJzdCA9IGludGVycG9sYXRlJDEodGFibGUsICd0aW1lJywgdGlja3NbMF0sICdwb3MnKTtcblx0XHRcdGlmICh0aWNrcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0c3RhcnQgPSAxIC0gZmlyc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdGFydCA9IChpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzWzFdLCAncG9zJykgLSBmaXJzdCkgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIW9wdGlvbnMudGltZS5tYXgpIHtcblx0XHRcdGxhc3QgPSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLCAncG9zJyk7XG5cdFx0XHRpZiAodGlja3MubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGVuZCA9IGxhc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbmQgPSAobGFzdCAtIGludGVycG9sYXRlJDEodGFibGUsICd0aW1lJywgdGlja3NbdGlja3MubGVuZ3RoIC0gMl0sICdwb3MnKSkgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7c3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH07XG59XG5cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG5cdHZhciB0aWNrcyA9IFtdO1xuXHR2YXIgaSwgaWxlbiwgdmFsdWUsIG1ham9yO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0dmFsdWUgPSB2YWx1ZXNbaV07XG5cdFx0bWFqb3IgPSBtYWpvclVuaXQgPyB2YWx1ZSA9PT0gK3NjYWxlLl9hZGFwdGVyLnN0YXJ0T2YodmFsdWUsIG1ham9yVW5pdCkgOiBmYWxzZTtcblxuXHRcdHRpY2tzLnB1c2goe1xuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0bWFqb3I6IG1ham9yXG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbnZhciBkZWZhdWx0Q29uZmlnJDQgPSB7XG5cdHBvc2l0aW9uOiAnYm90dG9tJyxcblxuXHQvKipcblx0ICogRGF0YSBkaXN0cmlidXRpb24gYWxvbmcgdGhlIHNjYWxlOlxuXHQgKiAtICdsaW5lYXInOiBkYXRhIGFyZSBzcHJlYWQgYWNjb3JkaW5nIHRvIHRoZWlyIHRpbWUgKGRpc3RhbmNlcyBjYW4gdmFyeSksXG5cdCAqIC0gJ3Nlcmllcyc6IGRhdGEgYXJlIHNwcmVhZCBhdCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuXG5cdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTA3XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0ZGlzdHJpYnV0aW9uOiAnbGluZWFyJyxcblxuXHQvKipcblx0ICogU2NhbGUgYm91bmRhcnkgc3RyYXRlZ3kgKGJ5cGFzc2VkIGJ5IG1pbi9tYXggdGltZSBvcHRpb25zKVxuXHQgKiAtIGBkYXRhYDogbWFrZSBzdXJlIGRhdGEgYXJlIGZ1bGx5IHZpc2libGUsIHRpY2tzIG91dHNpZGUgYXJlIHJlbW92ZWRcblx0ICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG5cdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTU2XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0Ym91bmRzOiAnZGF0YScsXG5cblx0YWRhcHRlcnM6IHt9LFxuXHR0aW1lOiB7XG5cdFx0cGFyc2VyOiBmYWxzZSwgLy8gZmFsc2UgPT0gYSBwYXR0ZXJuIHN0cmluZyBmcm9tIGh0dHBzOi8vbW9tZW50anMuY29tL2RvY3MvIy9wYXJzaW5nL3N0cmluZy1mb3JtYXQvIG9yIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgY29udmVydHMgaXRzIGFyZ3VtZW50IHRvIGEgbW9tZW50XG5cdFx0Zm9ybWF0OiBmYWxzZSwgLy8gREVQUkVDQVRFRCBmYWxzZSA9PSBkYXRlIG9iamVjdHMsIG1vbWVudCBvYmplY3QsIGNhbGxiYWNrIG9yIGEgcGF0dGVybiBzdHJpbmcgZnJvbSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0L1xuXHRcdHVuaXQ6IGZhbHNlLCAvLyBmYWxzZSA9PSBhdXRvbWF0aWMgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuXHRcdHJvdW5kOiBmYWxzZSwgLy8gbm9uZSwgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuXHRcdGRpc3BsYXlGb3JtYXQ6IGZhbHNlLCAvLyBERVBSRUNBVEVEXG5cdFx0aXNvV2Vla2RheTogZmFsc2UsIC8vIG92ZXJyaWRlIHdlZWsgc3RhcnQgZGF5IC0gc2VlIGh0dHBzOi8vbW9tZW50anMuY29tL2RvY3MvIy9nZXQtc2V0L2lzby13ZWVrZGF5L1xuXHRcdG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG5cdFx0ZGlzcGxheUZvcm1hdHM6IHt9XG5cdH0sXG5cdHRpY2tzOiB7XG5cdFx0YXV0b1NraXA6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0ICogVGlja3MgZ2VuZXJhdGlvbiBpbnB1dCB2YWx1ZXM6XG5cdFx0ICogLSAnYXV0byc6IGdlbmVyYXRlcyBcIm9wdGltYWxcIiB0aWNrcyBiYXNlZCBvbiBzY2FsZSBzaXplIGFuZCB0aW1lIG9wdGlvbnMuXG5cdFx0ICogLSAnZGF0YSc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIGRhdGEgKGluY2x1ZGluZyBsYWJlbHMgZnJvbSBkYXRhIHt0fHh8eX0gb2JqZWN0cykuXG5cdFx0ICogLSAnbGFiZWxzJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gdXNlciBnaXZlbiBgZGF0YS5sYWJlbHNgIHZhbHVlcyBPTkxZLlxuXHRcdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTA3XG5cdFx0ICogQHNpbmNlIDIuNy4wXG5cdFx0ICovXG5cdFx0c291cmNlOiAnYXV0bycsXG5cblx0XHRtYWpvcjoge1xuXHRcdFx0ZW5hYmxlZDogZmFsc2Vcblx0XHR9XG5cdH1cbn07XG5cbnZhciBzY2FsZV90aW1lID0gY29yZV9zY2FsZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm1lcmdlVGlja3NPcHRpb25zKCk7XG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHRpbWUgPSBvcHRpb25zLnRpbWUgfHwgKG9wdGlvbnMudGltZSA9IHt9KTtcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyID0gbmV3IGNvcmVfYWRhcHRlcnMuX2RhdGUob3B0aW9ucy5hZGFwdGVycy5kYXRlKTtcblxuXHRcdC8vIERFUFJFQ0FUSU9OUzogb3V0cHV0IGEgbWVzc2FnZSBvbmx5IG9uZSB0aW1lIHBlciB1cGRhdGVcblx0XHRpZiAodGltZS5mb3JtYXQpIHtcblx0XHRcdGNvbnNvbGUud2Fybignb3B0aW9ucy50aW1lLmZvcm1hdCBpcyBkZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBvcHRpb25zLnRpbWUucGFyc2VyLicpO1xuXHRcdH1cblxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGJlZm9yZSBpbnRyb2R1Y2luZyBhZGFwdGVyLCBgZGlzcGxheUZvcm1hdHNgIHdhc1xuXHRcdC8vIHN1cHBvc2VkIHRvIGNvbnRhaW4gKmFsbCogdW5pdC9zdHJpbmcgcGFpcnMgYnV0IHRoaXMgY2FuJ3QgYmUgcmVzb2x2ZWRcblx0XHQvLyB3aGVuIGxvYWRpbmcgdGhlIHNjYWxlIChhZGFwdGVycyBhcmUgbG9hZGVkIGFmdGVyd2FyZCksIHNvIGxldCdzIHBvcHVsYXRlXG5cdFx0Ly8gbWlzc2luZyBmb3JtYXRzIG9uIHVwZGF0ZVxuXHRcdGhlbHBlcnMkMS5tZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcblxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS51cGRhdGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFsbG93cyBkYXRhIHRvIGJlIHJlZmVyZW5jZWQgdmlhICd0JyBhdHRyaWJ1dGVcblx0ICovXG5cdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XG5cdFx0aWYgKHJhd1ZhbHVlICYmIHJhd1ZhbHVlLnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmF3VmFsdWUgPSByYXdWYWx1ZS50O1xuXHRcdH1cblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUuZ2V0UmlnaHRWYWx1ZS5jYWxsKHRoaXMsIHJhd1ZhbHVlKTtcblx0fSxcblxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBhZGFwdGVyID0gbWUuX2FkYXB0ZXI7XG5cdFx0dmFyIHRpbWVPcHRzID0gbWUub3B0aW9ucy50aW1lO1xuXHRcdHZhciB1bml0ID0gdGltZU9wdHMudW5pdCB8fCAnZGF5Jztcblx0XHR2YXIgbWluID0gTUFYX0lOVEVHRVI7XG5cdFx0dmFyIG1heCA9IE1JTl9JTlRFR0VSO1xuXHRcdHZhciB0aW1lc3RhbXBzID0gW107XG5cdFx0dmFyIGRhdGFzZXRzID0gW107XG5cdFx0dmFyIGxhYmVscyA9IFtdO1xuXHRcdHZhciBpLCBqLCBpbGVuLCBqbGVuLCBkYXRhLCB0aW1lc3RhbXA7XG5cdFx0dmFyIGRhdGFMYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcblxuXHRcdC8vIENvbnZlcnQgbGFiZWxzIHRvIHRpbWVzdGFtcHNcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YUxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGxhYmVscy5wdXNoKHBhcnNlKG1lLCBkYXRhTGFiZWxzW2ldKSk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIHRvIHRpbWVzdGFtcHNcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0ZGF0YSA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0uZGF0YTtcblxuXHRcdFx0XHQvLyBMZXQncyBjb25zaWRlciB0aGF0IGFsbCBkYXRhIGhhdmUgdGhlIHNhbWUgZm9ybWF0LlxuXHRcdFx0XHRpZiAoaGVscGVycyQxLmlzT2JqZWN0KGRhdGFbMF0pKSB7XG5cdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuXHRcdFx0XHRcdFx0dGltZXN0YW1wID0gcGFyc2UobWUsIGRhdGFbal0pO1xuXHRcdFx0XHRcdFx0dGltZXN0YW1wcy5wdXNoKHRpbWVzdGFtcCk7XG5cdFx0XHRcdFx0XHRkYXRhc2V0c1tpXVtqXSA9IHRpbWVzdGFtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGxhYmVscy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcHMucHVzaChsYWJlbHNbal0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhc2V0c1tpXSA9IGxhYmVscy5zbGljZSgwKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YXNldHNbaV0gPSBbXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobGFiZWxzLmxlbmd0aCkge1xuXHRcdFx0Ly8gU29ydCBsYWJlbHMgKiphZnRlcioqIGRhdGEgaGF2ZSBiZWVuIGNvbnZlcnRlZFxuXHRcdFx0bGFiZWxzID0gYXJyYXlVbmlxdWUobGFiZWxzKS5zb3J0KHNvcnRlcik7XG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIGxhYmVsc1swXSk7XG5cdFx0XHRtYXggPSBNYXRoLm1heChtYXgsIGxhYmVsc1tsYWJlbHMubGVuZ3RoIC0gMV0pO1xuXHRcdH1cblxuXHRcdGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdFx0dGltZXN0YW1wcyA9IGFycmF5VW5pcXVlKHRpbWVzdGFtcHMpLnNvcnQoc29ydGVyKTtcblx0XHRcdG1pbiA9IE1hdGgubWluKG1pbiwgdGltZXN0YW1wc1swXSk7XG5cdFx0XHRtYXggPSBNYXRoLm1heChtYXgsIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XG5cdFx0fVxuXG5cdFx0bWluID0gcGFyc2UobWUsIHRpbWVPcHRzLm1pbikgfHwgbWluO1xuXHRcdG1heCA9IHBhcnNlKG1lLCB0aW1lT3B0cy5tYXgpIHx8IG1heDtcblxuXHRcdC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gdmFsaWQgbWluL21heCwgc2V0IGxpbWl0cyBiYXNlZCBvbiB1bml0IHRpbWUgb3B0aW9uXG5cdFx0bWluID0gbWluID09PSBNQVhfSU5URUdFUiA/ICthZGFwdGVyLnN0YXJ0T2YoRGF0ZS5ub3coKSwgdW5pdCkgOiBtaW47XG5cdFx0bWF4ID0gbWF4ID09PSBNSU5fSU5URUdFUiA/ICthZGFwdGVyLmVuZE9mKERhdGUubm93KCksIHVuaXQpICsgMSA6IG1heDtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG1heCBpcyBzdHJpY3RseSBoaWdoZXIgdGhhbiBtaW4gKHJlcXVpcmVkIGJ5IHRoZSBsb29rdXAgdGFibGUpXG5cdFx0bWUubWluID0gTWF0aC5taW4obWluLCBtYXgpO1xuXHRcdG1lLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG5cblx0XHQvLyBQUklWQVRFXG5cdFx0bWUuX2hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRtZS5fdGFibGUgPSBbXTtcblx0XHRtZS5fdGltZXN0YW1wcyA9IHtcblx0XHRcdGRhdGE6IHRpbWVzdGFtcHMsXG5cdFx0XHRkYXRhc2V0czogZGF0YXNldHMsXG5cdFx0XHRsYWJlbHM6IGxhYmVsc1xuXHRcdH07XG5cdH0sXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWluID0gbWUubWluO1xuXHRcdHZhciBtYXggPSBtZS5tYXg7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcblx0XHR2YXIgdGltZXN0YW1wcyA9IFtdO1xuXHRcdHZhciB0aWNrcyA9IFtdO1xuXHRcdHZhciBpLCBpbGVuLCB0aW1lc3RhbXA7XG5cblx0XHRzd2l0Y2ggKG9wdGlvbnMudGlja3Muc291cmNlKSB7XG5cdFx0Y2FzZSAnZGF0YSc6XG5cdFx0XHR0aW1lc3RhbXBzID0gbWUuX3RpbWVzdGFtcHMuZGF0YTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2xhYmVscyc6XG5cdFx0XHR0aW1lc3RhbXBzID0gbWUuX3RpbWVzdGFtcHMubGFiZWxzO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnYXV0byc6XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRpbWVzdGFtcHMgPSBnZW5lcmF0ZShtZSwgbWluLCBtYXgsIG1lLmdldExhYmVsQ2FwYWNpdHkobWluKSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG5cdFx0XHRtaW4gPSB0aW1lc3RhbXBzWzBdO1xuXHRcdFx0bWF4ID0gdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuXHRcdH1cblxuXHRcdC8vIEVuZm9yY2UgbGltaXRzIHdpdGggdXNlciBtaW4vbWF4IG9wdGlvbnNcblx0XHRtaW4gPSBwYXJzZShtZSwgdGltZU9wdHMubWluKSB8fCBtaW47XG5cdFx0bWF4ID0gcGFyc2UobWUsIHRpbWVPcHRzLm1heCkgfHwgbWF4O1xuXG5cdFx0Ly8gUmVtb3ZlIHRpY2tzIG91dHNpZGUgdGhlIG1pbi9tYXggcmFuZ2Vcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbaV07XG5cdFx0XHRpZiAodGltZXN0YW1wID49IG1pbiAmJiB0aW1lc3RhbXAgPD0gbWF4KSB7XG5cdFx0XHRcdHRpY2tzLnB1c2godGltZXN0YW1wKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS5taW4gPSBtaW47XG5cdFx0bWUubWF4ID0gbWF4O1xuXG5cdFx0Ly8gUFJJVkFURVxuXHRcdG1lLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhtZSwgdGlja3MsIHRpbWVPcHRzLm1pblVuaXQsIG1lLm1pbiwgbWUubWF4KTtcblx0XHRtZS5fbWFqb3JVbml0ID0gZGV0ZXJtaW5lTWFqb3JVbml0KG1lLl91bml0KTtcblx0XHRtZS5fdGFibGUgPSBidWlsZExvb2t1cFRhYmxlKG1lLl90aW1lc3RhbXBzLmRhdGEsIG1pbiwgbWF4LCBvcHRpb25zLmRpc3RyaWJ1dGlvbik7XG5cdFx0bWUuX29mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyhtZS5fdGFibGUsIHRpY2tzLCBtaW4sIG1heCwgb3B0aW9ucyk7XG5cblx0XHRpZiAob3B0aW9ucy50aWNrcy5yZXZlcnNlKSB7XG5cdFx0XHR0aWNrcy5yZXZlcnNlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHMobWUsIHRpY2tzLCBtZS5fbWFqb3JVbml0KTtcblx0fSxcblxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuXHRcdHZhciBkYXRhID0gbWUuY2hhcnQuZGF0YTtcblx0XHR2YXIgdGltZU9wdHMgPSBtZS5vcHRpb25zLnRpbWU7XG5cdFx0dmFyIGxhYmVsID0gZGF0YS5sYWJlbHMgJiYgaW5kZXggPCBkYXRhLmxhYmVscy5sZW5ndGggPyBkYXRhLmxhYmVsc1tpbmRleF0gOiAnJztcblx0XHR2YXIgdmFsdWUgPSBkYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF07XG5cblx0XHRpZiAoaGVscGVycyQxLmlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdFx0bGFiZWwgPSBtZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcblx0XHR9XG5cdFx0aWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcblx0XHRcdHJldHVybiBhZGFwdGVyLmZvcm1hdCh0b1RpbWVzdGFtcChtZSwgbGFiZWwpLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBsYWJlbDtcblx0XHR9XG5cdFx0cmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHRvVGltZXN0YW1wKG1lLCBsYWJlbCksIHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcblx0fSxcblxuXHQvKipcblx0ICogRnVuY3Rpb24gdG8gZm9ybWF0IGFuIGluZGl2aWR1YWwgdGljayBtYXJrXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR0aWNrRm9ybWF0RnVuY3Rpb246IGZ1bmN0aW9uKHRpbWUsIGluZGV4LCB0aWNrcywgZm9ybWF0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcblx0XHR2YXIgbWlub3JGb3JtYXQgPSBmb3JtYXRzW21lLl91bml0XTtcblx0XHR2YXIgbWFqb3JVbml0ID0gbWUuX21ham9yVW5pdDtcblx0XHR2YXIgbWFqb3JGb3JtYXQgPSBmb3JtYXRzW21ham9yVW5pdF07XG5cdFx0dmFyIG1ham9yVGltZSA9ICthZGFwdGVyLnN0YXJ0T2YodGltZSwgbWFqb3JVbml0KTtcblx0XHR2YXIgbWFqb3JUaWNrT3B0cyA9IG9wdGlvbnMudGlja3MubWFqb3I7XG5cdFx0dmFyIG1ham9yID0gbWFqb3JUaWNrT3B0cy5lbmFibGVkICYmIG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aW1lID09PSBtYWpvclRpbWU7XG5cdFx0dmFyIGxhYmVsID0gYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0ID8gZm9ybWF0IDogbWFqb3IgPyBtYWpvckZvcm1hdCA6IG1pbm9yRm9ybWF0KTtcblx0XHR2YXIgdGlja09wdHMgPSBtYWpvciA/IG1ham9yVGlja09wdHMgOiBvcHRpb25zLnRpY2tzLm1pbm9yO1xuXHRcdHZhciBmb3JtYXR0ZXIgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpY2tPcHRzLmNhbGxiYWNrLCB0aWNrT3B0cy51c2VyQ2FsbGJhY2spO1xuXG5cdFx0cmV0dXJuIGZvcm1hdHRlciA/IGZvcm1hdHRlcihsYWJlbCwgaW5kZXgsIHRpY2tzKSA6IGxhYmVsO1xuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciBsYWJlbHMgPSBbXTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGxhYmVscy5wdXNoKHRoaXMudGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2tzW2ldLnZhbHVlLCBpLCB0aWNrcykpO1xuXHRcdH1cblxuXHRcdHJldHVybiBsYWJlbHM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRQaXhlbEZvck9mZnNldDogZnVuY3Rpb24odGltZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGlzUmV2ZXJzZSA9IG1lLm9wdGlvbnMudGlja3MucmV2ZXJzZTtcblx0XHR2YXIgc2l6ZSA9IG1lLl9ob3Jpem9udGFsID8gbWUud2lkdGggOiBtZS5oZWlnaHQ7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuX2hvcml6b250YWwgPyBpc1JldmVyc2UgPyBtZS5yaWdodCA6IG1lLmxlZnQgOiBpc1JldmVyc2UgPyBtZS5ib3R0b20gOiBtZS50b3A7XG5cdFx0dmFyIHBvcyA9IGludGVycG9sYXRlJDEobWUuX3RhYmxlLCAndGltZScsIHRpbWUsICdwb3MnKTtcblx0XHR2YXIgb2Zmc2V0ID0gc2l6ZSAqIChtZS5fb2Zmc2V0cy5zdGFydCArIHBvcykgLyAobWUuX29mZnNldHMuc3RhcnQgKyAxICsgbWUuX29mZnNldHMuZW5kKTtcblxuXHRcdHJldHVybiBpc1JldmVyc2UgPyBzdGFydCAtIG9mZnNldCA6IHN0YXJ0ICsgb2Zmc2V0O1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGltZSA9IG51bGw7XG5cblx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGltZSA9IG1lLl90aW1lc3RhbXBzLmRhdGFzZXRzW2RhdGFzZXRJbmRleF1baW5kZXhdO1xuXHRcdH1cblxuXHRcdGlmICh0aW1lID09PSBudWxsKSB7XG5cdFx0XHR0aW1lID0gcGFyc2UobWUsIHZhbHVlKTtcblx0XHR9XG5cblx0XHRpZiAodGltZSAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG1lLmdldFBpeGVsRm9yT2Zmc2V0KHRpbWUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIHRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuXHRcdHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoID9cblx0XHRcdHRoaXMuZ2V0UGl4ZWxGb3JPZmZzZXQodGlja3NbaW5kZXhdLnZhbHVlKSA6XG5cdFx0XHRudWxsO1xuXHR9LFxuXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc2l6ZSA9IG1lLl9ob3Jpem9udGFsID8gbWUud2lkdGggOiBtZS5oZWlnaHQ7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuX2hvcml6b250YWwgPyBtZS5sZWZ0IDogbWUudG9wO1xuXHRcdHZhciBwb3MgPSAoc2l6ZSA/IChwaXhlbCAtIHN0YXJ0KSAvIHNpemUgOiAwKSAqIChtZS5fb2Zmc2V0cy5zdGFydCArIDEgKyBtZS5fb2Zmc2V0cy5zdGFydCkgLSBtZS5fb2Zmc2V0cy5lbmQ7XG5cdFx0dmFyIHRpbWUgPSBpbnRlcnBvbGF0ZSQxKG1lLl90YWJsZSwgJ3BvcycsIHBvcywgJ3RpbWUnKTtcblxuXHRcdC8vIERFUFJFQ0FUSU9OLCB3ZSBzaG91bGQgcmV0dXJuIHRpbWUgZGlyZWN0bHlcblx0XHRyZXR1cm4gbWUuX2FkYXB0ZXIuX2NyZWF0ZSh0aW1lKTtcblx0fSxcblxuXHQvKipcblx0ICogQ3J1ZGUgYXBwcm94aW1hdGlvbiBvZiB3aGF0IHRoZSBsYWJlbCB3aWR0aCBtaWdodCBiZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0TGFiZWxXaWR0aDogZnVuY3Rpb24obGFiZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrc09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciB0aWNrTGFiZWxXaWR0aCA9IG1lLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG5cdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvUmFkaWFucyh0aWNrc09wdHMubWF4Um90YXRpb24pO1xuXHRcdHZhciBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHR2YXIgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0dmFyIHRpY2tGb250U2l6ZSA9IHZhbHVlT3JEZWZhdWx0JGModGlja3NPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpO1xuXG5cdFx0cmV0dXJuICh0aWNrTGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBzaW5Sb3RhdGlvbik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRMYWJlbENhcGFjaXR5OiBmdW5jdGlvbihleGFtcGxlVGltZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHQvLyBwaWNrIHRoZSBsb25nZXN0IGZvcm1hdCAobWlsbGlzZWNvbmRzKSBmb3IgZ3Vlc3RpbWF0aW9uXG5cdFx0dmFyIGZvcm1hdCA9IG1lLm9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcblx0XHR2YXIgZXhhbXBsZUxhYmVsID0gbWUudGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCBbXSwgZm9ybWF0KTtcblx0XHR2YXIgdGlja0xhYmVsV2lkdGggPSBtZS5nZXRMYWJlbFdpZHRoKGV4YW1wbGVMYWJlbCk7XG5cdFx0dmFyIGlubmVyV2lkdGggPSBtZS5pc0hvcml6b250YWwoKSA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBjYXBhY2l0eSA9IE1hdGguZmxvb3IoaW5uZXJXaWR0aCAvIHRpY2tMYWJlbFdpZHRoKTtcblxuXHRcdHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMkNCA9IGRlZmF1bHRDb25maWckNDtcbnNjYWxlX3RpbWUuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDQ7XG5cbnZhciBzY2FsZXMgPSB7XG5cdGNhdGVnb3J5OiBzY2FsZV9jYXRlZ29yeSxcblx0bGluZWFyOiBzY2FsZV9saW5lYXIsXG5cdGxvZ2FyaXRobWljOiBzY2FsZV9sb2dhcml0aG1pYyxcblx0cmFkaWFsTGluZWFyOiBzY2FsZV9yYWRpYWxMaW5lYXIsXG5cdHRpbWU6IHNjYWxlX3RpbWVcbn07XG5cbnZhciBGT1JNQVRTID0ge1xuXHRkYXRldGltZTogJ01NTSBELCBZWVlZLCBoOm1tOnNzIGEnLFxuXHRtaWxsaXNlY29uZDogJ2g6bW06c3MuU1NTIGEnLFxuXHRzZWNvbmQ6ICdoOm1tOnNzIGEnLFxuXHRtaW51dGU6ICdoOm1tIGEnLFxuXHRob3VyOiAnaEEnLFxuXHRkYXk6ICdNTU0gRCcsXG5cdHdlZWs6ICdsbCcsXG5cdG1vbnRoOiAnTU1NIFlZWVknLFxuXHRxdWFydGVyOiAnW1FdUSAtIFlZWVknLFxuXHR5ZWFyOiAnWVlZWSdcbn07XG5cbmNvcmVfYWRhcHRlcnMuX2RhdGUub3ZlcnJpZGUodHlwZW9mIG1vbWVudCA9PT0gJ2Z1bmN0aW9uJyA/IHtcblx0X2lkOiAnbW9tZW50JywgLy8gREVCVUcgT05MWVxuXG5cdGZvcm1hdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBGT1JNQVRTO1xuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0KSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhbHVlID0gbW9tZW50KHZhbHVlLCBmb3JtYXQpO1xuXHRcdH0gZWxzZSBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIG1vbWVudCkpIHtcblx0XHRcdHZhbHVlID0gbW9tZW50KHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlLmlzVmFsaWQoKSA/IHZhbHVlLnZhbHVlT2YoKSA6IG51bGw7XG5cdH0sXG5cblx0Zm9ybWF0OiBmdW5jdGlvbih0aW1lLCBmb3JtYXQpIHtcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpLmZvcm1hdChmb3JtYXQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24odGltZSwgYW1vdW50LCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5hZGQoYW1vdW50LCB1bml0KS52YWx1ZU9mKCk7XG5cdH0sXG5cblx0ZGlmZjogZnVuY3Rpb24obWF4LCBtaW4sIHVuaXQpIHtcblx0XHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKG1vbWVudChtYXgpLmRpZmYobW9tZW50KG1pbikpKS5hcyh1bml0KTtcblx0fSxcblxuXHRzdGFydE9mOiBmdW5jdGlvbih0aW1lLCB1bml0LCB3ZWVrZGF5KSB7XG5cdFx0dGltZSA9IG1vbWVudCh0aW1lKTtcblx0XHRpZiAodW5pdCA9PT0gJ2lzb1dlZWsnKSB7XG5cdFx0XHRyZXR1cm4gdGltZS5pc29XZWVrZGF5KHdlZWtkYXkpLnZhbHVlT2YoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRpbWUuc3RhcnRPZih1bml0KS52YWx1ZU9mKCk7XG5cdH0sXG5cblx0ZW5kT2Y6IGZ1bmN0aW9uKHRpbWUsIHVuaXQpIHtcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpLmVuZE9mKHVuaXQpLnZhbHVlT2YoKTtcblx0fSxcblxuXHQvLyBERVBSRUNBVElPTlNcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBzY2FsZS5nZXRWYWx1ZUZvclBpeGVsKCkuXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyZWF0ZTogZnVuY3Rpb24odGltZSkge1xuXHRcdHJldHVybiBtb21lbnQodGltZSk7XG5cdH0sXG59IDoge30pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0cGx1Z2luczoge1xuXHRcdGZpbGxlcjoge1xuXHRcdFx0cHJvcGFnYXRlOiB0cnVlXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIG1hcHBlcnMgPSB7XG5cdGRhdGFzZXQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHZhciBpbmRleCA9IHNvdXJjZS5maWxsO1xuXHRcdHZhciBjaGFydCA9IHNvdXJjZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcblx0XHR2YXIgdmlzaWJsZSA9IG1ldGEgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCk7XG5cdFx0dmFyIHBvaW50cyA9ICh2aXNpYmxlICYmIG1ldGEuZGF0YXNldC5fY2hpbGRyZW4pIHx8IFtdO1xuXHRcdHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIHx8IDA7XG5cblx0XHRyZXR1cm4gIWxlbmd0aCA/IG51bGwgOiBmdW5jdGlvbihwb2ludCwgaSkge1xuXHRcdFx0cmV0dXJuIChpIDwgbGVuZ3RoICYmIHBvaW50c1tpXS5fdmlldykgfHwgbnVsbDtcblx0XHR9O1xuXHR9LFxuXG5cdGJvdW5kYXJ5OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR2YXIgYm91bmRhcnkgPSBzb3VyY2UuYm91bmRhcnk7XG5cdFx0dmFyIHggPSBib3VuZGFyeSA/IGJvdW5kYXJ5LnggOiBudWxsO1xuXHRcdHZhciB5ID0gYm91bmRhcnkgPyBib3VuZGFyeS55IDogbnVsbDtcblxuXHRcdHJldHVybiBmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogeCA9PT0gbnVsbCA/IHBvaW50LnggOiB4LFxuXHRcdFx0XHR5OiB5ID09PSBudWxsID8gcG9pbnQueSA6IHksXG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cbn07XG5cbi8vIEB0b2RvIGlmIChmaWxsWzBdID09PSAnIycpXG5mdW5jdGlvbiBkZWNvZGVGaWxsKGVsLCBpbmRleCwgY291bnQpIHtcblx0dmFyIG1vZGVsID0gZWwuX21vZGVsIHx8IHt9O1xuXHR2YXIgZmlsbCA9IG1vZGVsLmZpbGw7XG5cdHZhciB0YXJnZXQ7XG5cblx0aWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuXHRcdGZpbGwgPSAhIW1vZGVsLmJhY2tncm91bmRDb2xvcjtcblx0fVxuXG5cdGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKGZpbGwgPT09IHRydWUpIHtcblx0XHRyZXR1cm4gJ29yaWdpbic7XG5cdH1cblxuXHR0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwsIDEwKTtcblx0aWYgKGlzRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcblx0XHRpZiAoZmlsbFswXSA9PT0gJy0nIHx8IGZpbGxbMF0gPT09ICcrJykge1xuXHRcdFx0dGFyZ2V0ID0gaW5kZXggKyB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0aWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblx0c3dpdGNoIChmaWxsKSB7XG5cdC8vIGNvbXBhdGliaWxpdHlcblx0Y2FzZSAnYm90dG9tJzpcblx0XHRyZXR1cm4gJ3N0YXJ0Jztcblx0Y2FzZSAndG9wJzpcblx0XHRyZXR1cm4gJ2VuZCc7XG5cdGNhc2UgJ3plcm8nOlxuXHRcdHJldHVybiAnb3JpZ2luJztcblx0Ly8gc3VwcG9ydGVkIGJvdW5kYXJpZXNcblx0Y2FzZSAnb3JpZ2luJzpcblx0Y2FzZSAnc3RhcnQnOlxuXHRjYXNlICdlbmQnOlxuXHRcdHJldHVybiBmaWxsO1xuXHQvLyBpbnZhbGlkIGZpbGwgdmFsdWVzXG5cdGRlZmF1bHQ6XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcblx0dmFyIG1vZGVsID0gc291cmNlLmVsLl9tb2RlbCB8fCB7fTtcblx0dmFyIHNjYWxlID0gc291cmNlLmVsLl9zY2FsZSB8fCB7fTtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHRhcmdldCA9IG51bGw7XG5cdHZhciBob3Jpem9udGFsO1xuXG5cdGlmIChpc0Zpbml0ZShmaWxsKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogdW50aWwgdjMsIHdlIHN0aWxsIG5lZWQgdG8gc3VwcG9ydCBib3VuZGFyeSB2YWx1ZXMgc2V0IG9uXG5cdC8vIHRoZSBtb2RlbCAoc2NhbGVUb3AsIHNjYWxlQm90dG9tIGFuZCBzY2FsZVplcm8pIGJlY2F1c2Ugc29tZSBleHRlcm5hbCBwbHVnaW5zIGFuZFxuXHQvLyBjb250cm9sbGVycyBtaWdodCBzdGlsbCB1c2UgaXQgKGUuZy4gdGhlIFNtaXRoIGNoYXJ0KS5cblxuXHRpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuXHRcdHRhcmdldCA9IG1vZGVsLnNjYWxlQm90dG9tID09PSB1bmRlZmluZWQgPyBzY2FsZS5ib3R0b20gOiBtb2RlbC5zY2FsZUJvdHRvbTtcblx0fSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuXHRcdHRhcmdldCA9IG1vZGVsLnNjYWxlVG9wID09PSB1bmRlZmluZWQgPyBzY2FsZS50b3AgOiBtb2RlbC5zY2FsZVRvcDtcblx0fSBlbHNlIGlmIChtb2RlbC5zY2FsZVplcm8gIT09IHVuZGVmaW5lZCkge1xuXHRcdHRhcmdldCA9IG1vZGVsLnNjYWxlWmVybztcblx0fSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUG9zaXRpb24pIHtcblx0XHR0YXJnZXQgPSBzY2FsZS5nZXRCYXNlUG9zaXRpb24oKTtcblx0fSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcblx0XHR0YXJnZXQgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcblx0fVxuXG5cdGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IG51bGwpIHtcblx0XHRpZiAodGFyZ2V0LnggIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQueSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGlmIChoZWxwZXJzJDEuaXNGaW5pdGUodGFyZ2V0KSkge1xuXHRcdFx0aG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogaG9yaXpvbnRhbCA/IHRhcmdldCA6IG51bGwsXG5cdFx0XHRcdHk6IGhvcml6b250YWwgPyBudWxsIDogdGFyZ2V0XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGluZGV4LCBwcm9wYWdhdGUpIHtcblx0dmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuXHR2YXIgZmlsbCA9IHNvdXJjZS5maWxsO1xuXHR2YXIgdmlzaXRlZCA9IFtpbmRleF07XG5cdHZhciB0YXJnZXQ7XG5cblx0aWYgKCFwcm9wYWdhdGUpIHtcblx0XHRyZXR1cm4gZmlsbDtcblx0fVxuXG5cdHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG5cdFx0aWYgKCFpc0Zpbml0ZShmaWxsKSkge1xuXHRcdFx0cmV0dXJuIGZpbGw7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcblx0XHRpZiAoIXRhcmdldCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICh0YXJnZXQudmlzaWJsZSkge1xuXHRcdFx0cmV0dXJuIGZpbGw7XG5cdFx0fVxuXG5cdFx0dmlzaXRlZC5wdXNoKGZpbGwpO1xuXHRcdGZpbGwgPSB0YXJnZXQuZmlsbDtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWFwcGVyKHNvdXJjZSkge1xuXHR2YXIgZmlsbCA9IHNvdXJjZS5maWxsO1xuXHR2YXIgdHlwZSA9ICdkYXRhc2V0JztcblxuXHRpZiAoZmlsbCA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmICghaXNGaW5pdGUoZmlsbCkpIHtcblx0XHR0eXBlID0gJ2JvdW5kYXJ5Jztcblx0fVxuXG5cdHJldHVybiBtYXBwZXJzW3R5cGVdKHNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIGlzRHJhd2FibGUocG9pbnQpIHtcblx0cmV0dXJuIHBvaW50ICYmICFwb2ludC5za2lwO1xufVxuXG5mdW5jdGlvbiBkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKSB7XG5cdHZhciBpO1xuXG5cdGlmICghbGVuMCB8fCAhbGVuMSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGJ1aWxkaW5nIGZpcnN0IGFyZWEgY3VydmUgKG5vcm1hbClcblx0Y3R4Lm1vdmVUbyhjdXJ2ZTBbMF0ueCwgY3VydmUwWzBdLnkpO1xuXHRmb3IgKGkgPSAxOyBpIDwgbGVuMDsgKytpKSB7XG5cdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBjdXJ2ZTBbaSAtIDFdLCBjdXJ2ZTBbaV0pO1xuXHR9XG5cblx0Ly8gam9pbmluZyB0aGUgdHdvIGFyZWEgY3VydmVzXG5cdGN0eC5saW5lVG8oY3VydmUxW2xlbjEgLSAxXS54LCBjdXJ2ZTFbbGVuMSAtIDFdLnkpO1xuXG5cdC8vIGJ1aWxkaW5nIG9wcG9zaXRlIGFyZWEgY3VydmUgKHJldmVyc2UpXG5cdGZvciAoaSA9IGxlbjEgLSAxOyBpID4gMDsgLS1pKSB7XG5cdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBjdXJ2ZTFbaV0sIGN1cnZlMVtpIC0gMV0sIHRydWUpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvRmlsbChjdHgsIHBvaW50cywgbWFwcGVyLCB2aWV3LCBjb2xvciwgbG9vcCkge1xuXHR2YXIgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuXHR2YXIgc3BhbiA9IHZpZXcuc3BhbkdhcHM7XG5cdHZhciBjdXJ2ZTAgPSBbXTtcblx0dmFyIGN1cnZlMSA9IFtdO1xuXHR2YXIgbGVuMCA9IDA7XG5cdHZhciBsZW4xID0gMDtcblx0dmFyIGksIGlsZW4sIGluZGV4LCBwMCwgcDEsIGQwLCBkMTtcblxuXHRjdHguYmVnaW5QYXRoKCk7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IChjb3VudCArICEhbG9vcCk7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpbmRleCA9IGkgJSBjb3VudDtcblx0XHRwMCA9IHBvaW50c1tpbmRleF0uX3ZpZXc7XG5cdFx0cDEgPSBtYXBwZXIocDAsIGluZGV4LCB2aWV3KTtcblx0XHRkMCA9IGlzRHJhd2FibGUocDApO1xuXHRcdGQxID0gaXNEcmF3YWJsZShwMSk7XG5cblx0XHRpZiAoZDAgJiYgZDEpIHtcblx0XHRcdGxlbjAgPSBjdXJ2ZTAucHVzaChwMCk7XG5cdFx0XHRsZW4xID0gY3VydmUxLnB1c2gocDEpO1xuXHRcdH0gZWxzZSBpZiAobGVuMCAmJiBsZW4xKSB7XG5cdFx0XHRpZiAoIXNwYW4pIHtcblx0XHRcdFx0ZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSk7XG5cdFx0XHRcdGxlbjAgPSBsZW4xID0gMDtcblx0XHRcdFx0Y3VydmUwID0gW107XG5cdFx0XHRcdGN1cnZlMSA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGQwKSB7XG5cdFx0XHRcdFx0Y3VydmUwLnB1c2gocDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkMSkge1xuXHRcdFx0XHRcdGN1cnZlMS5wdXNoKHAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xuXG5cdGN0eC5jbG9zZVBhdGgoKTtcblx0Y3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHRjdHguZmlsbCgpO1xufVxuXG52YXIgcGx1Z2luX2ZpbGxlciA9IHtcblx0aWQ6ICdmaWxsZXInLFxuXG5cdGFmdGVyRGF0YXNldHNVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0dmFyIGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcblx0XHR2YXIgcHJvcGFnYXRlID0gb3B0aW9ucy5wcm9wYWdhdGU7XG5cdFx0dmFyIHNvdXJjZXMgPSBbXTtcblx0XHR2YXIgbWV0YSwgaSwgZWwsIHNvdXJjZTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRlbCA9IG1ldGEuZGF0YXNldDtcblx0XHRcdHNvdXJjZSA9IG51bGw7XG5cblx0XHRcdGlmIChlbCAmJiBlbC5fbW9kZWwgJiYgZWwgaW5zdGFuY2VvZiBlbGVtZW50cy5MaW5lKSB7XG5cdFx0XHRcdHNvdXJjZSA9IHtcblx0XHRcdFx0XHR2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuXHRcdFx0XHRcdGZpbGw6IGRlY29kZUZpbGwoZWwsIGksIGNvdW50KSxcblx0XHRcdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRcdFx0ZWw6IGVsXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcblx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHRzb3VyY2UgPSBzb3VyY2VzW2ldO1xuXHRcdFx0aWYgKCFzb3VyY2UpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNvdXJjZS5maWxsID0gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBwcm9wYWdhdGUpO1xuXHRcdFx0c291cmNlLmJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG5cdFx0XHRzb3VyY2UubWFwcGVyID0gY3JlYXRlTWFwcGVyKHNvdXJjZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGJlZm9yZURhdGFzZXREcmF3OiBmdW5jdGlvbihjaGFydCwgYXJncykge1xuXHRcdHZhciBtZXRhID0gYXJncy5tZXRhLiRmaWxsZXI7XG5cdFx0aWYgKCFtZXRhKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGN0eCA9IGNoYXJ0LmN0eDtcblx0XHR2YXIgZWwgPSBtZXRhLmVsO1xuXHRcdHZhciB2aWV3ID0gZWwuX3ZpZXc7XG5cdFx0dmFyIHBvaW50cyA9IGVsLl9jaGlsZHJlbiB8fCBbXTtcblx0XHR2YXIgbWFwcGVyID0gbWV0YS5tYXBwZXI7XG5cdFx0dmFyIGNvbG9yID0gdmlldy5iYWNrZ3JvdW5kQ29sb3IgfHwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5cdFx0aWYgKG1hcHBlciAmJiBjb2xvciAmJiBwb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGN0eCwgY2hhcnQuY2hhcnRBcmVhKTtcblx0XHRcdGRvRmlsbChjdHgsIHBvaW50cywgbWFwcGVyLCB2aWV3LCBjb2xvciwgZWwuX2xvb3ApO1xuXHRcdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGN0eCk7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgbm9vcCQxID0gaGVscGVycyQxLm5vb3A7XG52YXIgdmFsdWVPckRlZmF1bHQkZCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGxlZ2VuZDoge1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0cG9zaXRpb246ICd0b3AnLFxuXHRcdGZ1bGxXaWR0aDogdHJ1ZSxcblx0XHRyZXZlcnNlOiBmYWxzZSxcblx0XHR3ZWlnaHQ6IDEwMDAsXG5cblx0XHQvLyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBoYW5kbGVcblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcblx0XHRcdHZhciBjaSA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgbWV0YSA9IGNpLmdldERhdGFzZXRNZXRhKGluZGV4KTtcblxuXHRcdFx0Ly8gU2VlIGNvbnRyb2xsZXIuaXNEYXRhc2V0VmlzaWJsZSBjb21tZW50XG5cdFx0XHRtZXRhLmhpZGRlbiA9IG1ldGEuaGlkZGVuID09PSBudWxsID8gIWNpLmRhdGEuZGF0YXNldHNbaW5kZXhdLmhpZGRlbiA6IG51bGw7XG5cblx0XHRcdC8vIFdlIGhpZCBhIGRhdGFzZXQgLi4uIHJlcmVuZGVyIHRoZSBjaGFydFxuXHRcdFx0Y2kudXBkYXRlKCk7XG5cdFx0fSxcblxuXHRcdG9uSG92ZXI6IG51bGwsXG5cdFx0b25MZWF2ZTogbnVsbCxcblxuXHRcdGxhYmVsczoge1xuXHRcdFx0Ym94V2lkdGg6IDQwLFxuXHRcdFx0cGFkZGluZzogMTAsXG5cdFx0XHQvLyBHZW5lcmF0ZXMgbGFiZWxzIHNob3duIGluIHRoZSBsZWdlbmRcblx0XHRcdC8vIFZhbGlkIHByb3BlcnRpZXMgdG8gcmV0dXJuOlxuXHRcdFx0Ly8gdGV4dCA6IHRleHQgdG8gZGlzcGxheVxuXHRcdFx0Ly8gZmlsbFN0eWxlIDogZmlsbCBvZiBjb2xvdXJlZCBib3hcblx0XHRcdC8vIHN0cm9rZVN0eWxlOiBzdHJva2Ugb2YgY29sb3VyZWQgYm94XG5cdFx0XHQvLyBoaWRkZW4gOiBpZiB0aGlzIGxlZ2VuZCBpdGVtIHJlZmVycyB0byBhIGhpZGRlbiBpdGVtXG5cdFx0XHQvLyBsaW5lQ2FwIDogY2FwIHN0eWxlIGZvciBsaW5lXG5cdFx0XHQvLyBsaW5lRGFzaFxuXHRcdFx0Ly8gbGluZURhc2hPZmZzZXQgOlxuXHRcdFx0Ly8gbGluZUpvaW4gOlxuXHRcdFx0Ly8gbGluZVdpZHRoIDpcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHRcdHJldHVybiBoZWxwZXJzJDEuaXNBcnJheShkYXRhLmRhdGFzZXRzKSA/IGRhdGEuZGF0YXNldHMubWFwKGZ1bmN0aW9uKGRhdGFzZXQsIGkpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dGV4dDogZGF0YXNldC5sYWJlbCxcblx0XHRcdFx0XHRcdGZpbGxTdHlsZTogKCFoZWxwZXJzJDEuaXNBcnJheShkYXRhc2V0LmJhY2tncm91bmRDb2xvcikgPyBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA6IGRhdGFzZXQuYmFja2dyb3VuZENvbG9yWzBdKSxcblx0XHRcdFx0XHRcdGhpZGRlbjogIWNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG5cdFx0XHRcdFx0XHRsaW5lQ2FwOiBkYXRhc2V0LmJvcmRlckNhcFN0eWxlLFxuXHRcdFx0XHRcdFx0bGluZURhc2g6IGRhdGFzZXQuYm9yZGVyRGFzaCxcblx0XHRcdFx0XHRcdGxpbmVEYXNoT2Zmc2V0OiBkYXRhc2V0LmJvcmRlckRhc2hPZmZzZXQsXG5cdFx0XHRcdFx0XHRsaW5lSm9pbjogZGF0YXNldC5ib3JkZXJKb2luU3R5bGUsXG5cdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGRhdGFzZXQuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogZGF0YXNldC5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRcdHBvaW50U3R5bGU6IGRhdGFzZXQucG9pbnRTdHlsZSxcblxuXHRcdFx0XHRcdFx0Ly8gQmVsb3cgaXMgZXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgZGF0YXNldHNcblx0XHRcdFx0XHRcdGRhdGFzZXRJbmRleDogaVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sIHRoaXMpIDogW107XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0ZXh0ID0gW107XG5cdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGV4dC5wdXNoKCc8bGk+PHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmJhY2tncm91bmRDb2xvciArICdcIj48L3NwYW4+Jyk7XG5cdFx0XHRpZiAoY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5sYWJlbCkge1xuXHRcdFx0XHR0ZXh0LnB1c2goY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5sYWJlbCk7XG5cdFx0XHR9XG5cdFx0XHR0ZXh0LnB1c2goJzwvbGk+Jyk7XG5cdFx0fVxuXHRcdHRleHQucHVzaCgnPC91bD4nKTtcblx0XHRyZXR1cm4gdGV4dC5qb2luKCcnKTtcblx0fVxufSk7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm94IHdpZHRoIGJhc2VkIG9uIHRoZSB1c2VQb2ludFN0eWxlIG9wdGlvblxuICogQHBhcmFtIHtvYmplY3R9IGxhYmVsb3B0cyAtIHRoZSBsYWJlbCBvcHRpb25zIG9uIHRoZSBsZWdlbmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb250U2l6ZSAtIHRoZSBsYWJlbCBmb250IHNpemVcbiAqIEByZXR1cm4ge251bWJlcn0gd2lkdGggb2YgdGhlIGNvbG9yIGJveCBhcmVhXG4gKi9cbmZ1bmN0aW9uIGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpIHtcblx0cmV0dXJuIGxhYmVsT3B0cy51c2VQb2ludFN0eWxlICYmIGxhYmVsT3B0cy5ib3hXaWR0aCA+IGZvbnRTaXplID9cblx0XHRmb250U2l6ZSA6XG5cdFx0bGFiZWxPcHRzLmJveFdpZHRoO1xufVxuXG4vKipcbiAqIElNUE9SVEFOVDogdGhpcyBjbGFzcyBpcyBleHBvc2VkIHB1YmxpY2x5IGFzIENoYXJ0LkxlZ2VuZCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eSByZXF1aXJlZCFcbiAqL1xudmFyIExlZ2VuZCA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdGhlbHBlcnMkMS5leHRlbmQodGhpcywgY29uZmlnKTtcblxuXHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuXHRcdHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuXHRcdC8qKlxuIFx0XHQgKiBAcHJpdmF0ZVxuIFx0XHQgKi9cblx0XHR0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG5cblx0XHQvLyBBcmUgd2UgaW4gZG91Z2hudXQgbW9kZSB3aGljaCBoYXMgYSBkaWZmZXJlbnQgZGF0YSB0eXBlXG5cdFx0dGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcblx0fSxcblxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuXHQvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgbGVnZW5kIHR5cGVzLlxuXHQvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBsZWdlbmQgdHlwZVxuXG5cdGJlZm9yZVVwZGF0ZTogbm9vcCQxLFxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcblxuXHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0bWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXHRcdG1lLm1hcmdpbnMgPSBtYXJnaW5zO1xuXG5cdFx0Ly8gRGltZW5zaW9uc1xuXHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cdFx0Ly8gTGFiZWxzXG5cdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcblx0XHRtZS5idWlsZExhYmVscygpO1xuXHRcdG1lLmFmdGVyQnVpbGRMYWJlbHMoKTtcblxuXHRcdC8vIEZpdFxuXHRcdG1lLmJlZm9yZUZpdCgpO1xuXHRcdG1lLmZpdCgpO1xuXHRcdG1lLmFmdGVyRml0KCk7XG5cdFx0Ly9cblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xuXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBub29wJDEsXG5cblx0Ly9cblxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBub29wJDEsXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXG5cdFx0Ly8gUmVzZXQgbWluU2l6ZVxuXHRcdG1lLm1pblNpemUgPSB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMFxuXHRcdH07XG5cdH0sXG5cdGFmdGVyU2V0RGltZW5zaW9uczogbm9vcCQxLFxuXG5cdC8vXG5cblx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AkMSxcblx0YnVpbGRMYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGxhYmVsT3B0cyA9IG1lLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuXHRcdHZhciBsZWdlbmRJdGVtcyA9IGhlbHBlcnMkMS5jYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFttZS5jaGFydF0sIG1lKSB8fCBbXTtcblxuXHRcdGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG5cdFx0XHRsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIG1lLmNoYXJ0LmRhdGEpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1lLm9wdGlvbnMucmV2ZXJzZSkge1xuXHRcdFx0bGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuXHRcdH1cblxuXHRcdG1lLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG5cdH0sXG5cdGFmdGVyQnVpbGRMYWJlbHM6IG5vb3AkMSxcblxuXHQvL1xuXG5cdGJlZm9yZUZpdDogbm9vcCQxLFxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBsYWJlbE9wdHMgPSBvcHRzLmxhYmVscztcblx0XHR2YXIgZGlzcGxheSA9IG9wdHMuZGlzcGxheTtcblxuXHRcdHZhciBjdHggPSBtZS5jdHg7XG5cblx0XHR2YXIgbGFiZWxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChsYWJlbE9wdHMpO1xuXHRcdHZhciBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuXG5cdFx0Ly8gUmVzZXQgaGl0IGJveGVzXG5cdFx0dmFyIGhpdGJveGVzID0gbWUubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZTtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gbWUubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBkaXNwbGF5ID8gMTAgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gZGlzcGxheSA/IDEwIDogMDtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0fVxuXG5cdFx0Ly8gSW5jcmVhc2Ugc2l6ZXMgaGVyZVxuXHRcdGlmIChkaXNwbGF5KSB7XG5cdFx0XHRjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0Ly8gTGFiZWxzXG5cblx0XHRcdFx0Ly8gV2lkdGggb2YgZWFjaCBsaW5lIG9mIGxlZ2VuZCBib3hlcy4gTGFiZWxzIHdyYXAgb250byBtdWx0aXBsZSBsaW5lcyB3aGVuIHRoZXJlIGFyZSB0b28gbWFueSB0byBmaXQgb24gb25lXG5cdFx0XHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocyA9IFswXTtcblx0XHRcdFx0dmFyIHRvdGFsSGVpZ2h0ID0gMDtcblxuXHRcdFx0XHRjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuXHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cblx0XHRcdFx0aGVscGVycyQxLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcblx0XHRcdFx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcblx0XHRcdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cblx0XHRcdFx0XHRpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nID4gbWluU2l6ZS53aWR0aCkge1xuXHRcdFx0XHRcdFx0dG90YWxIZWlnaHQgKz0gZm9udFNpemUgKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHRcdGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2Bcblx0XHRcdFx0XHRoaXRib3hlc1tpXSA9IHtcblx0XHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGZvbnRTaXplXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRtaW5TaXplLmhlaWdodCArPSB0b3RhbEhlaWdodDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHZQYWRkaW5nID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdHZhciBjb2x1bW5XaWR0aHMgPSBtZS5jb2x1bW5XaWR0aHMgPSBbXTtcblx0XHRcdFx0dmFyIHRvdGFsV2lkdGggPSBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0dmFyIGN1cnJlbnRDb2xXaWR0aCA9IDA7XG5cdFx0XHRcdHZhciBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcblx0XHRcdFx0dmFyIGl0ZW1IZWlnaHQgPSBmb250U2l6ZSArIHZQYWRkaW5nO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLmxlZ2VuZEl0ZW1zLCBmdW5jdGlvbihsZWdlbmRJdGVtLCBpKSB7XG5cdFx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0dmFyIGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblxuXHRcdFx0XHRcdC8vIElmIHRvbyB0YWxsLCBnbyB0byBuZXcgY29sdW1uXG5cdFx0XHRcdFx0aWYgKGkgPiAwICYmIGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ID4gbWluU2l6ZS5oZWlnaHQgLSB2UGFkZGluZykge1xuXHRcdFx0XHRcdFx0dG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHRcdGNvbHVtbldpZHRocy5wdXNoKGN1cnJlbnRDb2xXaWR0aCk7IC8vIHByZXZpb3VzIGNvbHVtbiB3aWR0aFxuXG5cdFx0XHRcdFx0XHRjdXJyZW50Q29sV2lkdGggPSAwO1xuXHRcdFx0XHRcdFx0Y3VycmVudENvbEhlaWdodCA9IDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gR2V0IG1heCB3aWR0aFxuXHRcdFx0XHRcdGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcblx0XHRcdFx0XHRjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQ7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxuXHRcdFx0XHRcdGhpdGJveGVzW2ldID0ge1xuXHRcdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRcdHdpZHRoOiBpdGVtV2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGZvbnRTaXplXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGg7XG5cdFx0XHRcdGNvbHVtbldpZHRocy5wdXNoKGN1cnJlbnRDb2xXaWR0aCk7XG5cdFx0XHRcdG1pblNpemUud2lkdGggKz0gdG90YWxXaWR0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGg7XG5cdFx0bWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG5cdH0sXG5cdGFmdGVyRml0OiBub29wJDEsXG5cblx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuXHR9LFxuXG5cdC8vIEFjdHVhbGx5IGRyYXcgdGhlIGxlZ2VuZCBvbiB0aGUgY2FudmFzXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBsYWJlbE9wdHMgPSBvcHRzLmxhYmVscztcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgZGVmYXVsdENvbG9yID0gZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yO1xuXHRcdHZhciBsaW5lRGVmYXVsdCA9IGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLmxpbmU7XG5cdFx0dmFyIGxlZ2VuZFdpZHRoID0gbWUud2lkdGg7XG5cdFx0dmFyIGxpbmVXaWR0aHMgPSBtZS5saW5lV2lkdGhzO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSkge1xuXHRcdFx0dmFyIGN0eCA9IG1lLmN0eDtcblx0XHRcdHZhciBmb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRkKGxhYmVsT3B0cy5mb250Q29sb3IsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0dmFyIGxhYmVsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobGFiZWxPcHRzKTtcblx0XHRcdHZhciBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuXHRcdFx0dmFyIGN1cnNvcjtcblxuXHRcdFx0Ly8gQ2FudmFzIHNldHVwXG5cdFx0XHRjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDAuNTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGZvbnRDb2xvcjsgLy8gZm9yIHN0cmlrZXRocm91Z2ggZWZmZWN0XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gZm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblx0XHRcdGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuXHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHR2YXIgaGl0Ym94ZXMgPSBtZS5sZWdlbmRIaXRCb3hlcztcblxuXHRcdFx0Ly8gY3VycmVudCBwb3NpdGlvblxuXHRcdFx0dmFyIGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG5cdFx0XHRcdGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCB0aGUgY3R4IGZvciB0aGUgYm94XG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cblx0XHRcdFx0dmFyIGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lV2lkdGgsIGxpbmVEZWZhdWx0LmJvcmRlcldpZHRoKTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG5cdFx0XHRcdGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmxpbmVDYXAsIGxpbmVEZWZhdWx0LmJvcmRlckNhcFN0eWxlKTtcblx0XHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCBsaW5lRGVmYXVsdC5ib3JkZXJEYXNoT2Zmc2V0KTtcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmxpbmVKb2luLCBsaW5lRGVmYXVsdC5ib3JkZXJKb2luU3R5bGUpO1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG5cblx0XHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRcdC8vIElFIDkgYW5kIDEwIGRvIG5vdCBzdXBwb3J0IGxpbmUgZGFzaFxuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0ubGluZURhc2gsIGxpbmVEZWZhdWx0LmJvcmRlckRhc2gpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcHRzLmxhYmVscyAmJiBvcHRzLmxhYmVscy51c2VQb2ludFN0eWxlKSB7XG5cdFx0XHRcdFx0Ly8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG5cdFx0XHRcdFx0Ly8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuXHRcdFx0XHRcdHZhciByYWRpdXMgPSBib3hXaWR0aCAqIE1hdGguU1FSVDIgLyAyO1xuXHRcdFx0XHRcdHZhciBjZW50ZXJYID0geCArIGJveFdpZHRoIC8gMjtcblx0XHRcdFx0XHR2YXIgY2VudGVyWSA9IHkgKyBmb250U2l6ZSAvIDI7XG5cblx0XHRcdFx0XHQvLyBEcmF3IHBvaW50U3R5bGUgYXMgbGVnZW5kIHN5bWJvbFxuXHRcdFx0XHRcdGhlbHBlcnMkMS5jYW52YXMuZHJhd1BvaW50KGN0eCwgbGVnZW5kSXRlbS5wb2ludFN0eWxlLCByYWRpdXMsIGNlbnRlclgsIGNlbnRlclkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIERyYXcgYm94IGFzIGxlZ2VuZCBzeW1ib2xcblx0XHRcdFx0XHRpZiAobGluZVdpZHRoICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlUmVjdCh4LCB5LCBib3hXaWR0aCwgZm9udFNpemUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoeCwgeSwgYm94V2lkdGgsIGZvbnRTaXplKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSwgdGV4dFdpZHRoKSB7XG5cdFx0XHRcdHZhciBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG5cdFx0XHRcdHZhciB4TGVmdCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgeDtcblx0XHRcdFx0dmFyIHlNaWRkbGUgPSB5ICsgaGFsZkZvbnRTaXplO1xuXG5cdFx0XHRcdGN0eC5maWxsVGV4dChsZWdlbmRJdGVtLnRleHQsIHhMZWZ0LCB5TWlkZGxlKTtcblxuXHRcdFx0XHRpZiAobGVnZW5kSXRlbS5oaWRkZW4pIHtcblx0XHRcdFx0XHQvLyBTdHJpa2V0aHJvdWdoIHRoZSB0ZXh0IGlmIGhpZGRlblxuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gMjtcblx0XHRcdFx0XHRjdHgubW92ZVRvKHhMZWZ0LCB5TWlkZGxlKTtcblx0XHRcdFx0XHRjdHgubGluZVRvKHhMZWZ0ICsgdGV4dFdpZHRoLCB5TWlkZGxlKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIEhvcml6b250YWxcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0Y3Vyc29yID0ge1xuXHRcdFx0XHRcdHg6IG1lLmxlZnQgKyAoKGxlZ2VuZFdpZHRoIC0gbGluZVdpZHRoc1swXSkgLyAyKSArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdHk6IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdGxpbmU6IDBcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnNvciA9IHtcblx0XHRcdFx0XHR4OiBtZS5sZWZ0ICsgbGFiZWxPcHRzLnBhZGRpbmcsXG5cdFx0XHRcdFx0eTogbWUudG9wICsgbGFiZWxPcHRzLnBhZGRpbmcsXG5cdFx0XHRcdFx0bGluZTogMFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaXRlbUhlaWdodCA9IGZvbnRTaXplICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHR2YXIgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cdFx0XHRcdHZhciB3aWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyB0ZXh0V2lkdGg7XG5cdFx0XHRcdHZhciB4ID0gY3Vyc29yLng7XG5cdFx0XHRcdHZhciB5ID0gY3Vyc29yLnk7XG5cblx0XHRcdFx0Ly8gVXNlIChtZS5sZWZ0ICsgbWUubWluU2l6ZS53aWR0aCkgYW5kIChtZS50b3AgKyBtZS5taW5TaXplLmhlaWdodClcblx0XHRcdFx0Ly8gaW5zdGVhZCBvZiBtZS5yaWdodCBhbmQgbWUuYm90dG9tIGJlY2F1c2UgbWUud2lkdGggYW5kIG1lLmhlaWdodFxuXHRcdFx0XHQvLyBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQgc2luY2UgbWUubWluU2l6ZSB3YXMgY2FsY3VsYXRlZFxuXHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0aWYgKGkgPiAwICYmIHggKyB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nID4gbWUubGVmdCArIG1lLm1pblNpemUud2lkdGgpIHtcblx0XHRcdFx0XHRcdHkgPSBjdXJzb3IueSArPSBpdGVtSGVpZ2h0O1xuXHRcdFx0XHRcdFx0Y3Vyc29yLmxpbmUrKztcblx0XHRcdFx0XHRcdHggPSBjdXJzb3IueCA9IG1lLmxlZnQgKyAoKGxlZ2VuZFdpZHRoIC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pIC8gMikgKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoaSA+IDAgJiYgeSArIGl0ZW1IZWlnaHQgPiBtZS50b3AgKyBtZS5taW5TaXplLmhlaWdodCkge1xuXHRcdFx0XHRcdHggPSBjdXJzb3IueCA9IHggKyBtZS5jb2x1bW5XaWR0aHNbY3Vyc29yLmxpbmVdICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0eSA9IGN1cnNvci55ID0gbWUudG9wICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0Y3Vyc29yLmxpbmUrKztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRyYXdMZWdlbmRCb3goeCwgeSwgbGVnZW5kSXRlbSk7XG5cblx0XHRcdFx0aGl0Ym94ZXNbaV0ubGVmdCA9IHg7XG5cdFx0XHRcdGhpdGJveGVzW2ldLnRvcCA9IHk7XG5cblx0XHRcdFx0Ly8gRmlsbCB0aGUgYWN0dWFsIGxhYmVsXG5cdFx0XHRcdGZpbGxUZXh0KHgsIHksIGxlZ2VuZEl0ZW0sIHRleHRXaWR0aCk7XG5cblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdGN1cnNvci54ICs9IHdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3Vyc29yLnkgKz0gaXRlbUhlaWdodDtcblx0XHRcdFx0fVxuXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0TGVnZW5kSXRlbUF0OiBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaSwgaGl0Qm94LCBsaDtcblxuXHRcdGlmICh4ID49IG1lLmxlZnQgJiYgeCA8PSBtZS5yaWdodCAmJiB5ID49IG1lLnRvcCAmJiB5IDw9IG1lLmJvdHRvbSkge1xuXHRcdFx0Ly8gU2VlIGlmIHdlIGFyZSB0b3VjaGluZyBvbmUgb2YgdGhlIGRhdGFzZXQgYm94ZXNcblx0XHRcdGxoID0gbWUubGVnZW5kSGl0Qm94ZXM7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0aGl0Qm94ID0gbGhbaV07XG5cblx0XHRcdFx0aWYgKHggPj0gaGl0Qm94LmxlZnQgJiYgeCA8PSBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aCAmJiB5ID49IGhpdEJveC50b3AgJiYgeSA8PSBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkge1xuXHRcdFx0XHRcdC8vIFRvdWNoaW5nIGFuIGVsZW1lbnRcblx0XHRcdFx0XHRyZXR1cm4gbWUubGVnZW5kSXRlbXNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICovXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHR5cGUgPSBlLnR5cGUgPT09ICdtb3VzZXVwJyA/ICdjbGljaycgOiBlLnR5cGU7XG5cdFx0dmFyIGhvdmVyZWRJdGVtO1xuXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG5cdFx0XHRpZiAoIW9wdHMub25Ib3ZlciAmJiAhb3B0cy5vbkxlYXZlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdGlmICghb3B0cy5vbkNsaWNrKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENoYXJ0IGV2ZW50IGFscmVhZHkgaGFzIHJlbGF0aXZlIHBvc2l0aW9uIGluIGl0XG5cdFx0aG92ZXJlZEl0ZW0gPSBtZS5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcblxuXHRcdGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAoaG92ZXJlZEl0ZW0gJiYgb3B0cy5vbkNsaWNrKSB7XG5cdFx0XHRcdC8vIHVzZSBlLm5hdGl2ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0b3B0cy5vbkNsaWNrLmNhbGwobWUsIGUubmF0aXZlLCBob3ZlcmVkSXRlbSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChvcHRzLm9uTGVhdmUgJiYgaG92ZXJlZEl0ZW0gIT09IG1lLl9ob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHRpZiAobWUuX2hvdmVyZWRJdGVtKSB7XG5cdFx0XHRcdFx0b3B0cy5vbkxlYXZlLmNhbGwobWUsIGUubmF0aXZlLCBtZS5faG92ZXJlZEl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1lLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0cy5vbkhvdmVyICYmIGhvdmVyZWRJdGVtKSB7XG5cdFx0XHRcdC8vIHVzZSBlLm5hdGl2ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0b3B0cy5vbkhvdmVyLmNhbGwobWUsIGUubmF0aXZlLCBob3ZlcmVkSXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoKGNoYXJ0LCBsZWdlbmRPcHRzKSB7XG5cdHZhciBsZWdlbmQgPSBuZXcgTGVnZW5kKHtcblx0XHRjdHg6IGNoYXJ0LmN0eCxcblx0XHRvcHRpb25zOiBsZWdlbmRPcHRzLFxuXHRcdGNoYXJ0OiBjaGFydFxuXHR9KTtcblxuXHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIGxlZ2VuZE9wdHMpO1xuXHRjb3JlX2xheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuXHRjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG59XG5cbnZhciBwbHVnaW5fbGVnZW5kID0ge1xuXHRpZDogJ2xlZ2VuZCcsXG5cblx0LyoqXG5cdCAqIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHNpbmNlIDIuMS41LCB0aGUgbGVnZW5kIGlzIHJlZ2lzdGVyZWQgYXMgYSBwbHVnaW4sIG1ha2luZ1xuXHQgKiBDaGFydC5MZWdlbmQgb2Jzb2xldGUuIFRvIGF2b2lkIGEgYnJlYWtpbmcgY2hhbmdlLCB3ZSBleHBvcnQgdGhlIExlZ2VuZCBhcyBwYXJ0IG9mXG5cdCAqIHRoZSBwbHVnaW4sIHdoaWNoIG9uZSB3aWxsIGJlIHJlLWV4cG9zZWQgaW4gdGhlIGNoYXJ0LmpzIGZpbGUuXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvMjY0MFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2VsZW1lbnQ6IExlZ2VuZCxcblxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciBsZWdlbmRPcHRzID0gY2hhcnQub3B0aW9ucy5sZWdlbmQ7XG5cblx0XHRpZiAobGVnZW5kT3B0cykge1xuXHRcdFx0Y3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoKGNoYXJ0LCBsZWdlbmRPcHRzKTtcblx0XHR9XG5cdH0sXG5cblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciBsZWdlbmRPcHRzID0gY2hhcnQub3B0aW9ucy5sZWdlbmQ7XG5cdFx0dmFyIGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcblxuXHRcdGlmIChsZWdlbmRPcHRzKSB7XG5cdFx0XHRoZWxwZXJzJDEubWVyZ2VJZihsZWdlbmRPcHRzLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5sZWdlbmQpO1xuXG5cdFx0XHRpZiAobGVnZW5kKSB7XG5cdFx0XHRcdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgbGVnZW5kT3B0cyk7XG5cdFx0XHRcdGxlZ2VuZC5vcHRpb25zID0gbGVnZW5kT3B0cztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChsZWdlbmQpIHtcblx0XHRcdGNvcmVfbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGxlZ2VuZCk7XG5cdFx0XHRkZWxldGUgY2hhcnQubGVnZW5kO1xuXHRcdH1cblx0fSxcblxuXHRhZnRlckV2ZW50OiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdHZhciBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG5cdFx0aWYgKGxlZ2VuZCkge1xuXHRcdFx0bGVnZW5kLmhhbmRsZUV2ZW50KGUpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIG5vb3AkMiA9IGhlbHBlcnMkMS5ub29wO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0dGl0bGU6IHtcblx0XHRkaXNwbGF5OiBmYWxzZSxcblx0XHRmb250U3R5bGU6ICdib2xkJyxcblx0XHRmdWxsV2lkdGg6IHRydWUsXG5cdFx0cGFkZGluZzogMTAsXG5cdFx0cG9zaXRpb246ICd0b3AnLFxuXHRcdHRleHQ6ICcnLFxuXHRcdHdlaWdodDogMjAwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgdG8gYmUgYWJvdmVcblx0fVxufSk7XG5cbi8qKlxuICogSU1QT1JUQU5UOiB0aGlzIGNsYXNzIGlzIGV4cG9zZWQgcHVibGljbHkgYXMgQ2hhcnQuTGVnZW5kLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHJlcXVpcmVkIVxuICovXG52YXIgVGl0bGUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRoZWxwZXJzJDEuZXh0ZW5kKG1lLCBjb25maWcpO1xuXG5cdFx0Ly8gQ29udGFpbnMgaGl0IGJveGVzIGZvciBlYWNoIGRhdGFzZXQgKGluIGRhdGFzZXQgb3JkZXIpXG5cdFx0bWUubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblx0fSxcblxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuXG5cdGJlZm9yZVVwZGF0ZTogbm9vcCQyLFxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcblxuXHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0bWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXHRcdG1lLm1hcmdpbnMgPSBtYXJnaW5zO1xuXG5cdFx0Ly8gRGltZW5zaW9uc1xuXHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cdFx0Ly8gTGFiZWxzXG5cdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcblx0XHRtZS5idWlsZExhYmVscygpO1xuXHRcdG1lLmFmdGVyQnVpbGRMYWJlbHMoKTtcblxuXHRcdC8vIEZpdFxuXHRcdG1lLmJlZm9yZUZpdCgpO1xuXHRcdG1lLmZpdCgpO1xuXHRcdG1lLmFmdGVyRml0KCk7XG5cdFx0Ly9cblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xuXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XG5cblx0fSxcblx0YWZ0ZXJVcGRhdGU6IG5vb3AkMixcblxuXHQvL1xuXG5cdGJlZm9yZVNldERpbWVuc2lvbnM6IG5vb3AkMixcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuXHRcdFx0bWUubGVmdCA9IDA7XG5cdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUudG9wID0gMDtcblx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcblx0XHR9XG5cblx0XHQvLyBSZXNldCBwYWRkaW5nXG5cdFx0bWUucGFkZGluZ0xlZnQgPSAwO1xuXHRcdG1lLnBhZGRpbmdUb3AgPSAwO1xuXHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XG5cdFx0bWUucGFkZGluZ0JvdHRvbSA9IDA7XG5cblx0XHQvLyBSZXNldCBtaW5TaXplXG5cdFx0bWUubWluU2l6ZSA9IHtcblx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fTtcblx0fSxcblx0YWZ0ZXJTZXREaW1lbnNpb25zOiBub29wJDIsXG5cblx0Ly9cblxuXHRiZWZvcmVCdWlsZExhYmVsczogbm9vcCQyLFxuXHRidWlsZExhYmVsczogbm9vcCQyLFxuXHRhZnRlckJ1aWxkTGFiZWxzOiBub29wJDIsXG5cblx0Ly9cblxuXHRiZWZvcmVGaXQ6IG5vb3AkMixcblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgZGlzcGxheSA9IG9wdHMuZGlzcGxheTtcblx0XHR2YXIgbWluU2l6ZSA9IG1lLm1pblNpemU7XG5cdFx0dmFyIGxpbmVDb3VudCA9IGhlbHBlcnMkMS5pc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcblx0XHR2YXIgZm9udE9wdHMgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG9wdHMpO1xuXHRcdHZhciB0ZXh0U2l6ZSA9IGRpc3BsYXkgPyAobGluZUNvdW50ICogZm9udE9wdHMubGluZUhlaWdodCkgKyAob3B0cy5wYWRkaW5nICogMikgOiAwO1xuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gbWUubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSB0ZXh0U2l6ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IHRleHRTaXplO1xuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcblx0XHR9XG5cblx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGg7XG5cdFx0bWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG5cblx0fSxcblx0YWZ0ZXJGaXQ6IG5vb3AkMixcblxuXHQvLyBTaGFyZWQgTWV0aG9kc1xuXHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG5cdFx0cmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcblx0fSxcblxuXHQvLyBBY3R1YWxseSBkcmF3IHRoZSB0aXRsZSBibG9jayBvbiB0aGUgY2FudmFzXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHR2YXIgZm9udE9wdHMgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG9wdHMpO1xuXHRcdFx0dmFyIGxpbmVIZWlnaHQgPSBmb250T3B0cy5saW5lSGVpZ2h0O1xuXHRcdFx0dmFyIG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgb3B0cy5wYWRkaW5nO1xuXHRcdFx0dmFyIHJvdGF0aW9uID0gMDtcblx0XHRcdHZhciB0b3AgPSBtZS50b3A7XG5cdFx0XHR2YXIgbGVmdCA9IG1lLmxlZnQ7XG5cdFx0XHR2YXIgYm90dG9tID0gbWUuYm90dG9tO1xuXHRcdFx0dmFyIHJpZ2h0ID0gbWUucmlnaHQ7XG5cdFx0XHR2YXIgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KG9wdHMuZm9udENvbG9yLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRjdHguZm9udCA9IGZvbnRPcHRzLnN0cmluZztcblxuXHRcdFx0Ly8gSG9yaXpvbnRhbFxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHRpdGxlWCA9IGxlZnQgKyAoKHJpZ2h0IC0gbGVmdCkgLyAyKTsgLy8gbWlkcG9pbnQgb2YgdGhlIHdpZHRoXG5cdFx0XHRcdHRpdGxlWSA9IHRvcCArIG9mZnNldDtcblx0XHRcdFx0bWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aXRsZVggPSBvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyBsZWZ0ICsgb2Zmc2V0IDogcmlnaHQgLSBvZmZzZXQ7XG5cdFx0XHRcdHRpdGxlWSA9IHRvcCArICgoYm90dG9tIC0gdG9wKSAvIDIpO1xuXHRcdFx0XHRtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcblx0XHRcdFx0cm90YXRpb24gPSBNYXRoLlBJICogKG9wdHMucG9zaXRpb24gPT09ICdsZWZ0JyA/IC0wLjUgOiAwLjUpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSh0aXRsZVgsIHRpdGxlWSk7XG5cdFx0XHRjdHgucm90YXRlKHJvdGF0aW9uKTtcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXHRcdFx0dmFyIHRleHQgPSBvcHRzLnRleHQ7XG5cdFx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGV4dCkpIHtcblx0XHRcdFx0dmFyIHkgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRjdHguZmlsbFRleHQodGV4dFtpXSwgMCwgeSwgbWF4V2lkdGgpO1xuXHRcdFx0XHRcdHkgKz0gbGluZUhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsIDAsIDAsIG1heFdpZHRoKTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpIHtcblx0dmFyIHRpdGxlID0gbmV3IFRpdGxlKHtcblx0XHRjdHg6IGNoYXJ0LmN0eCxcblx0XHRvcHRpb25zOiB0aXRsZU9wdHMsXG5cdFx0Y2hhcnQ6IGNoYXJ0XG5cdH0pO1xuXG5cdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuXHRjb3JlX2xheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG5cdGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cblxudmFyIHBsdWdpbl90aXRsZSA9IHtcblx0aWQ6ICd0aXRsZScsXG5cblx0LyoqXG5cdCAqIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHNpbmNlIDIuMS41LCB0aGUgdGl0bGUgaXMgcmVnaXN0ZXJlZCBhcyBhIHBsdWdpbiwgbWFraW5nXG5cdCAqIENoYXJ0LlRpdGxlIG9ic29sZXRlLiBUbyBhdm9pZCBhIGJyZWFraW5nIGNoYW5nZSwgd2UgZXhwb3J0IHRoZSBUaXRsZSBhcyBwYXJ0IG9mXG5cdCAqIHRoZSBwbHVnaW4sIHdoaWNoIG9uZSB3aWxsIGJlIHJlLWV4cG9zZWQgaW4gdGhlIGNoYXJ0LmpzIGZpbGUuXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvMjY0MFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2VsZW1lbnQ6IFRpdGxlLFxuXG5cdGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHRpdGxlT3B0cyA9IGNoYXJ0Lm9wdGlvbnMudGl0bGU7XG5cblx0XHRpZiAodGl0bGVPcHRzKSB7XG5cdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xuXHRcdH1cblx0fSxcblxuXHRiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHRpdGxlT3B0cyA9IGNoYXJ0Lm9wdGlvbnMudGl0bGU7XG5cdFx0dmFyIHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuXG5cdFx0aWYgKHRpdGxlT3B0cykge1xuXHRcdFx0aGVscGVycyQxLm1lcmdlSWYodGl0bGVPcHRzLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC50aXRsZSk7XG5cblx0XHRcdGlmICh0aXRsZUJsb2NrKSB7XG5cdFx0XHRcdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlQmxvY2ssIHRpdGxlT3B0cyk7XG5cdFx0XHRcdHRpdGxlQmxvY2sub3B0aW9ucyA9IHRpdGxlT3B0cztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZU5ld1RpdGxlQmxvY2tBbmRBdHRhY2goY2hhcnQsIHRpdGxlT3B0cyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aXRsZUJsb2NrKSB7XG5cdFx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcblx0XHRcdGRlbGV0ZSBjaGFydC50aXRsZUJsb2NrO1xuXHRcdH1cblx0fVxufTtcblxudmFyIHBsdWdpbnMgPSB7fTtcbnZhciBmaWxsZXIgPSBwbHVnaW5fZmlsbGVyO1xudmFyIGxlZ2VuZCA9IHBsdWdpbl9sZWdlbmQ7XG52YXIgdGl0bGUgPSBwbHVnaW5fdGl0bGU7XG5wbHVnaW5zLmZpbGxlciA9IGZpbGxlcjtcbnBsdWdpbnMubGVnZW5kID0gbGVnZW5kO1xucGx1Z2lucy50aXRsZSA9IHRpdGxlO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnRcbiAqL1xuXG5cbmNvcmVfY29udHJvbGxlci5oZWxwZXJzID0gaGVscGVycyQxO1xuXG4vLyBAdG9kbyBkaXNwYXRjaCB0aGVzZSBoZWxwZXJzIGludG8gYXBwcm9wcmlhdGVkIGhlbHBlcnMvaGVscGVycy4qIGZpbGUgYW5kIHdyaXRlIHVuaXQgdGVzdHMhXG5jb3JlX2hlbHBlcnMoY29yZV9jb250cm9sbGVyKTtcblxuY29yZV9jb250cm9sbGVyLl9hZGFwdGVycyA9IGNvcmVfYWRhcHRlcnM7XG5jb3JlX2NvbnRyb2xsZXIuQW5pbWF0aW9uID0gY29yZV9hbmltYXRpb247XG5jb3JlX2NvbnRyb2xsZXIuYW5pbWF0aW9uU2VydmljZSA9IGNvcmVfYW5pbWF0aW9ucztcbmNvcmVfY29udHJvbGxlci5jb250cm9sbGVycyA9IGNvbnRyb2xsZXJzO1xuY29yZV9jb250cm9sbGVyLkRhdGFzZXRDb250cm9sbGVyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlcjtcbmNvcmVfY29udHJvbGxlci5kZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHM7XG5jb3JlX2NvbnRyb2xsZXIuRWxlbWVudCA9IGNvcmVfZWxlbWVudDtcbmNvcmVfY29udHJvbGxlci5lbGVtZW50cyA9IGVsZW1lbnRzO1xuY29yZV9jb250cm9sbGVyLkludGVyYWN0aW9uID0gY29yZV9pbnRlcmFjdGlvbjtcbmNvcmVfY29udHJvbGxlci5sYXlvdXRzID0gY29yZV9sYXlvdXRzO1xuY29yZV9jb250cm9sbGVyLnBsYXRmb3JtID0gcGxhdGZvcm07XG5jb3JlX2NvbnRyb2xsZXIucGx1Z2lucyA9IGNvcmVfcGx1Z2lucztcbmNvcmVfY29udHJvbGxlci5TY2FsZSA9IGNvcmVfc2NhbGU7XG5jb3JlX2NvbnRyb2xsZXIuc2NhbGVTZXJ2aWNlID0gY29yZV9zY2FsZVNlcnZpY2U7XG5jb3JlX2NvbnRyb2xsZXIuVGlja3MgPSBjb3JlX3RpY2tzO1xuY29yZV9jb250cm9sbGVyLlRvb2x0aXAgPSBjb3JlX3Rvb2x0aXA7XG5cbi8vIFJlZ2lzdGVyIGJ1aWx0LWluIHNjYWxlc1xuXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycy5lYWNoKHNjYWxlcywgZnVuY3Rpb24oc2NhbGUsIHR5cGUpIHtcblx0Y29yZV9jb250cm9sbGVyLnNjYWxlU2VydmljZS5yZWdpc3RlclNjYWxlVHlwZSh0eXBlLCBzY2FsZSwgc2NhbGUuX2RlZmF1bHRzKTtcbn0pO1xuXG4vLyBMb2FkIHRvIHJlZ2lzdGVyIGJ1aWx0LWluIGFkYXB0ZXJzIChhcyBzaWRlIGVmZmVjdHMpXG5cblxuLy8gTG9hZGluZyBidWlsdC1pbiBwbHVnaW5zXG5cbmZvciAodmFyIGsgaW4gcGx1Z2lucykge1xuXHRpZiAocGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuXHRcdGNvcmVfY29udHJvbGxlci5wbHVnaW5zLnJlZ2lzdGVyKHBsdWdpbnNba10pO1xuXHR9XG59XG5cbmNvcmVfY29udHJvbGxlci5wbGF0Zm9ybS5pbml0aWFsaXplKCk7XG5cbnZhciBzcmMgPSBjb3JlX2NvbnRyb2xsZXI7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0d2luZG93LkNoYXJ0ID0gY29yZV9jb250cm9sbGVyO1xufVxuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkNoYXJ0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuQ2hhcnQgPSBjb3JlX2NvbnRyb2xsZXI7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5MZWdlbmRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjVcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5MZWdlbmQgPSBwbHVnaW5zLmxlZ2VuZC5fZWxlbWVudDtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpdGxlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuVGl0bGUgPSBwbHVnaW5zLnRpdGxlLl9lbGVtZW50O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQucGx1Z2lucyBpbnN0ZWFkXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsdWdpblNlcnZpY2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjVcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5wbHVnaW5TZXJ2aWNlID0gY29yZV9jb250cm9sbGVyLnBsdWdpbnM7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGluaGVyaXRpbmcgZnJvbSBDaGFydC5QbHVnaW5nQmFzZSBoYXMgbm9cbiAqIGVmZmVjdCwgaW5zdGVhZCBzaW1wbHkgY3JlYXRlL3JlZ2lzdGVyIHBsdWdpbnMgdmlhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqIEBpbnRlcmZhY2UgQ2hhcnQuUGx1Z2luQmFzZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLlBsdWdpbkJhc2UgPSBjb3JlX2NvbnRyb2xsZXIuRWxlbWVudC5leHRlbmQoe30pO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuY2FudmFzSGVscGVyc1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLmNhbnZhc0hlbHBlcnMgPSBjb3JlX2NvbnRyb2xsZXIuaGVscGVycy5jYW52YXM7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5sYXlvdXRzIGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmxheW91dFNlcnZpY2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjNcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5sYXlvdXRTZXJ2aWNlID0gY29yZV9jb250cm9sbGVyLmxheW91dHM7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZS5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuTGluZWFyU2NhbGVCYXNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLkxpbmVhclNjYWxlQmFzZSA9IHNjYWxlX2xpbmVhcmJhc2U7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGluc3RlYWQgd2Ugc2hvdWxkIGNyZWF0ZSBhIG5ldyBDaGFydFxuICogYnkgc2V0dGluZyB0aGUgdHlwZSBpbiB0aGUgY29uZmlnIChgbmV3IENoYXJ0KGlkLCB7dHlwZTogJ3tjaGFydC10eXBlfSd9YCkuXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKi9cbmNvcmVfY29udHJvbGxlci5oZWxwZXJzLmVhY2goXG5cdFtcblx0XHQnQmFyJyxcblx0XHQnQnViYmxlJyxcblx0XHQnRG91Z2hudXQnLFxuXHRcdCdMaW5lJyxcblx0XHQnUG9sYXJBcmVhJyxcblx0XHQnUmFkYXInLFxuXHRcdCdTY2F0dGVyJ1xuXHRdLFxuXHRmdW5jdGlvbihrbGFzcykge1xuXHRcdGNvcmVfY29udHJvbGxlcltrbGFzc10gPSBmdW5jdGlvbihjdHgsIGNmZykge1xuXHRcdFx0cmV0dXJuIG5ldyBjb3JlX2NvbnRyb2xsZXIoY3R4LCBjb3JlX2NvbnRyb2xsZXIuaGVscGVycy5tZXJnZShjZmcgfHwge30sIHtcblx0XHRcdFx0dHlwZToga2xhc3MuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBrbGFzcy5zbGljZSgxKVxuXHRcdFx0fSkpO1xuXHRcdH07XG5cdH1cbik7XG5cbnJldHVybiBzcmM7XG5cbn0pKSk7XG4iLCJpbXBvcnQgQ2hhcnQgZnJvbSAnY2hhcnQuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2hhcnQoY2hhcnRJZCwgY2hhcnRUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoY3JlYXRlRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgc3R5bGU6IHRoaXMuc3R5bGVzLFxuICAgICAgICBjbGFzczogdGhpcy5jc3NDbGFzc2VzXG4gICAgICB9LCBbY3JlYXRlRWxlbWVudCgnY2FudmFzJywge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiB0aGlzLmNoYXJ0SWQsXG4gICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICB9LFxuICAgICAgICByZWY6ICdjYW52YXMnXG4gICAgICB9KV0pO1xuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGNoYXJ0SWQ6IHtcbiAgICAgICAgZGVmYXVsdDogY2hhcnRJZCxcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICB9LFxuICAgICAgd2lkdGg6IHtcbiAgICAgICAgZGVmYXVsdDogNDAwLFxuICAgICAgICB0eXBlOiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgZGVmYXVsdDogNDAwLFxuICAgICAgICB0eXBlOiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICBjc3NDbGFzc2VzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0XG4gICAgICB9LFxuICAgICAgcGx1Z2luczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX2NoYXJ0OiBudWxsLFxuICAgICAgICBfcGx1Z2luczogdGhpcy5wbHVnaW5zXG4gICAgICB9O1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgYWRkUGx1Z2luOiBmdW5jdGlvbiBhZGRQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIHRoaXMuJGRhdGEuX3BsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlTGVnZW5kOiBmdW5jdGlvbiBnZW5lcmF0ZUxlZ2VuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJGRhdGEuX2NoYXJ0LmdlbmVyYXRlTGVnZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW5kZXJDaGFydDogZnVuY3Rpb24gcmVuZGVyQ2hhcnQoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy4kZGF0YS5fY2hhcnQpIHRoaXMuJGRhdGEuX2NoYXJ0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZGF0YS5fY2hhcnQgPSBuZXcgQ2hhcnQodGhpcy4kcmVmcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSwge1xuICAgICAgICAgIHR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgcGx1Z2luczogdGhpcy4kZGF0YS5fcGx1Z2luc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy4kZGF0YS5fY2hhcnQpIHtcbiAgICAgICAgdGhpcy4kZGF0YS5fY2hhcnQuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCB2YXIgQmFyID0gZ2VuZXJhdGVDaGFydCgnYmFyLWNoYXJ0JywgJ2JhcicpO1xuZXhwb3J0IHZhciBIb3Jpem9udGFsQmFyID0gZ2VuZXJhdGVDaGFydCgnaG9yaXpvbnRhbGJhci1jaGFydCcsICdob3Jpem9udGFsQmFyJyk7XG5leHBvcnQgdmFyIERvdWdobnV0ID0gZ2VuZXJhdGVDaGFydCgnZG91Z2hudXQtY2hhcnQnLCAnZG91Z2hudXQnKTtcbmV4cG9ydCB2YXIgTGluZSA9IGdlbmVyYXRlQ2hhcnQoJ2xpbmUtY2hhcnQnLCAnbGluZScpO1xuZXhwb3J0IHZhciBQaWUgPSBnZW5lcmF0ZUNoYXJ0KCdwaWUtY2hhcnQnLCAncGllJyk7XG5leHBvcnQgdmFyIFBvbGFyQXJlYSA9IGdlbmVyYXRlQ2hhcnQoJ3BvbGFyLWNoYXJ0JywgJ3BvbGFyQXJlYScpO1xuZXhwb3J0IHZhciBSYWRhciA9IGdlbmVyYXRlQ2hhcnQoJ3JhZGFyLWNoYXJ0JywgJ3JhZGFyJyk7XG5leHBvcnQgdmFyIEJ1YmJsZSA9IGdlbmVyYXRlQ2hhcnQoJ2J1YmJsZS1jaGFydCcsICdidWJibGUnKTtcbmV4cG9ydCB2YXIgU2NhdHRlciA9IGdlbmVyYXRlQ2hhcnQoJ3NjYXR0ZXItY2hhcnQnLCAnc2NhdHRlcicpO1xuZXhwb3J0IGRlZmF1bHQge1xuICBCYXI6IEJhcixcbiAgSG9yaXpvbnRhbEJhcjogSG9yaXpvbnRhbEJhcixcbiAgRG91Z2hudXQ6IERvdWdobnV0LFxuICBMaW5lOiBMaW5lLFxuICBQaWU6IFBpZSxcbiAgUG9sYXJBcmVhOiBQb2xhckFyZWEsXG4gIFJhZGFyOiBSYWRhcixcbiAgQnViYmxlOiBCdWJibGUsXG4gIFNjYXR0ZXI6IFNjYXR0ZXJcbn07IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgQmFyLCBtaXhpbnMgfSBmcm9tICd2dWUtY2hhcnRqcyc7XG4gIGNvbnN0IHsgcmVhY3RpdmVQcm9wIH0gPSBtaXhpbnM7XG5cbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLnBhZGRpbmcgPSAyMDtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmZvbnRTaXplID0gMTY7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5saW5lSGVpZ2h0ID0gMS42O1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBleHRlbmRzOiBCYXIsXG4gICAgbWl4aW5zOiBbcmVhY3RpdmVQcm9wXSxcbiAgICBwcm9wczoge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lVGVuc2lvbjogMSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMuY2hhcnREYXRhLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0sXG4gIH07XG48L3NjcmlwdD4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNoYXJ0TGFiZWxzID0gWycxOTgwJywgJzE5OTAnLCAnMjAwMCcsICcyMDEwJywgJzIwMjAnXTtcblxuY29uc3QgY2hhcnREYXRhTGlzdCA9IFs2NTQyNTY0LCA3MzIyNTY0LCA4MDA4Mjc4LCA4MTc1MTMzLCA1NDc1MTMzXTtcblxuY29uc3QgQ2hhcnREYXRhID0ge1xuICBkYXRhOiB7XG4gICAgbGFiZWxzOiBjaGFydExhYmVscyxcbiAgICBkYXRhc2V0czogW1xuICAgICAge1xuICAgICAgICBkYXRhOiBjaGFydERhdGFMaXN0LFxuICAgICAgICBmaWxsOiBmYWxzZSwgLy8gdXNlZCBieSBsaW5lIGNoYXJ0XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogW1xuICAgICAgICAgICcjMkYzMzRGJyxcbiAgICAgICAgICAnIzMxNTVBNicsXG4gICAgICAgICAgJyNGMjY5NUQnLFxuICAgICAgICAgICcjRUJCQ0Q4JyxcbiAgICAgICAgICAnI0Y5QTEzNycsXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlckNvbG9yOiBbXG4gICAgICAgICAgJyNBQ0FFQjknXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9LFxuICAgIF1cbiAgfSxcbiAgYmFyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgdGV4dDogJ1BvcHVsYXRpb24gQ2hhcnQnLFxuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBsaW5lVGVuc2lvbjogMSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4QXhlczogW3tcbiAgICAgICAgICBzY2FsZUxhYmVsOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTdHJpbmc6ICdZZWFycycsXG4gICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgeUF4ZXM6IFt7XG4gICAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnUG9wdWxhdGlvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgcGFkZGluZzogMjUsXG4gICAgICAgICAgfVxuICAgICAgICB9XVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaG9yaXpvbnRhbEJhcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgIHRleHQ6ICdQb3B1bGF0aW9uIENoYXJ0JyxcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeEF4ZXM6IFt7XG4gICAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnUG9wdWxhdGlvbicsXG4gICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgeUF4ZXM6IFt7XG4gICAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnWWVhcnMnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDI1LFxuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBpZToge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgIHRleHQ6ICdQb3B1bGF0aW9uIENoYXJ0JyxcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBsaW5lVGVuc2lvbjogMSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnREYXRhOyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLWJhci52dWUnOyAvLyBPdXIgY29tcG9uZW50XG5pbXBvcnQgQ2hhcnREYXRhIGZyb20gJy4vY2hhcnQuZGF0YSc7IC8vIE91ciBzYW1wbGUgZGF0YVxuXG5jb25zdCBjaGFydFR5cGUgPSAnYmFyJztcblxuY2xhc3MgQ2hhcnRCYXIge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoYG55Y28tY2hhcnQtJHtjaGFydFR5cGV9YCwgQ2hhcnRDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogYFtkYXRhLWpzPVwiY2hhcnQtJHtjaGFydFR5cGV9XCJdYCxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBDaGFydERhdGEuZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBDaGFydERhdGEuYmFyLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydEJhcjsiLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBIb3Jpem9udGFsQmFyLCBtaXhpbnMgfSBmcm9tICd2dWUtY2hhcnRqcyc7XG4gIGNvbnN0IHsgcmVhY3RpdmVQcm9wIH0gPSBtaXhpbnM7XG5cbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLnBhZGRpbmcgPSAyMDtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmZvbnRTaXplID0gMTY7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5saW5lSGVpZ2h0ID0gMS42O1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBleHRlbmRzOiBIb3Jpem9udGFsQmFyLFxuICAgIG1peGluczogW3JlYWN0aXZlUHJvcF0sXG4gICAgcHJvcHM6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICB9O1xuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7XG5pbXBvcnQgQ2hhcnRDb21wb25lbnQgZnJvbSAnLi9jaGFydC0taG9yaXpvbnRhbC1iYXIudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IENoYXJ0RGF0YSBmcm9tICcuL2NoYXJ0LmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY29uc3QgY2hhcnRUeXBlID0gJ2hvcml6b250YWwtYmFyJztcblxuY2xhc3MgQ2hhcnRIb3Jpem9udGFsQmFyIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KGBueWNvLWNoYXJ0LSR7Y2hhcnRUeXBlfWAsIENoYXJ0Q29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6IGBbZGF0YS1qcz1cImNoYXJ0LSR7Y2hhcnRUeXBlfVwiXWAsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogQ2hhcnREYXRhLmRhdGEsXG4gICAgICAgICAgb3B0aW9uczogQ2hhcnREYXRhLmhvcml6b250YWxCYXIub3B0aW9uc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0SG9yaXpvbnRhbEJhcjsiLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBMaW5lLCBtaXhpbnMgfSBmcm9tICd2dWUtY2hhcnRqcyc7XG4gIGNvbnN0IHsgcmVhY3RpdmVQcm9wIH0gPSBtaXhpbnM7XG5cbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLnBhZGRpbmcgPSAyMDtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmZvbnRTaXplID0gMTY7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5saW5lSGVpZ2h0ID0gMS42O1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBleHRlbmRzOiBMaW5lLFxuICAgIG1peGluczogW3JlYWN0aXZlUHJvcF0sXG4gICAgcHJvcHM6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICB9O1xuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7XG5pbXBvcnQgQ2hhcnRDb21wb25lbnQgZnJvbSAnLi9jaGFydC0tbGluZS52dWUnOyAvLyBPdXIgY29tcG9uZW50XG5pbXBvcnQgQ2hhcnREYXRhIGZyb20gJy4vY2hhcnQuZGF0YSc7IC8vIE91ciBzYW1wbGUgZGF0YVxuXG5jb25zdCBjaGFydFR5cGUgPSAnbGluZSc7XG5cbmNsYXNzIENoYXJ0TGluZSB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudChgbnljby1jaGFydC0ke2NoYXJ0VHlwZX1gLCBDaGFydENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiBgW2RhdGEtanM9XCJjaGFydC0ke2NoYXJ0VHlwZX1cIl1gLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IENoYXJ0RGF0YS5kYXRhLFxuICAgICAgICAgIG9wdGlvbnM6IENoYXJ0RGF0YS5iYXIub3B0aW9uc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0TGluZTsiLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBQaWUsIG1peGlucyB9IGZyb20gJ3Z1ZS1jaGFydGpzJztcbiAgY29uc3QgeyByZWFjdGl2ZVByb3AgfSA9IG1peGlucztcblxuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUucGFkZGluZyA9IDIwO1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUuZm9udFNpemUgPSAxNjtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmxpbmVIZWlnaHQgPSAxLjY7XG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIGV4dGVuZHM6IFBpZSxcbiAgICBtaXhpbnM6IFtyZWFjdGl2ZVByb3BdLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICB9O1xuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7XG5pbXBvcnQgQ2hhcnRDb21wb25lbnQgZnJvbSAnLi9jaGFydC0tcGllLnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBDaGFydERhdGEgZnJvbSAnLi9jaGFydC5kYXRhJzsgLy8gT3VyIHNhbXBsZSBkYXRhXG5cbmNvbnN0IGNoYXJ0VHlwZSA9ICdwaWUnO1xuXG5jbGFzcyBDaGFydFBpZSB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudChgbnljby1jaGFydC0ke2NoYXJ0VHlwZX1gLCBDaGFydENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiBgW2RhdGEtanM9XCJjaGFydC0ke2NoYXJ0VHlwZX1cIl1gLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IENoYXJ0RGF0YS5kYXRhLFxuICAgICAgICAgIG9wdGlvbnM6IENoYXJ0RGF0YS5waWUub3B0aW9uc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0UGllOyIsIjx0ZW1wbGF0ZT48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IHtcbiAgICAgICdsYXllcnMnOiB7XG4gICAgICAgIHR5cGU6IEFycmF5XG4gICAgICB9LFxuICAgICAgJ2NvbmZpZyc6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWFwOiBudWxsLFxuICAgICAgICBtYXBQb3B1cDogbnVsbCxcbiAgICAgICAgbWFwRmlsdGVyOiBudWxsLFxuICAgICAgICBhY3RpdmVMYXllcjogbnVsbCxcbiAgICAgICAgbWFwTG9hZGVkOiBmYWxzZSxcbiAgICAgICAgbWVudUl0ZW1zOiBbXSxcbiAgICAgICAgc2VsZWN0ZWRJdGVtczogW10sXG4gICAgICB9O1xuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZU1hcCgpO1xuICAgIH0sXG4gICAgZGVzdHJveWVkKCkge1xuICAgICAgdGhpcy5tYXAucmVtb3ZlKCk7XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgJ2xheWVycyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcFR5cGUgPT09ICdtdWx0aScpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICAgICAgICB0aGlzLnRyYWNrTGF5ZXIobGF5ZXIubmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChsYXllci5kZWZhdWx0KVxuICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUxheWVyID0gbGF5ZXIubmFtZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubWFwTG9hZGVkKVxuICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVMYXllcihsYXllcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29uZmlnLm1hcFR5cGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyc1swXTtcblxuICAgICAgICAgIHRoaXMuYWN0aXZlTGF5ZXIgPSBsYXllci5uYW1lO1xuICAgICAgICAgIHRoaXMuZ2VuZXJhdGVMZWdlbmQobGF5ZXIuZGF0YSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQpXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVMYXllcihsYXllcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUeXBlIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ21hcExvYWRlZCc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwTG9hZGVkICYmIHRoaXMubGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGxheWVycyA9IHRoaXMubGF5ZXJzO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUxheWVyKGxheWVyc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ21lbnVJdGVtcyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVudUl0ZW1zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplVG9nZ2xlKHRoaXMubWVudUl0ZW1zKTtcbiAgICAgIH0sXG4gICAgICAnc2VsZWN0ZWRJdGVtcyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmxheWVyc1swXTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gWydpbicsIGxheWVyLmxlZ2VuZENvbHVtbl07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmaWx0ZXIucHVzaCh0aGlzLnNlbGVjdGVkSXRlbXNbaV0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsZXQgcmVsYXRlZEZlYXR1cmVzID0gdGhpcy5tYXAucXVlcnlTb3VyY2VGZWF0dXJlcyhsYXllci5uYW1lLCB7XG4gICAgICAgICAgICBzb3VyY2VMYXllcjogbGF5ZXIubmFtZSxcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBzZXQgZmlsdGVyIHdoZW4gbGVnZW5kIGl0ZW0gc2VsZWN0ZWRcbiAgICAgICAgICB0aGlzLm1hcC5zZXRGaWx0ZXIoYCR7bGF5ZXIubmFtZX0taGlnaGxpZ2h0ZWRgLCBmaWx0ZXIpO1xuICAgICAgICAgIHRoaXMubWFwLnNldExheW91dFByb3BlcnR5KGAke2xheWVyLm5hbWV9LWhpZ2hsaWdodGVkYCwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoICYmICF0aGlzLm1hcFBvcHVwKSB7XG4gICAgICAgICAgdGhpcy5tYXAuc2V0RmlsdGVyKGAke2xheWVyLm5hbWV9LWhpZ2hsaWdodGVkYCwgbnVsbCk7XG4gICAgICAgICAgdGhpcy5tYXAuc2V0TGF5b3V0UHJvcGVydHkoYCR7bGF5ZXIubmFtZX0taGlnaGxpZ2h0ZWRgLCAndmlzaWJpbGl0eScsICdub25lJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBpbml0aWFsaXplTWFwKCkge1xuICAgICAgICBjb25zdCBtYXBDb25maWcgPSB0aGlzLmNvbmZpZztcblxuICAgICAgICBtYXBib3hnbC5hY2Nlc3NUb2tlbiA9IG1hcENvbmZpZy5BUElLZXk7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IG1hcGJveGdsLk1hcCh7XG4gICAgICAgICAgY29udGFpbmVyOiBtYXBDb25maWcuY29udGFpbmVySWQsXG4gICAgICAgICAgY2VudGVyOiBtYXBDb25maWcuY2VudGVyLFxuICAgICAgICAgIHpvb206IG1hcENvbmZpZy56b29tLFxuICAgICAgICAgIHN0eWxlOiBtYXBDb25maWcuc3R5bGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tYXAuYWRkQ29udHJvbChuZXcgbWFwYm94Z2wuTmF2aWdhdGlvbkNvbnRyb2woKSk7XG4gICAgICAgIHRoaXMubWFwLm9uKCdsb2FkJywgKCkgPT4gdGhpcy5tYXBMb2FkZWQgPSB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwLmdldExheWVyKGxheWVyLm5hbWUpID09PSB1bmRlZmluZWQgJiYgT2JqZWN0LmVudHJpZXMobGF5ZXIuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgdmlzaWJpbGl0eSA9IGxheWVyLm5hbWUgPT09IHRoaXMuYWN0aXZlTGF5ZXIgPyAndmlzaWJsZScgOiAnbm9uZSc7XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0gbGF5ZXIuZmlsdGVyQnkgPyBbJ2luJywgbGF5ZXIuZmlsdGVyQnksICcnXSA6IFtdO1xuICAgICAgICAgIGNvbnN0IGZpbGwgPSB0aGlzLmdlbmVyYXRlRmlsbENvbG9yKCk7XG5cbiAgICAgICAgICB0aGlzLm1hcC5hZGRTb3VyY2UobGF5ZXIubmFtZSwge1xuICAgICAgICAgICAgJ3R5cGUnOiAnZ2VvanNvbicsXG4gICAgICAgICAgICAnZGF0YSc6IGxheWVyLmRhdGFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMubWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgICdpZCc6IGxheWVyLm5hbWUsXG4gICAgICAgICAgICAndHlwZSc6ICdmaWxsJyxcbiAgICAgICAgICAgICdzb3VyY2UnOiBsYXllci5uYW1lLFxuICAgICAgICAgICAgJ3BhaW50Jzoge1xuICAgICAgICAgICAgICAnZmlsbC1vdXRsaW5lLWNvbG9yJzogZmlsbFswXSxcbiAgICAgICAgICAgICAgJ2ZpbGwtY29sb3InOiBmaWxsWzFdLFxuICAgICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMC43XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2xheW91dCc6IHtcbiAgICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiB2aXNpYmlsaXR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLm1hcC5hZGRMYXllcih7XG4gICAgICAgICAgICAnaWQnOiBgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGAsXG4gICAgICAgICAgICAndHlwZSc6ICdmaWxsJyxcbiAgICAgICAgICAgICdzb3VyY2UnOiBsYXllci5uYW1lLFxuICAgICAgICAgICAgJ3BhaW50Jzoge1xuICAgICAgICAgICAgICAnZmlsbC1vdXRsaW5lLWNvbG9yJzogZmlsbFswXSxcbiAgICAgICAgICAgICAgJ2ZpbGwtY29sb3InOiBmaWxsWzFdLFxuICAgICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdmaWx0ZXInOiBmaWx0ZXIsXG4gICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6IHZpc2liaWxpdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUZpbHRlcihsYXllcik7XG4gICAgICAgICAgdGhpcy51cGRhdGVDdXJzb3JPbkhvdmVyKGxheWVyLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW5pdGlhbGl6ZVBvcHVwKGV2ZW50LCBsYXllcikge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXBUeXBlID09PSAnbXVsdGknID8gdGhpcy5wb3B1cE11bHRpTGF5ZXIoZXZlbnQsIGxheWVyKSA6IHRoaXMucG9wdXBTaW5nbGVMYXllcihldmVudCwgbGF5ZXIpO1xuICAgICAgfSxcbiAgICAgIGluaXRpYWxpemVUb2dnbGUodG9nZ2xlTGlzdCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXBUeXBlID09PSAnbXVsdGknID8gdGhpcy50b2dnbGVNdWx0aUxheWVyKHRvZ2dsZUxpc3QpIDogdGhpcy50b2dnbGVTaW5nbGVMYXllcih0b2dnbGVMaXN0KTtcbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplRmlsdGVyKGxheWVyKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1hcFR5cGUgPT09ICdtdWx0aScgPyB0aGlzLmZpbHRlck11bHRpTGF5ZXIobGF5ZXIpIDogdGhpcy5maWx0ZXJTaW5nbGVMYXllcihsYXllcik7XG4gICAgICB9LFxuICAgICAgdXBkYXRlQ3Vyc29yT25Ib3ZlcihsYXllcklkKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMubWFwO1xuXG4gICAgICAgIC8vIGNoYW5nZSB0aGUgY3Vyc29yIHRvIGEgcG9pbnRlciB3aGVuIHRoZSBtb3VzZSBpcyBvdmVyIHRoZSBsYXllci5cbiAgICAgICAgbWFwLm9uKCdtb3VzZWVudGVyJywgbGF5ZXJJZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcC5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoYW5nZSB0aGUgY3Vyc29yIGJhY2sgdG8gdGhlIGRlZmF1bHQgd2hlbiBpdCBsZWF2ZXMgdGhlIGxheWVyLlxuICAgICAgICBtYXAub24oJ21vdXNlbGVhdmUnLCBsYXllcklkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWFwLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUZpbGxDb2xvcigpIHtcbiAgICAgICAgLy8gTllDTyBjb2xvcnMsIFsnZmlsbC1vdXRsaW5lJywgJ2ZpbGwnXVxuICAgICAgICBjb25zdCBjb2xvcnMgPSBbXG4gICAgICAgICAgLy8gYmxhY2ssIHJlZFxuICAgICAgICAgIFsnIzAwMDAwMCcsICcjRjI2OTVEJ10sXG4gICAgICAgICAgLy8gYmxhY2ssIG9yYW5nZVxuICAgICAgICAgIFsnIzAwMDAwMCcsICcjRkZBMTMzJ10sXG4gICAgICAgICAgLy8gZGFyayBibHVlLCBncmF5XG4gICAgICAgICAgWycjMkYzMzRGJywgJyNBQ0FFQjknXSxcbiAgICAgICAgICAvLyBibHVlLCBvcmFuZ2VcbiAgICAgICAgICBbJyMzMTU1QTYnLCAnI0Y5QTEzNyddXG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb2xvcnMubGVuZ3RoKV07XG4gICAgICB9LFxuICAgICAgLy8gbXVsdGkgbGF5ZXJcbiAgICAgIHRyYWNrTGF5ZXIocmVmZXJlbmNlKSB7XG4gICAgICAgIGlmICghdGhpcy5tZW51SXRlbXMuaW5jbHVkZXMocmVmZXJlbmNlKSlcbiAgICAgICAgICB0aGlzLm1lbnVJdGVtcy5wdXNoKHJlZmVyZW5jZSk7XG4gICAgICB9LFxuICAgICAgcG9wdXBNdWx0aUxheWVyKGV2ZW50LCBsYXllcikge1xuICAgICAgICBjb25zdCAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1hcCA9ICR0aGlzLm1hcDtcbiAgICAgICAgY29uc3QgbGF5ZXJOYW1lID0gYCR7bGF5ZXIubmFtZX0taGlnaGxpZ2h0ZWRgO1xuICAgICAgICBjb25zdCBwb3B1cCA9IG5ldyBtYXBib3hnbC5Qb3B1cCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0TG5nTGF0KGV2ZW50LmxuZ0xhdClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRIVE1MKGV2ZW50LmZlYXR1cmVzWzBdLnByb3BlcnRpZXNbbGF5ZXIuZmlsdGVyQnldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZFRvKG1hcCk7XG5cbiAgICAgICAgaWYgKHBvcHVwLmlzT3BlbigpKSB7XG4gICAgICAgICAgJHRoaXMubWFwUG9wdXAgPSBwb3B1cDtcbiAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJOYW1lLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgICAgbWFwLnNldEZpbHRlcihsYXllck5hbWUsICR0aGlzLm1hcEZpbHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBwb3B1cC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gcmVzZXQgYXNzb2NpYXRlZCBzdGF0ZXMgd2hlbiBwb3B1cCBkaXNtaXNzZWQgd2hpbGUgYWN0aXZlXG4gICAgICAgICAgaWYgKCR0aGlzLm1hcFBvcHVwID09PSBwb3B1cCkge1xuICAgICAgICAgICAgJHRoaXMubWFwUG9wdXAgPSBudWxsO1xuICAgICAgICAgICAgJHRoaXMubWFwRmlsdGVyID0gbnVsbDtcbiAgICAgICAgICAgIG1hcC5zZXRGaWx0ZXIobGF5ZXJOYW1lLCBudWxsKTtcbiAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShsYXllck5hbWUsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZpbHRlck11bHRpTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBtYXAgPSAkdGhpcy5tYXA7XG5cbiAgICAgICAgbWFwLm9uKCdjbGljaycsIGxheWVyLm5hbWUsIChlKSA9PiB7XG4gICAgICAgICAgLy8gc2V0IGJib3ggYXMgcmVhY3RhbmdsZSBhcmVhIGFyb3VuZCBjbGlja2VkIHBvaW50XG4gICAgICAgICAgbGV0IGJib3ggPSBbW2UucG9pbnQueCwgZS5wb2ludC55XSwgW2UucG9pbnQueCwgZS5wb2ludC55XV07XG4gICAgICAgICAgbGV0IGZlYXR1cmVzID0gbWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhiYm94LCB7IGxheWVyczogW2xheWVyLm5hbWVdIH0pO1xuXG4gICAgICAgICAgY29uc3QgZmlsdGVyID0gZmVhdHVyZXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIGZlYXR1cmUpIHtcbiAgICAgICAgICAgIG1lbW8ucHVzaChmZWF0dXJlLnByb3BlcnRpZXNbbGF5ZXIuZmlsdGVyQnldKTtcbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICAgIH0sIFsnaW4nLCBgJHtsYXllci5maWx0ZXJCeX1gXSk7XG5cbiAgICAgICAgICAkdGhpcy5tYXBGaWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgICAgJHRoaXMuaW5pdGlhbGl6ZVBvcHVwKGUsIGxheWVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlTXVsdGlMYXllcihsYXllcnNUb1RvZ2dsZSkge1xuICAgICAgICBjb25zdCAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1hcCA9ICR0aGlzLm1hcDtcbiAgICAgICAgY29uc3QgYWN0aXZlTGF5ZXIgPSAkdGhpcy5hY3RpdmVMYXllcjtcbiAgICAgICAgY29uc3QgbGlua0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29uZmlnLmxlZ2VuZElkKTtcblxuICAgICAgICAvLyBjbGVhciBhbGwgbGlua3MgYmVmb3JlIGFwcGVuZGluZyBuZXcgb25lcyB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICAgICAgd2hpbGUgKGxpbmtDb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGxpbmtDb250YWluZXIucmVtb3ZlQ2hpbGQobGlua0NvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5ZXJzVG9Ub2dnbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsYXllclJlZiA9IGxheWVyc1RvVG9nZ2xlW2ldO1xuICAgICAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cbiAgICAgICAgICBsaW5rLmhyZWYgPSAnIyc7XG4gICAgICAgICAgbGluay50ZXh0Q29udGVudCA9IGxheWVyUmVmO1xuXG4gICAgICAgICAgaWYgKGxheWVyUmVmID09PSBhY3RpdmVMYXllcilcbiAgICAgICAgICAgIGxpbmsuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG5cbiAgICAgICAgICAvLyBvbiBjbGljayB1cGRhdGUgbGluayBzdGF0ZSwgYWN0aXZlIGxheWVyIHJlZmVyZW5jZSwgYW5kIGxheWVyIHZpc2liaWxpdHlcbiAgICAgICAgICBsaW5rLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRMYXllciA9IHRoaXMudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IGxpbmtDb250YWluZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGFjdGl2ZSBwb3B1cFxuICAgICAgICAgICAgaWYgKCR0aGlzLm1hcFBvcHVwKVxuICAgICAgICAgICAgICAkdGhpcy5tYXBQb3B1cC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TGluayA9IGxpbmtzW2ldO1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TGF5ZXIgPSBjdXJyZW50TGluay50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudExheWVySGlnaGxpZ2h0ID0gYCR7Y3VycmVudExheWVyfS1oaWdobGlnaHRlZGA7XG4gICAgICAgICAgICAgIGNvbnN0IGxheWVyVmlzaWJpbGl0eSA9IG1hcC5nZXRMYXlvdXRQcm9wZXJ0eShjdXJyZW50TGF5ZXIsICd2aXNpYmlsaXR5Jyk7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMYXllciA9PT0gc2VsZWN0ZWRMYXllcikge1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBpZiBsYXllciBpcyBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyVmlzaWJpbGl0eSA9PT0gJ3Zpc2libGUnICYmIGN1cnJlbnRMaW5rLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJykpXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBzZXQgb3VyIGN1cnJlbnQgbGF5ZXIgYXMgdGhlIGdsb2JhbCBhY3RpdmUgbGF5ZXIsXG4gICAgICAgICAgICAgICAgLy8gYWRkIGFjdGl2ZSBjbGFzcyB0byBsaW5rLCBzZXQgbGF5ZXIgYXMgdmlzaWJsZVxuICAgICAgICAgICAgICAgICR0aGlzLmFjdGl2ZUxheWVyID0gY3VycmVudExheWVyO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5rLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShjdXJyZW50TGF5ZXIsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgbGlua3MgYWN0aXZlIGNsYXNzLCBzZXQgbGF5ZXIgdmlzaWJpbGl0eSB0byBub25lIGFuZCByZW1vdmUgZmlsdGVyc1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5rLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShjdXJyZW50TGF5ZXIsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoY3VycmVudExheWVySGlnaGxpZ2h0LCAndmlzaWJpbGl0eScsICdub25lJyk7XG4gICAgICAgICAgICAgICAgbWFwLnNldEZpbHRlcihjdXJyZW50TGF5ZXJIaWdobGlnaHQsIG51bGwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGxpbmtDb250YWluZXIuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBzaW5nbGUgbGF5ZXJcbiAgICAgIGdlbmVyYXRlTGVnZW5kKGxheWVyRGF0YSkge1xuICAgICAgICBsYXllckRhdGEuZmVhdHVyZXMuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSBmZWF0dXJlLnByb3BlcnRpZXNbdGhpcy5sYXllcnNbMF0ubGVnZW5kQ29sdW1uXTtcblxuICAgICAgICAgIGlmICghdGhpcy5tZW51SXRlbXMuaW5jbHVkZXMoaXRlbSkgJiYgaXRlbSlcbiAgICAgICAgICAgIHRoaXMubWVudUl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHBvcHVwU2luZ2xlTGF5ZXIoZXZlbnQsIGxheWVyKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuICAgICAgICBjb25zdCBsYXllck5hbWUgPSBgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGA7XG5cbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciBzaGFwZSBmYWxscyB1bmRlciBjdXJyZW50IGxlZ2VuZCBzZWxlY3Rpb25cbiAgICAgICAgbGV0IGluQ3VycmVudFNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGxldCBjb2x1bW5GaWx0ZXIgPSBldmVudC5mZWF0dXJlc1swXS5wcm9wZXJ0aWVzW2xheWVyLmxlZ2VuZENvbHVtbl07XG5cbiAgICAgICAgaWYgKCEkdGhpcy5zZWxlY3RlZEl0ZW1zLmluY2x1ZGVzKGNvbHVtbkZpbHRlcikpXG4gICAgICAgICAgaW5DdXJyZW50U2VsZWN0aW9uID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgcG9wdXAgPSBuZXcgbWFwYm94Z2wuUG9wdXAoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldExuZ0xhdChldmVudC5sbmdMYXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0SFRNTChldmVudC5mZWF0dXJlc1swXS5wcm9wZXJ0aWVzW2xheWVyLmZpbHRlckJ5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRUbyhtYXApO1xuXG4gICAgICAgIGlmIChwb3B1cC5pc09wZW4oKSkge1xuICAgICAgICAgICR0aGlzLm1hcFBvcHVwID0gcG9wdXA7XG5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbGVnZW5kIGl0ZW1zIHNlbGVjdGVkLCBoaWdobGlnaHQgc2VsZWN0ZWQgbWFwIHNoYXBlXG4gICAgICAgICAgaWYgKCEkdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGxheWVyTmFtZSwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICAgICAgbWFwLnNldEZpbHRlcihsYXllck5hbWUsICR0aGlzLm1hcEZpbHRlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGxlZ2VuZCBpdGVtcyBzZWxlY3RlZCBhbmQgc2VsZWN0ZWQgbWFwIHNoYXBlIGlzbid0XG4gICAgICAgICAgLy8gd2l0aGluIGFueSBvZiB0aGUgc2VsZWN0ZWQgbGVnZW5kIGl0ZW1zLCBoaWdobGlnaHQgc2VsZWN0ZWRcbiAgICAgICAgICAvLyBtYXAgc2hhcGUgYW5kIGNsZWFyIGxlZ2VuZFxuICAgICAgICAgIGlmICgkdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCA+IDAgJiYgIWluQ3VycmVudFNlbGVjdGlvbikge1xuICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGxheWVyTmFtZSwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICAgICAgbWFwLnNldEZpbHRlcihsYXllck5hbWUsICR0aGlzLm1hcEZpbHRlcik7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IGFsbCBjaGVja2VkIGxlZ2VuZCBpdGVtc1xuICAgICAgICAgICAgJHRoaXMuc2VsZWN0ZWRJdGVtcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyR3JvdXBJbnB1dHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmNvbmZpZy5sZWdlbmRJZCkucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQ6Y2hlY2tlZCcpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlckdyb3VwSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGZpbHRlckdyb3VwSW5wdXRzW2ldLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwb3B1cC5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gcmVzZXQgYXNzb2NpYXRlZCBzdGF0ZXMgd2hlbiBwb3B1cCBkaXNtaXNzZWQgd2hpbGUgYWN0aXZlXG4gICAgICAgICAgaWYgKCR0aGlzLm1hcFBvcHVwID09PSBwb3B1cCkge1xuICAgICAgICAgICAgJHRoaXMubWFwUG9wdXAgPSBudWxsO1xuICAgICAgICAgICAgJHRoaXMubWFwRmlsdGVyID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGxlZ2VuZCBpdGVtcyBzZWxlY3RlZCwgcmVzZXQgYWxsIGZpbHRlcnNcbiAgICAgICAgICAgIGlmICghJHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbWFwLnNldEZpbHRlcihsYXllck5hbWUsIG51bGwpO1xuICAgICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJOYW1lLCAndmlzaWJpbGl0eScsICdub25lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmaWx0ZXJTaW5nbGVMYXllcihsYXllcikge1xuICAgICAgICBjb25zdCAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1hcCA9ICR0aGlzLm1hcDtcblxuICAgICAgICBtYXAub24oJ2NsaWNrJywgbGF5ZXIubmFtZSwgKGUpID0+IHtcbiAgICAgICAgICAvLyBzZXQgYmJveCBhcyByZWFjdGFuZ2xlIGFyZWEgYXJvdW5kIGNsaWNrZWQgcG9pbnRcbiAgICAgICAgICBsZXQgYmJveCA9IFtbZS5wb2ludC54LCBlLnBvaW50LnldLCBbZS5wb2ludC54LCBlLnBvaW50LnldXTtcbiAgICAgICAgICBsZXQgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGJib3gsIHsgbGF5ZXJzOiBbbGF5ZXIubmFtZV0gfSk7XG4gICAgICAgICAgbGV0IGxlZ2VuZENvbHVtblZhbHVlID0gbnVsbDtcblxuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGZlYXR1cmVzLnJlZHVjZShmdW5jdGlvbihtZW1vLCBmZWF0dXJlKSB7XG4gICAgICAgICAgICBsZWdlbmRDb2x1bW5WYWx1ZSA9IGZlYXR1cmUucHJvcGVydGllc1tsYXllci5sZWdlbmRDb2x1bW5dO1xuICAgICAgICAgICAgbWVtby5wdXNoKGZlYXR1cmUucHJvcGVydGllc1tsYXllci5maWx0ZXJCeV0pO1xuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgICAgfSwgWydpbicsIGAke2xheWVyLmZpbHRlckJ5fWBdKTtcblxuICAgICAgICAgICR0aGlzLm1hcEZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgICAkdGhpcy5pbml0aWFsaXplUG9wdXAoZSwgbGF5ZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVTaW5nbGVMYXllcihmaWx0ZXJzVG9Ub2dnbGUpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBtYXAgPSAkdGhpcy5tYXA7XG4gICAgICAgIGNvbnN0IGZpbHRlckdyb3VwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5jb25maWcubGVnZW5kSWQpO1xuXG4gICAgICAgIGNvbnN0IGxheWVyID0gJHRoaXMubGF5ZXJzWzBdO1xuICAgICAgICBjb25zdCBsZWdlbmRDb2x1bW4gPSBsYXllci5sZWdlbmRDb2x1bW47XG5cbiAgICAgICAgLy8gY2xlYXIgYWxsIGxpbmtzIGJlZm9yZSBhcHBlbmRpbmcgbmV3IG9uZXMgdG8gcHJldmVudCBkdXBsaWNhdGVzXG4gICAgICAgIHdoaWxlIChmaWx0ZXJHcm91cC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZmlsdGVyR3JvdXAucmVtb3ZlQ2hpbGQoZmlsdGVyR3JvdXAuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbml0aWxpemUgYW4gaW5wdXQgZWxlbWVudCBmb3IgZWFjaCBmaWx0ZXIgdHlwZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcnNUb1RvZ2dsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxheWVyUmVmID0gZmlsdGVyc1RvVG9nZ2xlW2ldO1xuXG4gICAgICAgICAgLy8gY2hlY2tib3hcbiAgICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgaW5wdXQudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgICAgaW5wdXQuaWQgPSBsYXllclJlZjtcbiAgICAgICAgICBpbnB1dC52YWx1ZSA9IGxheWVyUmVmO1xuICAgICAgICAgIGZpbHRlckdyb3VwLmFwcGVuZENoaWxkKGlucHV0KTtcblxuICAgICAgICAgIC8vIGNoZWNrYm94IGxhYmVsXG4gICAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgbGF5ZXJSZWYpO1xuICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBsYXllclJlZik7XG4gICAgICAgICAgbGFiZWwudGV4dENvbnRlbnQgPSBsYXllclJlZjtcbiAgICAgICAgICBmaWx0ZXJHcm91cC5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgICAgICAgICAvLyB3aGVuIHRoZSBjaGVja2JveCBjaGFuZ2VzIHN0YXRlLCB1cGRhdGUgdGhlIHNlbGVjdGVkIGl0ZW1zIGFycmF5LlxuICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBlLnRhcmdldC52YWx1ZTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGNoZWNrYm94ZXMgY2hlY2tlZCBzdGF0ZVxuICAgICAgICAgICAgZS50YXJnZXQuY2hlY2tlZCA/ICd2aXNpYmxlJyA6ICdub25lJztcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHBvcHVwIGlmIG9uZSBleGlzdHNcbiAgICAgICAgICAgIGlmICgkdGhpcy5tYXBQb3B1cClcbiAgICAgICAgICAgICAgJHRoaXMubWFwUG9wdXAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5jaGVja2VkICYmICEkdGhpcy5zZWxlY3RlZEl0ZW1zLmluY2x1ZGVzKGl0ZW0pKVxuICAgICAgICAgICAgICAkdGhpcy5zZWxlY3RlZEl0ZW1zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgICAgIGlmICghZS50YXJnZXQuY2hlY2tlZCAmJiAkdGhpcy5zZWxlY3RlZEl0ZW1zLmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICR0aGlzLnNlbGVjdGVkSXRlbXMgPSAkdGhpcy5zZWxlY3RlZEl0ZW1zLmZpbHRlcigodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCAhPT0gaXRlbTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG48L3NjcmlwdD4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1hcERhdGEgPSB7XG4gIHNpbmdsZToge1xuICAgIGxheWVyczogW10sXG4gICAgY29uZmlnOiB7XG4gICAgICBBUElLZXk6ICdway5leUoxSWpvaWJubGpieTF3Y205a2RXTjBjeUlzSW1FaU9pSmphblpqWjNZNGIySXhOWFl3TTNsMFpETjZiV040YWpBNUluMC5YU3QtaG96NXAzajJzaXlsaTBnMG9nJyxcbiAgICAgIGNvbnRhaW5lcklkOiAnbnljby1tYXAtc2wnLFxuICAgICAgbGVnZW5kSWQ6ICdueWNvLW1hcC1sZWdlbmQnLFxuICAgICAgY2VudGVyOiBbLTczLjk4NjcxMCwgNDAuNjkzMzkxXSxcbiAgICAgIHpvb206IDksXG4gICAgICBzdHlsZTogJ21hcGJveDovL3N0eWxlcy9ueWNvLXByb2R1Y3RzL2NqdjZ3anE4ODEyeXMxZ3AzOW1udnVrMncnLFxuICAgICAgbWFwVHlwZTogJ3NpbmdsZSdcbiAgICB9XG4gIH0sXG4gIG11bHRpOiB7XG4gICAgbGF5ZXJzOiBbXSxcbiAgICBjb25maWc6IHtcbiAgICAgIEFQSUtleTogJ3BrLmV5SjFJam9pYm5samJ5MXdjbTlrZFdOMGN5SXNJbUVpT2lKamFuWmpaM1k0YjJJeE5YWXdNM2wwWkRONmJXTjRhakE1SW4wLlhTdC1ob3o1cDNqMnNpeWxpMGcwb2cnLFxuICAgICAgY29udGFpbmVySWQ6ICdueWNvLW1hcC1tbCcsXG4gICAgICBsZWdlbmRJZDogJ255Y28tbWFwLW1lbnUnLFxuICAgICAgY2VudGVyOiBbLTczLjk4NjcxMCwgNDAuNjkzMzkxXSxcbiAgICAgIHpvb206IDksXG4gICAgICBzdHlsZTogJ21hcGJveDovL3N0eWxlcy9ueWNvLXByb2R1Y3RzL2NqdjZ3anE4ODEyeXMxZ3AzOW1udnVrMncnLFxuICAgICAgbWFwVHlwZTogJ211bHRpJ1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXBEYXRhOyIsIihmdW5jdGlvbihHZW9KU09OKSB7XG4gIEdlb0pTT04udmVyc2lvbiA9ICcwLjUuMCc7XG5cbiAgLy8gQWxsb3cgdXNlciB0byBzcGVjaWZ5IGRlZmF1bHQgcGFyYW1ldGVyc1xuICBHZW9KU09OLmRlZmF1bHRzID0ge1xuICAgIGRvVGhyb3dzOiB7XG4gICAgICBpbnZhbGlkR2VvbWV0cnk6IGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEludmFsaWRHZW9tZXRyeUVycm9yKCkge1xuICAgIHZhciBhcmdzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgdmFyIGl0ZW0gPSBhcmdzLnNoaWZ0KCk7XG4gICAgdmFyIHBhcmFtcyA9IGFyZ3Muc2hpZnQoKTtcblxuICAgIEVycm9yLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMubWVzc2FnZSB8fCBcIkludmFsaWQgR2VvbWV0cnk6IFwiICsgJ2l0ZW06ICcgKyBKU09OLnN0cmluZ2lmeShpdGVtKSArICcsIHBhcmFtczogJyArIEpTT04uc3RyaW5naWZ5KHBhcmFtcyk7XG4gIH1cblxuICBJbnZhbGlkR2VvbWV0cnlFcnJvci5wcm90b3R5cGUgPSBFcnJvcjtcblxuXG4gIEdlb0pTT04uZXJyb3JzID0ge1xuICAgIEludmFsaWRHZW9tZXRyeUVycm9yOiBJbnZhbGlkR2VvbWV0cnlFcnJvclxuICB9O1xuXG4gIC8vZXhwb3Npbmcgc28gdGhpcyBjYW4gYmUgb3ZlcnJpZGVuIG1heWJlIGJ5IGdlb2pzb24tdmFsaWRhdGlvbiBvciB0aGUgbGlrZVxuICBHZW9KU09OLmlzR2VvbWV0cnlWYWxpZCA9IGZ1bmN0aW9uKGdlb21ldHJ5KXtcbiAgICBpZighZ2VvbWV0cnkgfHwgIU9iamVjdC5rZXlzKGdlb21ldHJ5KS5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gISFnZW9tZXRyeS50eXBlICYmICEhZ2VvbWV0cnkuY29vcmRpbmF0ZXMgJiYgQXJyYXkuaXNBcnJheShnZW9tZXRyeS5jb29yZGluYXRlcykgJiYgISFnZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7XG4gIH07XG5cbiAgLy8gVGhlIG9uZSBhbmQgb25seSBwdWJsaWMgZnVuY3Rpb24uXG4gIC8vIENvbnZlcnRzIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIEdlb0pTT04gZmVhdHVyZSBjb2xsZWN0aW9uXG4gIEdlb0pTT04ucGFyc2UgPSBmdW5jdGlvbihvYmplY3RzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGdlb2pzb24sXG4gICAgICAgIHNldHRpbmdzID0gYXBwbHlEZWZhdWx0cyhwYXJhbXMsIHRoaXMuZGVmYXVsdHMpLFxuICAgICAgICBwcm9wRnVuYztcblxuICAgIGdlb21BdHRycy5sZW5ndGggPSAwOyAvLyBSZXNldCB0aGUgbGlzdCBvZiBnZW9tZXRyeSBmaWVsZHNcbiAgICBzZXRHZW9tKHNldHRpbmdzKTtcbiAgICBwcm9wRnVuYyA9IGdldFByb3BGdW5jdGlvbihzZXR0aW5ncyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3RzKSkge1xuICAgICAgZ2VvanNvbiA9IHtcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLCBcImZlYXR1cmVzXCI6IFtdfTtcbiAgICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgZ2VvanNvbi5mZWF0dXJlcy5wdXNoKGdldEZlYXR1cmUoe2l0ZW06aXRlbSwgcGFyYW1zOiBzZXR0aW5ncywgcHJvcEZ1bmM6cHJvcEZ1bmN9KSk7XG4gICAgICB9KTtcbiAgICAgIGFkZE9wdGlvbmFscyhnZW9qc29uLCBzZXR0aW5ncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlb2pzb24gPSBnZXRGZWF0dXJlKHtpdGVtOm9iamVjdHMsIHBhcmFtczogc2V0dGluZ3MsIHByb3BGdW5jOnByb3BGdW5jfSk7XG4gICAgICBhZGRPcHRpb25hbHMoZ2VvanNvbiwgc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrKGdlb2pzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2VvanNvbjtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uc1xuICB2YXIgZ2VvbXMgPSBbJ1BvaW50JywgJ011bHRpUG9pbnQnLCAnTGluZVN0cmluZycsICdNdWx0aUxpbmVTdHJpbmcnLCAnUG9seWdvbicsICdNdWx0aVBvbHlnb24nLCAnR2VvSlNPTiddLFxuICAgICAgZ2VvbUF0dHJzID0gW107XG5cbiAgLy8gQWRkcyBkZWZhdWx0IHNldHRpbmdzIHRvIHVzZXItc3BlY2lmaWVkIHBhcmFtc1xuICAvLyBEb2VzIG5vdCBvdmVyd3JpdGUgYW55IHNldHRpbmdzLS1vbmx5IGFkZHMgZGVmYXVsdHNcbiAgLy8gdGhlIHRoZSB1c2VyIGRpZCBub3Qgc3BlY2lmeVxuICBmdW5jdGlvbiBhcHBseURlZmF1bHRzKHBhcmFtcywgZGVmYXVsdHMpIHtcbiAgICB2YXIgc2V0dGluZ3MgPSBwYXJhbXMgfHwge307XG5cbiAgICBmb3IodmFyIHNldHRpbmcgaW4gZGVmYXVsdHMpIHtcbiAgICAgIGlmKGRlZmF1bHRzLmhhc093blByb3BlcnR5KHNldHRpbmcpICYmICFzZXR0aW5nc1tzZXR0aW5nXSkge1xuICAgICAgICBzZXR0aW5nc1tzZXR0aW5nXSA9IGRlZmF1bHRzW3NldHRpbmddO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXR0aW5ncztcbiAgfVxuXG4gIC8vIEFkZHMgdGhlIG9wdGlvbmFsIEdlb0pTT04gcHJvcGVydGllcyBjcnMgYW5kIGJib3hcbiAgLy8gaWYgdGhleSBoYXZlIGJlZW4gc3BlY2lmaWVkXG4gIGZ1bmN0aW9uIGFkZE9wdGlvbmFscyhnZW9qc29uLCBzZXR0aW5ncyl7XG4gICAgaWYoc2V0dGluZ3MuY3JzICYmIGNoZWNrQ1JTKHNldHRpbmdzLmNycykpIHtcbiAgICAgIGlmKHNldHRpbmdzLmlzUG9zdGdyZXMpXG4gICAgICAgIGdlb2pzb24uZ2VvbWV0cnkuY3JzID0gc2V0dGluZ3MuY3JzO1xuICAgICAgZWxzZVxuICAgICAgICBnZW9qc29uLmNycyA9IHNldHRpbmdzLmNycztcbiAgICB9XG4gICAgaWYgKHNldHRpbmdzLmJib3gpIHtcbiAgICAgIGdlb2pzb24uYmJveCA9IHNldHRpbmdzLmJib3g7XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5leHRyYUdsb2JhbCkge1xuICAgICAgZ2VvanNvbi5wcm9wZXJ0aWVzID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2V0dGluZ3MuZXh0cmFHbG9iYWwpIHtcbiAgICAgICAgZ2VvanNvbi5wcm9wZXJ0aWVzW2tleV0gPSBzZXR0aW5ncy5leHRyYUdsb2JhbFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHRoZSBzdHJ1Y3R1cmUgb2YgQ1JTIG9iamVjdCBpcyB2YWxpZFxuICBmdW5jdGlvbiBjaGVja0NSUyhjcnMpIHtcbiAgICBpZiAoY3JzLnR5cGUgPT09ICduYW1lJykge1xuICAgICAgICBpZiAoY3JzLnByb3BlcnRpZXMgJiYgY3JzLnByb3BlcnRpZXMubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ1JTLiBQcm9wZXJ0aWVzIG11c3QgY29udGFpbiBcIm5hbWVcIiBrZXknKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3JzLnR5cGUgPT09ICdsaW5rJykge1xuICAgICAgICBpZiAoY3JzLnByb3BlcnRpZXMgJiYgY3JzLnByb3BlcnRpZXMuaHJlZiAmJiBjcnMucHJvcGVydGllcy50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDUlMuIFByb3BlcnRpZXMgbXVzdCBjb250YWluIFwiaHJlZlwiIGFuZCBcInR5cGVcIiBrZXknKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxkIENSUy4gVHlwZSBhdHRyaWJ1dGUgbXVzdCBiZSBcIm5hbWVcIiBvciBcImxpbmtcIicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1vdmVzIHRoZSB1c2VyLXNwZWNpZmllZCBnZW9tZXRyeSBwYXJhbWV0ZXJzXG4gIC8vIHVuZGVyIHRoZSBgZ2VvbWAga2V5IGluIHBhcmFtIGZvciBlYXNpZXIgYWNjZXNzXG4gIGZ1bmN0aW9uIHNldEdlb20ocGFyYW1zKSB7XG4gICAgcGFyYW1zLmdlb20gPSB7fTtcblxuICAgIGZvcih2YXIgcGFyYW0gaW4gcGFyYW1zKSB7XG4gICAgICBpZihwYXJhbXMuaGFzT3duUHJvcGVydHkocGFyYW0pICYmIGdlb21zLmluZGV4T2YocGFyYW0pICE9PSAtMSl7XG4gICAgICAgIHBhcmFtcy5nZW9tW3BhcmFtXSA9IHBhcmFtc1twYXJhbV07XG4gICAgICAgIGRlbGV0ZSBwYXJhbXNbcGFyYW1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldEdlb21BdHRyTGlzdChwYXJhbXMuZ2VvbSk7XG4gIH1cblxuICAvLyBBZGRzIGZpZWxkcyB3aGljaCBjb250YWluIGdlb21ldHJ5IGRhdGFcbiAgLy8gdG8gZ2VvbUF0dHJzLiBUaGlzIGxpc3QgaXMgdXNlZCB3aGVuIGFkZGluZ1xuICAvLyBwcm9wZXJ0aWVzIHRvIHRoZSBmZWF0dXJlcyBzbyB0aGF0IG5vIGdlb21ldHJ5XG4gIC8vIGZpZWxkcyBhcmUgYWRkZWQgdGhlIHByb3BlcnRpZXMga2V5XG4gIGZ1bmN0aW9uIHNldEdlb21BdHRyTGlzdChwYXJhbXMpIHtcbiAgICBmb3IodmFyIHBhcmFtIGluIHBhcmFtcykge1xuICAgICAgaWYocGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtKSkge1xuICAgICAgICBpZih0eXBlb2YgcGFyYW1zW3BhcmFtXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBnZW9tQXR0cnMucHVzaChwYXJhbXNbcGFyYW1dKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zW3BhcmFtXSA9PT0gJ29iamVjdCcpIHsgLy8gQXJyYXkgb2YgY29vcmRpbmF0ZXMgZm9yIFBvaW50XG4gICAgICAgICAgZ2VvbUF0dHJzLnB1c2gocGFyYW1zW3BhcmFtXVswXSk7XG4gICAgICAgICAgZ2VvbUF0dHJzLnB1c2gocGFyYW1zW3BhcmFtXVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihnZW9tQXR0cnMubGVuZ3RoID09PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm8gZ2VvbWV0cnkgYXR0cmlidXRlcyBzcGVjaWZpZWQnKTsgfVxuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIGZlYXR1cmUgb2JqZWN0IHRvIGJlIGFkZGVkXG4gIC8vIHRvIHRoZSBHZW9KU09OIGZlYXR1cmVzIGFycmF5XG4gIGZ1bmN0aW9uIGdldEZlYXR1cmUoYXJncykge1xuICAgIHZhciBpdGVtID0gYXJncy5pdGVtLFxuICAgICAgcGFyYW1zID0gYXJncy5wYXJhbXMsXG4gICAgICBwcm9wRnVuYyA9IGFyZ3MucHJvcEZ1bmM7XG5cbiAgICB2YXIgZmVhdHVyZSA9IHsgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiIH07XG5cbiAgICBmZWF0dXJlLmdlb21ldHJ5ID0gYnVpbGRHZW9tKGl0ZW0sIHBhcmFtcyk7XG4gICAgZmVhdHVyZS5wcm9wZXJ0aWVzID0gcHJvcEZ1bmMuY2FsbChpdGVtKTtcblxuICAgIHJldHVybiBmZWF0dXJlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOZXN0ZWQodmFsKXtcbiAgICByZXR1cm4gKC9eLitcXC4uKyQvLnRlc3QodmFsKSk7XG4gIH1cblxuICAvLyBBc3NlbWJsZXMgdGhlIGBnZW9tZXRyeWAgcHJvcGVydHlcbiAgLy8gZm9yIHRoZSBmZWF0dXJlIG91dHB1dFxuICBmdW5jdGlvbiBidWlsZEdlb20oaXRlbSwgcGFyYW1zKSB7XG4gICAgdmFyIGdlb20gPSB7fSxcbiAgICAgICAgYXR0cjtcblxuICAgIGZvcih2YXIgZ3R5cGUgaW4gcGFyYW1zLmdlb20pIHtcbiAgICAgIHZhciB2YWwgPSBwYXJhbXMuZ2VvbVtndHlwZV07XG5cbiAgICAgIC8vIEdlb21ldHJ5IHBhcmFtZXRlciBzcGVjaWZpZWQgYXM6IHtQb2ludDogJ2Nvb3Jkcyd9XG4gICAgICBpZih0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiBpdGVtLmhhc093blByb3BlcnR5KHZhbCkpIHtcbiAgICAgICAgaWYoZ3R5cGUgPT09ICdHZW9KU09OJykge1xuICAgICAgICAgIGdlb20gPSBpdGVtW3ZhbF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VvbS50eXBlID0gZ3R5cGU7XG4gICAgICAgICAgZ2VvbS5jb29yZGluYXRlcyA9IGl0ZW1bdmFsXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKiBIYW5kbGUgdGhpbmdzIGxpa2U6XG4gICAgICBQb2x5Z29uOiB7XG4gICAgICAgIG5vcnRoZWFzdDogWydsYXQnLCAnbG5nJ10sXG4gICAgICAgIHNvdXRod2VzdDogWydsYXQnLCAnbG5nJ11cbiAgICAgIH1cbiAgICAgICovXG4gICAgICBlbHNlIGlmKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cbiAgICAgICAgdmFyIHBvaW50cyA9IE9iamVjdC5rZXlzKHZhbCkubWFwKGZ1bmN0aW9uKGtleSl7XG4gICAgICAgICAgdmFyIG9yZGVyID0gdmFsW2tleV07XG4gICAgICAgICAgdmFyIG5ld0l0ZW0gPSBpdGVtW2tleV07XG4gICAgICAgICAgcmV0dXJuIGJ1aWxkR2VvbShuZXdJdGVtLCB7Z2VvbTp7IFBvaW50OiBvcmRlcn19KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdlb20udHlwZSA9IGd0eXBlO1xuICAgICAgICAvKmpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICBnZW9tLmNvb3JkaW5hdGVzID0gW10uY29uY2F0KHBvaW50cy5tYXAoZnVuY3Rpb24ocCl7XG4gICAgICAgICAgcmV0dXJuIHAuY29vcmRpbmF0ZXM7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgLy8gR2VvbWV0cnkgcGFyYW1ldGVyIHNwZWNpZmllZCBhczoge1BvaW50OiBbJ2xhdCcsICdsbmcnXX1cbiAgICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheSh2YWwpICYmIGl0ZW0uaGFzT3duUHJvcGVydHkodmFsWzBdKSAmJiBpdGVtLmhhc093blByb3BlcnR5KHZhbFsxXSkpe1xuICAgICAgICBnZW9tLnR5cGUgPSBndHlwZTtcbiAgICAgICAgZ2VvbS5jb29yZGluYXRlcyA9IFtOdW1iZXIoaXRlbVt2YWxbMV1dKSwgTnVtYmVyKGl0ZW1bdmFsWzBdXSldO1xuICAgICAgfVxuXG4gICAgICAvLyBHZW9tZXRyeSBwYXJhbWV0ZXIgc3BlY2lmaWVkIGFzOiB7UG9pbnQ6IFsnY29udGFpbmVyLmxhdCcsICdjb250YWluZXIubG5nJ119XG4gICAgICBlbHNlIGlmKEFycmF5LmlzQXJyYXkodmFsKSAmJiBpc05lc3RlZCh2YWxbMF0pICYmIGlzTmVzdGVkKHZhbFsxXSkpe1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcdC8vIGkuZS4gMCBhbmQgMVxuICAgICAgICAgIHZhciBwYXRocyA9IHZhbFtpXS5zcGxpdCgnLicpO1xuICAgICAgICAgIHZhciBpdGVtQ2xvbmUgPSBpdGVtO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGF0aHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICghaXRlbUNsb25lLmhhc093blByb3BlcnR5KHBhdGhzW2pdKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtQ2xvbmUgPSBpdGVtQ2xvbmVbcGF0aHNbal1dO1x0Ly8gSXRlcmF0ZSBkZWVwZXIgaW50byB0aGUgb2JqZWN0XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvb3JkaW5hdGVzW2ldID0gaXRlbUNsb25lO1xuICAgICAgICB9XG4gICAgICAgIGdlb20udHlwZSA9IGd0eXBlO1xuICAgICAgICBnZW9tLmNvb3JkaW5hdGVzID0gW051bWJlcihjb29yZGluYXRlc1sxXSksIE51bWJlcihjb29yZGluYXRlc1swXSldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHBhcmFtcy5kb1Rocm93cyAmJiBwYXJhbXMuZG9UaHJvd3MuaW52YWxpZEdlb21ldHJ5ICYmICFHZW9KU09OLmlzR2VvbWV0cnlWYWxpZChnZW9tKSl7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEdlb21ldHJ5RXJyb3IoaXRlbSwgcGFyYW1zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2VvbTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZ1bmN0aW9uIHRvIGJlIHVzZWQgdG9cbiAgLy8gYnVpbGQgdGhlIHByb3BlcnRpZXMgb2JqZWN0IGZvciBlYWNoIGZlYXR1cmVcbiAgZnVuY3Rpb24gZ2V0UHJvcEZ1bmN0aW9uKHBhcmFtcykge1xuICAgIHZhciBmdW5jO1xuXG4gICAgaWYoIXBhcmFtcy5leGNsdWRlICYmICFwYXJhbXMuaW5jbHVkZSkge1xuICAgICAgZnVuYyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yKHZhciBhdHRyIGluIHRoaXMpIHtcbiAgICAgICAgICBpZih0aGlzLmhhc093blByb3BlcnR5KGF0dHIpICYmIChnZW9tQXR0cnMuaW5kZXhPZihhdHRyKSA9PT0gLTEpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzW2F0dHJdID0gdGhpc1thdHRyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKHBhcmFtcy5pbmNsdWRlKSB7XG4gICAgICBmdW5jID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICBwYXJhbXMuaW5jbHVkZS5mb3JFYWNoKGZ1bmN0aW9uKGF0dHIpe1xuICAgICAgICAgIHByb3BlcnRpZXNbYXR0cl0gPSB0aGlzW2F0dHJdO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKHBhcmFtcy5leGNsdWRlKSB7XG4gICAgICBmdW5jID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICBmb3IodmFyIGF0dHIgaW4gdGhpcykge1xuICAgICAgICAgIGlmKHRoaXMuaGFzT3duUHJvcGVydHkoYXR0cikgJiYgKGdlb21BdHRycy5pbmRleE9mKGF0dHIpID09PSAtMSkgJiYgKHBhcmFtcy5leGNsdWRlLmluZGV4T2YoYXR0cikgPT09IC0xKSkge1xuICAgICAgICAgICAgcHJvcGVydGllc1thdHRyXSA9IHRoaXNbYXR0cl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG5cbiAgICAgIGZ1bmMuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzKTtcblxuICAgICAgaWYocGFyYW1zLmV4dHJhKSB7IGFkZEV4dHJhKHByb3BlcnRpZXMsIHBhcmFtcy5leHRyYSk7IH1cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH07XG4gIH1cblxuICAvLyBBZGRzIGRhdGEgY29udGFpbmVkIGluIHRoZSBgZXh0cmFgXG4gIC8vIHBhcmFtZXRlciBpZiBpdCBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgZnVuY3Rpb24gYWRkRXh0cmEocHJvcGVydGllcywgZXh0cmEpIHtcbiAgICBmb3IodmFyIGtleSBpbiBleHRyYSl7XG4gICAgICBpZihleHRyYS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHByb3BlcnRpZXNba2V5XSA9IGV4dHJhW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gIH1cblxufSh0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnID8gbW9kdWxlLmV4cG9ydHMgOiB3aW5kb3cuR2VvSlNPTiA9IHt9KSk7XG4iLCJtb2R1bGUuZXhwb3J0cy5SQURJVVMgPSA2Mzc4MTM3O1xubW9kdWxlLmV4cG9ydHMuRkxBVFRFTklORyA9IDEvMjk4LjI1NzIyMzU2Mztcbm1vZHVsZS5leHBvcnRzLlBPTEFSX1JBRElVUyA9IDYzNTY3NTIuMzE0MjtcbiIsInZhciB3Z3M4NCA9IHJlcXVpcmUoJ3dnczg0Jyk7XG5cbm1vZHVsZS5leHBvcnRzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5tb2R1bGUuZXhwb3J0cy5yaW5nID0gcmluZ0FyZWE7XG5cbmZ1bmN0aW9uIGdlb21ldHJ5KF8pIHtcbiAgICB2YXIgYXJlYSA9IDAsIGk7XG4gICAgc3dpdGNoIChfLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbkFyZWEoXy5jb29yZGluYXRlcyk7XG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgXy5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZWEgKz0gcG9seWdvbkFyZWEoXy5jb29yZGluYXRlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJlYTtcbiAgICAgICAgY2FzZSAnUG9pbnQnOlxuICAgICAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfLmdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmVhICs9IGdlb21ldHJ5KF8uZ2VvbWV0cmllc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJlYTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvbHlnb25BcmVhKGNvb3Jkcykge1xuICAgIHZhciBhcmVhID0gMDtcbiAgICBpZiAoY29vcmRzICYmIGNvb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFyZWEgKz0gTWF0aC5hYnMocmluZ0FyZWEoY29vcmRzWzBdKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmVhIC09IE1hdGguYWJzKHJpbmdBcmVhKGNvb3Jkc1tpXSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmVhO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgYXBwcm94aW1hdGUgYXJlYSBvZiB0aGUgcG9seWdvbiB3ZXJlIGl0IHByb2plY3RlZCBvbnRvXG4gKiAgICAgdGhlIGVhcnRoLiAgTm90ZSB0aGF0IHRoaXMgYXJlYSB3aWxsIGJlIHBvc2l0aXZlIGlmIHJpbmcgaXMgb3JpZW50ZWRcbiAqICAgICBjbG9ja3dpc2UsIG90aGVyd2lzZSBpdCB3aWxsIGJlIG5lZ2F0aXZlLlxuICpcbiAqIFJlZmVyZW5jZTpcbiAqIFJvYmVydC4gRy4gQ2hhbWJlcmxhaW4gYW5kIFdpbGxpYW0gSC4gRHVxdWV0dGUsIFwiU29tZSBBbGdvcml0aG1zIGZvclxuICogICAgIFBvbHlnb25zIG9uIGEgU3BoZXJlXCIsIEpQTCBQdWJsaWNhdGlvbiAwNy0wMywgSmV0IFByb3B1bHNpb25cbiAqICAgICBMYWJvcmF0b3J5LCBQYXNhZGVuYSwgQ0EsIEp1bmUgMjAwNyBodHRwOi8vdHJzLW5ldy5qcGwubmFzYS5nb3YvZHNwYWNlL2hhbmRsZS8yMDE0LzQwNDA5XG4gKlxuICogUmV0dXJuczpcbiAqIHtmbG9hdH0gVGhlIGFwcHJveGltYXRlIHNpZ25lZCBnZW9kZXNpYyBhcmVhIG9mIHRoZSBwb2x5Z29uIGluIHNxdWFyZVxuICogICAgIG1ldGVycy5cbiAqL1xuXG5mdW5jdGlvbiByaW5nQXJlYShjb29yZHMpIHtcbiAgICB2YXIgcDEsIHAyLCBwMywgbG93ZXJJbmRleCwgbWlkZGxlSW5kZXgsIHVwcGVySW5kZXgsIGksXG4gICAgYXJlYSA9IDAsXG4gICAgY29vcmRzTGVuZ3RoID0gY29vcmRzLmxlbmd0aDtcblxuICAgIGlmIChjb29yZHNMZW5ndGggPiAyKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29yZHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPT09IGNvb3Jkc0xlbmd0aCAtIDIpIHsvLyBpID0gTi0yXG4gICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGNvb3Jkc0xlbmd0aCAtIDI7XG4gICAgICAgICAgICAgICAgbWlkZGxlSW5kZXggPSBjb29yZHNMZW5ndGggLTE7XG4gICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGNvb3Jkc0xlbmd0aCAtIDEpIHsvLyBpID0gTi0xXG4gICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGNvb3Jkc0xlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgbWlkZGxlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gaSA9IDAgdG8gTi0zXG4gICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgbWlkZGxlSW5kZXggPSBpKzE7XG4gICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IGkrMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAxID0gY29vcmRzW2xvd2VySW5kZXhdO1xuICAgICAgICAgICAgcDIgPSBjb29yZHNbbWlkZGxlSW5kZXhdO1xuICAgICAgICAgICAgcDMgPSBjb29yZHNbdXBwZXJJbmRleF07XG4gICAgICAgICAgICBhcmVhICs9ICggcmFkKHAzWzBdKSAtIHJhZChwMVswXSkgKSAqIE1hdGguc2luKCByYWQocDJbMV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZWEgPSBhcmVhICogd2dzODQuUkFESVVTICogd2dzODQuUkFESVVTIC8gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJlYTtcbn1cblxuZnVuY3Rpb24gcmFkKF8pIHtcbiAgICByZXR1cm4gXyAqIE1hdGguUEkgLyAxODA7XG59IiwidmFyIGdlb2pzb25BcmVhID0gcmVxdWlyZSgnQG1hcGJveC9nZW9qc29uLWFyZWEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXdpbmQ7XG5cbmZ1bmN0aW9uIHJld2luZChnaiwgb3V0ZXIpIHtcbiAgICBzd2l0Y2ggKChnaiAmJiBnai50eXBlKSB8fCBudWxsKSB7XG4gICAgICAgIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIGdqLmZlYXR1cmVzID0gZ2ouZmVhdHVyZXMubWFwKGN1cnJ5T3V0ZXIocmV3aW5kLCBvdXRlcikpO1xuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgICAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgICAgICAgIGdqLmdlb21ldHJ5ID0gcmV3aW5kKGdqLmdlb21ldHJ5LCBvdXRlcik7XG4gICAgICAgICAgICByZXR1cm4gZ2o7XG4gICAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgcmV0dXJuIGNvcnJlY3QoZ2osIG91dGVyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGN1cnJ5T3V0ZXIoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbihfKSB7IHJldHVybiBhKF8sIGIpOyB9O1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0KF8sIG91dGVyKSB7XG4gICAgaWYgKF8udHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIF8uY29vcmRpbmF0ZXMgPSBjb3JyZWN0UmluZ3MoXy5jb29yZGluYXRlcywgb3V0ZXIpO1xuICAgIH0gZWxzZSBpZiAoXy50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICBfLmNvb3JkaW5hdGVzID0gXy5jb29yZGluYXRlcy5tYXAoY3VycnlPdXRlcihjb3JyZWN0UmluZ3MsIG91dGVyKSk7XG4gICAgfVxuICAgIHJldHVybiBfO1xufVxuXG5mdW5jdGlvbiBjb3JyZWN0UmluZ3MoXywgb3V0ZXIpIHtcbiAgICBvdXRlciA9ICEhb3V0ZXI7XG4gICAgX1swXSA9IHdpbmQoX1swXSwgb3V0ZXIpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgXy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfW2ldID0gd2luZChfW2ldLCAhb3V0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gXztcbn1cblxuZnVuY3Rpb24gd2luZChfLCBkaXIpIHtcbiAgICByZXR1cm4gY3coXykgPT09IGRpciA/IF8gOiBfLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gY3coXykge1xuICAgIHJldHVybiBnZW9qc29uQXJlYS5yaW5nKF8pID49IDA7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBWdWUgZnJvbSAndnVlL2Rpc3QvdnVlLmVzbS5icm93c2VyJztcbmltcG9ydCBNYXBDb21wb25lbnQgZnJvbSAnLi4vb2JqZWN0cy9tYXAvbWFwLnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBNYXBEYXRhIGZyb20gJy4vbWFwLmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcbmltcG9ydCBHZW9KU09OIGZyb20gJ2dlb2pzb24nO1xuaW1wb3J0IHJld2luZCBmcm9tICdnZW9qc29uLXJld2luZCc7XG5cbmNsYXNzIE1hcE11bHRpTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoJ255Y28tbWFwLW1sJywgTWFwQ29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6ICdbZGF0YS1qcz1cIm55Y28tbWFwLW1sXCJdJyxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsYXllcnM6IE1hcERhdGEubXVsdGkubGF5ZXJzLFxuICAgICAgICAgIGNvbmZpZzogTWFwRGF0YS5tdWx0aS5jb25maWcsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLmdldFppcGNvZGVEYXRhKCk7XG4gICAgICAgIHRoaXMuZ2V0Qm9yb3VnaERhdGEoKTtcbiAgICAgICAgdGhpcy5nZXROZWlnaGJvcmhvb2REYXRhKCk7XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBnZXRaaXBjb2RlRGF0YSgpIHtcbiAgICAgICAgICBmZXRjaCgnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2tpbXBlbmd1aW4vZ2VvSlNPTkBtYXN0ZXIvdGlnZXItemN0YS5nZW9qc29uJylcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIE1hcERhdGEubXVsdGkubGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd6aXBjb2RlcycsXG4gICAgICAgICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShkYXRhKSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGZpbHRlckJ5OiAnR0VPSUQxMCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Qm9yb3VnaERhdGEoKSB7XG4gICAgICAgICAgZmV0Y2goJ2h0dHBzOi8vZGF0YS5jaXR5b2ZuZXd5b3JrLnVzL3Jlc291cmNlLzd0M2IteXd2dy5qc29uJylcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgICAgICAgICAgIE1hcERhdGEubXVsdGkubGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdib3JvdWdocycsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5jb252ZXJ0VG9HZW9KU09OKGRhdGEpLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpbHRlckJ5OiAnYm9yb19uYW1lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXROZWlnaGJvcmhvb2REYXRhKCkge1xuICAgICAgICAgIGZldGNoKCdodHRwczovL2RhdGEuY2l0eW9mbmV3eW9yay51cy9yZXNvdXJjZS9xMno1LWFpMzguanNvbicpXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKGVycm9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgICAgICAgICAgICBNYXBEYXRhLm11bHRpLmxheWVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbmVpZ2hib3Job29kcycsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5jb252ZXJ0VG9HZW9KU09OKGRhdGEpLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpbHRlckJ5OiAnbnRhbmFtZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydFRvR2VvSlNPTihqc29uRGF0YSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBnZW9qc29uIHNhdGlzZmllcyByaWdodC1oYW5kIHJ1bGVcbiAgICAgICAgICBjb25zdCBkYXRhID0gcmV3aW5kKEdlb0pTT04ucGFyc2UoanNvbkRhdGEsIHtHZW9KU09OOiAndGhlX2dlb20nfSkpO1xuXG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cbmNsYXNzIE1hcFNpbmdsZUxheWVyIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KCdueWNvLW1hcC1zbCcsIE1hcENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiAnW2RhdGEtanM9XCJueWNvLW1hcC1zbFwiXScsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGF5ZXJzOiBNYXBEYXRhLnNpbmdsZS5sYXllcnMsXG4gICAgICAgICAgY29uZmlnOiBNYXBEYXRhLnNpbmdsZS5jb25maWcsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLmdldERhdGEoKTtcbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldERhdGEoKSB7XG4gICAgICAgICAgZmV0Y2goJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9raW1wZW5ndWluL2dlb0pTT05AbWFzdGVyL255Y28tbnljX3ppcGNvZGVzLmdlb2pzb24nKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihlcnJvcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgTWFwRGF0YS5zaW5nbGUubGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdueWNvLW55Y196aXBjb2RlcycsXG4gICAgICAgICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShkYXRhKSxcbiAgICAgICAgICAgICAgICBmaWx0ZXJCeTogJ1pDVEE1Q0UxMCcsXG4gICAgICAgICAgICAgICAgbGVnZW5kQ29sdW1uOiAnQk9STydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgTWFwTXVsdGlMYXllcixcbiAgTWFwU2luZ2xlTGF5ZXJcbn0iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBJY29ucyBmcm9tICcuLi9lbGVtZW50cy9pY29ucy9JY29ucyc7XG5pbXBvcnQgRmVlZCBmcm9tICcuLi9vYmplY3RzL2ZlZWQvRmVlZCc7XG5pbXBvcnQgVG9nZ2xlIGZyb20gJy4uL3V0aWxpdGllcy90b2dnbGUvVG9nZ2xlJztcbmltcG9ydCBUcmFjayBmcm9tICcuLi91dGlsaXRpZXMvdHJhY2svVHJhY2snO1xuaW1wb3J0IFNlbGVjdCBmcm9tICcuLi9lbGVtZW50cy9zZWxlY3Qvc2VsZWN0JztcbmltcG9ydCBDaGFydEJhciBmcm9tICcuLi9vYmplY3RzL2NoYXJ0cy9jaGFydC0tYmFyJztcbmltcG9ydCBDaGFydEhvcml6b250YWxCYXIgZnJvbSAnLi4vb2JqZWN0cy9jaGFydHMvY2hhcnQtLWhvcml6b250YWwtYmFyJztcbmltcG9ydCBDaGFydExpbmUgZnJvbSAnLi4vb2JqZWN0cy9jaGFydHMvY2hhcnQtLWxpbmUnO1xuaW1wb3J0IENoYXJ0UGllIGZyb20gJy4uL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1waWUnO1xuaW1wb3J0IHsgTWFwTXVsdGlMYXllciwgTWFwU2luZ2xlTGF5ZXIgfSBmcm9tICcuL01hcCc7XG4vKiogaW1wb3J0IG1vZHVsZXMgaGVyZSBhcyB0aGV5IGFyZSB3cml0dGVuICovXG5cbi8qKlxuICogTWV0aG9kcyBmb3IgdGhlIGdsb2JhbCBOeWNvUGF0dGVybnMgaW5zdGFuY2VcbiAqL1xuY2xhc3MgbnljbyB7XG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBJY29ucyBFbGVtZW50XG4gICAqIEBwYXJhbSAge1N0cmluZ30gcGF0aCAgVGhlIHBhdGggb2YgdGhlIGljb24gZmlsZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIEljb25zIGluc3RhbmNlXG4gICAqL1xuICBpY29ucyhwYXRoKSB7XG4gICAgcmV0dXJuIG5ldyBJY29ucyhwYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBGZWVkIE9iamVjdFxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgc2V0dGluZ3MgIFNldHRpbmcgZm9yIHRoZSBmZWVkXG4gICAqIEByZXR1cm4gIHtPYmplY3R9ICAgICAgICAgICAgRmVlZCBpbnN0YW5jZVxuICAgKi9cbiAgZmVlZChzZXR0aW5ncykge1xuICAgIHJldHVybiBuZXcgRmVlZChzZXR0aW5ncyk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgVG9nZ2xlIFV0aWxpdHlcbiAgICogQHJldHVybiAge09iamVjdH0gVG9nZ2xlIGluc3RhbmNlXG4gICAqL1xuICB0b2dnbGUoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IFRvZ2dsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgdGhlIFRyYWNrIE1vZHVsZVxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSBUcmFjayBNb2R1bGVcbiAgICovXG4gIHRyYWNrKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFjaygpO1xuICB9XG5cbiAgc2VsZWN0KCkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0KCk7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgdGhlIENoYXJ0IE9iamVjdHNcbiAgICogQHJldHVybiAge09iamVjdH0gQ2hhcnQgaW5zdGFuY2VcbiAgICovXG4gIGNoYXJ0KHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ2JhcicpXG4gICAgICByZXR1cm4gbmV3IENoYXJ0QmFyKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2hvcml6b250YWxCYXInKVxuICAgICAgcmV0dXJuIG5ldyBDaGFydEhvcml6b250YWxCYXIoKTtcblxuICAgIGlmICh0eXBlID09PSAnbGluZScpXG4gICAgICByZXR1cm4gbmV3IENoYXJ0TGluZSgpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdwaWUnKVxuICAgICAgcmV0dXJuIG5ldyBDaGFydFBpZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgdGhlIE1hcCBNb2R1bGVcbiAgICogQHJldHVybiAge09iamVjdH0gTWFwIE1vZHVsZVxuICAgKi9cbiAgbWFwKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ211bHRpJylcbiAgICAgIHJldHVybiBuZXcgTWFwTXVsdGlMYXllcigpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzaW5nbGUnKVxuICAgICAgcmV0dXJuIG5ldyBNYXBTaW5nbGVMYXllcigpO1xuICB9XG5cbiAgLyoqIGFkZCBBUElzIGhlcmUgYXMgdGhleSBhcmUgd3JpdHRlbiAqL1xufVxuXG5leHBvcnQgZGVmYXVsdCBueWNvO1xuIl0sIm5hbWVzIjpbIlV0aWxpdHkiLCJkZWJ1ZyIsImdldFVybFBhcmFtZXRlciIsIlBBUkFNUyIsIkRFQlVHIiwibmFtZSIsInF1ZXJ5U3RyaW5nIiwicXVlcnkiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInNlYXJjaCIsImNvbnN0IiwicGFyYW0iLCJyZXBsYWNlIiwicmVnZXgiLCJSZWdFeHAiLCJyZXN1bHRzIiwiZXhlYyIsImRlY29kZVVSSUNvbXBvbmVudCIsImxvY2FsaXplIiwic2x1ZyIsInRleHQiLCJsZXQiLCJzdHJpbmdzIiwiTE9DQUxJWkVEX1NUUklOR1MiLCJtYXRjaCIsImZpbHRlciIsInMiLCJoYXNPd25Qcm9wZXJ0eSIsImxhYmVsIiwiU0VMRUNUT1JTIiwicGFyc2VNYXJrZG93biIsIkljb25zIiwicGF0aCIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwib2siLCJjb25zb2xlIiwiZGlyIiwiY2F0Y2giLCJlcnJvciIsImRhdGEiLCJzcHJpdGUiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJzZXRBdHRyaWJ1dGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiT2JqZWN0IiwiZnJlZVNlbGYiLCJzZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiU3ltYm9sIiwib2JqZWN0UHJvdG8iLCJwcm90b3R5cGUiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsInVuZGVmaW5lZCIsImdldFJhd1RhZyIsInZhbHVlIiwiaXNPd24iLCJjYWxsIiwidGFnIiwidW5tYXNrZWQiLCJlIiwicmVzdWx0Iiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0IiwidHlwZSIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsImNvcmVKc0RhdGEiLCJtYXNrU3JjS2V5IiwidWlkIiwia2V5cyIsIklFX1BST1RPIiwiaXNNYXNrZWQiLCJmdW5jIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwidG9Tb3VyY2UiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJyZUlzTmF0aXZlIiwiYmFzZUlzTmF0aXZlIiwicGF0dGVybiIsInRlc3QiLCJnZXRWYWx1ZSIsIm9iamVjdCIsImtleSIsImdldE5hdGl2ZSIsImRlZmluZVByb3BlcnR5IiwiYmFzZUFzc2lnblZhbHVlIiwiZXEiLCJvdGhlciIsImFzc2lnblZhbHVlIiwib2JqVmFsdWUiLCJjb3B5T2JqZWN0Iiwic291cmNlIiwicHJvcHMiLCJjdXN0b21pemVyIiwiaXNOZXciLCJpbmRleCIsImxlbmd0aCIsIm5ld1ZhbHVlIiwiaWRlbnRpdHkiLCJhcHBseSIsInRoaXNBcmciLCJhcmdzIiwibmF0aXZlTWF4IiwiTWF0aCIsIm1heCIsIm92ZXJSZXN0Iiwic3RhcnQiLCJ0cmFuc2Zvcm0iLCJhcmd1bWVudHMiLCJhcnJheSIsIkFycmF5Iiwib3RoZXJBcmdzIiwiY29uc3RhbnQiLCJiYXNlU2V0VG9TdHJpbmciLCJzdHJpbmciLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIm5hdGl2ZU5vdyIsIkRhdGUiLCJub3ciLCJzaG9ydE91dCIsImNvdW50IiwibGFzdENhbGxlZCIsInN0YW1wIiwicmVtYWluaW5nIiwic2V0VG9TdHJpbmciLCJiYXNlUmVzdCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJpc0xlbmd0aCIsImlzQXJyYXlMaWtlIiwicmVJc1VpbnQiLCJpc0luZGV4IiwiaXNJdGVyYXRlZUNhbGwiLCJjcmVhdGVBc3NpZ25lciIsImFzc2lnbmVyIiwic291cmNlcyIsImd1YXJkIiwiYmFzZVRpbWVzIiwibiIsIml0ZXJhdGVlIiwiaXNPYmplY3RMaWtlIiwiYXJnc1RhZyIsImJhc2VJc0FyZ3VtZW50cyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMiLCJpc0FycmF5Iiwic3R1YkZhbHNlIiwiZnJlZUV4cG9ydHMiLCJleHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VVbmFyeSIsImZyZWVQcm9jZXNzIiwicHJvY2VzcyIsIm5vZGVVdGlsIiwidHlwZXMiLCJyZXF1aXJlIiwiYmluZGluZyIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiU3RyaW5nIiwicHVzaCIsImlzUHJvdG90eXBlIiwiQ3RvciIsImNvbnN0cnVjdG9yIiwicHJvdG8iLCJuYXRpdmVLZXlzSW4iLCJiYXNlS2V5c0luIiwiaXNQcm90byIsImtleXNJbiIsImFzc2lnbkluV2l0aCIsInNyY0luZGV4Iiwib3ZlckFyZyIsImFyZyIsImdldFByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwib2JqZWN0Q3RvclN0cmluZyIsImlzUGxhaW5PYmplY3QiLCJkb21FeGNUYWciLCJpc0Vycm9yIiwibWVzc2FnZSIsImF0dGVtcHQiLCJFcnJvciIsImFycmF5TWFwIiwiYmFzZVZhbHVlcyIsImN1c3RvbURlZmF1bHRzQXNzaWduSW4iLCJzcmNWYWx1ZSIsInN0cmluZ0VzY2FwZXMiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwibmF0aXZlS2V5cyIsImJhc2VLZXlzIiwicmVJbnRlcnBvbGF0ZSIsImJhc2VQcm9wZXJ0eU9mIiwiaHRtbEVzY2FwZXMiLCJlc2NhcGVIdG1sQ2hhciIsInN5bWJvbFRhZyIsImlzU3ltYm9sIiwiSU5GSU5JVFkiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nIiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNVbmVzY2FwZWRIdG1sIiwiZXNjYXBlIiwicmVFc2NhcGUiLCJyZUV2YWx1YXRlIiwidGVtcGxhdGVTZXR0aW5ncyIsInJlRW1wdHlTdHJpbmdMZWFkaW5nIiwicmVFbXB0eVN0cmluZ01pZGRsZSIsInJlRW1wdHlTdHJpbmdUcmFpbGluZyIsInJlRXNUZW1wbGF0ZSIsInJlTm9NYXRjaCIsInJlVW5lc2NhcGVkU3RyaW5nIiwidGVtcGxhdGUiLCJvcHRpb25zIiwic2V0dGluZ3MiLCJpbXBvcnRzIiwiXyIsImltcG9ydHNLZXlzIiwiaW1wb3J0c1ZhbHVlcyIsImlzRXNjYXBpbmciLCJpc0V2YWx1YXRpbmciLCJpbnRlcnBvbGF0ZSIsInJlRGVsaW1pdGVycyIsImV2YWx1YXRlIiwic291cmNlVVJMIiwiZXNjYXBlVmFsdWUiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZXNUZW1wbGF0ZVZhbHVlIiwiZXZhbHVhdGVWYWx1ZSIsIm9mZnNldCIsInNsaWNlIiwidmFyaWFibGUiLCJhcnJheUVhY2giLCJjcmVhdGVCYXNlRm9yIiwiZnJvbVJpZ2h0Iiwia2V5c0Z1bmMiLCJpdGVyYWJsZSIsImJhc2VGb3IiLCJiYXNlRm9yT3duIiwiY3JlYXRlQmFzZUVhY2giLCJlYWNoRnVuYyIsImNvbGxlY3Rpb24iLCJiYXNlRWFjaCIsImNhc3RGdW5jdGlvbiIsImZvckVhY2giLCJsaXN0Q2FjaGVDbGVhciIsIl9fZGF0YV9fIiwic2l6ZSIsImFzc29jSW5kZXhPZiIsImFycmF5UHJvdG8iLCJzcGxpY2UiLCJsaXN0Q2FjaGVEZWxldGUiLCJsYXN0SW5kZXgiLCJwb3AiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJlbnRyaWVzIiwiY2xlYXIiLCJlbnRyeSIsInNldCIsImdldCIsImhhcyIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJNYXAiLCJuYXRpdmVDcmVhdGUiLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiSEFTSF9VTkRFRklORUQiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJIYXNoIiwibWFwQ2FjaGVDbGVhciIsImlzS2V5YWJsZSIsImdldE1hcERhdGEiLCJtYXAiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiTEFSR0VfQVJSQVlfU0laRSIsInN0YWNrU2V0IiwicGFpcnMiLCJTdGFjayIsImFzc2lnbk1lcmdlVmFsdWUiLCJhbGxvY1Vuc2FmZSIsImNsb25lQnVmZmVyIiwiYnVmZmVyIiwiaXNEZWVwIiwiY29weSIsIlVpbnQ4QXJyYXkiLCJjbG9uZUFycmF5QnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiY2xvbmVUeXBlZEFycmF5IiwidHlwZWRBcnJheSIsImJ5dGVPZmZzZXQiLCJjb3B5QXJyYXkiLCJvYmplY3RDcmVhdGUiLCJjcmVhdGUiLCJiYXNlQ3JlYXRlIiwiaW5pdENsb25lT2JqZWN0IiwiaXNBcnJheUxpa2VPYmplY3QiLCJzYWZlR2V0IiwidG9QbGFpbk9iamVjdCIsImJhc2VNZXJnZURlZXAiLCJtZXJnZUZ1bmMiLCJzdGFjayIsInN0YWNrZWQiLCJpc0NvbW1vbiIsImlzVHlwZWQiLCJiYXNlTWVyZ2UiLCJtZXJnZSIsInZhbHVlcyIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJTZXRDYWNoZSIsImFkZCIsImFycmF5U29tZSIsInByZWRpY2F0ZSIsImNhY2hlSGFzIiwiY2FjaGUiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJlcXVhbEFycmF5cyIsImJpdG1hc2siLCJlcXVhbEZ1bmMiLCJpc1BhcnRpYWwiLCJhcnJMZW5ndGgiLCJvdGhMZW5ndGgiLCJzZWVuIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJtYXBUb0FycmF5Iiwic2V0VG9BcnJheSIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwiZXF1YWxCeVRhZyIsImNvbnZlcnQiLCJhcnJheVB1c2giLCJiYXNlR2V0QWxsS2V5cyIsInN5bWJvbHNGdW5jIiwiYXJyYXlGaWx0ZXIiLCJyZXNJbmRleCIsInN0dWJBcnJheSIsIm5hdGl2ZUdldFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRTeW1ib2xzIiwic3ltYm9sIiwiZ2V0QWxsS2V5cyIsImVxdWFsT2JqZWN0cyIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiRGF0YVZpZXciLCJQcm9taXNlIiwiU2V0IiwiV2Vha01hcCIsInByb21pc2VUYWciLCJkYXRhVmlld0N0b3JTdHJpbmciLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJnZXRUYWciLCJBcnJheUJ1ZmZlciIsInJlc29sdmUiLCJjdG9yU3RyaW5nIiwiYmFzZUlzRXF1YWxEZWVwIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJvYmpJc1dyYXBwZWQiLCJvdGhJc1dyYXBwZWQiLCJvYmpVbndyYXBwZWQiLCJvdGhVbndyYXBwZWQiLCJiYXNlSXNFcXVhbCIsImJhc2VJc01hdGNoIiwibWF0Y2hEYXRhIiwibm9DdXN0b21pemVyIiwiaXNTdHJpY3RDb21wYXJhYmxlIiwiZ2V0TWF0Y2hEYXRhIiwibWF0Y2hlc1N0cmljdENvbXBhcmFibGUiLCJiYXNlTWF0Y2hlcyIsInJlSXNEZWVwUHJvcCIsInJlSXNQbGFpblByb3AiLCJpc0tleSIsIkZVTkNfRVJST1JfVEVYVCIsIm1lbW9pemUiLCJyZXNvbHZlciIsIlR5cGVFcnJvciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJNQVhfTUVNT0laRV9TSVpFIiwibWVtb2l6ZUNhcHBlZCIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJzdHJpbmdUb1BhdGgiLCJjaGFyQ29kZUF0IiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJjYXN0UGF0aCIsInRvS2V5IiwiYmFzZUdldCIsImRlZmF1bHRWYWx1ZSIsImJhc2VIYXNJbiIsImhhc1BhdGgiLCJoYXNGdW5jIiwiaGFzSW4iLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZVByb3BlcnR5IiwiYmFzZVByb3BlcnR5RGVlcCIsInByb3BlcnR5IiwiYmFzZUl0ZXJhdGVlIiwiYmFzZU1hcCIsImJhc2VTb3J0QnkiLCJjb21wYXJlciIsInNvcnQiLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNOdWxsIiwidmFsSXNSZWZsZXhpdmUiLCJ2YWxJc1N5bWJvbCIsIm90aElzRGVmaW5lZCIsIm90aElzTnVsbCIsIm90aElzUmVmbGV4aXZlIiwib3RoSXNTeW1ib2wiLCJjb21wYXJlTXVsdGlwbGUiLCJvcmRlcnMiLCJvYmpDcml0ZXJpYSIsImNyaXRlcmlhIiwib3RoQ3JpdGVyaWEiLCJvcmRlcnNMZW5ndGgiLCJvcmRlciIsImJhc2VPcmRlckJ5IiwiaXRlcmF0ZWVzIiwib3JkZXJCeSIsIm5vb3AiLCJjcmVhdGVTZXQiLCJGZWVkIiwiY29uZmlnIiwiZGVmYXVsdCIsIl9zZXR0aW5ncyIsIl9tZXJnZSIsImluaXQiLCJmZWVkIiwicnNzVG9Kc29uIiwicnNzVXJsIiwiX2ZvckVhY2giLCJ1cmwiLCJ0aGlzIiwiX3JlcXVlc3QiLCJfcHJvY2VzcyIsIkpTT04iLCJwYXJzZSIsInRoaXMkMSIsImNvbXBpbGVkIiwiX3JlbmRlciIsImVsIiwicXVlcnlTZWxlY3RvciIsInNlbGVjdG9yIiwicmVqZWN0IiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJldmVudCIsIl94aHIiLCJ0YXJnZXQiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwib250aW1lb3V0Iiwib3BlbiIsInNlbmQiLCJsb2ciLCJfdmFsdWVzIiwidGVtcGxhdGVzIiwiam9pbiIsIl90ZW1wbGF0ZSIsIm1lZGl1bSIsIm9wZW5lciIsImhlYWRlciIsInBvc3RzIiwiY2xvc2VyIiwicG9zdEV4Y2VycHRMZW5ndGgiLCJpdGVtcyIsInBvc3QiLCJleGNlcnB0IiwiZGF0ZSIsImRlc2NyaXB0aW9uIiwic3Vic3RyIiwibWluIiwibGFzdEluZGV4T2YiLCJwdWJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwicG9zdERhdGVMb2NhbCIsInBvc3REYXRlRm9ybWF0IiwibWVyZ2VkIiwiY29uY2F0IiwiX29yZGVyQnkiLCJ0aXRsZSIsInRpdGxlVXJsIiwicHJvZmlsZUltZyIsImZvbnRTaXplIiwicmF0aW9Qcm9maWxlIiwicG9zdEJvcmRlckNvbG9yIiwicG9zdEltZ0hlaWdodCIsInBvc3RFeGNlcnB0VHJhaWwiLCJwb3N0Q3RhVGV4dCIsInllYXIiLCJtb250aCIsImRheSIsInBvc3REYXRlVGl0bGUiLCJjbGFzc2VzIiwid3JhcHBlciIsImZlZWRJdGVtIiwibGluayIsInRodW1ibmFpbCIsIml0ZW1Gb290ZXIiLCJjdGEiLCJ1bmlxdWUiLCJUb2dnbGUiLCJuYW1lc3BhY2UiLCJpbmFjdGl2ZUNsYXNzIiwiYWN0aXZlQ2xhc3MiLCJhZGRFdmVudExpc3RlbmVyIiwibWF0Y2hlcyIsInByZXZlbnREZWZhdWx0IiwiX3RvZ2dsZSIsImdldEF0dHJpYnV0ZSIsImVsZW1lbnRUb2dnbGUiLCJkYXRhc2V0IiwidW5kbyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJpIiwiZWxBcmlhUm9sZXMiLCJ0YXJnZXRBcmlhUm9sZXMiLCJjb250YWlucyIsImhhc2giLCJUcmFjayIsInRyYWNrS2V5IiwidHJhY2tEYXRhIiwiY2xpY2siLCJkIiwicGF0aG5hbWUiLCJ3dCIsIndlYnRyZW5kcyIsImdhIiwiZ3RhZyIsInZpZXciLCJhcHAiLCJndGFnVmlldyIsImFzc2lnbiIsInd0ZCIsImFyZ3NhIiwiZmxhdE1hcCIsImsiLCJXZWJ0cmVuZHMiLCJtdWx0aVRyYWNrIiwidXJpIiwiZmluZCIsImVsZW1lbnQiLCJhcHBfbmFtZSIsInNjcmVlbl9uYW1lIiwiZW1wdHlPYmplY3QiLCJmcmVlemUiLCJpc1VuZGVmIiwidiIsImlzRGVmIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzUHJpbWl0aXZlIiwib2JqIiwiX3RvU3RyaW5nIiwidG9SYXdUeXBlIiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsInBhcnNlRmxvYXQiLCJmbG9vciIsImlzRmluaXRlIiwiaXNQcm9taXNlIiwic3RyaW5naWZ5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibGlzdCIsInNwbGl0IiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsImluZGV4T2YiLCJoYXNPd24iLCJjYWNoZWQiLCJmbiIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiX2xlbmd0aCIsIm5hdGl2ZUJpbmQiLCJiaW5kIiwidG9BcnJheSIsInJldCIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJ0b09iamVjdCIsInJlcyIsImIiLCJubyIsImdlblN0YXRpY0tleXMiLCJtb2R1bGVzIiwicmVkdWNlIiwibSIsInN0YXRpY0tleXMiLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsImV2ZXJ5IiwiZ2V0VGltZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwid2FybkhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiYXN5bmMiLCJfbGlmZWN5Y2xlSG9va3MiLCJ1bmljb2RlTGV0dGVycyIsImlzUmVzZXJ2ZWQiLCJkZWYiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJwYXJzZVBhdGgiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwiaXNQaGFudG9tSlMiLCJpc0ZGIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlclJlbmRlcmluZyIsImVudiIsIlZVRV9FTlYiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaXNOYXRpdmUiLCJoYXNTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJ3YXJuIiwidGlwIiwiZ2VuZXJhdGVDb21wb25lbnRUcmFjZSIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJ0cmFjZSIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJjaWQiLCJfaXNWdWUiLCIkb3B0aW9ucyIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwicmVwZWF0IiwiJHBhcmVudCIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJsYXN0IiwiRGVwIiwiaWQiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwiYWRkRGVwIiwibm90aWZ5IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwicG9wVGFyZ2V0IiwiVk5vZGUiLCJjaGlsZHJlbiIsImVsbSIsImNvbnRleHQiLCJjb21wb25lbnRPcHRpb25zIiwiYXN5bmNGYWN0b3J5IiwibnMiLCJmbkNvbnRleHQiLCJmbk9wdGlvbnMiLCJmblNjb3BlSWQiLCJjb21wb25lbnRJbnN0YW5jZSIsInBhcmVudCIsInJhdyIsImlzU3RhdGljIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJhc3luY01ldGEiLCJpc0FzeW5jUGxhY2Vob2xkZXIiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJjaGlsZCIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kc1RvUGF0Y2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIm9ic2VydmUiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJkZWwiLCJzdHJhdHMiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImRlZHVwZUhvb2tzIiwiaG9va3MiLCJob29rIiwibWVyZ2VBc3NldHMiLCJhc3NlcnRPYmplY3RUeXBlIiwibWV0aG9kcyIsImluamVjdCIsImNvbXB1dGVkIiwicHJvdmlkZSIsImNoZWNrQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJ2YWxpZGF0ZUNvbXBvbmVudE5hbWUiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJkZWYkJDEiLCJtZXJnZU9wdGlvbnMiLCJfYmFzZSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJwcm9wIiwiYWJzZW50IiwiYm9vbGVhbkluZGV4IiwiZ2V0VHlwZUluZGV4IiwiQm9vbGVhbiIsInN0cmluZ0luZGV4IiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRPYnNlcnZlIiwiYXNzZXJ0UHJvcCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJnZXRJbnZhbGlkVHlwZU1lc3NhZ2UiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImlzU2FtZVR5cGUiLCJsZW4iLCJyZWNlaXZlZFR5cGUiLCJleHBlY3RlZFZhbHVlIiwic3R5bGVWYWx1ZSIsInJlY2VpdmVkVmFsdWUiLCJpc0V4cGxpY2FibGUiLCJpc0Jvb2xlYW4iLCJOdW1iZXIiLCJleHBsaWNpdFR5cGVzIiwic29tZSIsImVsZW0iLCJoYW5kbGVFcnJvciIsImVyciIsImluZm8iLCJjdXIiLCJlcnJvckNhcHR1cmVkIiwiY2FwdHVyZSIsImdsb2JhbEhhbmRsZUVycm9yIiwiaW52b2tlV2l0aEVycm9ySGFuZGxpbmciLCJoYW5kbGVyIiwibG9nRXJyb3IiLCJpc1VzaW5nTWljcm9UYXNrIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsImZsdXNoQ2FsbGJhY2tzIiwiY29waWVzIiwidGltZXJGdW5jIiwicCIsInNldFRpbWVvdXQiLCJNdXRhdGlvbk9ic2VydmVyIiwiY291bnRlciIsIm9ic2VydmVyIiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsImNoYXJhY3RlckRhdGEiLCJzZXRJbW1lZGlhdGUiLCJuZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJtYXJrIiwibWVhc3VyZSIsInBlcmYiLCJjbGVhck1hcmtzIiwiY2xlYXJNZWFzdXJlcyIsInN0YXJ0VGFnIiwiZW5kVGFnIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsIndhcm5SZXNlcnZlZFByZWZpeCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCIkZGF0YSIsImdldEhhbmRsZXIiLCJoYW5kbGVycyIsInJlbmRlciIsIl93aXRoU3RyaXBwZWQiLCJfcmVuZGVyUHJveHkiLCJzZWVuT2JqZWN0cyIsInRyYXZlcnNlIiwiX3RyYXZlcnNlIiwiaXNBIiwiaXNGcm96ZW4iLCJkZXBJZCIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwidXBkYXRlTGlzdGVuZXJzIiwib24iLCJvbGRPbiIsInJlbW92ZSQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyIiwib2xkIiwicGFyYW1zIiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImF0dHJzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4Iiwic2hpZnQiLCJfaXNWTGlzdCIsImluaXRQcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwicHJvdmlkZUtleSIsInByb3ZpZGVEZWZhdWx0IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwiaXNXaGl0ZXNwYWNlIiwibm9ybWFsaXplU2NvcGVkU2xvdHMiLCJub3JtYWxTbG90cyIsInByZXZTbG90cyIsIl9ub3JtYWxpemVkIiwiJHN0YWJsZSIsIm5vcm1hbGl6ZVNjb3BlZFNsb3QiLCJwcm94eU5vcm1hbFNsb3QiLCJwcm94eSIsInJlbmRlckxpc3QiLCJpdGVyYXRvciIsIm5leHQiLCJkb25lIiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsIiRzY29wZWRTbG90cyIsIm5vZGVzIiwiJHNsb3RzIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZXNvbHZlRmlsdGVyIiwiaXNLZXlOb3RNYXRjaCIsImV4cGVjdCIsImFjdHVhbCIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluS2V5Q29kZSIsImV2ZW50S2V5TmFtZSIsImJ1aWx0SW5LZXlOYW1lIiwibWFwcGVkS2V5Q29kZSIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImlzU3luYyIsImRvbVByb3BzIiwiY2FtZWxpemVkS2V5IiwiJGV2ZW50IiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsIl9zdGF0aWNUcmVlcyIsInN0YXRpY1JlbmRlckZucyIsIm1hcmtTdGF0aWMiLCJtYXJrT25jZSIsIm1hcmtTdGF0aWNOb2RlIiwiYmluZE9iamVjdExpc3RlbmVycyIsImV4aXN0aW5nIiwib3VycyIsInJlc29sdmVTY29wZWRTbG90cyIsImhhc0R5bmFtaWNLZXlzIiwiYmluZER5bmFtaWNLZXlzIiwiYmFzZU9iaiIsInByZXBlbmRNb2RpZmllciIsImluc3RhbGxSZW5kZXJIZWxwZXJzIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX2kiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsIl9nIiwiX2QiLCJfcCIsIkZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IiwiY29udGV4dFZtIiwiX29yaWdpbmFsIiwiaXNDb21waWxlZCIsIl9jb21waWxlZCIsIm5lZWROb3JtYWxpemF0aW9uIiwibGlzdGVuZXJzIiwiaW5qZWN0aW9ucyIsInNjb3BlZFNsb3RzIiwiX3Njb3BlSWQiLCJfYyIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQiLCJ2bm9kZXMiLCJjbG9uZSIsImRldnRvb2xzTWV0YSIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJoeWRyYXRpbmciLCJfaXNEZXN0cm95ZWQiLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsInByZXBhdGNoIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsImFjdGl2ZUluc3RhbmNlIiwiJG1vdW50Iiwib2xkVm5vZGUiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsImluc2VydCIsIl9pc01vdW50ZWQiLCJjYWxsSG9vayIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwiYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImRlc3Ryb3kiLCIkZGVzdHJveSIsImRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsImJhc2VDdG9yIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZnVuY3Rpb25hbCIsIm5hdGl2ZU9uIiwiYWJzdHJhY3QiLCJpbnN0YWxsQ29tcG9uZW50SG9va3MiLCJfaXNDb21wb25lbnQiLCJfcGFyZW50Vm5vZGUiLCJpbmxpbmVUZW1wbGF0ZSIsInRvTWVyZ2UiLCJfbWVyZ2VkIiwibWVyZ2VIb29rJDEiLCJmMSIsImYyIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsIiR2bm9kZSIsInByZSIsImFwcGx5TlMiLCJyZWdpc3RlckRlZXBCaW5kaW5ncyIsImZvcmNlIiwic3R5bGUiLCJjbGFzcyIsImluaXRSZW5kZXIiLCJfdm5vZGUiLCJwYXJlbnRWbm9kZSIsIl9yZW5kZXJDaGlsZHJlbiIsInBhcmVudERhdGEiLCJpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQiLCJfcGFyZW50TGlzdGVuZXJzIiwiY3VycmVudFJlbmRlcmluZ0luc3RhbmNlIiwicmVuZGVyTWl4aW4iLCJWdWUiLCIkbmV4dFRpY2siLCJyZW5kZXJFcnJvciIsImVuc3VyZUN0b3IiLCJjb21wIiwiYmFzZSIsIl9fZXNNb2R1bGUiLCJmYWN0b3J5IiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJvd25lciIsIm93bmVycyIsInN5bmMiLCJmb3JjZVJlbmRlciIsInJlbmRlckNvbXBsZXRlZCIsIiRmb3JjZVVwZGF0ZSIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJfdGFyZ2V0Iiwib25jZUhhbmRsZXIiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsIiRvbmNlIiwiY2JzIiwiJGVtaXQiLCJsb3dlckNhc2VFdmVudCIsInNldEFjdGl2ZUluc3RhbmNlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiaW5pdExpZmVjeWNsZSIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsInJlc3RvcmVBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9fdnVlX18iLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ1cGRhdGVDb21wb25lbnQiLCJfbmFtZSIsIl91aWQiLCJXYXRjaGVyIiwiYmVmb3JlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNEeW5hbWljU2NvcGVkU2xvdCIsIm5lZWRzRm9yY2VVcGRhdGUiLCIkYXR0cnMiLCIkbGlzdGVuZXJzIiwicHJvcEtleXMiLCJfcHJvcEtleXMiLCJpc0luSW5hY3RpdmVUcmVlIiwiZGlyZWN0IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiY3VycmVudEZsdXNoVGltZXN0YW1wIiwiZ2V0Tm93IiwiY3JlYXRlRXZlbnQiLCJ0aW1lU3RhbXAiLCJmbHVzaFNjaGVkdWxlclF1ZXVlIiwid2F0Y2hlciIsInJ1biIsInVzZXIiLCJleHByZXNzaW9uIiwiYWN0aXZhdGVkUXVldWUiLCJ1cGRhdGVkUXVldWUiLCJjYWxsQWN0aXZhdGVkSG9va3MiLCJjYWxsVXBkYXRlZEhvb2tzIiwiZW1pdCIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImRlZXAiLCJsYXp5IiwiYWN0aXZlIiwiZGlydHkiLCJkZXBzIiwibmV3RGVwcyIsImRlcElkcyIsIm5ld0RlcElkcyIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24iLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImh5cGhlbmF0ZWRLZXkiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVHZXR0ZXJJbnZva2VyIiwiY29tcHV0ZWRHZXR0ZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwidWlkJDMiLCJpbml0TWl4aW4iLCJfaW5pdCIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJjYWNoZWRTdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsIm1vZGlmaWVkIiwibGF0ZXN0Iiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImluaXRVc2UiLCJ1c2UiLCJwbHVnaW4iLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5zdGFsbCIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJwcnVuZUNhY2hlIiwia2VlcEFsaXZlSW5zdGFuY2UiLCJjYWNoZWROb2RlIiwicHJ1bmVDYWNoZUVudHJ5IiwiY3VycmVudCIsImNhY2hlZCQkMSIsInBhdHRlcm5UeXBlcyIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiY3JlYXRlZCIsImRlc3Ryb3llZCIsIm1vdW50ZWQiLCJwYXJzZUludCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsInV0aWwiLCJkZWZpbmVSZWFjdGl2ZSIsImRlbGV0ZSIsIm9ic2VydmFibGUiLCJzc3JDb250ZXh0IiwidmVyc2lvbiIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUiLCJjb252ZXJ0RW51bWVyYXRlZFZhbHVlIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImdlbkNsYXNzRm9yVm5vZGUiLCJwYXJlbnROb2RlIiwiY2hpbGROb2RlIiwibWVyZ2VDbGFzc0RhdGEiLCJyZW5kZXJDbGFzcyIsInN0YXRpY0NsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwiaXNQcmVUYWciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1RleHRJbnB1dFR5cGUiLCJzZWxlY3RlZCIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsInJlbW92ZUNoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwic2V0U3R5bGVTY29wZSIsInNjb3BlSWQiLCJub2RlT3BzIiwicmVmIiwicmVnaXN0ZXJSZWYiLCJpc1JlbW92YWwiLCJyZWZzIiwicmVmSW5Gb3IiLCJlbXB0eU5vZGUiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwidHlwZUEiLCJ0eXBlQiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJjcmVhdGVQYXRjaEZ1bmN0aW9uIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImlzVW5rbm93bkVsZW1lbnQkJDEiLCJpblZQcmUiLCJpZ25vcmUiLCJjcmVhdGluZ0VsbUluVlByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsInBhcmVudEVsbSIsInJlZkVsbSIsIm5lc3RlZCIsIm93bmVyQXJyYXkiLCJzZXRTY29wZSIsImNyZWF0ZUNoaWxkcmVuIiwiaW52b2tlQ3JlYXRlSG9va3MiLCJpc1JlYWN0aXZhdGVkIiwiaW5pdENvbXBvbmVudCIsInJlYWN0aXZhdGVDb21wb25lbnQiLCJwZW5kaW5nSW5zZXJ0IiwiaXNQYXRjaGFibGUiLCJpbm5lck5vZGUiLCJ0cmFuc2l0aW9uIiwiYWN0aXZhdGUiLCJyZWYkJDEiLCJjaGVja0R1cGxpY2F0ZUtleXMiLCJhbmNlc3RvciIsImFkZFZub2RlcyIsInN0YXJ0SWR4IiwiaW52b2tlRGVzdHJveUhvb2siLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJybSIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRTdGFydElkeCIsIm5ld1N0YXJ0SWR4Iiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsInZub2RlVG9Nb3ZlIiwiY2FuTW92ZSIsInBhdGNoVm5vZGUiLCJmaW5kSWR4SW5PbGQiLCJzZWVuS2V5cyIsImVuZCIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImh5ZHJhdGlvbkJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwiZnVsbEludm9rZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwiX2xlYXZlQ2IiLCJwYXRjaGFibGUiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiY2FsbEhvb2skMSIsIm9sZEFyZyIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsImJhc2VTZXRBdHRyIiwic2V0QXR0cmlidXRlTlMiLCJfX2llcGgiLCJibG9ja2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsInBhcnNlRmlsdGVycyIsImV4cCIsImluU2luZ2xlIiwiaW5Eb3VibGUiLCJpblRlbXBsYXRlU3RyaW5nIiwiaW5SZWdleCIsImN1cmx5Iiwic3F1YXJlIiwicGFyZW4iLCJsYXN0RmlsdGVySW5kZXgiLCJwcmV2IiwiZmlsdGVycyIsInRyaW0iLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicmFuZ2UiLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsImR5bmFtaWMiLCJyYW5nZVNldEl0ZW0iLCJwbGFpbiIsImFkZEF0dHIiLCJkeW5hbWljQXR0cnMiLCJhZGRSYXdBdHRyIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJhZGREaXJlY3RpdmUiLCJpc0R5bmFtaWNBcmciLCJwcmVwZW5kTW9kaWZpZXJNYXJrZXIiLCJhZGRIYW5kbGVyIiwiaW1wb3J0YW50IiwicHJldmVudCIsInJpZ2h0IiwibWlkZGxlIiwiZXZlbnRzIiwibmF0aXZlIiwibmF0aXZlRXZlbnRzIiwibmV3SGFuZGxlciIsImdldFJhd0JpbmRpbmdBdHRyIiwicmF3QXR0cnNNYXAiLCJnZXRCaW5kaW5nQXR0ciIsImdldFN0YXRpYyIsImR5bmFtaWNWYWx1ZSIsImdldEFuZFJlbW92ZUF0dHIiLCJzdGF0aWNWYWx1ZSIsInJlbW92ZUZyb21NYXAiLCJnZXRBbmRSZW1vdmVBdHRyQnlSZWdleCIsImdlbkNvbXBvbmVudE1vZGVsIiwiYmFzZVZhbHVlRXhwcmVzc2lvbiIsInZhbHVlRXhwcmVzc2lvbiIsImFzc2lnbm1lbnQiLCJnZW5Bc3NpZ25tZW50Q29kZSIsInBhcnNlTW9kZWwiLCJpbmRleCQxIiwiZXhwcmVzc2lvblBvcyIsImV4cHJlc3Npb25FbmRQb3MiLCJlb2YiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJjb2RlIiwidHlwZUJpbmRpbmciLCJuZWVkQ29tcG9zaXRpb25HdWFyZCIsIm5vcm1hbGl6ZUV2ZW50cyIsImNoYW5nZSIsInRhcmdldCQxIiwiY3JlYXRlT25jZUhhbmRsZXIkMSIsInJlbW92ZSQyIiwidXNlTWljcm90YXNrRml4IiwiYWRkJDEiLCJhdHRhY2hlZFRpbWVzdGFtcCIsIl93cmFwcGVyIiwiY3VycmVudFRhcmdldCIsIm93bmVyRG9jdW1lbnQiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJzdmdDb250YWluZXIiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzTm90SW5Gb2N1c0FuZERpcnR5IiwiaXNEaXJ0eVdpdGhNb2RpZmllcnMiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJ3aGl0ZXNwYWNlUkUiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJlbmRlZCIsIm9uRW5kIiwicHJvcENvdW50IiwidHJhbnNmb3JtUkUiLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsImFwcGVhciIsInN0YXJ0Q2xhc3MiLCJhcHBlYXJDbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJiZWZvcmVBcHBlYXIiLCJiZWZvcmVFbnRlciIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiYWZ0ZXJBcHBlYXIiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZW50ZXJDYW5jZWxsZWQiLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJkdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwibGVhdmVDYW5jZWxsZWQiLCJhZnRlckxlYXZlIiwiZGVsYXlMZWF2ZSIsInBlcmZvcm1MZWF2ZSIsImJlZm9yZUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJkaXJlY3RpdmUiLCJfdk9wdGlvbnMiLCJzZXRTZWxlY3RlZCIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25FbmQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJvIiwibmVlZFJlc2V0IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImFjdHVhbGx5U2V0U2VsZWN0ZWQiLCJpc011bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWRJbmRleCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsImgiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiaXNOb3RUZXh0Tm9kZSIsImlzVlNob3dEaXJlY3RpdmUiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsImJlZm9yZU1vdW50Iiwia2VwdCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJyZW1vdmVkIiwicG9zIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidXBkYXRlZCIsImhhc01vdmUiLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwiYXBwbHlUcmFuc2xhdGlvbiIsIl9yZWZsb3ciLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwiZGVmYXVsdFRhZ1JFIiwicmVnZXhFc2NhcGVSRSIsImJ1aWxkUmVnZXgiLCJkZWxpbWl0ZXJzIiwiY2xvc2UiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsInJhd1Rva2VucyIsInRva2VuVmFsdWUiLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSIsImtsYXNzJDEiLCJ0cmFuc2Zvcm1Ob2RlJDEiLCJzdHlsZUJpbmRpbmciLCJnZW5EYXRhJDEiLCJzdHlsZSQxIiwiZGVjb2RlciIsImhlIiwiZGVjb2RlIiwiaHRtbCIsImlzVW5hcnlUYWciLCJjYW5CZUxlZnRPcGVuVGFnIiwiaXNOb25QaHJhc2luZ1RhZyIsImF0dHJpYnV0ZSIsImR5bmFtaWNBcmdBdHRyaWJ1dGUiLCJuY25hbWUiLCJxbmFtZUNhcHR1cmUiLCJzdGFydFRhZ09wZW4iLCJzdGFydFRhZ0Nsb3NlIiwiZG9jdHlwZSIsImNvbW1lbnQiLCJjb25kaXRpb25hbENvbW1lbnQiLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicmUiLCJwYXJzZUhUTUwiLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsInN1YnN0cmluZyIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwiYWxsIiwidW5hcnlTbGFzaCIsInVuYXJ5Iiwic2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmIiwib3V0cHV0U291cmNlUmFuZ2UiLCJsb3dlckNhc2VkVGFnIiwibG93ZXJDYXNlZFRhZ05hbWUiLCJvblJFIiwiZGlyUkUiLCJmb3JBbGlhc1JFIiwiZm9ySXRlcmF0b3JSRSIsInN0cmlwUGFyZW5zUkUiLCJkeW5hbWljQXJnUkUiLCJhcmdSRSIsImJpbmRSRSIsIm1vZGlmaWVyUkUiLCJzbG90UkUiLCJsaW5lQnJlYWtSRSIsIndoaXRlc3BhY2VSRSQxIiwiaW52YWxpZEF0dHJpYnV0ZVJFIiwiZGVjb2RlSFRNTENhY2hlZCIsImVtcHR5U2xvdFNjb3BlVG9rZW4iLCJ3YXJuJDIiLCJ0cmFuc2Zvcm1zIiwicHJlVHJhbnNmb3JtcyIsInBvc3RUcmFuc2Zvcm1zIiwicGxhdGZvcm1Jc1ByZVRhZyIsInBsYXRmb3JtTXVzdFVzZVByb3AiLCJwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSIsIm1heWJlQ29tcG9uZW50IiwiY3JlYXRlQVNURWxlbWVudCIsIm1ha2VBdHRyc01hcCIsInByZXNlcnZlV2hpdGVzcGFjZSIsIndoaXRlc3BhY2VPcHRpb24iLCJ3aGl0ZXNwYWNlIiwiY3VycmVudFBhcmVudCIsImluUHJlIiwid2FybmVkIiwid2Fybk9uY2UiLCJjbG9zZUVsZW1lbnQiLCJ0cmltRW5kaW5nV2hpdGVzcGFjZSIsInByb2Nlc3NlZCIsInByb2Nlc3NFbGVtZW50IiwiaWYiLCJlbHNlaWYiLCJlbHNlIiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwiZm9yYmlkZGVuIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJsYXN0Tm9kZSIsImNvbW1lbnRzIiwiZ3VhcmRJRVNWR0J1ZyIsImN1bXVsYXRlZCIsImlzRm9yYmlkZGVuVGFnIiwicHJvY2Vzc1ByZSIsInByb2Nlc3NSYXdBdHRycyIsInByb2Nlc3NGb3IiLCJwcm9jZXNzSWYiLCJwcm9jZXNzT25jZSIsImlzVGV4dFRhZyIsInByb2Nlc3NLZXkiLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3RDb250ZW50IiwicHJvY2Vzc1Nsb3RPdXRsZXQiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiZm9yIiwiaXRlcmF0b3IyIiwiaXRlcmF0b3IxIiwiY2hlY2tJbkZvciIsInBhcnNlRm9yIiwiaW5NYXRjaCIsImFsaWFzIiwiaXRlcmF0b3JNYXRjaCIsImZpbmRQcmV2RWxlbWVudCIsImNvbmRpdGlvbiIsImlmQ29uZGl0aW9ucyIsInNsb3RUYXJnZXREeW5hbWljIiwic2xvdEJpbmRpbmciLCJnZXRTbG90TmFtZSIsInNsb3RDb250YWluZXIiLCJzbG90TmFtZSIsInN5bmNHZW4iLCJpc0R5bmFtaWMiLCJoYXNCaW5kaW5ncyIsInBhcnNlTW9kaWZpZXJzIiwiY2FtZWwiLCJhcmdNYXRjaCIsImNoZWNrRm9yQWxpYXNNb2RlbCIsImllTlNCdWciLCJpZU5TUHJlZml4IiwiX2VsIiwicHJlVHJhbnNmb3JtTm9kZSIsImlmQ29uZGl0aW9uIiwiaWZDb25kaXRpb25FeHRyYSIsImhhc0Vsc2UiLCJlbHNlSWZDb25kaXRpb24iLCJicmFuY2gwIiwiY2xvbmVBU1RFbGVtZW50IiwiYnJhbmNoMSIsImJyYW5jaDIiLCJtb2RlbCQxIiwibW9kdWxlcyQxIiwiZGlyZWN0aXZlcyQxIiwiYmFzZU9wdGlvbnMiLCJpc1N0YXRpY0tleSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsImdlblN0YXRpY0tleXNDYWNoZWQiLCJnZW5TdGF0aWNLZXlzJDEiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMkMSIsIm1hcmtTdGF0aWNSb290cyIsInN0YXRpYyIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiZm5FeHBSRSIsImZuSW52b2tlUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJ0YWIiLCJzcGFjZSIsInVwIiwiZG93biIsImtleU5hbWVzIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwiY3RybCIsImFsdCIsIm1ldGEiLCJnZW5IYW5kbGVycyIsInByZWZpeCIsInN0YXRpY0hhbmRsZXJzIiwiZHluYW1pY0hhbmRsZXJzIiwiaGFuZGxlckNvZGUiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJpc0Z1bmN0aW9uSW52b2NhdGlvbiIsImdlbk1vZGlmaWVyQ29kZSIsImtleU1vZGlmaWVyIiwiZ2VuS2V5RmlsdGVyIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsImtleUNvZGUiLCJrZXlOYW1lIiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJvbmNlSWQiLCJnZW5lcmF0ZSIsImFzdCIsInN0YXRlIiwiZ2VuRWxlbWVudCIsInN0YXRpY1Byb2Nlc3NlZCIsImdlblN0YXRpYyIsIm9uY2VQcm9jZXNzZWQiLCJnZW5PbmNlIiwiZm9yUHJvY2Vzc2VkIiwiZ2VuRm9yIiwiaWZQcm9jZXNzZWQiLCJnZW5JZiIsImdlbkNoaWxkcmVuIiwiZ2VuU2xvdCIsImdlbkNvbXBvbmVudCIsImdlbkRhdGEkMiIsIm9yaWdpbmFsUHJlU3RhdGUiLCJhbHRHZW4iLCJhbHRFbXB0eSIsImdlbklmQ29uZGl0aW9ucyIsImNvbmRpdGlvbnMiLCJnZW5UZXJuYXJ5RXhwIiwiYWx0SGVscGVyIiwiZ2VuRGlyZWN0aXZlcyIsImdlblByb3BzIiwiZ2VuU2NvcGVkU2xvdHMiLCJnZW5JbmxpbmVUZW1wbGF0ZSIsImhhc1J1bnRpbWUiLCJuZWVkUnVudGltZSIsImdlbiIsImlubGluZVJlbmRlckZucyIsImNvbnRhaW5zU2xvdENoaWxkIiwiZ2VuU2NvcGVkU2xvdCIsImlzTGVnYWN5U3ludGF4IiwicmV2ZXJzZVByb3h5IiwiY2hlY2tTa2lwIiwiYWx0R2VuRWxlbWVudCIsImFsdEdlbk5vZGUiLCJnZXROb3JtYWxpemF0aW9uVHlwZSIsImdlbk5vZGUiLCJuZWVkc05vcm1hbGl6YXRpb24iLCJnZW5Db21tZW50IiwiZ2VuVGV4dCIsInRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyIsImJpbmQkJDEiLCJjb21wb25lbnROYW1lIiwic3RhdGljUHJvcHMiLCJkeW5hbWljUHJvcHMiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJzdGlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJnZW5lcmF0ZUNvZGVGcmFtZSIsImxpbmVzIiwibGluZUxlbmd0aCIsInBhZCIsImNyZWF0ZUZ1bmN0aW9uIiwiZXJyb3JzIiwiY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiIsImNvbXBpbGUiLCJjb21waWxlVG9GdW5jdGlvbnMiLCJ3YXJuJCQxIiwidGlwcyIsImZuR2VuRXJyb3JzIiwiY3JlYXRlQ29tcGlsZXJDcmVhdG9yIiwiYmFzZUNvbXBpbGUiLCJjcmVhdGVDb21waWxlciIsImZpbmFsT3B0aW9ucyIsImxlYWRpbmdTcGFjZUxlbmd0aCIsImRpdiIsImdldFNob3VsZERlY29kZSIsImhyZWYiLCJpZFRvVGVtcGxhdGUiLCJtb3VudCIsImRvY3VtZW50RWxlbWVudCIsImdldE91dGVySFRNTCIsIm91dGVySFRNTCIsImNvbnRhaW5lciIsIlNlbGVjdERhdGEiLCJTZWxlY3QiLCJTZWxlY3RDb21wb25lbnQiLCJfY29uc3RhbnRzIiwiZGF0YUhhbmRsZXIiLCJuZXdEYXRhIiwiY2hhcnQiLCJfY2hhcnQiLCJuZXdEYXRhc2V0TGFiZWxzIiwiZGF0YXNldHMiLCJvbGREYXRhc2V0TGFiZWxzIiwib2xkTGFiZWxzIiwibmV3TGFiZWxzIiwib2xkRGF0YXNldEtleXMiLCJuZXdEYXRhc2V0S2V5cyIsImRlbGV0aW9uS2V5cyIsImRlbGV0aW9uS2V5IiwibGFiZWxzIiwieExhYmVscyIsInlMYWJlbHMiLCJyZW5kZXJDaGFydCIsImNoYXJ0RGF0YSIsInJlYWN0aXZlRGF0YSIsInJlYWN0aXZlUHJvcCIsImhvb2tDYWxsYmFjayIsInNldEhvb2tDYWxsYmFjayIsImlucHV0IiwiaXNPYmplY3RFbXB0eSIsImlzVW5kZWZpbmVkIiwiaXNOdW1iZXIiLCJpc0RhdGUiLCJoYXNPd25Qcm9wIiwiY3JlYXRlVVRDIiwiZm9ybWF0IiwibG9jYWxlIiwic3RyaWN0IiwiY3JlYXRlTG9jYWxPclVUQyIsInV0YyIsImRlZmF1bHRQYXJzaW5nRmxhZ3MiLCJlbXB0eSIsInVudXNlZFRva2VucyIsInVudXNlZElucHV0Iiwib3ZlcmZsb3ciLCJjaGFyc0xlZnRPdmVyIiwibnVsbElucHV0IiwiaW52YWxpZE1vbnRoIiwiaW52YWxpZEZvcm1hdCIsInVzZXJJbnZhbGlkYXRlZCIsImlzbyIsInBhcnNlZERhdGVQYXJ0cyIsIm1lcmlkaWVtIiwicmZjMjgyMiIsIndlZWtkYXlNaXNtYXRjaCIsImdldFBhcnNpbmdGbGFncyIsIl9wZiIsImZ1biIsImlzVmFsaWQiLCJfaXNWYWxpZCIsImZsYWdzIiwicGFyc2VkUGFydHMiLCJpc05vd1ZhbGlkIiwiaW52YWxpZFdlZWtkYXkiLCJfc3RyaWN0IiwiYmlnSG91ciIsImNyZWF0ZUludmFsaWQiLCJOYU4iLCJtb21lbnRQcm9wZXJ0aWVzIiwiY29weUNvbmZpZyIsIl9pc0FNb21lbnRPYmplY3QiLCJfdHptIiwiX2lzVVRDIiwiX29mZnNldCIsIl9sb2NhbGUiLCJ1cGRhdGVJblByb2dyZXNzIiwiTW9tZW50IiwidXBkYXRlT2Zmc2V0IiwiaXNNb21lbnQiLCJhYnNGbG9vciIsImNlaWwiLCJ0b0ludCIsImFyZ3VtZW50Rm9yQ29lcmNpb24iLCJjb2VyY2VkTnVtYmVyIiwiY29tcGFyZUFycmF5cyIsImFycmF5MSIsImFycmF5MiIsImRvbnRDb252ZXJ0IiwibGVuZ3RoRGlmZiIsImFicyIsImRpZmZzIiwic3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzIiwiZGVwcmVjYXRlIiwiZmlyc3RUaW1lIiwiZGVwcmVjYXRpb25IYW5kbGVyIiwiZGVwcmVjYXRpb25zIiwiZGVwcmVjYXRlU2ltcGxlIiwiX2NvbmZpZyIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwiX29yZGluYWxQYXJzZSIsIm1lcmdlQ29uZmlncyIsInBhcmVudENvbmZpZyIsImNoaWxkQ29uZmlnIiwiTG9jYWxlIiwiZGVmYXVsdENhbGVuZGFyIiwic2FtZURheSIsIm5leHREYXkiLCJuZXh0V2VlayIsImxhc3REYXkiLCJsYXN0V2VlayIsInNhbWVFbHNlIiwiY2FsZW5kYXIiLCJtb20iLCJvdXRwdXQiLCJfY2FsZW5kYXIiLCJkZWZhdWx0TG9uZ0RhdGVGb3JtYXQiLCJMVFMiLCJMVCIsIkwiLCJMTCIsIkxMTCIsIkxMTEwiLCJsb25nRGF0ZUZvcm1hdCIsIl9sb25nRGF0ZUZvcm1hdCIsImZvcm1hdFVwcGVyIiwiZGVmYXVsdEludmFsaWREYXRlIiwiaW52YWxpZERhdGUiLCJfaW52YWxpZERhdGUiLCJkZWZhdWx0T3JkaW5hbCIsImRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwib3JkaW5hbCIsIl9vcmRpbmFsIiwiZGVmYXVsdFJlbGF0aXZlVGltZSIsImZ1dHVyZSIsInBhc3QiLCJzcyIsIm1tIiwiaGgiLCJkZCIsIk0iLCJNTSIsInkiLCJ5eSIsInJlbGF0aXZlVGltZSIsIndpdGhvdXRTdWZmaXgiLCJpc0Z1dHVyZSIsIl9yZWxhdGl2ZVRpbWUiLCJwYXN0RnV0dXJlIiwiZGlmZiIsImFsaWFzZXMiLCJhZGRVbml0QWxpYXMiLCJ1bml0Iiwic2hvcnRoYW5kIiwibG93ZXJDYXNlIiwibm9ybWFsaXplVW5pdHMiLCJ1bml0cyIsIm5vcm1hbGl6ZU9iamVjdFVuaXRzIiwiaW5wdXRPYmplY3QiLCJub3JtYWxpemVkSW5wdXQiLCJub3JtYWxpemVkUHJvcCIsInByaW9yaXRpZXMiLCJhZGRVbml0UHJpb3JpdHkiLCJwcmlvcml0eSIsImdldFByaW9yaXRpemVkVW5pdHMiLCJ1bml0c09iaiIsInUiLCJ6ZXJvRmlsbCIsInRhcmdldExlbmd0aCIsImZvcmNlU2lnbiIsImFic051bWJlciIsInplcm9zVG9GaWxsIiwic2lnbiIsInBvdyIsImZvcm1hdHRpbmdUb2tlbnMiLCJsb2NhbEZvcm1hdHRpbmdUb2tlbnMiLCJmb3JtYXRGdW5jdGlvbnMiLCJmb3JtYXRUb2tlbkZ1bmN0aW9ucyIsImFkZEZvcm1hdFRva2VuIiwidG9rZW4iLCJwYWRkZWQiLCJsb2NhbGVEYXRhIiwicmVtb3ZlRm9ybWF0dGluZ1Rva2VucyIsIm1ha2VGb3JtYXRGdW5jdGlvbiIsImZvcm1hdE1vbWVudCIsImV4cGFuZEZvcm1hdCIsInJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyIsIm1hdGNoMSIsIm1hdGNoMiIsIm1hdGNoMyIsIm1hdGNoNCIsIm1hdGNoNiIsIm1hdGNoMXRvMiIsIm1hdGNoM3RvNCIsIm1hdGNoNXRvNiIsIm1hdGNoMXRvMyIsIm1hdGNoMXRvNCIsIm1hdGNoMXRvNiIsIm1hdGNoVW5zaWduZWQiLCJtYXRjaFNpZ25lZCIsIm1hdGNoT2Zmc2V0IiwibWF0Y2hTaG9ydE9mZnNldCIsIm1hdGNoVGltZXN0YW1wIiwibWF0Y2hXb3JkIiwicmVnZXhlcyIsImFkZFJlZ2V4VG9rZW4iLCJzdHJpY3RSZWdleCIsImlzU3RyaWN0IiwiZ2V0UGFyc2VSZWdleEZvclRva2VuIiwidW5lc2NhcGVGb3JtYXQiLCJyZWdleEVzY2FwZSIsIm1hdGNoZWQiLCJwMSIsInAyIiwicDMiLCJwNCIsImFkZFBhcnNlVG9rZW4iLCJhZGRXZWVrUGFyc2VUb2tlbiIsIl93IiwiYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4iLCJfYSIsIllFQVIiLCJNT05USCIsIkRBVEUiLCJIT1VSIiwiTUlOVVRFIiwiU0VDT05EIiwiTUlMTElTRUNPTkQiLCJXRUVLIiwiV0VFS0RBWSIsInBhcnNlVHdvRGlnaXRZZWFyIiwiZGF5c0luWWVhciIsImlzTGVhcFllYXIiLCJnZXRTZXRZZWFyIiwibWFrZUdldFNldCIsImdldElzTGVhcFllYXIiLCJrZWVwVGltZSIsInNldCQxIiwiZGF5c0luTW9udGgiLCJzdHJpbmdHZXQiLCJzdHJpbmdTZXQiLCJwcmlvcml0aXplZCIsIm1vZCIsIngiLCJtb2RNb250aCIsIm1vbnRoc1Nob3J0IiwibW9udGhzIiwibW9udGhzU2hvcnRSZWdleCIsIm1vbnRoc1JlZ2V4IiwibW9udGhzUGFyc2UiLCJNT05USFNfSU5fRk9STUFUIiwiZGVmYXVsdExvY2FsZU1vbnRocyIsImxvY2FsZU1vbnRocyIsIl9tb250aHMiLCJpc0Zvcm1hdCIsImRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCIsImxvY2FsZU1vbnRoc1Nob3J0IiwiX21vbnRoc1Nob3J0IiwiaGFuZGxlU3RyaWN0UGFyc2UiLCJtb250aE5hbWUiLCJpaSIsImxsYyIsInRvTG9jYWxlTG93ZXJDYXNlIiwiX21vbnRoc1BhcnNlIiwiX2xvbmdNb250aHNQYXJzZSIsIl9zaG9ydE1vbnRoc1BhcnNlIiwibG9jYWxlTW9udGhzUGFyc2UiLCJfbW9udGhzUGFyc2VFeGFjdCIsInNldE1vbnRoIiwiZGF5T2ZNb250aCIsImdldFNldE1vbnRoIiwiZ2V0RGF5c0luTW9udGgiLCJkZWZhdWx0TW9udGhzU2hvcnRSZWdleCIsImNvbXB1dGVNb250aHNQYXJzZSIsIl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IiwiX21vbnRoc1Nob3J0UmVnZXgiLCJkZWZhdWx0TW9udGhzUmVnZXgiLCJfbW9udGhzU3RyaWN0UmVnZXgiLCJfbW9udGhzUmVnZXgiLCJjbXBMZW5SZXYiLCJzaG9ydFBpZWNlcyIsImxvbmdQaWVjZXMiLCJtaXhlZFBpZWNlcyIsImNyZWF0ZURhdGUiLCJtcyIsImdldEZ1bGxZZWFyIiwic2V0RnVsbFllYXIiLCJjcmVhdGVVVENEYXRlIiwiVVRDIiwiZ2V0VVRDRnVsbFllYXIiLCJzZXRVVENGdWxsWWVhciIsImZpcnN0V2Vla09mZnNldCIsImRvdyIsImRveSIsImZ3ZCIsImZ3ZGx3IiwiZ2V0VVRDRGF5IiwiZGF5T2ZZZWFyRnJvbVdlZWtzIiwid2VlayIsIndlZWtkYXkiLCJsb2NhbFdlZWtkYXkiLCJ3ZWVrT2Zmc2V0IiwiZGF5T2ZZZWFyIiwicmVzWWVhciIsInJlc0RheU9mWWVhciIsIndlZWtPZlllYXIiLCJyZXNXZWVrIiwid2Vla3NJblllYXIiLCJ3ZWVrT2Zmc2V0TmV4dCIsImxvY2FsZVdlZWsiLCJfd2VlayIsImRlZmF1bHRMb2NhbGVXZWVrIiwibG9jYWxlRmlyc3REYXlPZldlZWsiLCJsb2NhbGVGaXJzdERheU9mWWVhciIsImdldFNldFdlZWsiLCJnZXRTZXRJU09XZWVrIiwid2Vla2RheXNNaW4iLCJ3ZWVrZGF5c1Nob3J0Iiwid2Vla2RheXMiLCJ3ZWVrZGF5c01pblJlZ2V4Iiwid2Vla2RheXNTaG9ydFJlZ2V4Iiwid2Vla2RheXNSZWdleCIsIndlZWtkYXlzUGFyc2UiLCJwYXJzZVdlZWtkYXkiLCJwYXJzZUlzb1dlZWtkYXkiLCJzaGlmdFdlZWtkYXlzIiwid3MiLCJkZWZhdWx0TG9jYWxlV2Vla2RheXMiLCJsb2NhbGVXZWVrZGF5cyIsIl93ZWVrZGF5cyIsImRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0IiwibG9jYWxlV2Vla2RheXNTaG9ydCIsIl93ZWVrZGF5c1Nob3J0IiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluIiwibG9jYWxlV2Vla2RheXNNaW4iLCJfd2Vla2RheXNNaW4iLCJoYW5kbGVTdHJpY3RQYXJzZSQxIiwid2Vla2RheU5hbWUiLCJfd2Vla2RheXNQYXJzZSIsIl9zaG9ydFdlZWtkYXlzUGFyc2UiLCJfbWluV2Vla2RheXNQYXJzZSIsImxvY2FsZVdlZWtkYXlzUGFyc2UiLCJfd2Vla2RheXNQYXJzZUV4YWN0IiwiX2Z1bGxXZWVrZGF5c1BhcnNlIiwiZ2V0U2V0RGF5T2ZXZWVrIiwiZ2V0RGF5IiwiZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIiwiZ2V0U2V0SVNPRGF5T2ZXZWVrIiwiZGVmYXVsdFdlZWtkYXlzUmVnZXgiLCJjb21wdXRlV2Vla2RheXNQYXJzZSIsIl93ZWVrZGF5c1N0cmljdFJlZ2V4IiwiX3dlZWtkYXlzUmVnZXgiLCJkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4IiwiX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCIsIl93ZWVrZGF5c1Nob3J0UmVnZXgiLCJkZWZhdWx0V2Vla2RheXNNaW5SZWdleCIsIl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IiwiX3dlZWtkYXlzTWluUmVnZXgiLCJtaW5QaWVjZXMiLCJtaW5wIiwic2hvcnRwIiwibG9uZ3AiLCJoRm9ybWF0IiwiaG91cnMiLCJrRm9ybWF0IiwibWludXRlcyIsInNlY29uZHMiLCJsb3dlcmNhc2UiLCJtYXRjaE1lcmlkaWVtIiwiX21lcmlkaWVtUGFyc2UiLCJrSW5wdXQiLCJfaXNQbSIsImlzUE0iLCJfbWVyaWRpZW0iLCJwb3MxIiwicG9zMiIsImxvY2FsZUlzUE0iLCJkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSIsImxvY2FsZU1lcmlkaWVtIiwiaXNMb3dlciIsImdldFNldEhvdXIiLCJiYXNlQ29uZmlnIiwiZGF5T2ZNb250aE9yZGluYWxQYXJzZSIsIm1lcmlkaWVtUGFyc2UiLCJsb2NhbGVzIiwibG9jYWxlRmFtaWxpZXMiLCJnbG9iYWxMb2NhbGUiLCJub3JtYWxpemVMb2NhbGUiLCJjaG9vc2VMb2NhbGUiLCJuYW1lcyIsImxvYWRMb2NhbGUiLCJvbGRMb2NhbGUiLCJfYWJiciIsImFsaWFzZWRSZXF1aXJlIiwiZ2V0U2V0R2xvYmFsTG9jYWxlIiwiZ2V0TG9jYWxlIiwiZGVmaW5lTG9jYWxlIiwiYWJiciIsInBhcmVudExvY2FsZSIsInVwZGF0ZUxvY2FsZSIsInRtcExvY2FsZSIsImxpc3RMb2NhbGVzIiwiY2hlY2tPdmVyZmxvdyIsIl9vdmVyZmxvd0RheU9mWWVhciIsIl9vdmVyZmxvd1dlZWtzIiwiX292ZXJmbG93V2Vla2RheSIsImRlZmF1bHRzIiwiY3VycmVudERhdGVBcnJheSIsIm5vd1ZhbHVlIiwiX3VzZVVUQyIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImNvbmZpZ0Zyb21BcnJheSIsImN1cnJlbnREYXRlIiwiZXhwZWN0ZWRXZWVrZGF5IiwieWVhclRvVXNlIiwiZGF5T2ZZZWFyRnJvbVdlZWtJbmZvIiwiX2RheU9mWWVhciIsIl9uZXh0RGF5Iiwic2V0VVRDTWludXRlcyIsImdldFVUQ01pbnV0ZXMiLCJ3Iiwid2Vla1llYXIiLCJ0ZW1wIiwid2Vla2RheU92ZXJmbG93IiwiR0ciLCJXIiwiRSIsImNyZWF0ZUxvY2FsIiwiY3VyV2VlayIsImdnIiwiZXh0ZW5kZWRJc29SZWdleCIsImJhc2ljSXNvUmVnZXgiLCJ0elJlZ2V4IiwiaXNvRGF0ZXMiLCJpc29UaW1lcyIsImFzcE5ldEpzb25SZWdleCIsImNvbmZpZ0Zyb21JU08iLCJhbGxvd1RpbWUiLCJkYXRlRm9ybWF0IiwidGltZUZvcm1hdCIsInR6Rm9ybWF0IiwiY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCIsImV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MiLCJ5ZWFyU3RyIiwibW9udGhTdHIiLCJkYXlTdHIiLCJob3VyU3RyIiwibWludXRlU3RyIiwic2Vjb25kU3RyIiwidW50cnVuY2F0ZVllYXIiLCJwcmVwcm9jZXNzUkZDMjgyMiIsImNoZWNrV2Vla2RheSIsIndlZWtkYXlTdHIiLCJwYXJzZWRJbnB1dCIsIndlZWtkYXlQcm92aWRlZCIsIndlZWtkYXlBY3R1YWwiLCJvYnNPZmZzZXRzIiwiVVQiLCJHTVQiLCJFRFQiLCJFU1QiLCJDRFQiLCJDU1QiLCJNRFQiLCJNU1QiLCJQRFQiLCJQU1QiLCJjYWxjdWxhdGVPZmZzZXQiLCJvYnNPZmZzZXQiLCJtaWxpdGFyeU9mZnNldCIsIm51bU9mZnNldCIsImhtIiwiY29uZmlnRnJvbVJGQzI4MjIiLCJwYXJzZWRBcnJheSIsImNvbmZpZ0Zyb21TdHJpbmciLCJjcmVhdGVGcm9tSW5wdXRGYWxsYmFjayIsIklTT184NjAxIiwiUkZDXzI4MjIiLCJza2lwcGVkIiwic3RyaW5nTGVuZ3RoIiwidG90YWxQYXJzZWRJbnB1dExlbmd0aCIsIm1lcmlkaWVtRml4V3JhcCIsImhvdXIiLCJpc1BtIiwibWVyaWRpZW1Ib3VyIiwiY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5IiwidGVtcENvbmZpZyIsImJlc3RNb21lbnQiLCJzY29yZVRvQmVhdCIsImN1cnJlbnRTY29yZSIsInNjb3JlIiwiY29uZmlnRnJvbU9iamVjdCIsIm1pbnV0ZSIsInNlY29uZCIsIm1pbGxpc2Vjb25kIiwiY3JlYXRlRnJvbUNvbmZpZyIsInByZXBhcmVDb25maWciLCJwcmVwYXJzZSIsImNvbmZpZ0Zyb21JbnB1dCIsImlzVVRDIiwicHJvdG90eXBlTWluIiwicHJvdG90eXBlTWF4IiwicGlja0J5IiwibW9tZW50cyIsIm9yZGVyaW5nIiwiaXNEdXJhdGlvblZhbGlkIiwidW5pdEhhc0RlY2ltYWwiLCJpc1ZhbGlkJDEiLCJjcmVhdGVJbnZhbGlkJDEiLCJjcmVhdGVEdXJhdGlvbiIsIkR1cmF0aW9uIiwieWVhcnMiLCJxdWFydGVycyIsInF1YXJ0ZXIiLCJ3ZWVrcyIsImlzb1dlZWsiLCJkYXlzIiwibWlsbGlzZWNvbmRzIiwiX21pbGxpc2Vjb25kcyIsIl9kYXlzIiwiX2J1YmJsZSIsImlzRHVyYXRpb24iLCJhYnNSb3VuZCIsInJvdW5kIiwic2VwYXJhdG9yIiwidXRjT2Zmc2V0Iiwib2Zmc2V0RnJvbVN0cmluZyIsImNodW5rT2Zmc2V0IiwibWF0Y2hlciIsImNodW5rIiwicGFydHMiLCJjbG9uZVdpdGhPZmZzZXQiLCJzZXRUaW1lIiwibG9jYWwiLCJnZXREYXRlT2Zmc2V0IiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJnZXRTZXRPZmZzZXQiLCJrZWVwTG9jYWxUaW1lIiwia2VlcE1pbnV0ZXMiLCJsb2NhbEFkanVzdCIsIl9jaGFuZ2VJblByb2dyZXNzIiwiYWRkU3VidHJhY3QiLCJnZXRTZXRab25lIiwic2V0T2Zmc2V0VG9VVEMiLCJzZXRPZmZzZXRUb0xvY2FsIiwic3VidHJhY3QiLCJzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCIsInRab25lIiwiaGFzQWxpZ25lZEhvdXJPZmZzZXQiLCJpc0RheWxpZ2h0U2F2aW5nVGltZSIsImlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCIsIl9pc0RTVFNoaWZ0ZWQiLCJpc0xvY2FsIiwiaXNVdGNPZmZzZXQiLCJpc1V0YyIsImFzcE5ldFJlZ2V4IiwiaXNvUmVnZXgiLCJkaWZmUmVzIiwicGFyc2VJc28iLCJtb21lbnRzRGlmZmVyZW5jZSIsImludmFsaWQiLCJpbnAiLCJwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlIiwiaXNBZnRlciIsImlzQmVmb3JlIiwiY3JlYXRlQWRkZXIiLCJkaXJlY3Rpb24iLCJwZXJpb2QiLCJkdXIiLCJpc0FkZGluZyIsImdldENhbGVuZGFyRm9ybWF0IiwibXlNb21lbnQiLCJjYWxlbmRhciQxIiwidGltZSIsImZvcm1hdHMiLCJzb2QiLCJzdGFydE9mIiwiY2FsZW5kYXJGb3JtYXQiLCJsb2NhbElucHV0IiwiZW5kT2YiLCJpc0JldHdlZW4iLCJpbmNsdXNpdml0eSIsImxvY2FsRnJvbSIsImxvY2FsVG8iLCJpc1NhbWUiLCJpbnB1dE1zIiwiaXNTYW1lT3JBZnRlciIsImlzU2FtZU9yQmVmb3JlIiwiYXNGbG9hdCIsInRoYXQiLCJ6b25lRGVsdGEiLCJtb250aERpZmYiLCJ3aG9sZU1vbnRoRGlmZiIsImFuY2hvciIsImFuY2hvcjIiLCJhZGp1c3QiLCJkZWZhdWx0Rm9ybWF0IiwiZGVmYXVsdEZvcm1hdFV0YyIsInRvSVNPU3RyaW5nIiwia2VlcE9mZnNldCIsInRvRGF0ZSIsImluc3BlY3QiLCJ6b25lIiwiZGF0ZXRpbWUiLCJzdWZmaXgiLCJpbnB1dFN0cmluZyIsInBvc3Rmb3JtYXQiLCJodW1hbml6ZSIsImZyb21Ob3ciLCJ0b05vdyIsIm5ld0xvY2FsZURhdGEiLCJsYW5nIiwiTVNfUEVSX1NFQ09ORCIsIk1TX1BFUl9NSU5VVEUiLCJNU19QRVJfSE9VUiIsIk1TX1BFUl80MDBfWUVBUlMiLCJtb2QkMSIsImRpdmlkZW5kIiwiZGl2aXNvciIsImxvY2FsU3RhcnRPZkRhdGUiLCJ1dGNTdGFydE9mRGF0ZSIsInN0YXJ0T2ZEYXRlIiwiaXNvV2Vla2RheSIsInVuaXgiLCJ0b0pTT04iLCJpc1ZhbGlkJDIiLCJwYXJzaW5nRmxhZ3MiLCJpbnZhbGlkQXQiLCJjcmVhdGlvbkRhdGEiLCJpc29XZWVrWWVhciIsImFkZFdlZWtZZWFyRm9ybWF0VG9rZW4iLCJnZXRTZXRXZWVrWWVhciIsImdldFNldFdlZWtZZWFySGVscGVyIiwiZ2V0U2V0SVNPV2Vla1llYXIiLCJnZXRJU09XZWVrc0luWWVhciIsImdldFdlZWtzSW5ZZWFyIiwid2Vla0luZm8iLCJ3ZWVrc1RhcmdldCIsInNldFdlZWtBbGwiLCJkYXlPZlllYXJEYXRhIiwiZ2V0U2V0UXVhcnRlciIsImdldFNldERheU9mTW9udGgiLCJnZXRTZXREYXlPZlllYXIiLCJnZXRTZXRNaW51dGUiLCJnZXRTZXRTZWNvbmQiLCJwYXJzZU1zIiwiZ2V0U2V0TWlsbGlzZWNvbmQiLCJnZXRab25lQWJiciIsImdldFpvbmVOYW1lIiwiaXNvV2Vla3MiLCJpc29XZWVrc0luWWVhciIsInBhcnNlWm9uZSIsImlzRFNUIiwiem9uZUFiYnIiLCJ6b25lTmFtZSIsImRhdGVzIiwiaXNEU1RTaGlmdGVkIiwiY3JlYXRlVW5peCIsImNyZWF0ZUluWm9uZSIsInByZVBhcnNlUG9zdEZvcm1hdCIsInByb3RvJDEiLCJmaXJzdERheU9mWWVhciIsImZpcnN0RGF5T2ZXZWVrIiwiZ2V0JDEiLCJmaWVsZCIsImxpc3RNb250aHNJbXBsIiwib3V0IiwibGlzdFdlZWtkYXlzSW1wbCIsImxvY2FsZVNvcnRlZCIsImxpc3RNb250aHMiLCJsaXN0TW9udGhzU2hvcnQiLCJsaXN0V2Vla2RheXMiLCJsaXN0V2Vla2RheXNTaG9ydCIsImxpc3RXZWVrZGF5c01pbiIsImxhbmdEYXRhIiwibWF0aEFicyIsImFkZFN1YnRyYWN0JDEiLCJzdWJ0cmFjdCQxIiwiYWJzQ2VpbCIsImJ1YmJsZSIsIm1vbnRoc0Zyb21EYXlzIiwibW9udGhzVG9EYXlzIiwiZGF5c1RvTW9udGhzIiwiYXMiLCJ2YWx1ZU9mJDEiLCJtYWtlQXMiLCJhc01pbGxpc2Vjb25kcyIsImFzU2Vjb25kcyIsImFzTWludXRlcyIsImFzSG91cnMiLCJhc0RheXMiLCJhc1dlZWtzIiwiYXNNb250aHMiLCJhc1F1YXJ0ZXJzIiwiYXNZZWFycyIsImNsb25lJDEiLCJnZXQkMiIsIm1ha2VHZXR0ZXIiLCJ0aHJlc2hvbGRzIiwic3Vic3RpdHV0ZVRpbWVBZ28iLCJyZWxhdGl2ZVRpbWUkMSIsInBvc05lZ0R1cmF0aW9uIiwiZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmciLCJyb3VuZGluZ0Z1bmN0aW9uIiwiZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkIiwidGhyZXNob2xkIiwibGltaXQiLCJ3aXRoU3VmZml4IiwiYWJzJDEiLCJ0b0lTT1N0cmluZyQxIiwiWSIsIkQiLCJ0b0ZpeGVkIiwidG90YWwiLCJ0b3RhbFNpZ24iLCJ5bVNpZ24iLCJkYXlzU2lnbiIsImhtc1NpZ24iLCJwcm90byQyIiwidG9Jc29TdHJpbmciLCJyZWxhdGl2ZVRpbWVSb3VuZGluZyIsInJlbGF0aXZlVGltZVRocmVzaG9sZCIsIkhUTUw1X0ZNVCIsIkRBVEVUSU1FX0xPQ0FMIiwiREFURVRJTUVfTE9DQUxfU0VDT05EUyIsIkRBVEVUSU1FX0xPQ0FMX01TIiwiVElNRSIsIlRJTUVfU0VDT05EUyIsIlRJTUVfTVMiLCJyZXF1aXJlJCQwIiwibW9tZW50IiwiY29udmVyc2lvbnMiLCJyZ2IyaHNsIiwicmdiMmhzdiIsInJnYjJod2IiLCJyZ2IyY215ayIsInJnYjJrZXl3b3JkIiwicmdiMnh5eiIsInJnYjJsYWIiLCJyZ2IybGNoIiwiaHNsMnJnYiIsImhzbDJoc3YiLCJoc2wyaHdiIiwiaHNsMmNteWsiLCJoc2wya2V5d29yZCIsImhzdjJyZ2IiLCJoc3YyaHNsIiwiaHN2Mmh3YiIsImhzdjJjbXlrIiwiaHN2MmtleXdvcmQiLCJod2IycmdiIiwiaHdiMmhzbCIsImh3YjJoc3YiLCJod2IyY215ayIsImh3YjJrZXl3b3JkIiwiY215azJyZ2IiLCJjbXlrMmhzbCIsImNteWsyaHN2IiwiY215azJod2IiLCJjbXlrMmtleXdvcmQiLCJrZXl3b3JkMnJnYiIsImtleXdvcmQyaHNsIiwia2V5d29yZDJoc3YiLCJrZXl3b3JkMmh3YiIsImtleXdvcmQyY215ayIsImtleXdvcmQybGFiIiwia2V5d29yZDJ4eXoiLCJ4eXoycmdiIiwieHl6MmxhYiIsInh5ejJsY2giLCJsYWIyeHl6IiwibGFiMnJnYiIsImxhYjJsY2giLCJsY2gybGFiIiwibGNoMnh5eiIsImxjaDJyZ2IiLCJyZ2IiLCJyIiwiZyIsImRlbHRhIiwicmV2ZXJzZUtleXdvcmRzIiwieiIsInh5eiIsImhzbCIsInQxIiwidDIiLCJ0MyIsInN2IiwiaHN2IiwiaGkiLCJmIiwicSIsInNsIiwiaHdiIiwid2giLCJibCIsInJhdGlvIiwiY215ayIsImxhYiIsInkyIiwiaHIiLCJhdGFuMiIsIlBJIiwic3FydCIsImxjaCIsImNvcyIsInNpbiIsImtleXdvcmQiLCJjc3NLZXl3b3JkcyIsImFsaWNlYmx1ZSIsImFudGlxdWV3aGl0ZSIsImFxdWEiLCJhcXVhbWFyaW5lIiwiYXp1cmUiLCJiZWlnZSIsImJpc3F1ZSIsImJsYWNrIiwiYmxhbmNoZWRhbG1vbmQiLCJibHVlIiwiYmx1ZXZpb2xldCIsImJyb3duIiwiYnVybHl3b29kIiwiY2FkZXRibHVlIiwiY2hhcnRyZXVzZSIsImNob2NvbGF0ZSIsImNvcmFsIiwiY29ybmZsb3dlcmJsdWUiLCJjb3Juc2lsayIsImNyaW1zb24iLCJjeWFuIiwiZGFya2JsdWUiLCJkYXJrY3lhbiIsImRhcmtnb2xkZW5yb2QiLCJkYXJrZ3JheSIsImRhcmtncmVlbiIsImRhcmtncmV5IiwiZGFya2toYWtpIiwiZGFya21hZ2VudGEiLCJkYXJrb2xpdmVncmVlbiIsImRhcmtvcmFuZ2UiLCJkYXJrb3JjaGlkIiwiZGFya3JlZCIsImRhcmtzYWxtb24iLCJkYXJrc2VhZ3JlZW4iLCJkYXJrc2xhdGVibHVlIiwiZGFya3NsYXRlZ3JheSIsImRhcmtzbGF0ZWdyZXkiLCJkYXJrdHVycXVvaXNlIiwiZGFya3Zpb2xldCIsImRlZXBwaW5rIiwiZGVlcHNreWJsdWUiLCJkaW1ncmF5IiwiZGltZ3JleSIsImRvZGdlcmJsdWUiLCJmaXJlYnJpY2siLCJmbG9yYWx3aGl0ZSIsImZvcmVzdGdyZWVuIiwiZnVjaHNpYSIsImdhaW5zYm9ybyIsImdob3N0d2hpdGUiLCJnb2xkIiwiZ29sZGVucm9kIiwiZ3JheSIsImdyZWVuIiwiZ3JlZW55ZWxsb3ciLCJncmV5IiwiaG9uZXlkZXciLCJob3RwaW5rIiwiaW5kaWFucmVkIiwiaW5kaWdvIiwiaXZvcnkiLCJraGFraSIsImxhdmVuZGVyIiwibGF2ZW5kZXJibHVzaCIsImxhd25ncmVlbiIsImxlbW9uY2hpZmZvbiIsImxpZ2h0Ymx1ZSIsImxpZ2h0Y29yYWwiLCJsaWdodGN5YW4iLCJsaWdodGdvbGRlbnJvZHllbGxvdyIsImxpZ2h0Z3JheSIsImxpZ2h0Z3JlZW4iLCJsaWdodGdyZXkiLCJsaWdodHBpbmsiLCJsaWdodHNhbG1vbiIsImxpZ2h0c2VhZ3JlZW4iLCJsaWdodHNreWJsdWUiLCJsaWdodHNsYXRlZ3JheSIsImxpZ2h0c2xhdGVncmV5IiwibGlnaHRzdGVlbGJsdWUiLCJsaWdodHllbGxvdyIsImxpbWUiLCJsaW1lZ3JlZW4iLCJsaW5lbiIsIm1hZ2VudGEiLCJtYXJvb24iLCJtZWRpdW1hcXVhbWFyaW5lIiwibWVkaXVtYmx1ZSIsIm1lZGl1bW9yY2hpZCIsIm1lZGl1bXB1cnBsZSIsIm1lZGl1bXNlYWdyZWVuIiwibWVkaXVtc2xhdGVibHVlIiwibWVkaXVtc3ByaW5nZ3JlZW4iLCJtZWRpdW10dXJxdW9pc2UiLCJtZWRpdW12aW9sZXRyZWQiLCJtaWRuaWdodGJsdWUiLCJtaW50Y3JlYW0iLCJtaXN0eXJvc2UiLCJtb2NjYXNpbiIsIm5hdmFqb3doaXRlIiwibmF2eSIsIm9sZGxhY2UiLCJvbGl2ZSIsIm9saXZlZHJhYiIsIm9yYW5nZSIsIm9yYW5nZXJlZCIsIm9yY2hpZCIsInBhbGVnb2xkZW5yb2QiLCJwYWxlZ3JlZW4iLCJwYWxldHVycXVvaXNlIiwicGFsZXZpb2xldHJlZCIsInBhcGF5YXdoaXAiLCJwZWFjaHB1ZmYiLCJwZXJ1IiwicGluayIsInBsdW0iLCJwb3dkZXJibHVlIiwicHVycGxlIiwicmViZWNjYXB1cnBsZSIsInJlZCIsInJvc3licm93biIsInJveWFsYmx1ZSIsInNhZGRsZWJyb3duIiwic2FsbW9uIiwic2FuZHlicm93biIsInNlYWdyZWVuIiwic2Vhc2hlbGwiLCJzaWVubmEiLCJzaWx2ZXIiLCJza3libHVlIiwic2xhdGVibHVlIiwic2xhdGVncmF5Iiwic2xhdGVncmV5Iiwic25vdyIsInNwcmluZ2dyZWVuIiwic3RlZWxibHVlIiwidGFuIiwidGVhbCIsInRoaXN0bGUiLCJ0b21hdG8iLCJ0dXJxdW9pc2UiLCJ2aW9sZXQiLCJ3aGVhdCIsIndoaXRlIiwid2hpdGVzbW9rZSIsInllbGxvdyIsInllbGxvd2dyZWVuIiwiQ29udmVydGVyIiwicGFpciIsImNvbnZzIiwicm91dGVTcGFjZSIsImdldFZhbHVlcyIsInNldFZhbHVlcyIsInZhbHMiLCJmc3BhY2UiLCJjb2xvckNvbnZlcnQiLCJjb2xvck5hbWUiLCJjb2xvclN0cmluZyIsImdldFJnYmEiLCJnZXRIc2xhIiwiZ2V0UmdiIiwiZ2V0SHNsIiwiZ2V0SHdiIiwiZ2V0QWxwaGEiLCJoZXhTdHJpbmciLCJyZ2JTdHJpbmciLCJyZ2JhU3RyaW5nIiwicGVyY2VudFN0cmluZyIsInBlcmNlbnRhU3RyaW5nIiwiaHNsU3RyaW5nIiwiaHNsYVN0cmluZyIsImh3YlN0cmluZyIsImhleCIsInJnYmEiLCJwZXIiLCJoZXhBbHBoYSIsInNjYWxlIiwiYWxwaGEiLCJoc2xhIiwiaGV4RG91YmxlIiwicmV2ZXJzZU5hbWVzIiwibnVtIiwiQ29sb3IiLCJsaWdodG5lc3MiLCJ3aGl0ZW5lc3MiLCJzZXRTcGFjZSIsInJnYkFycmF5IiwiaHNsQXJyYXkiLCJoc3ZBcnJheSIsImh3YkFycmF5IiwiY215a0FycmF5IiwicmdiYUFycmF5IiwiaHNsYUFycmF5Iiwic2V0Q2hhbm5lbCIsImh1ZSIsInNhdHVyYXRpb24iLCJzYXR1cmF0aW9udiIsImJsYWNrbmVzcyIsInJnYk51bWJlciIsImx1bWlub3NpdHkiLCJsdW0iLCJjaGFuIiwiY29udHJhc3QiLCJjb2xvcjIiLCJsdW0xIiwibHVtMiIsImxldmVsIiwiY29udHJhc3RSYXRpbyIsImRhcmsiLCJ5aXEiLCJsaWdodCIsIm5lZ2F0ZSIsImxpZ2h0ZW4iLCJkYXJrZW4iLCJzYXR1cmF0ZSIsImRlc2F0dXJhdGUiLCJ3aGl0ZW4iLCJibGFja2VuIiwiZ3JleXNjYWxlIiwiY2xlYXJlciIsIm9wYXF1ZXIiLCJyb3RhdGUiLCJkZWdyZWVzIiwibWl4IiwibWl4aW5Db2xvciIsIndlaWdodCIsImNvbG9yMSIsIncxIiwidzIiLCJzcGFjZXMiLCJtYXhlcyIsImNoYW5zIiwiY2FwcGVkIiwic25hbWUiLCJzdmFsdWVzIiwiY2hhcnRqc0NvbG9yIiwiaGVscGVycyIsImlzTnVsbE9yVW5kZWYiLCJ2YWx1ZU9yRGVmYXVsdCIsInZhbHVlQXRJbmRleE9yRGVmYXVsdCIsImVhY2giLCJsb29wYWJsZSIsInJldmVyc2UiLCJhcnJheUVxdWFscyIsImEwIiwiYTEiLCJpbGVuIiwidjAiLCJ2MSIsImtsZW4iLCJfbWVyZ2VyIiwidHZhbCIsInN2YWwiLCJfbWVyZ2VySWYiLCJtZXJnZUlmIiwibWVyZ2VyIiwic2V0Rm4iLCJpbmhlcml0cyIsImV4dGVuc2lvbnMiLCJtZSIsIkNoYXJ0RWxlbWVudCIsIlN1cnJvZ2F0ZSIsIl9fc3VwZXJfXyIsImhlbHBlcnNfY29yZSIsImNhbGxDYWxsYmFjayIsImZyb21JbmRleCIsImdldFZhbHVlT3JEZWZhdWx0IiwiZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0IiwiZWZmZWN0cyIsImxpbmVhciIsImVhc2VJblF1YWQiLCJlYXNlT3V0UXVhZCIsImVhc2VJbk91dFF1YWQiLCJlYXNlSW5DdWJpYyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJlYXNlSW5TaW5lIiwiZWFzZU91dFNpbmUiLCJlYXNlSW5PdXRTaW5lIiwiZWFzZUluRXhwbyIsImVhc2VPdXRFeHBvIiwiZWFzZUluT3V0RXhwbyIsImVhc2VJbkNpcmMiLCJlYXNlT3V0Q2lyYyIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5FbGFzdGljIiwiYXNpbiIsImVhc2VPdXRFbGFzdGljIiwiZWFzZUluT3V0RWxhc3RpYyIsImVhc2VJbkJhY2siLCJlYXNlT3V0QmFjayIsImVhc2VJbk91dEJhY2siLCJlYXNlSW5Cb3VuY2UiLCJlYXNlT3V0Qm91bmNlIiwiZWFzZUluT3V0Qm91bmNlIiwiaGVscGVyc19lYXNpbmciLCJlYXNpbmdFZmZlY3RzIiwiUkFEX1BFUl9ERUciLCJET1VCTEVfUEkiLCJIQUxGX1BJIiwiUVVBUlRFUl9QSSIsIlRXT19USElSRFNfUEkiLCJleHBvcnRzJDEiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInJvdW5kZWRSZWN0IiwicmFkaXVzIiwiYm90dG9tIiwibW92ZVRvIiwiYXJjIiwiY2xvc2VQYXRoIiwicmVjdCIsImRyYXdQb2ludCIsInJvdGF0aW9uIiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JuZXJSYWRpdXMiLCJyYWQiLCJkcmF3SW1hZ2UiLCJiZWdpblBhdGgiLCJsaW5lVG8iLCJTUVJUMV8yIiwiZmlsbCIsInN0cm9rZSIsIl9pc1BvaW50SW5BcmVhIiwicG9pbnQiLCJhcmVhIiwiZXBzaWxvbiIsImNsaXBBcmVhIiwic2F2ZSIsImNsaXAiLCJ1bmNsaXBBcmVhIiwicmVzdG9yZSIsInByZXZpb3VzIiwiZmxpcCIsInN0ZXBwZWQiLCJzdGVwcGVkTGluZSIsIm1pZHBvaW50IiwidGVuc2lvbiIsImJlemllckN1cnZlVG8iLCJjb250cm9sUG9pbnRQcmV2aW91c1giLCJjb250cm9sUG9pbnROZXh0WCIsImNvbnRyb2xQb2ludFByZXZpb3VzWSIsImNvbnRyb2xQb2ludE5leHRZIiwiaGVscGVyc19jYW52YXMiLCJkcmF3Um91bmRlZFJlY3RhbmdsZSIsIl9zZXQiLCJzY29wZSIsImRlZmF1bHRDb2xvciIsImRlZmF1bHRGb250Q29sb3IiLCJkZWZhdWx0Rm9udEZhbWlseSIsImRlZmF1bHRGb250U2l6ZSIsImRlZmF1bHRGb250U3R5bGUiLCJkZWZhdWx0TGluZUhlaWdodCIsInNob3dMaW5lcyIsImNvcmVfZGVmYXVsdHMiLCJ0b0ZvbnRTdHJpbmciLCJmb250IiwiZmFtaWx5IiwiaGVscGVyc19vcHRpb25zIiwidG9MaW5lSGVpZ2h0IiwidG9QYWRkaW5nIiwiX3BhcnNlRm9udCIsImdsb2JhbERlZmF1bHRzIiwiZm9udEZhbWlseSIsImxpbmVIZWlnaHQiLCJmb250U3R5bGUiLCJpbnB1dHMiLCJoZWxwZXJzJDEiLCJlYXNpbmciLCJjYW52YXMiLCJlYXNlIiwib3JpZ2luIiwiYzAiLCJjMSIsIkVsZW1lbnQiLCJjb25maWd1cmF0aW9uIiwiaW5pdGlhbGl6ZSIsImhpZGRlbiIsInBpdm90IiwiX3ZpZXciLCJfbW9kZWwiLCJfc3RhcnQiLCJ0b29sdGlwUG9zaXRpb24iLCJoYXNWYWx1ZSIsImNvcmVfZWxlbWVudCIsImV4cG9ydHMkMiIsImN1cnJlbnRTdGVwIiwibnVtU3RlcHMiLCJvbkFuaW1hdGlvblByb2dyZXNzIiwib25BbmltYXRpb25Db21wbGV0ZSIsImNvcmVfYW5pbWF0aW9uIiwiYW5pbWF0aW9uIiwib25Qcm9ncmVzcyIsIm9uQ29tcGxldGUiLCJjb3JlX2FuaW1hdGlvbnMiLCJhbmltYXRpb25zIiwicmVxdWVzdCIsImFkZEFuaW1hdGlvbiIsInN0YXJ0VGltZSIsImFuaW1hdGluZyIsImNhbmNlbEFuaW1hdGlvbiIsImZpbmRJbmRleCIsInJlcXVlc3RBbmltRnJhbWUiLCJzdGFydERpZ2VzdCIsIm5leHRTdGVwIiwiYXJyYXlFdmVudHMiLCJsaXN0ZW5BcnJheUV2ZW50cyIsImxpc3RlbmVyIiwiX2NoYXJ0anMiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwic3R1YiIsIkRhdGFzZXRDb250cm9sbGVyIiwiZGF0YXNldEluZGV4IiwiZGF0YXNldEVsZW1lbnRUeXBlIiwiZGF0YUVsZW1lbnRUeXBlIiwibGlua1NjYWxlcyIsImFkZEVsZW1lbnRzIiwidXBkYXRlSW5kZXgiLCJnZXRNZXRhIiwiZ2V0RGF0YXNldCIsInhBeGlzSUQiLCJzY2FsZXMiLCJ4QXhlcyIsInlBeGlzSUQiLCJ5QXhlcyIsImdldERhdGFzZXRNZXRhIiwiZ2V0U2NhbGVGb3JJZCIsInNjYWxlSUQiLCJfZ2V0VmFsdWVTY2FsZUlkIiwiX2dldEluZGV4U2NhbGVJZCIsIl9nZXRWYWx1ZVNjYWxlIiwiX2dldEluZGV4U2NhbGUiLCJyZXNldCIsImNyZWF0ZU1ldGFEYXRhc2V0IiwiX2RhdGFzZXRJbmRleCIsImNyZWF0ZU1ldGFEYXRhIiwiX2luZGV4IiwibWV0YURhdGEiLCJhZGRFbGVtZW50QW5kUmVzZXQiLCJ1cGRhdGVFbGVtZW50IiwiYnVpbGRPclVwZGF0ZUVsZW1lbnRzIiwicmVzeW5jRWxlbWVudHMiLCJlYXNpbmdWYWx1ZSIsImVsZW1lbnRzIiwiZHJhdyIsInJlbW92ZUhvdmVyU3R5bGUiLCIkcHJldmlvdXNTdHlsZSIsInNldEhvdmVyU3R5bGUiLCJjdXN0b20iLCJnZXRIb3ZlckNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJXaWR0aCIsImhvdmVyQmFja2dyb3VuZENvbG9yIiwiaG92ZXJCb3JkZXJDb2xvciIsImhvdmVyQm9yZGVyV2lkdGgiLCJudW1NZXRhIiwibnVtRGF0YSIsImluc2VydEVsZW1lbnRzIiwib25EYXRhUHVzaCIsIm9uRGF0YVBvcCIsIm9uRGF0YVNoaWZ0Iiwib25EYXRhU3BsaWNlIiwib25EYXRhVW5zaGlmdCIsImNvcmVfZGF0YXNldENvbnRyb2xsZXIiLCJib3JkZXJBbGlnbiIsImVsZW1lbnRfYXJjIiwiaW5MYWJlbFJhbmdlIiwibW91c2VYIiwiaG92ZXJSYWRpdXMiLCJpblJhbmdlIiwiY2hhcnRYIiwiY2hhcnRZIiwicG9pbnRSZWxhdGl2ZVBvc2l0aW9uIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJhbmdsZSIsImRpc3RhbmNlIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiYmV0d2VlbkFuZ2xlcyIsIndpdGhpblJhZGl1cyIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJnZXRDZW50ZXJQb2ludCIsImhhbGZBbmdsZSIsImhhbGZSYWRpdXMiLCJnZXRBcmVhIiwiY2VudHJlQW5nbGUiLCJyYW5nZUZyb21DZW50cmUiLCJzQSIsImVBIiwicGl4ZWxNYXJnaW4iLCJhbmdsZU1hcmdpbiIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImxpbmVKb2luIiwic3Ryb2tlU3R5bGUiLCJ2YWx1ZU9yRGVmYXVsdCQxIiwibGluZSIsImJvcmRlckNhcFN0eWxlIiwiYm9yZGVyRGFzaCIsImJvcmRlckRhc2hPZmZzZXQiLCJib3JkZXJKb2luU3R5bGUiLCJjYXBCZXppZXJQb2ludHMiLCJlbGVtZW50X2xpbmUiLCJzcGFuR2FwcyIsInBvaW50cyIsIl9jaGlsZHJlbiIsImdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cyIsImxhc3REcmF3bkluZGV4IiwiY3VycmVudFZNIiwiX2xvb3AiLCJsaW5lQ2FwIiwic2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsInByZXZpb3VzSXRlbSIsInNraXAiLCJ2YWx1ZU9yRGVmYXVsdCQyIiwiZGVmYXVsdENvbG9yJDEiLCJwb2ludFN0eWxlIiwiaGl0UmFkaXVzIiwieFJhbmdlIiwieVJhbmdlIiwibW91c2VZIiwiZWxlbWVudF9wb2ludCIsImluWFJhbmdlIiwiaW5ZUmFuZ2UiLCJwYWRkaW5nIiwiY2hhcnRBcmVhIiwiZGVmYXVsdENvbG9yJDIiLCJyZWN0YW5nbGUiLCJib3JkZXJTa2lwcGVkIiwiaXNWZXJ0aWNhbCIsImdldEJhckJvdW5kcyIsIngxIiwieDIiLCJ5MSIsImhhbGYiLCJzd2FwIiwib3JpZyIsInYyIiwicGFyc2VCb3JkZXJTa2lwcGVkIiwiZWRnZSIsImhvcml6b250YWwiLCJwYXJzZUJvcmRlcldpZHRoIiwibWF4VyIsIm1heEgiLCJib3VuZGluZ1JlY3RzIiwiYm91bmRzIiwiYm9yZGVyIiwib3V0ZXIiLCJpbm5lciIsInNraXBYIiwic2tpcFkiLCJlbGVtZW50X3JlY3RhbmdsZSIsInJlY3RzIiwiZmlsbFJlY3QiLCJBcmMiLCJMaW5lIiwiUG9pbnQiLCJSZWN0YW5nbGUiLCJyZXNvbHZlJDEiLCJob3ZlciIsImNhdGVnb3J5UGVyY2VudGFnZSIsImJhclBlcmNlbnRhZ2UiLCJncmlkTGluZXMiLCJvZmZzZXRHcmlkTGluZXMiLCJjb21wdXRlTWluU2FtcGxlU2l6ZSIsInBpeGVscyIsImlzSG9yaXpvbnRhbCIsInRpY2tzIiwiZ2V0VGlja3MiLCJjdXJyIiwiZ2V0UGl4ZWxGb3JUaWNrIiwiY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzIiwicnVsZXIiLCJ0aGlja25lc3MiLCJiYXJUaGlja25lc3MiLCJzdGFja0NvdW50IiwiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsInBlcmNlbnQiLCJjb250cm9sbGVyX2JhciIsImJhciIsIl9ydWxlciIsImdldFJ1bGVyIiwiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsIl94U2NhbGUiLCJfeVNjYWxlIiwiZGF0YXNldExhYmVsIiwiX3VwZGF0ZUVsZW1lbnRHZW9tZXRyeSIsInZzY2FsZSIsImdldEJhc2VQaXhlbCIsInZwaXhlbHMiLCJjYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyIsImlwaXhlbHMiLCJjYWxjdWxhdGVCYXJJbmRleFBpeGVscyIsImhlYWQiLCJjZW50ZXIiLCJfZ2V0U3RhY2tzIiwic3RhY2tzIiwiaXNEYXRhc2V0VmlzaWJsZSIsImdldFN0YWNrQ291bnQiLCJnZXRTdGFja0luZGV4IiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsImdldFJpZ2h0VmFsdWUiLCJtaW5CYXJMZW5ndGgiLCJpbWV0YSIsIml2YWx1ZSIsImNvbnRyb2xsZXIiLCJzdGFja0luZGV4IiwibWF4QmFyVGhpY2tuZXNzIiwiSW5maW5pdHkiLCJkYXRhSW5kZXgiLCJ2YWx1ZU9yRGVmYXVsdCQzIiwicmVzb2x2ZSQyIiwicG9zaXRpb24iLCJ0b29sdGlwcyIsImRhdGFQb2ludCIsInhMYWJlbCIsInlMYWJlbCIsImNvbnRyb2xsZXJfYnViYmxlIiwieFNjYWxlIiwieVNjYWxlIiwiZHNJbmRleCIsImdldFBpeGVsRm9yRGVjaW1hbCIsIl9vcHRpb25zIiwicmVzb2x2ZSQzIiwidmFsdWVPckRlZmF1bHQkNCIsImFuaW1hdGVSb3RhdGUiLCJhbmltYXRlU2NhbGUiLCJsZWdlbmRDYWxsYmFjayIsImxlZ2VuZCIsImdlbmVyYXRlTGFiZWxzIiwiZHMiLCJhcmNPcHRzIiwiYnciLCJvbkNsaWNrIiwibGVnZW5kSXRlbSIsImN1dG91dFBlcmNlbnRhZ2UiLCJjaXJjdW1mZXJlbmNlIiwidG9vbHRpcEl0ZW0iLCJkYXRhTGFiZWwiLCJjb250cm9sbGVyX2RvdWdobnV0IiwiZ2V0UmluZ0luZGV4IiwicmluZ0luZGV4IiwiYXZhaWxhYmxlV2lkdGgiLCJhdmFpbGFibGVIZWlnaHQiLCJtaW5TaXplIiwiYXJjcyIsImNoYXJ0V2VpZ2h0IiwiX2dldFJpbmdXZWlnaHQiLCJjb250YWluczAiLCJjb250YWluczkwIiwiY29udGFpbnMxODAiLCJjb250YWluczI3MCIsImN1dG91dCIsImdldE1heEJvcmRlcldpZHRoIiwicmFkaXVzTGVuZ3RoIiwiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImNhbGN1bGF0ZVRvdGFsIiwiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCJhbmltYXRpb25PcHRzIiwiY2VudGVyWCIsImNlbnRlclkiLCJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwiaG92ZXJXaWR0aCIsInJpbmdXZWlnaHRPZmZzZXQiLCJkYXRhU2V0SW5kZXgiLCJheGlzIiwiY29udHJvbGxlcl9ob3Jpem9udGFsQmFyIiwidmFsdWVPckRlZmF1bHQkNSIsInJlc29sdmUkNCIsImlzUG9pbnRJbkFyZWEiLCJsaW5lRW5hYmxlZCIsInNob3dMaW5lIiwiY29udHJvbGxlcl9saW5lIiwibGluZVRlbnNpb24iLCJfc2NhbGUiLCJfcmVzb2x2ZUxpbmVPcHRpb25zIiwidXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsImxpbmVNb2RlbCIsIl9yZXNvbHZlUG9pbnRPcHRpb25zIiwiY2FsY3VsYXRlUG9pbnRZIiwiRUxFTUVOVF9PUFRJT05TIiwiZWxlbWVudE9wdGlvbnMiLCJzdW1Qb3MiLCJzdW1OZWciLCJkc01ldGEiLCJzdGFja2VkUmlnaHRWYWx1ZSIsInJpZ2h0VmFsdWUiLCJjb250cm9sUG9pbnRzIiwicHQiLCJjYXBDb250cm9sUG9pbnQiLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwic3BsaW5lQ3VydmVNb25vdG9uZSIsInNwbGluZUN1cnZlIiwibmV4dEl0ZW0iLCJoYWxmQm9yZGVyV2lkdGgiLCJyZXNvbHZlJDUiLCJhbmdsZUxpbmVzIiwicG9pbnRMYWJlbHMiLCJiZWdpbkF0WmVybyIsImNvbnRyb2xsZXJfcG9sYXJBcmVhIiwic3RhcnRzIiwiX3N0YXJ0cyIsImFuZ2xlcyIsIl9hbmdsZXMiLCJfdXBkYXRlUmFkaXVzIiwiY291bnRWaXNpYmxlRWxlbWVudHMiLCJfY29tcHV0ZUFuZ2xlIiwiZ2V0VmlzaWJsZURhdGFzZXRDb3VudCIsInhDZW50ZXIiLCJ5Q2VudGVyIiwiZGF0YXNldFN0YXJ0QW5nbGUiLCJnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSIsInJlc2V0UmFkaXVzIiwiZG91Z2hudXQiLCJjb250cm9sbGVyX3BpZSIsInZhbHVlT3JEZWZhdWx0JDYiLCJyZXNvbHZlJDYiLCJjb250cm9sbGVyX3JhZGFyIiwicG9pbnRQb3NpdGlvbiIsImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsImNvbnRyb2xsZXJfc2NhdHRlciIsImNvbnRyb2xsZXJzIiwiaG9yaXpvbnRhbEJhciIsInBvbGFyQXJlYSIsInBpZSIsInJhZGFyIiwic2NhdHRlciIsImdldFJlbGF0aXZlUG9zaXRpb24iLCJwYXJzZVZpc2libGVJdGVtcyIsImpsZW4iLCJnZXRJbnRlcnNlY3RJdGVtcyIsImdldE5lYXJlc3RJdGVtcyIsImludGVyc2VjdCIsImRpc3RhbmNlTWV0cmljIiwibWluRGlzdGFuY2UiLCJQT1NJVElWRV9JTkZJTklUWSIsIm5lYXJlc3RJdGVtcyIsImdldERpc3RhbmNlTWV0cmljRm9yQXhpcyIsInVzZVgiLCJ1c2VZIiwicHQxIiwicHQyIiwiZGVsdGFYIiwiZGVsdGFZIiwiaW5kZXhNb2RlIiwiY29yZV9pbnRlcmFjdGlvbiIsIm1vZGVzIiwic2luZ2xlIiwibmVhcmVzdCIsImludGVyc2VjdHNJdGVtIiwiZmlsdGVyQnlQb3NpdGlvbiIsIndoZXJlIiwic29ydEJ5V2VpZ2h0IiwiX3RtcEluZGV4XyIsImZpbmRNYXhQYWRkaW5nIiwiYm94ZXMiLCJib3giLCJnZXRQYWRkaW5nIiwiYm94UGFkZGluZyIsImFkZFNpemVCeVBvc2l0aW9uIiwibGF5b3V0IiwiY29yZV9sYXlvdXRzIiwiYWRkQm94IiwiZnVsbFdpZHRoIiwicmVtb3ZlQm94IiwibGF5b3V0SXRlbSIsImNvbmZpZ3VyZSIsImxheW91dE9wdGlvbnMiLCJsZWZ0UGFkZGluZyIsInJpZ2h0UGFkZGluZyIsInRvcFBhZGRpbmciLCJib3R0b21QYWRkaW5nIiwibGVmdEJveGVzIiwicmlnaHRCb3hlcyIsInRvcEJveGVzIiwiYm90dG9tQm94ZXMiLCJjaGFydEFyZWFCb3hlcyIsInZlcnRpY2FsQm94ZXMiLCJob3Jpem9udGFsQm94ZXMiLCJvdXRlckJveGVzIiwiY2hhcnRXaWR0aCIsImNoYXJ0SGVpZ2h0IiwiY2hhcnRBcmVhV2lkdGgiLCJ2ZXJ0aWNhbEJveFdpZHRoIiwibWF4Q2hhcnRBcmVhV2lkdGgiLCJtYXhDaGFydEFyZWFIZWlnaHQiLCJvdXRlckJveFNpemVzIiwibWluQm94U2l6ZXMiLCJtYXhQYWRkaW5nIiwiZ2V0TWluaW11bUJveFNpemUiLCJmaXRCb3giLCJtaW5Cb3hTaXplIiwiZmluZE5leHRXaGVyZSIsIm1pbkJveCIsInNjYWxlTWFyZ2luIiwiZmluYWxGaXRWZXJ0aWNhbEJveCIsImxlZnRQYWRkaW5nQWRkaXRpb24iLCJ0b3BQYWRkaW5nQWRkaXRpb24iLCJuZXdNYXhDaGFydEFyZWFIZWlnaHQiLCJuZXdNYXhDaGFydEFyZWFXaWR0aCIsInBsYWNlQm94IiwicGxhdGZvcm1fYmFzaWMiLCJhY3F1aXJlQ29udGV4dCIsImdldENvbnRleHQiLCJwbGF0Zm9ybV9kb20iLCJwbGF0Zm9ybV9kb20kMSIsImdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UiLCJzdHlsZXNoZWV0IiwiRVhQQU5ET19LRVkiLCJDU1NfUFJFRklYIiwiQ1NTX1NJWkVfTU9OSVRPUiIsIkNTU19SRU5ERVJfTU9OSVRPUiIsIkNTU19SRU5ERVJfQU5JTUFUSU9OIiwiQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyIsIkVWRU5UX1RZUEVTIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInBvaW50ZXJ1cCIsInBvaW50ZXJsZWF2ZSIsInBvaW50ZXJvdXQiLCJyZWFkVXNlZFNpemUiLCJpbml0Q2FudmFzIiwicmVuZGVySGVpZ2h0IiwicmVuZGVyV2lkdGgiLCJkaXNwbGF5V2lkdGgiLCJhc3BlY3RSYXRpbyIsImRpc3BsYXlIZWlnaHQiLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwic3VwcG9ydHMiLCJldmVudExpc3RlbmVyT3B0aW9ucyIsImFkZExpc3RlbmVyIiwicmVtb3ZlTGlzdGVuZXIiLCJuYXRpdmVFdmVudCIsImZyb21OYXRpdmVFdmVudCIsInRocm90dGxlZCIsInRpY2tpbmciLCJjcmVhdGVEaXYiLCJjbGFzc05hbWUiLCJjcmVhdGVSZXNpemVyIiwibWF4U2l6ZSIsInJlc2l6ZXIiLCJleHBhbmQiLCJzaHJpbmsiLCJfcmVzZXQiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwib25TY3JvbGwiLCJ3YXRjaEZvclJlbmRlciIsImV4cGFuZG8iLCJyZW5kZXJQcm94eSIsImFuaW1hdGlvbk5hbWUiLCJyZWZsb3ciLCJvZmZzZXRQYXJlbnQiLCJ1bndhdGNoRm9yUmVuZGVyIiwiYWRkUmVzaXplTGlzdGVuZXIiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwiY2xpZW50V2lkdGgiLCJyZW1vdmVSZXNpemVMaXN0ZW5lciIsImluamVjdENTUyIsIl9zdHlsZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwicGxhdGZvcm1fZG9tJDIiLCJkaXNhYmxlQ1NTSW5qZWN0aW9uIiwiX2VuYWJsZWQiLCJfZW5zdXJlTG9hZGVkIiwiX2xvYWRlZCIsImdldEVsZW1lbnRCeUlkIiwicmVsZWFzZUNvbnRleHQiLCJwcm94aWVzIiwiYWRkRXZlbnQiLCJyZW1vdmVFdmVudCIsImltcGxlbWVudGF0aW9uIiwicGx1Z2lucyIsImNvcmVfcGx1Z2lucyIsIl9wbHVnaW5zIiwiX2NhY2hlSWQiLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJpZHgiLCJnZXRBbGwiLCJkZXNjcmlwdG9ycyIsImRlc2NyaXB0b3IiLCIkcGx1Z2lucyIsIl9pbnZhbGlkYXRlIiwiY29yZV9zY2FsZVNlcnZpY2UiLCJjb25zdHJ1Y3RvcnMiLCJyZWdpc3RlclNjYWxlVHlwZSIsInNjYWxlQ29uc3RydWN0b3IiLCJzY2FsZURlZmF1bHRzIiwiZ2V0U2NhbGVDb25zdHJ1Y3RvciIsImdldFNjYWxlRGVmYXVsdHMiLCJ1cGRhdGVTY2FsZURlZmF1bHRzIiwiYWRkaXRpb25zIiwiYWRkU2NhbGVzVG9MYXlvdXQiLCJ2YWx1ZU9yRGVmYXVsdCQ3IiwiZW5hYmxlZCIsInRpdGxlRm9udFN0eWxlIiwidGl0bGVTcGFjaW5nIiwidGl0bGVNYXJnaW5Cb3R0b20iLCJ0aXRsZUZvbnRDb2xvciIsInRpdGxlQWxpZ24iLCJib2R5U3BhY2luZyIsImJvZHlGb250Q29sb3IiLCJib2R5QWxpZ24iLCJmb290ZXJGb250U3R5bGUiLCJmb290ZXJTcGFjaW5nIiwiZm9vdGVyTWFyZ2luVG9wIiwiZm9vdGVyRm9udENvbG9yIiwiZm9vdGVyQWxpZ24iLCJ5UGFkZGluZyIsInhQYWRkaW5nIiwiY2FyZXRQYWRkaW5nIiwiY2FyZXRTaXplIiwibXVsdGlLZXlCYWNrZ3JvdW5kIiwiZGlzcGxheUNvbG9ycyIsImJlZm9yZVRpdGxlIiwidG9vbHRpcEl0ZW1zIiwibGFiZWxDb3VudCIsImFmdGVyVGl0bGUiLCJiZWZvcmVCb2R5IiwiYmVmb3JlTGFiZWwiLCJsYWJlbENvbG9yIiwibGFiZWxUZXh0Q29sb3IiLCJhZnRlckxhYmVsIiwiYWZ0ZXJCb2R5IiwiYmVmb3JlRm9vdGVyIiwiZm9vdGVyIiwiYWZ0ZXJGb290ZXIiLCJwb3NpdGlvbmVycyIsImF2ZXJhZ2UiLCJldmVudFBvc2l0aW9uIiwibmVhcmVzdEVsZW1lbnQiLCJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCJ0cCIsInB1c2hPckNvbmNhdCIsInRvUHVzaCIsInNwbGl0TmV3bGluZXMiLCJjcmVhdGVUb29sdGlwSXRlbSIsImluZGV4U2NhbGUiLCJ2YWx1ZVNjYWxlIiwiZ2V0TGFiZWxGb3JJbmRleCIsImdldEJhc2VNb2RlbCIsInRvb2x0aXBPcHRzIiwieEFsaWduIiwieUFsaWduIiwiX2JvZHlGb250RmFtaWx5IiwiYm9keUZvbnRGYW1pbHkiLCJfYm9keUZvbnRTdHlsZSIsImJvZHlGb250U3R5bGUiLCJfYm9keUFsaWduIiwiYm9keUZvbnRTaXplIiwiX3RpdGxlRm9udEZhbWlseSIsInRpdGxlRm9udEZhbWlseSIsIl90aXRsZUZvbnRTdHlsZSIsInRpdGxlRm9udFNpemUiLCJfdGl0bGVBbGlnbiIsIl9mb290ZXJGb250RmFtaWx5IiwiZm9vdGVyRm9udEZhbWlseSIsIl9mb290ZXJGb250U3R5bGUiLCJmb290ZXJGb250U2l6ZSIsIl9mb290ZXJBbGlnbiIsIm9wYWNpdHkiLCJsZWdlbmRDb2xvckJhY2tncm91bmQiLCJnZXRUb29sdGlwU2l6ZSIsInRvb2x0aXAiLCJjb21iaW5lZEJvZHlMZW5ndGgiLCJib2R5SXRlbSIsImFmdGVyIiwidGl0bGVMaW5lQ291bnQiLCJmb290ZXJMaW5lQ291bnQiLCJ3aWR0aFBhZGRpbmciLCJtYXhMaW5lV2lkdGgiLCJtZWFzdXJlVGV4dCIsImZvbnRTdHJpbmciLCJkZXRlcm1pbmVBbGlnbm1lbnQiLCJsZiIsInJmIiwib2xmIiwib3JmIiwieWYiLCJtaWRYIiwibWlkWSIsImdldEJhY2tncm91bmRQb2ludCIsImFsaWdubWVudCIsInBhZGRpbmdBbmRTaXplIiwicmFkaXVzQW5kUGFkZGluZyIsImdldEFsaWduZWRYIiwiYWxpZ24iLCJnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyIsImV4cG9ydHMkMyIsIl9sYXN0QWN0aXZlIiwiZ2V0VGl0bGUiLCJnZXRCZWZvcmVCb2R5IiwiZ2V0Qm9keSIsImJvZHlJdGVtcyIsImdldEFmdGVyQm9keSIsImdldEZvb3RlciIsImNoYW5nZWQiLCJleGlzdGluZ01vZGVsIiwiX2FjdGl2ZSIsImJhY2tncm91bmRQb2ludCIsInRvb2x0aXBTaXplIiwiY2FyZXRYIiwiY2FyZXRZIiwibGFiZWxDb2xvcnMiLCJsYWJlbFRleHRDb2xvcnMiLCJfZXZlbnRQb3NpdGlvbiIsIml0ZW1Tb3J0IiwiZGF0YVBvaW50cyIsImRyYXdDYXJldCIsInRvb2x0aXBQb2ludCIsImNhcmV0UG9zaXRpb24iLCJnZXRDYXJldFBvc2l0aW9uIiwieDMiLCJ5MyIsInB0WCIsInB0WSIsImRyYXdUaXRsZSIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwiZHJhd0JvZHkiLCJkcmF3Q29sb3JCb3hlcyIsInhMaW5lUGFkZGluZyIsImNvbG9yWCIsInRleHRDb2xvciIsImZpbGxMaW5lT2ZUZXh0Iiwic3Ryb2tlUmVjdCIsImRyYXdGb290ZXIiLCJkcmF3QmFja2dyb3VuZCIsInF1YWRyYXRpY0N1cnZlVG8iLCJoYXNUb29sdGlwQ29udGVudCIsImdsb2JhbEFscGhhIiwiaGFuZGxlRXZlbnQiLCJnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlIiwicG9zaXRpb25lcnNfMSIsImNvcmVfdG9vbHRpcCIsInZhbHVlT3JEZWZhdWx0JDgiLCJvbkhvdmVyIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJyZXNwb25zaXZlIiwicmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uIiwibWVyZ2VTY2FsZUNvbmZpZyIsInNsZW4iLCJtZXJnZUNvbmZpZyIsImluaXRDb25maWciLCJ1cGRhdGVDb25maWciLCJuZXdPcHRpb25zIiwiZW5zdXJlU2NhbGVzSGF2ZUlEcyIsImJ1aWxkT3JVcGRhdGVTY2FsZXMiLCJwb3NpdGlvbklzSG9yaXpvbnRhbCIsIkNoYXJ0IiwiY29uc3RydWN0IiwiX2J1ZmZlcmVkUmVuZGVyIiwiaW5zdGFuY2VzIiwicmV0aW5hU2NhbGUiLCJkZXZpY2VQaXhlbFJhdGlvIiwiYmluZEV2ZW50cyIsInJlc2l6ZSIsImluaXRUb29sVGlwIiwibmV3V2lkdGgiLCJnZXRNYXhpbXVtV2lkdGgiLCJuZXdIZWlnaHQiLCJnZXRNYXhpbXVtSGVpZ2h0IiwibmV3U2l6ZSIsIm9uUmVzaXplIiwic2NhbGVzT3B0aW9ucyIsInNjYWxlT3B0aW9ucyIsInhBeGlzT3B0aW9ucyIsInlBeGlzT3B0aW9ucyIsImR0eXBlIiwiZHBvc2l0aW9uIiwiaXNEZWZhdWx0Iiwic2NhbGVUeXBlIiwic2NhbGVDbGFzcyIsIm1lcmdlVGlja3NPcHRpb25zIiwiaGFzVXBkYXRlZCIsImJ1aWxkT3JVcGRhdGVDb250cm9sbGVycyIsIm5ld0NvbnRyb2xsZXJzIiwiZGVzdHJveURhdGFzZXRNZXRhIiwiQ29udHJvbGxlckNsYXNzIiwicmVzZXRFbGVtZW50cyIsInVwZGF0ZUxheW91dCIsInVwZGF0ZURhdGFzZXRzIiwibGFzdEFjdGl2ZSIsIl9idWZmZXJlZFJlcXVlc3QiLCJ1cGRhdGVEYXRhc2V0IiwiYW5pbWF0aW9uT3B0aW9ucyIsImFuaW1hdGlvbk9iamVjdCIsImVhc2luZ0Z1bmN0aW9uIiwic3RlcERlY2ltYWwiLCJkcmF3RGF0YXNldHMiLCJfZHJhd1Rvb2x0aXAiLCJkcmF3RGF0YXNldCIsImdldEVsZW1lbnRBdEV2ZW50IiwiZ2V0RWxlbWVudHNBdEV2ZW50IiwiZ2V0RWxlbWVudHNBdFhBeGlzIiwiZ2V0RGF0YXNldEF0RXZlbnQiLCJfbWV0YSIsImdlbmVyYXRlTGVnZW5kIiwidW5iaW5kRXZlbnRzIiwidG9CYXNlNjRJbWFnZSIsInRvRGF0YVVSTCIsIl9jaGFydEluc3RhbmNlIiwiX2xpc3RlbmVycyIsImV2ZW50SGFuZGxlciIsInVwZGF0ZUhvdmVyU3R5bGUiLCJidWZmZXJlZFJlcXVlc3QiLCJob3Zlck9wdGlvbnMiLCJjb3JlX2NvbnRyb2xsZXIiLCJDb250cm9sbGVyIiwiY29uZmlnTWVyZ2UiLCJzY2FsZU1lcmdlIiwiY29yZV9oZWxwZXJzIiwiZmlsdGVyQ2FsbGJhY2siLCJmaWx0ZXJlZCIsImFycmF5VG9TZWFyY2giLCJzdGFydEluZGV4IiwiY3VycmVudEl0ZW0iLCJmaW5kUHJldmlvdXNXaGVyZSIsImFsbW9zdEVxdWFscyIsImFsbW9zdFdob2xlIiwicm91bmRlZCIsIk5FR0FUSVZFX0lORklOSVRZIiwibG9nMTAiLCJleHBvbmVudCIsIkxPRzEwRSIsInBvd2VyT2YxMCIsImlzUG93ZXJPZjEwIiwidG9SYWRpYW5zIiwidG9EZWdyZWVzIiwicmFkaWFucyIsIl9kZWNpbWFsUGxhY2VzIiwiY2VudHJlUG9pbnQiLCJhbmdsZVBvaW50IiwiZGlzdGFuY2VGcm9tWENlbnRlciIsImRpc3RhbmNlRnJvbVlDZW50ZXIiLCJyYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIiLCJhbGlhc1BpeGVsIiwicGl4ZWxXaWR0aCIsIl9hbGlnblBpeGVsIiwicGl4ZWwiLCJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsImhhbGZXaWR0aCIsImZpcnN0UG9pbnQiLCJtaWRkbGVQb2ludCIsImFmdGVyUG9pbnQiLCJkMDEiLCJkMTIiLCJzMDEiLCJzMTIiLCJmYSIsImZiIiwiRVBTSUxPTiIsInBvaW50c1dpdGhUYW5nZW50cyIsImRlbHRhSyIsIm1LIiwicG9pbnRzTGVuIiwicG9pbnRCZWZvcmUiLCJwb2ludEN1cnJlbnQiLCJwb2ludEFmdGVyIiwic2xvcGVEZWx0YVgiLCJhbHBoYUsiLCJiZXRhSyIsInRhdUsiLCJzcXVhcmVkTWFnbml0dWRlIiwibG9vcCIsIm5pY2VOdW0iLCJmcmFjdGlvbiIsIm5pY2VGcmFjdGlvbiIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsImV2dCIsIm9yaWdpbmFsRXZlbnQiLCJzcmNFbGVtZW50IiwiYm91bmRpbmdSZWN0IiwidG91Y2hlcyIsImNsaWVudFgiLCJjbGllbnRZIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nVG9wIiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsInBhcnNlTWF4U3R5bGUiLCJwYXJlbnRQcm9wZXJ0eSIsInZhbHVlSW5QaXhlbHMiLCJpc0NvbnN0cmFpbmVkVmFsdWUiLCJnZXRDb25zdHJhaW50RGltZW5zaW9uIiwiZG9tTm9kZSIsIm1heFN0eWxlIiwicGVyY2VudGFnZVByb3BlcnR5IiwiZGVmYXVsdFZpZXciLCJfZ2V0UGFyZW50Tm9kZSIsImNvbnN0cmFpbmVkTm9kZSIsImNvbnN0cmFpbmVkQ29udGFpbmVyIiwiaGFzQ05vZGUiLCJoYXNDQ29udGFpbmVyIiwiaW5maW5pdHkiLCJnZXRDb25zdHJhaW50V2lkdGgiLCJnZXRDb25zdHJhaW50SGVpZ2h0IiwiX2NhbGN1bGF0ZVBhZGRpbmciLCJwYXJlbnREaW1lbnNpb24iLCJob3N0IiwiY3ciLCJjbGllbnRIZWlnaHQiLCJjdXJyZW50U3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZm9yY2VSYXRpbyIsInBpeGVsUmF0aW8iLCJwaXhlbFNpemUiLCJsb25nZXN0VGV4dCIsImFycmF5T2ZUaGluZ3MiLCJnYyIsImdhcmJhZ2VDb2xsZWN0IiwibG9uZ2VzdCIsInRoaW5nIiwibmVzdGVkVGhpbmciLCJnY0xlbiIsInRleHRXaWR0aCIsIm51bWJlck9mTGFiZWxMaW5lcyIsIm51bWJlck9mTGluZXMiLCJjb2xvciIsIkNhbnZhc0dyYWRpZW50IiwiY29sb3JWYWx1ZSIsIkNhbnZhc1BhdHRlcm4iLCJEYXRlQWRhcHRlciIsIl9jcmVhdGUiLCJvdmVycmlkZSIsIm1lbWJlcnMiLCJfZGF0ZSIsImNvcmVfYWRhcHRlcnMiLCJjb3JlX3RpY2tzIiwiZm9ybWF0dGVycyIsInRpY2tWYWx1ZSIsImxvZ0RlbHRhIiwidGlja1N0cmluZyIsIm1heFRpY2siLCJsb2dUaWNrIiwidG9FeHBvbmVudGlhbCIsIm51bURlY2ltYWwiLCJsb2dhcml0aG1pYyIsInJlbWFpbiIsInZhbHVlT3JEZWZhdWx0JDkiLCJkcmF3Qm9yZGVyIiwiZHJhd09uQ2hhcnRBcmVhIiwiZHJhd1RpY2tzIiwidGlja01hcmtMZW5ndGgiLCJ6ZXJvTGluZVdpZHRoIiwiemVyb0xpbmVDb2xvciIsInplcm9MaW5lQm9yZGVyRGFzaCIsInplcm9MaW5lQm9yZGVyRGFzaE9mZnNldCIsInNjYWxlTGFiZWwiLCJsYWJlbFN0cmluZyIsIm1pblJvdGF0aW9uIiwibWF4Um90YXRpb24iLCJtaXJyb3IiLCJhdXRvU2tpcCIsImF1dG9Ta2lwUGFkZGluZyIsImxhYmVsT2Zmc2V0IiwibWlub3IiLCJtYWpvciIsImxhYmVsc0Zyb21UaWNrcyIsImdldFBpeGVsRm9yR3JpZExpbmUiLCJsaW5lVmFsdWUiLCJjb21wdXRlVGV4dFNpemUiLCJ0aWNrIiwiY29yZV9zY2FsZSIsIl90aWNrcyIsImJlZm9yZVVwZGF0ZSIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwibWFyZ2lucyIsIl9tYXhMYWJlbExpbmVzIiwibG9uZ2VzdExhYmVsV2lkdGgiLCJsb25nZXN0VGV4dENhY2hlIiwiYmVmb3JlU2V0RGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJhZnRlclNldERpbWVuc2lvbnMiLCJiZWZvcmVEYXRhTGltaXRzIiwiZGV0ZXJtaW5lRGF0YUxpbWl0cyIsImFmdGVyRGF0YUxpbWl0cyIsImJlZm9yZUJ1aWxkVGlja3MiLCJidWlsZFRpY2tzIiwiYWZ0ZXJCdWlsZFRpY2tzIiwiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwiY29udmVydFRpY2tzVG9MYWJlbHMiLCJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uIiwiYmVmb3JlRml0IiwiZml0IiwiYWZ0ZXJGaXQiLCJhZnRlclVwZGF0ZSIsInRpY2tPcHRzIiwidXNlckNhbGxiYWNrIiwidGlja0ZvbnQiLCJsYWJlbFJvdGF0aW9uIiwib3JpZ2luYWxMYWJlbFdpZHRoIiwibGFiZWxXaWR0aCIsImNvc1JvdGF0aW9uIiwic2luUm90YXRpb24iLCJ0aWNrV2lkdGgiLCJhbmdsZVJhZGlhbnMiLCJzY2FsZUxhYmVsT3B0cyIsImdyaWRMaW5lT3B0cyIsIl9pc1Zpc2libGUiLCJwYXJzZUZvbnQiLCJpc0Z1bGxXaWR0aCIsInNjYWxlTGFiZWxGb250Iiwic2NhbGVMYWJlbFBhZGRpbmciLCJkZWx0YUhlaWdodCIsImxhcmdlc3RUZXh0V2lkdGgiLCJ0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzIiwibGluZVNwYWNlIiwidGlja1BhZGRpbmciLCJsYWJlbEhlaWdodCIsImZpcnN0TGFiZWxXaWR0aCIsImxhc3RMYWJlbFdpZHRoIiwib2Zmc2V0TGVmdCIsIm9mZnNldFJpZ2h0IiwiaGFuZGxlTWFyZ2lucyIsInJhd1ZhbHVlIiwiZ2V0VmFsdWVGb3JQaXhlbCIsImlubmVyV2lkdGgiLCJmaW5hbFZhbCIsImlubmVySGVpZ2h0IiwiZGVjaW1hbCIsInZhbHVlT2Zmc2V0IiwiZ2V0QmFzZVZhbHVlIiwiX2F1dG9Ta2lwIiwib3B0aW9uVGlja3MiLCJ0aWNrQ291bnQiLCJza2lwUmF0aW8iLCJtYXhUaWNrcyIsIm1heFRpY2tzTGltaXQiLCJ0aWNrc0xlbmd0aCIsIl90aWNrU2l6ZSIsImF4aXNMZW5ndGgiLCJQYWRkaW5nQm90dG9tIiwicm90Iiwib3B0aW9uTWFqb3JUaWNrcyIsImlzUm90YXRlZCIsImlzTWlycm9yZWQiLCJ0aWNrRm9udENvbG9yIiwiZm9udENvbG9yIiwibWFqb3JUaWNrRm9udENvbG9yIiwibWFqb3JUaWNrRm9udCIsInRsIiwic2NhbGVMYWJlbEZvbnRDb2xvciIsImxhYmVsUm90YXRpb25SYWRpYW5zIiwiaXRlbXNUb0RyYXciLCJheGlzV2lkdGgiLCJhbGlnblBpeGVsIiwiYm9yZGVyVmFsdWUiLCJ0aWNrU3RhcnQiLCJ0aWNrRW5kIiwibGluZUNvbG9yIiwiemVyb0xpbmVJbmRleCIsInR4MSIsInR5MSIsInR4MiIsInR5MiIsImxhYmVsWCIsImxhYmVsWSIsInRleHRPZmZzZXQiLCJsYWJlbFlPZmZzZXQiLCJsYWJlbFhPZmZzZXQiLCJnbFdpZHRoIiwiZ2xDb2xvciIsImdsQm9yZGVyRGFzaCIsImdsQm9yZGVyRGFzaE9mZnNldCIsIml0ZW1Ub0RyYXciLCJ0cmFuc2xhdGUiLCJzY2FsZUxhYmVsWCIsInNjYWxlTGFiZWxZIiwiaGFsZkxpbmVIZWlnaHQiLCJpc0xlZnQiLCJmaXJzdExpbmVXaWR0aCIsImxhc3RMaW5lV2lkdGgiLCJkZWZhdWx0Q29uZmlnIiwic2NhbGVfY2F0ZWdvcnkiLCJnZXRMYWJlbHMiLCJtaW5JbmRleCIsIm1heEluZGV4Iiwib2Zmc2V0QW10IiwidmFsdWVDYXRlZ29yeSIsInZhbHVlV2lkdGgiLCJ3aWR0aE9mZnNldCIsInZhbHVlSGVpZ2h0IiwiaGVpZ2h0T2Zmc2V0IiwiaG9yeiIsInZhbHVlRGltZW5zaW9uIiwiX2RlZmF1bHRzIiwiZ2VuZXJhdGVUaWNrcyIsImdlbmVyYXRpb25PcHRpb25zIiwiZGF0YVJhbmdlIiwiTUlOX1NQQUNJTkciLCJzdGVwU2l6ZSIsIm1heE51bVNwYWNlcyIsInByZWNpc2lvbiIsInJtaW4iLCJybWF4Iiwic3BhY2luZyIsImZhY3RvciIsIm5pY2VNaW4iLCJuaWNlTWF4IiwibnVtU3BhY2VzIiwic2NhbGVfbGluZWFyYmFzZSIsImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCJtaW5TaWduIiwibWF4U2lnbiIsInNldE1pbiIsInN1Z2dlc3RlZE1pbiIsInNldE1heCIsInN1Z2dlc3RlZE1heCIsImdldFRpY2tMaW1pdCIsIl9jb21wdXRlVGlja0xpbWl0IiwiaGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzIiwibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCJmaXhlZFN0ZXBTaXplIiwidGlja3NBc051bWJlcnMiLCJkZWZhdWx0Q29uZmlnJDEiLCJzY2FsZV9saW5lYXIiLCJERUZBVUxUX01JTiIsIkRFRkFVTFRfTUFYIiwiSURNYXRjaGVzIiwiaGFzU3RhY2tzIiwidmFsdWVzUGVyU3RhY2siLCJwb3NpdGl2ZVZhbHVlcyIsIm5lZ2F0aXZlVmFsdWVzIiwicmVsYXRpdmVQb2ludHMiLCJ2YWx1ZXNGb3JUeXBlIiwibWluVmFsIiwibWF4VmFsIiwiaW5uZXJEaW1lbnNpb24iLCJfZGVmYXVsdHMkMSIsInZhbHVlT3JEZWZhdWx0JGEiLCJnZW5lcmF0ZVRpY2tzJDEiLCJ0aWNrVmFsIiwiZW5kRXhwIiwiZW5kU2lnbmlmaWNhbmQiLCJzaWduaWZpY2FuZCIsIm1pbk5vdFplcm8iLCJsYXN0VGljayIsImRlZmF1bHRDb25maWckMiIsIm5vbk5lZ2F0aXZlT3JEZWZhdWx0Iiwic2NhbGVfbG9nYXJpdGhtaWMiLCJ0aWNrVmFsdWVzIiwiX2dldEZpcnN0VGlja1ZhbHVlIiwiZmlyc3RUaWNrVmFsdWUiLCJfZGVmYXVsdHMkMiIsInZhbHVlT3JEZWZhdWx0JGIiLCJ2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMSIsInJlc29sdmUkNyIsImRlZmF1bHRDb25maWckMyIsImFuaW1hdGUiLCJzaG93TGFiZWxCYWNrZHJvcCIsImJhY2tkcm9wQ29sb3IiLCJiYWNrZHJvcFBhZGRpbmdZIiwiYmFja2Ryb3BQYWRkaW5nWCIsImdldFZhbHVlQ291bnQiLCJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCJtZWFzdXJlTGFiZWxTaXplIiwiZGV0ZXJtaW5lTGltaXRzIiwiZml0V2l0aFBvaW50TGFiZWxzIiwicGxGb250IiwiZnVydGhlc3RMaW1pdHMiLCJmdXJ0aGVzdEFuZ2xlcyIsInRleHRTaXplIiwiX3BvaW50TGFiZWxTaXplcyIsInZhbHVlQ291bnQiLCJnZXRQb2ludFBvc2l0aW9uIiwiZHJhd2luZ0FyZWEiLCJnZXRJbmRleEFuZ2xlIiwiaExpbWl0cyIsInZMaW1pdHMiLCJzZXRSZWR1Y3Rpb25zIiwiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCJhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQiLCJkcmF3UG9pbnRMYWJlbHMiLCJhbmdsZUxpbmVPcHRzIiwicG9pbnRMYWJlbE9wdHMiLCJ0aWNrQmFja2Ryb3BIZWlnaHQiLCJvdXRlckRpc3RhbmNlIiwib3V0ZXJQb3NpdGlvbiIsImV4dHJhIiwicG9pbnRMYWJlbFBvc2l0aW9uIiwicG9pbnRMYWJlbEZvbnRDb2xvciIsImRyYXdSYWRpdXNMaW5lIiwibnVtYmVyT3JaZXJvIiwic2NhbGVfcmFkaWFsTGluZWFyIiwic2V0Q2VudGVyUG9pbnQiLCJsYXJnZXN0UG9zc2libGVSYWRpdXMiLCJyYWRpdXNSZWR1Y3Rpb25MZWZ0IiwicmFkaXVzUmVkdWN0aW9uUmlnaHQiLCJyYWRpdXNSZWR1Y3Rpb25Ub3AiLCJyYWRpdXNSZWR1Y3Rpb25Cb3R0b20iLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsIm1heFJpZ2h0IiwibWF4TGVmdCIsIm1heFRvcCIsIm1heEJvdHRvbSIsImFuZ2xlTXVsdGlwbGllciIsInN0YXJ0QW5nbGVSYWRpYW5zIiwic2NhbGluZ0ZhY3RvciIsImRpc3RhbmNlRnJvbUNlbnRlciIsInRoaXNBbmdsZSIsImdldEJhc2VQb3NpdGlvbiIsInlDZW50ZXJPZmZzZXQiLCJfZGVmYXVsdHMkMyIsInZhbHVlT3JEZWZhdWx0JGMiLCJNSU5fSU5URUdFUiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJNQVhfSU5URUdFUiIsIklOVEVSVkFMUyIsImNvbW1vbiIsInN0ZXBzIiwiVU5JVFMiLCJzb3J0ZXIiLCJhcnJheVVuaXF1ZSIsImJ1aWxkTG9va3VwVGFibGUiLCJ0aW1lc3RhbXBzIiwiZGlzdHJpYnV0aW9uIiwidGFibGUiLCJsb29rdXAiLCJsbyIsIm1pZCIsImkwIiwiaTEiLCJpbnRlcnBvbGF0ZSQxIiwic2tleSIsInRrZXkiLCJzcGFuIiwidG9UaW1lc3RhbXAiLCJhZGFwdGVyIiwiX2FkYXB0ZXIiLCJwYXJzZXIiLCJkZXRlcm1pbmVTdGVwU2l6ZSIsImNhcGFjaXR5IiwiaW50ZXJ2YWwiLCJkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzIiwibWluVW5pdCIsImRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nIiwiZGV0ZXJtaW5lTWFqb3JVbml0IiwidGltZU9wdHMiLCJ1bml0U3RlcFNpemUiLCJtYWpvclRpY2tzRW5hYmxlZCIsImZpcnN0IiwiY29tcHV0ZU9mZnNldHMiLCJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwibWFqb3JVbml0IiwiZGVmYXVsdENvbmZpZyQ0IiwiYWRhcHRlcnMiLCJkaXNwbGF5Rm9ybWF0IiwiZGlzcGxheUZvcm1hdHMiLCJzY2FsZV90aW1lIiwidGltZXN0YW1wIiwiZGF0YUxhYmVscyIsIl9ob3Jpem9udGFsIiwiX3RhYmxlIiwiX3RpbWVzdGFtcHMiLCJnZXRMYWJlbENhcGFjaXR5IiwiX3VuaXQiLCJfbWFqb3JVbml0IiwiX29mZnNldHMiLCJ0b29sdGlwRm9ybWF0IiwidGlja0Zvcm1hdEZ1bmN0aW9uIiwibWlub3JGb3JtYXQiLCJtYWpvckZvcm1hdCIsIm1ham9yVGltZSIsIm1ham9yVGlja09wdHMiLCJmb3JtYXR0ZXIiLCJnZXRQaXhlbEZvck9mZnNldCIsImlzUmV2ZXJzZSIsImdldExhYmVsV2lkdGgiLCJ0aWNrc09wdHMiLCJ0aWNrTGFiZWxXaWR0aCIsInRpY2tGb250U2l6ZSIsImV4YW1wbGVUaW1lIiwiZXhhbXBsZUxhYmVsIiwiX2RlZmF1bHRzJDQiLCJjYXRlZ29yeSIsInJhZGlhbExpbmVhciIsIkZPUk1BVFMiLCJfaWQiLCJhbW91bnQiLCJmaWxsZXIiLCJwcm9wYWdhdGUiLCJtYXBwZXJzIiwidmlzaWJsZSIsImJvdW5kYXJ5IiwiZGVjb2RlRmlsbCIsImNvbXB1dGVCb3VuZGFyeSIsInNjYWxlQm90dG9tIiwic2NhbGVUb3AiLCJzY2FsZVplcm8iLCJyZXNvbHZlVGFyZ2V0IiwidmlzaXRlZCIsImNyZWF0ZU1hcHBlciIsImlzRHJhd2FibGUiLCJkcmF3QXJlYSIsImN1cnZlMCIsImN1cnZlMSIsImxlbjAiLCJsZW4xIiwiZG9GaWxsIiwibWFwcGVyIiwicDAiLCJkMCIsImQxIiwicGx1Z2luX2ZpbGxlciIsImFmdGVyRGF0YXNldHNVcGRhdGUiLCIkZmlsbGVyIiwiYmVmb3JlRGF0YXNldERyYXciLCJub29wJDEiLCJ2YWx1ZU9yRGVmYXVsdCRkIiwiY2kiLCJvbkxlYXZlIiwiYm94V2lkdGgiLCJsaW5lRGFzaCIsImdldEJveFdpZHRoIiwibGFiZWxPcHRzIiwidXNlUG9pbnRTdHlsZSIsIkxlZ2VuZCIsImxlZ2VuZEhpdEJveGVzIiwiX2hvdmVyZWRJdGVtIiwiZG91Z2hudXRNb2RlIiwiYmVmb3JlQnVpbGRMYWJlbHMiLCJidWlsZExhYmVscyIsImFmdGVyQnVpbGRMYWJlbHMiLCJsZWdlbmRJdGVtcyIsImxhYmVsRm9udCIsImhpdGJveGVzIiwibGluZVdpZHRocyIsInRvdGFsSGVpZ2h0IiwidlBhZGRpbmciLCJjb2x1bW5XaWR0aHMiLCJ0b3RhbFdpZHRoIiwiY3VycmVudENvbFdpZHRoIiwiY3VycmVudENvbEhlaWdodCIsIml0ZW1IZWlnaHQiLCJpdGVtV2lkdGgiLCJsaW5lRGVmYXVsdCIsImxlZ2VuZFdpZHRoIiwiY3Vyc29yIiwiZHJhd0xlZ2VuZEJveCIsIlNRUlQyIiwiaGFsZkZvbnRTaXplIiwieExlZnQiLCJ5TWlkZGxlIiwiX2dldExlZ2VuZEl0ZW1BdCIsImhpdEJveCIsImxoIiwiaG92ZXJlZEl0ZW0iLCJjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2giLCJsZWdlbmRPcHRzIiwicGx1Z2luX2xlZ2VuZCIsIl9lbGVtZW50IiwiYmVmb3JlSW5pdCIsImFmdGVyRXZlbnQiLCJub29wJDIiLCJUaXRsZSIsImxpbmVDb3VudCIsImZvbnRPcHRzIiwidGl0bGVYIiwidGl0bGVZIiwiY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaCIsInRpdGxlT3B0cyIsInRpdGxlQmxvY2siLCJwbHVnaW5fdGl0bGUiLCJfYWRhcHRlcnMiLCJBbmltYXRpb24iLCJhbmltYXRpb25TZXJ2aWNlIiwiSW50ZXJhY3Rpb24iLCJsYXlvdXRzIiwiU2NhbGUiLCJzY2FsZVNlcnZpY2UiLCJUaWNrcyIsIlRvb2x0aXAiLCJwbHVnaW5TZXJ2aWNlIiwiUGx1Z2luQmFzZSIsImNhbnZhc0hlbHBlcnMiLCJsYXlvdXRTZXJ2aWNlIiwiTGluZWFyU2NhbGVCYXNlIiwiY2ZnIiwiZ2VuZXJhdGVDaGFydCIsImNoYXJ0SWQiLCJjaGFydFR5cGUiLCJjc3NDbGFzc2VzIiwiX2RlZmF1bHQiLCJhZGRQbHVnaW4iLCJiZWZvcmVEZXN0cm95IiwiQmFyIiwiSG9yaXpvbnRhbEJhciIsIlBpZSIsImNoYXJ0TGFiZWxzIiwiY2hhcnREYXRhTGlzdCIsIkNoYXJ0RGF0YSIsIkNoYXJ0QmFyIiwiQ2hhcnRDb21wb25lbnQiLCJDaGFydEhvcml6b250YWxCYXIiLCJDaGFydExpbmUiLCJDaGFydFBpZSIsIk1hcERhdGEiLCJsYXllcnMiLCJBUElLZXkiLCJjb250YWluZXJJZCIsImxlZ2VuZElkIiwiem9vbSIsIm1hcFR5cGUiLCJtdWx0aSIsIkdlb0pTT04iLCJkb1Rocm93cyIsImludmFsaWRHZW9tZXRyeSIsIkludmFsaWRHZW9tZXRyeUVycm9yIiwiaXNHZW9tZXRyeVZhbGlkIiwiZ2VvbWV0cnkiLCJjb29yZGluYXRlcyIsIm9iamVjdHMiLCJnZW9qc29uIiwiYXBwbHlEZWZhdWx0cyIsInByb3BGdW5jIiwiZ2VvbUF0dHJzIiwic2V0R2VvbSIsImdldFByb3BGdW5jdGlvbiIsImZlYXR1cmVzIiwiZ2V0RmVhdHVyZSIsImFkZE9wdGlvbmFscyIsImdlb21zIiwic2V0dGluZyIsImNycyIsImNoZWNrQ1JTIiwiaXNQb3N0Z3JlcyIsImJib3giLCJleHRyYUdsb2JhbCIsInByb3BlcnRpZXMiLCJnZW9tIiwic2V0R2VvbUF0dHJMaXN0IiwiZmVhdHVyZSIsImJ1aWxkR2VvbSIsImlzTmVzdGVkIiwiZ3R5cGUiLCJuZXdJdGVtIiwicGF0aHMiLCJpdGVtQ2xvbmUiLCJhZGRFeHRyYSIsInJpbmdBcmVhIiwicG9seWdvbkFyZWEiLCJnZW9tZXRyaWVzIiwiY29vcmRzIiwibG93ZXJJbmRleCIsIm1pZGRsZUluZGV4IiwidXBwZXJJbmRleCIsImNvb3Jkc0xlbmd0aCIsIndnczg0IiwiUkFESVVTIiwicmV3aW5kIiwiZ2oiLCJjdXJyeU91dGVyIiwiY29ycmVjdCIsImNvcnJlY3RSaW5ncyIsIndpbmQiLCJnZW9qc29uQXJlYSIsInJpbmciLCJNYXBNdWx0aUxheWVyIiwiTWFwQ29tcG9uZW50IiwiZ2V0WmlwY29kZURhdGEiLCJnZXRCb3JvdWdoRGF0YSIsImdldE5laWdoYm9yaG9vZERhdGEiLCJmaWx0ZXJCeSIsImNvbnZlcnRUb0dlb0pTT04iLCJqc29uRGF0YSIsIk1hcFNpbmdsZUxheWVyIiwibGVnZW5kQ29sdW1uIiwibnljbyIsImljb25z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QUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsRUFBUixDQTlCQTtNQStCaEJDLFVBQVUsRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsQ0FBVCxDQS9CSTtNQWdDaEJDLFVBQVUsRUFBRSxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsR0FBUixDQWhDSTtNQWlDaEJDLE9BQU8sRUFBRyxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sQ0FBUCxDQWpDTTtNQWtDaEJDLFVBQVUsRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQWxDSTtNQW1DaEJDLFlBQVksRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQW5DRTtNQW9DaEJDLGFBQWEsRUFBRyxDQUFDLEVBQUQsRUFBSSxFQUFKLEVBQU8sR0FBUCxDQXBDQTtNQXFDaEJDLGFBQWEsRUFBRyxDQUFDLEVBQUQsRUFBSSxFQUFKLEVBQU8sRUFBUCxDQXJDQTtNQXNDaEJDLGFBQWEsRUFBRyxDQUFDLEVBQUQsRUFBSSxFQUFKLEVBQU8sRUFBUCxDQXRDQTtNQXVDaEJDLGFBQWEsRUFBRyxDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sR0FBUCxDQXZDQTtNQXdDaEJDLFVBQVUsRUFBRSxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sR0FBUCxDQXhDSTtNQXlDaEJDLFFBQVEsRUFBRSxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsR0FBUixDQXpDTTtNQTBDaEJDLFdBQVcsRUFBRyxDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sR0FBUCxDQTFDRTtNQTJDaEJDLE9BQU8sRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQTNDTTtNQTRDaEJDLE9BQU8sRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQTVDTTtNQTZDaEJDLFVBQVUsRUFBRSxDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsR0FBUixDQTdDSTtNQThDaEJDLFNBQVMsRUFBRyxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsRUFBUixDQTlDSTtNQStDaEJDLFdBQVcsRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQS9DRTtNQWdEaEJDLFdBQVcsRUFBRyxDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsRUFBUixDQWhERTtNQWlEaEJDLE9BQU8sRUFBRyxDQUFDLEdBQUQsRUFBSyxDQUFMLEVBQU8sR0FBUCxDQWpETTtNQWtEaEJDLFNBQVMsRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQWxESTtNQW1EaEJDLFVBQVUsRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQW5ESTtNQW9EaEJDLElBQUksRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsQ0FBVCxDQXBEVTtNQXFEaEJDLFNBQVMsRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsRUFBVCxDQXJESTtNQXNEaEJDLElBQUksRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQXREVTtNQXVEaEJDLEtBQUssRUFBRyxDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sQ0FBUCxDQXZEUTtNQXdEaEJDLFdBQVcsRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsRUFBVCxDQXhERTtNQXlEaEJDLElBQUksRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQXpEVTtNQTBEaEJDLFFBQVEsRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQTFETTtNQTJEaEJDLE9BQU8sRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQTNETTtNQTREaEJDLFNBQVMsRUFBRyxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsRUFBUixDQTVESTtNQTZEaEJDLE1BQU0sRUFBRSxDQUFDLEVBQUQsRUFBSSxDQUFKLEVBQU0sR0FBTixDQTdEUTtNQThEaEJDLEtBQUssRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQTlEUTtNQStEaEJDLEtBQUssRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFM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RUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQWxJUTtNQW1JaEJDLE9BQU8sRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQW5JTTtNQW9JaEJDLFNBQVMsRUFBRyxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsR0FBUixDQXBJSTtNQXFJaEJDLFNBQVMsRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQXJJSTtNQXNJaEJDLFNBQVMsRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQXRJSTtNQXVJaEJDLElBQUksRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQXZJVTtNQXdJaEJDLFdBQVcsRUFBRyxDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sR0FBUCxDQXhJRTtNQXlJaEJDLFNBQVMsRUFBRyxDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsR0FBUixDQXpJSTtNQTBJaEJDLEdBQUcsRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQTFJVTtNQTJJaEJDLElBQUksRUFBRSxDQUFDLENBQUQsRUFBRyxHQUFILEVBQU8sR0FBUCxDQTNJVTtNQTRJaEJDLE9BQU8sRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQTVJTTtNQTZJaEJDLE1BQU0sRUFBRSxDQUFDLEdBQUQsRUFBSyxFQUFMLEVBQVEsRUFBUixDQTdJUTtNQThJaEJDLFNBQVMsRUFBRyxDQUFDLEVBQUQsRUFBSSxHQUFKLEVBQVEsR0FBUixDQTlJSTtNQStJaEJDLE1BQU0sRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQS9JUTtNQWdKaEJDLEtBQUssRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQWhKUTtNQWlKaEJDLEtBQUssRUFBRyxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxDQWpKUTtNQWtKaEJDLFVBQVUsRUFBRSxDQUFDLEdBQUQsRUFBSyxHQUFMLEVBQVMsR0FBVCxD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
