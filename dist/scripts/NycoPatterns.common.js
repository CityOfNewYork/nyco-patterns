'use strict';

/**
 * The Utility class
 * @class
 */

var Utility$1 = function Utility() {
  return this;
};
/**
 * Boolean for debug mode
 * @return {boolean} wether or not the front-end is in debug mode.
 */


Utility$1.debug = function () {
  return Utility$1.getUrlParameter(Utility$1.PARAMS.DEBUG) === '1';
};
/**
 * Returns the value of a given key in a URL query string. If no URL query
 * string is provided, the current URL location is used.
 * @param  {string}  name        - Key name.
 * @param  {?string} queryString - Optional query string to check.
 * @return {?string} Query parameter value.
 */


Utility$1.getUrlParameter = function (name, queryString) {
  var query = queryString || window.location.search;
  var param = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
  var regex = new RegExp('[\\?&]' + param + '=([^&#]*)');
  var results = regex.exec(query);
  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};
/**
 * For translating strings, there is a global LOCALIZED_STRINGS array that
 * is defined on the HTML template level so that those strings are exposed to
 * WPML translation. The LOCALIZED_STRINGS array is composed of objects with a
 * `slug` key whose value is some constant, and a `label` value which is the
 * translated equivalent. This function takes a slug name and returns the
 * label.
 * @param  {string} slug
 * @return {string} localized value
 */


Utility$1.localize = function (slug) {
  var text = slug || '';
  var strings = window.LOCALIZED_STRINGS || [];
  var match = strings.filter(function (s) {
    return s.hasOwnProperty('slug') && s['slug'] === slug ? s : false;
  });
  return match[0] && match[0].hasOwnProperty('label') ? match[0].label : text;
};
/**
 * Application parameters
 * @type {Object}
 */


Utility$1.PARAMS = {
  DEBUG: 'debug'
};
/**
 * Selectors for the Utility module
 * @type {Object}
 */

Utility$1.SELECTORS = {
  parseMarkdown: '[data-js="markdown"]'
};

/**
 * The Icon module
 * @class
 */

var Icons = function Icons(path) {
  path = path ? path : Icons.path;
  fetch(path).then(function (response) {
    if (response.ok) {
      return response.text();
    } else // eslint-disable-next-line no-console
      if (Utility$1.debug()) {
        console.dir(response);
      }
  }).catch(function (error) {
    // eslint-disable-next-line no-console
    if (Utility$1.debug()) {
      console.dir(error);
    }
  }).then(function (data) {
    var sprite = document.createElement('div');
    sprite.innerHTML = data;
    sprite.setAttribute('aria-hidden', true);
    sprite.setAttribute('style', 'display: none;');
    document.body.appendChild(sprite);
  });
  return this;
};
/** @type {String} The path of the icon file */


Icons.path = 'icons.svg';

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */

var Symbol$1 = root.Symbol;

/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString$1 = objectProto$1.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */

var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto$1 = Function.prototype,
    objectProto$2 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/** Used for built-in method references. */

var objectProto$3 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$2.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString = shortOut(baseSetToString);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */

function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */

function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */

function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */

var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */

var objectProto$4 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */

var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */

var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports$1 && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */

var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */

var objectProto$5 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$6;
  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */

var objectProto$7 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */

var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */

var getPrototype = overArg(Object.getPrototypeOf, Object);

/** `Object#toString` result references. */

var objectTag$1 = '[object Object]';
/** Used for built-in method references. */

var funcProto$2 = Function.prototype,
    objectProto$8 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$2 = funcProto$2.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString$2.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}

/** `Object#toString` result references. */

var domExcTag = '[object DOMException]',
    errorTag$1 = '[object Error]';
/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */

function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }

  var tag = baseGetTag(value);
  return tag == errorTag$1 || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */

var attempt = baseRest(function (func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */

function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

/** Used for built-in method references. */

var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */

function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined || eq(objValue, objectProto$9[key]) && !hasOwnProperty$7.call(object, key)) {
    return srcValue;
  }

  return objValue;
}

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};
/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */

var objectProto$a = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function (key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map characters to HTML entities. */

var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */

function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to match HTML entities and HTML characters. */

var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */

function escape(string) {
  string = toString(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
}

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */

var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': {
      'escape': escape
    }
  }
};

/** Used to match empty string literals in compiled template source. */

var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */

var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
/** Used to ensure capturing order of template delimiters. */

var reNoMatch = /($^)/;
/** Used to match unescaped characters in compiled string literals. */

var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */

function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }

  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);
  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);
  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '"; // Compile the regexp to match each delimiter.

  var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.

  var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';
  string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets.

    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }

    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }

    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }

    index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.

    return match;
  });
  source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.

  var variable = options.variable;

  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  } // Cleanup code by stripping empty strings.


  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

  source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
  var result = attempt(function () {
    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
  }); // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.

  result.source = source;

  if (isError(result)) {
    throw result;
  }

  return result;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */

var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */

function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */

var baseEach = createBaseEach(baseForOwn);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */

function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */

function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* Built-in method references that are verified to be native. */

var Map = getNative(root, 'Map');

/* Built-in method references that are verified to be native. */

var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto$b = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */

var objectProto$c = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$a = objectProto$c.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$a.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/** Detect free variable `exports`. */

var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
/** Built-in value references. */

var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

/** Built-in value references. */

var Uint8Array = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */

function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */

function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack());
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */

var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */

function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);

  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */

function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;
/** `Object#toString` result references. */

var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$2 = '[object Error]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';
var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag$2:
      return object.name == other.name && object.message == other.message;

    case regexpTag$1:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag$1:
      var convert = mapToArray;

    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */

var objectProto$d = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable$1 = objectProto$d.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$2 = 1;
/** Used for built-in method references. */

var objectProto$e = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$b = objectProto$e.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty$b.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* Built-in method references that are verified to be native. */

var DataView = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */

var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */

var Set$1 = getNative(root, 'Set');

/* Built-in method references that are verified to be native. */

var WeakMap = getNative(root, 'WeakMap');

/** `Object#toString` result references. */

var mapTag$2 = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$2 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';
var dataViewTag$2 = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map && getTag(new Map()) != mapTag$2 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$2 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;

        case mapCtorString:
          return mapTag$2;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag$2;

        case weakMapCtorString:
          return weakMapTag$1;
      }
    }

    return result;
  };
}

var getTag$1 = getTag;

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$3 = 1;
/** `Object#toString` result references. */

var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    objectTag$3 = '[object Object]';
/** Used for built-in method references. */

var objectProto$f = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$c = objectProto$f.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag$1 : getTag$1(object),
      othTag = othIsArr ? arrayTag$1 : getTag$1(other);
  objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
  var objIsObj = objTag == objectTag$3,
      othIsObj = othTag == objectTag$3,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$c.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$c.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */

function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */

function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/** Used to match property names within property paths. */

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */

var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */

function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

/** Used as references for various `Number` constants. */

var INFINITY$1 = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */

function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */

function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */

function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */

function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */

function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */

function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (typeof value == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);

  while (length--) {
    array[length] = array[length].value;
  }

  return array;
}

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */

function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);
    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }

    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }

  return 0;
}

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */

function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);

    if (result) {
      if (index >= ordersLength) {
        return result;
      }

      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


  return object.index - other.index;
}

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */

function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
  var result = baseMap(collection, function (value, key, collection) {
    var criteria = arrayMap(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return {
      'criteria': criteria,
      'index': ++index,
      'value': value
    };
  });
  return baseSortBy(result, function (object, other) {
    return compareMultiple(object, other, orders);
  });
}

/**
 * This method is like `_.sortBy` except that it allows specifying the sort
 * orders of the iteratees to sort by. If `orders` is unspecified, all values
 * are sorted in ascending order. Otherwise, specify an order of "desc" for
 * descending or "asc" for ascending sort order of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @param {string[]} [orders] The sort orders of `iteratees`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 34 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 36 }
 * ];
 *
 * // Sort by `user` in ascending order and by `age` in descending order.
 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 */

function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }

  if (!isArray(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }

  orders = guard ? undefined : orders;

  if (!isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }

  return baseOrderBy(collection, iteratees, orders);
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

/** Used as references for various `Number` constants. */

var INFINITY$2 = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY$2) ? noop : function (values) {
  return new Set$1(values);
};

/**
 *
 */

var Feed = function Feed(config) {
  this.default = Feed.default;
  this._settings = merge({}, Feed.default, config);
  this.init();
};
/**
 * Initializes the module
 */


Feed.prototype.init = function init() {
  var this$1 = this;
  var data = [];
  var feed = this._settings.feed;
  var config = {
    rssToJson: Feed.rssToJson,
    rssUrl: Array.isArray(feed) ? feed : [feed]
  }; // Go through each feed

  forEach(config.rssUrl, function (url, index) {
    // Make the request
    this$1._request(config, url).then(function (response) {
      // Process the data
      data.push(this$1._process(JSON.parse(response), this$1._settings)); // When all feeds have been requested, merge the data and compile

      if (data.length === config.rssUrl.length) {
        this$1._merge(data, this$1._settings);

        var compiled = this$1._render(this$1._merge(data, this$1._settings), this$1._settings);

        var el = document.querySelector(this$1._settings.selector);

        if (el) {
          el.innerHTML = compiled;
        }
      }
    });
  });

  return this;
};
/**
 * Create an XHR request for the feed data
 * @param{object} config The request data
 * @param{string} url  The request url
 * @return {Promise}     Resolves when the response is ready, rejects when
 *                       the operation times out or there is an error.
 */


Feed.prototype._request = function _request(config, url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function (event) {
      var _xhr = event.target;

      if (_xhr.readyState === 4) {
        if (_xhr.status >= 200 && _xhr.status < 400) {
          resolve(_xhr.response);
        } else {
          reject(new Error(_xhr.status));
        }
      }
    };

    xhr.ontimeout = function () {
      reject(new Error('The Feed request timed out'));
    };

    xhr.open('GET', config.rssToJson + "?rss_url=" + url, true);
    xhr.send();
    xhr = null;
  });
};
/**
 * Pass data to the appropriate processing function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The processed data
 */


Feed.prototype._process = function _process(data, settings) {
  return Feed.process[settings.type](data, settings);
};
/**
 * Pass data to the appropriate merge function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The merged feed data
 */


Feed.prototype._merge = function _merge(data, settings) {
  return Feed.merge[settings.type](data);
};
/**
 * Combine template components, pass data, and return compiled temlate
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {string}        The complied html string
 */


Feed.prototype._render = function _render(data, settings) {
  data.settings = settings;

  if (settings.log) {
    console.dir(data);
  }

  var template$1 = values(settings.templates).join('');

  var compiled = template(template$1, {
    'imports': {
      '_each': forEach
    }
  });

  return compiled(data);
};
/**
 * An open RSS to JSON api, see https://rss2json.com
 * @type {String}
 */


Feed.rssToJson = 'https://api.rss2json.com/v1/api.json';
/**
 * The template for the widget.
 * @type {String}
 */

Feed.templates = {
  medium: {
    opener: ['<section class="o-feed <%- settings.classes.wrapper %>" style="', '<% if (settings.fontSize) { %>font-size: <%- settings.fontSize %>;<% } %>', '<% if (settings.postBorderColor) { %>border-color: <%- settings.postBorderColor %>;<% } %>', '">'],
    header: ['<header class="o-feed__header <%- settings.classes.header %>">', '<div class="o-feed__avatar <%- settings.classes.avatar %>">', '<img src="', '<% if (settings.profileImg !== "") { %>', '<%- settings.profileImg %>', '<% } else { %>', '<%- feed.profileImg %>', '<% } %>" ', 'width="<%- settings.ratioProfile[0] %>" ', 'height="<%- settings.ratioProfile[1] %>">', '</div>', '<a class="o-feed__url <%- settings.classes.avatar %>" ', 'href="<% if (settings.titleUrl !== "") { %>', '<%- settings.titleUrl %>', '<% } else { %>', '<%- feed.url %>', '<% } %>" ', 'target="_blank" rel="noopener noreferrer nofollow">', '<% if (settings.title !== "") { %>', '<%- settings.title %>', '<% } else { %>', '<%- feed.title %>', '<% } %>', '</a>', '</header>'],
    posts: ['<div class="o-feed__items" style="', 'border-color: <%- settings.postBorderColor %>;', '">', '<% _each(items, function(post) { %>', '<div class="c-feed-item <%- settings.classes.feedItem %>">', '<h4 class="c-feed-item__title <%- settings.classes.title %>">', '<a class="c-feed-item__link <%- settings.classes.link %>"', 'href="<%- post.guid %>"', 'target="_blank"', 'rel="noopener noreferrer nofollow">', '<%- post.title %>', '</a>', '</h4>', '<span class="c-feed-item__date <%- settings.classes.date %>" ', 'title="<%- settings.postDateTitle %>">', '<%- post.date %>', '</span>', '<div class="c-feed-item__thumbnail <%- settings.classes.thumbnail %>"', 'style="', 'background-image: url(<%- post.thumbnail %>);', 'height: <%- settings.postImgHeight %>;"', 'aria-hidden="true">', '<img style="display: none;" src="<%- post.thumbnail %>" alt="<%- post.title %>">', '</div>', '<p class="c-feed-item__excerpt <%- settings.classes.excerpt %>">', '<%- post.excerpt %><%- settings.postExcerptTrail %>', '</p>', '<div class="c-feed-item__footer <%- settings.classes.itemFooter %>">', '<a class="c-feed-item__cta <%- settings.classes.cta %>" ', 'href="<%- post.guid %>" ', 'target="_blank" ', 'rel="noopener noreferrer nofollow">', '<%- settings.postCtaText %>', '</a>', '</div>', '</div>', '<% }); %>', '</div>'],
    closer: ['</section>']
  }
};
/**
 * Functions for processing the data based on the feed type.
 * @type {Object}
 */

Feed.process = {
  medium: function medium(data, settings) {
    var length = settings.postExcerptLength;

    forEach(data.items, function (post, index) {
      var excerpt = '';
      var date = ''; // Remove figures first

      excerpt = post.description.replace(/<figure.*>.*?<\/figure>/g, ''); // Remove all tags

      excerpt = excerpt.replace(/<(.|\n)*?>/g, ''); // Trim the excerpt

      excerpt = excerpt.substr(0, length);
      excerpt = excerpt.substr(0, Math.min(excerpt.length, excerpt.lastIndexOf(' ')));
      post.excerpt = excerpt; // Format the date

      date = new Date(Date.parse(post.pubDate.replace(' ', 'T'))).toLocaleDateString(settings.postDateLocal, settings.postDateFormat);
      post.date = date;
      return post;
    });

    return data;
  }
  /**
   * Functions for merging the data feeds together, based on the feed type.
   * @type {Object}
   */

};
Feed.merge = {
  medium: function medium(data) {
    var merged = {};
    var items = []; // Combine the post items

    data.forEach(function (feed) {
      items = items.concat(feed.items);
    }); // Merge the data, this will override values, it probably won't be
    // particularly useful for feeds that are the same, but potentially
    // different feed types could use this and combine unique data

    data.forEach(function (feed) {
      merged = merge(merged, feed);
    }); // Get unique posts
    // items = _uniqBy(items, (item) => item.guid);

    merged.items = orderBy(items, 'pubDate', 'desc');
    return merged;
  }
  /**
   * See https://rss2json.com/docs for details on default parameters
   * @type {Object}
   */

};
Feed.default = {
  feed: '',
  selector: '#js-feed',
  type: 'medium',
  title: '',
  titleUrl: '',
  profileImg: '',
  fontSize: '',
  ratioProfile: ['50', '50'],
  postBorderColor: 'lightsteelblue',
  postImgHeight: '200px',
  postExcerptLength: 120,
  postExcerptTrail: '…',
  postCtaText: 'Read the full post',
  postDateLocal: 'en-US',
  postDateFormat: {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  },
  postDateTitle: 'Published Date',
  classes: {
    wrapper: '',
    header: '',
    url: '',
    feedItem: '',
    title: '',
    link: '',
    thumbnail: '',
    excerpt: '',
    itemFooter: '',
    cta: '',
    date: ''
  },
  templates: {
    opener: Feed.templates.medium.opener.join(''),
    header: Feed.templates.medium.header.join(''),
    posts: Feed.templates.medium.posts.join(''),
    closer: Feed.templates.medium.closer.join('')
  },
  log: false,
  unique: false
};

/**
 * The Simple Toggle class. This will toggle the class 'active' and 'hidden'
 * on target elements, determined by a click event on a selected link or
 * element. This will also toggle the aria-hidden attribute for targeted
 * elements to support screen readers. Target settings and other functionality
 * can be controlled through data attributes.
 *
 * This uses the .matches() method which will require a polyfill for IE
 * https://polyfill.io/v2/docs/features/#Element_prototype_matches
 *
 * Basic Usage;
 *
 * javascript:
 *   new Toggle().init();
 *
 * Toggling Anchor links:
 *   <a data-js='toggle' href='#main-menu'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Toggling aria-control elements:
 *
 *   <button data-js='toggle' aria-controls='#main-menu' aria-pressed='false'>
 *      Menu
 *   </button>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Create "Undo" Event (to close a dialogue);
 *   <a href='#main-menu' data-js='toggle' data-toggle-undo='#close'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'>
 *     <a id="close">Close</a>
 *   </div>
 * @class
 */

var Toggle = function Toggle(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Toggle.selector,
    namespace: s.namespace ? s.namespace : Toggle.namespace,
    inactiveClass: s.inactiveClass ? s.inactiveClass : Toggle.inactiveClass,
    activeClass: s.activeClass ? s.activeClass : Toggle.activeClass
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    event.preventDefault();

    this$1._toggle(event);
  });
  return this;
};
/**
 * Logs constants to the debugger
 * @param{object} eventThe main click event
 * @return {object}      The class
 */


Toggle.prototype._toggle = function _toggle(event) {
  var this$1 = this;
  var el = event.target;
  var target = false;
  /** Anchor Links */

  target = el.getAttribute('href') ? document.querySelector(el.getAttribute('href')) : target;
  /** Toggle Controls */
  // console.dir(el.getAttribute('aria-controls'));

  target = el.getAttribute('aria-controls') ? document.querySelector("#" + el.getAttribute('aria-controls')) : target;
  /** Main Functionality */

  if (!target) {
    return this;
  }

  this.elementToggle(el, target);
  /** Undo */

  if (el.dataset[this._settings.namespace + "Undo"]) {
    var undo = document.querySelector(el.dataset[this._settings.namespace + "Undo"]);
    undo.addEventListener('click', function (event) {
      event.preventDefault();
      this$1.elementToggle(el, target);
      undo.removeEventListener('click');
    });
  }

  return this;
};
/**
 * The main toggling method
 * @param{object} el   The current element to toggle active
 * @param{object} target The target element to toggle active/hidden
 * @return {object}      The class
 */


Toggle.prototype.elementToggle = function elementToggle(el, target) {
  if (this._settings.activeClass !== '') {
    el.classList.toggle(this._settings.activeClass);
    target.classList.toggle(this._settings.activeClass);
  }

  if (this._settings.inactiveClass !== '') {
    target.classList.toggle(this._settings.inactiveClass);
  } // Check the element for defined aria roles and toggle them if they exist


  for (var i = 0; i < Toggle.elAriaRoles.length; i++) {
    if (el.getAttribute(Toggle.elAriaRoles[i])) {
      el.setAttribute(Toggle.elAriaRoles[i], !(el.getAttribute(Toggle.elAriaRoles[i]) === 'true'));
    }
  } // Check the target for defined aria roles and toggle them if they exist


  for (var i$1 = 0; i$1 < Toggle.targetAriaRoles.length; i$1++) {
    if (target.getAttribute(Toggle.targetAriaRoles[i$1])) {
      target.setAttribute(Toggle.targetAriaRoles[i$1], !(target.getAttribute(Toggle.targetAriaRoles[i$1]) === 'true'));
    }
  }

  if (el.getAttribute('href') && target.classList.contains(this._settings.activeClass)) {
    window.location.hash = '';
    window.location.hash = el.getAttribute('href');
  }

  return this;
};
/** @type {String} The main selector to add the toggling function to */


Toggle.selector = '[data-js*="toggle"]';
/** @type {String} The namespace for our data attribute settings */

Toggle.namespace = 'toggle';
/** @type {String} The hide class */

Toggle.inactiveClass = 'hidden';
/** @type {String} The active class */

Toggle.activeClass = 'active';
/** @type {Array} Aria roles to toggle true/false on the toggling element */

Toggle.elAriaRoles = ['aria-pressed', 'aria-expanded'];
/** @type {Array} Aria roles to toggle true/false on the target element */

Toggle.targetAriaRoles = ['aria-hidden'];

/**
 * Tracking bus for Google analytics and Webtrends.
 */

var Track = function Track(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Track.selector
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    var key = event.target.dataset.trackKey;
    var data = JSON.parse(event.target.dataset.trackData);
    this$1.click(key, data);
  });
  return this;
};
/**
 * Tracking function wrapper
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 * @return {object}        The final data object
 */


Track.prototype.click = function click(key, data) {
  // Set the path name based on the location
  var d = data.map(function (el) {
    if (el.hasOwnProperty(Track.key)) {
      el[Track.key] = window.location.pathname + "/" + el[Track.key];
    }

    return el;
  });
  var wt = this.webtrends(key, d);
  var ga = this.gtag(key, d);
  /* eslint-disable no-console */

  if (Utility$1.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */


  return d;
};
/**
 * Data bus for tracking views in Webtrends and Google Analytics
 * @param{string}   appThe name of the Single Page Application to track
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.view = function view(app, key, data) {
  var wt = this.webtrends(key, data);
  var ga = this.gtagView(app, key);
  /* eslint-disable no-console */

  if (Utility$1.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */

};
/**
 * Push Events to Webtrends
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.webtrends = function webtrends(key, data) {
  var event = [{
    'WT.ti': key
  }];

  if (data[0] && data[0].hasOwnProperty(Track.key)) {
    event.push({
      'DCS.dcsuri': data[0][Track.key]
    });
  } else {
    Object.assign(event, data);
  } // Format data for Webtrends


  var wtd = {
    argsa: event.flatMap(function (e) {
      return Object.keys(e).flatMap(function (k) {
        return [k, e[k]];
      });
    })
  };
  /* eslint-disable no-undef */

  if (typeof Webtrends !== 'undefined') {
    Webtrends.multiTrack(wtd);
  }
  /* eslint-disable no-undef */


  return ['Webtrends', wtd];
};
/**
 * Push Click Events to Google Analytics
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.gtag = function gtag$1(key, data) {
  var uri = data.find(function (element) {
    return element.hasOwnProperty(Track.key);
  });
  var event = {
    'event_category': key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag(Track.key, uri[Track.key], event);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, uri[Track.key], event];
};
/**
 * Push Screen View Events to Google Analytics
 * @param{string}   appThe name of the application
 * @param{string}   keyThe key or event of the data
 */

Track.prototype.gtagView = function gtagView(app, key) {
  var view = {
    app_name: app,
    screen_name: key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag('event', 'screen_view', view);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, 'screen_view', view];
};
/** @type {String} The main selector to add the tracking function to */


Track.selector = '[data-js*="track"]';
/** @type {String} The main event tracking key to map to Webtrends DCS.uri */

Track.key = 'event';

/*!
 * Vue.js v2.6.6
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject$1(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject$1(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString$1(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject$1(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty$d = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty$d.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop$1(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity$1 = function (_) {
  return _;
};
/**
 * Generate a string containing static keys from compiler modules.
 */


function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject$1(a);
  var isObjectB = isObject$1(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop$1,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity$1,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeLetters = 'a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD';
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeLetters + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = '__proto__' in {}; // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set =
  /*@__PURE__*/
  function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop$1;
var tip = noop$1;
var generateComponentTrace = noop$1; // work around flow check

var formatComponentName = noop$1;
{
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat$1 = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat$1(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */

var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if (!config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto$1 = Array.prototype;
var arrayMethods = Object.create(arrayProto$1);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto$1[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject$1(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject$1(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if (customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

{
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */

function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject$1(toVal) && isPlainObject$1(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
    assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeLetters + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject$1(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject$1(val) ? val : {
        type: val
      };
    }
  } else {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject$1(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject$1(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject$1(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if (warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if (isObject$1(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject$1(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

function isExplicable(value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;

    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;

      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;

            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }

  globalHandleError(err, vm, info);
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res)) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      });
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */

  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop$1);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */


var mark;
var measure;
{
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;
{
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */

var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject$1(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
      warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      }
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (slots.$stable && prevSlots && prevSlots !== emptyObject && Object.keys(normalSlots).length === 0) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key in slots) {
      if (slots[key] && key[0] !== '$') {
        res[key] = normalizeScopedSlot(normalSlots, key, slots[key]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$1 in normalSlots) {
    if (!(key$1 in res)) {
      res[key$1] = proxyNormalSlot(normalSlots, key$1);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', slots ? !!slots.$stable : true);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    return res && res.length === 0 ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject$1(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if (!isObject$1(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity$1;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject$1(value)) {
      warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);

        if (!(key in hash) && !(camelizedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + camelizedKey] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject$1(value)) {
      warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
hasDynamicKeys, res) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, hasDynamicKeys, res);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (key !== '' && key !== null) {
      // null is a speical value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString$1;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject$1(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject$1(data.style)) {
    traverse(data.style);
  }

  if (isObject$1(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  }
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack becaues all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if (vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if (Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject$1(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  var owner = currentRenderingInstance;

  if (isDef(factory.owners)) {
    // already pending
    factory.owners.push(owner);
  } else {
    var owners = factory.owners = [owner];
    var sync = true;

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
      warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject$1(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject("timeout (" + res.timeout + "ms)");
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if (config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop$1, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.

  var hasDynamicScopedSlot = !!(parentVnode.data.scopedSlots && !parentVnode.data.scopedSlots.$stable || vm.$scopedSlots !== emptyObject && !vm.$scopedSlots.$stable); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  {
    circular = {};
  }
  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.

if (inBrowser && getNow() > document.createEvent('Event').timeStamp) {
  // if the low-res timestamp which is bigger than the event timestamp
  // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
  // and we need to use the hi-res version for event listeners as well.
  getNow = function () {
    return performance.now();
  };
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if (has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if (!config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = expOrFn.toString(); // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop$1;
      warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject$1(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop$1,
  set: noop$1
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.

    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject$1(data)) {
    data = {};
    warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];
    {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
      warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if (getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop$1, noop$1, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop$1;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop$1;
    sharedPropertyDefinition.set = userDef.set || noop$1;
  }

  if (sharedPropertyDefinition.set === noop$1) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop$1 : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject$1(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject$1(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
      }
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if (config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    {
      initProxy(vm);
    } // expose real self

    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if (config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if (!(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if (name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject$1(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];

  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.6';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject$1(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
      warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps =
/*#__PURE__*/
Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if (data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;
    {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5B:
          square++;
          break;
        // [

        case 0x5D:
          square--;
          break;
        // ]

        case 0x7B:
          curly++;
          break;
        // {

        case 0x7D:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);

          if (p !== ' ') {
            break;
          }
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');

  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
  }
}
/*  */

/* eslint-disable no-unused-vars */


function baseWarn(msg, range) {
  console.error("[Vue compiler]: " + msg);
}
/* eslint-enable no-unused-vars */


function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
}

function addAttr(el, name, value, range, dynamic) {
  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
  attrs.push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
} // add a raw attr (use this in preTransforms)


function addRawAttr(el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({
    name: name,
    value: value
  }, range));
}

function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker(symbol, name, dynamic) {
  return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
}

function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
  modifiers = modifiers || emptyObject; // warn prevent and passive modifier

  /* istanbul ignore if */

  if (warn && modifiers.prevent && modifiers.passive) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
  } // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.


  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  } // check capture modifier


  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }

  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */


  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;

  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({
    value: value.trim(),
    dynamic: dynamic
  }, range);

  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */

  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr(el, name) {
  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);

  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);

    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
} // note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.


function getAndRemoveAttr(el, name, removeFromMap) {
  var val;

  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;

    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }

  if (removeFromMap) {
    delete el.attrsMap[name];
  }

  return val;
}

function getAndRemoveAttrByRegex(el, name) {
  var list = el.attrsList;

  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];

    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr;
    }
  }
}

function rangeSetItem(item, range) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }

    if (range.end != null) {
      item.end = range.end;
    }
  }

  return item;
}
/*  */

/**
 * Cross-platform code generation for component v-model
 */


function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;
  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;

  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var assignment = genAssignmentCode(value, valueExpression);
  el.model = {
    value: "(" + value + ")",
    expression: JSON.stringify(value),
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}
/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


function genAssignmentCode(value, assignment) {
  var res = parseModel(value);

  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}
/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */


var len, str, chr, index$1, expressionPos, expressionEndPos;

function parseModel(val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');

    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */

    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;

  while (!eof()) {
    chr = next();

    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }

    if (chr === 0x5B) {
      inBracket++;
    }

    if (chr === 0x5D) {
      inBracket--;
    }

    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;

  while (!eof()) {
    chr = next();

    if (chr === stringQuote) {
      break;
    }
  }
}
/*  */


var warn$1; // in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;
  {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
  } // ensure runtime directive metadata


  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type

  {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];

    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
    }
  }
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
  var valueExpression = '$event.target.value';

  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);

  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);

  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.


function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // #9462 bail for iOS 9 bug: event.timeStamp is 0 after history.pushState
      e.timeStamp === 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    } // skip the update if old and new VDOM state is the same.
    // the only exception is `value` where the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This also covers #4521 by skipping the unnecesarry `checked` update.


    if (key !== 'value' && cur === oldProps[key]) {
      continue;
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else {
      elm[key] = cur;
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject$1(duration) ? duration.enter : duration);

  if (explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject$1(duration) ? duration.leave : duration);

  if (isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue$1);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue$1);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
    warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue$1(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue$1(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue$1(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if (children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if (mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop$1; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if (config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;

  if (!tagRE.test(text)) {
    return;
  }

  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;

  while (match = tagRE.exec(text)) {
    index = match.index; // push text token

    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    } // tag token


    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    rawTokens.push({
      '@binding': exp
    });
    lastIndex = index + match[0].length;
  }

  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }

  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  };
}
/*  */


function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');

  if (staticClass) {
    var res = parseText(staticClass, options.delimiters);

    if (res) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
    }
  }

  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }

  var classBinding = getBindingAttr(el, 'class', false
  /* getStatic */
  );

  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';

  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }

  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }

  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};
/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');

  if (staticStyle) {
    /* istanbul ignore if */
    {
      var res = parseText(staticStyle, options.delimiters);

      if (res) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false
  /* getStatic */
  );

  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';

  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }

  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }

  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};
/*  */

var decoder;
var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};
/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open
// (and which close themselves)

var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
/**
 * Not type-checking this file because it's mostly vendor code.
 */
// Regular Expressions for parsing tags and attributes

var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeLetters + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page

var comment = /^<!\--/;
var conditionalComment = /^<!\[/; // Special Elements (can contain anything)

var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};
var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992

var isIgnoreNewlineTag = makeMap('pre,textarea', true);

var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;

  while (html) {
    last = html; // Make sure we're not in a plaintext content element like script/style

    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');

      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }

            advance(commentEnd + 3);
            continue;
          }
        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        } // Doctype:


        var doctypeMatch = html.match(doctype);

        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        } // End tag:


        var endTagMatch = html.match(endTag);

        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        } // Start tag:


        var startTagMatch = parseStartTag();

        if (startTagMatch) {
          handleStartTag(startTagMatch);

          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }

          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;

      if (textEnd >= 0) {
        rest = html.slice(textEnd);

        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);

          if (next < 0) {
            break;
          }

          textEnd += next;
          rest = html.slice(textEnd);
        }

        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;

        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
          .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }

        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }

        if (options.chars) {
          options.chars(text);
        }

        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);

      if (!stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"", {
          start: index + html.length
        });
      }

      break;
    }
  } // Clean up any remaining tags


  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);

    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;

      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }

      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }

      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
    var l = match.attrs.length;
    var attrs = new Array(l);

    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };

      if (options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({
        tag: tagName,
        lowerCasedTag: tagName.toLowerCase(),
        attrs: attrs,
        start: match.start,
        end: match.end
      });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;

    if (start == null) {
      start = index;
    }

    if (end == null) {
      end = index;
    } // Find the closest opened tag of the same type


    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();

      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (i > pos || !tagName && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.", {
            start: stack[i].start
          });
        }

        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      } // Remove the open elements from the stack


      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }

      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}
/*  */


var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;
var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.]+/g;
var slotRE = /^v-slot(:|$)|^#/;
var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /\s+/g;
var invalidAttributeRE = /[\s"'<>\/=]/;
var decodeHTMLCached = cached(he.decode);
var emptySlotScopeToken = "_empty_"; // configurable state

var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  };
}
/**
 * Convert HTML string to AST.
 */


function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;

  maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;
  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement(element) {
    trimEndingWhitespace(element);

    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    } // tree management


    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else {
        warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", {
          start: element.start
        });
      }
    }

    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"';
          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }

        currentParent.children.push(element);
        element.parent = currentParent;
      }
    } // final children cleanup
    // filter out scoped slots


    element.children = element.children.filter(function (c) {
      return !c.slotScope;
    }); // remove trailing whitespace node again

    trimEndingWhitespace(element); // check pre state

    if (element.pre) {
      inVPre = false;
    }

    if (platformIsPreTag(element.tag)) {
      inPre = false;
    } // apply post-transforms


    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace(el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;

      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints(el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', {
        start: el.start
      });
    }

    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start(tag, attrs, unary, start$1) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug

      /* istanbul ignore if */

      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);

      if (ns) {
        element.ns = ns;
      }

      {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated;
          }, {});
        }

        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
              start: attr.start + attr.name.indexOf("["),
              end: attr.start + attr.name.length
            });
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', {
          start: element.start
        });
      } // apply pre-transforms


      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);

        if (element.pre) {
          inVPre = true;
        }
      }

      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }

      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },
    end: function end(tag, start, end$1) {
      var element = stack[stack.length - 1]; // pop stack

      stack.length -= 1;
      currentParent = stack[stack.length - 1];

      if (options.outputSourceRange) {
        element.end = end$1;
      }

      closeElement(element);
    },
    chars: function chars(text, start, end) {
      if (!currentParent) {
        {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.', {
              start: start
            });
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.", {
              start: start
            });
          }
        }
        return;
      } // IE textarea placeholder bug

      /* istanbul ignore if */


      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }

      var children = currentParent.children;

      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }

      if (text) {
        if (whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }

        var res;
        var child;

        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }

        if (child) {
          if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }

          children.push(child);
        }
      }
    },
    comment: function comment(text, start, end) {
      // adding anyting as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };

        if (options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }

        currentParent.children.push(child);
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var list = el.attrsList;
  var len = list.length;

  if (len) {
    var attrs = el.attrs = new Array(len);

    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };

      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element); // determine whether this is a plain element after
  // removing structural attributes

  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);

  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }

  processAttrs(element);
  return element;
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');

  if (exp) {
    {
      if (el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
      }

      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;

        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true
          /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');

  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;

  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var res = parseFor(exp);

    if (res) {
      extend(el, res);
    } else {
      warn$2("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
    }
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);

  if (!inMatch) {
    return;
  }

  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);

  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();

    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }

  return res;
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');

  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }

    var elseif = getAndRemoveAttr(el, 'v-else-if');

    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);

  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
  }
}

function findPrevElement(children) {
  var i = children.length;

  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
      }

      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }

  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');

  if (once$$1 != null) {
    el.once = true;
  }
} // handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">


function processSlotContent(el) {
  var slotScope;

  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */

    if (slotScope) {
      warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
    }

    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
    /* istanbul ignore if */
    if (el.attrsMap['v-for']) {
      warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
    }

    el.slotScope = slotScope;
  } // slot="xxx"


  var slotTarget = getBindingAttr(el, 'slot');

  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.

    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  } // 2.6 v-slot syntax


  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding) {
        {
          if (el.slotTarget || el.slotScope) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.parent && !maybeComponent(el.parent)) {
            warn$2("<template v-slot> can only appear at the root level inside " + "the receiving the component", el);
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding$1) {
        {
          if (!maybeComponent(el)) {
            warn$2("v-slot can only be used on components or <template>.", slotBinding$1);
          }

          if (el.slotScope || el.slotTarget) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.scopedSlots) {
            warn$2("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
          }
        } // add the component's children to its default slot

        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true;
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now

        el.children = []; // mark el non-plain so data gets generated

        el.plain = false;
      }
    }
  }
}

function getSlotName(binding) {
  var name = binding.name.replace(slotRE, '');

  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else {
      warn$2("v-slot shorthand syntax requires a slot name.", binding);
    }
  }

  return dynamicArgRE.test(name) // dynamic [name]
  ? {
    name: name.slice(1, -1),
    dynamic: true // static name

  } : {
    name: "\"" + name + "\"",
    dynamic: false
  };
} // handle <slot/> outlets


function processSlotOutlet(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');

    if (el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
    }
  }
}

function processComponent(el) {
  var binding;

  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }

  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;

  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;

    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true; // modifiers

      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier

      if (modifiers) {
        name = name.replace(modifierRE, '');
      }

      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        if (value.trim().length === 0) {
          warn$2("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
        }

        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);

            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }

          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }

          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");

            if (!isDynamic) {
              addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);

              if (hyphenate(name) !== camelize(name)) {
                addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
              }
            } else {
              // handler w/ dynamic event name
              addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$2, list[i], true // dynamic
              );
            }
          }
        }

        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else {
        // normal directives
        name = name.replace(dirRE, ''); // parse arg

        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;

        if (arg) {
          name = name.slice(0, -(arg.length + 1));

          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }

        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);

        if (name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      {
        var res = parseText(value, delimiters);

        if (res) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation

      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;

  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }

    parent = parent.parent;
  }

  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);

  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};

  for (var i = 0, l = attrs.length; i < l; i++) {
    if (map[attrs[i].name] && !isIE && !isEdge) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }

    map[attrs[i].name] = attrs[i].value;
  }

  return map;
} // for script (e.g. type="x/template") or style, do not decode content


function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;
/* istanbul ignore next */

function guardIESVGBug(attrs) {
  var res = [];

  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];

    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }

  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;

  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
    }

    _el = _el.parent;
  }
}
/*  */


function preTransformNode(el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;

    if (!map['v-model']) {
      return;
    }

    var typeBinding;

    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }

    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + map['v-bind'] + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox

      var branch0 = cloneASTElement(el); // process for on the main node

      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed

      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      }); // 2. add radio else-if condition

      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      }); // 3. other

      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0;
    }
  }
}

function cloneASTElement(el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}

var model$1 = {
  preTransformNode: preTransformNode
};
var modules$1 = [klass$1, style$1, model$1];
/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
  }
}
/*  */


function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};
/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};
/*  */

var isStaticKey;
var isPlatformReservedTag;
var genStaticKeysCached = cached(genStaticKeys$1);
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */

function optimize(root, options) {
  if (!root) {
    return;
  }

  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.

  markStatic$1(root); // second pass: mark static roots.

  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);

  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }

    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);

      if (!child.static) {
        node.static = false;
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);

        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    } // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.


    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }

    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }

  if (node.type === 3) {
    // text
    return true;
  }

  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;

    if (node.tag !== 'template') {
      return false;
    }

    if (node.for) {
      return true;
    }
  }

  return false;
}
/*  */


var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases

var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
}; // KeyboardEvent.key aliases

var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
}; // #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once

var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";

  for (var name in events) {
    var handlerCode = genHandler(events[name]);

    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }

  staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";

  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
  } else {
    return prefix + staticHandlers;
  }
}

function genHandler(handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }

    return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];

    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key]; // left/right

        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }

    if (keys.length) {
      code += genKeyFilter(keys);
    } // Make sure modifiers like prevent and stop get executed after key filtering


    if (genModifierCode) {
      code += genModifierCode;
    }

    var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return (// make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
  );
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);

  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }

  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
}
/*  */


function on(el, dir) {
  if (dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }

  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}
/*  */


function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}
/*  */


var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop$1
};
/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;

  this.maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;

    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;

      if (!el.plain || el.pre && state.maybeComponent(el)) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    } // module transforms


    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }

    return code;
  }
} // hoist static sub-trees out


function genStatic(el, state) {
  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.

  var originalPreState = state.pre;

  if (el.pre) {
    state.pre = el.pre;
  }

  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  state.pre = originalPreState;
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
} // v-once


function genOnce(el, state) {
  el.onceProcessed = true;

  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;

    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }

      parent = parent.parent;
    }

    if (!key) {
      state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
      return genElement(el, state);
    }

    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion

  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();

  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  } // v-if with v-once should generate code like (a)?_m(0):_m(1)


  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true
    /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion

  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{'; // directives first.
  // directives may mutate the el's other properties before they are generated.

  var dirs = genDirectives(el, state);

  if (dirs) {
    data += dirs + ',';
  } // key


  if (el.key) {
    data += "key:" + el.key + ",";
  } // ref


  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }

  if (el.refInFor) {
    data += "refInFor:true,";
  } // pre


  if (el.pre) {
    data += "pre:true,";
  } // record original tag name for components using "is" attribute


  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  } // module data generation functions


  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  } // attributes


  if (el.attrs) {
    data += "attrs:" + genProps(el.attrs) + ",";
  } // DOM props


  if (el.props) {
    data += "domProps:" + genProps(el.props) + ",";
  } // event handlers


  if (el.events) {
    data += genHandlers(el.events, false) + ",";
  }

  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  } // slot target
  // only for non-scoped slots


  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  } // scoped slots


  if (el.scopedSlots) {
    data += genScopedSlots(el, el.scopedSlots, state) + ",";
  } // component v-model


  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  } // inline-template


  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);

    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }

  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.

  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
  } // v-bind data wrap


  if (el.wrapData) {
    data = el.wrapData(data);
  } // v-on data wrap


  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }

  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;

  if (!dirs) {
    return;
  }

  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;

  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];

    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }

    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }

  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];

  if (el.children.length !== 1 || ast.type !== 1) {
    state.warn('Inline-template components must have exactly one child element.', {
      start: el.start
    });
  }

  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(el, slots, state) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    ;
  }); // OR when it is inside another scoped slot (the reactivity is disconnected)
  // #9438

  if (!needsForceUpdate) {
    var parent = el.parent;

    while (parent) {
      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken) {
        needsForceUpdate = true;
        break;
      }

      parent = parent.parent;
    }
  }

  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(slots[key], state);
  }).join(',') + "]" + (needsForceUpdate ? ",true" : "") + ")";
}

function containsSlotChild(el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true;
    }

    return el.children.some(containsSlotChild);
  }

  return false;
}

function genScopedSlot(el, state) {
  var isLegacySyntax = el.attrsMap['slot-scope'];

  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null");
  }

  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot);
  }

  var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
  var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}"; // reverse proxy v-slot without scope on this.$slots

  var reverseProxy = slotScope ? "" : ",proxy:true";
  return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;

  if (children.length) {
    var el$1 = children[0]; // optimize single v-for

    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
      return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
    }

    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
  }
} // determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed


function getNormalizationType(children, maybeComponent) {
  var res = 0;

  for (var i = 0; i < children.length; i++) {
    var el = children[i];

    if (el.type !== 1) {
      continue;
    }

    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }

    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }

  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  } else if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
    return {
      // slot props are camelized
      name: camelize(attr.name),
      value: attr.value,
      dynamic: attr.dynamic
    };
  })) : null;
  var bind$$1 = el.attrsMap['v-bind'];

  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }

  if (attrs) {
    res += "," + attrs;
  }

  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }

  return res + ')';
} // componentName is el.component, take it as argument to shun flow's pessimistic refinement


function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var staticProps = "";
  var dynamicProps = "";

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);

    if (prop.dynamic) {
      dynamicProps += prop.name + "," + value + ",";
    } else {
      staticProps += "\"" + prop.name + "\":" + value + ",";
    }
  }

  staticProps = "{" + staticProps.slice(0, -1) + "}";

  if (dynamicProps) {
    return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
  } else {
    return staticProps;
  }
} // #3895, #4268


function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}
/*  */
// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b'); // these unary operators should not be used as property/method names

var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template

function detectErrors(ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode(node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];

        if (value) {
          var range = node.rawAttrsMap[name];

          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", warn, range);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", warn, range);
          }
        }
      }
    }

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent(exp, text, warn, range) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);

  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
  }

  checkExpression(exp, text, warn, range);
}

function checkFor(node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier(ident, type, text, warn, range) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
    }
  }
}

function checkExpression(exp, text, warn, range) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
    } else {
      warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
    }
  }
}
/*  */


var range = 2;

function generateCodeFrame(source, start, end) {
  if (start === void 0) start = 0;
  if (end === void 0) end = source.length;
  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) {
          continue;
        }

        res.push("" + (j + 1) + repeat(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
        var lineLength = lines[j].length;

        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat(" ", pad) + repeat("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat("^", length$1));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}

function repeat(str, n) {
  var result = '';

  while (true) {
    // eslint-disable-line
    if (n & 1) {
      result += str;
    }

    n >>>= 1;

    if (n <= 0) {
      break;
    }

    str += str;
  }

  return result;
}
/*  */


function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({
      err: err,
      code: code
    });
    return noop$1;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);
  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;
    /* istanbul ignore if */

    {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    } // check cache

    var key = options.delimiters ? String(options.delimiters) + template : template;

    if (cache[key]) {
      return cache[key];
    } // compile


    var compiled = compile(template, options); // check compilation errors/tips

    {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
          });
        } else {
          warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
      }

      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) {
            return tip(e.msg, vm);
          });
        } else {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }
    } // turn code into functions

    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    }); // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use

    /* istanbul ignore if */

    {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;
          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }
    return cache[key] = res;
  };
}
/*  */


function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if (options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = {
              msg: msg
            };

            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }

              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }

            (tip ? tips : errors).push(data);
          };
        } // merge custom modules


        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        } // merge custom directives


        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
        } // copy other options


        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;
      var compiled = baseCompile(template.trim(), finalOptions);
      {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}
/*  */
// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.


var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);

  if (options.optimize !== false) {
    optimize(ast, options);
  }

  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});
/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;
/*  */
// check whether current browser encodes a char inside attribute values

var div;

function getShouldDecode(href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0;
} // #3663: IE encodes newlines inside attribute values while other browsers don't


var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]

var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;
/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});
var mount = Vue.prototype.$mount;

Vue.prototype.$mount = function (el, hydrating) {
  el = el && query(el);
  /* istanbul ignore if */

  if (el === document.body || el === document.documentElement) {
    warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options; // resolve template/el and convert to render function

  if (!options.render) {
    var template = options.template;

    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */

          if (!template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }

    if (template) {
      /* istanbul ignore if */
      if (config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;
      /* istanbul ignore if */

      if (config.performance && mark) {
        mark('compile end');
        measure("vue " + this._name + " compile", 'compile', 'compile end');
      }
    }
  }

  return mount.call(this, el, hydrating);
};
/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */


function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue.compile = compileToFunctions;

//
//
//
//
//
//
//
//
//
//
//
//
var script = {
  props: ['options', 'value'],
  data: function data() {
    return {
      selected: null
    };
  },
  mounted: function mounted() {
    this.selected = this.value;
  },
  watch: {
    value: function value(newValue) {
      this.selected = newValue;
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

function createInjector(context) {
  return function (id, style) {
    return addStyle(id, style);
  };
}

var HEAD = document.head || document.getElementsByTagName('head')[0];
var styles = {};

function addStyle(id, css) {
  var group = isOldIE ? css.media || 'default' : id;
  var style = styles[group] || (styles[group] = {
    ids: new Set(),
    styles: []
  });

  if (!style.ids.has(id)) {
    style.ids.add(id);
    var code = css.source;

    if (css.map) {
      // https://developer.chrome.com/devtools/docs/javascript-debugging
      // this makes source maps inside style tags work properly in Chrome
      code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

      code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
    }

    if (!style.element) {
      style.element = document.createElement('style');
      style.element.type = 'text/css';

      if (css.media) {
        style.element.setAttribute('media', css.media);
      }

      HEAD.appendChild(style.element);
    }

    if ('styleSheet' in style.element) {
      style.styles.push(code);
      style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
    } else {
      var index = style.ids.size - 1;
      var textNode = document.createTextNode(code);
      var nodes = style.element.childNodes;

      if (nodes[index]) {
        style.element.removeChild(nodes[index]);
      }

      if (nodes.length) {
        style.element.insertBefore(textNode, nodes[index]);
      } else {
        style.element.appendChild(textNode);
      }
    }
  }
}

var browser = createInjector;

/* script */
var __vue_script__ = script;

/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", [
    _c(
      "select",
      {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.selected,
            expression: "selected"
          }
        ],
        staticClass: "select",
        on: {
          input: function(event) {
            _vm.$emit("input", event.target.value);
          },
          change: function($event) {
            var $$selectedVal = Array.prototype.filter
              .call($event.target.options, function(o) {
                return o.selected
              })
              .map(function(o) {
                var val = "_value" in o ? o._value : o.value;
                return val
              });
            _vm.selected = $event.target.multiple
              ? $$selectedVal
              : $$selectedVal[0];
          }
        }
      },
      _vm._l(_vm.options, function(option) {
        return _c(
          "option",
          { key: option.value, domProps: { value: option.value } },
          [_vm._v("\n      " + _vm._s(option.text) + "\n    ")]
        )
      }),
      0
    )
  ])
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  var __vue_inject_styles__ = function (inject) {
    if (!inject) { return }
    inject("data-v-afd20650_0", { source: "\n\n\n\n\n\n\n\n\n\n", map: {"version":3,"sources":[],"names":[],"mappings":"","file":"select.vue"}, media: undefined });

  };
  /* scoped */
  var __vue_scope_id__ = undefined;
  /* module identifier */
  var __vue_module_identifier__ = undefined;
  /* functional template */
  var __vue_is_functional_template__ = false;
  /* style inject SSR */
  

  
  var SelectComponent = normalizeComponent_1(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    browser,
    undefined
  );

var SelectData = [{
  text: 'All Boroughs',
  value: 'all'
}, {
  text: 'Brooklyn',
  value: 'brooklyn'
}, {
  text: 'Queens',
  value: 'queens'
}, {
  text: 'Manhattan',
  value: 'manhattan'
}, {
  text: 'Staten Island',
  value: 'staten island'
}, {
  text: 'The Bronx',
  value: 'bronx'
}];

var Select = function Select(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


Select.prototype.init = function init() {
  Vue.component('nyco-select', SelectComponent);
  new Vue({
    el: '[data-js="app"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        options: Select.data,
        selected: 'all'
      };
    },
    methods: {}
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


Select.prototype._constants = function _constants(param) {
  console.dir(param);
};

Select.data = SelectData;

function dataHandler(newData, oldData) {
  if (oldData) {
    var chart = this.$data._chart;
    var newDatasetLabels = newData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldDatasetLabels = oldData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldLabels = JSON.stringify(oldDatasetLabels);
    var newLabels = JSON.stringify(newDatasetLabels);

    if (newLabels === oldLabels && oldData.datasets.length === newData.datasets.length) {
      newData.datasets.forEach(function (dataset, i) {
        var oldDatasetKeys = Object.keys(oldData.datasets[i]);
        var newDatasetKeys = Object.keys(dataset);
        var deletionKeys = oldDatasetKeys.filter(function (key) {
          return key !== '_meta' && newDatasetKeys.indexOf(key) === -1;
        });
        deletionKeys.forEach(function (deletionKey) {
          delete chart.data.datasets[i][deletionKey];
        });

        for (var attribute in dataset) {
          if (dataset.hasOwnProperty(attribute)) {
            chart.data.datasets[i][attribute] = dataset[attribute];
          }
        }
      });

      if (newData.hasOwnProperty('labels')) {
        chart.data.labels = newData.labels;
        this.$emit('labels:update');
      }

      if (newData.hasOwnProperty('xLabels')) {
        chart.data.xLabels = newData.xLabels;
        this.$emit('xlabels:update');
      }

      if (newData.hasOwnProperty('yLabels')) {
        chart.data.yLabels = newData.yLabels;
        this.$emit('ylabels:update');
      }

      chart.update();
      this.$emit('chart:update');
    } else {
      if (chart) {
        chart.destroy();
        this.$emit('chart:destroy');
      }

      this.renderChart(this.chartData, this.options);
      this.$emit('chart:render');
    }
  } else {
    if (this.$data._chart) {
      this.$data._chart.destroy();

      this.$emit('chart:destroy');
    }

    this.renderChart(this.chartData, this.options);
    this.$emit('chart:render');
  }
}

var reactiveData = {
  data: function data() {
    return {
      chartData: null
    };
  },
  watch: {
    'chartData': dataHandler
  }
};
var reactiveProp = {
  props: {
    chartData: {
      required: true
    }
  },
  watch: {
    'chartData': dataHandler
  }
};
var mixins = {
  reactiveData: reactiveData,
  reactiveProp: reactiveProp
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var moment = createCommonjsModule(function (module, exports) {

  (function (global, factory) {
    module.exports = factory();
  })(commonjsGlobal, function () {

    var hookCallback;

    function hooks() {
      return hookCallback.apply(null, arguments);
    } // This is done to register the method called with moment()
    // without creating circular dependencies.


    function setHookCallback(callback) {
      hookCallback = callback;
    }

    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
      // IE8 will treat undefined and null as object if it wasn't for
      // input != null
      return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;

        for (k in obj) {
          if (obj.hasOwnProperty(k)) {
            return false;
          }
        }

        return true;
      }
    }

    function isUndefined(input) {
      return input === void 0;
    }

    function isNumber(input) {
      return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
      var res = [],
          i;

      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }

      return res;
    }

    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }

      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }

      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }

      return a;
    }

    function createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
      // We need to deep clone this object.
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }

    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }

      return m._pf;
    }

    var some;

    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }

        return false;
      };
    }

    function isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
          return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }

      return m._isValid;
    }

    function createInvalid(flags) {
      var m = createUTC(NaN);

      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }

      return m;
    } // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.


    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
      var i, prop, val;

      if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
      }

      if (!isUndefined(from._i)) {
        to._i = from._i;
      }

      if (!isUndefined(from._f)) {
        to._f = from._f;
      }

      if (!isUndefined(from._l)) {
        to._l = from._l;
      }

      if (!isUndefined(from._strict)) {
        to._strict = from._strict;
      }

      if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
      }

      if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
      }

      if (!isUndefined(from._offset)) {
        to._offset = from._offset;
      }

      if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
      }

      if (!isUndefined(from._locale)) {
        to._locale = from._locale;
      }

      if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
          prop = momentProperties[i];
          val = from[prop];

          if (!isUndefined(val)) {
            to[prop] = val;
          }
        }
      }

      return to;
    }

    var updateInProgress = false; // Moment prototype object

    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);

      if (!this.isValid()) {
        this._d = new Date(NaN);
      } // Prevent infinite loop in case updateOffset creates new moment
      // objects.


      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }

    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }

    function absFloor(number) {
      if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }

    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;

      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }

      return value;
    } // compare two arrays, return the number of differences


    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;

      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }

      return diffs + lengthDiff;
    }

    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }

    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function () {
        var arguments$1 = arguments;

        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }

        if (firstTime) {
          var args = [];
          var arg;

          for (var i = 0; i < arguments.length; i++) {
            arg = '';

            if (typeof arguments$1[i] === 'object') {
              arg += '\n[' + i + '] ';

              for (var key in arguments[0]) {
                arg += key + ': ' + arguments$1[0][key] + ', ';
              }

              arg = arg.slice(0, -2); // Remove trailing comma and space
            } else {
              arg = arguments$1[i];
            }

            args.push(arg);
          }

          warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
          firstTime = false;
        }

        return fn.apply(this, arguments);
      }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }

      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set(config) {
      var prop, i;

      for (i in config) {
        prop = config[i];

        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }

      this._config = config; // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
      // TODO: Remove "ordinalParse" fallback in next major release.

      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
    }

    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig),
          prop;

      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }

      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          // make sure changes to properties don't modify parent config
          res[prop] = extend({}, res[prop]);
        }
      }

      return res;
    }

    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }

    var keys;

    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function (obj) {
        var i,
            res = [];

        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }

        return res;
      };
    }

    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };

    function calendar(key, mom, now) {
      var output = this._calendar[key] || this._calendar['sameElse'];
      return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];

      if (format || !formatUpper) {
        return format;
      }

      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
      });
      return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
      return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;

      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);

          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }

      return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
      var units = [];

      for (var u in unitsObj) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }

      units.sort(function (a, b) {
        return a.priority - b.priority;
      });
      return units;
    }

    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {}; // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }

    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;

      if (typeof callback === 'string') {
        func = function () {
          return this[callback]();
        };
      }

      if (token) {
        formatTokenFunctions[token] = func;
      }

      if (padded) {
        formatTokenFunctions[padded[0]] = function () {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }

      if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }

    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }

      return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;

      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }

      return function (mom) {
        var output = '',
            i;

        for (i = 0; i < length; i++) {
          output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }

        return output;
      };
    } // format date using native date object


    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }

      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
      return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
      var i = 5;

      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }

      localFormattingTokens.lastIndex = 0;

      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }

      return format;
    }

    var match1 = /\d/; //       0 - 9

    var match2 = /\d\d/; //      00 - 99

    var match3 = /\d{3}/; //     000 - 999

    var match4 = /\d{4}/; //    0000 - 9999

    var match6 = /[+-]?\d{6}/; // -999999 - 999999

    var match1to2 = /\d\d?/; //       0 - 99

    var match3to4 = /\d\d\d\d?/; //     999 - 9999

    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

    var match1to3 = /\d{1,3}/; //       0 - 999

    var match1to4 = /\d{1,4}/; //       0 - 9999

    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

    var matchUnsigned = /\d+/; //       0 - inf

    var matchSigned = /[+-]?\d+/; //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months

    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }

    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }

      return regexes[token](config._strict, config._locale);
    } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


    function unescapeFormat(s) {
      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }

    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
      var i,
          func = callback;

      if (typeof token === 'string') {
        token = [token];
      }

      if (isNumber(callback)) {
        func = function (input, array) {
          array[callback] = toInt(input);
        };
      }

      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }

    function addWeekParseToken(token, callback) {
      addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }

    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8; // FORMATTING

    addFormatToken('Y', 0, 0, function () {
      var y = this.year();
      return y <= 9999 ? '' + y : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

    addUnitAlias('year', 'y'); // PRIORITIES

    addUnitPriority('year', 1); // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
      array[YEAR] = parseInt(input, 10);
    }); // HELPERS

    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    } // HOOKS


    hooks.parseTwoDigitYear = function (input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    }; // MOMENTS


    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
      return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
      return function (value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }

    function get(mom, unit) {
      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        } else {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
      }
    } // MOMENTS


    function stringGet(units) {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units]();
      }

      return this;
    }

    function stringSet(units, value) {
      if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);

        for (var i = 0; i < prioritized.length; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);

        if (isFunction(this[units])) {
          return this[units](value);
        }
      }

      return this;
    }

    function mod(n, x) {
      return (n % x + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function (o) {
        // I know
        var i;

        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }

        return -1;
      };
    }

    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }

      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    } // FORMATTING


    addFormatToken('M', ['MM', 2], 'Mo', function () {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
      return this.localeData().months(this, format);
    }); // ALIASES

    addUnitAlias('month', 'M'); // PRIORITY

    addUnitPriority('month', 8); // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
      return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    }); // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

    function localeMonths(m, format) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months['standalone'];
      }

      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

    function localeMonthsShort(m, format) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
      }

      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
      var i,
          ii,
          mom,
          llc = monthName.toLocaleLowerCase();

      if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];

        for (i = 0; i < 12; ++i) {
          mom = createUTC([2000, i]);
          this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeMonthsParse(monthName, format, strict) {
      var i, mom, regex;

      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
      }

      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      } // TODO: add sorting
      // Sorting makes sure if one month (or abbr) is a prefix of another
      // see sorting in computeMonthsParse


      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);

        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }

        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    } // MOMENTS


    function setMonth(mom, value) {
      var dayOfMonth;

      if (!mom.isValid()) {
        // No op
        return mom;
      }

      if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

          if (!isNumber(value)) {
            return mom;
          }
        }
      }

      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

      return mom;
    }

    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, 'Month');
      }
    }

    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;

    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }

        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }

    var defaultMonthsRegex = matchWord;

    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
          this._monthsRegex = defaultMonthsRegex;
        }

        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }

    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom;

      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
      } // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.


      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }

      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate(y, m, d, h, M, s, ms) {
      // can't just apply() to create a date:
      // https://stackoverflow.com/q/181348
      var date; // the date constructor remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        date = new Date(y + 400, m, d, h, M, s, ms);

        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h, M, s, ms);
      }

      return date;
    }

    function createUTCDate(y) {
      var date; // the Date.UTC function remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));

        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }

      return date;
    } // start-of-first-week - start-of-year


    function firstWeekOffset(year, dow, doy) {
      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;

      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }

      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }

    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;

      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }

      return {
        week: resWeek,
        year: resYear
      };
    }

    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    } // FORMATTING


    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W'); // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5); // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    }); // HELPERS
    // LOCALES

    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    };

    function localeFirstDayOfWeek() {
      return this._week.dow;
    }

    function localeFirstDayOfYear() {
      return this._week.doy;
    } // MOMENTS


    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    } // FORMATTING


    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E'); // PRIORITY

    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11); // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
      return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
      return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
      return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
      week[token] = toInt(input);
    }); // HELPERS

    function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
        return input;
      }

      if (!isNaN(input)) {
        return parseInt(input, 10);
      }

      input = locale.weekdaysParse(input);

      if (typeof input === 'number') {
        return input;
      }

      return null;
    }

    function parseIsoWeekday(input, locale) {
      if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
      }

      return isNaN(input) ? null : input;
    } // LOCALES


    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

    function localeWeekdays(m, format) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
      var i,
          ii,
          mom,
          llc = weekdayName.toLocaleLowerCase();

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
          mom = createUTC([2000, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
      var i, mom, regex;

      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
      }

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);

        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
          this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
          this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
        }

        if (!this._weekdaysParse[i]) {
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    } // MOMENTS


    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }

    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      } // behaves the same as moment#day except
      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
      // as a setter, sunday should belong to the previous week.


      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }

    var defaultWeekdaysRegex = matchWord;

    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }

        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }

    var defaultWeekdaysShortRegex = matchWord;

    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }

        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }

    var defaultWeekdaysMinRegex = matchWord;

    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }

        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }

    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var minPieces = [],
          shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          minp,
          shortp,
          longp;

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.


      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    } // FORMATTING


    function hFormat() {
      return this.hours() % 12 || 12;
    }

    function kFormat() {
      return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }

    meridiem('a', true);
    meridiem('A', false); // ALIASES

    addUnitAlias('hour', 'h'); // PRIORITY

    addUnitPriority('hour', 13); // PARSING

    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    }); // LOCALES

    function localeIsPM(input) {
      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
      // Using charAt should be more compatible.
      return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    } // MOMENTS
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.


    var getSetHour = makeGetSet('Hours', true);
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    }; // internal storage for locale config files

    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    } // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;

      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;

        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));

          if (locale) {
            return locale;
          }

          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            //the next array item is better than a shallower substring of this one
            break;
          }

          j--;
        }

        i++;
      }

      return globalLocale;
    }

    function loadLocale(name) {
      var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

      if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          var aliasedRequire = commonjsRequire;
          aliasedRequire('./locale/' + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }

      return locales[name];
    } // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.


    function getSetGlobalLocale(key, values) {
      var data;

      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }

        if (data) {
          // moment.duration._locale = moment._locale = data;
          globalLocale = data;
        } else {
          if (typeof console !== 'undefined' && console.warn) {
            //warn user if arguments are passed but the locale could not be set
            console.warn('Locale ' + key + ' not found. Did you forget to load it?');
          }
        }
      }

      return globalLocale._abbr;
    }

    function defineLocale(name, config) {
      if (config !== null) {
        var locale,
            parentConfig = baseConfig;
        config.abbr = name;

        if (locales[name] != null) {
          deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale = loadLocale(config.parentLocale);

            if (locale != null) {
              parentConfig = locale._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }

              localeFamilies[config.parentLocale].push({
                name: name,
                config: config
              });
              return null;
            }
          }
        }

        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function (x) {
            defineLocale(x.name, x.config);
          });
        } // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.


        getSetGlobalLocale(name);
        return locales[name];
      } else {
        // useful for testing
        delete locales[name];
        return null;
      }
    }

    function updateLocale(name, config) {
      if (config != null) {
        var locale,
            tmpLocale,
            parentConfig = baseConfig; // MERGE

        tmpLocale = loadLocale(name);

        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }

        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale; // backwards compat for now: also set the locale

        getSetGlobalLocale(name);
      } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }

      return locales[name];
    } // returns locale data


    function getLocale(key) {
      var locale;

      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }

      if (!key) {
        return globalLocale;
      }

      if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);

        if (locale) {
          return locale;
        }

        key = [key];
      }

      return chooseLocale(key);
    }

    function listLocales() {
      return keys(locales);
    }

    function checkOverflow(m) {
      var overflow;
      var a = m._a;

      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }

        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }

        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
      }

      return m;
    } // Pick the first defined of two or three arguments.


    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }

      if (b != null) {
        return b;
      }

      return c;
    }

    function currentDateArray(config) {
      // hooks is actually the exported moment object
      var nowValue = new Date(hooks.now());

      if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
      }

      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    } // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]


    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          expectedWeekday,
          yearToUse;

      if (config._d) {
        return;
      }

      currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      } //if the day of the year is set, figure out what it is


      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      } // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything


      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      } // Zero out whatever was not defaulted, including time


      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      } // Check for 24:00:00.000


      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }

      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
      // with parseZone.

      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }

      if (config._nextDay) {
        config._a[HOUR] = 24;
      } // check for mismatching day of week


      if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }

    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
      w = config._w;

      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).

        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);

        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        var curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
          // weekday -- low day numbers are considered next week
          weekday = w.d;

          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          // local weekday -- counting starts from beginning of week
          weekday = w.e + dow;

          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          // default to beginning of week
          weekday = dow;
        }
      }

      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    } // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat;

      if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }

        if (dateFormat == null) {
          config._isValid = false;
          return;
        }

        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              // match[2] should be 'T' or space
              timeFormat = (match[2] || ' ') + isoTimes[i][0];
              break;
            }
          }

          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }

        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }

        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = 'Z';
          } else {
            config._isValid = false;
            return;
          }
        }

        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }

      return result;
    }

    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);

      if (year <= 49) {
        return 2000 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }

      return year;
    }

    function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }

      return true;
    }

    var obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
      } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100,
            h = (hm - m) / 100;
        return h * 60 + m;
      }
    } // date and time from ref 2822 format


    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i));

      if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);

        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    } // date from iso format or fallback


    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);

      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }

      configFromISO(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }

      configFromRFC2822(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      } // Final attempt, use Input Fallback


      hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }); // constant that refers to the ISO standard

    hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


    hooks.RFC_2822 = function () {}; // date from string and format string


    function configFromStringAndFormat(config) {
      // TODO: Move this to another part of the creation flow to prevent circular deps
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }

      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }

      config._a = [];
      getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));

        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));

          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }

          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        } // don't parse if it's not a known token


        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }

          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      } // add remaining unparsed input length to the string


      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      } // clear _12h flag if hour is <= 12


      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }

      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;

      if (meridiem == null) {
        // nothing to do
        return hour;
      }

      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);

        if (isPm && hour < 12) {
          hour += 12;
        }

        if (!isPm && hour === 12) {
          hour = 0;
        }

        return hour;
      } else {
        // this is not supposed to happen
        return hour;
      }
    } // date from string and array of format strings


    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore;

      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }

      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);

        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }

        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
          continue;
        } // if there is any input that was not parsed add a penalty for that format


        currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }

      extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
      if (config._d) {
        return;
      }

      var i = normalizeObjectUnits(config._i);
      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }

    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));

      if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
      }

      return res;
    }

    function prepareConfig(config) {
      var input = config._i,
          format = config._f;
      config._locale = config._locale || getLocale(config._l);

      if (input === null || format === undefined && input === '') {
        return createInvalid({
          nullInput: true
        });
      }

      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }

      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }

      if (!isValid(config)) {
        config._d = null;
      }

      return config;
    }

    function configFromInput(config) {
      var input = config._i;

      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};

      if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
      }

      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = undefined;
      } // object construction must be done this way.
      // https://github.com/moment/moment/issues/1423


      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    }); // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.

    function pickBy(fn, moments) {
      var res, i;

      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }

      if (!moments.length) {
        return createLocal();
      }

      res = moments[0];

      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }

      return res;
    } // TODO: Use [].sort instead?


    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }

    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }

    var now = function () {
      return Date.now ? Date.now() : +new Date();
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
      for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }

      var unitHasDecimal = false;

      for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false; // only allow non-integers for smallest unit
          }

          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }

      return true;
    }

    function isValid$1() {
      return this._isValid;
    }

    function createInvalid$1() {
      return createDuration(NaN);
    }

    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

      this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
      minutes * 6e4 + // 1000 * 60
      hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately

      this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.

      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = getLocale();

      this._bubble();
    }

    function isDuration(obj) {
      return obj instanceof Duration;
    }

    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    } // FORMATTING


    function offset(token, separator) {
      addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';

        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }

        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
      });
    }

    offset('Z', ':');
    offset('ZZ', ''); // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    }); // HELPERS
    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']

    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher);

      if (matches === null) {
        return null;
      }

      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    } // Return a moment from input, that is local/utc/zone equivalent to model.


    function cloneWithOffset(input, model) {
      var res, diff;

      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

        res._d.setTime(res._d.valueOf() + diff);

        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }

    function getDateOffset(m) {
      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
      // https://github.com/moment/moment/pull/1871
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    } // HOOKS
    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.


    hooks.updateOffset = function () {}; // MOMENTS
    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.


    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset = this._offset || 0,
          localAdjust;

      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(matchShortOffset, input);

          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }

        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }

        this._offset = input;
        this._isUTC = true;

        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }

        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(this, createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }

        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }

    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }

        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }

    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }

      return this;
    }

    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);

        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }

      return this;
    }

    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }

      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }

    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }

      var c = {};
      copyConfig(c, this);
      c = prepareConfig(c);

      if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }

      return this._isDSTShifted;
    }

    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    } // ASP.NET json date format regex


    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day

    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
      var duration = input,
          // matching against regexp is expensive, do it on demand
      match = null,
          sign,
          ret,
          diffRes;

      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input)) {
        duration = {};

        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

        };
      } else if (!!(match = isoRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          w: parseIso(match[4], sign),
          d: parseIso(match[5], sign),
          h: parseIso(match[6], sign),
          m: parseIso(match[7], sign),
          s: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        // checks for null or undefined
        duration = {};
      } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }

      ret = new Duration(duration);

      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }

      return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
      // We'd normally use ~~inp for this, but unfortunately it also
      // converts floats to ints.
      // inp may be undefined, so careful calling replace on it.
      var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

      return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }

      res.milliseconds = +other - +base.clone().add(res.months, 'M');
      return res;
    }

    function momentsDifference(base, other) {
      var res;

      if (!(base.isValid() && other.isValid())) {
        return {
          milliseconds: 0,
          months: 0
        };
      }

      other = cloneWithOffset(other, base);

      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }

      return res;
    } // TODO: remove 'name' arg after deprecation is removed


    function createAdder(direction, name) {
      return function (val, period) {
        var dur, tmp; //invert the arguments, but complain about it

        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
          tmp = val;
          val = period;
          period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);

      if (!mom.isValid()) {
        // No op
        return;
      }

      updateOffset = updateOffset == null ? true : updateOffset;

      if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
      }

      if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
      }

      if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }

      if (updateOffset) {
        hooks.updateOffset(mom, days || months);
      }
    }

    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
      var diff = myMoment.diff(now, 'days', true);
      return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1(time, formats) {
      // We want to compare the start of today, vs this.
      // Getting start-of-today depends on whether we're local/utc/offset or not.
      var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse';
      var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
      return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone() {
      return new Moment(this);
    }

    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }

    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }

    function isBetween(from, to, units, inclusivity) {
      var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);

      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }

      inclusivity = inclusivity || '()';
      return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }

    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
      var that, zoneDelta, output;

      if (!this.isValid()) {
        return NaN;
      }

      that = cloneWithOffset(input, this);

      if (!that.isValid()) {
        return NaN;
      }

      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);

      switch (units) {
        case 'year':
          output = monthDiff(this, that) / 12;
          break;

        case 'month':
          output = monthDiff(this, that);
          break;

        case 'quarter':
          output = monthDiff(this, that) / 3;
          break;

        case 'second':
          output = (this - that) / 1e3;
          break;
        // 1000

        case 'minute':
          output = (this - that) / 6e4;
          break;
        // 1000 * 60

        case 'hour':
          output = (this - that) / 36e5;
          break;
        // 1000 * 60 * 60

        case 'day':
          output = (this - that - zoneDelta) / 864e5;
          break;
        // 1000 * 60 * 60 * 24, negate dst

        case 'week':
          output = (this - that - zoneDelta) / 6048e5;
          break;
        // 1000 * 60 * 60 * 24 * 7, negate dst

        default:
          output = this - that;
      }

      return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
      // difference in months
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;

      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor2 - anchor);
      } //check for negative zero, return zero if negative zero


      return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }

      var utc = keepOffset !== true;
      var m = utc ? this.clone().utc() : this;

      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
      }

      return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */


    function inspect() {
      if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
      }

      var func = 'moment';
      var zone = '';

      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
      }

      var prefix = '[' + func + '("]';
      var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
      var datetime = '-MM-DD[T]HH:mm:ss.SSS';
      var suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }

      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          to: this,
          from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          from: this,
          to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    } // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.


    function locale(key) {
      var newLocaleData;

      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);

        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }

        return this;
      }
    }

    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });

    function localeData() {
      return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }

    function utcStartOfDate(y, m, d) {
      // Date.UTC remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }

    function startOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year(), 0, 1);
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;

        case 'month':
          time = startOfDate(this.year(), this.month(), 1);
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date());
          break;

        case 'hour':
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;

        case 'minute':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;

        case 'second':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function endOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

        case 'month':
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;

        case 'hour':
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;

        case 'minute':
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;

        case 'second':
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
      return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
      return new Date(this.valueOf());
    }

    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }

    function toJSON() {
      // new Date(NaN).toJSON() === null
      return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
      return isValid(this);
    }

    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
      return getParsingFlags(this).overflow;
    }

    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    } // FORMATTING


    addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
      return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1); // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
      week[token] = hooks.parseTwoDigitYear(input);
    }); // MOMENTS

    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;

      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;

      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);

        if (week > weeksTarget) {
          week = weeksTarget;
        }

        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    } // FORMATTING


    addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

    addUnitAlias('quarter', 'Q'); // PRIORITY

    addUnitPriority('quarter', 7); // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    }); // MOMENTS

    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    } // FORMATTING


    addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

    addUnitAlias('date', 'D'); // PRIORITY

    addUnitPriority('date', 9); // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
      // TODO: Remove "ordinalParse" fallback in next major release.
      return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    }); // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

    addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

    addUnitPriority('dayOfYear', 4); // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
      config._dayOfYear = toInt(input);
    }); // HELPERS
    // MOMENTS

    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    } // FORMATTING


    addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

    addUnitAlias('minute', 'm'); // PRIORITY

    addUnitPriority('minute', 14); // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE); // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

    addUnitAlias('second', 's'); // PRIORITY

    addUnitPriority('second', 15); // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND); // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

    addFormatToken('S', 0, 0, function () {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
      return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
      return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
      return this.millisecond() * 1000000;
    }); // ALIASES

    addUnitAlias('millisecond', 'ms'); // PRIORITY

    addUnitPriority('millisecond', 16); // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;

    for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
    } // MOMENTS


    var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix(input) {
      return createLocal(input * 1000);
    }

    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
      return string;
    }

    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
      var locale = getLocale();
      var utc = createUTC().set(setter, index);
      return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';

      if (index != null) {
        return get$1(format, index, field, 'month');
      }

      var i;
      var out = [];

      for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
      }

      return out;
    } // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)


    function listWeekdaysImpl(localeSorted, format, index, field) {
      if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      }

      var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0;

      if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
      }

      var i;
      var out = [];

      for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
      }

      return out;
    }

    function listMonths(format, index) {
      return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
      return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function (number) {
        var b = number % 10,
            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        return number + output;
      }
    }); // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;

    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }

    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    } // supports only 2.0-style add(1, 's') or add(duration)


    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    } // supports only 2.0-style subtract(1, 's') or subtract(duration)


    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }

    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
      // check: https://github.com/moment/moment/issues/2166

      if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
      } // The following code bubbles up values, see the tests for
      // examples of what that means.


      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24); // convert days to months

      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }

    function daysToMonths(days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      return days * 4800 / 146097;
    }

    function monthsToDays(months) {
      // the reverse of daysToMonths
      return months * 146097 / 4800;
    }

    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }

      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);

      if (units === 'month' || units === 'quarter' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);

        switch (units) {
          case 'month':
            return months;

          case 'quarter':
            return months / 3;

          case 'year':
            return months / 12;
        }
      } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));

        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;

          case 'day':
            return days + milliseconds / 864e5;

          case 'hour':
            return days * 24 + milliseconds / 36e5;

          case 'minute':
            return days * 1440 + milliseconds / 6e4;

          case 'second':
            return days * 86400 + milliseconds / 1000;
          // Math.floor prevents floating point math errors here

          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;

          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    } // TODO: Use this.as('ms')?


    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }

      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }

    function makeAs(alias) {
      return function () {
        return this.as(alias);
      };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asQuarters = makeAs('Q');
    var asYears = makeAs('y');

    function clone$1() {
      return createDuration(this);
    }

    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
      return function () {
        return this.isValid() ? this._data[name] : NaN;
      };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
      return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month
      M: 11 // months to year

    }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
      var duration = createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    } // This function allows you to set the rounding function for relative time strings


    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === undefined) {
        return round;
      }

      if (typeof roundingFunction === 'function') {
        round = roundingFunction;
        return true;
      }

      return false;
    } // This function allows you to set a threshold for relative time strings


    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }

      if (limit === undefined) {
        return thresholds[threshold];
      }

      thresholds[threshold] = limit;

      if (threshold === 's') {
        thresholds.ss = limit - 1;
      }

      return true;
    }

    function humanize(withSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var locale = this.localeData();
      var output = relativeTime$1(this, !withSuffix, locale);

      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }

      return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
      // for ISO strings we do not use the normal bubbling rules:
      //  * milliseconds bubble up until they become hours
      //  * days do not bubble at all
      //  * months bubble up until they become years
      // This is because there is no context-free conversion between hours and days
      // (think of clock changes)
      // and also not between days and months (28-31 days per month)
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var seconds = abs$1(this._milliseconds) / 1000;
      var days = abs$1(this._days);
      var months = abs$1(this._months);
      var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60; // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
      var total = this.asSeconds();

      if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
      }

      var totalSign = total < 0 ? '-' : '';
      var ymSign = sign(this._months) !== sign(total) ? '-' : '';
      var daysSign = sign(this._days) !== sign(total) ? '-' : '';
      var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
      return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang; // Side effect imports
    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf'); // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
      config._d = new Date(toInt(input));
    }); // Side effect imports

    hooks.version = '2.24.0';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

    hooks.HTML5_FMT = {
      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
      // <input type="datetime-local" step="0.001" />
      DATE: 'YYYY-MM-DD',
      // <input type="date" />
      TIME: 'HH:mm',
      // <input type="time" />
      TIME_SECONDS: 'HH:mm:ss',
      // <input type="time" step="1" />
      TIME_MS: 'HH:mm:ss.SSS',
      // <input type="time" step="0.001" />
      WEEK: 'GGGG-[W]WW',
      // <input type="week" />
      MONTH: 'YYYY-MM' // <input type="month" />

    };
    return hooks;
  });
});

var Chart$1 = createCommonjsModule(function (module, exports) {
  /*!
   * Chart.js v2.8.0
   * https://www.chartjs.org
   * (c) 2019 Chart.js Contributors
   * Released under the MIT License
   */
  (function (global, factory) {
    module.exports = factory(function () {
      try {
        return moment;
      } catch (e) {}
    }());
  })(commonjsGlobal, function (moment) {

    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
    /* MIT license */

    var conversions = {
      rgb2hsl: rgb2hsl,
      rgb2hsv: rgb2hsv,
      rgb2hwb: rgb2hwb,
      rgb2cmyk: rgb2cmyk,
      rgb2keyword: rgb2keyword,
      rgb2xyz: rgb2xyz,
      rgb2lab: rgb2lab,
      rgb2lch: rgb2lch,
      hsl2rgb: hsl2rgb,
      hsl2hsv: hsl2hsv,
      hsl2hwb: hsl2hwb,
      hsl2cmyk: hsl2cmyk,
      hsl2keyword: hsl2keyword,
      hsv2rgb: hsv2rgb,
      hsv2hsl: hsv2hsl,
      hsv2hwb: hsv2hwb,
      hsv2cmyk: hsv2cmyk,
      hsv2keyword: hsv2keyword,
      hwb2rgb: hwb2rgb,
      hwb2hsl: hwb2hsl,
      hwb2hsv: hwb2hsv,
      hwb2cmyk: hwb2cmyk,
      hwb2keyword: hwb2keyword,
      cmyk2rgb: cmyk2rgb,
      cmyk2hsl: cmyk2hsl,
      cmyk2hsv: cmyk2hsv,
      cmyk2hwb: cmyk2hwb,
      cmyk2keyword: cmyk2keyword,
      keyword2rgb: keyword2rgb,
      keyword2hsl: keyword2hsl,
      keyword2hsv: keyword2hsv,
      keyword2hwb: keyword2hwb,
      keyword2cmyk: keyword2cmyk,
      keyword2lab: keyword2lab,
      keyword2xyz: keyword2xyz,
      xyz2rgb: xyz2rgb,
      xyz2lab: xyz2lab,
      xyz2lch: xyz2lch,
      lab2xyz: lab2xyz,
      lab2rgb: lab2rgb,
      lab2lch: lab2lch,
      lch2lab: lch2lab,
      lch2xyz: lch2xyz,
      lch2rgb: lch2rgb
    };

    function rgb2hsl(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          l;

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max == min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    }

    function rgb2hsv(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          v;

      if (max == 0) {
        s = 0;
      } else {
        s = delta / max * 1000 / 10;
      }

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      v = max / 255 * 1000 / 10;
      return [h, s, v];
    }

    function rgb2hwb(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          h = rgb2hsl(rgb)[0],
          w = 1 / 255 * Math.min(r, Math.min(g, b)),
          b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    }

    function rgb2cmyk(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          c,
          m,
          y,
          k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    }

    function rgb2keyword(rgb) {
      return reverseKeywords[JSON.stringify(rgb)];
    }

    function rgb2xyz(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255; // assume sRGB

      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    }

    function rgb2lab(rgb) {
      var xyz = rgb2xyz(rgb),
          x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function rgb2lch(args) {
      return lab2lch(rgb2lab(args));
    }

    function hsl2rgb(hsl) {
      var h = hsl[0] / 360,
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          t1,
          t2,
          t3,
          rgb,
          val;

      if (s == 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        t3 < 0 && t3++;
        t3 > 1 && t3--;

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    }

    function hsl2hsv(hsl) {
      var h = hsl[0],
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          sv,
          v;

      if (l === 0) {
        // no need to do calc on black
        // also avoids divide by 0 error
        return [0, 0, 0];
      }

      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      v = (l + s) / 2;
      sv = 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    }

    function hsl2hwb(args) {
      return rgb2hwb(hsl2rgb(args));
    }

    function hsl2cmyk(args) {
      return rgb2cmyk(hsl2rgb(args));
    }

    function hsl2keyword(args) {
      return rgb2keyword(hsl2rgb(args));
    }

    function hsv2rgb(hsv) {
      var h = hsv[0] / 60,
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          hi = Math.floor(h) % 6;
      var f = h - Math.floor(h),
          p = 255 * v * (1 - s),
          q = 255 * v * (1 - s * f),
          t = 255 * v * (1 - s * (1 - f)),
          v = 255 * v;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    }

    function hsv2hsl(hsv) {
      var h = hsv[0],
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          sl,
          l;
      l = (2 - s) * v;
      sl = s * v;
      sl /= l <= 1 ? l : 2 - l;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    }

    function hsv2hwb(args) {
      return rgb2hwb(hsv2rgb(args));
    }

    function hsv2cmyk(args) {
      return rgb2cmyk(hsv2rgb(args));
    }

    function hsv2keyword(args) {
      return rgb2keyword(hsv2rgb(args));
    } // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


    function hwb2rgb(hwb) {
      var h = hwb[0] / 360,
          wh = hwb[1] / 100,
          bl = hwb[2] / 100,
          ratio = wh + bl,
          i,
          v,
          f,
          n; // wh + bl cant be > 1

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) != 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh); // linear interpolation

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    }

    function hwb2hsl(args) {
      return rgb2hsl(hwb2rgb(args));
    }

    function hwb2hsv(args) {
      return rgb2hsv(hwb2rgb(args));
    }

    function hwb2cmyk(args) {
      return rgb2cmyk(hwb2rgb(args));
    }

    function hwb2keyword(args) {
      return rgb2keyword(hwb2rgb(args));
    }

    function cmyk2rgb(cmyk) {
      var c = cmyk[0] / 100,
          m = cmyk[1] / 100,
          y = cmyk[2] / 100,
          k = cmyk[3] / 100,
          r,
          g,
          b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    }

    function cmyk2hsl(args) {
      return rgb2hsl(cmyk2rgb(args));
    }

    function cmyk2hsv(args) {
      return rgb2hsv(cmyk2rgb(args));
    }

    function cmyk2hwb(args) {
      return rgb2hwb(cmyk2rgb(args));
    }

    function cmyk2keyword(args) {
      return rgb2keyword(cmyk2rgb(args));
    }

    function xyz2rgb(xyz) {
      var x = xyz[0] / 100,
          y = xyz[1] / 100,
          z = xyz[2] / 100,
          r,
          g,
          b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    }

    function xyz2lab(xyz) {
      var x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function xyz2lch(args) {
      return lab2lch(xyz2lab(args));
    }

    function lab2xyz(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          x,
          y,
          z,
          y2;

      if (l <= 8) {
        y = l * 100 / 903.3;
        y2 = 7.787 * (y / 100) + 16 / 116;
      } else {
        y = 100 * Math.pow((l + 16) / 116, 3);
        y2 = Math.pow(y / 100, 1 / 3);
      }

      x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
      z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
      return [x, y, z];
    }

    function lab2lch(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          hr,
          h,
          c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    }

    function lab2rgb(args) {
      return xyz2rgb(lab2xyz(args));
    }

    function lch2lab(lch) {
      var l = lch[0],
          c = lch[1],
          h = lch[2],
          a,
          b,
          hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    }

    function lch2xyz(args) {
      return lab2xyz(lch2lab(args));
    }

    function lch2rgb(args) {
      return lab2rgb(lch2lab(args));
    }

    function keyword2rgb(keyword) {
      return cssKeywords[keyword];
    }

    function keyword2hsl(args) {
      return rgb2hsl(keyword2rgb(args));
    }

    function keyword2hsv(args) {
      return rgb2hsv(keyword2rgb(args));
    }

    function keyword2hwb(args) {
      return rgb2hwb(keyword2rgb(args));
    }

    function keyword2cmyk(args) {
      return rgb2cmyk(keyword2rgb(args));
    }

    function keyword2lab(args) {
      return rgb2lab(keyword2rgb(args));
    }

    function keyword2xyz(args) {
      return rgb2xyz(keyword2rgb(args));
    }

    var cssKeywords = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var reverseKeywords = {};

    for (var key in cssKeywords) {
      reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
    }

    var convert = function () {
      return new Converter();
    };

    for (var func in conversions) {
      // export Raw versions
      convert[func + "Raw"] = function (func) {
        // accept array or plain args
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          return conversions[func](arg);
        };
      }(func);

      var pair = /(\w+)2(\w+)/.exec(func),
          from = pair[1],
          to = pair[2]; // export rgb2hsl and ["rgb"]["hsl"]

      convert[from] = convert[from] || {};

      convert[from][to] = convert[func] = function (func) {
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          var val = conversions[func](arg);

          if (typeof val == "string" || val === undefined) {
            return val;
          } // keyword


          for (var i = 0; i < val.length; i++) {
            val[i] = Math.round(val[i]);
          }

          return val;
        };
      }(func);
    }
    /* Converter does lazy conversion and caching */


    var Converter = function () {
      this.convs = {};
    };
    /* Either get the values for a space or
      set the values for a space, depending on args */


    Converter.prototype.routeSpace = function (space, args) {
      var values = args[0];

      if (values === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof values == "number") {
        values = Array.prototype.slice.call(args);
      }

      return this.setValues(space, values);
    };
    /* Set the values for a space, invalidating cache */


    Converter.prototype.setValues = function (space, values) {
      this.space = space;
      this.convs = {};
      this.convs[space] = values;
      return this;
    };
    /* Get the values for a space. If there's already
      a conversion for the space, fetch it, otherwise
      compute it */


    Converter.prototype.getValues = function (space) {
      var vals = this.convs[space];

      if (!vals) {
        var fspace = this.space,
            from = this.convs[fspace];
        vals = convert[fspace][space](from);
        this.convs[space] = vals;
      }

      return vals;
    };

    ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
      Converter.prototype[space] = function (vals) {
        return this.routeSpace(space, arguments);
      };
    });
    var colorConvert = convert;
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    /* MIT license */

    var colorString = {
      getRgba: getRgba,
      getHsla: getHsla,
      getRgb: getRgb,
      getHsl: getHsl,
      getHwb: getHwb,
      getAlpha: getAlpha,
      hexString: hexString,
      rgbString: rgbString,
      rgbaString: rgbaString,
      percentString: percentString,
      percentaString: percentaString,
      hslString: hslString,
      hslaString: hslaString,
      hwbString: hwbString,
      keyword: keyword
    };

    function getRgba(string) {
      if (!string) {
        return;
      }

      var abbr = /^#([a-fA-F0-9]{3,4})$/i,
          hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
          rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          keyword = /(\w+)/;
      var rgb = [0, 0, 0],
          a = 1,
          match = string.match(abbr),
          hexAlpha = "";

      if (match) {
        match = match[1];
        hexAlpha = match[3];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(rgba)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i + 1]);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(per)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(keyword)) {
        if (match[1] == "transparent") {
          return [0, 0, 0, 0];
        }

        rgb = colorName[match[1]];

        if (!rgb) {
          return;
        }
      }

      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = scale(rgb[i], 0, 255);
      }

      if (!a && a != 0) {
        a = 1;
      } else {
        a = scale(a, 0, 1);
      }

      rgb[3] = a;
      return rgb;
    }

    function getHsla(string) {
      if (!string) {
        return;
      }

      var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hsl);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            s = scale(parseFloat(match[2]), 0, 100),
            l = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
    }

    function getHwb(string) {
      if (!string) {
        return;
      }

      var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hwb);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            w = scale(parseFloat(match[2]), 0, 100),
            b = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
    }

    function getRgb(string) {
      var rgba = getRgba(string);
      return rgba && rgba.slice(0, 3);
    }

    function getHsl(string) {
      var hsla = getHsla(string);
      return hsla && hsla.slice(0, 3);
    }

    function getAlpha(string) {
      var vals = getRgba(string);

      if (vals) {
        return vals[3];
      } else if (vals = getHsla(string)) {
        return vals[3];
      } else if (vals = getHwb(string)) {
        return vals[3];
      }
    } // generators


    function hexString(rgba, a) {
      var a = a !== undefined && rgba.length === 3 ? a : rgba[3];
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
    }

    function rgbString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return rgbaString(rgba, alpha);
      }

      return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
    }

    function rgbaString(rgba, alpha) {
      if (alpha === undefined) {
        alpha = rgba[3] !== undefined ? rgba[3] : 1;
      }

      return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
    }

    function percentString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return percentaString(rgba, alpha);
      }

      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgb(" + r + "%, " + g + "%, " + b + "%)";
    }

    function percentaString(rgba, alpha) {
      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
    }

    function hslString(hsla, alpha) {
      if (alpha < 1 || hsla[3] && hsla[3] < 1) {
        return hslaString(hsla, alpha);
      }

      return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
    }

    function hslaString(hsla, alpha) {
      if (alpha === undefined) {
        alpha = hsla[3] !== undefined ? hsla[3] : 1;
      }

      return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
    } // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
    // (hwb have alpha optional & 1 is default value)


    function hwbString(hwb, alpha) {
      if (alpha === undefined) {
        alpha = hwb[3] !== undefined ? hwb[3] : 1;
      }

      return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
    }

    function keyword(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    } // helpers


    function scale(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }

    function hexDouble(num) {
      var str = num.toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    } //create a list of reverse color names


    var reverseNames = {};

    for (var name in colorName) {
      reverseNames[colorName[name]] = name;
    }
    /* MIT license */


    var Color = function (obj) {
      if (obj instanceof Color) {
        return obj;
      }

      if (!(this instanceof Color)) {
        return new Color(obj);
      }

      this.valid = false;
      this.values = {
        rgb: [0, 0, 0],
        hsl: [0, 0, 0],
        hsv: [0, 0, 0],
        hwb: [0, 0, 0],
        cmyk: [0, 0, 0, 0],
        alpha: 1
      }; // parse Color() argument

      var vals;

      if (typeof obj === 'string') {
        vals = colorString.getRgba(obj);

        if (vals) {
          this.setValues('rgb', vals);
        } else if (vals = colorString.getHsla(obj)) {
          this.setValues('hsl', vals);
        } else if (vals = colorString.getHwb(obj)) {
          this.setValues('hwb', vals);
        }
      } else if (typeof obj === 'object') {
        vals = obj;

        if (vals.r !== undefined || vals.red !== undefined) {
          this.setValues('rgb', vals);
        } else if (vals.l !== undefined || vals.lightness !== undefined) {
          this.setValues('hsl', vals);
        } else if (vals.v !== undefined || vals.value !== undefined) {
          this.setValues('hsv', vals);
        } else if (vals.w !== undefined || vals.whiteness !== undefined) {
          this.setValues('hwb', vals);
        } else if (vals.c !== undefined || vals.cyan !== undefined) {
          this.setValues('cmyk', vals);
        }
      }
    };

    Color.prototype = {
      isValid: function () {
        return this.valid;
      },
      rgb: function () {
        return this.setSpace('rgb', arguments);
      },
      hsl: function () {
        return this.setSpace('hsl', arguments);
      },
      hsv: function () {
        return this.setSpace('hsv', arguments);
      },
      hwb: function () {
        return this.setSpace('hwb', arguments);
      },
      cmyk: function () {
        return this.setSpace('cmyk', arguments);
      },
      rgbArray: function () {
        return this.values.rgb;
      },
      hslArray: function () {
        return this.values.hsl;
      },
      hsvArray: function () {
        return this.values.hsv;
      },
      hwbArray: function () {
        var values = this.values;

        if (values.alpha !== 1) {
          return values.hwb.concat([values.alpha]);
        }

        return values.hwb;
      },
      cmykArray: function () {
        return this.values.cmyk;
      },
      rgbaArray: function () {
        var values = this.values;
        return values.rgb.concat([values.alpha]);
      },
      hslaArray: function () {
        var values = this.values;
        return values.hsl.concat([values.alpha]);
      },
      alpha: function (val) {
        if (val === undefined) {
          return this.values.alpha;
        }

        this.setValues('alpha', val);
        return this;
      },
      red: function (val) {
        return this.setChannel('rgb', 0, val);
      },
      green: function (val) {
        return this.setChannel('rgb', 1, val);
      },
      blue: function (val) {
        return this.setChannel('rgb', 2, val);
      },
      hue: function (val) {
        if (val) {
          val %= 360;
          val = val < 0 ? 360 + val : val;
        }

        return this.setChannel('hsl', 0, val);
      },
      saturation: function (val) {
        return this.setChannel('hsl', 1, val);
      },
      lightness: function (val) {
        return this.setChannel('hsl', 2, val);
      },
      saturationv: function (val) {
        return this.setChannel('hsv', 1, val);
      },
      whiteness: function (val) {
        return this.setChannel('hwb', 1, val);
      },
      blackness: function (val) {
        return this.setChannel('hwb', 2, val);
      },
      value: function (val) {
        return this.setChannel('hsv', 2, val);
      },
      cyan: function (val) {
        return this.setChannel('cmyk', 0, val);
      },
      magenta: function (val) {
        return this.setChannel('cmyk', 1, val);
      },
      yellow: function (val) {
        return this.setChannel('cmyk', 2, val);
      },
      black: function (val) {
        return this.setChannel('cmyk', 3, val);
      },
      hexString: function () {
        return colorString.hexString(this.values.rgb);
      },
      rgbString: function () {
        return colorString.rgbString(this.values.rgb, this.values.alpha);
      },
      rgbaString: function () {
        return colorString.rgbaString(this.values.rgb, this.values.alpha);
      },
      percentString: function () {
        return colorString.percentString(this.values.rgb, this.values.alpha);
      },
      hslString: function () {
        return colorString.hslString(this.values.hsl, this.values.alpha);
      },
      hslaString: function () {
        return colorString.hslaString(this.values.hsl, this.values.alpha);
      },
      hwbString: function () {
        return colorString.hwbString(this.values.hwb, this.values.alpha);
      },
      keyword: function () {
        return colorString.keyword(this.values.rgb, this.values.alpha);
      },
      rgbNumber: function () {
        var rgb = this.values.rgb;
        return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
      },
      luminosity: function () {
        // http://www.w3.org/TR/WCAG20/#relativeluminancedef
        var rgb = this.values.rgb;
        var lum = [];

        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }

        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function (color2) {
        // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();

        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }

        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function (color2) {
        var contrastRatio = this.contrast(color2);

        if (contrastRatio >= 7.1) {
          return 'AAA';
        }

        return contrastRatio >= 4.5 ? 'AA' : '';
      },
      dark: function () {
        // YIQ equation from http://24ways.org/2010/calculating-color-contrast
        var rgb = this.values.rgb;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        return yiq < 128;
      },
      light: function () {
        return !this.dark();
      },
      negate: function () {
        var rgb = [];

        for (var i = 0; i < 3; i++) {
          rgb[i] = 255 - this.values.rgb[i];
        }

        this.setValues('rgb', rgb);
        return this;
      },
      lighten: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] += hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      darken: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] -= hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      saturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] += hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      desaturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] -= hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      whiten: function (ratio) {
        var hwb = this.values.hwb;
        hwb[1] += hwb[1] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      blacken: function (ratio) {
        var hwb = this.values.hwb;
        hwb[2] += hwb[2] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      greyscale: function () {
        var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale

        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        this.setValues('rgb', [val, val, val]);
        return this;
      },
      clearer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha - alpha * ratio);
        return this;
      },
      opaquer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha + alpha * ratio);
        return this;
      },
      rotate: function (degrees) {
        var hsl = this.values.hsl;
        var hue = (hsl[0] + degrees) % 360;
        hsl[0] = hue < 0 ? 360 + hue : hue;
        this.setValues('hsl', hsl);
        return this;
      },

      /**
       * Ported from sass implementation in C
       * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
       */
      mix: function (mixinColor, weight) {
        var color1 = this;
        var color2 = mixinColor;
        var p = weight === undefined ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;
        return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
      },
      toJSON: function () {
        return this.rgb();
      },
      clone: function () {
        // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
        // making the final build way to big to embed in Chart.js. So let's do it manually,
        // assuming that values to clone are 1 dimension arrays containing only numbers,
        // except 'alpha' which is a number.
        var result = new Color();
        var source = this.values;
        var target = result.values;
        var value, type;

        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            value = source[prop];
            type = {}.toString.call(value);

            if (type === '[object Array]') {
              target[prop] = value.slice(0);
            } else if (type === '[object Number]') {
              target[prop] = value;
            } else {
              console.error('unexpected color value:', value);
            }
          }
        }

        return result;
      }
    };
    Color.prototype.spaces = {
      rgb: ['red', 'green', 'blue'],
      hsl: ['hue', 'saturation', 'lightness'],
      hsv: ['hue', 'saturation', 'value'],
      hwb: ['hue', 'whiteness', 'blackness'],
      cmyk: ['cyan', 'magenta', 'yellow', 'black']
    };
    Color.prototype.maxes = {
      rgb: [255, 255, 255],
      hsl: [360, 100, 100],
      hsv: [360, 100, 100],
      hwb: [360, 100, 100],
      cmyk: [100, 100, 100, 100]
    };

    Color.prototype.getValues = function (space) {
      var values = this.values;
      var vals = {};

      for (var i = 0; i < space.length; i++) {
        vals[space.charAt(i)] = values[space][i];
      }

      if (values.alpha !== 1) {
        vals.a = values.alpha;
      } // {r: 255, g: 255, b: 255, a: 0.4}


      return vals;
    };

    Color.prototype.setValues = function (space, vals) {
      var values = this.values;
      var spaces = this.spaces;
      var maxes = this.maxes;
      var alpha = 1;
      var i;
      this.valid = true;

      if (space === 'alpha') {
        alpha = vals;
      } else if (vals.length) {
        // [10, 10, 10]
        values[space] = vals.slice(0, space.length);
        alpha = vals[space.length];
      } else if (vals[space.charAt(0)] !== undefined) {
        // {r: 10, g: 10, b: 10}
        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[space.charAt(i)];
        }

        alpha = vals.a;
      } else if (vals[spaces[space][0]] !== undefined) {
        // {red: 10, green: 10, blue: 10}
        var chans = spaces[space];

        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[chans[i]];
        }

        alpha = vals.alpha;
      }

      values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

      if (space === 'alpha') {
        return false;
      }

      var capped; // cap values of the space prior converting all values

      for (i = 0; i < space.length; i++) {
        capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
        values[space][i] = Math.round(capped);
      } // convert to all the other color spaces


      for (var sname in spaces) {
        if (sname !== space) {
          values[sname] = colorConvert[space][sname](values[space]);
        }
      }

      return true;
    };

    Color.prototype.setSpace = function (space, args) {
      var vals = args[0];

      if (vals === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof vals === 'number') {
        vals = Array.prototype.slice.call(args);
      }

      this.setValues(space, vals);
      return this;
    };

    Color.prototype.setChannel = function (space, index, val) {
      var svalues = this.values[space];

      if (val === undefined) {
        // color.red()
        return svalues[index];
      } else if (val === svalues[index]) {
        // color.red(color.red())
        return this;
      } // color.red(100)


      svalues[index] = val;
      this.setValues(space, svalues);
      return this;
    };

    if (typeof window !== 'undefined') {
      window.Color = Color;
    }

    var chartjsColor = Color;
    /**
     * @namespace Chart.helpers
     */

    var helpers = {
      /**
       * An empty function that can be used, for example, for optional callback.
       */
      noop: function () {},

      /**
       * Returns a unique id, sequentially generated from a global variable.
       * @returns {number}
       * @function
       */
      uid: function () {
        var id = 0;
        return function () {
          return id++;
        };
      }(),

      /**
       * Returns true if `value` is neither null nor undefined, else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isNullOrUndef: function (value) {
        return value === null || typeof value === 'undefined';
      },

      /**
       * Returns true if `value` is an array (including typed arrays), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @function
       */
      isArray: function (value) {
        if (Array.isArray && Array.isArray(value)) {
          return true;
        }

        var type = Object.prototype.toString.call(value);

        if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
          return true;
        }

        return false;
      },

      /**
       * Returns true if `value` is an object (excluding null), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isObject: function (value) {
        return value !== null && Object.prototype.toString.call(value) === '[object Object]';
      },

      /**
       * Returns true if `value` is a finite number, else returns false
       * @param {*} value  - The value to test.
       * @returns {boolean}
       */
      isFinite: function (value) {
        return (typeof value === 'number' || value instanceof Number) && isFinite(value);
      },

      /**
       * Returns `value` if defined, else returns `defaultValue`.
       * @param {*} value - The value to return if defined.
       * @param {*} defaultValue - The value to return if `value` is undefined.
       * @returns {*}
       */
      valueOrDefault: function (value, defaultValue) {
        return typeof value === 'undefined' ? defaultValue : value;
      },

      /**
       * Returns value at the given `index` in array if defined, else returns `defaultValue`.
       * @param {Array} value - The array to lookup for value at `index`.
       * @param {number} index - The index in `value` to lookup for value.
       * @param {*} defaultValue - The value to return if `value[index]` is undefined.
       * @returns {*}
       */
      valueAtIndexOrDefault: function (value, index, defaultValue) {
        return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
      },

      /**
       * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
       * value returned by `fn`. If `fn` is not a function, this method returns undefined.
       * @param {function} fn - The function to call.
       * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @returns {*}
       */
      callback: function (fn, args, thisArg) {
        if (fn && typeof fn.call === 'function') {
          return fn.apply(thisArg, args);
        }
      },

      /**
       * Note(SB) for performance sake, this method should only be used when loopable type
       * is unknown or in none intensive code (not called often and small loopable). Else
       * it's preferable to use a regular for() loop and save extra function calls.
       * @param {object|Array} loopable - The object or array to be iterated.
       * @param {function} fn - The function to call for each item.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @param {boolean} [reverse] - If true, iterates backward on the loopable.
       */
      each: function (loopable, fn, thisArg, reverse) {
        var i, len, keys;

        if (helpers.isArray(loopable)) {
          len = loopable.length;

          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (helpers.isObject(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;

          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      },

      /**
       * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
       * @see https://stackoverflow.com/a/14853974
       * @param {Array} a0 - The array to compare
       * @param {Array} a1 - The array to compare
       * @returns {boolean}
       */
      arrayEquals: function (a0, a1) {
        var i, ilen, v0, v1;

        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }

        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];

          if (v0 instanceof Array && v1 instanceof Array) {
            if (!helpers.arrayEquals(v0, v1)) {
              return false;
            }
          } else if (v0 !== v1) {
            // NOTE: two different object instances will never be equal: {x:20} != {x:20}
            return false;
          }
        }

        return true;
      },

      /**
       * Returns a deep copy of `source` without keeping references on objects and arrays.
       * @param {*} source - The value to clone.
       * @returns {*}
       */
      clone: function (source) {
        if (helpers.isArray(source)) {
          return source.map(helpers.clone);
        }

        if (helpers.isObject(source)) {
          var target = {};
          var keys = Object.keys(source);
          var klen = keys.length;
          var k = 0;

          for (; k < klen; ++k) {
            target[keys[k]] = helpers.clone(source[keys[k]]);
          }

          return target;
        }

        return source;
      },

      /**
       * The default merger when Chart.helpers.merge is called without merger option.
       * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
       * @private
       */
      _merger: function (key, target, source, options) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.merge(tval, sval, options);
        } else {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Merges source[key] in target[key] only if target[key] is undefined.
       * @private
       */
      _mergerIf: function (key, target, source) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.mergeIf(tval, sval);
        } else if (!target.hasOwnProperty(key)) {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Recursively deep copies `source` properties into `target` with the given `options`.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @param {object} [options] - Merging options:
       * @param {function} [options.merger] - The merge method (key, target, source, options)
       * @returns {object} The `target` object.
       */
      merge: function (target, source, options) {
        var sources = helpers.isArray(source) ? source : [source];
        var ilen = sources.length;
        var merge, i, keys, klen, k;

        if (!helpers.isObject(target)) {
          return target;
        }

        options = options || {};
        merge = options.merger || helpers._merger;

        for (i = 0; i < ilen; ++i) {
          source = sources[i];

          if (!helpers.isObject(source)) {
            continue;
          }

          keys = Object.keys(source);

          for (k = 0, klen = keys.length; k < klen; ++k) {
            merge(keys[k], target, source, options);
          }
        }

        return target;
      },

      /**
       * Recursively deep copies `source` properties into `target` *only* if not defined in target.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @returns {object} The `target` object.
       */
      mergeIf: function (target, source) {
        return helpers.merge(target, source, {
          merger: helpers._mergerIf
        });
      },

      /**
       * Applies the contents of two or more objects together into the first object.
       * @param {object} target - The target object in which all objects are merged into.
       * @param {object} arg1 - Object containing additional properties to merge in target.
       * @param {object} argN - Additional objects containing properties to merge in target.
       * @returns {object} The `target` object.
       */
      extend: function (target) {
        var arguments$1 = arguments;

        var setFn = function (value, key) {
          target[key] = value;
        };

        for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
          helpers.each(arguments$1[i], setFn);
        }

        return target;
      },

      /**
       * Basic javascript inheritance based on the model created in Backbone.js
       */
      inherits: function (extensions) {
        var me = this;
        var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
          return me.apply(this, arguments);
        };

        var Surrogate = function () {
          this.constructor = ChartElement;
        };

        Surrogate.prototype = me.prototype;
        ChartElement.prototype = new Surrogate();
        ChartElement.extend = helpers.inherits;

        if (extensions) {
          helpers.extend(ChartElement.prototype, extensions);
        }

        ChartElement.__super__ = me.prototype;
        return ChartElement;
      }
    };
    var helpers_core = helpers; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.callback instead.
     * @function Chart.helpers.callCallback
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    helpers.callCallback = helpers.callback;
    /**
     * Provided for backward compatibility, use Array.prototype.indexOf instead.
     * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
     * @function Chart.helpers.indexOf
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.indexOf = function (array, item, fromIndex) {
      return Array.prototype.indexOf.call(array, item, fromIndex);
    };
    /**
     * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
     * @function Chart.helpers.getValueOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */


    helpers.getValueOrDefault = helpers.valueOrDefault;
    /**
     * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
     * @function Chart.helpers.getValueAtIndexOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
    /**
     * Easing functions adapted from Robert Penner's easing equations.
     * @namespace Chart.helpers.easingEffects
     * @see http://www.robertpenner.com/easing/
     */

    var effects = {
      linear: function (t) {
        return t;
      },
      easeInQuad: function (t) {
        return t * t;
      },
      easeOutQuad: function (t) {
        return -t * (t - 2);
      },
      easeInOutQuad: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t;
        }

        return -0.5 * (--t * (t - 2) - 1);
      },
      easeInCubic: function (t) {
        return t * t * t;
      },
      easeOutCubic: function (t) {
        return (t = t - 1) * t * t + 1;
      },
      easeInOutCubic: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t + 2);
      },
      easeInQuart: function (t) {
        return t * t * t * t;
      },
      easeOutQuart: function (t) {
        return -((t = t - 1) * t * t * t - 1);
      },
      easeInOutQuart: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t;
        }

        return -0.5 * ((t -= 2) * t * t * t - 2);
      },
      easeInQuint: function (t) {
        return t * t * t * t * t;
      },
      easeOutQuint: function (t) {
        return (t = t - 1) * t * t * t * t + 1;
      },
      easeInOutQuint: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t * t * t + 2);
      },
      easeInSine: function (t) {
        return -Math.cos(t * (Math.PI / 2)) + 1;
      },
      easeOutSine: function (t) {
        return Math.sin(t * (Math.PI / 2));
      },
      easeInOutSine: function (t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
      },
      easeInExpo: function (t) {
        return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
      },
      easeOutExpo: function (t) {
        return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
      },
      easeInOutExpo: function (t) {
        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(2, 10 * (t - 1));
        }

        return 0.5 * (-Math.pow(2, -10 * --t) + 2);
      },
      easeInCirc: function (t) {
        if (t >= 1) {
          return t;
        }

        return -(Math.sqrt(1 - t * t) - 1);
      },
      easeOutCirc: function (t) {
        return Math.sqrt(1 - (t = t - 1) * t);
      },
      easeInOutCirc: function (t) {
        if ((t /= 0.5) < 1) {
          return -0.5 * (Math.sqrt(1 - t * t) - 1);
        }

        return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      },
      easeInElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
      },
      easeOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
      },
      easeInOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if ((t /= 0.5) === 2) {
          return 1;
        }

        if (!p) {
          p = 0.45;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        if (t < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
        }

        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      easeInBack: function (t) {
        var s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      easeOutBack: function (t) {
        var s = 1.70158;
        return (t = t - 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack: function (t) {
        var s = 1.70158;

        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }

        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      easeInBounce: function (t) {
        return 1 - effects.easeOutBounce(1 - t);
      },
      easeOutBounce: function (t) {
        if (t < 1 / 2.75) {
          return 7.5625 * t * t;
        }

        if (t < 2 / 2.75) {
          return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        }

        if (t < 2.5 / 2.75) {
          return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        }

        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      },
      easeInOutBounce: function (t) {
        if (t < 0.5) {
          return effects.easeInBounce(t * 2) * 0.5;
        }

        return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
      }
    };
    var helpers_easing = {
      effects: effects
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
     * @function Chart.helpers.easingEffects
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.easingEffects = effects;
    var PI = Math.PI;
    var RAD_PER_DEG = PI / 180;
    var DOUBLE_PI = PI * 2;
    var HALF_PI = PI / 2;
    var QUARTER_PI = PI / 4;
    var TWO_THIRDS_PI = PI * 2 / 3;
    /**
     * @namespace Chart.helpers.canvas
     */

    var exports$1 = {
      /**
       * Clears the entire canvas associated to the given `chart`.
       * @param {Chart} chart - The chart for which to clear the canvas.
       */
      clear: function (chart) {
        chart.ctx.clearRect(0, 0, chart.width, chart.height);
      },

      /**
       * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
       * given size (width, height) and the same `radius` for all corners.
       * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
       * @param {number} x - The x axis of the coordinate for the rectangle starting point.
       * @param {number} y - The y axis of the coordinate for the rectangle starting point.
       * @param {number} width - The rectangle's width.
       * @param {number} height - The rectangle's height.
       * @param {number} radius - The rounded amount (in pixels) for the four corners.
       * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
       */
      roundedRect: function (ctx, x, y, width, height, radius) {
        if (radius) {
          var r = Math.min(radius, height / 2, width / 2);
          var left = x + r;
          var top = y + r;
          var right = x + width - r;
          var bottom = y + height - r;
          ctx.moveTo(x, top);

          if (left < right && top < bottom) {
            ctx.arc(left, top, r, -PI, -HALF_PI);
            ctx.arc(right, top, r, -HALF_PI, 0);
            ctx.arc(right, bottom, r, 0, HALF_PI);
            ctx.arc(left, bottom, r, HALF_PI, PI);
          } else if (left < right) {
            ctx.moveTo(left, y);
            ctx.arc(right, top, r, -HALF_PI, HALF_PI);
            ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
          } else if (top < bottom) {
            ctx.arc(left, top, r, -PI, 0);
            ctx.arc(left, bottom, r, 0, PI);
          } else {
            ctx.arc(left, top, r, -PI, PI);
          }

          ctx.closePath();
          ctx.moveTo(x, y);
        } else {
          ctx.rect(x, y, width, height);
        }
      },
      drawPoint: function (ctx, style, radius, x, y, rotation) {
        var type, xOffset, yOffset, size, cornerRadius;
        var rad = (rotation || 0) * RAD_PER_DEG;

        if (style && typeof style === 'object') {
          type = style.toString();

          if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
            return;
          }
        }

        if (isNaN(radius) || radius <= 0) {
          return;
        }

        ctx.beginPath();

        switch (style) {
          // Default includes circle
          default:
            ctx.arc(x, y, radius, 0, DOUBLE_PI);
            ctx.closePath();
            break;

          case 'triangle':
            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;

          case 'rectRounded':
            // NOTE: the rounded rect implementation changed to use `arc` instead of
            // `quadraticCurveTo` since it generates better results when rect is
            // almost a circle. 0.516 (instead of 0.5) produces results with visually
            // closer proportion to the previous impl and it is inscribed in the
            // circle with `radius`. For more details, see the following PRs:
            // https://github.com/chartjs/Chart.js/issues/5597
            // https://github.com/chartjs/Chart.js/issues/5858
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;

          case 'rect':
            if (!rotation) {
              size = Math.SQRT1_2 * radius;
              ctx.rect(x - size, y - size, 2 * size, 2 * size);
              break;
            }

            rad += QUARTER_PI;

          /* falls through */

          case 'rectRot':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + yOffset, y - xOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            ctx.closePath();
            break;

          case 'crossRot':
            rad += QUARTER_PI;

          /* falls through */

          case 'cross':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'star':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            rad += QUARTER_PI;
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'line':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;

          case 'dash':
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
            break;
        }

        ctx.fill();
        ctx.stroke();
      },

      /**
       * Returns true if the point is inside the rectangle
       * @param {object} point - The point to test
       * @param {object} area - The rectangle
       * @returns {boolean}
       * @private
       */
      _isPointInArea: function (point, area) {
        var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

        return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
      },
      clipArea: function (ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      },
      unclipArea: function (ctx) {
        ctx.restore();
      },
      lineTo: function (ctx, previous, target, flip) {
        var stepped = target.steppedLine;

        if (stepped) {
          if (stepped === 'middle') {
            var midpoint = (previous.x + target.x) / 2.0;
            ctx.lineTo(midpoint, flip ? target.y : previous.y);
            ctx.lineTo(midpoint, flip ? previous.y : target.y);
          } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }

          ctx.lineTo(target.x, target.y);
          return;
        }

        if (!target.tension) {
          ctx.lineTo(target.x, target.y);
          return;
        }

        ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
      }
    };
    var helpers_canvas = exports$1; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
     * @namespace Chart.helpers.clear
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.clear = exports$1.clear;
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
     * @namespace Chart.helpers.drawRoundedRectangle
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.drawRoundedRectangle = function (ctx) {
      ctx.beginPath();
      exports$1.roundedRect.apply(exports$1, arguments);
    };

    var defaults = {
      /**
       * @private
       */
      _set: function (scope, values) {
        return helpers_core.merge(this[scope] || (this[scope] = {}), values);
      }
    };

    defaults._set('global', {
      defaultColor: 'rgba(0,0,0,0.1)',
      defaultFontColor: '#666',
      defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      defaultFontSize: 12,
      defaultFontStyle: 'normal',
      defaultLineHeight: 1.2,
      showLines: true
    });

    var core_defaults = defaults;
    var valueOrDefault = helpers_core.valueOrDefault;
    /**
     * Converts the given font object into a CSS font string.
     * @param {object} font - A font object.
     * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
     * @private
     */

    function toFontString(font) {
      if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
        return null;
      }

      return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
    }
    /**
     * @alias Chart.helpers.options
     * @namespace
     */


    var helpers_options = {
      /**
       * Converts the given line height `value` in pixels for a specific font `size`.
       * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
       * @param {number} size - The font size (in pixels) used to resolve relative `value`.
       * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
       * @since 2.7.0
       */
      toLineHeight: function (value, size) {
        var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);

        if (!matches || matches[1] === 'normal') {
          return size * 1.2;
        }

        value = +matches[2];

        switch (matches[3]) {
          case 'px':
            return value;

          case '%':
            value /= 100;
            break;

          default:
            break;
        }

        return size * value;
      },

      /**
       * Converts the given value into a padding object with pre-computed width/height.
       * @param {number|object} value - If a number, set the value to all TRBL component,
       *  else, if and object, use defined properties and sets undefined ones to 0.
       * @returns {object} The padding values (top, right, bottom, left, width, height)
       * @since 2.7.0
       */
      toPadding: function (value) {
        var t, r, b, l;

        if (helpers_core.isObject(value)) {
          t = +value.top || 0;
          r = +value.right || 0;
          b = +value.bottom || 0;
          l = +value.left || 0;
        } else {
          t = r = b = l = +value || 0;
        }

        return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          height: t + b,
          width: l + r
        };
      },

      /**
       * Parses font options and returns the font object.
       * @param {object} options - A object that contains font options to be parsed.
       * @return {object} The font object.
       * @todo Support font.* options and renamed to toFont().
       * @private
       */
      _parseFont: function (options) {
        var globalDefaults = core_defaults.global;
        var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
        var font = {
          family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
          lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
          size: size,
          style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
          weight: null,
          string: ''
        };
        font.string = toFontString(font);
        return font;
      },

      /**
       * Evaluates the given `inputs` sequentially and returns the first defined value.
       * @param {Array} inputs - An array of values, falling back to the last value.
       * @param {object} [context] - If defined and the current value is a function, the value
       * is called with `context` as first argument and the result becomes the new input.
       * @param {number} [index] - If defined and the current value is an array, the value
       * at `index` become the new input.
       * @since 2.7.0
       */
      resolve: function (inputs, context, index) {
        var i, ilen, value;

        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];

          if (value === undefined) {
            continue;
          }

          if (context !== undefined && typeof value === 'function') {
            value = value(context);
          }

          if (index !== undefined && helpers_core.isArray(value)) {
            value = value[index];
          }

          if (value !== undefined) {
            return value;
          }
        }
      }
    };
    var helpers$1 = helpers_core;
    var easing = helpers_easing;
    var canvas = helpers_canvas;
    var options = helpers_options;
    helpers$1.easing = easing;
    helpers$1.canvas = canvas;
    helpers$1.options = options;

    function interpolate(start, view, model, ease) {
      var keys = Object.keys(model);
      var i, ilen, key, actual, origin, target, type, c0, c1;

      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        target = model[key]; // if a value is added to the model after pivot() has been called, the view
        // doesn't contain it, so let's initialize the view to the target value.

        if (!view.hasOwnProperty(key)) {
          view[key] = target;
        }

        actual = view[key];

        if (actual === target || key[0] === '_') {
          continue;
        }

        if (!start.hasOwnProperty(key)) {
          start[key] = actual;
        }

        origin = start[key];
        type = typeof target;

        if (type === typeof origin) {
          if (type === 'string') {
            c0 = chartjsColor(origin);

            if (c0.valid) {
              c1 = chartjsColor(target);

              if (c1.valid) {
                view[key] = c1.mix(c0, ease).rgbString();
                continue;
              }
            }
          } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
            view[key] = origin + (target - origin) * ease;
            continue;
          }
        }

        view[key] = target;
      }
    }

    var Element = function (configuration) {
      helpers$1.extend(this, configuration);
      this.initialize.apply(this, arguments);
    };

    helpers$1.extend(Element.prototype, {
      initialize: function () {
        this.hidden = false;
      },
      pivot: function () {
        var me = this;

        if (!me._view) {
          me._view = helpers$1.clone(me._model);
        }

        me._start = {};
        return me;
      },
      transition: function (ease) {
        var me = this;
        var model = me._model;
        var start = me._start;
        var view = me._view; // No animation -> No Transition

        if (!model || ease === 1) {
          me._view = model;
          me._start = null;
          return me;
        }

        if (!view) {
          view = me._view = {};
        }

        if (!start) {
          start = me._start = {};
        }

        interpolate(start, view, model, ease);
        return me;
      },
      tooltipPosition: function () {
        return {
          x: this._model.x,
          y: this._model.y
        };
      },
      hasValue: function () {
        return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
      }
    });
    Element.extend = helpers$1.inherits;
    var core_element = Element;
    var exports$2 = core_element.extend({
      chart: null,
      // the animation associated chart instance
      currentStep: 0,
      // the current animation step
      numSteps: 60,
      // default number of steps
      easing: '',
      // the easing to use for this animation
      render: null,
      // render function used by the animation service
      onAnimationProgress: null,
      // user specified callback to fire on each step of the animation
      onAnimationComplete: null // user specified callback to fire when the animation finishes

    });
    var core_animation = exports$2; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.Animation instead
     * @prop Chart.Animation#animationObject
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'animationObject', {
      get: function () {
        return this;
      }
    });
    /**
     * Provided for backward compatibility, use Chart.Animation#chart instead
     * @prop Chart.Animation#chartInstance
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'chartInstance', {
      get: function () {
        return this.chart;
      },
      set: function (value) {
        this.chart = value;
      }
    });

    core_defaults._set('global', {
      animation: {
        duration: 1000,
        easing: 'easeOutQuart',
        onProgress: helpers$1.noop,
        onComplete: helpers$1.noop
      }
    });

    var core_animations = {
      animations: [],
      request: null,

      /**
       * @param {Chart} chart - The chart to animate.
       * @param {Chart.Animation} animation - The animation that we will animate.
       * @param {number} duration - The animation duration in ms.
       * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
       */
      addAnimation: function (chart, animation, duration, lazy) {
        var animations = this.animations;
        var i, ilen;
        animation.chart = chart;
        animation.startTime = Date.now();
        animation.duration = duration;

        if (!lazy) {
          chart.animating = true;
        }

        for (i = 0, ilen = animations.length; i < ilen; ++i) {
          if (animations[i].chart === chart) {
            animations[i] = animation;
            return;
          }
        }

        animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word

        if (animations.length === 1) {
          this.requestAnimationFrame();
        }
      },
      cancelAnimation: function (chart) {
        var index = helpers$1.findIndex(this.animations, function (animation) {
          return animation.chart === chart;
        });

        if (index !== -1) {
          this.animations.splice(index, 1);
          chart.animating = false;
        }
      },
      requestAnimationFrame: function () {
        var me = this;

        if (me.request === null) {
          // Skip animation frame requests until the active one is executed.
          // This can happen when processing mouse events, e.g. 'mousemove'
          // and 'mouseout' events will trigger multiple renders.
          me.request = helpers$1.requestAnimFrame.call(window, function () {
            me.request = null;
            me.startDigest();
          });
        }
      },

      /**
       * @private
       */
      startDigest: function () {
        var me = this;
        me.advance(); // Do we have more stuff to animate?

        if (me.animations.length > 0) {
          me.requestAnimationFrame();
        }
      },

      /**
       * @private
       */
      advance: function () {
        var animations = this.animations;
        var animation, chart, numSteps, nextStep;
        var i = 0; // 1 animation per chart, so we are looping charts here

        while (i < animations.length) {
          animation = animations[i];
          chart = animation.chart;
          numSteps = animation.numSteps; // Make sure that currentStep starts at 1
          // https://github.com/chartjs/Chart.js/issues/6104

          nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
          animation.currentStep = Math.min(nextStep, numSteps);
          helpers$1.callback(animation.render, [chart, animation], chart);
          helpers$1.callback(animation.onAnimationProgress, [animation], chart);

          if (animation.currentStep >= numSteps) {
            helpers$1.callback(animation.onAnimationComplete, [animation], chart);
            chart.animating = false;
            animations.splice(i, 1);
          } else {
            ++i;
          }
        }
      }
    };
    var resolve = helpers$1.options.resolve;
    var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
    /**
     * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
     * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
     * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
     */

    function listenArrayEvents(array, listener) {
      if (array._chartjs) {
        array._chartjs.listeners.push(listener);

        return;
      }

      Object.defineProperty(array, '_chartjs', {
        configurable: true,
        enumerable: false,
        value: {
          listeners: [listener]
        }
      });
      arrayEvents.forEach(function (key) {
        var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
        var base = array[key];
        Object.defineProperty(array, key, {
          configurable: true,
          enumerable: false,
          value: function () {
            var args = Array.prototype.slice.call(arguments);
            var res = base.apply(this, args);
            helpers$1.each(array._chartjs.listeners, function (object) {
              if (typeof object[method] === 'function') {
                object[method].apply(object, args);
              }
            });
            return res;
          }
        });
      });
    }
    /**
     * Removes the given array event listener and cleanup extra attached properties (such as
     * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
     */


    function unlistenArrayEvents(array, listener) {
      var stub = array._chartjs;

      if (!stub) {
        return;
      }

      var listeners = stub.listeners;
      var index = listeners.indexOf(listener);

      if (index !== -1) {
        listeners.splice(index, 1);
      }

      if (listeners.length > 0) {
        return;
      }

      arrayEvents.forEach(function (key) {
        delete array[key];
      });
      delete array._chartjs;
    } // Base class for all dataset controllers (line, bar, etc)


    var DatasetController = function (chart, datasetIndex) {
      this.initialize(chart, datasetIndex);
    };

    helpers$1.extend(DatasetController.prototype, {
      /**
       * Element type used to generate a meta dataset (e.g. Chart.element.Line).
       * @type {Chart.core.element}
       */
      datasetElementType: null,

      /**
       * Element type used to generate a meta data (e.g. Chart.element.Point).
       * @type {Chart.core.element}
       */
      dataElementType: null,
      initialize: function (chart, datasetIndex) {
        var me = this;
        me.chart = chart;
        me.index = datasetIndex;
        me.linkScales();
        me.addElements();
      },
      updateIndex: function (datasetIndex) {
        this.index = datasetIndex;
      },
      linkScales: function () {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
          meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
        }

        if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
          meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
        }
      },
      getDataset: function () {
        return this.chart.data.datasets[this.index];
      },
      getMeta: function () {
        return this.chart.getDatasetMeta(this.index);
      },
      getScaleForId: function (scaleID) {
        return this.chart.scales[scaleID];
      },

      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().yAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getValueScale: function () {
        return this.getScaleForId(this._getValueScaleId());
      },

      /**
       * @private
       */
      _getIndexScale: function () {
        return this.getScaleForId(this._getIndexScaleId());
      },
      reset: function () {
        this.update(true);
      },

      /**
       * @private
       */
      destroy: function () {
        if (this._data) {
          unlistenArrayEvents(this._data, this);
        }
      },
      createMetaDataset: function () {
        var me = this;
        var type = me.datasetElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index
        });
      },
      createMetaData: function (index) {
        var me = this;
        var type = me.dataElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index,
          _index: index
        });
      },
      addElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data || [];
        var metaData = meta.data;
        var i, ilen;

        for (i = 0, ilen = data.length; i < ilen; ++i) {
          metaData[i] = metaData[i] || me.createMetaData(i);
        }

        meta.dataset = meta.dataset || me.createMetaDataset();
      },
      addElementAndReset: function (index) {
        var element = this.createMetaData(index);
        this.getMeta().data.splice(index, 0, element);
        this.updateElement(element, index, true);
      },
      buildOrUpdateElements: function () {
        var me = this;
        var dataset = me.getDataset();
        var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate
        // real-time charts), we need to monitor these data modifications and synchronize
        // the internal meta data accordingly.

        if (me._data !== data) {
          if (me._data) {
            // This case happens when the user replaced the data array instance.
            unlistenArrayEvents(me._data, me);
          }

          if (data && Object.isExtensible(data)) {
            listenArrayEvents(data, me);
          }

          me._data = data;
        } // Re-sync meta data in case the user replaced the data array or if we missed
        // any updates and so make sure that we handle number of datapoints changing.


        me.resyncElements();
      },
      update: helpers$1.noop,
      transition: function (easingValue) {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        for (; i < ilen; ++i) {
          elements[i].transition(easingValue);
        }

        if (meta.dataset) {
          meta.dataset.transition(easingValue);
        }
      },
      draw: function () {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        if (meta.dataset) {
          meta.dataset.draw();
        }

        for (; i < ilen; ++i) {
          elements[i].draw();
        }
      },
      removeHoverStyle: function (element) {
        helpers$1.merge(element._model, element.$previousStyle || {});
        delete element.$previousStyle;
      },
      setHoverStyle: function (element) {
        var dataset = this.chart.data.datasets[element._datasetIndex];
        var index = element._index;
        var custom = element.custom || {};
        var model = element._model;
        var getHoverColor = helpers$1.getHoverColor;
        element.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
        model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
        model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
      },

      /**
       * @private
       */
      resyncElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data;
        var numMeta = meta.data.length;
        var numData = data.length;

        if (numData < numMeta) {
          meta.data.splice(numData, numMeta - numData);
        } else if (numData > numMeta) {
          me.insertElements(numMeta, numData - numMeta);
        }
      },

      /**
       * @private
       */
      insertElements: function (start, count) {
        for (var i = 0; i < count; ++i) {
          this.addElementAndReset(start + i);
        }
      },

      /**
       * @private
       */
      onDataPush: function () {
        var count = arguments.length;
        this.insertElements(this.getDataset().data.length - count, count);
      },

      /**
       * @private
       */
      onDataPop: function () {
        this.getMeta().data.pop();
      },

      /**
       * @private
       */
      onDataShift: function () {
        this.getMeta().data.shift();
      },

      /**
       * @private
       */
      onDataSplice: function (start, count) {
        this.getMeta().data.splice(start, count);
        this.insertElements(start, arguments.length - 2);
      },

      /**
       * @private
       */
      onDataUnshift: function () {
        this.insertElements(0, arguments.length);
      }
    });
    DatasetController.extend = helpers$1.inherits;
    var core_datasetController = DatasetController;

    core_defaults._set('global', {
      elements: {
        arc: {
          backgroundColor: core_defaults.global.defaultColor,
          borderColor: '#fff',
          borderWidth: 2,
          borderAlign: 'center'
        }
      }
    });

    var element_arc = core_element.extend({
      inLabelRange: function (mouseX) {
        var vm = this._view;

        if (vm) {
          return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
        }

        return false;
      },
      inRange: function (chartX, chartY) {
        var vm = this._view;

        if (vm) {
          var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {
            x: chartX,
            y: chartY
          });
          var angle = pointRelativePosition.angle;
          var distance = pointRelativePosition.distance; // Sanitise angle range

          var startAngle = vm.startAngle;
          var endAngle = vm.endAngle;

          while (endAngle < startAngle) {
            endAngle += 2.0 * Math.PI;
          }

          while (angle > endAngle) {
            angle -= 2.0 * Math.PI;
          }

          while (angle < startAngle) {
            angle += 2.0 * Math.PI;
          } // Check if within the range of the open/close angle


          var betweenAngles = angle >= startAngle && angle <= endAngle;
          var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
          return betweenAngles && withinRadius;
        }

        return false;
      },
      getCenterPoint: function () {
        var vm = this._view;
        var halfAngle = (vm.startAngle + vm.endAngle) / 2;
        var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
        return {
          x: vm.x + Math.cos(halfAngle) * halfRadius,
          y: vm.y + Math.sin(halfAngle) * halfRadius
        };
      },
      getArea: function () {
        var vm = this._view;
        return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
      },
      tooltipPosition: function () {
        var vm = this._view;
        var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
        var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
        return {
          x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
          y: vm.y + Math.sin(centreAngle) * rangeFromCentre
        };
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var sA = vm.startAngle;
        var eA = vm.endAngle;
        var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;
        var angleMargin;
        ctx.save();
        ctx.beginPath();
        ctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);
        ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
        ctx.closePath();
        ctx.fillStyle = vm.backgroundColor;
        ctx.fill();

        if (vm.borderWidth) {
          if (vm.borderAlign === 'inner') {
            // Draw an inner border by cliping the arc and drawing a double-width border
            // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
            ctx.beginPath();
            angleMargin = pixelMargin / vm.outerRadius;
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);

            if (vm.innerRadius > pixelMargin) {
              angleMargin = pixelMargin / vm.innerRadius;
              ctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);
            } else {
              ctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);
            }

            ctx.closePath();
            ctx.clip();
            ctx.beginPath();
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
            ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
            ctx.closePath();
            ctx.lineWidth = vm.borderWidth * 2;
            ctx.lineJoin = 'round';
          } else {
            ctx.lineWidth = vm.borderWidth;
            ctx.lineJoin = 'bevel';
          }

          ctx.strokeStyle = vm.borderColor;
          ctx.stroke();
        }

        ctx.restore();
      }
    });
    var valueOrDefault$1 = helpers$1.valueOrDefault;
    var defaultColor = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        line: {
          tension: 0.4,
          backgroundColor: defaultColor,
          borderWidth: 3,
          borderColor: defaultColor,
          borderCapStyle: 'butt',
          borderDash: [],
          borderDashOffset: 0.0,
          borderJoinStyle: 'miter',
          capBezierPoints: true,
          fill: true // do we fill in the area between the line and its base axis

        }
      }
    });

    var element_line = core_element.extend({
      draw: function () {
        var me = this;
        var vm = me._view;
        var ctx = me._chart.ctx;
        var spanGaps = vm.spanGaps;

        var points = me._children.slice(); // clone array


        var globalDefaults = core_defaults.global;
        var globalOptionLineElements = globalDefaults.elements.line;
        var lastDrawnIndex = -1;
        var index, current, previous, currentVM; // If we are looping, adding the first point again

        if (me._loop && points.length) {
          points.push(points[0]);
        }

        ctx.save(); // Stroke Line Options

        ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash

        if (ctx.setLineDash) {
          ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
        }

        ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
        ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
        ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
        ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line

        ctx.beginPath();
        lastDrawnIndex = -1;

        for (index = 0; index < points.length; ++index) {
          current = points[index];
          previous = helpers$1.previousItem(points, index);
          currentVM = current._view; // First point moves to it's starting position no matter what

          if (index === 0) {
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = index;
            }
          } else {
            previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

            if (!currentVM.skip) {
              if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                // There was a gap and this is the first point after the gap
                ctx.moveTo(currentVM.x, currentVM.y);
              } else {
                // Line to next point
                helpers$1.canvas.lineTo(ctx, previous._view, current._view);
              }

              lastDrawnIndex = index;
            }
          }
        }

        ctx.stroke();
        ctx.restore();
      }
    });
    var valueOrDefault$2 = helpers$1.valueOrDefault;
    var defaultColor$1 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        point: {
          radius: 3,
          pointStyle: 'circle',
          backgroundColor: defaultColor$1,
          borderColor: defaultColor$1,
          borderWidth: 1,
          // Hover
          hitRadius: 1,
          hoverRadius: 4,
          hoverBorderWidth: 1
        }
      }
    });

    function xRange(mouseX) {
      var vm = this._view;
      return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
    }

    function yRange(mouseY) {
      var vm = this._view;
      return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
    }

    var element_point = core_element.extend({
      inRange: function (mouseX, mouseY) {
        var vm = this._view;
        return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
      },
      inLabelRange: xRange,
      inXRange: xRange,
      inYRange: yRange,
      getCenterPoint: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      },
      getArea: function () {
        return Math.PI * Math.pow(this._view.radius, 2);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y,
          padding: vm.radius + vm.borderWidth
        };
      },
      draw: function (chartArea) {
        var vm = this._view;
        var ctx = this._chart.ctx;
        var pointStyle = vm.pointStyle;
        var rotation = vm.rotation;
        var radius = vm.radius;
        var x = vm.x;
        var y = vm.y;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow

        if (vm.skip) {
          return;
        } // Clipping for Points.


        if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
          ctx.strokeStyle = vm.borderColor || defaultColor;
          ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
          ctx.fillStyle = vm.backgroundColor || defaultColor;
          helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
        }
      }
    });
    var defaultColor$2 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        rectangle: {
          backgroundColor: defaultColor$2,
          borderColor: defaultColor$2,
          borderSkipped: 'bottom',
          borderWidth: 0
        }
      }
    });

    function isVertical(vm) {
      return vm && vm.width !== undefined;
    }
    /**
     * Helper function to get the bounds of the bar regardless of the orientation
     * @param bar {Chart.Element.Rectangle} the bar
     * @return {Bounds} bounds of the bar
     * @private
     */


    function getBarBounds(vm) {
      var x1, x2, y1, y2, half;

      if (isVertical(vm)) {
        half = vm.width / 2;
        x1 = vm.x - half;
        x2 = vm.x + half;
        y1 = Math.min(vm.y, vm.base);
        y2 = Math.max(vm.y, vm.base);
      } else {
        half = vm.height / 2;
        x1 = Math.min(vm.x, vm.base);
        x2 = Math.max(vm.x, vm.base);
        y1 = vm.y - half;
        y2 = vm.y + half;
      }

      return {
        left: x1,
        top: y1,
        right: x2,
        bottom: y2
      };
    }

    function swap(orig, v1, v2) {
      return orig === v1 ? v2 : orig === v2 ? v1 : orig;
    }

    function parseBorderSkipped(vm) {
      var edge = vm.borderSkipped;
      var res = {};

      if (!edge) {
        return res;
      }

      if (vm.horizontal) {
        if (vm.base > vm.x) {
          edge = swap(edge, 'left', 'right');
        }
      } else if (vm.base < vm.y) {
        edge = swap(edge, 'bottom', 'top');
      }

      res[edge] = true;
      return res;
    }

    function parseBorderWidth(vm, maxW, maxH) {
      var value = vm.borderWidth;
      var skip = parseBorderSkipped(vm);
      var t, r, b, l;

      if (helpers$1.isObject(value)) {
        t = +value.top || 0;
        r = +value.right || 0;
        b = +value.bottom || 0;
        l = +value.left || 0;
      } else {
        t = r = b = l = +value || 0;
      }

      return {
        t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,
        r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,
        b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
        l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l
      };
    }

    function boundingRects(vm) {
      var bounds = getBarBounds(vm);
      var width = bounds.right - bounds.left;
      var height = bounds.bottom - bounds.top;
      var border = parseBorderWidth(vm, width / 2, height / 2);
      return {
        outer: {
          x: bounds.left,
          y: bounds.top,
          w: width,
          h: height
        },
        inner: {
          x: bounds.left + border.l,
          y: bounds.top + border.t,
          w: width - border.l - border.r,
          h: height - border.t - border.b
        }
      };
    }

    function inRange(vm, x, y) {
      var skipX = x === null;
      var skipY = y === null;
      var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
      return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
    }

    var element_rectangle = core_element.extend({
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var rects = boundingRects(vm);
        var outer = rects.outer;
        var inner = rects.inner;
        ctx.fillStyle = vm.backgroundColor;
        ctx.fillRect(outer.x, outer.y, outer.w, outer.h);

        if (outer.w === inner.w && outer.h === inner.h) {
          return;
        }

        ctx.save();
        ctx.beginPath();
        ctx.rect(outer.x, outer.y, outer.w, outer.h);
        ctx.clip();
        ctx.fillStyle = vm.borderColor;
        ctx.rect(inner.x, inner.y, inner.w, inner.h);
        ctx.fill('evenodd');
        ctx.restore();
      },
      height: function () {
        var vm = this._view;
        return vm.base - vm.y;
      },
      inRange: function (mouseX, mouseY) {
        return inRange(this._view, mouseX, mouseY);
      },
      inLabelRange: function (mouseX, mouseY) {
        var vm = this._view;
        return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
      },
      inXRange: function (mouseX) {
        return inRange(this._view, mouseX, null);
      },
      inYRange: function (mouseY) {
        return inRange(this._view, null, mouseY);
      },
      getCenterPoint: function () {
        var vm = this._view;
        var x, y;

        if (isVertical(vm)) {
          x = vm.x;
          y = (vm.y + vm.base) / 2;
        } else {
          x = (vm.x + vm.base) / 2;
          y = vm.y;
        }

        return {
          x: x,
          y: y
        };
      },
      getArea: function () {
        var vm = this._view;
        return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      }
    });
    var elements = {};
    var Arc = element_arc;
    var Line = element_line;
    var Point = element_point;
    var Rectangle = element_rectangle;
    elements.Arc = Arc;
    elements.Line = Line;
    elements.Point = Point;
    elements.Rectangle = Rectangle;
    var resolve$1 = helpers$1.options.resolve;

    core_defaults._set('bar', {
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }],
        yAxes: [{
          type: 'linear'
        }]
      }
    });
    /**
     * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
     * @private
     */


    function computeMinSampleSize(scale, pixels) {
      var min = scale.isHorizontal() ? scale.width : scale.height;
      var ticks = scale.getTicks();
      var prev, curr, i, ilen;

      for (i = 1, ilen = pixels.length; i < ilen; ++i) {
        min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
      }

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        curr = scale.getPixelForTick(i);
        min = i > 0 ? Math.min(min, curr - prev) : min;
        prev = curr;
      }

      return min;
    }
    /**
     * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
     * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
     * mode currently always generates bars equally sized (until we introduce scriptable options?).
     * @private
     */


    function computeFitCategoryTraits(index, ruler, options) {
      var thickness = options.barThickness;
      var count = ruler.stackCount;
      var curr = ruler.pixels[index];
      var size, ratio;

      if (helpers$1.isNullOrUndef(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
      } else {
        // When bar thickness is enforced, category and bar percentages are ignored.
        // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
        // and deprecate barPercentage since this value is ignored when thickness is absolute.
        size = thickness * count;
        ratio = 1;
      }

      return {
        chunk: size / count,
        ratio: ratio,
        start: curr - size / 2
      };
    }
    /**
     * Computes an "optimal" category that globally arranges bars side by side (no gap when
     * percentage options are 1), based on the previous and following categories. This mode
     * generates bars with different widths when data are not evenly spaced.
     * @private
     */


    function computeFlexCategoryTraits(index, ruler, options) {
      var pixels = ruler.pixels;
      var curr = pixels[index];
      var prev = index > 0 ? pixels[index - 1] : null;
      var next = index < pixels.length - 1 ? pixels[index + 1] : null;
      var percent = options.categoryPercentage;
      var start, size;

      if (prev === null) {
        // first data: its size is double based on the next point or,
        // if it's also the last data, we use the scale size.
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
      }

      if (next === null) {
        // last data: its size is also double based on the previous point.
        next = curr + curr - prev;
      }

      start = curr - (curr - Math.min(prev, next)) / 2 * percent;
      size = Math.abs(next - prev) / 2 * percent;
      return {
        chunk: size / ruler.stackCount,
        ratio: options.barPercentage,
        start: start
      };
    }

    var controller_bar = core_datasetController.extend({
      dataElementType: elements.Rectangle,
      initialize: function () {
        var me = this;
        var meta;
        core_datasetController.prototype.initialize.apply(me, arguments);
        meta = me.getMeta();
        meta.stack = me.getDataset().stack;
        meta.bar = true;
      },
      update: function (reset) {
        var me = this;
        var rects = me.getMeta().data;
        var i, ilen;
        me._ruler = me.getRuler();

        for (i = 0, ilen = rects.length; i < ilen; ++i) {
          me.updateElement(rects[i], i, reset);
        }
      },
      updateElement: function (rectangle, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        var options = me._resolveElementOptions(rectangle, index);

        rectangle._xScale = me.getScaleForId(meta.xAxisID);
        rectangle._yScale = me.getScaleForId(meta.yAxisID);
        rectangle._datasetIndex = me.index;
        rectangle._index = index;
        rectangle._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderSkipped: options.borderSkipped,
          borderWidth: options.borderWidth,
          datasetLabel: dataset.label,
          label: me.chart.data.labels[index]
        };

        me._updateElementGeometry(rectangle, index, reset);

        rectangle.pivot();
      },

      /**
       * @private
       */
      _updateElementGeometry: function (rectangle, index, reset) {
        var me = this;
        var model = rectangle._model;

        var vscale = me._getValueScale();

        var base = vscale.getBasePixel();
        var horizontal = vscale.isHorizontal();
        var ruler = me._ruler || me.getRuler();
        var vpixels = me.calculateBarValuePixels(me.index, index);
        var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
        model.horizontal = horizontal;
        model.base = reset ? base : vpixels.base;
        model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
        model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
        model.height = horizontal ? ipixels.size : undefined;
        model.width = horizontal ? undefined : ipixels.size;
      },

      /**
       * Returns the stacks based on groups and bar visibility.
       * @param {number} [last] - The dataset index
       * @returns {string[]} The list of stack IDs
       * @private
       */
      _getStacks: function (last) {
        var me = this;
        var chart = me.chart;

        var scale = me._getIndexScale();

        var stacked = scale.options.stacked;
        var ilen = last === undefined ? chart.data.datasets.length : last + 1;
        var stacks = [];
        var i, meta;

        for (i = 0; i < ilen; ++i) {
          meta = chart.getDatasetMeta(i);

          if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
            stacks.push(meta.stack);
          }
        }

        return stacks;
      },

      /**
       * Returns the effective number of stacks based on groups and bar visibility.
       * @private
       */
      getStackCount: function () {
        return this._getStacks().length;
      },

      /**
       * Returns the stack index for the given dataset based on groups and bar visibility.
       * @param {number} [datasetIndex] - The dataset index
       * @param {string} [name] - The stack name to find
       * @returns {number} The stack index
       * @private
       */
      getStackIndex: function (datasetIndex, name) {
        var stacks = this._getStacks(datasetIndex);

        var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present

        return index === -1 ? stacks.length - 1 : index;
      },

      /**
       * @private
       */
      getRuler: function () {
        var me = this;

        var scale = me._getIndexScale();

        var stackCount = me.getStackCount();
        var datasetIndex = me.index;
        var isHorizontal = scale.isHorizontal();
        var start = isHorizontal ? scale.left : scale.top;
        var end = start + (isHorizontal ? scale.width : scale.height);
        var pixels = [];
        var i, ilen, min;

        for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
          pixels.push(scale.getPixelForValue(null, i, datasetIndex));
        }

        min = helpers$1.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;
        return {
          min: min,
          pixels: pixels,
          start: start,
          end: end,
          stackCount: stackCount,
          scale: scale
        };
      },

      /**
       * Note: pixel values are not clamped to the scale area.
       * @private
       */
      calculateBarValuePixels: function (datasetIndex, index) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();

        var scale = me._getValueScale();

        var isHorizontal = scale.isHorizontal();
        var datasets = chart.data.datasets;
        var value = +scale.getRightValue(datasets[datasetIndex].data[index]);
        var minBarLength = scale.options.minBarLength;
        var stacked = scale.options.stacked;
        var stack = meta.stack;
        var start = 0;
        var i, imeta, ivalue, base, head, size;

        if (stacked || stacked === undefined && stack !== undefined) {
          for (i = 0; i < datasetIndex; ++i) {
            imeta = chart.getDatasetMeta(i);

            if (imeta.bar && imeta.stack === stack && imeta.controller._getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {
              ivalue = +scale.getRightValue(datasets[i].data[index]);

              if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
                start += ivalue;
              }
            }
          }
        }

        base = scale.getPixelForValue(start);
        head = scale.getPixelForValue(start + value);
        size = head - base;

        if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
          size = minBarLength;

          if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {
            head = base - minBarLength;
          } else {
            head = base + minBarLength;
          }
        }

        return {
          size: size,
          base: base,
          head: head,
          center: head + size / 2
        };
      },

      /**
       * @private
       */
      calculateBarIndexPixels: function (datasetIndex, index, ruler) {
        var me = this;
        var options = ruler.scale.options;
        var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
        var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
        var center = range.start + range.chunk * stackIndex + range.chunk / 2;
        var size = Math.min(helpers$1.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);
        return {
          base: center - size / 2,
          head: center + size / 2,
          center: center,
          size: size
        };
      },
      draw: function () {
        var me = this;
        var chart = me.chart;

        var scale = me._getValueScale();

        var rects = me.getMeta().data;
        var dataset = me.getDataset();
        var ilen = rects.length;
        var i = 0;
        helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);

        for (; i < ilen; ++i) {
          if (!isNaN(scale.getRightValue(dataset.data[i]))) {
            rects[i].draw();
          }
        }

        helpers$1.canvas.unclipArea(chart.ctx);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (rectangle, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = rectangle.custom || {};
        var options = chart.options.elements.rectangle;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$1([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      }
    });
    var valueOrDefault$3 = helpers$1.valueOrDefault;
    var resolve$2 = helpers$1.options.resolve;

    core_defaults._set('bubble', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          // bubble should probably use a linear scale by default
          position: 'bottom',
          id: 'x-axis-0' // need an ID so datasets can reference the scale

        }],
        yAxes: [{
          type: 'linear',
          position: 'left',
          id: 'y-axis-0'
        }]
      },
      tooltips: {
        callbacks: {
          title: function () {
            // Title doesn't make sense for scatter since we format the data as a point
            return '';
          },
          label: function (item, data) {
            var datasetLabel = data.datasets[item.datasetIndex].label || '';
            var dataPoint = data.datasets[item.datasetIndex].data[item.index];
            return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
          }
        }
      }
    });

    var controller_bubble = core_datasetController.extend({
      /**
       * @protected
       */
      dataElementType: elements.Point,

      /**
       * @protected
       */
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var points = meta.data; // Update Points

        helpers$1.each(points, function (point, index) {
          me.updateElement(point, index, reset);
        });
      },

      /**
       * @protected
       */
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var xScale = me.getScaleForId(meta.xAxisID);
        var yScale = me.getScaleForId(meta.yAxisID);

        var options = me._resolveElementOptions(point, index);

        var data = me.getDataset().data[index];
        var dsIndex = me.index;
        var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
        var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = dsIndex;
        point._index = index;
        point._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          hitRadius: options.hitRadius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          radius: reset ? 0 : options.radius,
          skip: custom.skip || isNaN(x) || isNaN(y),
          x: x,
          y: y
        };
        point.pivot();
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$3(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$3(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$3(options.hoverBorderWidth, options.borderWidth);
        model.radius = options.radius + options.hoverRadius;
      },

      /**
       * @private
       */
      _resolveElementOptions: function (point, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = point.custom || {};
        var options = chart.options.elements.point;
        var data = dataset.data[index];
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$2([custom[key], dataset[key], options[key]], context, index);
        } // Custom radius resolution


        values.radius = resolve$2([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);
        return values;
      }
    });
    var resolve$3 = helpers$1.options.resolve;
    var valueOrDefault$4 = helpers$1.valueOrDefault;

    core_defaults._set('doughnut', {
      animation: {
        // Boolean - Whether we animate the rotation of the Doughnut
        animateRotate: true,
        // Boolean - Whether we animate scaling the Doughnut from the centre
        animateScale: false
      },
      hover: {
        mode: 'single'
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc && arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$3([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$3([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$3([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i); // toggle visibility of index if exists

            if (meta.data[index]) {
              meta.data[index].hidden = !meta.data[index].hidden;
            }
          }

          chart.update();
        }
      },
      // The percentage of the chart that we cut out of the middle.
      cutoutPercentage: 50,
      // The rotation of the chart, where the first data arc begins.
      rotation: Math.PI * -0.5,
      // The total circumference of the chart.
      circumference: Math.PI * 2.0,
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (tooltipItem, data) {
            var dataLabel = data.labels[tooltipItem.index];
            var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

            if (helpers$1.isArray(dataLabel)) {
              // show value on first line of multiline label
              // need to clone because we are changing the value
              dataLabel = dataLabel.slice();
              dataLabel[0] += value;
            } else {
              dataLabel += value;
            }

            return dataLabel;
          }
        }
      }
    });

    var controller_doughnut = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
      getRingIndex: function (datasetIndex) {
        var ringIndex = 0;

        for (var j = 0; j < datasetIndex; ++j) {
          if (this.chart.isDatasetVisible(j)) {
            ++ringIndex;
          }
        }

        return ringIndex;
      },
      update: function (reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var availableWidth = chartArea.right - chartArea.left;
        var availableHeight = chartArea.bottom - chartArea.top;
        var minSize = Math.min(availableWidth, availableHeight);
        var offset = {
          x: 0,
          y: 0
        };
        var meta = me.getMeta();
        var arcs = meta.data;
        var cutoutPercentage = opts.cutoutPercentage;
        var circumference = opts.circumference;

        var chartWeight = me._getRingWeight(me.index);

        var i, ilen; // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc

        if (circumference < Math.PI * 2.0) {
          var startAngle = opts.rotation % (Math.PI * 2.0);
          startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
          var endAngle = startAngle + circumference;
          var start = {
            x: Math.cos(startAngle),
            y: Math.sin(startAngle)
          };
          var end = {
            x: Math.cos(endAngle),
            y: Math.sin(endAngle)
          };
          var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
          var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
          var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
          var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
          var cutout = cutoutPercentage / 100.0;
          var min = {
            x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
            y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
          };
          var max = {
            x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
            y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
          };
          var size = {
            width: (max.x - min.x) * 0.5,
            height: (max.y - min.y) * 0.5
          };
          minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
          offset = {
            x: (max.x + min.x) * -0.5,
            y: (max.y + min.y) * -0.5
          };
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
        }

        chart.borderWidth = me.getMaxBorderWidth();
        chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
        chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
        chart.offsetX = offset.x * chart.outerRadius;
        chart.offsetY = offset.y * chart.outerRadius;
        meta.total = me.calculateTotal();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
        me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          me.updateElement(arcs[i], i, reset);
        }
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var animationOpts = opts.animation;
        var centerX = (chartArea.left + chartArea.right) / 2;
        var centerY = (chartArea.top + chartArea.bottom) / 2;
        var startAngle = opts.rotation; // non reset case handled later

        var endAngle = opts.rotation; // non reset case handled later

        var dataset = me.getDataset();
        var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
        var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
        var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX + chart.offsetX,
            y: centerY + chart.offsetY,
            startAngle: startAngle,
            endAngle: endAngle,
            circumference: circumference,
            outerRadius: outerRadius,
            innerRadius: innerRadius,
            label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
          }
        });
        var model = arc._model; // Set correct angles if not resetting

        if (!reset || !animationOpts.animateRotate) {
          if (index === 0) {
            model.startAngle = opts.rotation;
          } else {
            model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
          }

          model.endAngle = model.startAngle + model.circumference;
        }

        arc.pivot();
      },
      calculateTotal: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var total = 0;
        var value;
        helpers$1.each(meta.data, function (element, index) {
          value = dataset.data[index];

          if (!isNaN(value) && !element.hidden) {
            total += Math.abs(value);
          }
        });
        /* if (total === 0) {
        	total = NaN;
        }*/

        return total;
      },
      calculateCircumference: function (value) {
        var total = this.getMeta().total;

        if (total > 0 && !isNaN(value)) {
          return Math.PI * 2.0 * (Math.abs(value) / total);
        }

        return 0;
      },
      // gets the max border or hover width to properly scale pie charts
      getMaxBorderWidth: function (arcs) {
        var me = this;
        var max = 0;
        var chart = me.chart;
        var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;

        if (!arcs) {
          // Find the outmost visible dataset
          for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              meta = chart.getDatasetMeta(i);
              arcs = meta.data;

              if (i !== me.index) {
                controller = meta.controller;
              }

              break;
            }
          }
        }

        if (!arcs) {
          return 0;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arc = arcs[i];
          options = controller ? controller._resolveElementOptions(arc, i) : arc._options;

          if (options.borderAlign !== 'inner') {
            borderWidth = options.borderWidth;
            hoverWidth = options.hoverBorderWidth;
            max = borderWidth > max ? borderWidth : max;
            max = hoverWidth > max ? hoverWidth : max;
          }
        }

        return max;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$3([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
       * @private
       */
      _getRingWeightOffset: function (datasetIndex) {
        var ringWeightOffset = 0;

        for (var i = 0; i < datasetIndex; ++i) {
          if (this.chart.isDatasetVisible(i)) {
            ringWeightOffset += this._getRingWeight(i);
          }
        }

        return ringWeightOffset;
      },

      /**
       * @private
       */
      _getRingWeight: function (dataSetIndex) {
        return Math.max(valueOrDefault$4(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
      },

      /**
       * Returns the sum of all visibile data set weights.  This value can be 0.
       * @private
       */
      _getVisibleDatasetWeightTotal: function () {
        return this._getRingWeightOffset(this.chart.data.datasets.length);
      }
    });

    core_defaults._set('horizontalBar', {
      hover: {
        mode: 'index',
        axis: 'y'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          position: 'bottom'
        }],
        yAxes: [{
          type: 'category',
          position: 'left',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }]
      },
      elements: {
        rectangle: {
          borderSkipped: 'left'
        }
      },
      tooltips: {
        mode: 'index',
        axis: 'y'
      }
    });

    var controller_horizontalBar = controller_bar.extend({
      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().yAxisID;
      }
    });
    var valueOrDefault$5 = helpers$1.valueOrDefault;
    var resolve$4 = helpers$1.options.resolve;
    var isPointInArea = helpers$1.canvas._isPointInArea;

    core_defaults._set('line', {
      showLines: true,
      spanGaps: false,
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          id: 'x-axis-0'
        }],
        yAxes: [{
          type: 'linear',
          id: 'y-axis-0'
        }]
      }
    });

    function lineEnabled(dataset, options) {
      return valueOrDefault$5(dataset.showLine, options.showLines);
    }

    var controller_line = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.getScaleForId(meta.yAxisID);
        var dataset = me.getDataset();
        var showLine = lineEnabled(dataset, me.chart.options);
        var i, ilen; // Update Line

        if (showLine) {
          // Compatibility: If the properties are defined with only the old name, use those values
          if (dataset.tension !== undefined && dataset.lineTension === undefined) {
            dataset.lineTension = dataset.tension;
          } // Utility


          line._scale = scale;
          line._datasetIndex = me.index; // Data

          line._children = points; // Model

          line._model = me._resolveLineOptions(line);
          line.pivot();
        } // Update Points


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        }

        if (showLine && line._model.tension !== 0) {
          me.updateBezierControlPoints();
        } // Now pivot the point for animation


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var datasetIndex = me.index;
        var value = dataset.data[index];
        var yScale = me.getScaleForId(meta.yAxisID);
        var xScale = me.getScaleForId(meta.xAxisID);
        var lineModel = meta.dataset._model;
        var x, y;

        var options = me._resolvePointOptions(point, index);

        x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
        y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility

        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = datasetIndex;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$5(custom.tension, lineModel ? lineModel.tension : 0),
          steppedLine: lineModel ? lineModel.steppedLine : false,
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options;
        var elementOptions = options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill', 'cubicInterpolationMode'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[key], elementOptions[key]]);
        } // The default behavior of lines is to break at null values, according
        // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
        // This option gives lines the ability to span gaps


        values.spanGaps = valueOrDefault$5(dataset.spanGaps, options.spanGaps);
        values.tension = valueOrDefault$5(dataset.lineTension, elementOptions.tension);
        values.steppedLine = resolve$4([custom.steppedLine, dataset.steppedLine, elementOptions.stepped]);
        return values;
      },
      calculatePointY: function (value, index, datasetIndex) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var yScale = me.getScaleForId(meta.yAxisID);
        var sumPos = 0;
        var sumNeg = 0;
        var i, ds, dsMeta;

        if (yScale.options.stacked) {
          for (i = 0; i < datasetIndex; i++) {
            ds = chart.data.datasets[i];
            dsMeta = chart.getDatasetMeta(i);

            if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
              var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));

              if (stackedRightValue < 0) {
                sumNeg += stackedRightValue || 0;
              } else {
                sumPos += stackedRightValue || 0;
              }
            }
          }

          var rightValue = Number(yScale.getRightValue(value));

          if (rightValue < 0) {
            return yScale.getPixelForValue(sumNeg + rightValue);
          }

          return yScale.getPixelForValue(sumPos + rightValue);
        }

        return yScale.getPixelForValue(value);
      },
      updateBezierControlPoints: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var lineModel = meta.dataset._model;
        var area = chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

        if (lineModel.spanGaps) {
          points = points.filter(function (pt) {
            return !pt._model.skip;
          });
        }

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        if (lineModel.cubicInterpolationMode === 'monotone') {
          helpers$1.splineCurveMonotone(points);
        } else {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;
            controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
            model.controlPointPreviousX = controlPoints.previous.x;
            model.controlPointPreviousY = controlPoints.previous.y;
            model.controlPointNextX = controlPoints.next.x;
            model.controlPointNextY = controlPoints.next.y;
          }
        }

        if (chart.options.elements.line.capBezierPoints) {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;

            if (isPointInArea(model, area)) {
              if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
              }

              if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
              }
            }
          }
        }
      },
      draw: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var points = meta.data || [];
        var area = chart.chartArea;
        var ilen = points.length;
        var halfBorderWidth;
        var i = 0;

        if (lineEnabled(me.getDataset(), chart.options)) {
          halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;
          helpers$1.canvas.clipArea(chart.ctx, {
            left: area.left,
            right: area.right,
            top: area.top - halfBorderWidth,
            bottom: area.bottom + halfBorderWidth
          });
          meta.dataset.draw();
          helpers$1.canvas.unclipArea(chart.ctx);
        } // Draw the points


        for (; i < ilen; ++i) {
          points[i].draw(area);
        }
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$5(options.hoverRadius, options.radius);
      }
    });
    var resolve$5 = helpers$1.options.resolve;

    core_defaults._set('polarArea', {
      scale: {
        type: 'radialLinear',
        angleLines: {
          display: false
        },
        gridLines: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        ticks: {
          beginAtZero: true
        }
      },
      // Boolean - Whether to animate the rotation of the chart
      animation: {
        animateRotate: true,
        animateScale: true
      },
      startAngle: -0.5 * Math.PI,
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$5([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$5([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$5([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i);
            meta.data[index].hidden = !meta.data[index].hidden;
          }

          chart.update();
        }
      },
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (item, data) {
            return data.labels[item.index] + ': ' + item.yLabel;
          }
        }
      }
    });

    var controller_polarArea = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var dataset = me.getDataset();
        var meta = me.getMeta();
        var start = me.chart.options.startAngle || 0;
        var starts = me._starts = [];
        var angles = me._angles = [];
        var arcs = meta.data;
        var i, ilen, angle;

        me._updateRadius();

        meta.count = me.countVisibleElements();

        for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
          starts[i] = start;
          angle = me._computeAngle(i);
          angles[i] = angle;
          start += angle;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
          me.updateElement(arcs[i], i, reset);
        }
      },

      /**
       * @private
       */
      _updateRadius: function () {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        chart.outerRadius = Math.max(minSize / 2, 0);
        chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
        me.innerRadius = me.outerRadius - chart.radiusLength;
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var opts = chart.options;
        var animationOpts = opts.animation;
        var scale = chart.scale;
        var labels = chart.data.labels;
        var centerX = scale.xCenter;
        var centerY = scale.yCenter; // var negHalfPI = -0.5 * Math.PI;

        var datasetStartAngle = opts.startAngle;
        var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var startAngle = me._starts[index];
        var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
        var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          _scale: scale,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX,
            y: centerY,
            innerRadius: 0,
            outerRadius: reset ? resetRadius : distance,
            startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
            endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
            label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
          }
        });
        arc.pivot();
      },
      countVisibleElements: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var count = 0;
        helpers$1.each(meta.data, function (element, index) {
          if (!isNaN(dataset.data[index]) && !element.hidden) {
            count++;
          }
        });
        return count;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        var valueOrDefault = helpers$1.valueOrDefault;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$5([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _computeAngle: function (index) {
        var me = this;
        var count = this.getMeta().count;
        var dataset = me.getDataset();
        var meta = me.getMeta();

        if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
          return 0;
        } // Scriptable options


        var context = {
          chart: me.chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        return resolve$5([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);
      }
    });

    core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));

    core_defaults._set('pie', {
      cutoutPercentage: 0
    }); // Pie charts are Doughnut chart with different defaults


    var controller_pie = controller_doughnut;
    var valueOrDefault$6 = helpers$1.valueOrDefault;
    var resolve$6 = helpers$1.options.resolve;

    core_defaults._set('radar', {
      scale: {
        type: 'radialLinear'
      },
      elements: {
        line: {
          tension: 0 // no bezier in radar

        }
      }
    });

    var controller_radar = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.chart.scale;
        var dataset = me.getDataset();
        var i, ilen; // Compatibility: If the properties are defined with only the old name, use those values

        if (dataset.tension !== undefined && dataset.lineTension === undefined) {
          dataset.lineTension = dataset.tension;
        } // Utility


        line._scale = scale;
        line._datasetIndex = me.index; // Data

        line._children = points;
        line._loop = true; // Model

        line._model = me._resolveLineOptions(line);
        line.pivot(); // Update Points

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        } // Update bezier control points


        me.updateBezierControlPoints(); // Now pivot the point for animation

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var scale = me.chart.scale;
        var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

        var options = me._resolvePointOptions(point, index);

        var lineModel = me.getMeta().dataset._model;

        var x = reset ? scale.xCenter : pointPosition.x;
        var y = reset ? scale.yCenter : pointPosition.y; // Utility

        point._scale = scale;
        point._options = options;
        point._datasetIndex = me.index;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          // value not used in dataset scale, but we want a consistent API between scales
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[key], options[key]]);
        }

        values.tension = valueOrDefault$6(dataset.lineTension, options.tension);
        return values;
      },
      updateBezierControlPoints: function () {
        var me = this;
        var meta = me.getMeta();
        var area = me.chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints;

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;
          controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph

          model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
          model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
          model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
          model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
        }
      },
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
      }
    });

    core_defaults._set('scatter', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          id: 'x-axis-1',
          // need an ID so datasets can reference the scale
          type: 'linear',
          // scatter should not use a category axis
          position: 'bottom'
        }],
        yAxes: [{
          id: 'y-axis-1',
          type: 'linear',
          position: 'left'
        }]
      },
      showLines: false,
      tooltips: {
        callbacks: {
          title: function () {
            return ''; // doesn't make sense for scatter since data are formatted as a point
          },
          label: function (item) {
            return '(' + item.xLabel + ', ' + item.yLabel + ')';
          }
        }
      }
    }); // Scatter charts use line controllers


    var controller_scatter = controller_line; // NOTE export a map in which the key represents the controller type, not
    // the class, and so must be CamelCase in order to be correctly retrieved
    // by the controller in core.controller.js (`controllers[meta.type]`).

    var controllers = {
      bar: controller_bar,
      bubble: controller_bubble,
      doughnut: controller_doughnut,
      horizontalBar: controller_horizontalBar,
      line: controller_line,
      polarArea: controller_polarArea,
      pie: controller_pie,
      radar: controller_radar,
      scatter: controller_scatter
    };
    /**
     * Helper function to get relative position for an event
     * @param {Event|IEvent} event - The event to get the position for
     * @param {Chart} chart - The chart
     * @returns {object} the event position
     */

    function getRelativePosition(e, chart) {
      if (e.native) {
        return {
          x: e.x,
          y: e.y
        };
      }

      return helpers$1.getRelativePosition(e, chart);
    }
    /**
     * Helper function to traverse all of the visible elements in the chart
     * @param {Chart} chart - the chart
     * @param {function} handler - the callback to execute for each visible item
     */


    function parseVisibleItems(chart, handler) {
      var datasets = chart.data.datasets;
      var meta, i, j, ilen, jlen;

      for (i = 0, ilen = datasets.length; i < ilen; ++i) {
        if (!chart.isDatasetVisible(i)) {
          continue;
        }

        meta = chart.getDatasetMeta(i);

        for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
          var element = meta.data[j];

          if (!element._view.skip) {
            handler(element);
          }
        }
      }
    }
    /**
     * Helper function to get the items that intersect the event position
     * @param {ChartElement[]} items - elements to filter
     * @param {object} position - the point to be nearest to
     * @return {ChartElement[]} the nearest items
     */


    function getIntersectItems(chart, position) {
      var elements = [];
      parseVisibleItems(chart, function (element) {
        if (element.inRange(position.x, position.y)) {
          elements.push(element);
        }
      });
      return elements;
    }
    /**
     * Helper function to get the items nearest to the event position considering all visible items in teh chart
     * @param {Chart} chart - the chart to look at elements from
     * @param {object} position - the point to be nearest to
     * @param {boolean} intersect - if true, only consider items that intersect the position
     * @param {function} distanceMetric - function to provide the distance between points
     * @return {ChartElement[]} the nearest items
     */


    function getNearestItems(chart, position, intersect, distanceMetric) {
      var minDistance = Number.POSITIVE_INFINITY;
      var nearestItems = [];
      parseVisibleItems(chart, function (element) {
        if (intersect && !element.inRange(position.x, position.y)) {
          return;
        }

        var center = element.getCenterPoint();
        var distance = distanceMetric(position, center);

        if (distance < minDistance) {
          nearestItems = [element];
          minDistance = distance;
        } else if (distance === minDistance) {
          // Can have multiple items at the same distance in which case we sort by size
          nearestItems.push(element);
        }
      });
      return nearestItems;
    }
    /**
     * Get a distance metric function for two points based on the
     * axis mode setting
     * @param {string} axis - the axis mode. x|y|xy
     */


    function getDistanceMetricForAxis(axis) {
      var useX = axis.indexOf('x') !== -1;
      var useY = axis.indexOf('y') !== -1;
      return function (pt1, pt2) {
        var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }

    function indexMode(chart, e, options) {
      var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour

      options.axis = options.axis || 'x';
      var distanceMetric = getDistanceMetricForAxis(options.axis);
      var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
      var elements = [];

      if (!items.length) {
        return [];
      }

      chart.data.datasets.forEach(function (dataset, datasetIndex) {
        if (chart.isDatasetVisible(datasetIndex)) {
          var meta = chart.getDatasetMeta(datasetIndex);
          var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)

          if (element && !element._view.skip) {
            elements.push(element);
          }
        }
      });
      return elements;
    }
    /**
     * @interface IInteractionOptions
     */

    /**
     * If true, only consider items that intersect the point
     * @name IInterfaceOptions#boolean
     * @type Boolean
     */

    /**
     * Contains interaction related functions
     * @namespace Chart.Interaction
     */


    var core_interaction = {
      // Helper function for different modes
      modes: {
        single: function (chart, e) {
          var position = getRelativePosition(e, chart);
          var elements = [];
          parseVisibleItems(chart, function (element) {
            if (element.inRange(position.x, position.y)) {
              elements.push(element);
              return elements;
            }
          });
          return elements.slice(0, 1);
        },

        /**
         * @function Chart.Interaction.modes.label
         * @deprecated since version 2.4.0
         * @todo remove at version 3
         * @private
         */
        label: indexMode,

        /**
         * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
         * @function Chart.Interaction.modes.index
         * @since v2.4.0
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        index: indexMode,

        /**
         * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect is false, we find the nearest item and return the items in that dataset
         * @function Chart.Interaction.modes.dataset
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        dataset: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

          if (items.length > 0) {
            items = chart.getDatasetMeta(items[0]._datasetIndex).data;
          }

          return items;
        },

        /**
         * @function Chart.Interaction.modes.x-axis
         * @deprecated since version 2.4.0. Use index mode and intersect == true
         * @todo remove at version 3
         * @private
         */
        'x-axis': function (chart, e) {
          return indexMode(chart, e, {
            intersect: false
          });
        },

        /**
         * Point mode returns all elements that hit test based on the event position
         * of the event
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        point: function (chart, e) {
          var position = getRelativePosition(e, chart);
          return getIntersectItems(chart, position);
        },

        /**
         * nearest mode returns the element closest to the point
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        nearest: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          return getNearestItems(chart, position, options.intersect, distanceMetric);
        },

        /**
         * x mode returns the elements that hit-test at the current x coordinate
         * @function Chart.Interaction.modes.x
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        x: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inXRange(position.x)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        },

        /**
         * y mode returns the elements that hit-test at the current y coordinate
         * @function Chart.Interaction.modes.y
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        y: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inYRange(position.y)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        }
      }
    };

    function filterByPosition(array, position) {
      return helpers$1.where(array, function (v) {
        return v.position === position;
      });
    }

    function sortByWeight(array, reverse) {
      array.forEach(function (v, i) {
        v._tmpIndex_ = i;
        return v;
      });
      array.sort(function (a, b) {
        var v0 = reverse ? b : a;
        var v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
      });
      array.forEach(function (v) {
        delete v._tmpIndex_;
      });
    }

    function findMaxPadding(boxes) {
      var top = 0;
      var left = 0;
      var bottom = 0;
      var right = 0;
      helpers$1.each(boxes, function (box) {
        if (box.getPadding) {
          var boxPadding = box.getPadding();
          top = Math.max(top, boxPadding.top);
          left = Math.max(left, boxPadding.left);
          bottom = Math.max(bottom, boxPadding.bottom);
          right = Math.max(right, boxPadding.right);
        }
      });
      return {
        top: top,
        left: left,
        bottom: bottom,
        right: right
      };
    }

    function addSizeByPosition(boxes, size) {
      helpers$1.each(boxes, function (box) {
        size[box.position] += box.isHorizontal() ? box.height : box.width;
      });
    }

    core_defaults._set('global', {
      layout: {
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      }
    });
    /**
     * @interface ILayoutItem
     * @prop {string} position - The position of the item in the chart layout. Possible values are
     * 'left', 'top', 'right', 'bottom', and 'chartArea'
     * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area
     * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
     * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
     * @prop {function} update - Takes two parameters: width and height. Returns size of item
     * @prop {function} getPadding -  Returns an object with padding on the edges
     * @prop {number} width - Width of item. Must be valid after update()
     * @prop {number} height - Height of item. Must be valid after update()
     * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update
     * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update
     * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update
     * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
     */
    // The layout service is very self explanatory.  It's responsible for the layout within a chart.
    // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
    // It is this service's responsibility of carrying out that layout.


    var core_layouts = {
      defaults: {},

      /**
       * Register a box to a chart.
       * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
       * @param {Chart} chart - the chart to use
       * @param {ILayoutItem} item - the item to add to be layed out
       */
      addBox: function (chart, item) {
        if (!chart.boxes) {
          chart.boxes = [];
        } // initialize item with default values


        item.fullWidth = item.fullWidth || false;
        item.position = item.position || 'top';
        item.weight = item.weight || 0;
        chart.boxes.push(item);
      },

      /**
       * Remove a layoutItem from a chart
       * @param {Chart} chart - the chart to remove the box from
       * @param {ILayoutItem} layoutItem - the item to remove from the layout
       */
      removeBox: function (chart, layoutItem) {
        var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;

        if (index !== -1) {
          chart.boxes.splice(index, 1);
        }
      },

      /**
       * Sets (or updates) options on the given `item`.
       * @param {Chart} chart - the chart in which the item lives (or will be added to)
       * @param {ILayoutItem} item - the item to configure with the given options
       * @param {object} options - the new item options.
       */
      configure: function (chart, item, options) {
        var props = ['fullWidth', 'position', 'weight'];
        var ilen = props.length;
        var i = 0;
        var prop;

        for (; i < ilen; ++i) {
          prop = props[i];

          if (options.hasOwnProperty(prop)) {
            item[prop] = options[prop];
          }
        }
      },

      /**
       * Fits boxes of the given chart into the given size by having each box measure itself
       * then running a fitting algorithm
       * @param {Chart} chart - the chart
       * @param {number} width - the width to fit into
       * @param {number} height - the height to fit into
       */
      update: function (chart, width, height) {
        if (!chart) {
          return;
        }

        var layoutOptions = chart.options.layout || {};
        var padding = helpers$1.options.toPadding(layoutOptions.padding);
        var leftPadding = padding.left;
        var rightPadding = padding.right;
        var topPadding = padding.top;
        var bottomPadding = padding.bottom;
        var leftBoxes = filterByPosition(chart.boxes, 'left');
        var rightBoxes = filterByPosition(chart.boxes, 'right');
        var topBoxes = filterByPosition(chart.boxes, 'top');
        var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
        var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea'); // Sort boxes by weight. A higher weight is further away from the chart area

        sortByWeight(leftBoxes, true);
        sortByWeight(rightBoxes, false);
        sortByWeight(topBoxes, true);
        sortByWeight(bottomBoxes, false);
        var verticalBoxes = leftBoxes.concat(rightBoxes);
        var horizontalBoxes = topBoxes.concat(bottomBoxes);
        var outerBoxes = verticalBoxes.concat(horizontalBoxes); // Essentially we now have any number of boxes on each of the 4 sides.
        // Our canvas looks like the following.
        // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
        // B1 is the bottom axis
        // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
        // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
        // an error will be thrown.
        //
        // |----------------------------------------------------|
        // |                  T1 (Full Width)                   |
        // |----------------------------------------------------|
        // |    |    |                 T2                  |    |
        // |    |----|-------------------------------------|----|
        // |    |    | C1 |                           | C2 |    |
        // |    |    |----|                           |----|    |
        // |    |    |                                     |    |
        // | L1 | L2 |           ChartArea (C0)            | R1 |
        // |    |    |                                     |    |
        // |    |    |----|                           |----|    |
        // |    |    | C3 |                           | C4 |    |
        // |    |----|-------------------------------------|----|
        // |    |    |                 B1                  |    |
        // |----------------------------------------------------|
        // |                  B2 (Full Width)                   |
        // |----------------------------------------------------|
        //
        // What we do to find the best sizing, we do the following
        // 1. Determine the minimum size of the chart area.
        // 2. Split the remaining width equally between each vertical axis
        // 3. Split the remaining height equally between each horizontal axis
        // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
        // 5. Adjust the sizes of each axis based on it's minimum reported size.
        // 6. Refit each axis
        // 7. Position each axis in the final location
        // 8. Tell the chart the final location of the chart area
        // 9. Tell any axes that overlay the chart area the positions of the chart area
        // Step 1

        var chartWidth = width - leftPadding - rightPadding;
        var chartHeight = height - topPadding - bottomPadding;
        var chartAreaWidth = chartWidth / 2; // min 50%
        // Step 2

        var verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length; // Step 3
        // TODO re-limit horizontal axis height (this limit has affected only padding calculation since PR 1837)
        // var horizontalBoxHeight = (height - chartAreaHeight) / horizontalBoxes.length;
        // Step 4

        var maxChartAreaWidth = chartWidth;
        var maxChartAreaHeight = chartHeight;
        var outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        var minBoxSizes = [];
        var maxPadding;

        function getMinimumBoxSize(box) {
          var minSize;
          var isHorizontal = box.isHorizontal();

          if (isHorizontal) {
            minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);
            maxChartAreaHeight -= minSize.height;
          } else {
            minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
            maxChartAreaWidth -= minSize.width;
          }

          minBoxSizes.push({
            horizontal: isHorizontal,
            width: minSize.width,
            box: box
          });
        }

        helpers$1.each(outerBoxes, getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)

        maxPadding = findMaxPadding(outerBoxes); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
        // be if the axes are drawn at their minimum sizes.
        // Steps 5 & 6
        // Function to fit a box

        function fitBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minBox) {
            return minBox.box === box;
          });

          if (minBoxSize) {
            if (minBoxSize.horizontal) {
              var scaleMargin = {
                left: Math.max(outerBoxSizes.left, maxPadding.left),
                right: Math.max(outerBoxSizes.right, maxPadding.right),
                top: 0,
                bottom: 0
              }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
              // on the margin. Sometimes they need to increase in size slightly

              box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
            } else {
              box.update(minBoxSize.width, maxChartAreaHeight);
            }
          }
        } // Update, and calculate the left and right margins for the horizontal boxes


        helpers$1.each(verticalBoxes, fitBox);
        addSizeByPosition(verticalBoxes, outerBoxSizes); // Set the Left and Right margins for the horizontal boxes

        helpers$1.each(horizontalBoxes, fitBox);
        addSizeByPosition(horizontalBoxes, outerBoxSizes);

        function finalFitVerticalBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minSize) {
            return minSize.box === box;
          });
          var scaleMargin = {
            left: 0,
            right: 0,
            top: outerBoxSizes.top,
            bottom: outerBoxSizes.bottom
          };

          if (minBoxSize) {
            box.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);
          }
        } // Let the left layout know the final margin


        helpers$1.each(verticalBoxes, finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)

        outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        addSizeByPosition(outerBoxes, outerBoxSizes); // We may be adding some padding to account for rotated x axis labels

        var leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);
        outerBoxSizes.left += leftPaddingAddition;
        outerBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);
        var topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);
        outerBoxSizes.top += topPaddingAddition;
        outerBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation
        // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
        // without calling `fit` again

        var newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;
        var newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;

        if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
          helpers$1.each(verticalBoxes, function (box) {
            box.height = newMaxChartAreaHeight;
          });
          helpers$1.each(horizontalBoxes, function (box) {
            if (!box.fullWidth) {
              box.width = newMaxChartAreaWidth;
            }
          });
          maxChartAreaHeight = newMaxChartAreaHeight;
          maxChartAreaWidth = newMaxChartAreaWidth;
        } // Step 7 - Position the boxes


        var left = leftPadding + leftPaddingAddition;
        var top = topPadding + topPaddingAddition;

        function placeBox(box) {
          if (box.isHorizontal()) {
            box.left = box.fullWidth ? leftPadding : outerBoxSizes.left;
            box.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;
            box.top = top;
            box.bottom = top + box.height; // Move to next point

            top = box.bottom;
          } else {
            box.left = left;
            box.right = left + box.width;
            box.top = outerBoxSizes.top;
            box.bottom = outerBoxSizes.top + maxChartAreaHeight; // Move to next point

            left = box.right;
          }
        }

        helpers$1.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height

        left += maxChartAreaWidth;
        top += maxChartAreaHeight;
        helpers$1.each(rightBoxes, placeBox);
        helpers$1.each(bottomBoxes, placeBox); // Step 8

        chart.chartArea = {
          left: outerBoxSizes.left,
          top: outerBoxSizes.top,
          right: outerBoxSizes.left + maxChartAreaWidth,
          bottom: outerBoxSizes.top + maxChartAreaHeight
        }; // Step 9

        helpers$1.each(chartAreaBoxes, function (box) {
          box.left = chart.chartArea.left;
          box.top = chart.chartArea.top;
          box.right = chart.chartArea.right;
          box.bottom = chart.chartArea.bottom;
          box.update(maxChartAreaWidth, maxChartAreaHeight);
        });
      }
    };
    /**
     * Platform fallback implementation (minimal).
     * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
     */

    var platform_basic = {
      acquireContext: function (item) {
        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        }

        return item && item.getContext('2d') || null;
      }
    };
    var platform_dom = "/*\n * DOM element rendering detection\n * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index: -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth: 1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop: 0;\n}\n";
    var platform_dom$1 =
    /*#__PURE__*/
    Object.freeze({
      default: platform_dom
    });

    function getCjsExportFromNamespace(n) {
      return n && n.default || n;
    }

    var stylesheet = getCjsExportFromNamespace(platform_dom$1);
    var EXPANDO_KEY = '$chartjs';
    var CSS_PREFIX = 'chartjs-';
    var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';
    var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
    var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
    var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
    /**
     * DOM event types -> Chart.js event types.
     * Note: only events with different types are mapped.
     * @see https://developer.mozilla.org/en-US/docs/Web/Events
     */

    var EVENT_TYPES = {
      touchstart: 'mousedown',
      touchmove: 'mousemove',
      touchend: 'mouseup',
      pointerenter: 'mouseenter',
      pointerdown: 'mousedown',
      pointermove: 'mousemove',
      pointerup: 'mouseup',
      pointerleave: 'mouseout',
      pointerout: 'mouseout'
    };
    /**
     * The "used" size is the final value of a dimension property after all calculations have
     * been performed. This method uses the computed style of `element` but returns undefined
     * if the computed style is not expressed in pixels. That can happen in some cases where
     * `element` has a size relative to its parent and this last one is not yet displayed,
     * for example because of `display: none` on a parent node.
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     * @returns {number} Size in pixels or undefined if unknown.
     */

    function readUsedSize(element, property) {
      var value = helpers$1.getStyle(element, property);
      var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? Number(matches[1]) : undefined;
    }
    /**
     * Initializes the canvas style and render size without modifying the canvas display size,
     * since responsiveness is handled by the controller.resize() method. The config is used
     * to determine the aspect ratio to apply in case no explicit height has been specified.
     */


    function initCanvas(canvas, config) {
      var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
      // returns null or '' if no explicit value has been set to the canvas attribute.

      var renderHeight = canvas.getAttribute('height');
      var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy

      canvas[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      }; // Force canvas to display as block to avoid extra space caused by inline
      // elements, which would interfere with the responsive resize process.
      // https://github.com/chartjs/Chart.js/issues/2538

      style.display = style.display || 'block';

      if (renderWidth === null || renderWidth === '') {
        var displayWidth = readUsedSize(canvas, 'width');

        if (displayWidth !== undefined) {
          canvas.width = displayWidth;
        }
      }

      if (renderHeight === null || renderHeight === '') {
        if (canvas.style.height === '') {
          // If no explicit render height and style height, let's apply the aspect ratio,
          // which one can be specified by the user but also by charts as default option
          // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
          canvas.height = canvas.width / (config.options.aspectRatio || 2);
        } else {
          var displayHeight = readUsedSize(canvas, 'height');

          if (displayWidth !== undefined) {
            canvas.height = displayHeight;
          }
        }
      }

      return canvas;
    }
    /**
     * Detects support for options object argument in addEventListener.
     * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
     * @private
     */


    var supportsEventListenerOptions = function () {
      var supports = false;

      try {
        var options = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line getter-return
          get: function () {
            supports = true;
          }
        });
        window.addEventListener('e', null, options);
      } catch (e) {// continue regardless of error
      }

      return supports;
    }(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
    // https://github.com/chartjs/Chart.js/issues/4287


    var eventListenerOptions = supportsEventListenerOptions ? {
      passive: true
    } : false;

    function addListener(node, type, listener) {
      node.addEventListener(type, listener, eventListenerOptions);
    }

    function removeListener(node, type, listener) {
      node.removeEventListener(type, listener, eventListenerOptions);
    }

    function createEvent(type, chart, x, y, nativeEvent) {
      return {
        type: type,
        chart: chart,
        native: nativeEvent || null,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
      };
    }

    function fromNativeEvent(event, chart) {
      var type = EVENT_TYPES[event.type] || event.type;
      var pos = helpers$1.getRelativePosition(event, chart);
      return createEvent(type, chart, pos.x, pos.y, event);
    }

    function throttled(fn, thisArg) {
      var ticking = false;
      var args = [];
      return function () {
        args = Array.prototype.slice.call(arguments);
        thisArg = thisArg || this;

        if (!ticking) {
          ticking = true;
          helpers$1.requestAnimFrame.call(window, function () {
            ticking = false;
            fn.apply(thisArg, args);
          });
        }
      };
    }

    function createDiv(cls) {
      var el = document.createElement('div');
      el.className = cls || '';
      return el;
    } // Implementation based on https://github.com/marcj/css-element-queries


    function createResizer(handler) {
      var maxSize = 1000000; // NOTE(SB) Don't use innerHTML because it could be considered unsafe.
      // https://github.com/chartjs/Chart.js/issues/5902

      var resizer = createDiv(CSS_SIZE_MONITOR);
      var expand = createDiv(CSS_SIZE_MONITOR + '-expand');
      var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');
      expand.appendChild(createDiv());
      shrink.appendChild(createDiv());
      resizer.appendChild(expand);
      resizer.appendChild(shrink);

      resizer._reset = function () {
        expand.scrollLeft = maxSize;
        expand.scrollTop = maxSize;
        shrink.scrollLeft = maxSize;
        shrink.scrollTop = maxSize;
      };

      var onScroll = function () {
        resizer._reset();

        handler();
      };

      addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
      addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
      return resizer;
    } // https://davidwalsh.name/detect-node-insertion


    function watchForRender(node, handler) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

      var proxy = expando.renderProxy = function (e) {
        if (e.animationName === CSS_RENDER_ANIMATION) {
          handler();
        }
      };

      helpers$1.each(ANIMATION_START_EVENTS, function (type) {
        addListener(node, type, proxy);
      }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
      // is removed then added back immediately (same animation frame?). Accessing the
      // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
      // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
      // https://github.com/chartjs/Chart.js/issues/4737

      expando.reflow = !!node.offsetParent;
      node.classList.add(CSS_RENDER_MONITOR);
    }

    function unwatchForRender(node) {
      var expando = node[EXPANDO_KEY] || {};
      var proxy = expando.renderProxy;

      if (proxy) {
        helpers$1.each(ANIMATION_START_EVENTS, function (type) {
          removeListener(node, type, proxy);
        });
        delete expando.renderProxy;
      }

      node.classList.remove(CSS_RENDER_MONITOR);
    }

    function addResizeListener(node, listener, chart) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.

      var resizer = expando.resizer = createResizer(throttled(function () {
        if (expando.resizer) {
          var container = chart.options.maintainAspectRatio && node.parentNode;
          var w = container ? container.clientWidth : 0;
          listener(createEvent('resize', chart));

          if (container && container.clientWidth < w && chart.canvas) {
            // If the container size shrank during chart resize, let's assume
            // scrollbar appeared. So we resize again with the scrollbar visible -
            // effectively making chart smaller and the scrollbar hidden again.
            // Because we are inside `throttled`, and currently `ticking`, scroll
            // events are ignored during this whole 2 resize process.
            // If we assumed wrong and something else happened, we are resizing
            // twice in a frame (potential performance issue)
            listener(createEvent('resize', chart));
          }
        }
      })); // The resizer needs to be attached to the node parent, so we first need to be
      // sure that `node` is attached to the DOM before injecting the resizer element.

      watchForRender(node, function () {
        if (expando.resizer) {
          var container = node.parentNode;

          if (container && container !== resizer.parentNode) {
            container.insertBefore(resizer, container.firstChild);
          } // The container size might have changed, let's reset the resizer state.


          resizer._reset();
        }
      });
    }

    function removeResizeListener(node) {
      var expando = node[EXPANDO_KEY] || {};
      var resizer = expando.resizer;
      delete expando.resizer;
      unwatchForRender(node);

      if (resizer && resizer.parentNode) {
        resizer.parentNode.removeChild(resizer);
      }
    }

    function injectCSS(platform, css) {
      // https://stackoverflow.com/q/3922139
      var style = platform._style || document.createElement('style');

      if (!platform._style) {
        platform._style = style;
        css = '/* Chart.js */\n' + css;
        style.setAttribute('type', 'text/css');
        document.getElementsByTagName('head')[0].appendChild(style);
      }

      style.appendChild(document.createTextNode(css));
    }

    var platform_dom$2 = {
      /**
       * When `true`, prevents the automatic injection of the stylesheet required to
       * correctly detect when the chart is added to the DOM and then resized. This
       * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
       * to be manually imported to make this library compatible with any CSP.
       * See https://github.com/chartjs/Chart.js/issues/5208
       */
      disableCSSInjection: false,

      /**
       * This property holds whether this platform is enabled for the current environment.
       * Currently used by platform.js to select the proper implementation.
       * @private
       */
      _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

      /**
       * @private
       */
      _ensureLoaded: function () {
        if (this._loaded) {
          return;
        }

        this._loaded = true; // https://github.com/chartjs/Chart.js/issues/5208

        if (!this.disableCSSInjection) {
          injectCSS(this, stylesheet);
        }
      },
      acquireContext: function (item, config) {
        if (typeof item === 'string') {
          item = document.getElementById(item);
        } else if (item.length) {
          // Support for array based queries (such as jQuery)
          item = item[0];
        }

        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        } // To prevent canvas fingerprinting, some add-ons undefine the getContext
        // method, for example: https://github.com/kkapsner/CanvasBlocker
        // https://github.com/chartjs/Chart.js/issues/2807


        var context = item && item.getContext && item.getContext('2d'); // Load platform resources on first chart creation, to make possible to change
        // platform options after importing the library (e.g. `disableCSSInjection`).

        this._ensureLoaded(); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
        // inside an iframe or when running in a protected environment. We could guess the
        // types from their toString() value but let's keep things flexible and assume it's
        // a sufficient condition if the item has a context2D which has item as `canvas`.
        // https://github.com/chartjs/Chart.js/issues/3887
        // https://github.com/chartjs/Chart.js/issues/4102
        // https://github.com/chartjs/Chart.js/issues/4152


        if (context && context.canvas === item) {
          initCanvas(item, config);
          return context;
        }

        return null;
      },
      releaseContext: function (context) {
        var canvas = context.canvas;

        if (!canvas[EXPANDO_KEY]) {
          return;
        }

        var initial = canvas[EXPANDO_KEY].initial;
        ['height', 'width'].forEach(function (prop) {
          var value = initial[prop];

          if (helpers$1.isNullOrUndef(value)) {
            canvas.removeAttribute(prop);
          } else {
            canvas.setAttribute(prop, value);
          }
        });
        helpers$1.each(initial.style || {}, function (value, key) {
          canvas.style[key] = value;
        }); // The canvas render size might have been changed (and thus the state stack discarded),
        // we can't use save() and restore() to restore the initial state. So make sure that at
        // least the canvas context is reset to the default state by setting the canvas width.
        // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
        // eslint-disable-next-line no-self-assign

        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
      },
      addEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          addResizeListener(canvas, listener, chart);
          return;
        }

        var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
        var proxies = expando.proxies || (expando.proxies = {});

        var proxy = proxies[chart.id + '_' + type] = function (event) {
          listener(fromNativeEvent(event, chart));
        };

        addListener(canvas, type, proxy);
      },
      removeEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          removeResizeListener(canvas);
          return;
        }

        var expando = listener[EXPANDO_KEY] || {};
        var proxies = expando.proxies || {};
        var proxy = proxies[chart.id + '_' + type];

        if (!proxy) {
          return;
        }

        removeListener(canvas, type, proxy);
      }
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use EventTarget.addEventListener instead.
     * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     * @function Chart.helpers.addEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.addEvent = addListener;
    /**
     * Provided for backward compatibility, use EventTarget.removeEventListener instead.
     * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
     * @function Chart.helpers.removeEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.removeEvent = removeListener; // @TODO Make possible to select another platform at build time.

    var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
    /**
     * @namespace Chart.platform
     * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
     * @since 2.4.0
     */

    var platform = helpers$1.extend({
      /**
       * @since 2.7.0
       */
      initialize: function () {},

      /**
       * Called at chart construction time, returns a context2d instance implementing
       * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
       * @param {*} item - The native item from which to acquire context (platform specific)
       * @param {object} options - The chart options
       * @returns {CanvasRenderingContext2D} context2d instance
       */
      acquireContext: function () {},

      /**
       * Called at chart destruction time, releases any resources associated to the context
       * previously returned by the acquireContext() method.
       * @param {CanvasRenderingContext2D} context - The context2d instance
       * @returns {boolean} true if the method succeeded, else false
       */
      releaseContext: function () {},

      /**
       * Registers the specified listener on the given chart.
       * @param {Chart} chart - Chart from which to listen for event
       * @param {string} type - The ({@link IEvent}) type to listen for
       * @param {function} listener - Receives a notification (an object that implements
       * the {@link IEvent} interface) when an event of the specified type occurs.
       */
      addEventListener: function () {},

      /**
       * Removes the specified listener previously registered with addEventListener.
       * @param {Chart} chart - Chart from which to remove the listener
       * @param {string} type - The ({@link IEvent}) type to remove
       * @param {function} listener - The listener function to remove from the event target.
       */
      removeEventListener: function () {}
    }, implementation);

    core_defaults._set('global', {
      plugins: {}
    });
    /**
     * The plugin service singleton
     * @namespace Chart.plugins
     * @since 2.1.0
     */


    var core_plugins = {
      /**
       * Globally registered plugins.
       * @private
       */
      _plugins: [],

      /**
       * This identifier is used to invalidate the descriptors cache attached to each chart
       * when a global plugin is registered or unregistered. In this case, the cache ID is
       * incremented and descriptors are regenerated during following API calls.
       * @private
       */
      _cacheId: 0,

      /**
       * Registers the given plugin(s) if not already registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      register: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          if (p.indexOf(plugin) === -1) {
            p.push(plugin);
          }
        });
        this._cacheId++;
      },

      /**
       * Unregisters the given plugin(s) only if registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      unregister: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          var idx = p.indexOf(plugin);

          if (idx !== -1) {
            p.splice(idx, 1);
          }
        });
        this._cacheId++;
      },

      /**
       * Remove all registered plugins.
       * @since 2.1.5
       */
      clear: function () {
        this._plugins = [];
        this._cacheId++;
      },

      /**
       * Returns the number of registered plugins?
       * @returns {number}
       * @since 2.1.5
       */
      count: function () {
        return this._plugins.length;
      },

      /**
       * Returns all registered plugin instances.
       * @returns {IPlugin[]} array of plugin objects.
       * @since 2.1.5
       */
      getAll: function () {
        return this._plugins;
      },

      /**
       * Calls enabled plugins for `chart` on the specified hook and with the given args.
       * This method immediately returns as soon as a plugin explicitly returns false. The
       * returned value can be used, for instance, to interrupt the current action.
       * @param {Chart} chart - The chart instance for which plugins should be called.
       * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
       * @param {Array} [args] - Extra arguments to apply to the hook call.
       * @returns {boolean} false if any of the plugins return false, else returns true.
       */
      notify: function (chart, hook, args) {
        var descriptors = this.descriptors(chart);
        var ilen = descriptors.length;
        var i, descriptor, plugin, params, method;

        for (i = 0; i < ilen; ++i) {
          descriptor = descriptors[i];
          plugin = descriptor.plugin;
          method = plugin[hook];

          if (typeof method === 'function') {
            params = [chart].concat(args || []);
            params.push(descriptor.options);

            if (method.apply(plugin, params) === false) {
              return false;
            }
          }
        }

        return true;
      },

      /**
       * Returns descriptors of enabled plugins for the given chart.
       * @returns {object[]} [{ plugin, options }]
       * @private
       */
      descriptors: function (chart) {
        var cache = chart.$plugins || (chart.$plugins = {});

        if (cache.id === this._cacheId) {
          return cache.descriptors;
        }

        var plugins = [];
        var descriptors = [];
        var config = chart && chart.config || {};
        var options = config.options && config.options.plugins || {};

        this._plugins.concat(config.plugins || []).forEach(function (plugin) {
          var idx = plugins.indexOf(plugin);

          if (idx !== -1) {
            return;
          }

          var id = plugin.id;
          var opts = options[id];

          if (opts === false) {
            return;
          }

          if (opts === true) {
            opts = helpers$1.clone(core_defaults.global.plugins[id]);
          }

          plugins.push(plugin);
          descriptors.push({
            plugin: plugin,
            options: opts || {}
          });
        });

        cache.descriptors = descriptors;
        cache.id = this._cacheId;
        return descriptors;
      },

      /**
       * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
       * but in some cases, this reference can be changed by the user when updating options.
       * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
       * @private
       */
      _invalidate: function (chart) {
        delete chart.$plugins;
      }
    };
    var core_scaleService = {
      // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
      // use the new chart options to grab the correct scale
      constructors: {},
      // Use a registration function so that we can move to an ES6 map when we no longer need to support
      // old browsers
      // Scale config defaults
      defaults: {},
      registerScaleType: function (type, scaleConstructor, scaleDefaults) {
        this.constructors[type] = scaleConstructor;
        this.defaults[type] = helpers$1.clone(scaleDefaults);
      },
      getScaleConstructor: function (type) {
        return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
      },
      getScaleDefaults: function (type) {
        // Return the scale defaults merged with the global settings so that we always use the latest ones
        return this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};
      },
      updateScaleDefaults: function (type, additions) {
        var me = this;

        if (me.defaults.hasOwnProperty(type)) {
          me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
        }
      },
      addScalesToLayout: function (chart) {
        // Adds each scale to the chart.boxes array to be sized accordingly
        helpers$1.each(chart.scales, function (scale) {
          // Set ILayoutItem parameters for backwards compatibility
          scale.fullWidth = scale.options.fullWidth;
          scale.position = scale.options.position;
          scale.weight = scale.options.weight;
          core_layouts.addBox(chart, scale);
        });
      }
    };
    var valueOrDefault$7 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      tooltips: {
        enabled: true,
        custom: null,
        mode: 'nearest',
        position: 'average',
        intersect: true,
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleFontStyle: 'bold',
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleFontColor: '#fff',
        titleAlign: 'left',
        bodySpacing: 2,
        bodyFontColor: '#fff',
        bodyAlign: 'left',
        footerFontStyle: 'bold',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFontColor: '#fff',
        footerAlign: 'left',
        yPadding: 6,
        xPadding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        multiKeyBackground: '#fff',
        displayColors: true,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        callbacks: {
          // Args are: (tooltipItems, data)
          beforeTitle: helpers$1.noop,
          title: function (tooltipItems, data) {
            var title = '';
            var labels = data.labels;
            var labelCount = labels ? labels.length : 0;

            if (tooltipItems.length > 0) {
              var item = tooltipItems[0];

              if (item.label) {
                title = item.label;
              } else if (item.xLabel) {
                title = item.xLabel;
              } else if (labelCount > 0 && item.index < labelCount) {
                title = labels[item.index];
              }
            }

            return title;
          },
          afterTitle: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeBody: helpers$1.noop,
          // Args are: (tooltipItem, data)
          beforeLabel: helpers$1.noop,
          label: function (tooltipItem, data) {
            var label = data.datasets[tooltipItem.datasetIndex].label || '';

            if (label) {
              label += ': ';
            }

            if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
              label += tooltipItem.value;
            } else {
              label += tooltipItem.yLabel;
            }

            return label;
          },
          labelColor: function (tooltipItem, chart) {
            var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
            var activeElement = meta.data[tooltipItem.index];
            var view = activeElement._view;
            return {
              borderColor: view.borderColor,
              backgroundColor: view.backgroundColor
            };
          },
          labelTextColor: function () {
            return this._options.bodyFontColor;
          },
          afterLabel: helpers$1.noop,
          // Args are: (tooltipItems, data)
          afterBody: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeFooter: helpers$1.noop,
          footer: helpers$1.noop,
          afterFooter: helpers$1.noop
        }
      }
    });

    var positioners = {
      /**
       * Average mode places the tooltip at the average position of the elements shown
       * @function Chart.Tooltip.positioners.average
       * @param elements {ChartElement[]} the elements being displayed in the tooltip
       * @returns {object} tooltip position
       */
      average: function (elements) {
        if (!elements.length) {
          return false;
        }

        var i, len;
        var x = 0;
        var y = 0;
        var count = 0;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var pos = el.tooltipPosition();
            x += pos.x;
            y += pos.y;
            ++count;
          }
        }

        return {
          x: x / count,
          y: y / count
        };
      },

      /**
       * Gets the tooltip position nearest of the item nearest to the event position
       * @function Chart.Tooltip.positioners.nearest
       * @param elements {Chart.Element[]} the tooltip elements
       * @param eventPosition {object} the position of the event in canvas coordinates
       * @returns {object} the tooltip position
       */
      nearest: function (elements, eventPosition) {
        var x = eventPosition.x;
        var y = eventPosition.y;
        var minDistance = Number.POSITIVE_INFINITY;
        var i, len, nearestElement;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var center = el.getCenterPoint();
            var d = helpers$1.distanceBetweenPoints(eventPosition, center);

            if (d < minDistance) {
              minDistance = d;
              nearestElement = el;
            }
          }
        }

        if (nearestElement) {
          var tp = nearestElement.tooltipPosition();
          x = tp.x;
          y = tp.y;
        }

        return {
          x: x,
          y: y
        };
      }
    }; // Helper to push or concat based on if the 2nd parameter is an array or not

    function pushOrConcat(base, toPush) {
      if (toPush) {
        if (helpers$1.isArray(toPush)) {
          // base = base.concat(toPush);
          Array.prototype.push.apply(base, toPush);
        } else {
          base.push(toPush);
        }
      }

      return base;
    }
    /**
     * Returns array of strings split by newline
     * @param {string} value - The value to split by newline.
     * @returns {string[]} value if newline present - Returned from String split() method
     * @function
     */


    function splitNewlines(str) {
      if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
        return str.split('\n');
      }

      return str;
    }
    /**
     * Private helper to create a tooltip item model
     * @param element - the chart element (point, arc, bar) to create the tooltip item for
     * @return new tooltip item
     */


    function createTooltipItem(element) {
      var xScale = element._xScale;
      var yScale = element._yScale || element._scale; // handle radar || polarArea charts

      var index = element._index;
      var datasetIndex = element._datasetIndex;

      var controller = element._chart.getDatasetMeta(datasetIndex).controller;

      var indexScale = controller._getIndexScale();

      var valueScale = controller._getValueScale();

      return {
        xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
        yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
        label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',
        value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',
        index: index,
        datasetIndex: datasetIndex,
        x: element._model.x,
        y: element._model.y
      };
    }
    /**
     * Helper to get the reset model for the tooltip
     * @param tooltipOpts {object} the tooltip options
     */


    function getBaseModel(tooltipOpts) {
      var globalDefaults = core_defaults.global;
      return {
        // Positioning
        xPadding: tooltipOpts.xPadding,
        yPadding: tooltipOpts.yPadding,
        xAlign: tooltipOpts.xAlign,
        yAlign: tooltipOpts.yAlign,
        // Body
        bodyFontColor: tooltipOpts.bodyFontColor,
        _bodyFontFamily: valueOrDefault$7(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
        _bodyFontStyle: valueOrDefault$7(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
        _bodyAlign: tooltipOpts.bodyAlign,
        bodyFontSize: valueOrDefault$7(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
        bodySpacing: tooltipOpts.bodySpacing,
        // Title
        titleFontColor: tooltipOpts.titleFontColor,
        _titleFontFamily: valueOrDefault$7(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
        _titleFontStyle: valueOrDefault$7(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
        titleFontSize: valueOrDefault$7(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
        _titleAlign: tooltipOpts.titleAlign,
        titleSpacing: tooltipOpts.titleSpacing,
        titleMarginBottom: tooltipOpts.titleMarginBottom,
        // Footer
        footerFontColor: tooltipOpts.footerFontColor,
        _footerFontFamily: valueOrDefault$7(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
        _footerFontStyle: valueOrDefault$7(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
        footerFontSize: valueOrDefault$7(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
        _footerAlign: tooltipOpts.footerAlign,
        footerSpacing: tooltipOpts.footerSpacing,
        footerMarginTop: tooltipOpts.footerMarginTop,
        // Appearance
        caretSize: tooltipOpts.caretSize,
        cornerRadius: tooltipOpts.cornerRadius,
        backgroundColor: tooltipOpts.backgroundColor,
        opacity: 0,
        legendColorBackground: tooltipOpts.multiKeyBackground,
        displayColors: tooltipOpts.displayColors,
        borderColor: tooltipOpts.borderColor,
        borderWidth: tooltipOpts.borderWidth
      };
    }
    /**
     * Get the size of the tooltip
     */


    function getTooltipSize(tooltip, model) {
      var ctx = tooltip._chart.ctx;
      var height = model.yPadding * 2; // Tooltip Padding

      var width = 0; // Count of all lines in the body

      var body = model.body;
      var combinedBodyLength = body.reduce(function (count, bodyItem) {
        return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
      }, 0);
      combinedBodyLength += model.beforeBody.length + model.afterBody.length;
      var titleLineCount = model.title.length;
      var footerLineCount = model.footer.length;
      var titleFontSize = model.titleFontSize;
      var bodyFontSize = model.bodyFontSize;
      var footerFontSize = model.footerFontSize;
      height += titleLineCount * titleFontSize; // Title Lines

      height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing

      height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin

      height += combinedBodyLength * bodyFontSize; // Body Lines

      height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing

      height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin

      height += footerLineCount * footerFontSize; // Footer Lines

      height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
      // Title width

      var widthPadding = 0;

      var maxLineWidth = function (line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };

      ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
      helpers$1.each(model.title, maxLineWidth); // Body width

      ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
      helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box

      widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
      helpers$1.each(body, function (bodyItem) {
        helpers$1.each(bodyItem.before, maxLineWidth);
        helpers$1.each(bodyItem.lines, maxLineWidth);
        helpers$1.each(bodyItem.after, maxLineWidth);
      }); // Reset back to 0

      widthPadding = 0; // Footer width

      ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
      helpers$1.each(model.footer, maxLineWidth); // Add padding

      width += 2 * model.xPadding;
      return {
        width: width,
        height: height
      };
    }
    /**
     * Helper to get the alignment of a tooltip given the size
     */


    function determineAlignment(tooltip, size) {
      var model = tooltip._model;
      var chart = tooltip._chart;
      var chartArea = tooltip._chart.chartArea;
      var xAlign = 'center';
      var yAlign = 'center';

      if (model.y < size.height) {
        yAlign = 'top';
      } else if (model.y > chart.height - size.height) {
        yAlign = 'bottom';
      }

      var lf, rf; // functions to determine left, right alignment

      var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart

      var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges

      var midX = (chartArea.left + chartArea.right) / 2;
      var midY = (chartArea.top + chartArea.bottom) / 2;

      if (yAlign === 'center') {
        lf = function (x) {
          return x <= midX;
        };

        rf = function (x) {
          return x > midX;
        };
      } else {
        lf = function (x) {
          return x <= size.width / 2;
        };

        rf = function (x) {
          return x >= chart.width - size.width / 2;
        };
      }

      olf = function (x) {
        return x + size.width + model.caretSize + model.caretPadding > chart.width;
      };

      orf = function (x) {
        return x - size.width - model.caretSize - model.caretPadding < 0;
      };

      yf = function (y) {
        return y <= midY ? 'top' : 'bottom';
      };

      if (lf(model.x)) {
        xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?

        if (olf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      } else if (rf(model.x)) {
        xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?

        if (orf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      }

      var opts = tooltip._options;
      return {
        xAlign: opts.xAlign ? opts.xAlign : xAlign,
        yAlign: opts.yAlign ? opts.yAlign : yAlign
      };
    }
    /**
     * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
     */


    function getBackgroundPoint(vm, size, alignment, chart) {
      // Background Position
      var x = vm.x;
      var y = vm.y;
      var caretSize = vm.caretSize;
      var caretPadding = vm.caretPadding;
      var cornerRadius = vm.cornerRadius;
      var xAlign = alignment.xAlign;
      var yAlign = alignment.yAlign;
      var paddingAndSize = caretSize + caretPadding;
      var radiusAndPadding = cornerRadius + caretPadding;

      if (xAlign === 'right') {
        x -= size.width;
      } else if (xAlign === 'center') {
        x -= size.width / 2;

        if (x + size.width > chart.width) {
          x = chart.width - size.width;
        }

        if (x < 0) {
          x = 0;
        }
      }

      if (yAlign === 'top') {
        y += paddingAndSize;
      } else if (yAlign === 'bottom') {
        y -= size.height + paddingAndSize;
      } else {
        y -= size.height / 2;
      }

      if (yAlign === 'center') {
        if (xAlign === 'left') {
          x += paddingAndSize;
        } else if (xAlign === 'right') {
          x -= paddingAndSize;
        }
      } else if (xAlign === 'left') {
        x -= radiusAndPadding;
      } else if (xAlign === 'right') {
        x += radiusAndPadding;
      }

      return {
        x: x,
        y: y
      };
    }

    function getAlignedX(vm, align) {
      return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
    }
    /**
     * Helper to build before and after body lines
     */


    function getBeforeAfterBodyLines(callback) {
      return pushOrConcat([], splitNewlines(callback));
    }

    var exports$3 = core_element.extend({
      initialize: function () {
        this._model = getBaseModel(this._options);
        this._lastActive = [];
      },
      // Get the title
      // Args are: (tooltipItem, data)
      getTitle: function () {
        var me = this;
        var opts = me._options;
        var callbacks = opts.callbacks;
        var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
        var title = callbacks.title.apply(me, arguments);
        var afterTitle = callbacks.afterTitle.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
      },
      // Args are: (tooltipItem, data)
      getBeforeBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
      },
      // Args are: (tooltipItem, data)
      getBody: function (tooltipItems, data) {
        var me = this;
        var callbacks = me._options.callbacks;
        var bodyItems = [];
        helpers$1.each(tooltipItems, function (tooltipItem) {
          var bodyItem = {
            before: [],
            lines: [],
            after: []
          };
          pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
          pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
          pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
          bodyItems.push(bodyItem);
        });
        return bodyItems;
      },
      // Args are: (tooltipItem, data)
      getAfterBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
      },
      // Get the footer and beforeFooter and afterFooter lines
      // Args are: (tooltipItem, data)
      getFooter: function () {
        var me = this;
        var callbacks = me._options.callbacks;
        var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
        var footer = callbacks.footer.apply(me, arguments);
        var afterFooter = callbacks.afterFooter.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
      },
      update: function (changed) {
        var me = this;
        var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
        // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
        // which breaks any animations.

        var existingModel = me._model;
        var model = me._model = getBaseModel(opts);
        var active = me._active;
        var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations

        var alignment = {
          xAlign: existingModel.xAlign,
          yAlign: existingModel.yAlign
        };
        var backgroundPoint = {
          x: existingModel.x,
          y: existingModel.y
        };
        var tooltipSize = {
          width: existingModel.width,
          height: existingModel.height
        };
        var tooltipPosition = {
          x: existingModel.caretX,
          y: existingModel.caretY
        };
        var i, len;

        if (active.length) {
          model.opacity = 1;
          var labelColors = [];
          var labelTextColors = [];
          tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
          var tooltipItems = [];

          for (i = 0, len = active.length; i < len; ++i) {
            tooltipItems.push(createTooltipItem(active[i]));
          } // If the user provided a filter function, use it to modify the tooltip items


          if (opts.filter) {
            tooltipItems = tooltipItems.filter(function (a) {
              return opts.filter(a, data);
            });
          } // If the user provided a sorting function, use it to modify the tooltip items


          if (opts.itemSort) {
            tooltipItems = tooltipItems.sort(function (a, b) {
              return opts.itemSort(a, b, data);
            });
          } // Determine colors for boxes


          helpers$1.each(tooltipItems, function (tooltipItem) {
            labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
            labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
          }); // Build the Text Lines

          model.title = me.getTitle(tooltipItems, data);
          model.beforeBody = me.getBeforeBody(tooltipItems, data);
          model.body = me.getBody(tooltipItems, data);
          model.afterBody = me.getAfterBody(tooltipItems, data);
          model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors

          model.x = tooltipPosition.x;
          model.y = tooltipPosition.y;
          model.caretPadding = opts.caretPadding;
          model.labelColors = labelColors;
          model.labelTextColors = labelTextColors; // data points

          model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip

          tooltipSize = getTooltipSize(this, model);
          alignment = determineAlignment(this, tooltipSize); // Final Size and Position

          backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
        } else {
          model.opacity = 0;
        }

        model.xAlign = alignment.xAlign;
        model.yAlign = alignment.yAlign;
        model.x = backgroundPoint.x;
        model.y = backgroundPoint.y;
        model.width = tooltipSize.width;
        model.height = tooltipSize.height; // Point where the caret on the tooltip points to

        model.caretX = tooltipPosition.x;
        model.caretY = tooltipPosition.y;
        me._model = model;

        if (changed && opts.custom) {
          opts.custom.call(me, model);
        }

        return me;
      },
      drawCaret: function (tooltipPoint, size) {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
      },
      getCaretPosition: function (tooltipPoint, size, vm) {
        var x1, x2, x3, y1, y2, y3;
        var caretSize = vm.caretSize;
        var cornerRadius = vm.cornerRadius;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var ptX = tooltipPoint.x;
        var ptY = tooltipPoint.y;
        var width = size.width;
        var height = size.height;

        if (yAlign === 'center') {
          y2 = ptY + height / 2;

          if (xAlign === 'left') {
            x1 = ptX;
            x2 = x1 - caretSize;
            x3 = x1;
            y1 = y2 + caretSize;
            y3 = y2 - caretSize;
          } else {
            x1 = ptX + width;
            x2 = x1 + caretSize;
            x3 = x1;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize;
          }
        } else {
          if (xAlign === 'left') {
            x2 = ptX + cornerRadius + caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else if (xAlign === 'right') {
            x2 = ptX + width - cornerRadius - caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else {
            x2 = vm.caretX;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          }

          if (yAlign === 'top') {
            y1 = ptY;
            y2 = y1 - caretSize;
            y3 = y1;
          } else {
            y1 = ptY + height;
            y2 = y1 + caretSize;
            y3 = y1; // invert drawing order

            var tmp = x3;
            x3 = x1;
            x1 = tmp;
          }
        }

        return {
          x1: x1,
          x2: x2,
          x3: x3,
          y1: y1,
          y2: y2,
          y3: y3
        };
      },
      drawTitle: function (pt, vm, ctx) {
        var title = vm.title;

        if (title.length) {
          pt.x = getAlignedX(vm, vm._titleAlign);
          ctx.textAlign = vm._titleAlign;
          ctx.textBaseline = 'top';
          var titleFontSize = vm.titleFontSize;
          var titleSpacing = vm.titleSpacing;
          ctx.fillStyle = vm.titleFontColor;
          ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
          var i, len;

          for (i = 0, len = title.length; i < len; ++i) {
            ctx.fillText(title[i], pt.x, pt.y);
            pt.y += titleFontSize + titleSpacing; // Line Height and spacing

            if (i + 1 === title.length) {
              pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
            }
          }
        }
      },
      drawBody: function (pt, vm, ctx) {
        var bodyFontSize = vm.bodyFontSize;
        var bodySpacing = vm.bodySpacing;
        var bodyAlign = vm._bodyAlign;
        var body = vm.body;
        var drawColorBoxes = vm.displayColors;
        var labelColors = vm.labelColors;
        var xLinePadding = 0;
        var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;
        var textColor;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'top';
        ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
        pt.x = getAlignedX(vm, bodyAlign); // Before Body

        var fillLineOfText = function (line) {
          ctx.fillText(line, pt.x + xLinePadding, pt.y);
          pt.y += bodyFontSize + bodySpacing;
        }; // Before body lines


        ctx.fillStyle = vm.bodyFontColor;
        helpers$1.each(vm.beforeBody, fillLineOfText);
        xLinePadding = drawColorBoxes && bodyAlign !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0; // Draw body lines now

        helpers$1.each(body, function (bodyItem, i) {
          textColor = vm.labelTextColors[i];
          ctx.fillStyle = textColor;
          helpers$1.each(bodyItem.before, fillLineOfText);
          helpers$1.each(bodyItem.lines, function (line) {
            // Draw Legend-like boxes if needed
            if (drawColorBoxes) {
              // Fill a white rect so that colours merge nicely if the opacity is < 1
              ctx.fillStyle = vm.legendColorBackground;
              ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Border

              ctx.lineWidth = 1;
              ctx.strokeStyle = labelColors[i].borderColor;
              ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Inner square

              ctx.fillStyle = labelColors[i].backgroundColor;
              ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
              ctx.fillStyle = textColor;
            }

            fillLineOfText(line);
          });
          helpers$1.each(bodyItem.after, fillLineOfText);
        }); // Reset back to 0 for after body

        xLinePadding = 0; // After body lines

        helpers$1.each(vm.afterBody, fillLineOfText);
        pt.y -= bodySpacing; // Remove last body spacing
      },
      drawFooter: function (pt, vm, ctx) {
        var footer = vm.footer;

        if (footer.length) {
          pt.x = getAlignedX(vm, vm._footerAlign);
          pt.y += vm.footerMarginTop;
          ctx.textAlign = vm._footerAlign;
          ctx.textBaseline = 'top';
          ctx.fillStyle = vm.footerFontColor;
          ctx.font = helpers$1.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
          helpers$1.each(footer, function (line) {
            ctx.fillText(line, pt.x, pt.y);
            pt.y += vm.footerFontSize + vm.footerSpacing;
          });
        }
      },
      drawBackground: function (pt, vm, ctx, tooltipSize) {
        ctx.fillStyle = vm.backgroundColor;
        ctx.strokeStyle = vm.borderColor;
        ctx.lineWidth = vm.borderWidth;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var x = pt.x;
        var y = pt.y;
        var width = tooltipSize.width;
        var height = tooltipSize.height;
        var radius = vm.cornerRadius;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);

        if (yAlign === 'top') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);

        if (yAlign === 'center' && xAlign === 'right') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);

        if (yAlign === 'bottom') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);

        if (yAlign === 'center' && xAlign === 'left') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();

        if (vm.borderWidth > 0) {
          ctx.stroke();
        }
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;

        if (vm.opacity === 0) {
          return;
        }

        var tooltipSize = {
          width: vm.width,
          height: vm.height
        };
        var pt = {
          x: vm.x,
          y: vm.y
        }; // IE11/Edge does not like very small opacities, so snap to 0

        var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip

        var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

        if (this._options.enabled && hasTooltipContent) {
          ctx.save();
          ctx.globalAlpha = opacity; // Draw Background

          this.drawBackground(pt, vm, ctx, tooltipSize); // Draw Title, Body, and Footer

          pt.y += vm.yPadding; // Titles

          this.drawTitle(pt, vm, ctx); // Body

          this.drawBody(pt, vm, ctx); // Footer

          this.drawFooter(pt, vm, ctx);
          ctx.restore();
        }
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       * @returns {boolean} true if the tooltip changed
       */
      handleEvent: function (e) {
        var me = this;
        var options = me._options;
        var changed = false;
        me._lastActive = me._lastActive || []; // Find Active Elements for tooltips

        if (e.type === 'mouseout') {
          me._active = [];
        } else {
          me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
        } // Remember Last Actives


        changed = !helpers$1.arrayEquals(me._active, me._lastActive); // Only handle target event on tooltip change

        if (changed) {
          me._lastActive = me._active;

          if (options.enabled || options.custom) {
            me._eventPosition = {
              x: e.x,
              y: e.y
            };
            me.update(true);
            me.pivot();
          }
        }

        return changed;
      }
    });
    /**
     * @namespace Chart.Tooltip.positioners
     */

    var positioners_1 = positioners;
    var core_tooltip = exports$3;
    core_tooltip.positioners = positioners_1;
    var valueOrDefault$8 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      elements: {},
      events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
      hover: {
        onHover: null,
        mode: 'nearest',
        intersect: true,
        animationDuration: 400
      },
      onClick: null,
      maintainAspectRatio: true,
      responsive: true,
      responsiveAnimationDuration: 0
    });
    /**
     * Recursively merge the given config objects representing the `scales` option
     * by incorporating scale defaults in `xAxes` and `yAxes` array items, then
     * returns a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeScaleConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          if (key === 'xAxes' || key === 'yAxes') {
            var slen = source[key].length;
            var i, type, scale;

            if (!target[key]) {
              target[key] = [];
            }

            for (i = 0; i < slen; ++i) {
              scale = source[key][i];
              type = valueOrDefault$8(scale.type, key === 'xAxes' ? 'category' : 'linear');

              if (i >= target[key].length) {
                target[key].push({});
              }

              if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
                // new/untyped scale or type changed: let's apply the new defaults
                // then merge source scale to correctly overwrite the defaults.
                helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
              } else {
                // scales type are the same
                helpers$1.merge(target[key][i], scale);
              }
            }
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }
    /**
     * Recursively merge the given config objects as the root options by handling
     * default scale options for the `scales` and `scale` properties, then returns
     * a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          var tval = target[key] || {};
          var sval = source[key];

          if (key === 'scales') {
            // scale config merging is complex. Add our own function here for that
            target[key] = mergeScaleConfig(tval, sval);
          } else if (key === 'scale') {
            // used in polar area & radar charts since there is only one scale
            target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }

    function initConfig(config) {
      config = config || {}; // Do NOT use mergeConfig for the data object because this method merges arrays
      // and so would change references to labels and datasets, preventing data updates.

      var data = config.data = config.data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
      return config;
    }

    function updateConfig(chart) {
      var newOptions = chart.options;
      helpers$1.each(chart.scales, function (scale) {
        core_layouts.removeBox(chart, scale);
      });
      newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
      chart.options = chart.config.options = newOptions;
      chart.ensureScalesHaveIDs();
      chart.buildOrUpdateScales(); // Tooltip

      chart.tooltip._options = newOptions.tooltips;
      chart.tooltip.initialize();
    }

    function positionIsHorizontal(position) {
      return position === 'top' || position === 'bottom';
    }

    var Chart = function (item, config) {
      this.construct(item, config);
      return this;
    };

    helpers$1.extend(Chart.prototype,
    /** @lends Chart */
    {
      /**
       * @private
       */
      construct: function (item, config) {
        var me = this;
        config = initConfig(config);
        var context = platform.acquireContext(item, config);
        var canvas = context && context.canvas;
        var height = canvas && canvas.height;
        var width = canvas && canvas.width;
        me.id = helpers$1.uid();
        me.ctx = context;
        me.canvas = canvas;
        me.config = config;
        me.width = width;
        me.height = height;
        me.aspectRatio = height ? width / height : null;
        me.options = config.options;
        me._bufferedRender = false;
        /**
         * Provided for backward compatibility, Chart and Chart.Controller have been merged,
         * the "instance" still need to be defined since it might be called from plugins.
         * @prop Chart#chart
         * @deprecated since version 2.6.0
         * @todo remove at version 3
         * @private
         */

        me.chart = me;
        me.controller = me; // chart.chart.controller #inception
        // Add the chart instance to the global namespace

        Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`

        Object.defineProperty(me, 'data', {
          get: function () {
            return me.config.data;
          },
          set: function (value) {
            me.config.data = value;
          }
        });

        if (!context || !canvas) {
          // The given item is not a compatible context2d element, let's return before finalizing
          // the chart initialization but after setting basic chart / controller properties that
          // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
          // https://github.com/chartjs/Chart.js/issues/2807
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }

        me.initialize();
        me.update();
      },

      /**
       * @private
       */
      initialize: function () {
        var me = this; // Before init plugin notification

        core_plugins.notify(me, 'beforeInit');
        helpers$1.retinaScale(me, me.options.devicePixelRatio);
        me.bindEvents();

        if (me.options.responsive) {
          // Initial resize before chart draws (must be silent to preserve initial animations).
          me.resize(true);
        } // Make sure scales have IDs and are built before we build any controllers.


        me.ensureScalesHaveIDs();
        me.buildOrUpdateScales();
        me.initToolTip(); // After init plugin notification

        core_plugins.notify(me, 'afterInit');
        return me;
      },
      clear: function () {
        helpers$1.canvas.clear(this);
        return this;
      },
      stop: function () {
        // Stops any current animation loop occurring
        core_animations.cancelAnimation(this);
        return this;
      },
      resize: function (silent) {
        var me = this;
        var options = me.options;
        var canvas = me.canvas;
        var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that
        // the canvas display style uses the same integer values to avoid blurring effect.
        // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed

        var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
        var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));

        if (me.width === newWidth && me.height === newHeight) {
          return;
        }

        canvas.width = me.width = newWidth;
        canvas.height = me.height = newHeight;
        canvas.style.width = newWidth + 'px';
        canvas.style.height = newHeight + 'px';
        helpers$1.retinaScale(me, options.devicePixelRatio);

        if (!silent) {
          // Notify any plugins about the resize
          var newSize = {
            width: newWidth,
            height: newHeight
          };
          core_plugins.notify(me, 'resize', [newSize]); // Notify of resize

          if (options.onResize) {
            options.onResize(me, newSize);
          }

          me.stop();
          me.update({
            duration: options.responsiveAnimationDuration
          });
        }
      },
      ensureScalesHaveIDs: function () {
        var options = this.options;
        var scalesOptions = options.scales || {};
        var scaleOptions = options.scale;
        helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {
          xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
        });
        helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {
          yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
        });

        if (scaleOptions) {
          scaleOptions.id = scaleOptions.id || 'scale';
        }
      },

      /**
       * Builds a map of scale ID to scale object for future lookup.
       */
      buildOrUpdateScales: function () {
        var me = this;
        var options = me.options;
        var scales = me.scales || {};
        var items = [];
        var updated = Object.keys(scales).reduce(function (obj, id) {
          obj[id] = false;
          return obj;
        }, {});

        if (options.scales) {
          items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
            return {
              options: xAxisOptions,
              dtype: 'category',
              dposition: 'bottom'
            };
          }), (options.scales.yAxes || []).map(function (yAxisOptions) {
            return {
              options: yAxisOptions,
              dtype: 'linear',
              dposition: 'left'
            };
          }));
        }

        if (options.scale) {
          items.push({
            options: options.scale,
            dtype: 'radialLinear',
            isDefault: true,
            dposition: 'chartArea'
          });
        }

        helpers$1.each(items, function (item) {
          var scaleOptions = item.options;
          var id = scaleOptions.id;
          var scaleType = valueOrDefault$8(scaleOptions.type, item.dtype);

          if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
            scaleOptions.position = item.dposition;
          }

          updated[id] = true;
          var scale = null;

          if (id in scales && scales[id].type === scaleType) {
            scale = scales[id];
            scale.options = scaleOptions;
            scale.ctx = me.ctx;
            scale.chart = me;
          } else {
            var scaleClass = core_scaleService.getScaleConstructor(scaleType);

            if (!scaleClass) {
              return;
            }

            scale = new scaleClass({
              id: id,
              type: scaleType,
              options: scaleOptions,
              ctx: me.ctx,
              chart: me
            });
            scales[scale.id] = scale;
          }

          scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)
          // and consider it as a regular scale part of the "scales"" map only! This would
          // make the logic easier and remove some useless? custom code.

          if (item.isDefault) {
            me.scale = scale;
          }
        }); // clear up discarded scales

        helpers$1.each(updated, function (hasUpdated, id) {
          if (!hasUpdated) {
            delete scales[id];
          }
        });
        me.scales = scales;
        core_scaleService.addScalesToLayout(this);
      },
      buildOrUpdateControllers: function () {
        var me = this;
        var newControllers = [];
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          var meta = me.getDatasetMeta(datasetIndex);
          var type = dataset.type || me.config.type;

          if (meta.type && meta.type !== type) {
            me.destroyDatasetMeta(datasetIndex);
            meta = me.getDatasetMeta(datasetIndex);
          }

          meta.type = type;

          if (meta.controller) {
            meta.controller.updateIndex(datasetIndex);
            meta.controller.linkScales();
          } else {
            var ControllerClass = controllers[meta.type];

            if (ControllerClass === undefined) {
              throw new Error('"' + meta.type + '" is not a chart type.');
            }

            meta.controller = new ControllerClass(me, datasetIndex);
            newControllers.push(meta.controller);
          }
        }, me);
        return newControllers;
      },

      /**
       * Reset the elements of all datasets
       * @private
       */
      resetElements: function () {
        var me = this;
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.reset();
        }, me);
      },

      /**
      * Resets the chart back to it's state before the initial animation
      */
      reset: function () {
        this.resetElements();
        this.tooltip.initialize();
      },
      update: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        updateConfig(me); // plugins options references might have change, let's invalidate the cache
        // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167

        core_plugins._invalidate(me);

        if (core_plugins.notify(me, 'beforeUpdate') === false) {
          return;
        } // In case the entire data object changed


        me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset

        var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts

        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
        }, me);
        me.updateLayout(); // Can only reset the new controllers after the scales have been updated

        if (me.options.animation && me.options.animation.duration) {
          helpers$1.each(newControllers, function (controller) {
            controller.reset();
          });
        }

        me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed
        // after update.

        me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.
        // When we reset the tooltip, we need to clear it

        me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it

        core_plugins.notify(me, 'afterUpdate');

        if (me._bufferedRender) {
          me._bufferedRequest = {
            duration: config.duration,
            easing: config.easing,
            lazy: config.lazy
          };
        } else {
          me.render(config);
        }
      },

      /**
       * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
       * hook, in which case, plugins will not be called on `afterLayout`.
       * @private
       */
      updateLayout: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeLayout') === false) {
          return;
        }

        core_layouts.update(this, this.width, this.height);
        /**
         * Provided for backward compatibility, use `afterLayout` instead.
         * @method IPlugin#afterScaleUpdate
         * @deprecated since version 2.5.0
         * @todo remove at version 3
         * @private
         */

        core_plugins.notify(me, 'afterScaleUpdate');
        core_plugins.notify(me, 'afterLayout');
      },

      /**
       * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
       * @private
       */
      updateDatasets: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {
          return;
        }

        for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.updateDataset(i);
        }

        core_plugins.notify(me, 'afterDatasetsUpdate');
      },

      /**
       * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
       * @private
       */
      updateDataset: function (index) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index
        };

        if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
          return;
        }

        meta.controller.update();
        core_plugins.notify(me, 'afterDatasetUpdate', [args]);
      },
      render: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        var animationOptions = me.options.animation;
        var duration = valueOrDefault$8(config.duration, animationOptions && animationOptions.duration);
        var lazy = config.lazy;

        if (core_plugins.notify(me, 'beforeRender') === false) {
          return;
        }

        var onComplete = function (animation) {
          core_plugins.notify(me, 'afterRender');
          helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
        };

        if (animationOptions && duration) {
          var animation = new core_animation({
            numSteps: duration / 16.66,
            // 60 fps
            easing: config.easing || animationOptions.easing,
            render: function (chart, animationObject) {
              var easingFunction = helpers$1.easing.effects[animationObject.easing];
              var currentStep = animationObject.currentStep;
              var stepDecimal = currentStep / animationObject.numSteps;
              chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
            },
            onAnimationProgress: animationOptions.onProgress,
            onAnimationComplete: onComplete
          });
          core_animations.addAnimation(me, animation, duration, lazy);
        } else {
          me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781

          onComplete(new core_animation({
            numSteps: 0,
            chart: me
          }));
        }

        return me;
      },
      draw: function (easingValue) {
        var me = this;
        me.clear();

        if (helpers$1.isNullOrUndef(easingValue)) {
          easingValue = 1;
        }

        me.transition(easingValue);

        if (me.width <= 0 || me.height <= 0) {
          return;
        }

        if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
          return;
        } // Draw all the scales


        helpers$1.each(me.boxes, function (box) {
          box.draw(me.chartArea);
        }, me);
        me.drawDatasets(easingValue);

        me._drawTooltip(easingValue);

        core_plugins.notify(me, 'afterDraw', [easingValue]);
      },

      /**
       * @private
       */
      transition: function (easingValue) {
        var me = this;

        for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
          if (me.isDatasetVisible(i)) {
            me.getDatasetMeta(i).controller.transition(easingValue);
          }
        }

        me.tooltip.transition(easingValue);
      },

      /**
       * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
       * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
       * @private
       */
      drawDatasets: function (easingValue) {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
          return;
        } // Draw datasets reversed to support proper line stacking


        for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
          if (me.isDatasetVisible(i)) {
            me.drawDataset(i, easingValue);
          }
        }

        core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
      },

      /**
       * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
       * hook, in which case, plugins will not be called on `afterDatasetDraw`.
       * @private
       */
      drawDataset: function (index, easingValue) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
          return;
        }

        meta.controller.draw(easingValue);
        core_plugins.notify(me, 'afterDatasetDraw', [args]);
      },

      /**
       * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
       * hook, in which case, plugins will not be called on `afterTooltipDraw`.
       * @private
       */
      _drawTooltip: function (easingValue) {
        var me = this;
        var tooltip = me.tooltip;
        var args = {
          tooltip: tooltip,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
          return;
        }

        tooltip.draw();
        core_plugins.notify(me, 'afterTooltipDraw', [args]);
      },

      /**
       * Get the single element that was clicked on
       * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
       */
      getElementAtEvent: function (e) {
        return core_interaction.modes.single(this, e);
      },
      getElementsAtEvent: function (e) {
        return core_interaction.modes.label(this, e, {
          intersect: true
        });
      },
      getElementsAtXAxis: function (e) {
        return core_interaction.modes['x-axis'](this, e, {
          intersect: true
        });
      },
      getElementsAtEventForMode: function (e, mode, options) {
        var method = core_interaction.modes[mode];

        if (typeof method === 'function') {
          return method(this, e, options);
        }

        return [];
      },
      getDatasetAtEvent: function (e) {
        return core_interaction.modes.dataset(this, e, {
          intersect: true
        });
      },
      getDatasetMeta: function (datasetIndex) {
        var me = this;
        var dataset = me.data.datasets[datasetIndex];

        if (!dataset._meta) {
          dataset._meta = {};
        }

        var meta = dataset._meta[me.id];

        if (!meta) {
          meta = dataset._meta[me.id] = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            // See isDatasetVisible() comment
            xAxisID: null,
            yAxisID: null
          };
        }

        return meta;
      },
      getVisibleDatasetCount: function () {
        var count = 0;

        for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          if (this.isDatasetVisible(i)) {
            count++;
          }
        }

        return count;
      },
      isDatasetVisible: function (datasetIndex) {
        var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
        // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.

        return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
      },
      generateLegend: function () {
        return this.options.legendCallback(this);
      },

      /**
       * @private
       */
      destroyDatasetMeta: function (datasetIndex) {
        var id = this.id;
        var dataset = this.data.datasets[datasetIndex];
        var meta = dataset._meta && dataset._meta[id];

        if (meta) {
          meta.controller.destroy();
          delete dataset._meta[id];
        }
      },
      destroy: function () {
        var me = this;
        var canvas = me.canvas;
        var i, ilen;
        me.stop(); // dataset controllers need to cleanup associated data

        for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.destroyDatasetMeta(i);
        }

        if (canvas) {
          me.unbindEvents();
          helpers$1.canvas.clear(me);
          platform.releaseContext(me.ctx);
          me.canvas = null;
          me.ctx = null;
        }

        core_plugins.notify(me, 'destroy');
        delete Chart.instances[me.id];
      },
      toBase64Image: function () {
        return this.canvas.toDataURL.apply(this.canvas, arguments);
      },
      initToolTip: function () {
        var me = this;
        me.tooltip = new core_tooltip({
          _chart: me,
          _chartInstance: me,
          // deprecated, backward compatibility
          _data: me.data,
          _options: me.options.tooltips
        }, me);
      },

      /**
       * @private
       */
      bindEvents: function () {
        var me = this;
        var listeners = me._listeners = {};

        var listener = function () {
          me.eventHandler.apply(me, arguments);
        };

        helpers$1.each(me.options.events, function (type) {
          platform.addEventListener(me, type, listener);
          listeners[type] = listener;
        }); // Elements used to detect size change should not be injected for non responsive charts.
        // See https://github.com/chartjs/Chart.js/issues/2210

        if (me.options.responsive) {
          listener = function () {
            me.resize();
          };

          platform.addEventListener(me, 'resize', listener);
          listeners.resize = listener;
        }
      },

      /**
       * @private
       */
      unbindEvents: function () {
        var me = this;
        var listeners = me._listeners;

        if (!listeners) {
          return;
        }

        delete me._listeners;
        helpers$1.each(listeners, function (listener, type) {
          platform.removeEventListener(me, type, listener);
        });
      },
      updateHoverStyle: function (elements, mode, enabled) {
        var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
        var element, i, ilen;

        for (i = 0, ilen = elements.length; i < ilen; ++i) {
          element = elements[i];

          if (element) {
            this.getDatasetMeta(element._datasetIndex).controller[method](element);
          }
        }
      },

      /**
       * @private
       */
      eventHandler: function (e) {
        var me = this;
        var tooltip = me.tooltip;

        if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {
          return;
        } // Buffer any update calls so that renders do not occur


        me._bufferedRender = true;
        me._bufferedRequest = null;
        var changed = me.handleEvent(e); // for smooth tooltip animations issue #4989
        // the tooltip should be the source of change
        // Animation check workaround:
        // tooltip._start will be null when tooltip isn't animating

        if (tooltip) {
          changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
        }

        core_plugins.notify(me, 'afterEvent', [e]);
        var bufferedRequest = me._bufferedRequest;

        if (bufferedRequest) {
          // If we have an update that was triggered, we need to do a normal render
          me.render(bufferedRequest);
        } else if (changed && !me.animating) {
          // If entering, leaving, or changing elements, animate the change via pivot
          me.stop(); // We only need to render at this point. Updating will cause scales to be
          // recomputed generating flicker & using more memory than necessary.

          me.render({
            duration: me.options.hover.animationDuration,
            lazy: true
          });
        }

        me._bufferedRender = false;
        me._bufferedRequest = null;
        return me;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event the event to handle
       * @return {boolean} true if the chart needs to re-render
       */
      handleEvent: function (e) {
        var me = this;
        var options = me.options || {};
        var hoverOptions = options.hover;
        var changed = false;
        me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips

        if (e.type === 'mouseout') {
          me.active = [];
        } else {
          me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
        } // Invoke onHover hook
        // Need to call with native event here to not break backwards compatibility


        helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

        if (e.type === 'mouseup' || e.type === 'click') {
          if (options.onClick) {
            // Use e.native here for backwards compatibility
            options.onClick.call(me, e.native, me.active);
          }
        } // Remove styling for last active (even if it may still be active)


        if (me.lastActive.length) {
          me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
        } // Built in hover styling


        if (me.active.length && hoverOptions.mode) {
          me.updateHoverStyle(me.active, hoverOptions.mode, true);
        }

        changed = !helpers$1.arrayEquals(me.active, me.lastActive); // Remember Last Actives

        me.lastActive = me.active;
        return changed;
      }
    });
    /**
     * NOTE(SB) We actually don't use this container anymore but we need to keep it
     * for backward compatibility. Though, it can still be useful for plugins that
     * would need to work on multiple charts?!
     */

    Chart.instances = {};
    var core_controller = Chart; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart instead.
     * @class Chart.Controller
     * @deprecated since version 2.6
     * @todo remove at version 3
     * @private
     */

    Chart.Controller = Chart;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    Chart.types = {};
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.configMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.configMerge = mergeConfig;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.scaleMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.scaleMerge = mergeScaleConfig;

    var core_helpers = function () {
      // -- Basic js utility methods
      helpers$1.where = function (collection, filterCallback) {
        if (helpers$1.isArray(collection) && Array.prototype.filter) {
          return collection.filter(filterCallback);
        }

        var filtered = [];
        helpers$1.each(collection, function (item) {
          if (filterCallback(item)) {
            filtered.push(item);
          }
        });
        return filtered;
      };

      helpers$1.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
        return array.findIndex(callback, scope);
      } : function (array, callback, scope) {
        scope = scope === undefined ? array : scope;

        for (var i = 0, ilen = array.length; i < ilen; ++i) {
          if (callback.call(scope, array[i], i, array)) {
            return i;
          }
        }

        return -1;
      };

      helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to start of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = -1;
        }

        for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      };

      helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to end of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = arrayToSearch.length;
        }

        for (var i = startIndex - 1; i >= 0; i--) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      }; // -- Math methods


      helpers$1.isNumber = function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      };

      helpers$1.almostEquals = function (x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      };

      helpers$1.almostWhole = function (x, epsilon) {
        var rounded = Math.round(x);
        return rounded - epsilon < x && rounded + epsilon > x;
      };

      helpers$1.max = function (array) {
        return array.reduce(function (max, value) {
          if (!isNaN(value)) {
            return Math.max(max, value);
          }

          return max;
        }, Number.NEGATIVE_INFINITY);
      };

      helpers$1.min = function (array) {
        return array.reduce(function (min, value) {
          if (!isNaN(value)) {
            return Math.min(min, value);
          }

          return min;
        }, Number.POSITIVE_INFINITY);
      };

      helpers$1.sign = Math.sign ? function (x) {
        return Math.sign(x);
      } : function (x) {
        x = +x; // convert to a number

        if (x === 0 || isNaN(x)) {
          return x;
        }

        return x > 0 ? 1 : -1;
      };
      helpers$1.log10 = Math.log10 ? function (x) {
        return Math.log10(x);
      } : function (x) {
        var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
        // Check for whole powers of 10,
        // which due to floating point rounding error should be corrected.

        var powerOf10 = Math.round(exponent);
        var isPowerOf10 = x === Math.pow(10, powerOf10);
        return isPowerOf10 ? powerOf10 : exponent;
      };

      helpers$1.toRadians = function (degrees) {
        return degrees * (Math.PI / 180);
      };

      helpers$1.toDegrees = function (radians) {
        return radians * (180 / Math.PI);
      };
      /**
       * Returns the number of decimal places
       * i.e. the number of digits after the decimal point, of the value of this Number.
       * @param {number} x - A number.
       * @returns {number} The number of decimal places.
       * @private
       */


      helpers$1._decimalPlaces = function (x) {
        if (!helpers$1.isFinite(x)) {
          return;
        }

        var e = 1;
        var p = 0;

        while (Math.round(x * e) / e !== x) {
          e *= 10;
          p++;
        }

        return p;
      }; // Gets the angle from vertical upright to the point about a centre.


      helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {
        var distanceFromXCenter = anglePoint.x - centrePoint.x;
        var distanceFromYCenter = anglePoint.y - centrePoint.y;
        var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

        if (angle < -0.5 * Math.PI) {
          angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
        }

        return {
          angle: angle,
          distance: radialDistanceFromCenter
        };
      };

      helpers$1.distanceBetweenPoints = function (pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      };
      /**
       * Provided for backward compatibility, not available anymore
       * @function Chart.helpers.aliasPixel
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       */


      helpers$1.aliasPixel = function (pixelWidth) {
        return pixelWidth % 2 === 0 ? 0 : 0.5;
      };
      /**
       * Returns the aligned pixel value to avoid anti-aliasing blur
       * @param {Chart} chart - The chart instance.
       * @param {number} pixel - A pixel value.
       * @param {number} width - The width of the element.
       * @returns {number} The aligned pixel value.
       * @private
       */


      helpers$1._alignPixel = function (chart, pixel, width) {
        var devicePixelRatio = chart.currentDevicePixelRatio;
        var halfWidth = width / 2;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
      };

      helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
        // Props to Rob Spencer at scaled innovation for his post on splining between points
        // http://scaledinnovation.com/analytics/splines/aboutSplines.html
        // This function must also respect "skipped" points
        var previous = firstPoint.skip ? middlePoint : firstPoint;
        var current = middlePoint;
        var next = afterPoint.skip ? middlePoint : afterPoint;
        var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
        var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
        var s01 = d01 / (d01 + d12);
        var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf

        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        var fa = t * s01; // scaling factor for triangle Ta

        var fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      };

      helpers$1.EPSILON = Number.EPSILON || 1e-14;

      helpers$1.splineCurveMonotone = function (points) {
        // This function calculates Bézier control points in a similar way than |splineCurve|,
        // but preserves monotonicity of the provided data and ensures no local extremums are added
        // between the dataset discrete points due to the interpolation.
        // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
        var pointsWithTangents = (points || []).map(function (point) {
          return {
            model: point._model,
            deltaK: 0,
            mK: 0
          };
        }); // Calculate slopes (deltaK) and initialize tangents (mK)

        var pointsLen = pointsWithTangents.length;
        var i, pointBefore, pointCurrent, pointAfter;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointAfter && !pointAfter.model.skip) {
            var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0

            pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
          }

          if (!pointBefore || pointBefore.model.skip) {
            pointCurrent.mK = pointCurrent.deltaK;
          } else if (!pointAfter || pointAfter.model.skip) {
            pointCurrent.mK = pointBefore.deltaK;
          } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
            pointCurrent.mK = 0;
          } else {
            pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
          }
        } // Adjust tangents to ensure monotonic properties


        var alphaK, betaK, tauK, squaredMagnitude;

        for (i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointsWithTangents[i];
          pointAfter = pointsWithTangents[i + 1];

          if (pointCurrent.model.skip || pointAfter.model.skip) {
            continue;
          }

          if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
            pointCurrent.mK = pointAfter.mK = 0;
            continue;
          }

          alphaK = pointCurrent.mK / pointCurrent.deltaK;
          betaK = pointAfter.mK / pointCurrent.deltaK;
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

          if (squaredMagnitude <= 9) {
            continue;
          }

          tauK = 3 / Math.sqrt(squaredMagnitude);
          pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
          pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
        } // Compute control points


        var deltaX;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointBefore && !pointBefore.model.skip) {
            deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
            pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
            pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
          }

          if (pointAfter && !pointAfter.model.skip) {
            deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
            pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
            pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
          }
        }
      };

      helpers$1.nextItem = function (collection, index, loop) {
        if (loop) {
          return index >= collection.length - 1 ? collection[0] : collection[index + 1];
        }

        return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
      };

      helpers$1.previousItem = function (collection, index, loop) {
        if (loop) {
          return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
        }

        return index <= 0 ? collection[0] : collection[index - 1];
      }; // Implementation of the nice number algorithm used in determining where axis labels will go


      helpers$1.niceNum = function (range, round) {
        var exponent = Math.floor(helpers$1.log10(range));
        var fraction = range / Math.pow(10, exponent);
        var niceFraction;

        if (round) {
          if (fraction < 1.5) {
            niceFraction = 1;
          } else if (fraction < 3) {
            niceFraction = 2;
          } else if (fraction < 7) {
            niceFraction = 5;
          } else {
            niceFraction = 10;
          }
        } else if (fraction <= 1.0) {
          niceFraction = 1;
        } else if (fraction <= 2) {
          niceFraction = 2;
        } else if (fraction <= 5) {
          niceFraction = 5;
        } else {
          niceFraction = 10;
        }

        return niceFraction * Math.pow(10, exponent);
      }; // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/


      helpers$1.requestAnimFrame = function () {
        if (typeof window === 'undefined') {
          return function (callback) {
            callback();
          };
        }

        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
          return window.setTimeout(callback, 1000 / 60);
        };
      }(); // -- DOM methods


      helpers$1.getRelativePosition = function (evt, chart) {
        var mouseX, mouseY;
        var e = evt.originalEvent || evt;
        var canvas = evt.target || evt.srcElement;
        var boundingRect = canvas.getBoundingClientRect();
        var touches = e.touches;

        if (touches && touches.length > 0) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        } // Scale mouse coordinates into canvas coordinates
        // by following the pattern laid out by 'jerryj' in the comments of
        // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/


        var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));
        var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));
        var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));
        var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));
        var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
        var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
        // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here

        mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
        mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
        return {
          x: mouseX,
          y: mouseY
        };
      }; // Private helper function to convert max-width/max-height values that may be percentages into a number


      function parseMaxStyle(styleValue, node, parentProperty) {
        var valueInPixels;

        if (typeof styleValue === 'string') {
          valueInPixels = parseInt(styleValue, 10);

          if (styleValue.indexOf('%') !== -1) {
            // percentage * size in dimension
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }

        return valueInPixels;
      }
      /**
       * Returns if the given value contains an effective constraint.
       * @private
       */


      function isConstrainedValue(value) {
        return value !== undefined && value !== null && value !== 'none';
      }
      /**
       * Returns the max width or height of the given DOM node in a cross-browser compatible fashion
       * @param {HTMLElement} domNode - the node to check the constraint on
       * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')
       * @param {string} percentageProperty - property of parent to use when calculating width as a percentage
       * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}
       */


      function getConstraintDimension(domNode, maxStyle, percentageProperty) {
        var view = document.defaultView;

        var parentNode = helpers$1._getParentNode(domNode);

        var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
        var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
        var hasCNode = isConstrainedValue(constrainedNode);
        var hasCContainer = isConstrainedValue(constrainedContainer);
        var infinity = Number.POSITIVE_INFINITY;

        if (hasCNode || hasCContainer) {
          return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
        }

        return 'none';
      } // returns Number or undefined if no constraint


      helpers$1.getConstraintWidth = function (domNode) {
        return getConstraintDimension(domNode, 'max-width', 'clientWidth');
      }; // returns Number or undefined if no constraint


      helpers$1.getConstraintHeight = function (domNode) {
        return getConstraintDimension(domNode, 'max-height', 'clientHeight');
      };
      /**
       * @private
      	 */


      helpers$1._calculatePadding = function (container, padding, parentDimension) {
        padding = helpers$1.getStyle(container, padding);
        return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
      };
      /**
       * @private
       */


      helpers$1._getParentNode = function (domNode) {
        var parent = domNode.parentNode;

        if (parent && parent.toString() === '[object ShadowRoot]') {
          parent = parent.host;
        }

        return parent;
      };

      helpers$1.getMaximumWidth = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientWidth;
        }

        var clientWidth = container.clientWidth;

        var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);

        var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);

        var w = clientWidth - paddingLeft - paddingRight;
        var cw = helpers$1.getConstraintWidth(domNode);
        return isNaN(cw) ? w : Math.min(w, cw);
      };

      helpers$1.getMaximumHeight = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientHeight;
        }

        var clientHeight = container.clientHeight;

        var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);

        var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);

        var h = clientHeight - paddingTop - paddingBottom;
        var ch = helpers$1.getConstraintHeight(domNode);
        return isNaN(ch) ? h : Math.min(h, ch);
      };

      helpers$1.getStyle = function (el, property) {
        return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
      };

      helpers$1.retinaScale = function (chart, forceRatio) {
        var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;

        if (pixelRatio === 1) {
          return;
        }

        var canvas = chart.canvas;
        var height = chart.height;
        var width = chart.width;
        canvas.height = height * pixelRatio;
        canvas.width = width * pixelRatio;
        chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,
        // making the chart visually bigger, so let's enforce it to the "correct" values.
        // See https://github.com/chartjs/Chart.js/issues/3575

        if (!canvas.style.height && !canvas.style.width) {
          canvas.style.height = height + 'px';
          canvas.style.width = width + 'px';
        }
      }; // -- Canvas methods


      helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {
        return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
      };

      helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        var data = cache.data = cache.data || {};
        var gc = cache.garbageCollect = cache.garbageCollect || [];

        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }

        ctx.font = font;
        var longest = 0;
        helpers$1.each(arrayOfThings, function (thing) {
          // Undefined strings and arrays should not be measured
          if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
            longest = helpers$1.measureText(ctx, data, gc, longest, thing);
          } else if (helpers$1.isArray(thing)) {
            // if it is an array lets measure each element
            // to do maybe simplify this function a bit so we can do this more recursively?
            helpers$1.each(thing, function (nestedThing) {
              // Undefined strings and arrays should not be measured
              if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
              }
            });
          }
        });
        var gcLen = gc.length / 2;

        if (gcLen > arrayOfThings.length) {
          for (var i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }

          gc.splice(0, gcLen);
        }

        return longest;
      };

      helpers$1.measureText = function (ctx, data, gc, longest, string) {
        var textWidth = data[string];

        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
        }

        if (textWidth > longest) {
          longest = textWidth;
        }

        return longest;
      };

      helpers$1.numberOfLabelLines = function (arrayOfThings) {
        var numberOfLines = 1;
        helpers$1.each(arrayOfThings, function (thing) {
          if (helpers$1.isArray(thing)) {
            if (thing.length > numberOfLines) {
              numberOfLines = thing.length;
            }
          }
        });
        return numberOfLines;
      };

      helpers$1.color = !chartjsColor ? function (value) {
        console.error('Color.js not found!');
        return value;
      } : function (value) {
        /* global CanvasGradient */
        if (value instanceof CanvasGradient) {
          value = core_defaults.global.defaultColor;
        }

        return chartjsColor(value);
      };

      helpers$1.getHoverColor = function (colorValue) {
        /* global CanvasPattern */
        return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
      };
    };

    function abstract() {
      throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');
    }
    /**
     * Date adapter (current used by the time scale)
     * @namespace Chart._adapters._date
     * @memberof Chart._adapters
     * @private
     */

    /**
     * Currently supported unit string values.
     * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}
     * @memberof Chart._adapters._date
     * @name Unit
     */

    /**
     * @class
     */


    function DateAdapter(options) {
      this.options = options || {};
    }

    helpers$1.extend(DateAdapter.prototype,
    /** @lends DateAdapter */
    {
      /**
       * Returns a map of time formats for the supported formatting units defined
       * in Unit as well as 'datetime' representing a detailed date/time string.
       * @returns {{string: string}}
       */
      formats: abstract,

      /**
       * Parses the given `value` and return the associated timestamp.
       * @param {any} value - the value to parse (usually comes from the data)
       * @param {string} [format] - the expected data format
       * @returns {(number|null)}
       * @function
       */
      parse: abstract,

      /**
       * Returns the formatted date in the specified `format` for a given `timestamp`.
       * @param {number} timestamp - the timestamp to format
       * @param {string} format - the date/time token
       * @return {string}
       * @function
       */
      format: abstract,

      /**
       * Adds the specified `amount` of `unit` to the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {number} amount - the amount to add
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      add: abstract,

      /**
       * Returns the number of `unit` between the given timestamps.
       * @param {number} max - the input timestamp (reference)
       * @param {number} min - the timestamp to substract
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      diff: abstract,

      /**
       * Returns start of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @param {number} [weekday] - the ISO day of the week with 1 being Monday
       * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
       * @function
       */
      startOf: abstract,

      /**
       * Returns end of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @function
       */
      endOf: abstract,
      // DEPRECATIONS

      /**
       * Provided for backward compatibility for scale.getValueForPixel(),
       * this method should be overridden only by the moment adapter.
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (value) {
        return value;
      }
    });

    DateAdapter.override = function (members) {
      helpers$1.extend(DateAdapter.prototype, members);
    };

    var _date = DateAdapter;
    var core_adapters = {
      _date: _date
    };
    /**
     * Namespace to hold static tick generation functions
     * @namespace Chart.Ticks
     */

    var core_ticks = {
      /**
       * Namespace to hold formatters for different types of ticks
       * @namespace Chart.Ticks.formatters
       */
      formatters: {
        /**
         * Formatter for value labels
         * @method Chart.Ticks.formatters.values
         * @param value the value to display
         * @return {string|string[]} the label to display
         */
        values: function (value) {
          return helpers$1.isArray(value) ? value : '' + value;
        },

        /**
         * Formatter for linear numeric ticks
         * @method Chart.Ticks.formatters.linear
         * @param tickValue {number} the value to be formatted
         * @param index {number} the position of the tickValue parameter in the ticks array
         * @param ticks {number[]} the list of ticks being converted
         * @return {string} string representation of the tickValue parameter
         */
        linear: function (tickValue, index, ticks) {
          // If we have lots of ticks, don't use the ones
          var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need

          if (Math.abs(delta) > 1) {
            if (tickValue !== Math.floor(tickValue)) {
              // not an integer
              delta = tickValue - Math.floor(tickValue);
            }
          }

          var logDelta = helpers$1.log10(Math.abs(delta));
          var tickString = '';

          if (tickValue !== 0) {
            var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));

            if (maxTick < 1e-4) {
              // all ticks are small numbers; use scientific notation
              var logTick = helpers$1.log10(Math.abs(tickValue));
              tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
            } else {
              var numDecimal = -1 * Math.floor(logDelta);
              numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places

              tickString = tickValue.toFixed(numDecimal);
            }
          } else {
            tickString = '0'; // never show decimal places for 0
          }

          return tickString;
        },
        logarithmic: function (tickValue, index, ticks) {
          var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));

          if (tickValue === 0) {
            return '0';
          } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
            return tickValue.toExponential();
          }

          return '';
        }
      }
    };
    var valueOrDefault$9 = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;

    core_defaults._set('scale', {
      display: true,
      position: 'left',
      offset: false,
      // grid line settings
      gridLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        drawBorder: true,
        drawOnChartArea: true,
        drawTicks: true,
        tickMarkLength: 10,
        zeroLineWidth: 1,
        zeroLineColor: 'rgba(0,0,0,0.25)',
        zeroLineBorderDash: [],
        zeroLineBorderDashOffset: 0.0,
        offsetGridLines: false,
        borderDash: [],
        borderDashOffset: 0.0
      },
      // scale label
      scaleLabel: {
        // display property
        display: false,
        // actual label
        labelString: '',
        // top/bottom padding
        padding: {
          top: 4,
          bottom: 4
        }
      },
      // label settings
      ticks: {
        beginAtZero: false,
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        padding: 0,
        reverse: false,
        display: true,
        autoSkip: true,
        autoSkipPadding: 0,
        labelOffset: 0,
        // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
        callback: core_ticks.formatters.values,
        minor: {},
        major: {}
      }
    });

    function labelsFromTicks(ticks) {
      var labels = [];
      var i, ilen;

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        labels.push(ticks[i].label);
      }

      return labels;
    }

    function getPixelForGridLine(scale, index, offsetGridLines) {
      var lineValue = scale.getPixelForTick(index);

      if (offsetGridLines) {
        if (scale.getTicks().length === 1) {
          lineValue -= scale.isHorizontal() ? Math.max(lineValue - scale.left, scale.right - lineValue) : Math.max(lineValue - scale.top, scale.bottom - lineValue);
        } else if (index === 0) {
          lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
          lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
        }
      }

      return lineValue;
    }

    function computeTextSize(context, tick, font) {
      return helpers$1.isArray(tick) ? helpers$1.longestText(context, font, tick) : context.measureText(tick).width;
    }

    var core_scale = core_element.extend({
      /**
       * Get the padding needed for the scale
       * @method getPadding
       * @private
       * @returns {Padding} the necessary padding
       */
      getPadding: function () {
        var me = this;
        return {
          left: me.paddingLeft || 0,
          top: me.paddingTop || 0,
          right: me.paddingRight || 0,
          bottom: me.paddingBottom || 0
        };
      },

      /**
       * Returns the scale tick objects ({label, major})
       * @since 2.7
       */
      getTicks: function () {
        return this._ticks;
      },
      // These methods are ordered by lifecyle. Utilities then follow.
      // Any function defined here is inherited by all scale types.
      // Any function can be extended by the scale type
      mergeTicksOptions: function () {
        var ticks = this.options.ticks;

        if (ticks.minor === false) {
          ticks.minor = {
            display: false
          };
        }

        if (ticks.major === false) {
          ticks.major = {
            display: false
          };
        }

        for (var key in ticks) {
          if (key !== 'major' && key !== 'minor') {
            if (typeof ticks.minor[key] === 'undefined') {
              ticks.minor[key] = ticks[key];
            }

            if (typeof ticks.major[key] === 'undefined') {
              ticks.major[key] = ticks[key];
            }
          }
        }
      },
      beforeUpdate: function () {
        helpers$1.callback(this.options.beforeUpdate, [this]);
      },
      update: function (maxWidth, maxHeight, margins) {
        var me = this;
        var i, ilen, labels, label, ticks, tick; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = helpers$1.extend({
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, margins);
        me._maxLabelLines = 0;
        me.longestLabelWidth = 0;
        me.longestTextCache = me.longestTextCache || {}; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Data min/max

        me.beforeDataLimits();
        me.determineDataLimits();
        me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!
        // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
        // and must not be accessed directly from outside this class. `this.ticks` being
        // around for long time and not marked as private, we can't change its structure
        // without unexpected breaking changes. If you need to access the scale ticks,
        // use scale.getTicks() instead.

        me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,
        // we still support no return (`this.ticks` internally set by calling this method).

        ticks = me.buildTicks() || []; // Allow modification of ticks in callback.

        ticks = me.afterBuildTicks(ticks) || ticks;
        me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD
        // COMPAT, we still support no return (`this.ticks` internally changed by calling
        // this method and supposed to contain only string values).

        labels = me.convertTicksToLabels(ticks) || me.ticks;
        me.afterTickToLabelConversion();
        me.ticks = labels; // BACKWARD COMPATIBILITY
        // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
        // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)

        for (i = 0, ilen = labels.length; i < ilen; ++i) {
          label = labels[i];
          tick = ticks[i];

          if (!tick) {
            ticks.push(tick = {
              label: label,
              major: false
            });
          } else {
            tick.label = label;
          }
        }

        me._ticks = ticks; // Tick Rotation

        me.beforeCalculateTickRotation();
        me.calculateTickRotation();
        me.afterCalculateTickRotation(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: function () {
        helpers$1.callback(this.options.afterUpdate, [this]);
      },
      //
      beforeSetDimensions: function () {
        helpers$1.callback(this.options.beforeSetDimensions, [this]);
      },
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0;
      },
      afterSetDimensions: function () {
        helpers$1.callback(this.options.afterSetDimensions, [this]);
      },
      // Data limits
      beforeDataLimits: function () {
        helpers$1.callback(this.options.beforeDataLimits, [this]);
      },
      determineDataLimits: helpers$1.noop,
      afterDataLimits: function () {
        helpers$1.callback(this.options.afterDataLimits, [this]);
      },
      //
      beforeBuildTicks: function () {
        helpers$1.callback(this.options.beforeBuildTicks, [this]);
      },
      buildTicks: helpers$1.noop,
      afterBuildTicks: function (ticks) {
        var me = this; // ticks is empty for old axis implementations here

        if (helpers$1.isArray(ticks) && ticks.length) {
          return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
        } // Support old implementations (that modified `this.ticks` directly in buildTicks)


        me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
        return ticks;
      },
      beforeTickToLabelConversion: function () {
        helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
      },
      convertTicksToLabels: function () {
        var me = this; // Convert ticks to strings

        var tickOpts = me.options.ticks;
        me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
      },
      afterTickToLabelConversion: function () {
        helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
      },
      //
      beforeCalculateTickRotation: function () {
        helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
      },
      calculateTickRotation: function () {
        var me = this;
        var context = me.ctx;
        var tickOpts = me.options.ticks;
        var labels = labelsFromTicks(me._ticks); // Get the width of each grid by calculating the difference
        // between x offsets between 0 and 1.

        var tickFont = helpers$1.options._parseFont(tickOpts);

        context.font = tickFont.string;
        var labelRotation = tickOpts.minRotation || 0;

        if (labels.length && me.options.display && me.isHorizontal()) {
          var originalLabelWidth = helpers$1.longestText(context, tickFont.string, labels, me.longestTextCache);
          var labelWidth = originalLabelWidth;
          var cosRotation, sinRotation; // Allow 3 pixels x2 padding either side for label readability

          var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter

          while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
            var angleRadians = helpers$1.toRadians(labelRotation);
            cosRotation = Math.cos(angleRadians);
            sinRotation = Math.sin(angleRadians);

            if (sinRotation * originalLabelWidth > me.maxHeight) {
              // go back one step
              labelRotation--;
              break;
            }

            labelRotation++;
            labelWidth = cosRotation * originalLabelWidth;
          }
        }

        me.labelRotation = labelRotation;
      },
      afterCalculateTickRotation: function () {
        helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
      },
      //
      beforeFit: function () {
        helpers$1.callback(this.options.beforeFit, [this]);
      },
      fit: function () {
        var me = this; // Reset

        var minSize = me.minSize = {
          width: 0,
          height: 0
        };
        var labels = labelsFromTicks(me._ticks);
        var opts = me.options;
        var tickOpts = opts.ticks;
        var scaleLabelOpts = opts.scaleLabel;
        var gridLineOpts = opts.gridLines;

        var display = me._isVisible();

        var position = opts.position;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var tickFont = parseFont(tickOpts);
        var tickMarkLength = opts.gridLines.tickMarkLength; // Width

        if (isHorizontal) {
          // subtract the margins to line up with the chartArea if we are a full width scale
          minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
        } else {
          minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } // height


        if (isHorizontal) {
          minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } else {
          minSize.height = me.maxHeight; // fill all the height
        } // Are we showing a title for the scale?


        if (scaleLabelOpts.display && display) {
          var scaleLabelFont = parseFont(scaleLabelOpts);
          var scaleLabelPadding = helpers$1.options.toPadding(scaleLabelOpts.padding);
          var deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;

          if (isHorizontal) {
            minSize.height += deltaHeight;
          } else {
            minSize.width += deltaHeight;
          }
        } // Don't bother fitting the ticks if we are not showing the labels


        if (tickOpts.display && display) {
          var largestTextWidth = helpers$1.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);
          var tallestLabelHeightInLines = helpers$1.numberOfLabelLines(labels);
          var lineSpace = tickFont.size * 0.5;
          var tickPadding = me.options.ticks.padding; // Store max number of lines and widest label for _autoSkip

          me._maxLabelLines = tallestLabelHeightInLines;
          me.longestLabelWidth = largestTextWidth;

          if (isHorizontal) {
            var angleRadians = helpers$1.toRadians(me.labelRotation);
            var cosRotation = Math.cos(angleRadians);
            var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation

            var labelHeight = sinRotation * largestTextWidth + tickFont.lineHeight * tallestLabelHeightInLines + lineSpace; // padding

            minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
            me.ctx.font = tickFont.string;
            var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);
            var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);
            var offsetLeft = me.getPixelForTick(0) - me.left;
            var offsetRight = me.right - me.getPixelForTick(labels.length - 1);
            var paddingLeft, paddingRight; // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
            // which means that the right padding is dominated by the font height

            if (me.labelRotation !== 0) {
              paddingLeft = position === 'bottom' ? cosRotation * firstLabelWidth : cosRotation * lineSpace;
              paddingRight = position === 'bottom' ? cosRotation * lineSpace : cosRotation * lastLabelWidth;
            } else {
              paddingLeft = firstLabelWidth / 2;
              paddingRight = lastLabelWidth / 2;
            }

            me.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges

            me.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;
          } else {
            // A vertical axis is more constrained by the width. Labels are the
            // dominant factor here, so get that length first and account for padding
            if (tickOpts.mirror) {
              largestTextWidth = 0;
            } else {
              // use lineSpace for consistency with horizontal axis
              // tickPadding is not implemented for horizontal
              largestTextWidth += tickPadding + lineSpace;
            }

            minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
            me.paddingTop = tickFont.size / 2;
            me.paddingBottom = tickFont.size / 2;
          }
        }

        me.handleMargins();
        me.width = minSize.width;
        me.height = minSize.height;
      },

      /**
       * Handle margins and padding interactions
       * @private
       */
      handleMargins: function () {
        var me = this;

        if (me.margins) {
          me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
          me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
          me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
          me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
        }
      },
      afterFit: function () {
        helpers$1.callback(this.options.afterFit, [this]);
      },
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      isFullWidth: function () {
        return this.options.fullWidth;
      },
      // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
      getRightValue: function (rawValue) {
        // Null and undefined values first
        if (helpers$1.isNullOrUndef(rawValue)) {
          return NaN;
        } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values


        if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {
          return NaN;
        } // If it is in fact an object, dive in one more level


        if (rawValue) {
          if (this.isHorizontal()) {
            if (rawValue.x !== undefined) {
              return this.getRightValue(rawValue.x);
            }
          } else if (rawValue.y !== undefined) {
            return this.getRightValue(rawValue.y);
          }
        } // Value is good, return it


        return rawValue;
      },

      /**
       * Used to get the value to display in the tooltip for the data at the given index
       * @param index
       * @param datasetIndex
       */
      getLabelForIndex: helpers$1.noop,

      /**
       * Returns the location of the given data point. Value can either be an index or a numerical value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param value
       * @param index
       * @param datasetIndex
       */
      getPixelForValue: helpers$1.noop,

      /**
       * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param pixel
       */
      getValueForPixel: helpers$1.noop,

      /**
       * Returns the location of the tick at the given index
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForTick: function (index) {
        var me = this;
        var offset = me.options.offset;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
          var pixel = tickWidth * index + me.paddingLeft;

          if (offset) {
            pixel += tickWidth / 2;
          }

          var finalVal = me.left + pixel;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
        return me.top + index * (innerHeight / (me._ticks.length - 1));
      },

      /**
       * Utility for getting the pixel location of a percentage of scale
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForDecimal: function (decimal) {
        var me = this;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var valueOffset = innerWidth * decimal + me.paddingLeft;
          var finalVal = me.left + valueOffset;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        return me.top + decimal * me.height;
      },

      /**
       * Returns the pixel for the minimum chart value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getBasePixel: function () {
        return this.getPixelForValue(this.getBaseValue());
      },
      getBaseValue: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
      },

      /**
       * Returns a subset of ticks to be plotted to avoid overlapping labels.
       * @private
       */
      _autoSkip: function (ticks) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor;
        var tickCount = ticks.length;
        var skipRatio = false;
        var maxTicks = optionTicks.maxTicksLimit; // Total space needed to display all ticks. First and last ticks are
        // drawn as their center at end of axis, so tickCount-1

        var ticksLength = me._tickSize() * (tickCount - 1); // Axis length

        var axisLength = isHorizontal ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.PaddingBottom);
        var result = [];
        var i, tick;

        if (ticksLength > axisLength) {
          skipRatio = 1 + Math.floor(ticksLength / axisLength);
        } // if they defined a max number of optionTicks,
        // increase skipRatio until that number is met


        if (tickCount > maxTicks) {
          skipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));
        }

        for (i = 0; i < tickCount; i++) {
          tick = ticks[i];

          if (skipRatio > 1 && i % skipRatio > 0) {
            // leave tick in place but make sure it's not displayed (#4635)
            delete tick.label;
          }

          result.push(tick);
        }

        return result;
      },

      /**
       * @private
       */
      _tickSize: function () {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor; // Calculate space needed by label in axis direction.

        var rot = helpers$1.toRadians(me.labelRotation);
        var cos = Math.abs(Math.cos(rot));
        var sin = Math.abs(Math.sin(rot));
        var padding = optionTicks.autoSkipPadding || 0;
        var w = me.longestLabelWidth + padding || 0;

        var tickFont = helpers$1.options._parseFont(optionTicks);

        var h = me._maxLabelLines * tickFont.lineHeight + padding || 0; // Calculate space needed for 1 tick in axis direction.

        return isHorizontal ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
      },

      /**
       * @private
       */
      _isVisible: function () {
        var me = this;
        var chart = me.chart;
        var display = me.options.display;
        var i, ilen, meta;

        if (display !== 'auto') {
          return !!display;
        } // When 'auto', the scale is visible if at least one associated dataset is visible.


        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);

            if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
              return true;
            }
          }
        }

        return false;
      },

      /**
       * Actually draw the scale on the canvas
       * @param {object} chartArea - the area of the chart to draw full grid lines on
       */
      draw: function (chartArea) {
        var me = this;
        var options = me.options;

        if (!me._isVisible()) {
          return;
        }

        var chart = me.chart;
        var context = me.ctx;
        var globalDefaults = core_defaults.global;
        var defaultFontColor = globalDefaults.defaultFontColor;
        var optionTicks = options.ticks.minor;
        var optionMajorTicks = options.ticks.major || optionTicks;
        var gridLines = options.gridLines;
        var scaleLabel = options.scaleLabel;
        var position = options.position;
        var isRotated = me.labelRotation !== 0;
        var isMirrored = optionTicks.mirror;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
        var tickFontColor = valueOrDefault$9(optionTicks.fontColor, defaultFontColor);
        var tickFont = parseFont(optionTicks);
        var lineHeight = tickFont.lineHeight;
        var majorTickFontColor = valueOrDefault$9(optionMajorTicks.fontColor, defaultFontColor);
        var majorTickFont = parseFont(optionMajorTicks);
        var tickPadding = optionTicks.padding;
        var labelOffset = optionTicks.labelOffset;
        var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
        var scaleLabelFontColor = valueOrDefault$9(scaleLabel.fontColor, defaultFontColor);
        var scaleLabelFont = parseFont(scaleLabel);
        var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
        var labelRotationRadians = helpers$1.toRadians(me.labelRotation);
        var itemsToDraw = [];
        var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
        var alignPixel = helpers$1._alignPixel;
        var borderValue, tickStart, tickEnd;

        if (position === 'top') {
          borderValue = alignPixel(chart, me.bottom, axisWidth);
          tickStart = me.bottom - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else if (position === 'bottom') {
          borderValue = alignPixel(chart, me.top, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.top + tl;
        } else if (position === 'left') {
          borderValue = alignPixel(chart, me.right, axisWidth);
          tickStart = me.right - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else {
          borderValue = alignPixel(chart, me.left, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.left + tl;
        }

        var epsilon = 0.0000001; // 0.0000001 is margin in pixels for Accumulated error.

        helpers$1.each(ticks, function (tick, index) {
          // autoskipper skipped this tick (#4635)
          if (helpers$1.isNullOrUndef(tick.label)) {
            return;
          }

          var label = tick.label;
          var lineWidth, lineColor, borderDash, borderDashOffset;

          if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
            // Draw the first index specially
            lineWidth = gridLines.zeroLineWidth;
            lineColor = gridLines.zeroLineColor;
            borderDash = gridLines.zeroLineBorderDash || [];
            borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;
          } else {
            lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);
            lineColor = valueAtIndexOrDefault(gridLines.color, index);
            borderDash = gridLines.borderDash || [];
            borderDashOffset = gridLines.borderDashOffset || 0.0;
          } // Common properties


          var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;
          var labelCount = helpers$1.isArray(label) ? label.length : 1;
          var lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);

          if (isHorizontal) {
            var labelYOffset = tl + tickPadding;

            if (lineValue < me.left - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);
            ty1 = tickStart;
            ty2 = tickEnd;
            labelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)

            if (position === 'top') {
              y1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;
              y2 = chartArea.bottom;
              textOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;
              textAlign = !isRotated ? 'center' : 'left';
              labelY = me.bottom - labelYOffset;
            } else {
              y1 = chartArea.top;
              y2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;
              textOffset = (!isRotated ? 0.5 : 0) * lineHeight;
              textAlign = !isRotated ? 'center' : 'right';
              labelY = me.top + labelYOffset;
            }
          } else {
            var labelXOffset = (isMirrored ? 0 : tl) + tickPadding;

            if (lineValue < me.top - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tickStart;
            tx2 = tickEnd;
            ty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);
            labelY = me.getPixelForTick(index) + labelOffset;
            textOffset = (1 - labelCount) * lineHeight / 2;

            if (position === 'left') {
              x1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;
              x2 = chartArea.right;
              textAlign = isMirrored ? 'left' : 'right';
              labelX = me.right - labelXOffset;
            } else {
              x1 = chartArea.left;
              x2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;
              textAlign = isMirrored ? 'right' : 'left';
              labelX = me.left + labelXOffset;
            }
          }

          itemsToDraw.push({
            tx1: tx1,
            ty1: ty1,
            tx2: tx2,
            ty2: ty2,
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            labelX: labelX,
            labelY: labelY,
            glWidth: lineWidth,
            glColor: lineColor,
            glBorderDash: borderDash,
            glBorderDashOffset: borderDashOffset,
            rotation: -1 * labelRotationRadians,
            label: label,
            major: tick.major,
            textOffset: textOffset,
            textAlign: textAlign
          });
        }); // Draw all of the tick labels, tick marks, and grid lines at the correct places

        helpers$1.each(itemsToDraw, function (itemToDraw) {
          var glWidth = itemToDraw.glWidth;
          var glColor = itemToDraw.glColor;

          if (gridLines.display && glWidth && glColor) {
            context.save();
            context.lineWidth = glWidth;
            context.strokeStyle = glColor;

            if (context.setLineDash) {
              context.setLineDash(itemToDraw.glBorderDash);
              context.lineDashOffset = itemToDraw.glBorderDashOffset;
            }

            context.beginPath();

            if (gridLines.drawTicks) {
              context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
              context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
            }

            if (gridLines.drawOnChartArea) {
              context.moveTo(itemToDraw.x1, itemToDraw.y1);
              context.lineTo(itemToDraw.x2, itemToDraw.y2);
            }

            context.stroke();
            context.restore();
          }

          if (optionTicks.display) {
            // Make sure we draw text in the correct color and font
            context.save();
            context.translate(itemToDraw.labelX, itemToDraw.labelY);
            context.rotate(itemToDraw.rotation);
            context.font = itemToDraw.major ? majorTickFont.string : tickFont.string;
            context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
            context.textBaseline = 'middle';
            context.textAlign = itemToDraw.textAlign;
            var label = itemToDraw.label;
            var y = itemToDraw.textOffset;

            if (helpers$1.isArray(label)) {
              for (var i = 0; i < label.length; ++i) {
                // We just make sure the multiline element is a string here..
                context.fillText('' + label[i], 0, y);
                y += lineHeight;
              }
            } else {
              context.fillText(label, 0, y);
            }

            context.restore();
          }
        });

        if (scaleLabel.display) {
          // Draw the scale label
          var scaleLabelX;
          var scaleLabelY;
          var rotation = 0;
          var halfLineHeight = scaleLabelFont.lineHeight / 2;

          if (isHorizontal) {
            scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width

            scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
          } else {
            var isLeft = position === 'left';
            scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
            scaleLabelY = me.top + (me.bottom - me.top) / 2;
            rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
          }

          context.save();
          context.translate(scaleLabelX, scaleLabelY);
          context.rotate(rotation);
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          context.fillStyle = scaleLabelFontColor; // render in correct colour

          context.font = scaleLabelFont.string;
          context.fillText(scaleLabel.labelString, 0, 0);
          context.restore();
        }

        if (axisWidth) {
          // Draw the line at the edge of the axis
          var firstLineWidth = axisWidth;
          var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);
          var x1, x2, y1, y2;

          if (isHorizontal) {
            x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
            x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
            y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }

          context.lineWidth = axisWidth;
          context.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
          context.beginPath();
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
          context.stroke();
        }
      }
    });
    var defaultConfig = {
      position: 'bottom'
    };
    var scale_category = core_scale.extend({
      /**
      * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
      * else fall back to data.labels
      * @private
      */
      getLabels: function () {
        var data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
      },
      determineDataLimits: function () {
        var me = this;
        var labels = me.getLabels();
        me.minIndex = 0;
        me.maxIndex = labels.length - 1;
        var findIndex;

        if (me.options.ticks.min !== undefined) {
          // user specified min value
          findIndex = labels.indexOf(me.options.ticks.min);
          me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
        }

        if (me.options.ticks.max !== undefined) {
          // user specified max value
          findIndex = labels.indexOf(me.options.ticks.max);
          me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
        }

        me.min = labels[me.minIndex];
        me.max = labels[me.maxIndex];
      },
      buildTicks: function () {
        var me = this;
        var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array

        me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var chart = me.chart;

        if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
          return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
        }

        return me.ticks[index - me.minIndex];
      },
      // Used to get data value locations.  Value can either be an index or a numerical value
      getPixelForValue: function (value, index) {
        var me = this;
        var offset = me.options.offset; // 1 is added because we need the length but we have the indexes

        var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1); // If value is a data object, then index is the index in the data array,
        // not the index of the scale. We need to change that.

        var valueCategory;

        if (value !== undefined && value !== null) {
          valueCategory = me.isHorizontal() ? value.x : value.y;
        }

        if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
          var labels = me.getLabels();
          value = valueCategory || value;
          var idx = labels.indexOf(value);
          index = idx !== -1 ? idx : index;
        }

        if (me.isHorizontal()) {
          var valueWidth = me.width / offsetAmt;
          var widthOffset = valueWidth * (index - me.minIndex);

          if (offset) {
            widthOffset += valueWidth / 2;
          }

          return me.left + widthOffset;
        }

        var valueHeight = me.height / offsetAmt;
        var heightOffset = valueHeight * (index - me.minIndex);

        if (offset) {
          heightOffset += valueHeight / 2;
        }

        return me.top + heightOffset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var offset = me.options.offset;
        var value;
        var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
        var horz = me.isHorizontal();
        var valueDimension = (horz ? me.width : me.height) / offsetAmt;
        pixel -= horz ? me.left : me.top;

        if (offset) {
          pixel -= valueDimension / 2;
        }

        if (pixel <= 0) {
          value = 0;
        } else {
          value = Math.round(pixel / valueDimension);
        }

        return value + me.minIndex;
      },
      getBasePixel: function () {
        return this.bottom;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults = defaultConfig;
    scale_category._defaults = _defaults;
    var noop = helpers$1.noop;
    var isNullOrUndef = helpers$1.isNullOrUndef;
    /**
     * Generate a set of linear ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks(generationOptions, dataRange) {
      var ticks = []; // To get a "nice" value for the tick spacing, we will use the appropriately named
      // "nice number" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
      // for details.

      var MIN_SPACING = 1e-14;
      var stepSize = generationOptions.stepSize;
      var unit = stepSize || 1;
      var maxNumSpaces = generationOptions.maxTicks - 1;
      var min = generationOptions.min;
      var max = generationOptions.max;
      var precision = generationOptions.precision;
      var rmin = dataRange.min;
      var rmax = dataRange.max;
      var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
      var factor, niceMin, niceMax, numSpaces; // Beyond MIN_SPACING floating point numbers being to lose precision
      // such that we can't do the math necessary to generate ticks

      if (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {
        return [rmin, rmax];
      }

      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);

      if (numSpaces > maxNumSpaces) {
        // If the calculated num of spaces exceeds maxNumSpaces, recalculate it
        spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
      }

      if (stepSize || isNullOrUndef(precision)) {
        // If a precision is not specified, calculate factor based on spacing
        factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
      } else {
        // If the user specified a precision, round to that number of decimal places
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
      }

      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.

      if (stepSize) {
        // If very close to our whole number, use it.
        if (!isNullOrUndef(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {
          niceMin = min;
        }

        if (!isNullOrUndef(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {
          niceMax = max;
        }
      }

      numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.

      if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }

      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      ticks.push(isNullOrUndef(min) ? niceMin : min);

      for (var j = 1; j < numSpaces; ++j) {
        ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
      }

      ticks.push(isNullOrUndef(max) ? niceMax : max);
      return ticks;
    }

    var scale_linearbase = core_scale.extend({
      getRightValue: function (value) {
        if (typeof value === 'string') {
          return +value;
        }

        return core_scale.prototype.getRightValue.call(this, value);
      },
      handleTickRangeOptions: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
        // do nothing since that would make the chart weird. If the user really wants a weird chart
        // axis, they can manually override it

        if (tickOpts.beginAtZero) {
          var minSign = helpers$1.sign(me.min);
          var maxSign = helpers$1.sign(me.max);

          if (minSign < 0 && maxSign < 0) {
            // move the top up to 0
            me.max = 0;
          } else if (minSign > 0 && maxSign > 0) {
            // move the bottom down to 0
            me.min = 0;
          }
        }

        var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
        var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

        if (tickOpts.min !== undefined) {
          me.min = tickOpts.min;
        } else if (tickOpts.suggestedMin !== undefined) {
          if (me.min === null) {
            me.min = tickOpts.suggestedMin;
          } else {
            me.min = Math.min(me.min, tickOpts.suggestedMin);
          }
        }

        if (tickOpts.max !== undefined) {
          me.max = tickOpts.max;
        } else if (tickOpts.suggestedMax !== undefined) {
          if (me.max === null) {
            me.max = tickOpts.suggestedMax;
          } else {
            me.max = Math.max(me.max, tickOpts.suggestedMax);
          }
        }

        if (setMin !== setMax) {
          // We set the min or the max but not both.
          // So ensure that our range is good
          // Inverted or 0 length range can happen when
          // ticks.min is set, and no datasets are visible
          if (me.min >= me.max) {
            if (setMin) {
              me.max = me.min + 1;
            } else {
              me.min = me.max - 1;
            }
          }
        }

        if (me.min === me.max) {
          me.max++;

          if (!tickOpts.beginAtZero) {
            me.min--;
          }
        }
      },
      getTickLimit: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var stepSize = tickOpts.stepSize;
        var maxTicksLimit = tickOpts.maxTicksLimit;
        var maxTicks;

        if (stepSize) {
          maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
        } else {
          maxTicks = me._computeTickLimit();
          maxTicksLimit = maxTicksLimit || 11;
        }

        if (maxTicksLimit) {
          maxTicks = Math.min(maxTicksLimit, maxTicks);
        }

        return maxTicks;
      },
      _computeTickLimit: function () {
        return Number.POSITIVE_INFINITY;
      },
      handleDirectionalChanges: noop,
      buildTicks: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of
        // the axis area. For now, we say that the minimum tick spacing in pixels must be 40
        // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
        // the graph. Make sure we always have at least 2 ticks

        var maxTicks = me.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        var numericGeneratorOptions = {
          maxTicks: maxTicks,
          min: tickOpts.min,
          max: tickOpts.max,
          precision: tickOpts.precision,
          stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
        };
        var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
        me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          ticks.reverse();
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }
      },
      convertTicksToLabels: function () {
        var me = this;
        me.ticksAsNumbers = me.ticks.slice();
        me.zeroLineIndex = me.ticks.indexOf(0);
        core_scale.prototype.convertTicksToLabels.call(me);
      }
    });
    var defaultConfig$1 = {
      position: 'left',
      ticks: {
        callback: core_ticks.formatters.linear
      }
    };
    var scale_linear = scale_linearbase.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();
        var DEFAULT_MIN = 0;
        var DEFAULT_MAX = 1;

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // First Calculate the range


        me.min = null;
        me.max = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (valuesPerStack[key] === undefined) {
              valuesPerStack[key] = {
                positiveValues: [],
                negativeValues: []
              };
            } // Store these per type


            var positiveValues = valuesPerStack[key].positiveValues;
            var negativeValues = valuesPerStack[key].negativeValues;

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                positiveValues[index] = positiveValues[index] || 0;
                negativeValues[index] = negativeValues[index] || 0;

                if (opts.relativePoints) {
                  positiveValues[index] = 100;
                } else if (value < 0) {
                  negativeValues[index] += value;
                } else {
                  positiveValues[index] += value;
                }
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
            var minVal = helpers$1.min(values);
            var maxVal = helpers$1.max(values);
            me.min = me.min === null ? minVal : Math.min(me.min, minVal);
            me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }
              });
            }
          });
        }

        me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
        me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        this.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        var me = this;
        var tickFont;

        if (me.isHorizontal()) {
          return Math.ceil(me.width / 40);
        }

        tickFont = helpers$1.options._parseFont(me.options.ticks);
        return Math.ceil(me.height / tickFont.lineHeight);
      },
      // Called after the ticks are built. We need
      handleDirectionalChanges: function () {
        if (!this.isHorizontal()) {
          // We are in a vertical orientation. The top value is the highest. So reverse the array
          this.ticks.reverse();
        }
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      // Utils
      getPixelForValue: function (value) {
        // This must be called after fit has been run so that
        // this.left, this.top, this.right, and this.bottom have been defined
        var me = this;
        var start = me.start;
        var rightValue = +me.getRightValue(value);
        var pixel;
        var range = me.end - start;

        if (me.isHorizontal()) {
          pixel = me.left + me.width / range * (rightValue - start);
        } else {
          pixel = me.bottom - me.height / range * (rightValue - start);
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var innerDimension = isHorizontal ? me.width : me.height;
        var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
        return me.start + (me.end - me.start) * offset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticksAsNumbers[index]);
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$1 = defaultConfig$1;
    scale_linear._defaults = _defaults$1;
    var valueOrDefault$a = helpers$1.valueOrDefault;
    /**
     * Generate a set of logarithmic ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks$1(generationOptions, dataRange) {
      var ticks = [];
      var tickVal = valueOrDefault$a(generationOptions.min, Math.pow(10, Math.floor(helpers$1.log10(dataRange.min))));
      var endExp = Math.floor(helpers$1.log10(dataRange.max));
      var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
      var exp, significand;

      if (tickVal === 0) {
        exp = Math.floor(helpers$1.log10(dataRange.minNotZero));
        significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
        ticks.push(tickVal);
        tickVal = significand * Math.pow(10, exp);
      } else {
        exp = Math.floor(helpers$1.log10(tickVal));
        significand = Math.floor(tickVal / Math.pow(10, exp));
      }

      var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

      do {
        ticks.push(tickVal);
        ++significand;

        if (significand === 10) {
          significand = 1;
          ++exp;
          precision = exp >= 0 ? 1 : precision;
        }

        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
      } while (exp < endExp || exp === endExp && significand < endSignificand);

      var lastTick = valueOrDefault$a(generationOptions.max, tickVal);
      ticks.push(lastTick);
      return ticks;
    }

    var defaultConfig$2 = {
      position: 'left',
      // label settings
      ticks: {
        callback: core_ticks.formatters.logarithmic
      }
    }; // TODO(v3): change this to positiveOrDefault

    function nonNegativeOrDefault(value, defaultValue) {
      return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
    }

    var scale_logarithmic = core_scale.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // Calculate Range


        me.min = null;
        me.max = null;
        me.minNotZero = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              if (valuesPerStack[key] === undefined) {
                valuesPerStack[key] = [];
              }

              helpers$1.each(dataset.data, function (rawValue, index) {
                var values = valuesPerStack[key];
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                values[index] = values[index] || 0;
                values[index] += value;
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            if (valuesForType.length > 0) {
              var minVal = helpers$1.min(valuesForType);
              var maxVal = helpers$1.max(valuesForType);
              me.min = me.min === null ? minVal : Math.min(me.min, minVal);
              me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
            }
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }

                if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                  me.minNotZero = value;
                }
              });
            }
          });
        } // Common base implementation to handle ticks.min, ticks.max


        this.handleTickRangeOptions();
      },
      handleTickRangeOptions: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var DEFAULT_MIN = 1;
        var DEFAULT_MAX = 10;
        me.min = nonNegativeOrDefault(tickOpts.min, me.min);
        me.max = nonNegativeOrDefault(tickOpts.max, me.max);

        if (me.min === me.max) {
          if (me.min !== 0 && me.min !== null) {
            me.min = Math.pow(10, Math.floor(helpers$1.log10(me.min)) - 1);
            me.max = Math.pow(10, Math.floor(helpers$1.log10(me.max)) + 1);
          } else {
            me.min = DEFAULT_MIN;
            me.max = DEFAULT_MAX;
          }
        }

        if (me.min === null) {
          me.min = Math.pow(10, Math.floor(helpers$1.log10(me.max)) - 1);
        }

        if (me.max === null) {
          me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers$1.log10(me.min)) + 1) : DEFAULT_MAX;
        }

        if (me.minNotZero === null) {
          if (me.min > 0) {
            me.minNotZero = me.min;
          } else if (me.max < 1) {
            me.minNotZero = Math.pow(10, Math.floor(helpers$1.log10(me.max)));
          } else {
            me.minNotZero = DEFAULT_MIN;
          }
        }
      },
      buildTicks: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = !me.isHorizontal();
        var generationOptions = {
          min: nonNegativeOrDefault(tickOpts.min),
          max: nonNegativeOrDefault(tickOpts.max)
        };
        var ticks = me.ticks = generateTicks$1(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          reverse = !reverse;
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }

        if (reverse) {
          ticks.reverse();
        }
      },
      convertTicksToLabels: function () {
        this.tickValues = this.ticks.slice();
        core_scale.prototype.convertTicksToLabels.call(this);
      },
      // Get the correct tooltip label
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.tickValues[index]);
      },

      /**
       * Returns the value of the first tick.
       * @param {number} value - The minimum not zero value.
       * @return {number} The first tick value.
       * @private
       */
      _getFirstTickValue: function (value) {
        var exp = Math.floor(helpers$1.log10(value));
        var significand = Math.floor(value / Math.pow(10, exp));
        return significand * Math.pow(10, exp);
      },
      getPixelForValue: function (value) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var offset = 0;
        var innerDimension, pixel, start, end, sign;
        value = +me.getRightValue(value);

        if (reverse) {
          start = me.end;
          end = me.start;
          sign = -1;
        } else {
          start = me.start;
          end = me.end;
          sign = 1;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          pixel = reverse ? me.right : me.left;
        } else {
          innerDimension = me.height;
          sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)

          pixel = reverse ? me.top : me.bottom;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            innerDimension -= offset;
            start = firstTickValue;
          }

          if (value !== 0) {
            offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
          }

          pixel += sign * offset;
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var innerDimension, start, end, value;

        if (reverse) {
          start = me.end;
          end = me.start;
        } else {
          start = me.start;
          end = me.end;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          value = reverse ? me.right - pixel : pixel - me.left;
        } else {
          innerDimension = me.height;
          value = reverse ? pixel - me.top : me.bottom - pixel;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            var offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            value -= offset;
            innerDimension -= offset;
            start = firstTickValue;
          }

          value *= log10(end) - log10(start);
          value /= innerDimension;
          value = Math.pow(10, log10(start) + value);
        }

        return value;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$2 = defaultConfig$2;
    scale_logarithmic._defaults = _defaults$2;
    var valueOrDefault$b = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
    var resolve$7 = helpers$1.options.resolve;
    var defaultConfig$3 = {
      display: true,
      // Boolean - Whether to animate scaling the chart from the centre
      animate: true,
      position: 'chartArea',
      angleLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0.0
      },
      gridLines: {
        circular: false
      },
      // label settings
      ticks: {
        // Boolean - Show a backdrop to the scale label
        showLabelBackdrop: true,
        // String - The colour of the label backdrop
        backdropColor: 'rgba(255,255,255,0.75)',
        // Number - The backdrop padding above & below the label in pixels
        backdropPaddingY: 2,
        // Number - The backdrop padding to the side of the label in pixels
        backdropPaddingX: 2,
        callback: core_ticks.formatters.linear
      },
      pointLabels: {
        // Boolean - if true, show point labels
        display: true,
        // Number - Point label font size in pixels
        fontSize: 10,
        // Function - Used to convert point labels
        callback: function (label) {
          return label;
        }
      }
    };

    function getValueCount(scale) {
      var opts = scale.options;
      return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
    }

    function getTickBackdropHeight(opts) {
      var tickOpts = opts.ticks;

      if (tickOpts.display && opts.display) {
        return valueOrDefault$b(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
      }

      return 0;
    }

    function measureLabelSize(ctx, lineHeight, label) {
      if (helpers$1.isArray(label)) {
        return {
          w: helpers$1.longestText(ctx, ctx.font, label),
          h: label.length * lineHeight
        };
      }

      return {
        w: ctx.measureText(label).width,
        h: lineHeight
      };
    }

    function determineLimits(angle, pos, size, min, max) {
      if (angle === min || angle === max) {
        return {
          start: pos - size / 2,
          end: pos + size / 2
        };
      } else if (angle < min || angle > max) {
        return {
          start: pos - size,
          end: pos
        };
      }

      return {
        start: pos,
        end: pos + size
      };
    }
    /**
     * Helper function to fit a radial linear scale with point labels
     */


    function fitWithPointLabels(scale) {
      // Right, this is really confusing and there is a lot of maths going on here
      // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
      //
      // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
      //
      // Solution:
      //
      // We assume the radius of the polygon is half the size of the canvas at first
      // at each index we check if the text overlaps.
      //
      // Where it does, we store that angle and that index.
      //
      // After finding the largest index and angle we calculate how much we need to remove
      // from the shape radius to move the point inwards by that x.
      //
      // We average the left and right distances to get the maximum shape radius that can fit in the box
      // along with labels.
      //
      // Once we have that, we can find the centre point for the chart, by taking the x text protrusion
      // on each side, removing that from the size, halving it and adding the left x protrusion width.
      //
      // This will mean we have a shape fitted to the canvas, as large as it can be with the labels
      // and position it in the most space efficient manner
      //
      // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
      var plFont = helpers$1.options._parseFont(scale.options.pointLabels); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
      // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points


      var furthestLimits = {
        l: 0,
        r: scale.width,
        t: 0,
        b: scale.height - scale.paddingTop
      };
      var furthestAngles = {};
      var i, textSize, pointPosition;
      scale.ctx.font = plFont.string;
      scale._pointLabelSizes = [];
      var valueCount = getValueCount(scale);

      for (i = 0; i < valueCount; i++) {
        pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
        textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');
        scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle

        var angleRadians = scale.getIndexAngle(i);
        var angle = helpers$1.toDegrees(angleRadians) % 360;
        var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

        if (hLimits.start < furthestLimits.l) {
          furthestLimits.l = hLimits.start;
          furthestAngles.l = angleRadians;
        }

        if (hLimits.end > furthestLimits.r) {
          furthestLimits.r = hLimits.end;
          furthestAngles.r = angleRadians;
        }

        if (vLimits.start < furthestLimits.t) {
          furthestLimits.t = vLimits.start;
          furthestAngles.t = angleRadians;
        }

        if (vLimits.end > furthestLimits.b) {
          furthestLimits.b = vLimits.end;
          furthestAngles.b = angleRadians;
        }
      }

      scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
    }

    function getTextAlignForAngle(angle) {
      if (angle === 0 || angle === 180) {
        return 'center';
      } else if (angle < 180) {
        return 'left';
      }

      return 'right';
    }

    function fillText(ctx, text, position, lineHeight) {
      var y = position.y + lineHeight / 2;
      var i, ilen;

      if (helpers$1.isArray(text)) {
        for (i = 0, ilen = text.length; i < ilen; ++i) {
          ctx.fillText(text[i], position.x, y);
          y += lineHeight;
        }
      } else {
        ctx.fillText(text, position.x, y);
      }
    }

    function adjustPointPositionForLabelHeight(angle, textSize, position) {
      if (angle === 90 || angle === 270) {
        position.y -= textSize.h / 2;
      } else if (angle > 270 || angle < 90) {
        position.y -= textSize.h;
      }
    }

    function drawPointLabels(scale) {
      var ctx = scale.ctx;
      var opts = scale.options;
      var angleLineOpts = opts.angleLines;
      var gridLineOpts = opts.gridLines;
      var pointLabelOpts = opts.pointLabels;
      var lineWidth = valueOrDefault$b(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
      var lineColor = valueOrDefault$b(angleLineOpts.color, gridLineOpts.color);
      var tickBackdropHeight = getTickBackdropHeight(opts);
      ctx.save();
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = lineColor;

      if (ctx.setLineDash) {
        ctx.setLineDash(resolve$7([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
        ctx.lineDashOffset = resolve$7([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);
      }

      var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max); // Point Label Font

      var plFont = helpers$1.options._parseFont(pointLabelOpts);

      ctx.font = plFont.string;
      ctx.textBaseline = 'middle';

      for (var i = getValueCount(scale) - 1; i >= 0; i--) {
        if (angleLineOpts.display && lineWidth && lineColor) {
          var outerPosition = scale.getPointPosition(i, outerDistance);
          ctx.beginPath();
          ctx.moveTo(scale.xCenter, scale.yCenter);
          ctx.lineTo(outerPosition.x, outerPosition.y);
          ctx.stroke();
        }

        if (pointLabelOpts.display) {
          // Extra pixels out for some label spacing
          var extra = i === 0 ? tickBackdropHeight / 2 : 0;
          var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5); // Keep this in loop since we may support array properties here

          var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
          ctx.fillStyle = pointLabelFontColor;
          var angleRadians = scale.getIndexAngle(i);
          var angle = helpers$1.toDegrees(angleRadians);
          ctx.textAlign = getTextAlignForAngle(angle);
          adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
          fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);
        }
      }

      ctx.restore();
    }

    function drawRadiusLine(scale, gridLineOpts, radius, index) {
      var ctx = scale.ctx;
      var circular = gridLineOpts.circular;
      var valueCount = getValueCount(scale);
      var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
      var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
      var pointPosition;

      if (!circular && !valueCount || !lineColor || !lineWidth) {
        return;
      }

      ctx.save();
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = lineWidth;

      if (ctx.setLineDash) {
        ctx.setLineDash(gridLineOpts.borderDash || []);
        ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;
      }

      ctx.beginPath();

      if (circular) {
        // Draw circular arcs between the points
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
      } else {
        // Draw straight lines connecting each index
        pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);

        for (var i = 1; i < valueCount; i++) {
          pointPosition = scale.getPointPosition(i, radius);
          ctx.lineTo(pointPosition.x, pointPosition.y);
        }
      }

      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    function numberOrZero(param) {
      return helpers$1.isNumber(param) ? param : 0;
    }

    var scale_radialLinear = scale_linearbase.extend({
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        me.width = me.maxWidth;
        me.height = me.maxHeight;
        me.paddingTop = getTickBackdropHeight(me.options) / 2;
        me.xCenter = Math.floor(me.width / 2);
        me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
        me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var min = Number.POSITIVE_INFINITY;
        var max = Number.NEGATIVE_INFINITY;
        helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {
          if (chart.isDatasetVisible(datasetIndex)) {
            var meta = chart.getDatasetMeta(datasetIndex);
            helpers$1.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue);

              if (isNaN(value) || meta.data[index].hidden) {
                return;
              }

              min = Math.min(value, min);
              max = Math.max(value, max);
            });
          }
        });
        me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
        me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        me.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
      },
      convertTicksToLabels: function () {
        var me = this;
        scale_linearbase.prototype.convertTicksToLabels.call(me); // Point labels

        me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      fit: function () {
        var me = this;
        var opts = me.options;

        if (opts.display && opts.pointLabels.display) {
          fitWithPointLabels(me);
        } else {
          me.setCenterPoint(0, 0, 0, 0);
        }
      },

      /**
       * Set radius reductions and determine new radius and center point
       * @private
       */
      setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {
        var me = this;
        var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
        var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
        var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
        var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
        radiusReductionLeft = numberOrZero(radiusReductionLeft);
        radiusReductionRight = numberOrZero(radiusReductionRight);
        radiusReductionTop = numberOrZero(radiusReductionTop);
        radiusReductionBottom = numberOrZero(radiusReductionBottom);
        me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
        me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
      },
      setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {
        var me = this;
        var maxRight = me.width - rightMovement - me.drawingArea;
        var maxLeft = leftMovement + me.drawingArea;
        var maxTop = topMovement + me.drawingArea;
        var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
        me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
        me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
      },
      getIndexAngle: function (index) {
        var angleMultiplier = Math.PI * 2 / getValueCount(this);
        var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
        var startAngleRadians = startAngle * Math.PI * 2 / 360; // Start from the top instead of right, so remove a quarter of the circle

        return index * angleMultiplier + startAngleRadians;
      },
      getDistanceFromCenterForValue: function (value) {
        var me = this;

        if (value === null) {
          return 0; // null always in center
        } // Take into account half font size + the yPadding of the top value


        var scalingFactor = me.drawingArea / (me.max - me.min);

        if (me.options.ticks.reverse) {
          return (me.max - value) * scalingFactor;
        }

        return (value - me.min) * scalingFactor;
      },
      getPointPosition: function (index, distanceFromCenter) {
        var me = this;
        var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
        return {
          x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
          y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
        };
      },
      getPointPositionForValue: function (index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
      },
      getBasePosition: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
      },
      draw: function () {
        var me = this;
        var opts = me.options;
        var gridLineOpts = opts.gridLines;
        var tickOpts = opts.ticks;

        if (opts.display) {
          var ctx = me.ctx;
          var startAngle = this.getIndexAngle(0);

          var tickFont = helpers$1.options._parseFont(tickOpts);

          if (opts.angleLines.display || opts.pointLabels.display) {
            drawPointLabels(me);
          }

          helpers$1.each(me.ticks, function (label, index) {
            // Don't draw a centre value (if it is minimum)
            if (index > 0 || tickOpts.reverse) {
              var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]); // Draw circular lines around the scale

              if (gridLineOpts.display && index !== 0) {
                drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
              }

              if (tickOpts.display) {
                var tickFontColor = valueOrDefault$b(tickOpts.fontColor, core_defaults.global.defaultFontColor);
                ctx.font = tickFont.string;
                ctx.save();
                ctx.translate(me.xCenter, me.yCenter);
                ctx.rotate(startAngle);

                if (tickOpts.showLabelBackdrop) {
                  var labelWidth = ctx.measureText(label).width;
                  ctx.fillStyle = tickOpts.backdropColor;
                  ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
                }

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = tickFontColor;
                ctx.fillText(label, 0, -yCenterOffset);
                ctx.restore();
              }
            }
          });
        }
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$3 = defaultConfig$3;
    scale_radialLinear._defaults = _defaults$3;
    var valueOrDefault$c = helpers$1.valueOrDefault; // Integer constants are from the ES6 spec.

    var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var INTERVALS = {
      millisecond: {
        common: true,
        size: 1,
        steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
      },
      second: {
        common: true,
        size: 1000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      minute: {
        common: true,
        size: 60000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      hour: {
        common: true,
        size: 3600000,
        steps: [1, 2, 3, 6, 12]
      },
      day: {
        common: true,
        size: 86400000,
        steps: [1, 2, 5]
      },
      week: {
        common: false,
        size: 604800000,
        steps: [1, 2, 3, 4]
      },
      month: {
        common: true,
        size: 2.628e9,
        steps: [1, 2, 3]
      },
      quarter: {
        common: false,
        size: 7.884e9,
        steps: [1, 2, 3, 4]
      },
      year: {
        common: true,
        size: 3.154e10
      }
    };
    var UNITS = Object.keys(INTERVALS);

    function sorter(a, b) {
      return a - b;
    }

    function arrayUnique(items) {
      var hash = {};
      var out = [];
      var i, ilen, item;

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];

        if (!hash[item]) {
          hash[item] = true;
          out.push(item);
        }
      }

      return out;
    }
    /**
     * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
     * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
     * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
     * extremity (left + width or top + height). Note that it would be more optimized to directly
     * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
     * to create the lookup table. The table ALWAYS contains at least two items: min and max.
     *
     * @param {number[]} timestamps - timestamps sorted from lowest to highest.
     * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min
     * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
     * If 'series', timestamps will be positioned at the same distance from each other. In this
     * case, only timestamps that break the time linearity are registered, meaning that in the
     * best case, all timestamps are linear, the table contains only min and max.
     */


    function buildLookupTable(timestamps, min, max, distribution) {
      if (distribution === 'linear' || !timestamps.length) {
        return [{
          time: min,
          pos: 0
        }, {
          time: max,
          pos: 1
        }];
      }

      var table = [];
      var items = [min];
      var i, ilen, prev, curr, next;

      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];

        if (curr > min && curr < max) {
          items.push(curr);
        }
      }

      items.push(max);

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i]; // only add points that breaks the scale linearity

        if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }

      return table;
    } // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/


    function lookup(table, key, value) {
      var lo = 0;
      var hi = table.length - 1;
      var mid, i0, i1;

      while (lo >= 0 && lo <= hi) {
        mid = lo + hi >> 1;
        i0 = table[mid - 1] || null;
        i1 = table[mid];

        if (!i0) {
          // given value is outside table (before first item)
          return {
            lo: null,
            hi: i1
          };
        } else if (i1[key] < value) {
          lo = mid + 1;
        } else if (i0[key] > value) {
          hi = mid - 1;
        } else {
          return {
            lo: i0,
            hi: i1
          };
        }
      } // given value is outside table (after last item)


      return {
        lo: i1,
        hi: null
      };
    }
    /**
     * Linearly interpolates the given source `value` using the table items `skey` values and
     * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
     * returns the position for a timestamp equal to 42. If value is out of bounds, values at
     * index [0, 1] or [n - 1, n] are used for the interpolation.
     */


    function interpolate$1(table, skey, sval, tkey) {
      var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)

      var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
      var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
      var span = next[skey] - prev[skey];
      var ratio = span ? (sval - prev[skey]) / span : 0;
      var offset = (next[tkey] - prev[tkey]) * ratio;
      return prev[tkey] + offset;
    }

    function toTimestamp(scale, input) {
      var adapter = scale._adapter;
      var options = scale.options.time;
      var parser = options.parser;
      var format = parser || options.format;
      var value = input;

      if (typeof parser === 'function') {
        value = parser(value);
      } // Only parse if its not a timestamp already


      if (!helpers$1.isFinite(value)) {
        value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);
      }

      if (value !== null) {
        return +value;
      } // Labels are in an incompatible format and no `parser` has been provided.
      // The user might still use the deprecated `format` option for parsing.


      if (!parser && typeof format === 'function') {
        value = format(input); // `format` could return something else than a timestamp, if so, parse it

        if (!helpers$1.isFinite(value)) {
          value = adapter.parse(value);
        }
      }

      return value;
    }

    function parse(scale, input) {
      if (helpers$1.isNullOrUndef(input)) {
        return null;
      }

      var options = scale.options.time;
      var value = toTimestamp(scale, scale.getRightValue(input));

      if (value === null) {
        return value;
      }

      if (options.round) {
        value = +scale._adapter.startOf(value, options.round);
      }

      return value;
    }
    /**
     * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
     * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
     */


    function determineStepSize(min, max, unit, capacity) {
      var range = max - min;
      var interval = INTERVALS[unit];
      var milliseconds = interval.size;
      var steps = interval.steps;
      var i, ilen, factor;

      if (!steps) {
        return Math.ceil(range / (capacity * milliseconds));
      }

      for (i = 0, ilen = steps.length; i < ilen; ++i) {
        factor = steps[i];

        if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
          break;
        }
      }

      return factor;
    }
    /**
     * Figures out what unit results in an appropriate number of auto-generated ticks
     */


    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      var ilen = UNITS.length;
      var i, interval, factor;

      for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
        interval = INTERVALS[UNITS[i]];
        factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
          return UNITS[i];
        }
      }

      return UNITS[ilen - 1];
    }
    /**
     * Figures out what unit to format a set of ticks with
     */


    function determineUnitForFormatting(scale, ticks, minUnit, min, max) {
      var ilen = UNITS.length;
      var i, unit;

      for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
        unit = UNITS[i];

        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {
          return unit;
        }
      }

      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }

    function determineMajorUnit(unit) {
      for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
        if (INTERVALS[UNITS[i]].common) {
          return UNITS[i];
        }
      }
    }
    /**
     * Generates a maximum of `capacity` timestamps between min and max, rounded to the
     * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
     * Important: this method can return ticks outside the min and max range, it's the
     * responsibility of the calling code to clamp values if needed.
     */


    function generate(scale, min, max, capacity) {
      var adapter = scale._adapter;
      var options = scale.options;
      var timeOpts = options.time;
      var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
      var major = determineMajorUnit(minor);
      var stepSize = valueOrDefault$c(timeOpts.stepSize, timeOpts.unitStepSize);
      var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
      var majorTicksEnabled = options.ticks.major.enabled;
      var interval = INTERVALS[minor];
      var first = min;
      var last = max;
      var ticks = [];
      var time;

      if (!stepSize) {
        stepSize = determineStepSize(min, max, minor, capacity);
      } // For 'week' unit, handle the first day of week option


      if (weekday) {
        first = +adapter.startOf(first, 'isoWeek', weekday);
        last = +adapter.startOf(last, 'isoWeek', weekday);
      } // Align first/last ticks on unit


      first = +adapter.startOf(first, weekday ? 'day' : minor);
      last = +adapter.startOf(last, weekday ? 'day' : minor); // Make sure that the last tick include max

      if (last < max) {
        last = +adapter.add(last, 1, minor);
      }

      time = first;

      if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
        // Align the first tick on the previous `minor` unit aligned on the `major` unit:
        // we first aligned time on the previous `major` unit then add the number of full
        // stepSize there is between first and the previous major time.
        time = +adapter.startOf(time, major);
        time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
      }

      for (; time < last; time = +adapter.add(time, stepSize, minor)) {
        ticks.push(+time);
      }

      ticks.push(+time);
      return ticks;
    }
    /**
     * Returns the start and end offsets from edges in the form of {start, end}
     * where each value is a relative width to the scale and ranges between 0 and 1.
     * They add extra margins on the both sides by scaling down the original scale.
     * Offsets are added when the `offset` option is true.
     */


    function computeOffsets(table, ticks, min, max, options) {
      var start = 0;
      var end = 0;
      var first, last;

      if (options.offset && ticks.length) {
        if (!options.time.min) {
          first = interpolate$1(table, 'time', ticks[0], 'pos');

          if (ticks.length === 1) {
            start = 1 - first;
          } else {
            start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;
          }
        }

        if (!options.time.max) {
          last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');

          if (ticks.length === 1) {
            end = last;
          } else {
            end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;
          }
        }
      }

      return {
        start: start,
        end: end
      };
    }

    function ticksFromTimestamps(scale, values, majorUnit) {
      var ticks = [];
      var i, ilen, value, major;

      for (i = 0, ilen = values.length; i < ilen; ++i) {
        value = values[i];
        major = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;
        ticks.push({
          value: value,
          major: major
        });
      }

      return ticks;
    }

    var defaultConfig$4 = {
      position: 'bottom',

      /**
       * Data distribution along the scale:
       * - 'linear': data are spread according to their time (distances can vary),
       * - 'series': data are spread at the same distance from each other.
       * @see https://github.com/chartjs/Chart.js/pull/4507
       * @since 2.7.0
       */
      distribution: 'linear',

      /**
       * Scale boundary strategy (bypassed by min/max time options)
       * - `data`: make sure data are fully visible, ticks outside are removed
       * - `ticks`: make sure ticks are fully visible, data outside are truncated
       * @see https://github.com/chartjs/Chart.js/pull/4556
       * @since 2.7.0
       */
      bounds: 'data',
      adapters: {},
      time: {
        parser: false,
        // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
        format: false,
        // DEPRECATED false == date objects, moment object, callback or a pattern string from https://momentjs.com/docs/#/parsing/string-format/
        unit: false,
        // false == automatic or override with week, month, year, etc.
        round: false,
        // none, or override with week, month, year, etc.
        displayFormat: false,
        // DEPRECATED
        isoWeekday: false,
        // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
        minUnit: 'millisecond',
        displayFormats: {}
      },
      ticks: {
        autoSkip: false,

        /**
         * Ticks generation input values:
         * - 'auto': generates "optimal" ticks based on scale size and time options.
         * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
         * - 'labels': generates ticks from user given `data.labels` values ONLY.
         * @see https://github.com/chartjs/Chart.js/pull/4507
         * @since 2.7.0
         */
        source: 'auto',
        major: {
          enabled: false
        }
      }
    };
    var scale_time = core_scale.extend({
      initialize: function () {
        this.mergeTicksOptions();
        core_scale.prototype.initialize.call(this);
      },
      update: function () {
        var me = this;
        var options = me.options;
        var time = options.time || (options.time = {});
        var adapter = me._adapter = new core_adapters._date(options.adapters.date); // DEPRECATIONS: output a message only one time per update

        if (time.format) {
          console.warn('options.time.format is deprecated and replaced by options.time.parser.');
        } // Backward compatibility: before introducing adapter, `displayFormats` was
        // supposed to contain *all* unit/string pairs but this can't be resolved
        // when loading the scale (adapters are loaded afterward), so let's populate
        // missing formats on update


        helpers$1.mergeIf(time.displayFormats, adapter.formats());
        return core_scale.prototype.update.apply(me, arguments);
      },

      /**
       * Allows data to be referenced via 't' attribute
       */
      getRightValue: function (rawValue) {
        if (rawValue && rawValue.t !== undefined) {
          rawValue = rawValue.t;
        }

        return core_scale.prototype.getRightValue.call(this, rawValue);
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var adapter = me._adapter;
        var timeOpts = me.options.time;
        var unit = timeOpts.unit || 'day';
        var min = MAX_INTEGER;
        var max = MIN_INTEGER;
        var timestamps = [];
        var datasets = [];
        var labels = [];
        var i, j, ilen, jlen, data, timestamp;
        var dataLabels = chart.data.labels || []; // Convert labels to timestamps

        for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
          labels.push(parse(me, dataLabels[i]));
        } // Convert data to timestamps


        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            data = chart.data.datasets[i].data; // Let's consider that all data have the same format.

            if (helpers$1.isObject(data[0])) {
              datasets[i] = [];

              for (j = 0, jlen = data.length; j < jlen; ++j) {
                timestamp = parse(me, data[j]);
                timestamps.push(timestamp);
                datasets[i][j] = timestamp;
              }
            } else {
              for (j = 0, jlen = labels.length; j < jlen; ++j) {
                timestamps.push(labels[j]);
              }

              datasets[i] = labels.slice(0);
            }
          } else {
            datasets[i] = [];
          }
        }

        if (labels.length) {
          // Sort labels **after** data have been converted
          labels = arrayUnique(labels).sort(sorter);
          min = Math.min(min, labels[0]);
          max = Math.max(max, labels[labels.length - 1]);
        }

        if (timestamps.length) {
          timestamps = arrayUnique(timestamps).sort(sorter);
          min = Math.min(min, timestamps[0]);
          max = Math.max(max, timestamps[timestamps.length - 1]);
        }

        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // In case there is no valid min/max, set limits based on unit time option

        min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
        max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)

        me.min = Math.min(min, max);
        me.max = Math.max(min + 1, max); // PRIVATE

        me._horizontal = me.isHorizontal();
        me._table = [];
        me._timestamps = {
          data: timestamps,
          datasets: datasets,
          labels: labels
        };
      },
      buildTicks: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        var options = me.options;
        var timeOpts = options.time;
        var timestamps = [];
        var ticks = [];
        var i, ilen, timestamp;

        switch (options.ticks.source) {
          case 'data':
            timestamps = me._timestamps.data;
            break;

          case 'labels':
            timestamps = me._timestamps.labels;
            break;

          case 'auto':
          default:
            timestamps = generate(me, min, max, me.getLabelCapacity(min), options);
        }

        if (options.bounds === 'ticks' && timestamps.length) {
          min = timestamps[0];
          max = timestamps[timestamps.length - 1];
        } // Enforce limits with user min/max options


        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // Remove ticks outside the min/max range

        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
          timestamp = timestamps[i];

          if (timestamp >= min && timestamp <= max) {
            ticks.push(timestamp);
          }
        }

        me.min = min;
        me.max = max; // PRIVATE

        me._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);
        me._majorUnit = determineMajorUnit(me._unit);
        me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
        me._offsets = computeOffsets(me._table, ticks, min, max, options);

        if (options.ticks.reverse) {
          ticks.reverse();
        }

        return ticksFromTimestamps(me, ticks, me._majorUnit);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var adapter = me._adapter;
        var data = me.chart.data;
        var timeOpts = me.options.time;
        var label = data.labels && index < data.labels.length ? data.labels[index] : '';
        var value = data.datasets[datasetIndex].data[index];

        if (helpers$1.isObject(value)) {
          label = me.getRightValue(value);
        }

        if (timeOpts.tooltipFormat) {
          return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
        }

        if (typeof label === 'string') {
          return label;
        }

        return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
      },

      /**
       * Function to format an individual tick mark
       * @private
       */
      tickFormatFunction: function (time, index, ticks, format) {
        var me = this;
        var adapter = me._adapter;
        var options = me.options;
        var formats = options.time.displayFormats;
        var minorFormat = formats[me._unit];
        var majorUnit = me._majorUnit;
        var majorFormat = formats[majorUnit];
        var majorTime = +adapter.startOf(time, majorUnit);
        var majorTickOpts = options.ticks.major;
        var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
        var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
        var tickOpts = major ? majorTickOpts : options.ticks.minor;
        var formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);
        return formatter ? formatter(label, index, ticks) : label;
      },
      convertTicksToLabels: function (ticks) {
        var labels = [];
        var i, ilen;

        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
        }

        return labels;
      },

      /**
       * @private
       */
      getPixelForOffset: function (time) {
        var me = this;
        var isReverse = me.options.ticks.reverse;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;
        var pos = interpolate$1(me._table, 'time', time, 'pos');
        var offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);
        return isReverse ? start - offset : start + offset;
      },
      getPixelForValue: function (value, index, datasetIndex) {
        var me = this;
        var time = null;

        if (index !== undefined && datasetIndex !== undefined) {
          time = me._timestamps.datasets[datasetIndex][index];
        }

        if (time === null) {
          time = parse(me, value);
        }

        if (time !== null) {
          return me.getPixelForOffset(time);
        }
      },
      getPixelForTick: function (index) {
        var ticks = this.getTicks();
        return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? me.left : me.top;
        var pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;
        var time = interpolate$1(me._table, 'pos', pos, 'time'); // DEPRECATION, we should return time directly

        return me._adapter._create(time);
      },

      /**
       * Crude approximation of what the label width might be
       * @private
       */
      getLabelWidth: function (label) {
        var me = this;
        var ticksOpts = me.options.ticks;
        var tickLabelWidth = me.ctx.measureText(label).width;
        var angle = helpers$1.toRadians(ticksOpts.maxRotation);
        var cosRotation = Math.cos(angle);
        var sinRotation = Math.sin(angle);
        var tickFontSize = valueOrDefault$c(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
        return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
      },

      /**
       * @private
       */
      getLabelCapacity: function (exampleTime) {
        var me = this; // pick the longest format (milliseconds) for guestimation

        var format = me.options.time.displayFormats.millisecond;
        var exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);
        var tickLabelWidth = me.getLabelWidth(exampleLabel);
        var innerWidth = me.isHorizontal() ? me.width : me.height;
        var capacity = Math.floor(innerWidth / tickLabelWidth);
        return capacity > 0 ? capacity : 1;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$4 = defaultConfig$4;
    scale_time._defaults = _defaults$4;
    var scales = {
      category: scale_category,
      linear: scale_linear,
      logarithmic: scale_logarithmic,
      radialLinear: scale_radialLinear,
      time: scale_time
    };
    var FORMATS = {
      datetime: 'MMM D, YYYY, h:mm:ss a',
      millisecond: 'h:mm:ss.SSS a',
      second: 'h:mm:ss a',
      minute: 'h:mm a',
      hour: 'hA',
      day: 'MMM D',
      week: 'll',
      month: 'MMM YYYY',
      quarter: '[Q]Q - YYYY',
      year: 'YYYY'
    };

    core_adapters._date.override(typeof moment === 'function' ? {
      _id: 'moment',
      // DEBUG ONLY
      formats: function () {
        return FORMATS;
      },
      parse: function (value, format) {
        if (typeof value === 'string' && typeof format === 'string') {
          value = moment(value, format);
        } else if (!(value instanceof moment)) {
          value = moment(value);
        }

        return value.isValid() ? value.valueOf() : null;
      },
      format: function (time, format) {
        return moment(time).format(format);
      },
      add: function (time, amount, unit) {
        return moment(time).add(amount, unit).valueOf();
      },
      diff: function (max, min, unit) {
        return moment.duration(moment(max).diff(moment(min))).as(unit);
      },
      startOf: function (time, unit, weekday) {
        time = moment(time);

        if (unit === 'isoWeek') {
          return time.isoWeekday(weekday).valueOf();
        }

        return time.startOf(unit).valueOf();
      },
      endOf: function (time, unit) {
        return moment(time).endOf(unit).valueOf();
      },
      // DEPRECATIONS

      /**
       * Provided for backward compatibility with scale.getValueForPixel().
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (time) {
        return moment(time);
      }
    } : {});

    core_defaults._set('global', {
      plugins: {
        filler: {
          propagate: true
        }
      }
    });

    var mappers = {
      dataset: function (source) {
        var index = source.fill;
        var chart = source.chart;
        var meta = chart.getDatasetMeta(index);
        var visible = meta && chart.isDatasetVisible(index);
        var points = visible && meta.dataset._children || [];
        var length = points.length || 0;
        return !length ? null : function (point, i) {
          return i < length && points[i]._view || null;
        };
      },
      boundary: function (source) {
        var boundary = source.boundary;
        var x = boundary ? boundary.x : null;
        var y = boundary ? boundary.y : null;
        return function (point) {
          return {
            x: x === null ? point.x : x,
            y: y === null ? point.y : y
          };
        };
      }
    }; // @todo if (fill[0] === '#')

    function decodeFill(el, index, count) {
      var model = el._model || {};
      var fill = model.fill;
      var target;

      if (fill === undefined) {
        fill = !!model.backgroundColor;
      }

      if (fill === false || fill === null) {
        return false;
      }

      if (fill === true) {
        return 'origin';
      }

      target = parseFloat(fill, 10);

      if (isFinite(target) && Math.floor(target) === target) {
        if (fill[0] === '-' || fill[0] === '+') {
          target = index + target;
        }

        if (target === index || target < 0 || target >= count) {
          return false;
        }

        return target;
      }

      switch (fill) {
        // compatibility
        case 'bottom':
          return 'start';

        case 'top':
          return 'end';

        case 'zero':
          return 'origin';
        // supported boundaries

        case 'origin':
        case 'start':
        case 'end':
          return fill;
        // invalid fill values

        default:
          return false;
      }
    }

    function computeBoundary(source) {
      var model = source.el._model || {};
      var scale = source.el._scale || {};
      var fill = source.fill;
      var target = null;
      var horizontal;

      if (isFinite(fill)) {
        return null;
      } // Backward compatibility: until v3, we still need to support boundary values set on
      // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
      // controllers might still use it (e.g. the Smith chart).


      if (fill === 'start') {
        target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
      } else if (fill === 'end') {
        target = model.scaleTop === undefined ? scale.top : model.scaleTop;
      } else if (model.scaleZero !== undefined) {
        target = model.scaleZero;
      } else if (scale.getBasePosition) {
        target = scale.getBasePosition();
      } else if (scale.getBasePixel) {
        target = scale.getBasePixel();
      }

      if (target !== undefined && target !== null) {
        if (target.x !== undefined && target.y !== undefined) {
          return target;
        }

        if (helpers$1.isFinite(target)) {
          horizontal = scale.isHorizontal();
          return {
            x: horizontal ? target : null,
            y: horizontal ? null : target
          };
        }
      }

      return null;
    }

    function resolveTarget(sources, index, propagate) {
      var source = sources[index];
      var fill = source.fill;
      var visited = [index];
      var target;

      if (!propagate) {
        return fill;
      }

      while (fill !== false && visited.indexOf(fill) === -1) {
        if (!isFinite(fill)) {
          return fill;
        }

        target = sources[fill];

        if (!target) {
          return false;
        }

        if (target.visible) {
          return fill;
        }

        visited.push(fill);
        fill = target.fill;
      }

      return false;
    }

    function createMapper(source) {
      var fill = source.fill;
      var type = 'dataset';

      if (fill === false) {
        return null;
      }

      if (!isFinite(fill)) {
        type = 'boundary';
      }

      return mappers[type](source);
    }

    function isDrawable(point) {
      return point && !point.skip;
    }

    function drawArea(ctx, curve0, curve1, len0, len1) {
      var i;

      if (!len0 || !len1) {
        return;
      } // building first area curve (normal)


      ctx.moveTo(curve0[0].x, curve0[0].y);

      for (i = 1; i < len0; ++i) {
        helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
      } // joining the two area curves


      ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)

      for (i = len1 - 1; i > 0; --i) {
        helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
      }
    }

    function doFill(ctx, points, mapper, view, color, loop) {
      var count = points.length;
      var span = view.spanGaps;
      var curve0 = [];
      var curve1 = [];
      var len0 = 0;
      var len1 = 0;
      var i, ilen, index, p0, p1, d0, d1;
      ctx.beginPath();

      for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
        index = i % count;
        p0 = points[index]._view;
        p1 = mapper(p0, index, view);
        d0 = isDrawable(p0);
        d1 = isDrawable(p1);

        if (d0 && d1) {
          len0 = curve0.push(p0);
          len1 = curve1.push(p1);
        } else if (len0 && len1) {
          if (!span) {
            drawArea(ctx, curve0, curve1, len0, len1);
            len0 = len1 = 0;
            curve0 = [];
            curve1 = [];
          } else {
            if (d0) {
              curve0.push(p0);
            }

            if (d1) {
              curve1.push(p1);
            }
          }
        }
      }

      drawArea(ctx, curve0, curve1, len0, len1);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    var plugin_filler = {
      id: 'filler',
      afterDatasetsUpdate: function (chart, options) {
        var count = (chart.data.datasets || []).length;
        var propagate = options.propagate;
        var sources = [];
        var meta, i, el, source;

        for (i = 0; i < count; ++i) {
          meta = chart.getDatasetMeta(i);
          el = meta.dataset;
          source = null;

          if (el && el._model && el instanceof elements.Line) {
            source = {
              visible: chart.isDatasetVisible(i),
              fill: decodeFill(el, i, count),
              chart: chart,
              el: el
            };
          }

          meta.$filler = source;
          sources.push(source);
        }

        for (i = 0; i < count; ++i) {
          source = sources[i];

          if (!source) {
            continue;
          }

          source.fill = resolveTarget(sources, i, propagate);
          source.boundary = computeBoundary(source);
          source.mapper = createMapper(source);
        }
      },
      beforeDatasetDraw: function (chart, args) {
        var meta = args.meta.$filler;

        if (!meta) {
          return;
        }

        var ctx = chart.ctx;
        var el = meta.el;
        var view = el._view;
        var points = el._children || [];
        var mapper = meta.mapper;
        var color = view.backgroundColor || core_defaults.global.defaultColor;

        if (mapper && color && points.length) {
          helpers$1.canvas.clipArea(ctx, chart.chartArea);
          doFill(ctx, points, mapper, view, color, el._loop);
          helpers$1.canvas.unclipArea(ctx);
        }
      }
    };
    var noop$1 = helpers$1.noop;
    var valueOrDefault$d = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      legend: {
        display: true,
        position: 'top',
        fullWidth: true,
        reverse: false,
        weight: 1000,
        // a callback that will handle
        onClick: function (e, legendItem) {
          var index = legendItem.datasetIndex;
          var ci = this.chart;
          var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment

          meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart

          ci.update();
        },
        onHover: null,
        onLeave: null,
        labels: {
          boxWidth: 40,
          padding: 10,
          // Generates labels shown in the legend
          // Valid properties to return:
          // text : text to display
          // fillStyle : fill of coloured box
          // strokeStyle: stroke of coloured box
          // hidden : if this legend item refers to a hidden item
          // lineCap : cap style for line
          // lineDash
          // lineDashOffset :
          // lineJoin :
          // lineWidth :
          generateLabels: function (chart) {
            var data = chart.data;
            return helpers$1.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
              return {
                text: dataset.label,
                fillStyle: !helpers$1.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
                hidden: !chart.isDatasetVisible(i),
                lineCap: dataset.borderCapStyle,
                lineDash: dataset.borderDash,
                lineDashOffset: dataset.borderDashOffset,
                lineJoin: dataset.borderJoinStyle,
                lineWidth: dataset.borderWidth,
                strokeStyle: dataset.borderColor,
                pointStyle: dataset.pointStyle,
                // Below is extra data used for toggling the datasets
                datasetIndex: i
              };
            }, this) : [];
          }
        }
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');

        for (var i = 0; i < chart.data.datasets.length; i++) {
          text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');

          if (chart.data.datasets[i].label) {
            text.push(chart.data.datasets[i].label);
          }

          text.push('</li>');
        }

        text.push('</ul>');
        return text.join('');
      }
    });
    /**
     * Helper function to get the box width based on the usePointStyle option
     * @param {object} labelopts - the label options on the legend
     * @param {number} fontSize - the label font size
     * @return {number} width of the color box area
     */


    function getBoxWidth(labelOpts, fontSize) {
      return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
    }
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Legend = core_element.extend({
      initialize: function (config) {
        helpers$1.extend(this, config); // Contains hit boxes for each dataset (in dataset order)

        this.legendHitBoxes = [];
        /**
        	 * @private
        	 */

        this._hoveredItem = null; // Are we in doughnut mode which has a different data type

        this.doughnutMode = false;
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      // Any function defined here is inherited by all legend types.
      // Any function can be extended by the legend type
      beforeUpdate: noop$1,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$1,
      //
      beforeSetDimensions: noop$1,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$1,
      //
      beforeBuildLabels: noop$1,
      buildLabels: function () {
        var me = this;
        var labelOpts = me.options.labels || {};
        var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];

        if (labelOpts.filter) {
          legendItems = legendItems.filter(function (item) {
            return labelOpts.filter(item, me.chart.data);
          });
        }

        if (me.options.reverse) {
          legendItems.reverse();
        }

        me.legendItems = legendItems;
      },
      afterBuildLabels: noop$1,
      //
      beforeFit: noop$1,
      fit: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var display = opts.display;
        var ctx = me.ctx;

        var labelFont = helpers$1.options._parseFont(labelOpts);

        var fontSize = labelFont.size; // Reset hit boxes

        var hitboxes = me.legendHitBoxes = [];
        var minSize = me.minSize;
        var isHorizontal = me.isHorizontal();

        if (isHorizontal) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = display ? 10 : 0;
        } else {
          minSize.width = display ? 10 : 0;
          minSize.height = me.maxHeight; // fill all the height
        } // Increase sizes here


        if (display) {
          ctx.font = labelFont.string;

          if (isHorizontal) {
            // Labels
            // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
            var lineWidths = me.lineWidths = [0];
            var totalHeight = 0;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

              if (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {
                totalHeight += fontSize + labelOpts.padding;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;
              } // Store the hitbox width and height here. Final position will be updated in `draw`


              hitboxes[i] = {
                left: 0,
                top: 0,
                width: width,
                height: fontSize
              };
              lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
            });
            minSize.height += totalHeight;
          } else {
            var vPadding = labelOpts.padding;
            var columnWidths = me.columnWidths = [];
            var totalWidth = labelOpts.padding;
            var currentColWidth = 0;
            var currentColHeight = 0;
            var itemHeight = fontSize + vPadding;
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column

              if (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {
                totalWidth += currentColWidth + labelOpts.padding;
                columnWidths.push(currentColWidth); // previous column width

                currentColWidth = 0;
                currentColHeight = 0;
              } // Get max width


              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`

              hitboxes[i] = {
                left: 0,
                top: 0,
                width: itemWidth,
                height: fontSize
              };
            });
            totalWidth += currentColWidth;
            columnWidths.push(currentColWidth);
            minSize.width += totalWidth;
          }
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$1,
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      // Actually draw the legend on the canvas
      draw: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor;
        var lineDefault = globalDefaults.elements.line;
        var legendWidth = me.width;
        var lineWidths = me.lineWidths;

        if (opts.display) {
          var ctx = me.ctx;
          var fontColor = valueOrDefault$d(labelOpts.fontColor, globalDefaults.defaultFontColor);

          var labelFont = helpers$1.options._parseFont(labelOpts);

          var fontSize = labelFont.size;
          var cursor; // Canvas setup

          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.lineWidth = 0.5;
          ctx.strokeStyle = fontColor; // for strikethrough effect

          ctx.fillStyle = fontColor; // render in correct colour

          ctx.font = labelFont.string;
          var boxWidth = getBoxWidth(labelOpts, fontSize);
          var hitboxes = me.legendHitBoxes; // current position

          var drawLegendBox = function (x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0) {
              return;
            } // Set the ctx for the box


            ctx.save();
            var lineWidth = valueOrDefault$d(legendItem.lineWidth, lineDefault.borderWidth);
            ctx.fillStyle = valueOrDefault$d(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault$d(legendItem.lineCap, lineDefault.borderCapStyle);
            ctx.lineDashOffset = valueOrDefault$d(legendItem.lineDashOffset, lineDefault.borderDashOffset);
            ctx.lineJoin = valueOrDefault$d(legendItem.lineJoin, lineDefault.borderJoinStyle);
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault$d(legendItem.strokeStyle, defaultColor);

            if (ctx.setLineDash) {
              // IE 9 and 10 do not support line dash
              ctx.setLineDash(valueOrDefault$d(legendItem.lineDash, lineDefault.borderDash));
            }

            if (opts.labels && opts.labels.usePointStyle) {
              // Recalculate x and y for drawPoint() because its expecting
              // x and y to be center of figure (instead of top left)
              var radius = boxWidth * Math.SQRT2 / 2;
              var centerX = x + boxWidth / 2;
              var centerY = y + fontSize / 2; // Draw pointStyle as legend symbol

              helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
            } else {
              // Draw box as legend symbol
              if (lineWidth !== 0) {
                ctx.strokeRect(x, y, boxWidth, fontSize);
              }

              ctx.fillRect(x, y, boxWidth, fontSize);
            }

            ctx.restore();
          };

          var fillText = function (x, y, legendItem, textWidth) {
            var halfFontSize = fontSize / 2;
            var xLeft = boxWidth + halfFontSize + x;
            var yMiddle = y + halfFontSize;
            ctx.fillText(legendItem.text, xLeft, yMiddle);

            if (legendItem.hidden) {
              // Strikethrough the text if hidden
              ctx.beginPath();
              ctx.lineWidth = 2;
              ctx.moveTo(xLeft, yMiddle);
              ctx.lineTo(xLeft + textWidth, yMiddle);
              ctx.stroke();
            }
          }; // Horizontal


          var isHorizontal = me.isHorizontal();

          if (isHorizontal) {
            cursor = {
              x: me.left + (legendWidth - lineWidths[0]) / 2 + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          } else {
            cursor = {
              x: me.left + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          }

          var itemHeight = fontSize + labelOpts.padding;
          helpers$1.each(me.legendItems, function (legendItem, i) {
            var textWidth = ctx.measureText(legendItem.text).width;
            var width = boxWidth + fontSize / 2 + textWidth;
            var x = cursor.x;
            var y = cursor.y; // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)
            // instead of me.right and me.bottom because me.width and me.height
            // may have been changed since me.minSize was calculated

            if (isHorizontal) {
              if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                y = cursor.y += itemHeight;
                cursor.line++;
                x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2 + labelOpts.padding;
              }
            } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
              x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
              y = cursor.y = me.top + labelOpts.padding;
              cursor.line++;
            }

            drawLegendBox(x, y, legendItem);
            hitboxes[i].left = x;
            hitboxes[i].top = y; // Fill the actual label

            fillText(x, y, legendItem, textWidth);

            if (isHorizontal) {
              cursor.x += width + labelOpts.padding;
            } else {
              cursor.y += itemHeight;
            }
          });
        }
      },

      /**
       * @private
       */
      _getLegendItemAt: function (x, y) {
        var me = this;
        var i, hitBox, lh;

        if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
          // See if we are touching one of the dataset boxes
          lh = me.legendHitBoxes;

          for (i = 0; i < lh.length; ++i) {
            hitBox = lh[i];

            if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
              // Touching an element
              return me.legendItems[i];
            }
          }
        }

        return null;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       */
      handleEvent: function (e) {
        var me = this;
        var opts = me.options;
        var type = e.type === 'mouseup' ? 'click' : e.type;
        var hoveredItem;

        if (type === 'mousemove') {
          if (!opts.onHover && !opts.onLeave) {
            return;
          }
        } else if (type === 'click') {
          if (!opts.onClick) {
            return;
          }
        } else {
          return;
        } // Chart event already has relative position in it


        hoveredItem = me._getLegendItemAt(e.x, e.y);

        if (type === 'click') {
          if (hoveredItem && opts.onClick) {
            // use e.native for backwards compatibility
            opts.onClick.call(me, e.native, hoveredItem);
          }
        } else {
          if (opts.onLeave && hoveredItem !== me._hoveredItem) {
            if (me._hoveredItem) {
              opts.onLeave.call(me, e.native, me._hoveredItem);
            }

            me._hoveredItem = hoveredItem;
          }

          if (opts.onHover && hoveredItem) {
            // use e.native for backwards compatibility
            opts.onHover.call(me, e.native, hoveredItem);
          }
        }
      }
    });

    function createNewLegendAndAttach(chart, legendOpts) {
      var legend = new Legend({
        ctx: chart.ctx,
        options: legendOpts,
        chart: chart
      });
      core_layouts.configure(chart, legend, legendOpts);
      core_layouts.addBox(chart, legend);
      chart.legend = legend;
    }

    var plugin_legend = {
      id: 'legend',

      /**
       * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
       * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Legend,
      beforeInit: function (chart) {
        var legendOpts = chart.options.legend;

        if (legendOpts) {
          createNewLegendAndAttach(chart, legendOpts);
        }
      },
      beforeUpdate: function (chart) {
        var legendOpts = chart.options.legend;
        var legend = chart.legend;

        if (legendOpts) {
          helpers$1.mergeIf(legendOpts, core_defaults.global.legend);

          if (legend) {
            core_layouts.configure(chart, legend, legendOpts);
            legend.options = legendOpts;
          } else {
            createNewLegendAndAttach(chart, legendOpts);
          }
        } else if (legend) {
          core_layouts.removeBox(chart, legend);
          delete chart.legend;
        }
      },
      afterEvent: function (chart, e) {
        var legend = chart.legend;

        if (legend) {
          legend.handleEvent(e);
        }
      }
    };
    var noop$2 = helpers$1.noop;

    core_defaults._set('global', {
      title: {
        display: false,
        fontStyle: 'bold',
        fullWidth: true,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000 // by default greater than legend (1000) to be above

      }
    });
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Title = core_element.extend({
      initialize: function (config) {
        var me = this;
        helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)

        me.legendHitBoxes = [];
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      beforeUpdate: noop$2,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$2,
      //
      beforeSetDimensions: noop$2,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$2,
      //
      beforeBuildLabels: noop$2,
      buildLabels: noop$2,
      afterBuildLabels: noop$2,
      //
      beforeFit: noop$2,
      fit: function () {
        var me = this;
        var opts = me.options;
        var display = opts.display;
        var minSize = me.minSize;
        var lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;

        var fontOpts = helpers$1.options._parseFont(opts);

        var textSize = display ? lineCount * fontOpts.lineHeight + opts.padding * 2 : 0;

        if (me.isHorizontal()) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = textSize;
        } else {
          minSize.width = textSize;
          minSize.height = me.maxHeight; // fill all the height
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$2,
      // Shared Methods
      isHorizontal: function () {
        var pos = this.options.position;
        return pos === 'top' || pos === 'bottom';
      },
      // Actually draw the title block on the canvas
      draw: function () {
        var me = this;
        var ctx = me.ctx;
        var opts = me.options;

        if (opts.display) {
          var fontOpts = helpers$1.options._parseFont(opts);

          var lineHeight = fontOpts.lineHeight;
          var offset = lineHeight / 2 + opts.padding;
          var rotation = 0;
          var top = me.top;
          var left = me.left;
          var bottom = me.bottom;
          var right = me.right;
          var maxWidth, titleX, titleY;
          ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour

          ctx.font = fontOpts.string; // Horizontal

          if (me.isHorizontal()) {
            titleX = left + (right - left) / 2; // midpoint of the width

            titleY = top + offset;
            maxWidth = right - left;
          } else {
            titleX = opts.position === 'left' ? left + offset : right - offset;
            titleY = top + (bottom - top) / 2;
            maxWidth = bottom - top;
            rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
          }

          ctx.save();
          ctx.translate(titleX, titleY);
          ctx.rotate(rotation);
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          var text = opts.text;

          if (helpers$1.isArray(text)) {
            var y = 0;

            for (var i = 0; i < text.length; ++i) {
              ctx.fillText(text[i], 0, y, maxWidth);
              y += lineHeight;
            }
          } else {
            ctx.fillText(text, 0, 0, maxWidth);
          }

          ctx.restore();
        }
      }
    });

    function createNewTitleBlockAndAttach(chart, titleOpts) {
      var title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart: chart
      });
      core_layouts.configure(chart, title, titleOpts);
      core_layouts.addBox(chart, title);
      chart.titleBlock = title;
    }

    var plugin_title = {
      id: 'title',

      /**
       * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
       * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Title,
      beforeInit: function (chart) {
        var titleOpts = chart.options.title;

        if (titleOpts) {
          createNewTitleBlockAndAttach(chart, titleOpts);
        }
      },
      beforeUpdate: function (chart) {
        var titleOpts = chart.options.title;
        var titleBlock = chart.titleBlock;

        if (titleOpts) {
          helpers$1.mergeIf(titleOpts, core_defaults.global.title);

          if (titleBlock) {
            core_layouts.configure(chart, titleBlock, titleOpts);
            titleBlock.options = titleOpts;
          } else {
            createNewTitleBlockAndAttach(chart, titleOpts);
          }
        } else if (titleBlock) {
          core_layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        }
      }
    };
    var plugins = {};
    var filler = plugin_filler;
    var legend = plugin_legend;
    var title = plugin_title;
    plugins.filler = filler;
    plugins.legend = legend;
    plugins.title = title;
    /**
     * @namespace Chart
     */

    core_controller.helpers = helpers$1; // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!

    core_helpers(core_controller);
    core_controller._adapters = core_adapters;
    core_controller.Animation = core_animation;
    core_controller.animationService = core_animations;
    core_controller.controllers = controllers;
    core_controller.DatasetController = core_datasetController;
    core_controller.defaults = core_defaults;
    core_controller.Element = core_element;
    core_controller.elements = elements;
    core_controller.Interaction = core_interaction;
    core_controller.layouts = core_layouts;
    core_controller.platform = platform;
    core_controller.plugins = core_plugins;
    core_controller.Scale = core_scale;
    core_controller.scaleService = core_scaleService;
    core_controller.Ticks = core_ticks;
    core_controller.Tooltip = core_tooltip; // Register built-in scales

    core_controller.helpers.each(scales, function (scale, type) {
      core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
    }); // Load to register built-in adapters (as side effects)
    // Loading built-in plugins

    for (var k in plugins) {
      if (plugins.hasOwnProperty(k)) {
        core_controller.plugins.register(plugins[k]);
      }
    }

    core_controller.platform.initialize();
    var src = core_controller;

    if (typeof window !== 'undefined') {
      window.Chart = core_controller;
    } // DEPRECATIONS

    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Chart
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */


    core_controller.Chart = core_controller;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Legend
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Legend = plugins.legend._element;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Title
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Title = plugins.title._element;
    /**
     * Provided for backward compatibility, use Chart.plugins instead
     * @namespace Chart.pluginService
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.pluginService = core_controller.plugins;
    /**
     * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
     * effect, instead simply create/register plugins via plain JavaScript objects.
     * @interface Chart.PluginBase
     * @deprecated since version 2.5.0
     * @todo remove at version 3
     * @private
     */

    core_controller.PluginBase = core_controller.Element.extend({});
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas instead.
     * @namespace Chart.canvasHelpers
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    core_controller.canvasHelpers = core_controller.helpers.canvas;
    /**
     * Provided for backward compatibility, use Chart.layouts instead.
     * @namespace Chart.layoutService
     * @deprecated since version 2.7.3
     * @todo remove at version 3
     * @private
     */

    core_controller.layoutService = core_controller.layouts;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.LinearScaleBase
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    core_controller.LinearScaleBase = scale_linearbase;
    /**
     * Provided for backward compatibility, instead we should create a new Chart
     * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     */

    core_controller.helpers.each(['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'], function (klass) {
      core_controller[klass] = function (ctx, cfg) {
        return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
          type: klass.charAt(0).toLowerCase() + klass.slice(1)
        }));
      };
    });
    return src;
  });
});

function generateChart(chartId, chartType) {
  return {
    render: function render(createElement) {
      return createElement('div', {
        style: this.styles,
        class: this.cssClasses
      }, [createElement('canvas', {
        attrs: {
          id: this.chartId,
          width: this.width,
          height: this.height
        },
        ref: 'canvas'
      })]);
    },
    props: {
      chartId: {
        default: chartId,
        type: String
      },
      width: {
        default: 400,
        type: Number
      },
      height: {
        default: 400,
        type: Number
      },
      cssClasses: {
        type: String,
        default: ''
      },
      styles: {
        type: Object
      },
      plugins: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    data: function data() {
      return {
        _chart: null,
        _plugins: this.plugins
      };
    },
    methods: {
      addPlugin: function addPlugin(plugin) {
        this.$data._plugins.push(plugin);
      },
      generateLegend: function generateLegend() {
        if (this.$data._chart) {
          return this.$data._chart.generateLegend();
        }
      },
      renderChart: function renderChart(data, options) {
        if (this.$data._chart) {
          this.$data._chart.destroy();
        }

        this.$data._chart = new Chart$1(this.$refs.canvas.getContext('2d'), {
          type: chartType,
          data: data,
          options: options,
          plugins: this.$data._plugins
        });
      }
    },
    beforeDestroy: function beforeDestroy() {
      if (this.$data._chart) {
        this.$data._chart.destroy();
      }
    }
  };
}
var Bar = generateChart('bar-chart', 'bar');
var HorizontalBar = generateChart('horizontalbar-chart', 'horizontalBar');
var Line = generateChart('line-chart', 'line');
var Pie = generateChart('pie-chart', 'pie');

var reactiveProp$1 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$1 = {
  extends: Bar,
  mixins: [reactiveProp$1],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$1 = script$1;

/* template */

  /* style */
  var __vue_inject_styles__$1 = undefined;
  /* scoped */
  var __vue_scope_id__$1 = undefined;
  /* module identifier */
  var __vue_module_identifier__$1 = undefined;
  /* functional template */
  var __vue_is_functional_template__$1 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent = normalizeComponent_1(
    {},
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    undefined,
    undefined
  );

var chartLabels = ['1980', '1990', '2000', '2010', '2020'];
var chartDataList = [6542564, 7322564, 8008278, 8175133, 5475133];
var ChartData = {
  data: {
    labels: chartLabels,
    datasets: [{
      data: chartDataList,
      fill: false,
      // used by line chart
      backgroundColor: ['#2F334F', '#3155A6', '#F2695D', '#EBBCD8', '#F9A137'],
      borderColor: ['#ACAEB9'],
      borderWidth: 1
    }]
  },
  bar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  horizontalBar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  pie: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: true
      },
      lineTension: 1
    }
  }
};

var chartType = 'bar';

var ChartBar = function ChartBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType, ChartComponent);
  new Vue({
    el: "[data-js=\"chart-" + chartType + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$2 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$2 = {
  extends: HorizontalBar,
  mixins: [reactiveProp$2],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$2 = script$2;

/* template */

  /* style */
  var __vue_inject_styles__$2 = undefined;
  /* scoped */
  var __vue_scope_id__$2 = undefined;
  /* module identifier */
  var __vue_module_identifier__$2 = undefined;
  /* functional template */
  var __vue_is_functional_template__$2 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$1 = normalizeComponent_1(
    {},
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    undefined,
    undefined
  );

var chartType$1 = 'horizontal-bar';

var ChartHorizontalBar = function ChartHorizontalBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartHorizontalBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$1, ChartComponent$1);
  new Vue({
    el: "[data-js=\"chart-" + chartType$1 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.horizontalBar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartHorizontalBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$3 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$3 = {
  extends: Line,
  mixins: [reactiveProp$3],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$3 = script$3;

/* template */

  /* style */
  var __vue_inject_styles__$3 = undefined;
  /* scoped */
  var __vue_scope_id__$3 = undefined;
  /* module identifier */
  var __vue_module_identifier__$3 = undefined;
  /* functional template */
  var __vue_is_functional_template__$3 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$2 = normalizeComponent_1(
    {},
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3,
    __vue_module_identifier__$3,
    undefined,
    undefined
  );

var chartType$2 = 'line';

var ChartLine = function ChartLine(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartLine.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$2, ChartComponent$2);
  new Vue({
    el: "[data-js=\"chart-" + chartType$2 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartLine.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$4 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$4 = {
  extends: Pie,
  mixins: [reactiveProp$4],
  props: {
    options: {
      type: Object,
      default: function default$1() {
        return {
          legend: {
            display: true
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$4 = script$4;

/* template */

  /* style */
  var __vue_inject_styles__$4 = undefined;
  /* scoped */
  var __vue_scope_id__$4 = undefined;
  /* module identifier */
  var __vue_module_identifier__$4 = undefined;
  /* functional template */
  var __vue_is_functional_template__$4 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$3 = normalizeComponent_1(
    {},
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4,
    __vue_module_identifier__$4,
    undefined,
    undefined
  );

var chartType$3 = 'pie';

var ChartPie = function ChartPie(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartPie.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$3, ChartComponent$3);
  new Vue({
    el: "[data-js=\"chart-" + chartType$3 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.pie.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartPie.prototype._constants = function _constants(param) {
  console.dir(param);
};

//
//
var script$5 = {
  props: {
    'layers': {
      type: Array
    },
    'config': {
      type: Object
    }
  },
  data: function data() {
    return {
      map: null,
      mapPopup: null,
      mapFilter: null,
      activeLayer: null,
      mapLoaded: false,
      menuItems: [],
      selectedItems: []
    };
  },
  mounted: function mounted() {
    this.initializeMap();
  },
  destroyed: function destroyed() {
    this.map.remove();
  },
  watch: {
    'layers': function layers() {
      var layers = this.layers;

      if (this.config.mapType === 'multi') {
        for (var i = 0; i < layers.length; i++) {
          var layer = layers[i];
          this.trackLayer(layer.name);

          if (layer.default || this.layers.length === 1) {
            this.activeLayer = layer.name;
          }

          if (this.mapLoaded) {
            this.initializeLayer(layer);
          }
        }
      } else if (this.config.mapType === 'single') {
        var layer$1 = this.layers[0];
        this.activeLayer = layer$1.name;
        this.generateLegend(layer$1.data);

        if (this.mapLoaded) {
          this.initializeLayer(layer$1);
        }
      } else {
        throw new Error('mapType must be defined');
      }
    },
    'mapLoaded': function mapLoaded() {
      if (this.mapLoaded && this.layers.length) {
        var layers = this.layers;

        for (var i = 0; i < layers.length; i++) {
          this.initializeLayer(layers[i]);
        }
      }
    },
    'menuItems': function menuItems() {
      if (this.menuItems.length > 1) {
        this.initializeToggle(this.menuItems);
      }
    },
    'selectedItems': function selectedItems() {
      var layer = this.layers[0];
      var filter = ['in', layer.legendColumn];

      for (var i = 0; i < this.selectedItems.length; i++) {
        filter.push(this.selectedItems[i]);
      }

      if (this.selectedItems.length > 0) {
        var relatedFeatures = this.map.querySourceFeatures(layer.name, {
          sourceLayer: layer.name,
          filter: filter
        }); // set filter when legend item selected

        this.map.setFilter(layer.name + "-highlighted", filter);
        this.map.setLayoutProperty(layer.name + "-highlighted", 'visibility', 'visible');
      }

      if (!this.selectedItems.length && !this.mapPopup) {
        this.map.setFilter(layer.name + "-highlighted", null);
        this.map.setLayoutProperty(layer.name + "-highlighted", 'visibility', 'none');
      }
    }
  },
  methods: {
    initializeMap: function initializeMap() {
      var this$1 = this;
      var mapConfig = this.config;
      var options = {
        container: mapConfig.containerId
      };

      if (mapConfig.center) {
        options.center = mapConfig.center;
      }

      if (mapConfig.style) {
        options.style = mapConfig.style;
      }

      if (mapConfig.zoom) {
        options.zoom = mapConfig.zoom;
      }

      mapboxgl.accessToken = mapConfig.APIKey;
      this.map = new mapboxgl.Map(options);
      this.map.addControl(new mapboxgl.NavigationControl()); // disable map zoom when using scroll

      if (mapConfig.disableScroll) {
        this.map.scrollZoom.disable();
      }

      this.map.on('load', function () {
        return this$1.mapLoaded = true;
      });
    },
    initializeLayer: function initializeLayer(layer) {
      if (this.map.getLayer(layer.name) === undefined && Object.entries(layer.data).length !== 0) {
        var visibility = layer.name === this.activeLayer ? 'visible' : 'none';
        var filter = layer.filterBy ? ['in', layer.filterBy, ''] : [];
        var fill = this.config.colors ? this.generateFillColor(this.config.colors) : layer.fill;
        this.map.addSource(layer.name, {
          'type': 'geojson',
          'data': layer.data
        });
        this.map.addLayer({
          'id': layer.name,
          'type': 'fill',
          'source': layer.name,
          'paint': {
            'fill-outline-color': fill[0],
            'fill-color': fill[1],
            'fill-opacity': 0.7
          },
          'layout': {
            'visibility': visibility
          }
        });
        this.map.addLayer({
          'id': layer.name + "-highlighted",
          'type': 'fill',
          'source': layer.name,
          'paint': {
            'fill-outline-color': fill[0],
            'fill-color': fill[1],
            'fill-opacity': 1
          },
          'filter': filter,
          'layout': {
            'visibility': visibility
          }
        });
        this.initializeFilter(layer);
        this.updateCursorOnHover(layer.name);
      }
    },
    initializePopup: function initializePopup(event, layer) {
      this.config.mapType === 'multi' ? this.popupMultiLayer(event, layer) : this.popupSingleLayer(event, layer);
    },
    initializeToggle: function initializeToggle(toggleList) {
      this.config.mapType === 'multi' ? this.toggleMultiLayer(toggleList) : this.toggleSingleLayer(toggleList);
    },
    initializeFilter: function initializeFilter(layer) {
      this.config.mapType === 'multi' ? this.filterMultiLayer(layer) : this.filterSingleLayer(layer);
    },
    updateCursorOnHover: function updateCursorOnHover(layerId) {
      var map = this.map; // change the cursor to a pointer when the mouse is over the layer.

      map.on('mouseenter', layerId, function () {
        map.getCanvas().style.cursor = 'pointer';
      }); // change the cursor back to the default when it leaves the layer.

      map.on('mouseleave', layerId, function () {
        map.getCanvas().style.cursor = '';
      });
    },
    generateFillColor: function generateFillColor(colors) {
      return colors[Math.floor(Math.random() * colors.length)];
    },
    // multi layer
    trackLayer: function trackLayer(reference) {
      if (!this.menuItems.includes(reference)) {
        this.menuItems.push(reference);
      }
    },
    popupMultiLayer: function popupMultiLayer(event, layer) {
      var $this = this;
      var map = $this.map;
      var layerName = layer.name + "-highlighted";
      var popup = new mapboxgl.Popup().setLngLat(event.lngLat).setHTML(event.features[0].properties[layer.filterBy]).addTo(map);

      if (popup.isOpen()) {
        $this.mapPopup = popup;
        map.setLayoutProperty(layerName, 'visibility', 'visible');
        map.setFilter(layerName, $this.mapFilter);
      }

      popup.on('close', function () {
        // reset associated states when popup dismissed while active
        if ($this.mapPopup === popup) {
          $this.mapPopup = null;
          $this.mapFilter = null;
          map.setFilter(layerName, null);
          map.setLayoutProperty(layerName, 'visibility', 'none');
        }
      });
    },
    filterMultiLayer: function filterMultiLayer(layer) {
      var $this = this;
      var map = $this.map;
      map.on('click', layer.name, function (e) {
        // set bbox as reactangle area around clicked point
        var bbox = [[e.point.x, e.point.y], [e.point.x, e.point.y]];
        var features = map.queryRenderedFeatures(bbox, {
          layers: [layer.name]
        });
        var filter = features.reduce(function (memo, feature) {
          memo.push(feature.properties[layer.filterBy]);
          return memo;
        }, ['in', "" + layer.filterBy]);
        $this.mapFilter = filter;
        $this.initializePopup(e, layer);
      });
    },
    toggleMultiLayer: function toggleMultiLayer(layersToToggle) {
      var $this = this;
      var map = $this.map;
      var activeLayer = $this.activeLayer;
      var linkContainer = document.getElementById(this.config.legendId); // clear all links before appending new ones to prevent duplicates

      while (linkContainer.firstChild) {
        linkContainer.removeChild(linkContainer.firstChild);
      }

      for (var i = 0; i < layersToToggle.length; i++) {
        var layerRef = layersToToggle[i];
        var link = document.createElement('a');
        link.href = '#';
        link.textContent = layerRef;

        if (layerRef === activeLayer) {
          link.classList.add('active');
        } // on click update link state, active layer reference, and layer visibility


        link.onclick = function (e) {
          e.preventDefault();
          e.stopPropagation();
          var selectedLayer = this.textContent;
          var links = linkContainer.getElementsByTagName('a'); // remove active popup

          if ($this.mapPopup) {
            $this.mapPopup.remove();
          }

          for (var i = 0; i < links.length; i++) {
            var currentLink = links[i];
            var currentLayer = currentLink.textContent;
            var currentLayerHighlight = currentLayer + "-highlighted";
            var layerVisibility = map.getLayoutProperty(currentLayer, 'visibility');

            if (currentLayer === selectedLayer) {
              // return if layer is already selected
              if (layerVisibility === 'visible' && currentLink.classList.contains('active')) {
                return;
              } // set our current layer as the global active layer,
              // add active class to link, set layer as visible


              $this.activeLayer = currentLayer;
              currentLink.classList.add('active');
              map.setLayoutProperty(currentLayer, 'visibility', 'visible');
            } else {
              // remove links active class, set layer visibility to none and remove filters
              currentLink.classList.remove('active');
              map.setLayoutProperty(currentLayer, 'visibility', 'none');
              map.setLayoutProperty(currentLayerHighlight, 'visibility', 'none');
              map.setFilter(currentLayerHighlight, null);
            }
          }
        };

        linkContainer.appendChild(link);
      }
    },
    // single layer
    generateLegend: function generateLegend(layerData) {
      var this$1 = this;
      layerData.features.forEach(function (feature) {
        var item = feature.properties[this$1.layers[0].legendColumn];

        if (!this$1.menuItems.includes(item) && item) {
          this$1.menuItems.push(item);
        }
      });
    },
    popupSingleLayer: function popupSingleLayer(event, layer) {
      var $this = this;
      var map = $this.map;
      var layerName = layer.name + "-highlighted"; // check whether shape falls under current legend selection

      var inCurrentSelection = true;
      var columnFilter = event.features[0].properties[layer.legendColumn];

      if (!$this.selectedItems.includes(columnFilter)) {
        inCurrentSelection = false;
      }

      var popup = new mapboxgl.Popup().setLngLat(event.lngLat).setHTML(event.features[0].properties[layer.filterBy]).addTo(map);

      if (popup.isOpen()) {
        $this.mapPopup = popup; // if there are no legend items selected, highlight selected map shape

        if (!$this.selectedItems.length) {
          map.setLayoutProperty(layerName, 'visibility', 'visible');
          map.setFilter(layerName, $this.mapFilter);
        } // if there are legend items selected and selected map shape isn't
        // within any of the selected legend items, highlight selected
        // map shape and clear legend


        if ($this.selectedItems.length > 0 && !inCurrentSelection) {
          map.setLayoutProperty(layerName, 'visibility', 'visible');
          map.setFilter(layerName, $this.mapFilter); // reset all checked legend items

          $this.selectedItems = [];
          var filterGroupInputs = document.getElementById(this.config.legendId).querySelectorAll('input:checked');

          for (var i = 0; i < filterGroupInputs.length; i++) {
            filterGroupInputs[i].checked = false;
          }
        }
      }

      popup.on('close', function () {
        // reset associated states when popup dismissed while active
        if ($this.mapPopup === popup) {
          $this.mapPopup = null;
          $this.mapFilter = null; // if there are no legend items selected, reset all filters

          if (!$this.selectedItems.length) {
            map.setFilter(layerName, null);
            map.setLayoutProperty(layerName, 'visibility', 'none');
          }
        }
      });
    },
    filterSingleLayer: function filterSingleLayer(layer) {
      var $this = this;
      var map = $this.map;
      map.on('click', layer.name, function (e) {
        // set bbox as reactangle area around clicked point
        var bbox = [[e.point.x, e.point.y], [e.point.x, e.point.y]];
        var features = map.queryRenderedFeatures(bbox, {
          layers: [layer.name]
        });
        var legendColumnValue = null;
        var filter = features.reduce(function (memo, feature) {
          legendColumnValue = feature.properties[layer.legendColumn];
          memo.push(feature.properties[layer.filterBy]);
          return memo;
        }, ['in', "" + layer.filterBy]);
        $this.mapFilter = filter;
        $this.initializePopup(e, layer);
      });
    },
    toggleSingleLayer: function toggleSingleLayer(filtersToToggle) {
      var $this = this;
      var map = $this.map;
      var filterGroup = document.getElementById(this.config.legendId);
      var layer = $this.layers[0];
      var legendColumn = layer.legendColumn; // clear all links before appending new ones to prevent duplicates

      while (filterGroup.firstChild) {
        filterGroup.removeChild(filterGroup.firstChild);
      } // initilize an input element for each filter type


      for (var i = 0; i < filtersToToggle.length; i++) {
        var layerRef = filtersToToggle[i]; // checkbox

        var input = document.createElement('input');
        input.type = 'checkbox';
        input.id = layerRef;
        input.value = layerRef;
        filterGroup.appendChild(input); // checkbox label

        var label = document.createElement('label');
        label.setAttribute('for', layerRef);
        label.setAttribute('title', layerRef);
        label.textContent = layerRef;
        filterGroup.appendChild(label); // when the checkbox changes state, update the selected items array.

        input.addEventListener('change', function (e) {
          var item = e.target.value; // reset the checkboxes checked state

          e.target.checked ? 'visible' : 'none'; // remove popup if one exists

          if ($this.mapPopup) {
            $this.mapPopup.remove();
          }

          if (e.target.checked && !$this.selectedItems.includes(item)) {
            $this.selectedItems.push(item);
          }

          if (!e.target.checked && $this.selectedItems.includes(item)) {
            $this.selectedItems = $this.selectedItems.filter(function (val) {
              return val !== item;
            });
          }
        });
      }
    }
  }
};

/* script */
var __vue_script__$5 = script$5;

/* template */
var __vue_render__$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div")
};
var __vue_staticRenderFns__$1 = [];
__vue_render__$1._withStripped = true;

  /* style */
  var __vue_inject_styles__$5 = undefined;
  /* scoped */
  var __vue_scope_id__$5 = undefined;
  /* module identifier */
  var __vue_module_identifier__$5 = undefined;
  /* functional template */
  var __vue_is_functional_template__$5 = false;
  /* style inject */
  
  /* style inject SSR */
  

  
  var MapComponent = normalizeComponent_1(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$5,
    __vue_script__$5,
    __vue_scope_id__$5,
    __vue_is_functional_template__$5,
    __vue_module_identifier__$5,
    undefined,
    undefined
  );

/**
 * Config
 */
var nycoColors = {
  colors: {
    'primary-navy': '#2F334F',
    'primary-navy-70t': '#6E7085',
    'primary-navy-50t': '#9698A7',
    'primary-navy-30t': '#C0C2CA',
    'primary-blue': '#3155A6',
    'primary-blue-70t': '#6C88C1',
    'primary-blue-50t': '#96ABD2',
    'primary-blue-30t': '#C0CCE3',
    'primary-red': '#F2695D',
    'primary-red-70t': '#F6958D',
    'primary-red-50t': '#F8B2AD',
    'primary-red-30t': '#FBD1CE',
    'secondary-grey': '#ACAEB9',
    'secondary-grey-70t': '#C4C6CD',
    'secondary-grey-50t': '#D5D6DC',
    'secondary-grey-30t': '#E8E7E9',
    'secondary-white': '#F3F3F3',
    'secondary-white-70t': '#F6F6F6',
    'secondary-white-50t': '#F9F9FA',
    'secondary-white-30t': '#FBFCFC',
    'secondary-orange': '#F9A137',
    'secondary-orange-70t': '#FFA133',
    'secondary-orange-50t': '#FED09A',
    'secondary-orange-30t': '#FFE3C2',
    'secondary-pink': '#EBBCD8',
    'secondary-pink-70t': '#F2D0E3',
    'secondary-pink-50t': '#F7DDEB',
    'secondary-pink-30t': '#FDEBF3',
    'base-black': '#000000',
    'base-white': '#FFFFFF'
  },
  colorCombinations: {
    'light-background': {
      'color': 'base-black',
      'headings': 'primary-navy',
      'hyperlinks': 'primary-blue',
      'visited': 'primary-blue',
      'hover': 'primary-navy',
      'background-color': 'base-white',
      'border': 'secondary-grey',
      'placeholder': 'secondary-grey',
      'checkbox-background': 'primary-navy',
      'error': 'primary-red'
    },
    'mid-background': {
      'color': 'base-black',
      'headings': 'primary-navy',
      'hyperlinks': 'primary-blue',
      'visited': 'primary-blue',
      'hover': 'primary-navy',
      'background-color': 'secondary-white'
    },
    'dark-background': {
      'color': 'base-white',
      'font-smooth': true,
      'headings': 'base-white',
      'hyperlinks': 'base-white',
      'visited': 'base-white',
      'hover': 'base-white',
      'background-color': 'primary-navy'
    },
    'primary-button': {
      'font-weight': 'bold',
      'color': 'base-white',
      'font-smooth': true,
      'background-color': 'primary-blue'
    },
    'secondary-button': {
      'font-weight': 'bold',
      'color': 'base-white',
      'font-smooth': true,
      'background-color': 'primary-red'
    }
  }
};
var color = nycoColors.colors;
var mapColorCombinations = [[color['primary-navy'], color['primary-navy-70t']], [color['base-black'], color['secondary-orange']], [color['primary-navy'], color['secondary-grey']], [color['primary-blue'], color['secondary-orange']]];
var colors = {
  nycoColors: nycoColors,
  mapColorCombinations: mapColorCombinations
};
var colors_2 = colors.mapColorCombinations;

var MapData = {
  single: {
    layers: [],
    config: {
      APIKey: 'pk.eyJ1Ijoibnljby1wcm9kdWN0cyIsImEiOiJjanZjZ3Y4b2IxNXYwM3l0ZDN6bWN4ajA5In0.XSt-hoz5p3j2siyli0g0og',
      containerId: 'nyco-map-sl',
      legendId: 'nyco-map-legend',
      center: [-73.986710, 40.693391],
      zoom: 9,
      disableScroll: true,
      style: 'mapbox://styles/nyco-products/cjv6wjq8812ys1gp39mnvuk2w',
      mapType: 'single'
    }
  },
  multi: {
    layers: [],
    config: {
      APIKey: 'pk.eyJ1Ijoibnljby1wcm9kdWN0cyIsImEiOiJjanZjZ3Y4b2IxNXYwM3l0ZDN6bWN4ajA5In0.XSt-hoz5p3j2siyli0g0og',
      containerId: 'nyco-map-ml',
      legendId: 'nyco-map-menu',
      center: [-73.986710, 40.693391],
      zoom: 9,
      disableScroll: true,
      style: 'mapbox://styles/nyco-products/cjv6wjq8812ys1gp39mnvuk2w',
      mapType: 'multi',
      colors: colors_2
    }
  }
};

var geojson = createCommonjsModule(function (module) {
  (function (GeoJSON) {
    GeoJSON.version = '0.5.0'; // Allow user to specify default parameters

    GeoJSON.defaults = {
      doThrows: {
        invalidGeometry: false
      }
    };

    function InvalidGeometryError() {
      var args = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
      var item = args.shift();
      var params = args.shift();
      Error.apply(this, args);
      this.message = this.message || "Invalid Geometry: " + 'item: ' + JSON.stringify(item) + ', params: ' + JSON.stringify(params);
    }

    InvalidGeometryError.prototype = Error;
    GeoJSON.errors = {
      InvalidGeometryError: InvalidGeometryError
    }; //exposing so this can be overriden maybe by geojson-validation or the like

    GeoJSON.isGeometryValid = function (geometry) {
      if (!geometry || !Object.keys(geometry).length) {
        return false;
      }

      return !!geometry.type && !!geometry.coordinates && Array.isArray(geometry.coordinates) && !!geometry.coordinates.length;
    }; // The one and only public function.
    // Converts an array of objects into a GeoJSON feature collection


    GeoJSON.parse = function (objects, params, callback) {
      var geojson,
          settings = applyDefaults(params, this.defaults),
          propFunc;
      geomAttrs.length = 0; // Reset the list of geometry fields

      setGeom(settings);
      propFunc = getPropFunction(settings);

      if (Array.isArray(objects)) {
        geojson = {
          "type": "FeatureCollection",
          "features": []
        };
        objects.forEach(function (item) {
          geojson.features.push(getFeature({
            item: item,
            params: settings,
            propFunc: propFunc
          }));
        });
        addOptionals(geojson, settings);
      } else {
        geojson = getFeature({
          item: objects,
          params: settings,
          propFunc: propFunc
        });
        addOptionals(geojson, settings);
      }

      if (callback && typeof callback === 'function') {
        callback(geojson);
      } else {
        return geojson;
      }
    }; // Helper functions


    var geoms = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon', 'GeoJSON'],
        geomAttrs = []; // Adds default settings to user-specified params
    // Does not overwrite any settings--only adds defaults
    // the the user did not specify

    function applyDefaults(params, defaults) {
      var settings = params || {};

      for (var setting in defaults) {
        if (defaults.hasOwnProperty(setting) && !settings[setting]) {
          settings[setting] = defaults[setting];
        }
      }

      return settings;
    } // Adds the optional GeoJSON properties crs and bbox
    // if they have been specified


    function addOptionals(geojson, settings) {
      if (settings.crs && checkCRS(settings.crs)) {
        if (settings.isPostgres) {
          geojson.geometry.crs = settings.crs;
        } else {
          geojson.crs = settings.crs;
        }
      }

      if (settings.bbox) {
        geojson.bbox = settings.bbox;
      }

      if (settings.extraGlobal) {
        geojson.properties = {};

        for (var key in settings.extraGlobal) {
          geojson.properties[key] = settings.extraGlobal[key];
        }
      }
    } // Verify that the structure of CRS object is valid


    function checkCRS(crs) {
      if (crs.type === 'name') {
        if (crs.properties && crs.properties.name) {
          return true;
        } else {
          throw new Error('Invalid CRS. Properties must contain "name" key');
        }
      } else if (crs.type === 'link') {
        if (crs.properties && crs.properties.href && crs.properties.type) {
          return true;
        } else {
          throw new Error('Invalid CRS. Properties must contain "href" and "type" key');
        }
      } else {
        throw new Error('Invald CRS. Type attribute must be "name" or "link"');
      }
    } // Moves the user-specified geometry parameters
    // under the `geom` key in param for easier access


    function setGeom(params) {
      params.geom = {};

      for (var param in params) {
        if (params.hasOwnProperty(param) && geoms.indexOf(param) !== -1) {
          params.geom[param] = params[param];
          delete params[param];
        }
      }

      setGeomAttrList(params.geom);
    } // Adds fields which contain geometry data
    // to geomAttrs. This list is used when adding
    // properties to the features so that no geometry
    // fields are added the properties key


    function setGeomAttrList(params) {
      for (var param in params) {
        if (params.hasOwnProperty(param)) {
          if (typeof params[param] === 'string') {
            geomAttrs.push(params[param]);
          } else if (typeof params[param] === 'object') {
            // Array of coordinates for Point
            geomAttrs.push(params[param][0]);
            geomAttrs.push(params[param][1]);
          }
        }
      }

      if (geomAttrs.length === 0) {
        throw new Error('No geometry attributes specified');
      }
    } // Creates a feature object to be added
    // to the GeoJSON features array


    function getFeature(args) {
      var item = args.item,
          params = args.params,
          propFunc = args.propFunc;
      var feature = {
        "type": "Feature"
      };
      feature.geometry = buildGeom(item, params);
      feature.properties = propFunc.call(item);
      return feature;
    }

    function isNested(val) {
      return /^.+\..+$/.test(val);
    } // Assembles the `geometry` property
    // for the feature output


    function buildGeom(item, params) {
      var geom = {};

      for (var gtype in params.geom) {
        var val = params.geom[gtype]; // Geometry parameter specified as: {Point: 'coords'}

        if (typeof val === 'string' && item.hasOwnProperty(val)) {
          if (gtype === 'GeoJSON') {
            geom = item[val];
          } else {
            geom.type = gtype;
            geom.coordinates = item[val];
          }
        }
        /* Handle things like:
        Polygon: {
          northeast: ['lat', 'lng'],
          southwest: ['lat', 'lng']
        }
        */
        else if (typeof val === 'object' && !Array.isArray(val)) {
            /*jshint loopfunc: true */
            var points = Object.keys(val).map(function (key) {
              var order = val[key];
              var newItem = item[key];
              return buildGeom(newItem, {
                geom: {
                  Point: order
                }
              });
            });
            geom.type = gtype;
            /*jshint loopfunc: true */

            geom.coordinates = [].concat(points.map(function (p) {
              return p.coordinates;
            }));
          } // Geometry parameter specified as: {Point: ['lat', 'lng']}
          else if (Array.isArray(val) && item.hasOwnProperty(val[0]) && item.hasOwnProperty(val[1])) {
              geom.type = gtype;
              geom.coordinates = [Number(item[val[1]]), Number(item[val[0]])];
            } // Geometry parameter specified as: {Point: ['container.lat', 'container.lng']}
            else if (Array.isArray(val) && isNested(val[0]) && isNested(val[1])) {
                var coordinates = [];

                for (var i = 0; i < val.length; i++) {
                  // i.e. 0 and 1
                  var paths = val[i].split('.');
                  var itemClone = item;

                  for (var j = 0; j < paths.length; j++) {
                    if (!itemClone.hasOwnProperty(paths[j])) {
                      return false;
                    }

                    itemClone = itemClone[paths[j]]; // Iterate deeper into the object
                  }

                  coordinates[i] = itemClone;
                }

                geom.type = gtype;
                geom.coordinates = [Number(coordinates[1]), Number(coordinates[0])];
              }
      }

      if (params.doThrows && params.doThrows.invalidGeometry && !GeoJSON.isGeometryValid(geom)) {
        throw new InvalidGeometryError(item, params);
      }

      return geom;
    } // Returns the function to be used to
    // build the properties object for each feature


    function getPropFunction(params) {
      var func;

      if (!params.exclude && !params.include) {
        func = function (properties) {
          for (var attr in this) {
            if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1) {
              properties[attr] = this[attr];
            }
          }
        };
      } else if (params.include) {
        func = function (properties) {
          params.include.forEach(function (attr) {
            properties[attr] = this[attr];
          }, this);
        };
      } else if (params.exclude) {
        func = function (properties) {
          for (var attr in this) {
            if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1 && params.exclude.indexOf(attr) === -1) {
              properties[attr] = this[attr];
            }
          }
        };
      }

      return function () {
        var properties = {};
        func.call(this, properties);

        if (params.extra) {
          addExtra(properties, params.extra);
        }

        return properties;
      };
    } // Adds data contained in the `extra`
    // parameter if it has been specified


    function addExtra(properties, extra) {
      for (var key in extra) {
        if (extra.hasOwnProperty(key)) {
          properties[key] = extra[key];
        }
      }

      return properties;
    }
  })(module.exports);
});

var RADIUS = 6378137;
var FLATTENING = 1 / 298.257223563;
var POLAR_RADIUS = 6356752.3142;
var wgs84 = {
  RADIUS: RADIUS,
  FLATTENING: FLATTENING,
  POLAR_RADIUS: POLAR_RADIUS
};

var geometry_1 = geometry;
var ring = ringArea;

function geometry(_) {
  var area = 0,
      i;

  switch (_.type) {
    case 'Polygon':
      return polygonArea(_.coordinates);

    case 'MultiPolygon':
      for (i = 0; i < _.coordinates.length; i++) {
        area += polygonArea(_.coordinates[i]);
      }

      return area;

    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
      return 0;

    case 'GeometryCollection':
      for (i = 0; i < _.geometries.length; i++) {
        area += geometry(_.geometries[i]);
      }

      return area;
  }
}

function polygonArea(coords) {
  var area = 0;

  if (coords && coords.length > 0) {
    area += Math.abs(ringArea(coords[0]));

    for (var i = 1; i < coords.length; i++) {
      area -= Math.abs(ringArea(coords[i]));
    }
  }

  return area;
}
/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */


function ringArea(coords) {
  var p1,
      p2,
      p3,
      lowerIndex,
      middleIndex,
      upperIndex,
      i,
      area = 0,
      coordsLength = coords.length;

  if (coordsLength > 2) {
    for (i = 0; i < coordsLength; i++) {
      if (i === coordsLength - 2) {
        // i = N-2
        lowerIndex = coordsLength - 2;
        middleIndex = coordsLength - 1;
        upperIndex = 0;
      } else if (i === coordsLength - 1) {
        // i = N-1
        lowerIndex = coordsLength - 1;
        middleIndex = 0;
        upperIndex = 1;
      } else {
        // i = 0 to N-3
        lowerIndex = i;
        middleIndex = i + 1;
        upperIndex = i + 2;
      }

      p1 = coords[lowerIndex];
      p2 = coords[middleIndex];
      p3 = coords[upperIndex];
      area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
    }

    area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
  }

  return area;
}

function rad(_) {
  return _ * Math.PI / 180;
}

var geojsonArea = {
  geometry: geometry_1,
  ring: ring
};

var geojsonRewind = rewind;

function rewind(gj, outer) {
  switch (gj && gj.type || null) {
    case 'FeatureCollection':
      gj.features = gj.features.map(curryOuter(rewind, outer));
      return gj;

    case 'Feature':
      gj.geometry = rewind(gj.geometry, outer);
      return gj;

    case 'Polygon':
    case 'MultiPolygon':
      return correct(gj, outer);

    default:
      return gj;
  }
}

function curryOuter(a, b) {
  return function (_) {
    return a(_, b);
  };
}

function correct(_, outer) {
  if (_.type === 'Polygon') {
    _.coordinates = correctRings(_.coordinates, outer);
  } else if (_.type === 'MultiPolygon') {
    _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
  }

  return _;
}

function correctRings(_, outer) {
  outer = !!outer;
  _[0] = wind(_[0], outer);

  for (var i = 1; i < _.length; i++) {
    _[i] = wind(_[i], !outer);
  }

  return _;
}

function wind(_, dir) {
  return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
  return geojsonArea.ring(_) >= 0;
}

var MapMultiLayer = function MapMultiLayer(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


MapMultiLayer.prototype.init = function init() {
  Vue.component('nyco-map-ml', MapComponent);
  new Vue({
    el: '[data-js="nyco-map-ml"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        layers: MapData.multi.layers,
        config: MapData.multi.config
      };
    },
    created: function created() {
      this.getZipcodeData();
      this.getBoroughData();
      this.getNeighborhoodData();
    },
    methods: {
      getZipcodeData: function getZipcodeData() {
        fetch('https://cdn.jsdelivr.net/gh/kimpenguin/geoJSON@master/tiger-zcta.geojson').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          MapData.multi.layers.push({
            name: 'zipcodes',
            data: JSON.parse(data),
            default: true,
            filterBy: 'GEOID10'
          });
        });
      },
      getBoroughData: function getBoroughData() {
        var this$1 = this;
        fetch('https://data.cityofnewyork.us/resource/7t3b-ywvw.json').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          data = JSON.parse(data);
          MapData.multi.layers.push({
            name: 'boroughs',
            data: this$1.convertToGeoJSON(data),
            default: false,
            filterBy: 'boro_name'
          });
        });
      },
      getNeighborhoodData: function getNeighborhoodData() {
        var this$1 = this;
        fetch('https://data.cityofnewyork.us/resource/q2z5-ai38.json').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          data = JSON.parse(data);
          MapData.multi.layers.push({
            name: 'neighborhoods',
            data: this$1.convertToGeoJSON(data),
            default: false,
            filterBy: 'ntaname'
          });
        });
      },
      convertToGeoJSON: function convertToGeoJSON(jsonData) {
        // ensure geojson satisfies right-hand rule
        var data = geojsonRewind(geojson.parse(jsonData, {
          GeoJSON: 'the_geom'
        }));
        return data;
      }
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


MapMultiLayer.prototype._constants = function _constants(param) {
  console.dir(param);
};

var MapSingleLayer = function MapSingleLayer(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


MapSingleLayer.prototype.init = function init() {
  Vue.component('nyco-map-sl', MapComponent);
  new Vue({
    el: '[data-js="nyco-map-sl"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        layers: MapData.single.layers,
        config: MapData.single.config
      };
    },
    created: function created() {
      this.getData();
    },
    methods: {
      getData: function getData() {
        fetch('https://cdn.jsdelivr.net/gh/kimpenguin/geoJSON@master/nyco-nyc_zipcodes.geojson').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        }).catch(function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          MapData.single.layers.push({
            name: 'nyco-nyc_zipcodes',
            data: JSON.parse(data),
            filterBy: 'ZCTA5CE10',
            legendColumn: 'BORO',
            fill: colors_2[3]
          });
        });
      }
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


MapSingleLayer.prototype._constants = function _constants(param) {
  console.dir(param);
};

/**
 * JaroWinkler function.
 * https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance
 * @param {string} s1 string one.
 * @param {string} s2 second string.
 * @return {number} amount of matches.
 */
function jaro(s1, s2) {
  var assign;
  var shorter;
  var longer;
  assign = s1.length > s2.length ? [s1, s2] : [s2, s1], longer = assign[0], shorter = assign[1];
  var matchingWindow = Math.floor(longer.length / 2) - 1;
  var shorterMatches = [];
  var longerMatches = [];

  for (var i = 0; i < shorter.length; i++) {
    var ch = shorter[i];
    var windowStart = Math.max(0, i - matchingWindow);
    var windowEnd = Math.min(i + matchingWindow + 1, longer.length);

    for (var j = windowStart; j < windowEnd; j++) {
      if (longerMatches[j] === undefined && ch === longer[j]) {
        shorterMatches[i] = longerMatches[j] = ch;
        break;
      }
    }
  }

  var shorterMatchesString = shorterMatches.join('');
  var longerMatchesString = longerMatches.join('');
  var numMatches = shorterMatchesString.length;
  var transpositions = 0;

  for (var i$1 = 0; i$1 < shorterMatchesString.length; i$1++) {
    if (shorterMatchesString[i$1] !== longerMatchesString[i$1]) {
      transpositions++;
    }
  }

  return numMatches > 0 ? (numMatches / shorter.length + numMatches / longer.length + (numMatches - Math.floor(transpositions / 2)) / numMatches) / 3.0 : 0;
}
/**
 * @param {string} s1 string one.
 * @param {string} s2 second string.
 * @param {number} prefixScalingFactor
 * @return {number} jaroSimilarity
 */


function jaroWinkler (s1, s2, prefixScalingFactor) {
  if (prefixScalingFactor === void 0) prefixScalingFactor = 0.2;
  var jaroSimilarity = jaro(s1, s2);
  var commonPrefixLength = 0;

  for (var i = 0; i < s1.length; i++) {
    if (s1[i] === s2[i]) {
      commonPrefixLength++;
    } else {
      break;
    }
  }

  return jaroSimilarity + Math.min(commonPrefixLength, 4) * prefixScalingFactor * (1 - jaroSimilarity);
}

function memoize$1 (fn) {
  var cache = {};
  return function () {
    var args = [],
        len = arguments.length;

    while (len--) {
      args[len] = arguments[len];
    }

    var key = JSON.stringify(args);
    return cache[key] || (cache[key] = fn.apply(void 0, args));
  };
}

/* eslint-env browser */
/**
 * Autocomplete for autocomplete.
 * Forked and modified from https://github.com/xavi/miss-plete
 */

var Autocomplete = function Autocomplete(settings) {
  var this$1 = this;
  if (settings === void 0) settings = {};
  this.settings = {
    'selector': settings.selector,
    // required
    'options': settings.options,
    // required
    'classname': settings.classname,
    // required
    'selected': settings.hasOwnProperty('selected') ? settings.selected : false,
    'score': settings.hasOwnProperty('score') ? settings.score : memoize$1(Autocomplete.score),
    'listItem': settings.hasOwnProperty('listItem') ? settings.listItem : Autocomplete.listItem,
    'getSiblingIndex': settings.hasOwnProperty('getSiblingIndex') ? settings.getSiblingIndex : Autocomplete.getSiblingIndex
  };
  this.scoredOptions = null;
  this.container = null;
  this.ul = null;
  this.highlighted = -1;
  this.SELECTORS = Autocomplete.selectors;
  this.STRINGS = Autocomplete.strings;
  this.MAX_ITEMS = Autocomplete.maxItems;
  window.addEventListener('keydown', function (e) {
    this$1.keydownEvent(e);
  });
  window.addEventListener('keyup', function (e) {
    this$1.keyupEvent(e);
  });
  window.addEventListener('input', function (e) {
    this$1.inputEvent(e);
  });
  var body = document.querySelector('body');
  body.addEventListener('focus', function (e) {
    this$1.focusEvent(e);
  }, true);
  body.addEventListener('blur', function (e) {
    this$1.blurEvent(e);
  }, true);
  return this;
};
/**
 * EVENTS
 */

/**
 * The input focus event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.focusEvent = function focusEvent(event) {
  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.input.value === '') {
    this.message('INIT');
  }
};
/**
 * The input keydown event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.keydownEvent = function keydownEvent(event) {
  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.ul) {
    switch (event.keyCode) {
      case 13:
        this.keyEnter(event);
        break;

      case 27:
        this.keyEscape(event);
        break;

      case 40:
        this.keyDown(event);
        break;

      case 38:
        this.keyUp(event);
        break;
    }
  }
};
/**
 * The input keyup event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.keyupEvent = function keyupEvent(event) {
  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;
};
/**
 * The input event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.inputEvent = function inputEvent(event) {
  var this$1 = this;

  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.input.value.length > 0) {
    this.scoredOptions = this.settings.options.map(function (option) {
      return this$1.settings.score(this$1.input.value, option);
    }).sort(function (a, b) {
      return b.score - a.score;
    });
  } else {
    this.scoredOptions = [];
  }

  this.dropdown();
};
/**
 * The input blur event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.blurEvent = function blurEvent(event) {
  if (event.target === window || !event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.input.dataset.persistDropdown === 'true') {
    return;
  }

  this.remove();
  this.highlighted = -1;
};
/**
 * KEY INPUT EVENTS
 */

/**
 * What happens when the user presses the down arrow
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyDown = function keyDown(event) {
  event.preventDefault();
  this.highlight(this.highlighted < this.ul.children.length - 1 ? this.highlighted + 1 : -1);
  return this;
};
/**
 * What happens when the user presses the up arrow
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyUp = function keyUp(event) {
  event.preventDefault();
  this.highlight(this.highlighted > -1 ? this.highlighted - 1 : this.ul.children.length - 1);
  return this;
};
/**
 * What happens when the user presses the enter key
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyEnter = function keyEnter(event) {
  this.selected();
  return this;
};
/**
 * What happens when the user presses the escape key
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyEscape = function keyEscape(event) {
  this.remove();
  return this;
};
/**
 * STATIC
 */

/**
 * It must return an object with at least the properties 'score'
 * and 'displayValue.' Default is a Jaro–Winkler similarity function.
 * @param{array}value
 * @param{array}synonyms
 * @return {int}  Score or displayValue
 */


Autocomplete.score = function score(value, synonyms) {
  var closestSynonym = null;
  synonyms.forEach(function (synonym) {
    var similarity = jaroWinkler(synonym.trim().toLowerCase(), value.trim().toLowerCase());

    if (closestSynonym === null || similarity > closestSynonym.similarity) {
      closestSynonym = {
        similarity: similarity,
        value: synonym
      };

      if (similarity === 1) {
        return;
      }
    }
  });
  return {
    score: closestSynonym.similarity,
    displayValue: synonyms[0]
  };
};
/**
 * List item for dropdown list.
 * @param{Number}scoredOption
 * @param{Number}index
 * @return {string}The a list item <li>.
 */


Autocomplete.listItem = function listItem(scoredOption, index, maxItems) {
  var normalizedIndex = index + 1; // start at 1

  var li = normalizedIndex > maxItems ? null : document.createElement('li');

  if (li) {
    li.setAttribute('role', 'option');
    li.setAttribute('tabindex', '-1');
    li.setAttribute('aria-selected', 'false');
  }

  li && li.appendChild(document.createTextNode(scoredOption.displayValue));
  return li;
};
/**
 * Get index of previous element.
 * @param{array} node
 * @return {number}index of previous element.
 */


Autocomplete.getSiblingIndex = function getSiblingIndex(node) {
  var index = -1;
  var n = node;

  do {
    index++;
    n = n.previousElementSibling;
  } while (n);

  return index;
};
/**
 * PUBLIC METHODS
 */

/**
 * Display options as a list.
 * @return{object} The Class
 */


Autocomplete.prototype.dropdown = function dropdown() {
  var this$1 = this;
  var documentFragment = document.createDocumentFragment();
  this.scoredOptions.every(function (scoredOption, i) {
    var listItem = this$1.settings.listItem(scoredOption, i, this$1.MAX_ITEMS);
    listItem && documentFragment.appendChild(listItem);
    return !!listItem;
  });
  this.remove();
  this.highlighted = -1;

  if (documentFragment.hasChildNodes()) {
    var newUl = document.createElement('ul');
    newUl.setAttribute('role', 'listbox');
    newUl.setAttribute('tabindex', '0');
    newUl.setAttribute('id', this.SELECTORS.OPTIONS);
    newUl.addEventListener('mouseover', function (event) {
      if (event.target.tagName === 'LI') {
        this$1.highlight(this$1.settings.getSiblingIndex(event.target));
      }
    });
    newUl.addEventListener('mousedown', function (event) {
      return event.preventDefault();
    });
    newUl.addEventListener('click', function (event) {
      if (event.target.tagName === 'LI') {
        this$1.selected();
      }
    });
    newUl.appendChild(documentFragment); // See CSS to understand why the <ul> has to be wrapped in a <div>

    var newContainer = document.createElement('div');
    newContainer.className = this.settings.classname;
    newContainer.appendChild(newUl);
    this.input.setAttribute('aria-expanded', 'true'); // Inserts the dropdown just after the <input> element

    this.input.parentNode.insertBefore(newContainer, this.input.nextSibling);
    this.container = newContainer;
    this.ul = newUl;
    this.message('TYPING', this.settings.options.length);
  }

  return this;
};
/**
 * Highlight new option selected.
 * @param {Number}newIndex
 * @return{object}The Class
 */


Autocomplete.prototype.highlight = function highlight(newIndex) {
  if (newIndex > -1 && newIndex < this.ul.children.length) {
    // If any option already selected, then unselect it
    if (this.highlighted !== -1) {
      this.ul.children[this.highlighted].classList.remove(this.SELECTORS.HIGHLIGHT);
      this.ul.children[this.highlighted].removeAttribute('aria-selected');
      this.ul.children[this.highlighted].removeAttribute('id');
      this.input.removeAttribute('aria-activedescendant');
    }

    this.highlighted = newIndex;

    if (this.highlighted !== -1) {
      this.ul.children[this.highlighted].classList.add(this.SELECTORS.HIGHLIGHT);
      this.ul.children[this.highlighted].setAttribute('aria-selected', 'true');
      this.ul.children[this.highlighted].setAttribute('id', this.SELECTORS.ACTIVE_DESCENDANT);
      this.input.setAttribute('aria-activedescendant', this.SELECTORS.ACTIVE_DESCENDANT);
    }
  }

  return this;
};
/**
 * Selects an option from a list of items.
 * @return{object} The Class
 */


Autocomplete.prototype.selected = function selected() {
  if (this.highlighted !== -1) {
    this.input.value = this.scoredOptions[this.highlighted].displayValue;
    this.remove();
    this.message('SELECTED', this.input.value);

    if (window.innerWidth <= 768) {
      this.input.scrollIntoView(true);
    }
  } // User provided callback method for selected option.


  if (this.settings.selected) {
    this.settings.selected(this.input.value, this);
  }

  return this;
};
/**
 * Remove dropdown list once a list item is selected.
 * @return{object} The Class
 */


Autocomplete.prototype.remove = function remove() {
  this.container && this.container.remove();
  this.input.setAttribute('aria-expanded', 'false');
  this.container = null;
  this.ul = null;
  return this;
};
/**
 * Messaging that is passed to the screen reader
 * @param {string}key     The Key of the message to write
 * @param {string}variableA variable to provide to the string.
 * @return{object}          The Class
 */


Autocomplete.prototype.message = function message(key, variable) {
  var this$1 = this;
  if (key === void 0) key = false;
  if (variable === void 0) variable = '';

  if (!key) {
    return this;
  }

  var messages = {
    'INIT': function INIT() {
      return this$1.STRINGS.DIRECTIONS_TYPE;
    },
    'TYPING': function TYPING() {
      return [this$1.STRINGS.OPTION_AVAILABLE.replace('{{ NUMBER }}', variable), this$1.STRINGS.DIRECTIONS_REVIEW].join('. ');
    },
    'SELECTED': function SELECTED() {
      return [this$1.STRINGS.OPTION_SELECTED.replace('{{ VALUE }}', variable), this$1.STRINGS.DIRECTIONS_TYPE].join('. ');
    }
  };
  document.querySelector("#" + this.input.getAttribute('aria-describedby')).innerHTML = messages[key]();
  return this;
};
/** Selectors for the Autocomplete class. */


Autocomplete.selectors = {
  'HIGHLIGHT': 'input-autocomplete__highlight',
  'OPTIONS': 'input-autocomplete__options',
  'ACTIVE_DESCENDANT': 'input-autocomplete__selected',
  'SCREEN_READER_ONLY': 'sr-only'
};
/**  */

Autocomplete.strings = {
  'DIRECTIONS_TYPE': 'Start typing to generate a list of potential input options',
  'DIRECTIONS_REVIEW': ['Keyboard users can use the up and down arrows to ', 'review options and press enter to select an option'].join(''),
  'OPTION_AVAILABLE': '{{ NUMBER }} options available',
  'OPTION_SELECTED': '{{ VALUE }} selected'
};
/** Maximum amount of results to be returned. */

Autocomplete.maxItems = 5;

/**
 * The InputAutocomplete class.
 */

var InputAutocomplete = function InputAutocomplete(settings) {
  if (settings === void 0) settings = {};
  this.library = new Autocomplete({
    options: settings.hasOwnProperty('options') ? settings.options : InputAutocomplete.options,
    selected: settings.hasOwnProperty('selected') ? settings.selected : false,
    selector: settings.hasOwnProperty('selector') ? settings.selector : InputAutocomplete.selector,
    classname: settings.hasOwnProperty('classname') ? settings.classname : InputAutocomplete.classname
  });
  return this;
};
/**
 * Setter for the Autocomplete options
 * @param{object} reset Set of array options for the Autocomplete class
 * @return {object} InputAutocomplete object with new options.
 */


InputAutocomplete.prototype.options = function options(reset) {
  this.library.settings.options = reset;
  return this;
};
/**
 * Setter for the Autocomplete strings
 * @param{object}localizedStringsObject containing strings.
 * @return {object} Autocomplete strings
 */


InputAutocomplete.prototype.strings = function strings(localizedStrings) {
  Object.assign(this.library.STRINGS, localizedStrings);
  return this;
};
/** @type {array} Default options for the autocomplete class */


InputAutocomplete.options = [];
/** @type {string} The search box dom selector */

InputAutocomplete.selector = '[data-js="input-autocomplete__input"]';
/** @type {string} The classname for the dropdown element */

InputAutocomplete.classname = 'input-autocomplete__dropdown';

/** import modules here as they are written */

/**
 * Methods for the global NycoPatterns instance
 */

var nyco = function nyco() {};

nyco.prototype.icons = function icons(path) {
  return new Icons(path);
};
/**
 * Method for the Feed Object
 * @param {Object}settingsSetting for the feed
 * @return{Object}          Feed instance
 */


nyco.prototype.feed = function feed(settings) {
  return new Feed(settings);
};
/**
 * Method for the Toggle Utility
 * @return{Object} Toggle instance
 */


nyco.prototype.toggle = function toggle(settings) {
  return new Toggle();
};
/**
 * Method for the Track Module
 * @return{Object} Track Module
 */


nyco.prototype.track = function track(settings) {
  return new Track();
};

nyco.prototype.select = function select() {
  return new Select();
};
/**
 * Method for the Chart Objects
 * @return{Object} Chart instance
 */


nyco.prototype.chart = function chart(type) {
  if (type === 'bar') {
    return new ChartBar();
  }

  if (type === 'horizontalBar') {
    return new ChartHorizontalBar();
  }

  if (type === 'line') {
    return new ChartLine();
  }

  if (type === 'pie') {
    return new ChartPie();
  }
};
/**
 * Method for the Map Module
 * @return{Object} Map Module
 */


nyco.prototype.map = function map(type) {
  if (type === 'multi') {
    return new MapMultiLayer();
  }

  if (type === 'single') {
    return new MapSingleLayer();
  }
};
/**
 * Method for the Input Autocomplete Element
 * @return{Object} Input Autocomplete instance
 */


nyco.prototype.inputAutocomplete = function inputAutocomplete(settings) {
  if (settings === void 0) settings = {};
  return new InputAutocomplete(settings);
};

module.exports = nyco;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTnljb1BhdHRlcm5zLmNvbW1vbi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2pzL21vZHVsZXMvdXRpbGl0eS5qcyIsIi4uLy4uL3NyYy9lbGVtZW50cy9pY29ucy9JY29ucy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvU291cmNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXROYXRpdmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlPYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXBwbHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyUmVzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY29uc3RhbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaG9ydE91dC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvU3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJlc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUFzc2lnbmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5c0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbkluV2l0aC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRXJyb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2F0dGVtcHQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXNjYXBlU3RyaW5nQ2hhci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlSW50ZXJwb2xhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUHJvcGVydHlPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZUh0bWxDaGFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUb1N0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VzY2FwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlRXNjYXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVFdmFsdWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGVTZXR0aW5ncy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUVhY2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGb3JPd24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRWFjaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdEZ1bmN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mb3JFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlQ2xlYXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NvY0luZGV4T2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19MaXN0Q2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0NsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaENsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0hhc2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXlhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWFwRGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwQ2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja1NldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N0YWNrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fVWludDhBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVR5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lT2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZU9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NhZmVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWVyZ2VEZWVwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1lcmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9tZXJnZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0Q2FjaGVBZGQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1NldENhY2hlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTb21lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEFycmF5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcFRvQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxCeVRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5UHVzaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlGaWx0ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFN5bWJvbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxPYmplY3RzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fRGF0YVZpZXcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19Qcm9taXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fV2Vha01hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTWF0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXRjaERhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXRjaGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21lbW9pemUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tZW1vaXplQ2FwcGVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaW5nVG9QYXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdFBhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b0tleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VIYXNJbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc1BhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2hhc0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3Byb3BlcnR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUl0ZXJhdGVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTb3J0QnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wYXJlQXNjZW5kaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29tcGFyZU11bHRpcGxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU9yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL29yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRmluZEluZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmFOLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaWN0SW5kZXhPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub29wLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlU2V0LmpzIiwiLi4vLi4vc3JjL29iamVjdHMvZmVlZC9GZWVkLmpzIiwiLi4vLi4vc3JjL3V0aWxpdGllcy90b2dnbGUvVG9nZ2xlLmpzIiwiLi4vLi4vc3JjL3V0aWxpdGllcy90cmFjay9UcmFjay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLmJyb3dzZXIuanMiLCIuLi8uLi9zcmMvZWxlbWVudHMvc2VsZWN0L3NlbGVjdC52dWUiLCIuLi8uLi9zcmMvZWxlbWVudHMvc2VsZWN0L3NlbGVjdC5kYXRhLmpzIiwiLi4vLi4vc3JjL2VsZW1lbnRzL3NlbGVjdC9zZWxlY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWNoYXJ0anMvZXMvbWl4aW5zL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9DaGFydC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUtY2hhcnRqcy9lcy9CYXNlQ2hhcnRzLmpzIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1iYXIudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LmRhdGEuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWJhci5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0taG9yaXpvbnRhbC1iYXIudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1ob3Jpem9udGFsLWJhci5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0tbGluZS52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWxpbmUuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZS52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZS5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL21hcC9tYXAudnVlIiwiLi4vLi4vY29uZmlnL2NvbG9ycy5qcyIsIi4uLy4uL3NyYy9qcy9tYXAuZGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9nZW9qc29uL2dlb2pzb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2dzODQvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hcGJveC9nZW9qc29uLWFyZWEvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZ2VvanNvbi1yZXdpbmQvaW5kZXguanMiLCIuLi8uLi9zcmMvanMvTWFwLmpzIiwiLi4vLi4vc3JjL2pzL21vZHVsZXMvamFyb1dpbmtsZXIuanMiLCIuLi8uLi9zcmMvanMvbW9kdWxlcy9tZW1vaXplLmpzIiwiLi4vLi4vc3JjL2pzL21vZHVsZXMvYXV0b2NvbXBsZXRlLmpzIiwiLi4vLi4vc3JjL2VsZW1lbnRzL2lucHV0cy9pbnB1dC1hdXRvY29tcGxldGUuanMiLCIuLi8uLi9zcmMvanMvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIFV0aWxpdHkgY2xhc3NcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBVdGlsaXR5IHtcbiAgLyoqXG4gICAqIFRoZSBVdGlsaXR5IGNvbnN0cnVjdG9yXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIFV0aWxpdHkgY2xhc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxuICogQm9vbGVhbiBmb3IgZGVidWcgbW9kZVxuICogQHJldHVybiB7Ym9vbGVhbn0gd2V0aGVyIG9yIG5vdCB0aGUgZnJvbnQtZW5kIGlzIGluIGRlYnVnIG1vZGUuXG4gKi9cblV0aWxpdHkuZGVidWcgPSAoKSA9PiAoVXRpbGl0eS5nZXRVcmxQYXJhbWV0ZXIoVXRpbGl0eS5QQVJBTVMuREVCVUcpID09PSAnMScpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4ga2V5IGluIGEgVVJMIHF1ZXJ5IHN0cmluZy4gSWYgbm8gVVJMIHF1ZXJ5XG4gKiBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBjdXJyZW50IFVSTCBsb2NhdGlvbiBpcyB1c2VkLlxuICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgICAgICAgLSBLZXkgbmFtZS5cbiAqIEBwYXJhbSAgez9zdHJpbmd9IHF1ZXJ5U3RyaW5nIC0gT3B0aW9uYWwgcXVlcnkgc3RyaW5nIHRvIGNoZWNrLlxuICogQHJldHVybiB7P3N0cmluZ30gUXVlcnkgcGFyYW1ldGVyIHZhbHVlLlxuICovXG5VdGlsaXR5LmdldFVybFBhcmFtZXRlciA9IChuYW1lLCBxdWVyeVN0cmluZykgPT4ge1xuICBjb25zdCBxdWVyeSA9IHF1ZXJ5U3RyaW5nIHx8IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XG4gIGNvbnN0IHBhcmFtID0gbmFtZS5yZXBsYWNlKC9bXFxbXS8sICdcXFxcWycpLnJlcGxhY2UoL1tcXF1dLywgJ1xcXFxdJyk7XG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW1xcXFw/Jl0nICsgcGFyYW0gKyAnPShbXiYjXSopJyk7XG4gIGNvbnN0IHJlc3VsdHMgPSByZWdleC5leGVjKHF1ZXJ5KTtcblxuICByZXR1cm4gcmVzdWx0cyA9PT0gbnVsbCA/ICcnIDpcbiAgICBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG59O1xuXG4vKipcbiAqIEZvciB0cmFuc2xhdGluZyBzdHJpbmdzLCB0aGVyZSBpcyBhIGdsb2JhbCBMT0NBTElaRURfU1RSSU5HUyBhcnJheSB0aGF0XG4gKiBpcyBkZWZpbmVkIG9uIHRoZSBIVE1MIHRlbXBsYXRlIGxldmVsIHNvIHRoYXQgdGhvc2Ugc3RyaW5ncyBhcmUgZXhwb3NlZCB0b1xuICogV1BNTCB0cmFuc2xhdGlvbi4gVGhlIExPQ0FMSVpFRF9TVFJJTkdTIGFycmF5IGlzIGNvbXBvc2VkIG9mIG9iamVjdHMgd2l0aCBhXG4gKiBgc2x1Z2Aga2V5IHdob3NlIHZhbHVlIGlzIHNvbWUgY29uc3RhbnQsIGFuZCBhIGBsYWJlbGAgdmFsdWUgd2hpY2ggaXMgdGhlXG4gKiB0cmFuc2xhdGVkIGVxdWl2YWxlbnQuIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBzbHVnIG5hbWUgYW5kIHJldHVybnMgdGhlXG4gKiBsYWJlbC5cbiAqIEBwYXJhbSAge3N0cmluZ30gc2x1Z1xuICogQHJldHVybiB7c3RyaW5nfSBsb2NhbGl6ZWQgdmFsdWVcbiAqL1xuVXRpbGl0eS5sb2NhbGl6ZSA9IGZ1bmN0aW9uKHNsdWcpIHtcbiAgbGV0IHRleHQgPSBzbHVnIHx8ICcnO1xuICBjb25zdCBzdHJpbmdzID0gd2luZG93LkxPQ0FMSVpFRF9TVFJJTkdTIHx8IFtdO1xuICBjb25zdCBtYXRjaCA9IHN0cmluZ3MuZmlsdGVyKFxuICAgIChzKSA9PiAocy5oYXNPd25Qcm9wZXJ0eSgnc2x1ZycpICYmIHNbJ3NsdWcnXSA9PT0gc2x1ZykgPyBzIDogZmFsc2VcbiAgKTtcbiAgcmV0dXJuIChtYXRjaFswXSAmJiBtYXRjaFswXS5oYXNPd25Qcm9wZXJ0eSgnbGFiZWwnKSkgPyBtYXRjaFswXS5sYWJlbCA6IHRleHQ7XG59O1xuXG4vKipcbiAqIEFwcGxpY2F0aW9uIHBhcmFtZXRlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblV0aWxpdHkuUEFSQU1TID0ge1xuICBERUJVRzogJ2RlYnVnJ1xufTtcblxuLyoqXG4gKiBTZWxlY3RvcnMgZm9yIHRoZSBVdGlsaXR5IG1vZHVsZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuVXRpbGl0eS5TRUxFQ1RPUlMgPSB7XG4gIHBhcnNlTWFya2Rvd246ICdbZGF0YS1qcz1cIm1hcmtkb3duXCJdJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVXRpbGl0eTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFV0aWxpdHkgZnJvbSAnLi4vLi4vanMvbW9kdWxlcy91dGlsaXR5JztcblxuLyoqXG4gKiBUaGUgSWNvbiBtb2R1bGVcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBJY29ucyB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBpY29uIGZpbGVcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgY2xhc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhdGgpIHtcbiAgICBwYXRoID0gKHBhdGgpID8gcGF0aCA6IEljb25zLnBhdGg7XG5cbiAgICBmZXRjaChwYXRoKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaylcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihyZXNwb25zZSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihlcnJvcik7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3Qgc3ByaXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHNwcml0ZS5pbm5lckhUTUwgPSBkYXRhO1xuICAgICAgICBzcHJpdGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgICBzcHJpdGUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNwcml0ZSk7XG4gICAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgcGF0aCBvZiB0aGUgaWNvbiBmaWxlICovXG5JY29ucy5wYXRoID0gJ2ljb25zLnN2Zyc7XG5cbmV4cG9ydCBkZWZhdWx0IEljb25zO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbmV4cG9ydCBkZWZhdWx0IGNvcmVKc0RhdGE7XG4iLCJpbXBvcnQgY29yZUpzRGF0YSBmcm9tICcuL19jb3JlSnNEYXRhLmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU291cmNlO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc01hc2tlZCBmcm9tICcuL19pc01hc2tlZC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYXRpdmU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VmFsdWU7XG4iLCJpbXBvcnQgYmFzZUlzTmF0aXZlIGZyb20gJy4vX2Jhc2VJc05hdGl2ZS5qcyc7XG5pbXBvcnQgZ2V0VmFsdWUgZnJvbSAnLi9fZ2V0VmFsdWUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXROYXRpdmU7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVQcm9wZXJ0eTtcbiIsImltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcTtcbiIsImltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduVmFsdWU7XG4iLCJpbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlkZW50aXR5O1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcHBseTtcbiIsImltcG9ydCBhcHBseSBmcm9tICcuL19hcHBseS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJSZXN0O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnN0YW50O1xuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gJy4vY29uc3RhbnQuanMnO1xuaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZVByb3BlcnR5LmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hvcnRPdXQ7XG4iLCJpbXBvcnQgYmFzZVNldFRvU3RyaW5nIGZyb20gJy4vX2Jhc2VTZXRUb1N0cmluZy5qcyc7XG5pbXBvcnQgc2hvcnRPdXQgZnJvbSAnLi9fc2hvcnRPdXQuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5leHBvcnQgZGVmYXVsdCBzZXRUb1N0cmluZztcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBvdmVyUmVzdCBmcm9tICcuL19vdmVyUmVzdC5qcyc7XG5pbXBvcnQgc2V0VG9TdHJpbmcgZnJvbSAnLi9fc2V0VG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJlc3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0luZGV4O1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJdGVyYXRlZUNhbGw7XG4iLCJpbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGlzSXRlcmF0ZWVDYWxsIGZyb20gJy4vX2lzSXRlcmF0ZWVDYWxsLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQXNzaWduZXI7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVGltZXM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzQXJndW1lbnRzO1xuIiwiaW1wb3J0IGJhc2VJc0FyZ3VtZW50cyBmcm9tICcuL19iYXNlSXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViRmFsc2U7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzSW47XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXNJbiBmcm9tICcuL19uYXRpdmVLZXlzSW4uanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5c0luO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXNJbiBmcm9tICcuL19iYXNlS2V5c0luLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXNJbjtcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGNyZWF0ZUFzc2lnbmVyIGZyb20gJy4vX2NyZWF0ZUFzc2lnbmVyLmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBhbGlhcyBleHRlbmRXaXRoXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbldpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAqIH1cbiAqXG4gKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gKlxuICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduSW5XaXRoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJBcmc7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFByb3RvdHlwZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFcnJvcihFcnJvcik7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Vycm9yO1xuIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcbmltcG9ydCBiYXNlUmVzdCBmcm9tICcuL19iYXNlUmVzdC5qcyc7XG5pbXBvcnQgaXNFcnJvciBmcm9tICcuL2lzRXJyb3IuanMnO1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICogfSwgJz5fPicpO1xuICpcbiAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gKiAgIGVsZW1lbnRzID0gW107XG4gKiB9XG4gKi9cbnZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXR0ZW1wdDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VWYWx1ZXM7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICByZXR1cm4gc3JjVmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9ialZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluO1xuIiwiLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgJ1xcXFwnOiAnXFxcXCcsXG4gIFwiJ1wiOiBcIidcIixcbiAgJ1xcbic6ICduJyxcbiAgJ1xccic6ICdyJyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGVTdHJpbmdDaGFyO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzIGZyb20gJy4vX2Jhc2VLZXlzLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXM7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVJbnRlcnBvbGF0ZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5T2Y7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5T2YgZnJvbSAnLi9fYmFzZVByb3BlcnR5T2YuanMnO1xuXG4vKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xudmFyIGh0bWxFc2NhcGVzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbnZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlSHRtbENoYXI7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUb1N0cmluZztcbiIsImltcG9ydCBiYXNlVG9TdHJpbmcgZnJvbSAnLi9fYmFzZVRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1N0cmluZztcbiIsImltcG9ydCBlc2NhcGVIdG1sQ2hhciBmcm9tICcuL19lc2NhcGVIdG1sQ2hhci5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbnZhciByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gKlxuICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAqXG4gKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAqIFhTUyB2ZWN0b3JzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVzY2FwZTtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVFc2NhcGU7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nO1xuXG5leHBvcnQgZGVmYXVsdCByZUV2YWx1YXRlO1xuIiwiaW1wb3J0IGVzY2FwZSBmcm9tICcuL2VzY2FwZS5qcyc7XG5pbXBvcnQgcmVFc2NhcGUgZnJvbSAnLi9fcmVFc2NhcGUuanMnO1xuaW1wb3J0IHJlRXZhbHVhdGUgZnJvbSAnLi9fcmVFdmFsdWF0ZS5qcyc7XG5pbXBvcnQgcmVJbnRlcnBvbGF0ZSBmcm9tICcuL19yZUludGVycG9sYXRlLmpzJztcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgJ2ltcG9ydHMnOiB7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgJ18nOiB7ICdlc2NhcGUnOiBlc2NhcGUgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZVNldHRpbmdzO1xuIiwiaW1wb3J0IGFzc2lnbkluV2l0aCBmcm9tICcuL2Fzc2lnbkluV2l0aC5qcyc7XG5pbXBvcnQgYXR0ZW1wdCBmcm9tICcuL2F0dGVtcHQuanMnO1xuaW1wb3J0IGJhc2VWYWx1ZXMgZnJvbSAnLi9fYmFzZVZhbHVlcy5qcyc7XG5pbXBvcnQgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiBmcm9tICcuL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzJztcbmltcG9ydCBlc2NhcGVTdHJpbmdDaGFyIGZyb20gJy4vX2VzY2FwZVN0cmluZ0NoYXIuanMnO1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi9pc0Vycm9yLmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuaW1wb3J0IHJlSW50ZXJwb2xhdGUgZnJvbSAnLi9fcmVJbnRlcnBvbGF0ZS5qcyc7XG5pbXBvcnQgdGVtcGxhdGVTZXR0aW5ncyBmcm9tICcuL3RlbXBsYXRlU2V0dGluZ3MuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xudmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2hcbiAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gKi9cbnZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbi8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICpcbiAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSd0ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAqXG4gKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAqXG4gKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICpcbiAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICpcbiAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gKlxuICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gKiBjb21waWxlZChkYXRhKTtcbiAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gKlxuICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gKiBjb21waWxlZC5zb3VyY2U7XG4gKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gKiAvLyAgIHJldHVybiBfX3A7XG4gKiAvLyB9XG4gKlxuICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gKiAgIHZhciBKU1QgPSB7XFxcbiAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICogICB9O1xcXG4gKiAnKTtcbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gIHZhciBzZXR0aW5ncyA9IHRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0cy5fLnRlbXBsYXRlU2V0dGluZ3MgfHwgdGVtcGxhdGVTZXR0aW5ncztcblxuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICB2YXIgaXNFc2NhcGluZyxcbiAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICwgJ2cnKTtcblxuICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gIHZhciBzb3VyY2VVUkwgPSAnc291cmNlVVJMJyBpbiBvcHRpb25zID8gJy8vIyBzb3VyY2VVUkw9JyArIG9wdGlvbnMuc291cmNlVVJMICsgJ1xcbicgOiAnJztcblxuICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgfVxuICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICB9XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgIHJldHVybiBtYXRjaDtcbiAgfSk7XG5cbiAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgdmFyIHZhcmlhYmxlID0gb3B0aW9ucy52YXJpYWJsZTtcbiAgaWYgKCF2YXJpYWJsZSkge1xuICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICB9XG4gIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgKHZhcmlhYmxlXG4gICAgICA/ICcnXG4gICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgKSArXG4gICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAoaXNFc2NhcGluZ1xuICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgOiAnJ1xuICAgICkgK1xuICAgIChpc0V2YWx1YXRpbmdcbiAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgIDogJztcXG4nXG4gICAgKSArXG4gICAgc291cmNlICtcbiAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gIH0pO1xuXG4gIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgdGhyb3cgcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRlbXBsYXRlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUVhY2g7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQmFzZUZvcjtcbiIsImltcG9ydCBjcmVhdGVCYXNlRm9yIGZyb20gJy4vX2NyZWF0ZUJhc2VGb3IuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGb3I7XG4iLCJpbXBvcnQgYmFzZUZvciBmcm9tICcuL19iYXNlRm9yLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUZvck93bjtcbiIsImltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQmFzZUVhY2g7XG4iLCJpbXBvcnQgYmFzZUZvck93biBmcm9tICcuL19iYXNlRm9yT3duLmpzJztcbmltcG9ydCBjcmVhdGVCYXNlRWFjaCBmcm9tICcuL19jcmVhdGVCYXNlRWFjaC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlRWFjaDtcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FzdEZ1bmN0aW9uO1xuIiwiaW1wb3J0IGFycmF5RWFjaCBmcm9tICcuL19hcnJheUVhY2guanMnO1xuaW1wb3J0IGJhc2VFYWNoIGZyb20gJy4vX2Jhc2VFYWNoLmpzJztcbmltcG9ydCBjYXN0RnVuY3Rpb24gZnJvbSAnLi9fY2FzdEZ1bmN0aW9uLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGFsaWFzIGVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQHNlZSBfLmZvckVhY2hSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICpcbiAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGNhc3RGdW5jdGlvbihpdGVyYXRlZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JFYWNoO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVDbGVhcjtcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzb2NJbmRleE9mO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZURlbGV0ZTtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlR2V0O1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlSGFzO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZVNldDtcbiIsImltcG9ydCBsaXN0Q2FjaGVDbGVhciBmcm9tICcuL19saXN0Q2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbGlzdENhY2hlRGVsZXRlIGZyb20gJy4vX2xpc3RDYWNoZURlbGV0ZS5qcyc7XG5pbXBvcnQgbGlzdENhY2hlR2V0IGZyb20gJy4vX2xpc3RDYWNoZUdldC5qcyc7XG5pbXBvcnQgbGlzdENhY2hlSGFzIGZyb20gJy4vX2xpc3RDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbGlzdENhY2hlU2V0IGZyb20gJy4vX2xpc3RDYWNoZVNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTGlzdENhY2hlO1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0hhcztcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVDcmVhdGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoRGVsZXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hHZXQ7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEhhcztcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hTZXQ7XG4iLCJpbXBvcnQgaGFzaENsZWFyIGZyb20gJy4vX2hhc2hDbGVhci5qcyc7XG5pbXBvcnQgaGFzaERlbGV0ZSBmcm9tICcuL19oYXNoRGVsZXRlLmpzJztcbmltcG9ydCBoYXNoR2V0IGZyb20gJy4vX2hhc2hHZXQuanMnO1xuaW1wb3J0IGhhc2hIYXMgZnJvbSAnLi9faGFzaEhhcy5qcyc7XG5pbXBvcnQgaGFzaFNldCBmcm9tICcuL19oYXNoU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IEhhc2g7XG4iLCJpbXBvcnQgSGFzaCBmcm9tICcuL19IYXNoLmpzJztcbmltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0tleWFibGU7XG4iLCJpbXBvcnQgaXNLZXlhYmxlIGZyb20gJy4vX2lzS2V5YWJsZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TWFwRGF0YTtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUdldDtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUhhcztcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlU2V0O1xuIiwiaW1wb3J0IG1hcENhY2hlQ2xlYXIgZnJvbSAnLi9fbWFwQ2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVEZWxldGUgZnJvbSAnLi9fbWFwQ2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IG1hcENhY2hlR2V0IGZyb20gJy4vX21hcENhY2hlR2V0LmpzJztcbmltcG9ydCBtYXBDYWNoZUhhcyBmcm9tICcuL19tYXBDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVTZXQgZnJvbSAnLi9fbWFwQ2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTWFwQ2FjaGU7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5pbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tTZXQ7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgc3RhY2tDbGVhciBmcm9tICcuL19zdGFja0NsZWFyLmpzJztcbmltcG9ydCBzdGFja0RlbGV0ZSBmcm9tICcuL19zdGFja0RlbGV0ZS5qcyc7XG5pbXBvcnQgc3RhY2tHZXQgZnJvbSAnLi9fc3RhY2tHZXQuanMnO1xuaW1wb3J0IHN0YWNrSGFzIGZyb20gJy4vX3N0YWNrSGFzLmpzJztcbmltcG9ydCBzdGFja1NldCBmcm9tICcuL19zdGFja1NldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuZXhwb3J0IGRlZmF1bHQgU3RhY2s7XG4iLCJpbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVCdWZmZXI7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgVWludDhBcnJheTtcbiIsImltcG9ydCBVaW50OEFycmF5IGZyb20gJy4vX1VpbnQ4QXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJpbXBvcnQgY2xvbmVBcnJheUJ1ZmZlciBmcm9tICcuL19jbG9uZUFycmF5QnVmZmVyLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlBcnJheTtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUNyZWF0ZTtcbiIsImltcG9ydCBiYXNlQ3JlYXRlIGZyb20gJy4vX2Jhc2VDcmVhdGUuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpbml0Q2xvbmVPYmplY3Q7XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZU9iamVjdDtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzYWZlR2V0O1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1BsYWluT2JqZWN0O1xuIiwiaW1wb3J0IGFzc2lnbk1lcmdlVmFsdWUgZnJvbSAnLi9fYXNzaWduTWVyZ2VWYWx1ZS5qcyc7XG5pbXBvcnQgY2xvbmVCdWZmZXIgZnJvbSAnLi9fY2xvbmVCdWZmZXIuanMnO1xuaW1wb3J0IGNsb25lVHlwZWRBcnJheSBmcm9tICcuL19jbG9uZVR5cGVkQXJyYXkuanMnO1xuaW1wb3J0IGNvcHlBcnJheSBmcm9tICcuL19jb3B5QXJyYXkuanMnO1xuaW1wb3J0IGluaXRDbG9uZU9iamVjdCBmcm9tICcuL19pbml0Q2xvbmVPYmplY3QuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0FycmF5TGlrZU9iamVjdCBmcm9tICcuL2lzQXJyYXlMaWtlT2JqZWN0LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QuanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgc2FmZUdldCBmcm9tICcuL19zYWZlR2V0LmpzJztcbmltcG9ydCB0b1BsYWluT2JqZWN0IGZyb20gJy4vdG9QbGFpbk9iamVjdC5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNZXJnZURlZXA7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGFzc2lnbk1lcmdlVmFsdWUgZnJvbSAnLi9fYXNzaWduTWVyZ2VWYWx1ZS5qcyc7XG5pbXBvcnQgYmFzZUZvciBmcm9tICcuL19iYXNlRm9yLmpzJztcbmltcG9ydCBiYXNlTWVyZ2VEZWVwIGZyb20gJy4vX2Jhc2VNZXJnZURlZXAuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5pbXBvcnQgc2FmZUdldCBmcm9tICcuL19zYWZlR2V0LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNZXJnZTtcbiIsImltcG9ydCBiYXNlTWVyZ2UgZnJvbSAnLi9fYmFzZU1lcmdlLmpzJztcbmltcG9ydCBjcmVhdGVBc3NpZ25lciBmcm9tICcuL19jcmVhdGVBc3NpZ25lci5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtZXJnZTtcbiIsImltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlcztcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0Q2FjaGVIYXM7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuaW1wb3J0IHNldENhY2hlQWRkIGZyb20gJy4vX3NldENhY2hlQWRkLmpzJztcbmltcG9ydCBzZXRDYWNoZUhhcyBmcm9tICcuL19zZXRDYWNoZUhhcy5qcyc7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuZXhwb3J0IGRlZmF1bHQgU2V0Q2FjaGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVNvbWU7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FjaGVIYXM7XG4iLCJpbXBvcnQgU2V0Q2FjaGUgZnJvbSAnLi9fU2V0Q2FjaGUuanMnO1xuaW1wb3J0IGFycmF5U29tZSBmcm9tICcuL19hcnJheVNvbWUuanMnO1xuaW1wb3J0IGNhY2hlSGFzIGZyb20gJy4vX2NhY2hlSGFzLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxBcnJheXM7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBUb0FycmF5O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0VG9BcnJheTtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBVaW50OEFycmF5IGZyb20gJy4vX1VpbnQ4QXJyYXkuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuaW1wb3J0IGVxdWFsQXJyYXlzIGZyb20gJy4vX2VxdWFsQXJyYXlzLmpzJztcbmltcG9ydCBtYXBUb0FycmF5IGZyb20gJy4vX21hcFRvQXJyYXkuanMnO1xuaW1wb3J0IHNldFRvQXJyYXkgZnJvbSAnLi9fc2V0VG9BcnJheS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsQnlUYWc7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5UHVzaDtcbiIsImltcG9ydCBhcnJheVB1c2ggZnJvbSAnLi9fYXJyYXlQdXNoLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldEFsbEtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5RmlsdGVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkFycmF5O1xuIiwiaW1wb3J0IGFycmF5RmlsdGVyIGZyb20gJy4vX2FycmF5RmlsdGVyLmpzJztcbmltcG9ydCBzdHViQXJyYXkgZnJvbSAnLi9zdHViQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGdldFN5bWJvbHM7XG4iLCJpbXBvcnQgYmFzZUdldEFsbEtleXMgZnJvbSAnLi9fYmFzZUdldEFsbEtleXMuanMnO1xuaW1wb3J0IGdldFN5bWJvbHMgZnJvbSAnLi9fZ2V0U3ltYm9scy5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRBbGxLZXlzO1xuIiwiaW1wb3J0IGdldEFsbEtleXMgZnJvbSAnLi9fZ2V0QWxsS2V5cy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbE9iamVjdHM7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhVmlldztcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9taXNlO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5leHBvcnQgZGVmYXVsdCBTZXQ7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgV2Vha01hcDtcbiIsImltcG9ydCBEYXRhVmlldyBmcm9tICcuL19EYXRhVmlldy5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuL19Qcm9taXNlLmpzJztcbmltcG9ydCBTZXQgZnJvbSAnLi9fU2V0LmpzJztcbmltcG9ydCBXZWFrTWFwIGZyb20gJy4vX1dlYWtNYXAuanMnO1xuaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRUYWc7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGVxdWFsQXJyYXlzIGZyb20gJy4vX2VxdWFsQXJyYXlzLmpzJztcbmltcG9ydCBlcXVhbEJ5VGFnIGZyb20gJy4vX2VxdWFsQnlUYWcuanMnO1xuaW1wb3J0IGVxdWFsT2JqZWN0cyBmcm9tICcuL19lcXVhbE9iamVjdHMuanMnO1xuaW1wb3J0IGdldFRhZyBmcm9tICcuL19nZXRUYWcuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzRXF1YWxEZWVwO1xuIiwiaW1wb3J0IGJhc2VJc0VxdWFsRGVlcCBmcm9tICcuL19iYXNlSXNFcXVhbERlZXAuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNFcXVhbDtcbiIsImltcG9ydCBTdGFjayBmcm9tICcuL19TdGFjay5qcyc7XG5pbXBvcnQgYmFzZUlzRXF1YWwgZnJvbSAnLi9fYmFzZUlzRXF1YWwuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTWF0Y2g7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiaW1wb3J0IGlzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19pc1N0cmljdENvbXBhcmFibGUuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE1hdGNoRGF0YTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJpbXBvcnQgYmFzZUlzTWF0Y2ggZnJvbSAnLi9fYmFzZUlzTWF0Y2guanMnO1xuaW1wb3J0IGdldE1hdGNoRGF0YSBmcm9tICcuL19nZXRNYXRjaERhdGEuanMnO1xuaW1wb3J0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXRjaGVzO1xuIiwiaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0tleTtcbiIsImltcG9ydCBNYXBDYWNoZSBmcm9tICcuL19NYXBDYWNoZS5qcyc7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZTtcbiIsImltcG9ydCBtZW1vaXplIGZyb20gJy4vbWVtb2l6ZS5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWVtb2l6ZUNhcHBlZDtcbiIsImltcG9ydCBtZW1vaXplQ2FwcGVkIGZyb20gJy4vX21lbW9pemVDYXBwZWQuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ1RvUGF0aDtcbiIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNLZXkgZnJvbSAnLi9faXNLZXkuanMnO1xuaW1wb3J0IHN0cmluZ1RvUGF0aCBmcm9tICcuL19zdHJpbmdUb1BhdGguanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYXN0UGF0aDtcbiIsImltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvS2V5O1xuIiwiaW1wb3J0IGNhc3RQYXRoIGZyb20gJy4vX2Nhc3RQYXRoLmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXQ7XG4iLCJpbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXQ7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUhhc0luO1xuIiwiaW1wb3J0IGNhc3RQYXRoIGZyb20gJy4vX2Nhc3RQYXRoLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNQYXRoO1xuIiwiaW1wb3J0IGJhc2VIYXNJbiBmcm9tICcuL19iYXNlSGFzSW4uanMnO1xuaW1wb3J0IGhhc1BhdGggZnJvbSAnLi9faGFzUGF0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzSW47XG4iLCJpbXBvcnQgYmFzZUlzRXF1YWwgZnJvbSAnLi9fYmFzZUlzRXF1YWwuanMnO1xuaW1wb3J0IGdldCBmcm9tICcuL2dldC5qcyc7XG5pbXBvcnQgaGFzSW4gZnJvbSAnLi9oYXNJbi5qcyc7XG5pbXBvcnQgaXNLZXkgZnJvbSAnLi9faXNLZXkuanMnO1xuaW1wb3J0IGlzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19pc1N0cmljdENvbXBhcmFibGUuanMnO1xuaW1wb3J0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIGZyb20gJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1hdGNoZXNQcm9wZXJ0eTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eTtcbiIsImltcG9ydCBiYXNlR2V0IGZyb20gJy4vX2Jhc2VHZXQuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5RGVlcDtcbiIsImltcG9ydCBiYXNlUHJvcGVydHkgZnJvbSAnLi9fYmFzZVByb3BlcnR5LmpzJztcbmltcG9ydCBiYXNlUHJvcGVydHlEZWVwIGZyb20gJy4vX2Jhc2VQcm9wZXJ0eURlZXAuanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJvcGVydHk7XG4iLCJpbXBvcnQgYmFzZU1hdGNoZXMgZnJvbSAnLi9fYmFzZU1hdGNoZXMuanMnO1xuaW1wb3J0IGJhc2VNYXRjaGVzUHJvcGVydHkgZnJvbSAnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IHByb3BlcnR5IGZyb20gJy4vcHJvcGVydHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXRlcmF0ZWU7XG4iLCJpbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWFwO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNvcnRCeTtcbiIsImltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcblxuLyoqXG4gKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wYXJlQXNjZW5kaW5nO1xuIiwiaW1wb3J0IGNvbXBhcmVBc2NlbmRpbmcgZnJvbSAnLi9fY29tcGFyZUFzY2VuZGluZy5qcyc7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBhcmVNdWx0aXBsZTtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgYmFzZU1hcCBmcm9tICcuL19iYXNlTWFwLmpzJztcbmltcG9ydCBiYXNlU29ydEJ5IGZyb20gJy4vX2Jhc2VTb3J0QnkuanMnO1xuaW1wb3J0IGJhc2VVbmFyeSBmcm9tICcuL19iYXNlVW5hcnkuanMnO1xuaW1wb3J0IGNvbXBhcmVNdWx0aXBsZSBmcm9tICcuL19jb21wYXJlTXVsdGlwbGUuanMnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IGl0ZXJhdGVlcyBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICB2YXIgaW5kZXggPSAtMTtcbiAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLmxlbmd0aCA/IGl0ZXJhdGVlcyA6IFtpZGVudGl0eV0sIGJhc2VVbmFyeShiYXNlSXRlcmF0ZWUpKTtcblxuICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU9yZGVyQnk7XG4iLCJpbXBvcnQgYmFzZU9yZGVyQnkgZnJvbSAnLi9fYmFzZU9yZGVyQnkuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIHNvcnRcbiAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXG4gKiBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvclxuICogZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBcnJheVtdfEZ1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICogXTtcbiAqXG4gKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gKiBfLm9yZGVyQnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICovXG5mdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICB9XG4gIG9yZGVycyA9IGd1YXJkID8gdW5kZWZpbmVkIDogb3JkZXJzO1xuICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgIG9yZGVycyA9IG9yZGVycyA9PSBudWxsID8gW10gOiBbb3JkZXJzXTtcbiAgfVxuICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvcmRlckJ5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGaW5kSW5kZXg7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYU47XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmljdEluZGV4T2Y7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUluY2x1ZGVzV2l0aDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5vb3A7XG4iLCJpbXBvcnQgU2V0IGZyb20gJy4vX1NldC5qcyc7XG5pbXBvcnQgbm9vcCBmcm9tICcuL25vb3AuanMnO1xuaW1wb3J0IHNldFRvQXJyYXkgZnJvbSAnLi9fc2V0VG9BcnJheS5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAqL1xudmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVNldDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuaW1wb3J0IF90ZW1wbGF0ZSBmcm9tICdsb2Rhc2gtZXMvdGVtcGxhdGUnO1xuaW1wb3J0IF9mb3JFYWNoIGZyb20gJ2xvZGFzaC1lcy9mb3JFYWNoJztcbmltcG9ydCBfbWVyZ2UgZnJvbSAnbG9kYXNoLWVzL21lcmdlJztcbmltcG9ydCBfdmFsdWVzIGZyb20gJ2xvZGFzaC1lcy92YWx1ZXMnO1xuaW1wb3J0IF9vcmRlckJ5IGZyb20gJ2xvZGFzaC1lcy9vcmRlckJ5JztcbmltcG9ydCBfdW5pcUJ5IGZyb20gJ2xvZGFzaC1lcy91bmlxQnknO1xuXG4vKipcbiAqXG4gKi9cbmNsYXNzIEZlZWQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmRlZmF1bHQgPSBGZWVkLmRlZmF1bHQ7XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IF9tZXJnZSh7fSwgRmVlZC5kZWZhdWx0LCBjb25maWcpO1xuXG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBsZXQgZGF0YSA9IFtdO1xuICAgIGxldCBmZWVkID0gdGhpcy5fc2V0dGluZ3MuZmVlZDtcbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgcnNzVG9Kc29uOiBGZWVkLnJzc1RvSnNvbixcbiAgICAgIHJzc1VybDogKEFycmF5LmlzQXJyYXkoZmVlZCkpID8gZmVlZCA6IFtmZWVkXVxuICAgIH07XG5cbiAgICAvLyBHbyB0aHJvdWdoIGVhY2ggZmVlZFxuICAgIF9mb3JFYWNoKGNvbmZpZy5yc3NVcmwsICh1cmwsIGluZGV4KSA9PiB7XG4gICAgICAvLyBNYWtlIHRoZSByZXF1ZXN0XG4gICAgICB0aGlzLl9yZXF1ZXN0KGNvbmZpZywgdXJsKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGRhdGFcbiAgICAgICAgICBkYXRhLnB1c2godGhpcy5fcHJvY2VzcyhKU09OLnBhcnNlKHJlc3BvbnNlKSwgdGhpcy5fc2V0dGluZ3MpKTtcbiAgICAgICAgICAvLyBXaGVuIGFsbCBmZWVkcyBoYXZlIGJlZW4gcmVxdWVzdGVkLCBtZXJnZSB0aGUgZGF0YSBhbmQgY29tcGlsZVxuICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gY29uZmlnLnJzc1VybC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX21lcmdlKGRhdGEsIHRoaXMuX3NldHRpbmdzKTtcblxuICAgICAgICAgICAgbGV0IGNvbXBpbGVkID0gdGhpcy5fcmVuZGVyKFxuICAgICAgICAgICAgICB0aGlzLl9tZXJnZShkYXRhLCB0aGlzLl9zZXR0aW5ncyksXG4gICAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuX3NldHRpbmdzLnNlbGVjdG9yKTtcbiAgICAgICAgICAgIGlmIChlbCkgZWwuaW5uZXJIVE1MID0gY29tcGlsZWQ7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gWEhSIHJlcXVlc3QgZm9yIHRoZSBmZWVkIGRhdGFcbiAgICogQHBhcmFtICB7b2JqZWN0fSBjb25maWcgVGhlIHJlcXVlc3QgZGF0YVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAgICBUaGUgcmVxdWVzdCB1cmxcbiAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgUmVzb2x2ZXMgd2hlbiB0aGUgcmVzcG9uc2UgaXMgcmVhZHksIHJlamVjdHMgd2hlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgb3BlcmF0aW9uIHRpbWVzIG91dCBvciB0aGVyZSBpcyBhbiBlcnJvci5cbiAgICovXG4gIF9yZXF1ZXN0KGNvbmZpZywgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBsZXQgX3hociA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKF94aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIGlmIChfeGhyLnN0YXR1cyA+PSAyMDAgJiYgX3hoci5zdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAgIHJlc29sdmUoX3hoci5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoX3hoci5zdGF0dXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBGZWVkIHJlcXVlc3QgdGltZWQgb3V0JykpO1xuICAgICAgfTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCBgJHtjb25maWcucnNzVG9Kc29ufT9yc3NfdXJsPSR7dXJsfWAsIHRydWUpO1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICAgIHhociA9IG51bGw7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFzcyBkYXRhIHRvIHRoZSBhcHByb3ByaWF0ZSBwcm9jZXNzaW5nIGZ1bmN0aW9uIGJhc2VkIG9uIHR5cGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBkYXRhICAgICBUaGUgcmVxdWVzdGVkIGZlZWQgZGF0YSB0byBwYXNzXG4gICAqIEBwYXJhbSAge29iamVjdH0gc2V0dGluZ3MgVGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIHByb2Nlc3NlZCBkYXRhXG4gICAqL1xuICBfcHJvY2VzcyhkYXRhLCBzZXR0aW5ncykge1xuICAgIHJldHVybiBGZWVkLnByb2Nlc3Nbc2V0dGluZ3MudHlwZV0oZGF0YSwgc2V0dGluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhc3MgZGF0YSB0byB0aGUgYXBwcm9wcmlhdGUgbWVyZ2UgZnVuY3Rpb24gYmFzZWQgb24gdHlwZVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGRhdGEgICAgIFRoZSByZXF1ZXN0ZWQgZmVlZCBkYXRhIHRvIHBhc3NcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzZXR0aW5ncyBUaGUgYXBwbGljYXRpb24gc2V0dGluZ3NcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBUaGUgbWVyZ2VkIGZlZWQgZGF0YVxuICAgKi9cbiAgX21lcmdlKGRhdGEsIHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIEZlZWQubWVyZ2Vbc2V0dGluZ3MudHlwZV0oZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZSB0ZW1wbGF0ZSBjb21wb25lbnRzLCBwYXNzIGRhdGEsIGFuZCByZXR1cm4gY29tcGlsZWQgdGVtbGF0ZVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGRhdGEgICAgIFRoZSByZXF1ZXN0ZWQgZmVlZCBkYXRhIHRvIHBhc3NcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzZXR0aW5ncyBUaGUgYXBwbGljYXRpb24gc2V0dGluZ3NcbiAgICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICBUaGUgY29tcGxpZWQgaHRtbCBzdHJpbmdcbiAgICovXG4gIF9yZW5kZXIoZGF0YSwgc2V0dGluZ3MpIHtcbiAgICBkYXRhLnNldHRpbmdzID0gc2V0dGluZ3M7XG5cbiAgICBpZiAoc2V0dGluZ3MubG9nKVxuICAgICAgY29uc29sZS5kaXIoZGF0YSk7XG5cbiAgICBsZXQgdGVtcGxhdGUgPSBfdmFsdWVzKHNldHRpbmdzLnRlbXBsYXRlcykuam9pbignJyk7XG4gICAgbGV0IGNvbXBpbGVkID0gX3RlbXBsYXRlKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICB7XG4gICAgICAgICdpbXBvcnRzJzoge1xuICAgICAgICAgICdfZWFjaCc6IF9mb3JFYWNoXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiBjb21waWxlZChkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIG9wZW4gUlNTIHRvIEpTT04gYXBpLCBzZWUgaHR0cHM6Ly9yc3MyanNvbi5jb21cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkZlZWQucnNzVG9Kc29uID0gJ2h0dHBzOi8vYXBpLnJzczJqc29uLmNvbS92MS9hcGkuanNvbic7XG5cbi8qKlxuICogVGhlIHRlbXBsYXRlIGZvciB0aGUgd2lkZ2V0LlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuRmVlZC50ZW1wbGF0ZXMgPSB7XG4gIG1lZGl1bToge1xuICAgIG9wZW5lcjogW1xuICAgICAgJzxzZWN0aW9uIGNsYXNzPVwiby1mZWVkIDwlLSBzZXR0aW5ncy5jbGFzc2VzLndyYXBwZXIgJT5cIiBzdHlsZT1cIicsXG4gICAgICAgICc8JSBpZiAoc2V0dGluZ3MuZm9udFNpemUpIHsgJT5mb250LXNpemU6IDwlLSBzZXR0aW5ncy5mb250U2l6ZSAlPjs8JSB9ICU+JyxcbiAgICAgICAgJzwlIGlmIChzZXR0aW5ncy5wb3N0Qm9yZGVyQ29sb3IpIHsgJT5ib3JkZXItY29sb3I6IDwlLSBzZXR0aW5ncy5wb3N0Qm9yZGVyQ29sb3IgJT47PCUgfSAlPicsXG4gICAgICAnXCI+J1xuICAgIF0sXG4gICAgaGVhZGVyOiBbXG4gICAgICAnPGhlYWRlciBjbGFzcz1cIm8tZmVlZF9faGVhZGVyIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmhlYWRlciAlPlwiPicsXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiby1mZWVkX19hdmF0YXIgPCUtIHNldHRpbmdzLmNsYXNzZXMuYXZhdGFyICU+XCI+JyxcbiAgICAgICAgICAnPGltZyBzcmM9XCInLFxuICAgICAgICAgICAgICAgICc8JSBpZiAoc2V0dGluZ3MucHJvZmlsZUltZyAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAgICAgICAnPCUtIHNldHRpbmdzLnByb2ZpbGVJbWcgJT4nLFxuICAgICAgICAgICAgICAgICc8JSB9IGVsc2UgeyAlPicsXG4gICAgICAgICAgICAgICAgICAnPCUtIGZlZWQucHJvZmlsZUltZyAlPicsXG4gICAgICAgICAgICAgICAgJzwlIH0gJT5cIiAnLFxuICAgICAgICAgICAgICAgJ3dpZHRoPVwiPCUtIHNldHRpbmdzLnJhdGlvUHJvZmlsZVswXSAlPlwiICcsXG4gICAgICAgICAgICAgICAnaGVpZ2h0PVwiPCUtIHNldHRpbmdzLnJhdGlvUHJvZmlsZVsxXSAlPlwiPicsXG4gICAgICAgICc8L2Rpdj4nLFxuICAgICAgICAnPGEgY2xhc3M9XCJvLWZlZWRfX3VybCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5hdmF0YXIgJT5cIiAnLFxuICAgICAgICAgICdocmVmPVwiPCUgaWYgKHNldHRpbmdzLnRpdGxlVXJsICE9PSBcIlwiKSB7ICU+JyxcbiAgICAgICAgICAgICc8JS0gc2V0dGluZ3MudGl0bGVVcmwgJT4nLFxuICAgICAgICAgICc8JSB9IGVsc2UgeyAlPicsXG4gICAgICAgICAgICAnPCUtIGZlZWQudXJsICU+JyxcbiAgICAgICAgICAnPCUgfSAlPlwiICcsXG4gICAgICAgICAgICd0YXJnZXQ9XCJfYmxhbmtcIiByZWw9XCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI+JyxcbiAgICAgICAgICAnPCUgaWYgKHNldHRpbmdzLnRpdGxlICE9PSBcIlwiKSB7ICU+JyxcbiAgICAgICAgICAgICc8JS0gc2V0dGluZ3MudGl0bGUgJT4nLFxuICAgICAgICAgICc8JSB9IGVsc2UgeyAlPicsXG4gICAgICAgICAgICAnPCUtIGZlZWQudGl0bGUgJT4nLFxuICAgICAgICAgICc8JSB9ICU+JyxcbiAgICAgICAgJzwvYT4nLFxuICAgICAgJzwvaGVhZGVyPidcbiAgICBdLFxuICAgIHBvc3RzOiBbXG4gICAgICAnPGRpdiBjbGFzcz1cIm8tZmVlZF9faXRlbXNcIiBzdHlsZT1cIicsXG4gICAgICAgICdib3JkZXItY29sb3I6IDwlLSBzZXR0aW5ncy5wb3N0Qm9yZGVyQ29sb3IgJT47JyxcbiAgICAgICdcIj4nLFxuICAgICAgICAnPCUgX2VhY2goaXRlbXMsIGZ1bmN0aW9uKHBvc3QpIHsgJT4nLFxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYy1mZWVkLWl0ZW0gPCUtIHNldHRpbmdzLmNsYXNzZXMuZmVlZEl0ZW0gJT5cIj4nLFxuICAgICAgICAgICAgJzxoNCBjbGFzcz1cImMtZmVlZC1pdGVtX190aXRsZSA8JS0gc2V0dGluZ3MuY2xhc3Nlcy50aXRsZSAlPlwiPicsXG4gICAgICAgICAgICAgICc8YSBjbGFzcz1cImMtZmVlZC1pdGVtX19saW5rIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmxpbmsgJT5cIicsXG4gICAgICAgICAgICAgICAgICdocmVmPVwiPCUtIHBvc3QuZ3VpZCAlPlwiJyxcbiAgICAgICAgICAgICAgICAgJ3RhcmdldD1cIl9ibGFua1wiJyxcbiAgICAgICAgICAgICAgICAgJ3JlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXIgbm9mb2xsb3dcIj4nLFxuICAgICAgICAgICAgICAgICc8JS0gcG9zdC50aXRsZSAlPicsXG4gICAgICAgICAgICAgICc8L2E+JyxcbiAgICAgICAgICAgICc8L2g0PicsXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJjLWZlZWQtaXRlbV9fZGF0ZSA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5kYXRlICU+XCIgJyxcbiAgICAgICAgICAgICAgICAgICd0aXRsZT1cIjwlLSBzZXR0aW5ncy5wb3N0RGF0ZVRpdGxlICU+XCI+JyxcbiAgICAgICAgICAgICAgJzwlLSBwb3N0LmRhdGUgJT4nLFxuICAgICAgICAgICAgJzwvc3Bhbj4nLFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJjLWZlZWQtaXRlbV9fdGh1bWJuYWlsIDwlLSBzZXR0aW5ncy5jbGFzc2VzLnRodW1ibmFpbCAlPlwiJyxcbiAgICAgICAgICAgICAgICAgJ3N0eWxlPVwiJyxcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2U6IHVybCg8JS0gcG9zdC50aHVtYm5haWwgJT4pOycsXG4gICAgICAgICAgICAgICAgICAgICdoZWlnaHQ6IDwlLSBzZXR0aW5ncy5wb3N0SW1nSGVpZ2h0ICU+O1wiJyxcbiAgICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuPVwidHJ1ZVwiPicsXG4gICAgICAgICAgICAgICc8aW1nIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIiBzcmM9XCI8JS0gcG9zdC50aHVtYm5haWwgJT5cIiBhbHQ9XCI8JS0gcG9zdC50aXRsZSAlPlwiPicsXG4gICAgICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgICAgICc8cCBjbGFzcz1cImMtZmVlZC1pdGVtX19leGNlcnB0IDwlLSBzZXR0aW5ncy5jbGFzc2VzLmV4Y2VycHQgJT5cIj4nLFxuICAgICAgICAgICAgICAnPCUtIHBvc3QuZXhjZXJwdCAlPjwlLSBzZXR0aW5ncy5wb3N0RXhjZXJwdFRyYWlsICU+JyxcbiAgICAgICAgICAgICc8L3A+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYy1mZWVkLWl0ZW1fX2Zvb3RlciA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5pdGVtRm9vdGVyICU+XCI+JyxcbiAgICAgICAgICAgICAgJzxhIGNsYXNzPVwiYy1mZWVkLWl0ZW1fX2N0YSA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5jdGEgJT5cIiAnLFxuICAgICAgICAgICAgICAgICAnaHJlZj1cIjwlLSBwb3N0Lmd1aWQgJT5cIiAnLFxuICAgICAgICAgICAgICAgICAndGFyZ2V0PVwiX2JsYW5rXCIgJyxcbiAgICAgICAgICAgICAgICAgJ3JlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXIgbm9mb2xsb3dcIj4nLFxuICAgICAgICAgICAgICAgICc8JS0gc2V0dGluZ3MucG9zdEN0YVRleHQgJT4nLFxuICAgICAgICAgICAgICAnPC9hPicsXG4gICAgICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgJzwlIH0pOyAlPicsXG4gICAgICAnPC9kaXY+J1xuICAgIF0sXG4gICAgY2xvc2VyOiBbXG4gICAgICAnPC9zZWN0aW9uPidcbiAgICBdXG4gIH1cbn07XG5cbi8qKlxuICogRnVuY3Rpb25zIGZvciBwcm9jZXNzaW5nIHRoZSBkYXRhIGJhc2VkIG9uIHRoZSBmZWVkIHR5cGUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5GZWVkLnByb2Nlc3MgPSB7XG4gIG1lZGl1bTogZnVuY3Rpb24oZGF0YSwgc2V0dGluZ3MpIHtcbiAgICBsZXQgbGVuZ3RoID0gc2V0dGluZ3MucG9zdEV4Y2VycHRMZW5ndGg7XG5cbiAgICBfZm9yRWFjaChkYXRhLml0ZW1zLCBmdW5jdGlvbihwb3N0LCBpbmRleCkge1xuICAgICAgbGV0IGV4Y2VycHQgPSAnJztcbiAgICAgIGxldCBkYXRlID0gJyc7XG5cbiAgICAgIC8vIFJlbW92ZSBmaWd1cmVzIGZpcnN0XG4gICAgICBleGNlcnB0ID0gcG9zdC5kZXNjcmlwdGlvblxuICAgICAgICAucmVwbGFjZSgvPGZpZ3VyZS4qPi4qPzxcXC9maWd1cmU+L2csICcnKTtcblxuICAgICAgLy8gUmVtb3ZlIGFsbCB0YWdzXG4gICAgICBleGNlcnB0ID0gZXhjZXJwdC5yZXBsYWNlKC88KC58XFxuKSo/Pi9nLCAnJyk7XG5cbiAgICAgIC8vIFRyaW0gdGhlIGV4Y2VycHRcbiAgICAgIGV4Y2VycHQgPSBleGNlcnB0LnN1YnN0cigwLCBsZW5ndGgpO1xuICAgICAgZXhjZXJwdCA9IGV4Y2VycHQuc3Vic3RyKDAsXG4gICAgICAgIE1hdGgubWluKGV4Y2VycHQubGVuZ3RoLCBleGNlcnB0Lmxhc3RJbmRleE9mKCcgJykpXG4gICAgICApO1xuXG4gICAgICBwb3N0LmV4Y2VycHQgPSBleGNlcnB0O1xuXG4gICAgICAvLyBGb3JtYXQgdGhlIGRhdGVcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKHBvc3QucHViRGF0ZS5yZXBsYWNlKCcgJywgJ1QnKSkpXG4gICAgICAgIC50b0xvY2FsZURhdGVTdHJpbmcoc2V0dGluZ3MucG9zdERhdGVMb2NhbCwgc2V0dGluZ3MucG9zdERhdGVGb3JtYXQpO1xuXG4gICAgICBwb3N0LmRhdGUgPSBkYXRlO1xuXG4gICAgICByZXR1cm4gcG9zdDtcbiAgICB9KTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb25zIGZvciBtZXJnaW5nIHRoZSBkYXRhIGZlZWRzIHRvZ2V0aGVyLCBiYXNlZCBvbiB0aGUgZmVlZCB0eXBlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuRmVlZC5tZXJnZSA9IHtcbiAgbWVkaXVtOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgbGV0IG1lcmdlZCA9IHt9O1xuICAgIGxldCBpdGVtcyA9IFtdO1xuXG4gICAgLy8gQ29tYmluZSB0aGUgcG9zdCBpdGVtc1xuICAgIGRhdGEuZm9yRWFjaCgoZmVlZCkgPT4ge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoZmVlZC5pdGVtcyk7XG4gICAgfSk7XG5cbiAgICAvLyBNZXJnZSB0aGUgZGF0YSwgdGhpcyB3aWxsIG92ZXJyaWRlIHZhbHVlcywgaXQgcHJvYmFibHkgd29uJ3QgYmVcbiAgICAvLyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBmZWVkcyB0aGF0IGFyZSB0aGUgc2FtZSwgYnV0IHBvdGVudGlhbGx5XG4gICAgLy8gZGlmZmVyZW50IGZlZWQgdHlwZXMgY291bGQgdXNlIHRoaXMgYW5kIGNvbWJpbmUgdW5pcXVlIGRhdGFcbiAgICBkYXRhLmZvckVhY2goKGZlZWQpID0+IHtcbiAgICAgIG1lcmdlZCA9IF9tZXJnZShtZXJnZWQsIGZlZWQpO1xuICAgIH0pO1xuXG4gICAgLy8gR2V0IHVuaXF1ZSBwb3N0c1xuICAgIC8vIGl0ZW1zID0gX3VuaXFCeShpdGVtcywgKGl0ZW0pID0+IGl0ZW0uZ3VpZCk7XG5cbiAgICBtZXJnZWQuaXRlbXMgPSBfb3JkZXJCeShpdGVtcywgJ3B1YkRhdGUnLCAnZGVzYycpO1xuXG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfVxufVxuXG4vKipcbiAqIFNlZSBodHRwczovL3JzczJqc29uLmNvbS9kb2NzIGZvciBkZXRhaWxzIG9uIGRlZmF1bHQgcGFyYW1ldGVyc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuRmVlZC5kZWZhdWx0ID0ge1xuICBmZWVkOiAnJyxcbiAgc2VsZWN0b3I6ICcjanMtZmVlZCcsXG4gIHR5cGU6ICdtZWRpdW0nLFxuICB0aXRsZTogJycsXG4gIHRpdGxlVXJsOiAnJyxcbiAgcHJvZmlsZUltZzogJycsXG4gIGZvbnRTaXplOiAnJyxcbiAgcmF0aW9Qcm9maWxlOiBbJzUwJywgJzUwJ10sXG4gIHBvc3RCb3JkZXJDb2xvcjogJ2xpZ2h0c3RlZWxibHVlJyxcbiAgcG9zdEltZ0hlaWdodDogJzIwMHB4JyxcbiAgcG9zdEV4Y2VycHRMZW5ndGg6IDEyMCxcbiAgcG9zdEV4Y2VycHRUcmFpbDogJ+KApicsXG4gIHBvc3RDdGFUZXh0OiAnUmVhZCB0aGUgZnVsbCBwb3N0JyxcbiAgcG9zdERhdGVMb2NhbDogJ2VuLVVTJyxcbiAgcG9zdERhdGVGb3JtYXQ6IHtcbiAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgbW9udGg6ICdsb25nJyxcbiAgICBkYXk6ICdudW1lcmljJ1xuICB9LFxuICBwb3N0RGF0ZVRpdGxlOiAnUHVibGlzaGVkIERhdGUnLFxuICBjbGFzc2VzOiB7XG4gICAgd3JhcHBlcjogJycsXG4gICAgaGVhZGVyOiAnJyxcbiAgICB1cmw6ICcnLFxuICAgIGZlZWRJdGVtOiAnJyxcbiAgICB0aXRsZTogJycsXG4gICAgbGluazogJycsXG4gICAgdGh1bWJuYWlsOiAnJyxcbiAgICBleGNlcnB0OiAnJyxcbiAgICBpdGVtRm9vdGVyOiAnJyxcbiAgICBjdGE6ICcnLFxuICAgIGRhdGU6ICcnXG4gIH0sXG4gIHRlbXBsYXRlczoge1xuICAgIG9wZW5lcjogRmVlZC50ZW1wbGF0ZXMubWVkaXVtLm9wZW5lci5qb2luKCcnKSxcbiAgICBoZWFkZXI6IEZlZWQudGVtcGxhdGVzLm1lZGl1bS5oZWFkZXIuam9pbignJyksXG4gICAgcG9zdHM6IEZlZWQudGVtcGxhdGVzLm1lZGl1bS5wb3N0cy5qb2luKCcnKSxcbiAgICBjbG9zZXI6IEZlZWQudGVtcGxhdGVzLm1lZGl1bS5jbG9zZXIuam9pbignJylcbiAgfSxcbiAgbG9nOiBmYWxzZSxcbiAgdW5pcXVlOiBmYWxzZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgRmVlZDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgU2ltcGxlIFRvZ2dsZSBjbGFzcy4gVGhpcyB3aWxsIHRvZ2dsZSB0aGUgY2xhc3MgJ2FjdGl2ZScgYW5kICdoaWRkZW4nXG4gKiBvbiB0YXJnZXQgZWxlbWVudHMsIGRldGVybWluZWQgYnkgYSBjbGljayBldmVudCBvbiBhIHNlbGVjdGVkIGxpbmsgb3JcbiAqIGVsZW1lbnQuIFRoaXMgd2lsbCBhbHNvIHRvZ2dsZSB0aGUgYXJpYS1oaWRkZW4gYXR0cmlidXRlIGZvciB0YXJnZXRlZFxuICogZWxlbWVudHMgdG8gc3VwcG9ydCBzY3JlZW4gcmVhZGVycy4gVGFyZ2V0IHNldHRpbmdzIGFuZCBvdGhlciBmdW5jdGlvbmFsaXR5XG4gKiBjYW4gYmUgY29udHJvbGxlZCB0aHJvdWdoIGRhdGEgYXR0cmlidXRlcy5cbiAqXG4gKiBUaGlzIHVzZXMgdGhlIC5tYXRjaGVzKCkgbWV0aG9kIHdoaWNoIHdpbGwgcmVxdWlyZSBhIHBvbHlmaWxsIGZvciBJRVxuICogaHR0cHM6Ly9wb2x5ZmlsbC5pby92Mi9kb2NzL2ZlYXR1cmVzLyNFbGVtZW50X3Byb3RvdHlwZV9tYXRjaGVzXG4gKlxuICogQmFzaWMgVXNhZ2U7XG4gKlxuICogamF2YXNjcmlwdDpcbiAqICAgbmV3IFRvZ2dsZSgpLmluaXQoKTtcbiAqXG4gKiBUb2dnbGluZyBBbmNob3IgbGlua3M6XG4gKiAgIDxhIGRhdGEtanM9J3RvZ2dsZScgaHJlZj0nI21haW4tbWVudSc+TWVudTwvYT5cbiAqICAgPGRpdiBpZD0nbWFpbi1tZW51JyBhcmlhLWhpZGRlbj0ndHJ1ZSc+IC4uLiA8L2Rpdj5cbiAqXG4gKiBUb2dnbGluZyBhcmlhLWNvbnRyb2wgZWxlbWVudHM6XG4gKlxuICogICA8YnV0dG9uIGRhdGEtanM9J3RvZ2dsZScgYXJpYS1jb250cm9scz0nI21haW4tbWVudScgYXJpYS1wcmVzc2VkPSdmYWxzZSc+XG4gKiAgICAgIE1lbnVcbiAqICAgPC9idXR0b24+XG4gKiAgIDxkaXYgaWQ9J21haW4tbWVudScgYXJpYS1oaWRkZW49J3RydWUnPiAuLi4gPC9kaXY+XG4gKlxuICogQ3JlYXRlIFwiVW5kb1wiIEV2ZW50ICh0byBjbG9zZSBhIGRpYWxvZ3VlKTtcbiAqICAgPGEgaHJlZj0nI21haW4tbWVudScgZGF0YS1qcz0ndG9nZ2xlJyBkYXRhLXRvZ2dsZS11bmRvPScjY2xvc2UnPk1lbnU8L2E+XG4gKiAgIDxkaXYgaWQ9J21haW4tbWVudScgYXJpYS1oaWRkZW49J3RydWUnPlxuICogICAgIDxhIGlkPVwiY2xvc2VcIj5DbG9zZTwvYT5cbiAqICAgPC9kaXY+XG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgVG9nZ2xlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHMgU2V0dGluZ3MgZm9yIHRoaXMgVG9nZ2xlIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgY2xhc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHMpIHtcbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgcyA9ICghcykgPyB7fSA6IHM7XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IHtcbiAgICAgIHNlbGVjdG9yOiAocy5zZWxlY3RvcikgPyBzLnNlbGVjdG9yIDogVG9nZ2xlLnNlbGVjdG9yLFxuICAgICAgbmFtZXNwYWNlOiAocy5uYW1lc3BhY2UpID8gcy5uYW1lc3BhY2UgOiBUb2dnbGUubmFtZXNwYWNlLFxuICAgICAgaW5hY3RpdmVDbGFzczogKHMuaW5hY3RpdmVDbGFzcykgPyBzLmluYWN0aXZlQ2xhc3MgOiBUb2dnbGUuaW5hY3RpdmVDbGFzcyxcbiAgICAgIGFjdGl2ZUNsYXNzOiAocy5hY3RpdmVDbGFzcykgPyBzLmFjdGl2ZUNsYXNzIDogVG9nZ2xlLmFjdGl2ZUNsYXNzLFxuICAgIH07XG5cbiAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMuX3NldHRpbmdzLnNlbGVjdG9yKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl90b2dnbGUoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gZXZlbnQgIFRoZSBtYWluIGNsaWNrIGV2ZW50XG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIFRoZSBjbGFzc1xuICAgKi9cbiAgX3RvZ2dsZShldmVudCkge1xuICAgIGxldCBlbCA9IGV2ZW50LnRhcmdldDtcbiAgICBsZXQgdGFyZ2V0ID0gZmFsc2U7XG5cbiAgICAvKiogQW5jaG9yIExpbmtzICovXG4gICAgdGFyZ2V0ID0gKGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSA/XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSA6IHRhcmdldDtcblxuICAgIC8qKiBUb2dnbGUgQ29udHJvbHMgKi9cbiAgICAvLyBjb25zb2xlLmRpcihlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSk7XG4gICAgdGFyZ2V0ID0gKGVsLmdldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpKSA/XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHtlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKX1gKSA6IHRhcmdldDtcblxuICAgIC8qKiBNYWluIEZ1bmN0aW9uYWxpdHkgKi9cbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuIHRoaXM7XG4gICAgdGhpcy5lbGVtZW50VG9nZ2xlKGVsLCB0YXJnZXQpO1xuXG4gICAgLyoqIFVuZG8gKi9cbiAgICBpZiAoZWwuZGF0YXNldFtgJHt0aGlzLl9zZXR0aW5ncy5uYW1lc3BhY2V9VW5kb2BdKSB7XG4gICAgICBjb25zdCB1bmRvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgZWwuZGF0YXNldFtgJHt0aGlzLl9zZXR0aW5ncy5uYW1lc3BhY2V9VW5kb2BdXG4gICAgICApO1xuXG4gICAgICB1bmRvLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudFRvZ2dsZShlbCwgdGFyZ2V0KTtcbiAgICAgICAgdW5kby5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1haW4gdG9nZ2xpbmcgbWV0aG9kXG4gICAqIEBwYXJhbSAge29iamVjdH0gZWwgICAgIFRoZSBjdXJyZW50IGVsZW1lbnQgdG8gdG9nZ2xlIGFjdGl2ZVxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IGVsZW1lbnQgdG8gdG9nZ2xlIGFjdGl2ZS9oaWRkZW5cbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgVGhlIGNsYXNzXG4gICAqL1xuICBlbGVtZW50VG9nZ2xlKGVsLCB0YXJnZXQpIHtcbiAgICBpZiAodGhpcy5fc2V0dGluZ3MuYWN0aXZlQ2xhc3MgIT09ICcnKSB7XG4gICAgICBlbC5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUNsYXNzKTtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUNsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2V0dGluZ3MuaW5hY3RpdmVDbGFzcyAhPT0gJycpIHtcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuX3NldHRpbmdzLmluYWN0aXZlQ2xhc3MpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBlbGVtZW50IGZvciBkZWZpbmVkIGFyaWEgcm9sZXMgYW5kIHRvZ2dsZSB0aGVtIGlmIHRoZXkgZXhpc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRvZ2dsZS5lbEFyaWFSb2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZShUb2dnbGUuZWxBcmlhUm9sZXNbaV0pKVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoVG9nZ2xlLmVsQXJpYVJvbGVzW2ldLFxuICAgICAgICAgICEoZWwuZ2V0QXR0cmlidXRlKFRvZ2dsZS5lbEFyaWFSb2xlc1tpXSkgPT09ICd0cnVlJykpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSB0YXJnZXQgZm9yIGRlZmluZWQgYXJpYSByb2xlcyBhbmQgdG9nZ2xlIHRoZW0gaWYgdGhleSBleGlzdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVG9nZ2xlLnRhcmdldEFyaWFSb2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRhcmdldC5nZXRBdHRyaWJ1dGUoVG9nZ2xlLnRhcmdldEFyaWFSb2xlc1tpXSkpXG4gICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoVG9nZ2xlLnRhcmdldEFyaWFSb2xlc1tpXSxcbiAgICAgICAgICAhKHRhcmdldC5nZXRBdHRyaWJ1dGUoVG9nZ2xlLnRhcmdldEFyaWFSb2xlc1tpXSkgPT09ICd0cnVlJykpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpICYmXG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUNsYXNzKSlcbiAgICB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnO1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIG1haW4gc2VsZWN0b3IgdG8gYWRkIHRoZSB0b2dnbGluZyBmdW5jdGlvbiB0byAqL1xuVG9nZ2xlLnNlbGVjdG9yID0gJ1tkYXRhLWpzKj1cInRvZ2dsZVwiXSc7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgbmFtZXNwYWNlIGZvciBvdXIgZGF0YSBhdHRyaWJ1dGUgc2V0dGluZ3MgKi9cblRvZ2dsZS5uYW1lc3BhY2UgPSAndG9nZ2xlJztcblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBoaWRlIGNsYXNzICovXG5Ub2dnbGUuaW5hY3RpdmVDbGFzcyA9ICdoaWRkZW4nO1xuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIGFjdGl2ZSBjbGFzcyAqL1xuVG9nZ2xlLmFjdGl2ZUNsYXNzID0gJ2FjdGl2ZSc7XG5cbi8qKiBAdHlwZSB7QXJyYXl9IEFyaWEgcm9sZXMgdG8gdG9nZ2xlIHRydWUvZmFsc2Ugb24gdGhlIHRvZ2dsaW5nIGVsZW1lbnQgKi9cblRvZ2dsZS5lbEFyaWFSb2xlcyA9IFsnYXJpYS1wcmVzc2VkJywgJ2FyaWEtZXhwYW5kZWQnXTtcblxuLyoqIEB0eXBlIHtBcnJheX0gQXJpYSByb2xlcyB0byB0b2dnbGUgdHJ1ZS9mYWxzZSBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQgKi9cblRvZ2dsZS50YXJnZXRBcmlhUm9sZXMgPSBbJ2FyaWEtaGlkZGVuJ107XG5cbmV4cG9ydCBkZWZhdWx0IFRvZ2dsZTsiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBVdGlsaXR5IGZyb20gJy4uLy4uL2pzL21vZHVsZXMvdXRpbGl0eSc7XG5cbi8qKlxuICogVHJhY2tpbmcgYnVzIGZvciBHb29nbGUgYW5hbHl0aWNzIGFuZCBXZWJ0cmVuZHMuXG4gKi9cbmNsYXNzIFRyYWNrIHtcbiAgY29uc3RydWN0b3Iocykge1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG5cbiAgICBzID0gKCFzKSA/IHt9IDogcztcblxuICAgIHRoaXMuX3NldHRpbmdzID0ge1xuICAgICAgc2VsZWN0b3I6IChzLnNlbGVjdG9yKSA/IHMuc2VsZWN0b3IgOiBUcmFjay5zZWxlY3RvcixcbiAgICB9O1xuXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLl9zZXR0aW5ncy5zZWxlY3RvcikpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgbGV0IGtleSA9IGV2ZW50LnRhcmdldC5kYXRhc2V0LnRyYWNrS2V5O1xuICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LnRhcmdldC5kYXRhc2V0LnRyYWNrRGF0YSk7XG5cbiAgICAgIHRoaXMuY2xpY2soa2V5LCBkYXRhKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNraW5nIGZ1bmN0aW9uIHdyYXBwZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICBUaGUgZmluYWwgZGF0YSBvYmplY3RcbiAgICovXG4gIGNsaWNrKGtleSwgZGF0YSkge1xuICAgIC8vIFNldCB0aGUgcGF0aCBuYW1lIGJhc2VkIG9uIHRoZSBsb2NhdGlvblxuICAgIGNvbnN0IGQgPSBkYXRhLm1hcChlbCA9PiB7XG4gICAgICAgIGlmIChlbC5oYXNPd25Qcm9wZXJ0eShUcmFjay5rZXkpKVxuICAgICAgICAgIGVsW1RyYWNrLmtleV0gPSBgJHt3aW5kb3cubG9jYXRpb24ucGF0aG5hbWV9LyR7ZWxbVHJhY2sua2V5XX1gXG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH0pO1xuXG4gICAgbGV0IHd0ID0gdGhpcy53ZWJ0cmVuZHMoa2V5LCBkKTtcbiAgICBsZXQgZ2EgPSB0aGlzLmd0YWcoa2V5LCBkKTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKVxuICAgICAgY29uc29sZS5kaXIoeydUcmFjayc6IFt3dCwgZ2FdfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cbiAgICByZXR1cm4gZDtcbiAgfTtcblxuICAvKipcbiAgICogRGF0YSBidXMgZm9yIHRyYWNraW5nIHZpZXdzIGluIFdlYnRyZW5kcyBhbmQgR29vZ2xlIEFuYWx5dGljc1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBhcHAgIFRoZSBuYW1lIG9mIHRoZSBTaW5nbGUgUGFnZSBBcHBsaWNhdGlvbiB0byB0cmFja1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBrZXkgIFRoZSBrZXkgb3IgZXZlbnQgb2YgdGhlIGRhdGFcbiAgICogQHBhcmFtICB7Y29sbGVjdGlvbn0gZGF0YSBUaGUgZGF0YSB0byB0cmFja1xuICAgKi9cbiAgdmlldyhhcHAsIGtleSwgZGF0YSkge1xuICAgIGxldCB3dCA9IHRoaXMud2VidHJlbmRzKGtleSwgZGF0YSk7XG4gICAgbGV0IGdhID0gdGhpcy5ndGFnVmlldyhhcHAsIGtleSk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgaWYgKFV0aWxpdHkuZGVidWcoKSlcbiAgICAgIGNvbnNvbGUuZGlyKHsnVHJhY2snOiBbd3QsIGdhXX0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXNoIEV2ZW50cyB0byBXZWJ0cmVuZHNcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICovXG4gIHdlYnRyZW5kcyhrZXksIGRhdGEpIHtcbiAgICBsZXQgZXZlbnQgPSBbe1xuICAgICAgJ1dULnRpJzoga2V5XG4gICAgfV07XG5cbiAgICBpZiAoZGF0YVswXSAmJiBkYXRhWzBdLmhhc093blByb3BlcnR5KFRyYWNrLmtleSkpIHtcbiAgICAgIGV2ZW50LnB1c2goe1xuICAgICAgICAnRENTLmRjc3VyaSc6IGRhdGFbMF1bVHJhY2sua2V5XVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZXZlbnQsIGRhdGEpO1xuICAgIH1cblxuICAgIC8vIEZvcm1hdCBkYXRhIGZvciBXZWJ0cmVuZHNcbiAgICBsZXQgd3RkID0ge2FyZ3NhOiBldmVudC5mbGF0TWFwKGUgPT4ge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGUpLmZsYXRNYXAoayA9PiBbaywgZVtrXV0pO1xuICAgIH0pfTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgaWYgKHR5cGVvZiBXZWJ0cmVuZHMgIT09ICd1bmRlZmluZWQnKVxuICAgICAgV2VidHJlbmRzLm11bHRpVHJhY2sod3RkKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuXG4gICAgcmV0dXJuIFsnV2VidHJlbmRzJywgd3RkXTtcbiAgfTtcblxuICAvKipcbiAgICogUHVzaCBDbGljayBFdmVudHMgdG8gR29vZ2xlIEFuYWx5dGljc1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICBrZXkgIFRoZSBrZXkgb3IgZXZlbnQgb2YgdGhlIGRhdGFcbiAgICogQHBhcmFtICB7Y29sbGVjdGlvbn0gZGF0YSBUaGUgZGF0YSB0byB0cmFja1xuICAgKi9cbiAgZ3RhZyhrZXksIGRhdGEpIHtcbiAgICBsZXQgdXJpID0gZGF0YS5maW5kKChlbGVtZW50KSA9PiBlbGVtZW50Lmhhc093blByb3BlcnR5KFRyYWNrLmtleSkpO1xuXG4gICAgbGV0IGV2ZW50ID0ge1xuICAgICAgJ2V2ZW50X2NhdGVnb3J5Jzoga2V5XG4gICAgfTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgaWYgKHR5cGVvZiBndGFnICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGd0YWcoVHJhY2sua2V5LCB1cmlbVHJhY2sua2V5XSwgZXZlbnQpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYgKi9cblxuICAgIHJldHVybiBbJ2d0YWcnLCBUcmFjay5rZXksIHVyaVtUcmFjay5rZXldLCBldmVudF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggU2NyZWVuIFZpZXcgRXZlbnRzIHRvIEdvb2dsZSBBbmFseXRpY3NcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgYXBwICBUaGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb25cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqL1xuICBndGFnVmlldyhhcHAsIGtleSkge1xuICAgIGxldCB2aWV3ID0ge1xuICAgICAgYXBwX25hbWU6IGFwcCxcbiAgICAgIHNjcmVlbl9uYW1lOiBrZXlcbiAgICB9O1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cbiAgICBpZiAodHlwZW9mIGd0YWcgIT09ICd1bmRlZmluZWQnKVxuICAgICAgZ3RhZygnZXZlbnQnLCAnc2NyZWVuX3ZpZXcnLCB2aWV3KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG5cbiAgICByZXR1cm4gWydndGFnJywgVHJhY2sua2V5LCAnc2NyZWVuX3ZpZXcnLCB2aWV3XTtcbiAgfTtcbn1cblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBtYWluIHNlbGVjdG9yIHRvIGFkZCB0aGUgdHJhY2tpbmcgZnVuY3Rpb24gdG8gKi9cblRyYWNrLnNlbGVjdG9yID0gJ1tkYXRhLWpzKj1cInRyYWNrXCJdJztcblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBtYWluIGV2ZW50IHRyYWNraW5nIGtleSB0byBtYXAgdG8gV2VidHJlbmRzIERDUy51cmkgKi9cblRyYWNrLmtleSA9ICdldmVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IFRyYWNrOyIsIi8qIVxuICogVnVlLmpzIHYyLjYuNlxuICogKGMpIDIwMTQtMjAxOSBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4vKiAgKi9cblxuY29uc3QgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gKi9cbmNvbnN0IF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICBjb25zdCBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiAoXG4gICAgaXNEZWYodmFsKSAmJlxuICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gdmFsID0+IG1hcFt2YWwudG9Mb3dlckNhc2UoKV1cbiAgICA6IHZhbCA9PiBtYXBbdmFsXVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG5jb25zdCBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xuY29uc3QgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIGNvbnN0IGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbmNvbnN0IGNhbWVsaXplID0gY2FjaGVkKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJycpXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG5jb25zdCBjYXBpdGFsaXplID0gY2FjaGVkKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xuY29uc3QgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVkKChzdHIpID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxuICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cbiAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxuY29uc3QgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gID8gbmF0aXZlQmluZFxuICA6IHBvbHlmaWxsQmluZDtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBsZXQgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgY29uc3QgcmVzID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xuY29uc3Qgbm8gPSAoYSwgYiwgYykgPT4gZmFsc2U7XG5cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gKi9cbmNvbnN0IGlkZW50aXR5ID0gKF8pID0+IF87XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKChrZXlzLCBtKSA9PiB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZVxuICBjb25zdCBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgY29uc3QgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIGNvbnN0IGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoKGUsIGkpID0+IHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpXG4gICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGtleSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgcmV0dXJuIGlcbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbmNvbnN0IEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG5jb25zdCBMSUZFQ1lDTEVfSE9PS1MgPSBbXG4gICdiZWZvcmVDcmVhdGUnLFxuICAnY3JlYXRlZCcsXG4gICdiZWZvcmVNb3VudCcsXG4gICdtb3VudGVkJyxcbiAgJ2JlZm9yZVVwZGF0ZScsXG4gICd1cGRhdGVkJyxcbiAgJ2JlZm9yZURlc3Ryb3knLFxuICAnZGVzdHJveWVkJyxcbiAgJ2FjdGl2YXRlZCcsXG4gICdkZWFjdGl2YXRlZCcsXG4gICdlcnJvckNhcHR1cmVkJyxcbiAgJ3NlcnZlclByZWZldGNoJ1xuXTtcblxuLyogICovXG5cblxuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdXBkYXRlcyBhc3luY2hyb25vdXNseS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBieSBWdWUgVGVzdCBVdGlsc1xuICAgKiBUaGlzIHdpbGwgc2lnbmlmaWNhbnRseSByZWR1Y2UgcGVyZm9ybWFuY2UgaWYgc2V0IHRvIGZhbHNlLlxuICAgKi9cbiAgYXN5bmM6IHRydWUsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG4vKipcbiAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXG4gKiBza2lwcGluZyBcXHUxMDAwMC1cXHVFRkZGRiBkdWUgdG8gaXQgZnJlZXppbmcgdXAgUGhhbnRvbUpTXG4gKi9cbmNvbnN0IHVuaWNvZGVMZXR0ZXJzID0gJ2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQnO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgY29uc3QgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG5jb25zdCBiYWlsUkUgPSBuZXcgUmVnRXhwKGBbXiR7dW5pY29kZUxldHRlcnN9LiRfXFxcXGRdYCk7XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHJldHVyblxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbmNvbnN0IGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbmNvbnN0IGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbmNvbnN0IHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG5jb25zdCBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuY29uc3QgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xuY29uc3QgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbmNvbnN0IGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xuY29uc3QgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG5jb25zdCBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG5jb25zdCBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuY29uc3QgaXNQaGFudG9tSlMgPSBVQSAmJiAvcGhhbnRvbWpzLy50ZXN0KFVBKTtcbmNvbnN0IGlzRkYgPSBVQSAmJiBVQS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG5jb25zdCBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbmxldCBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG5sZXQgX2lzU2VydmVyO1xuY29uc3QgaXNTZXJ2ZXJSZW5kZXJpbmcgPSAoKSA9PiB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10gJiYgZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG5jb25zdCBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG5jb25zdCBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG4gIHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG5sZXQgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gY2xhc3MgU2V0ICAge1xuICAgIFxuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfVxuICAgIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmxldCB3YXJuID0gbm9vcDtcbmxldCB0aXAgPSBub29wO1xubGV0IGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbmxldCBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG57XG4gIGNvbnN0IGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIGNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIGNvbnN0IGNsYXNzaWZ5ID0gc3RyID0+IHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGMgPT4gYy50b1VwcGVyQ2FzZSgpKVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTtcblxuICB3YXJuID0gKG1zZywgdm0pID0+IHtcbiAgICBjb25zdCB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihgW1Z1ZSB3YXJuXTogJHttc2d9JHt0cmFjZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gKG1zZywgdm0pID0+IHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtWdWUgdGlwXTogJHttc2d9YCArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9ICh2bSwgaW5jbHVkZUZpbGUpID0+IHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiB2bSA9PT0gJ2Z1bmN0aW9uJyAmJiB2bS5jaWQgIT0gbnVsbFxuICAgICAgPyB2bS5vcHRpb25zXG4gICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICA/IHZtLiRvcHRpb25zIHx8IHZtLmNvbnN0cnVjdG9yLm9wdGlvbnNcbiAgICAgICAgOiB2bTtcbiAgICBsZXQgbmFtZSA9IG9wdGlvbnMubmFtZSB8fCBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gICAgY29uc3QgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IGA8JHtjbGFzc2lmeShuYW1lKX0+YCA6IGA8QW5vbnltb3VzPmApICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IGAgYXQgJHtmaWxlfWAgOiAnJylcbiAgICApXG4gIH07XG5cbiAgY29uc3QgcmVwZWF0ID0gKHN0ciwgbikgPT4ge1xuICAgIGxldCByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSByZXMgKz0gc3RyO1xuICAgICAgaWYgKG4gPiAxKSBzdHIgKz0gc3RyO1xuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSB2bSA9PiB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICBjb25zdCB0cmVlID0gW107XG4gICAgICBsZXQgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoKHZtLCBpKSA9PiBgJHtcbiAgICAgICAgICBpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMilcbiAgICAgICAgfSR7XG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gYCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSl9Li4uICgke3ZtWzFdfSByZWN1cnNpdmUgY2FsbHMpYFxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKVxuICAgICAgICB9YClcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgXFxuXFxuKGZvdW5kIGluICR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bSl9KWBcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5sZXQgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbmNsYXNzIERlcCB7XG4gIFxuICBcbiAgXG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuaWQgPSB1aWQrKztcbiAgICB0aGlzLnN1YnMgPSBbXTtcbiAgfVxuXG4gIGFkZFN1YiAoc3ViKSB7XG4gICAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbiAgfVxuXG4gIHJlbW92ZVN1YiAoc3ViKSB7XG4gICAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbiAgfVxuXG4gIGRlcGVuZCAoKSB7XG4gICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeSAoKSB7XG4gICAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgICBjb25zdCBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gICAgaWYgKCFjb25maWcuYXN5bmMpIHtcbiAgICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcbiAgICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcbiAgICAgIC8vIG9yZGVyXG4gICAgICBzdWJzLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4vLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xuY29uc3QgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAodGFyZ2V0KSB7XG4gIHRhcmdldFN0YWNrLnB1c2godGFyZ2V0KTtcbiAgRGVwLnRhcmdldCA9IHRhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgdGFyZ2V0U3RhY2sucG9wKCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbn1cblxuLyogICovXG5cbmNsYXNzIFZOb2RlIHtcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgIC8vIHJlbmRlcmVkIGluIHRoaXMgY29tcG9uZW50J3Mgc2NvcGVcbiAgXG4gIFxuICAgLy8gY29tcG9uZW50IGluc3RhbmNlXG4gICAvLyBjb21wb25lbnQgcGxhY2Vob2xkZXIgbm9kZVxuXG4gIC8vIHN0cmljdGx5IGludGVybmFsXG4gICAvLyBjb250YWlucyByYXcgSFRNTD8gKHNlcnZlciBvbmx5KVxuICAgLy8gaG9pc3RlZCBzdGF0aWMgbm9kZVxuICAgLy8gbmVjZXNzYXJ5IGZvciBlbnRlciB0cmFuc2l0aW9uIGNoZWNrXG4gICAvLyBlbXB0eSBjb21tZW50IHBsYWNlaG9sZGVyP1xuICAgLy8gaXMgYSBjbG9uZWQgbm9kZT9cbiAgIC8vIGlzIGEgdi1vbmNlIG5vZGU/XG4gICAvLyBhc3luYyBjb21wb25lbnQgZmFjdG9yeSBmdW5jdGlvblxuICBcbiAgXG4gIFxuICAgLy8gcmVhbCBjb250ZXh0IHZtIGZvciBmdW5jdGlvbmFsIG5vZGVzXG4gICAvLyBmb3IgU1NSIGNhY2hpbmdcbiAgIC8vIHVzZWQgdG8gc3RvcmUgZnVuY3Rpb25hbCByZW5kZXIgY29udGV4dCBmb3IgZGV2dG9vbHNcbiAgIC8vIGZ1bmN0aW9uYWwgc2NvcGUgaWQgc3VwcG9ydFxuXG4gIGNvbnN0cnVjdG9yIChcbiAgICB0YWcsXG4gICAgZGF0YSxcbiAgICBjaGlsZHJlbixcbiAgICB0ZXh0LFxuICAgIGVsbSxcbiAgICBjb250ZXh0LFxuICAgIGNvbXBvbmVudE9wdGlvbnMsXG4gICAgYXN5bmNGYWN0b3J5XG4gICkge1xuICAgIHRoaXMudGFnID0gdGFnO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5lbG0gPSBlbG07XG4gICAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICAgIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gICAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gICAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gICAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IGNoaWxkICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxuICB9XG59XG5cbmNvbnN0IGNyZWF0ZUVtcHR5Vk5vZGUgPSAodGV4dCA9ICcnKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIGNvbnN0IGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICAvLyAjNzk3NVxuICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xuICAgIC8vIGEgY2hpbGQuXG4gICAgdm5vZGUuY2hpbGRyZW4gJiYgdm5vZGUuY2hpbGRyZW4uc2xpY2UoKSxcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG5jb25zdCBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuY29uc3QgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxuY29uc3QgbWV0aG9kc1RvUGF0Y2ggPSBbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dO1xuXG4vKipcbiAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICovXG5tZXRob2RzVG9QYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIGNvbnN0IG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBjb25zdCBvYiA9IHRoaXMuX19vYl9fO1xuICAgIGxldCBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG5jb25zdCBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG5sZXQgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG5jbGFzcyBPYnNlcnZlciB7XG4gIFxuICBcbiAgIC8vIG51bWJlciBvZiB2bXMgdGhhdCBoYXZlIHRoaXMgb2JqZWN0IGFzIHJvb3QgJGRhdGFcblxuICBjb25zdHJ1Y3RvciAodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gICAgdGhpcy52bUNvdW50ID0gMDtcbiAgICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmIChoYXNQcm90bykge1xuICAgICAgICBwcm90b0F1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5QXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhbGsodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYWxrIHRocm91Z2ggYWxsIHByb3BlcnRpZXMgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gICAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICAgKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAgICovXG4gIHdhbGsgKG9iaikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gICAqL1xuICBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIGNvbnN0IGRlcCA9IG5ldyBEZXAoKTtcblxuICBjb25zdCBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIGNvbnN0IGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgY29uc3Qgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cblxuICBsZXQgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAoY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgLy8gIzc5ODE6IGZvciBhY2Nlc3NvciBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVyXG4gICAgICBpZiAoZ2V0dGVyICYmICFzZXR0ZXIpIHJldHVyblxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpXG4gICkge1xuICAgIHdhcm4oYENhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6ICR7KHRhcmdldCl9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGNvbnN0IG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpXG4gICkge1xuICAgIHdhcm4oYENhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6ICR7KHRhcmdldCl9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKGxldCBlLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xuY29uc3Qgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbntcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgYG9wdGlvbiBcIiR7a2V5fVwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIGAgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSByZXR1cm4gdG9cbiAgbGV0IGtleSwgdG9WYWwsIGZyb21WYWw7XG5cbiAgY29uc3Qga2V5cyA9IGhhc1N5bWJvbFxuICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXG4gICAgOiBPYmplY3Qua2V5cyhmcm9tKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIC8vIGluIGNhc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IG9ic2VydmVkLi4uXG4gICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIGNvbnRpbnVlXG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdG9WYWwgIT09IGZyb21WYWwgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QodG9WYWwpICYmXG4gICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpXG4gICAgKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIGNvbnN0IGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgY29uc3QgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIGNvbnN0IHJlcyA9IGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbDtcbiAgcmV0dXJuIHJlc1xuICAgID8gZGVkdXBlSG9va3MocmVzKVxuICAgIDogcmVzXG59XG5cbmZ1bmN0aW9uIGRlZHVwZUhvb2tzIChob29rcykge1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XG4gICAgICByZXMucHVzaChob29rc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goaG9vayA9PiB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBjb25zdCByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgaWYgKGNoaWxkVmFsKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7XG4gIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIGNoaWxkVmFsID0gdW5kZWZpbmVkO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpXG4gIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsXG4gIGNvbnN0IHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZFZhbCkge1xuICAgIGxldCBwYXJlbnQgPSByZXRba2V5XTtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBpZiAoY2hpbGRWYWwgJiYgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgcmV0dXJuIGNoaWxkVmFsXG4gIGNvbnN0IHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbmNvbnN0IGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghbmV3IFJlZ0V4cChgXlthLXpBLVpdW1xcXFwtXFxcXC4wLTlfJHt1bmljb2RlTGV0dGVyc31dKiRgKS50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnc2hvdWxkIGNvbmZvcm0gdG8gdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZSBpbiBodG1sNSBzcGVjaWZpY2F0aW9uLidcbiAgICApO1xuICB9XG4gIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICB3YXJuKFxuICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAnaWQ6ICcgKyBuYW1lXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gIGNvbnN0IHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgcmV0dXJuXG4gIGNvbnN0IHJlcyA9IHt9O1xuICBsZXQgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2FybihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXCJwcm9wc1wiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIGAgK1xuICAgICAgYGJ1dCBnb3QgJHt0b1Jhd1R5cGUocHJvcHMpfS5gLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIGNvbnN0IGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICBpZiAoIWluamVjdCkgcmV0dXJuXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluamVjdCkge1xuICAgICAgY29uc3QgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdhcm4oXG4gICAgICBgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwiaW5qZWN0XCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgYCArXG4gICAgICBgYnV0IGdvdCAke3RvUmF3VHlwZShpbmplY3QpfS5gLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICBjb25zdCBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRpcnMpIHtcbiAgICAgIGNvbnN0IGRlZiQkMSA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmJCQxLCB1cGRhdGU6IGRlZiQkMSB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm4oXG4gICAgICBgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwiJHtuYW1lfVwiOiBleHBlY3RlZCBhbiBPYmplY3QsIGAgK1xuICAgICAgYGJ1dCBnb3QgJHt0b1Jhd1R5cGUodmFsdWUpfS5gLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG5cbiAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gIC8vIHRoZSByZXN1bHQgb2YgYW5vdGhlciBtZXJnZU9wdGlvbnMgY2FsbC5cbiAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgaWYgKGNoaWxkLmV4dGVuZHMpIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICB9XG4gICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgbGV0IGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIGNvbnN0IHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgcmV0dXJuIGFzc2V0c1tpZF1cbiAgY29uc3QgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdXG4gIGNvbnN0IFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdXG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICBjb25zdCByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmICh3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIGNvbnN0IHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICBjb25zdCBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgbGV0IHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGJvb2xlYW4gY2FzdGluZ1xuICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgaWYgKGJvb2xlYW5JbmRleCA+IC0xKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSB7XG4gICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgICAgY29uc3Qgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIGNvbnN0IHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgfVxuICB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICBjb25zdCBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQgdHlwZSA9IHByb3AudHlwZTtcbiAgbGV0IHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgY29uc3QgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cblxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgIGdldEludmFsaWRUeXBlTWVzc2FnZShuYW1lLCB2YWx1ZSwgZXhwZWN0ZWRUeXBlcyksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICBsZXQgdmFsaWQ7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgY29uc3QgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIiR7bmFtZX1cIi5gICtcbiAgICBgIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKX1gO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICBjb25zdCByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICBjb25zdCBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYCB3aXRoIHZhbHVlICR7ZXhwZWN0ZWRWYWx1ZX1gO1xuICB9XG4gIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgaWYgKGlzRXhwbGljYWJsZShyZWNlaXZlZFR5cGUpKSB7XG4gICAgbWVzc2FnZSArPSBgd2l0aCB2YWx1ZSAke3JlY2VpdmVkVmFsdWV9LmA7XG4gIH1cbiAgcmV0dXJuIG1lc3NhZ2Vcbn1cblxuZnVuY3Rpb24gc3R5bGVWYWx1ZSAodmFsdWUsIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlfWBcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUgKHZhbHVlKSB7XG4gIGNvbnN0IGV4cGxpY2l0VHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGVsZW0gPT4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbSlcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuICguLi5hcmdzKSB7XG4gIHJldHVybiBhcmdzLnNvbWUoZWxlbSA9PiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJylcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIGxldCBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgY29uc3QgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgIGlmIChob29rcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHJldHVyblxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcgKFxuICBoYW5kbGVyLFxuICBjb250ZXh0LFxuICBhcmdzLFxuICB2bSxcbiAgaW5mb1xuKSB7XG4gIGxldCByZXM7XG4gIHRyeSB7XG4gICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgaWYgKHJlcyAmJiAhcmVzLl9pc1Z1ZSAmJiBpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzLmNhdGNoKGUgPT4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBgIChQcm9taXNlL2FzeW5jKWApKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgaW5mbyk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gaWYgdGhlIHVzZXIgaW50ZW50aW9uYWxseSB0aHJvd3MgdGhlIG9yaWdpbmFsIGVycm9yIGluIHRoZSBoYW5kbGVyLFxuICAgICAgLy8gZG8gbm90IGxvZyBpdCB0d2ljZVxuICAgICAgaWYgKGUgIT09IGVycikge1xuICAgICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gbG9nRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAge1xuICAgIHdhcm4oYEVycm9yIGluICR7aW5mb306IFwiJHtlcnIudG9TdHJpbmcoKX1cImAsIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cblxubGV0IGlzVXNpbmdNaWNyb1Rhc2sgPSBmYWxzZTtcblxuY29uc3QgY2FsbGJhY2tzID0gW107XG5sZXQgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgY29uc3QgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIG1pY3JvdGFza3MuXG4vLyBJbiAyLjUgd2UgdXNlZCAobWFjcm8pIHRhc2tzIChpbiBjb21iaW5hdGlvbiB3aXRoIG1pY3JvdGFza3MpLlxuLy8gSG93ZXZlciwgaXQgaGFzIHN1YnRsZSBwcm9ibGVtcyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnRcbi8vIChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuLy8gQWxzbywgdXNpbmcgKG1hY3JvKSB0YXNrcyBpbiBldmVudCBoYW5kbGVyIHdvdWxkIGNhdXNlIHNvbWUgd2VpcmQgYmVoYXZpb3JzXG4vLyB0aGF0IGNhbm5vdCBiZSBjaXJjdW12ZW50ZWQgKGUuZy4gIzcxMDksICM3MTUzLCAjNzU0NiwgIzc4MzQsICM4MTA5KS5cbi8vIFNvIHdlIG5vdyB1c2UgbWljcm90YXNrcyBldmVyeXdoZXJlLCBhZ2Fpbi5cbi8vIEEgbWFqb3IgZHJhd2JhY2sgb2YgdGhpcyB0cmFkZW9mZiBpcyB0aGF0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvc1xuLy8gd2hlcmUgbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTAsIHdoaWNoIGhhdmUgd29ya2Fyb3VuZHMpXG4vLyBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWUgZXZlbnQgKCM2NTY2KS5cbmxldCB0aW1lckZ1bmM7XG5cbi8vIFRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4vLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbi8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbi8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgY29uc3QgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgc2V0VGltZW91dChub29wKTtcbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIC8vIFVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gIGxldCBjb3VudGVyID0gMTtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaENhbGxiYWNrcyk7XG4gIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgfSk7XG4gIHRpbWVyRnVuYyA9ICgpID0+IHtcbiAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgfTtcbiAgaXNVc2luZ01pY3JvVGFzayA9IHRydWU7XG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAvLyBUZWNoaW5pY2FsbHkgaXQgbGV2ZXJhZ2VzIHRoZSAobWFjcm8pIHRhc2sgcXVldWUsXG4gIC8vIGJ1dCBpdCBpcyBzdGlsbCBhIGJldHRlciBjaG9pY2UgdGhhbiBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gIHRpbWVyRnVuYyA9ICgpID0+IHtcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgbGV0IF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaCgoKSA9PiB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICB0aW1lckZ1bmMoKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxubGV0IG1hcms7XG5sZXQgbWVhc3VyZTtcblxue1xuICBjb25zdCBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSB0YWcgPT4gcGVyZi5tYXJrKHRhZyk7XG4gICAgbWVhc3VyZSA9IChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSA9PiB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG5sZXQgaW5pdFByb3h5O1xuXG57XG4gIGNvbnN0IGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIGNvbnN0IHdhcm5Ob25QcmVzZW50ID0gKHRhcmdldCwga2V5KSA9PiB7XG4gICAgd2FybihcbiAgICAgIGBQcm9wZXJ0eSBvciBtZXRob2QgXCIke2tleX1cIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IGAgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IHdhcm5SZXNlcnZlZFByZWZpeCA9ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgUHJvcGVydHkgXCIke2tleX1cIiBtdXN0IGJlIGFjY2Vzc2VkIHdpdGggXCIkZGF0YS4ke2tleX1cIiBiZWNhdXNlIGAgK1xuICAgICAgJ3Byb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCBcIiRcIiBvciBcIl9cIiBhcmUgbm90IHByb3hpZWQgaW4gdGhlIFZ1ZSBpbnN0YW5jZSB0byAnICtcbiAgICAgICdwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIFZ1ZSBpbnRlcm5hbHMnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICBjb25zdCBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oYEF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLiR7a2V5fWApO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgaGFzSGFuZGxlciA9IHtcbiAgICBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICBjb25zdCBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgY29uc3QgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fFxuICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTtcbiAgICAgICAgZWxzZSB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTtcbiAgICAgICAgZWxzZSB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICBjb25zdCBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICBjb25zdCBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5jb25zdCBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgbGV0IGksIGtleXM7XG4gIGNvbnN0IGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgY29uc3QgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTtcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7XG4gIH1cbn1cblxuLyogICovXG5cbmNvbnN0IG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKChuYW1lKSA9PiB7XG4gIGNvbnN0IHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICBjb25zdCBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICBjb25zdCBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZSxcbiAgICBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgY29uc3QgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgY29uc3QgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cywgdm0sIGB2LW9uIGhhbmRsZXJgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbnMsIG51bGwsIGFyZ3VtZW50cywgdm0sIGB2LW9uIGhhbmRsZXJgKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgY3JlYXRlT25jZUhhbmRsZXIsXG4gIHZtXG4pIHtcbiAgbGV0IG5hbWUsIGRlZiQkMSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYkJDEgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFwiJHtldmVudC5uYW1lfVwiOiBnb3QgYCArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyLCB2bSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNUcnVlKGV2ZW50Lm9uY2UpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlT25jZUhhbmRsZXIoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICBkZWYgPSBkZWYuZGF0YS5ob29rIHx8IChkZWYuZGF0YS5ob29rID0ge30pO1xuICB9XG4gIGxldCBpbnZva2VyO1xuICBjb25zdCBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIGNvbnN0IHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCByZXMgPSB7fTtcbiAgY29uc3QgeyBhdHRycywgcHJvcHMgfSA9IGRhdGE7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAge1xuICAgICAgICBjb25zdCBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIGBQcm9wIFwiJHtrZXlJbkxvd2VyQ2FzZX1cIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IGAgK1xuICAgICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3Rvcil9LCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc2AgK1xuICAgICAgICAgICAgYCBcIiR7a2V5fVwiLiBgICtcbiAgICAgICAgICAgIGBOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIGAgK1xuICAgICAgICAgICAgYHByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gYCArXG4gICAgICAgICAgICBgdGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7YWx0S2V5fVwiIGluc3RlYWQgb2YgXCIke2tleX1cIi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGxldCBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSBjb250aW51ZVxuICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgYCR7bmVzdGVkSW5kZXggfHwgJyd9XyR7aX1gKTtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgKGNbMF0pLnRleHQpO1xuICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgIGMua2V5ID0gYF9fdmxpc3Qke25lc3RlZEluZGV4fV8ke2l9X19gO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgY29uc3QgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICBjb25zdCByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldLCAoKSA9PiB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIGAgK1xuICAgICAgICAgICAgYG92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gYCArXG4gICAgICAgICAgICBgaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFwiJHtrZXl9XCJgLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSBjb250aW51ZVxuICAgICAgY29uc3QgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICBsZXQgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIGNvbnN0IHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKGBJbmplY3Rpb24gXCIke2tleX1cIiBub3QgZm91bmRgLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG5cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHJldHVybiB7fVxuICB9XG4gIGNvbnN0IHNsb3RzID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgY29uc3QgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIGNvbnN0IHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAoY29uc3QgbmFtZSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBub3JtYWxTbG90cyxcbiAgcHJldlNsb3RzXG4pIHtcbiAgbGV0IHJlcztcbiAgaWYgKCFzbG90cykge1xuICAgIHJlcyA9IHt9O1xuICB9IGVsc2UgaWYgKHNsb3RzLl9ub3JtYWxpemVkKSB7XG4gICAgLy8gZmFzdCBwYXRoIDE6IGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXIgb25seSwgcGFyZW50IGRpZCBub3QgY2hhbmdlXG4gICAgcmV0dXJuIHNsb3RzLl9ub3JtYWxpemVkXG4gIH0gZWxzZSBpZiAoXG4gICAgc2xvdHMuJHN0YWJsZSAmJlxuICAgIHByZXZTbG90cyAmJlxuICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICBPYmplY3Qua2V5cyhub3JtYWxTbG90cykubGVuZ3RoID09PSAwXG4gICkge1xuICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcbiAgICByZXR1cm4gcHJldlNsb3RzXG4gIH0gZWxzZSB7XG4gICAgcmVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1trZXldICYmIGtleVswXSAhPT0gJyQnKSB7XG4gICAgICAgIHJlc1trZXldID0gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xuICBmb3IgKGNvbnN0IGtleSBpbiBub3JtYWxTbG90cykge1xuICAgIGlmICghKGtleSBpbiByZXMpKSB7XG4gICAgICByZXNba2V5XSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxuICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcbiAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgKHNsb3RzKS5fbm9ybWFsaXplZCA9IHJlcztcbiAgfVxuICBkZWYocmVzLCAnJHN0YWJsZScsIHNsb3RzID8gISFzbG90cy4kc3RhYmxlIDogdHJ1ZSk7XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICBjb25zdCBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcbiAgICByZXMgPSByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzKVxuICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcbiAgICByZXR1cm4gcmVzICYmIHJlcy5sZW5ndGggPT09IDBcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHJlc1xuICB9O1xuICAvLyB0aGlzIGlzIGEgc2xvdCB1c2luZyB0aGUgbmV3IHYtc2xvdCBzeW50YXggd2l0aG91dCBzY29wZS4gYWx0aG91Z2ggaXQgaXNcbiAgLy8gY29tcGlsZWQgYXMgYSBzY29wZWQgc2xvdCwgcmVuZGVyIGZuIHVzZXJzIHdvdWxkIGV4cGVjdCBpdCB0byBiZSBwcmVzZW50XG4gIC8vIG9uIHRoaXMuJHNsb3RzIGJlY2F1c2UgdGhlIHVzYWdlIGlzIHNlbWFudGljYWxseSBhIG5vcm1hbCBzbG90LlxuICBpZiAoZm4ucHJveHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsU2xvdHMsIGtleSwge1xuICAgICAgZ2V0OiBub3JtYWxpemVkLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBub3JtYWxpemVkXG59XG5cbmZ1bmN0aW9uIHByb3h5Tm9ybWFsU2xvdChzbG90cywga2V5KSB7XG4gIHJldHVybiAoKSA9PiBzbG90c1trZXldXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIGxldCByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgaWYgKGhhc1N5bWJvbCAmJiB2YWxbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgcmV0ID0gW107XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICBsZXQgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgd2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuICAgICAgICByZXQucHVzaChyZW5kZXIocmVzdWx0LnZhbHVlLCByZXQubGVuZ3RoKSk7XG4gICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc0RlZihyZXQpKSB7XG4gICAgcmV0ID0gW107XG4gIH1cbiAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICBjb25zdCBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgbGV0IG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICBub2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgY29uc3QgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0tleU5vdE1hdGNoIChleHBlY3QsIGFjdHVhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3QpKSB7XG4gICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsXG4gIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5LZXlDb2RlLFxuICBldmVudEtleU5hbWUsXG4gIGJ1aWx0SW5LZXlOYW1lXG4pIHtcbiAgY29uc3QgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5LZXlDb2RlO1xuICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpXG4gIH0gZWxzZSBpZiAobWFwcGVkS2V5Q29kZSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSlcbiAgfSBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcbiAgICByZXR1cm4gaHlwaGVuYXRlKGV2ZW50S2V5TmFtZSkgIT09IGtleVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcCxcbiAgaXNTeW5jXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNoO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkgJiYgIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgY29uc3Qgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bYHVwZGF0ZToke2NhbWVsaXplZEtleX1gXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIGNvbnN0IGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgbGV0IHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgYF9fc3RhdGljX18ke2luZGV4fWAsIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgYF9fb25jZV9fJHtpbmRleH0ke2tleSA/IGBfJHtrZXl9YCA6IGBgfWAsIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIGAke2tleX1fJHtpfWAsIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICBjb25zdCBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIGhhc0R5bmFtaWNLZXlzLFxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzbG90ID0gZm5zW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgaGFzRHluYW1pY0tleXMsIHJlcyk7XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmREeW5hbWljS2V5cyAoYmFzZU9iaiwgdmFsdWVzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3Qga2V5ID0gdmFsdWVzW2ldO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkpIHtcbiAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgfSBlbHNlIGlmIChrZXkgIT09ICcnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgLy8gbnVsbCBpcyBhIHNwZWljYWwgdmFsdWUgZm9yIGV4cGxpY2l0bHkgcmVtb3ZpbmcgYSBiaW5kaW5nXG4gICAgICB3YXJuKFxuICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogJHtrZXl9YCxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VPYmpcbn1cblxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIGxldCBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIGNvbnN0IGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICBjb25zdCBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy4kc2xvdHMpIHtcbiAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICBkYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB0aGlzLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJHNsb3RzXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQgKCkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuc2xvdHMoKSlcbiAgICB9XG4gIH0pKTtcblxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy4kc2xvdHMpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gKGEsIGIsIGMsIGQpID0+IHtcbiAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGNvbnN0IHByb3BzID0ge307XG4gIGNvbnN0IHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7XG4gICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTtcbiAgfVxuXG4gIGNvbnN0IHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIGNvbnN0IHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcblxuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dClcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgIGNvbnN0IHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgY29uc3QgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgY2xvbmUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICB7XG4gICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9IHJlbmRlckNvbnRleHQ7XG4gIH1cbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG5jb25zdCBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0ICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgaWYgKFxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlXG4gICAgKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIGNvbnN0IG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBjb25zdCBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0ICh2bm9kZSkge1xuICAgIGNvbnN0IHsgY29udGV4dCwgY29tcG9uZW50SW5zdGFuY2UgfSA9IHZub2RlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95ICh2bm9kZSkge1xuICAgIGNvbnN0IHsgY29tcG9uZW50SW5zdGFuY2UgfSA9IHZub2RlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB3YXJuKGBJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiAke1N0cmluZyhDdG9yKX1gLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgbGV0IGFzeW5jRmFjdG9yeTtcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgYXN5bmNGYWN0b3J5ID0gQ3RvcjtcbiAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIG5vZGUgZm9yIGFzeW5jIGNvbXBvbmVudCwgd2hpY2ggaXMgcmVuZGVyZWRcbiAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxuICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgcmV0dXJuIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIoXG4gICAgICAgIGFzeW5jRmFjdG9yeSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHRhZ1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICB0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICBjb25zdCBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgY29uc3QgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIGNvbnN0IHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgZGF0YSA9IHt9O1xuICAgIGlmIChzbG90KSB7XG4gICAgICBkYXRhLnNsb3QgPSBzbG90O1xuICAgIH1cbiAgfVxuXG4gIC8vIGluc3RhbGwgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgY29uc3QgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgY29uc3Qgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgYHZ1ZS1jb21wb25lbnQtJHtDdG9yLmNpZH0ke25hbWUgPyBgLSR7bmFtZX1gIDogJyd9YCxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvciwgcHJvcHNEYXRhLCBsaXN0ZW5lcnMsIHRhZywgY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbikge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIHBhcmVudFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICBjb25zdCBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgY29uc3QgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgY29uc3QgZXhpc3RpbmcgPSBob29rc1trZXldO1xuICAgIGNvbnN0IHRvTWVyZ2UgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcbiAgICAgIGhvb2tzW2tleV0gPSBleGlzdGluZyA/IG1lcmdlSG9vayQxKHRvTWVyZ2UsIGV4aXN0aW5nKSA6IHRvTWVyZ2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChmMSwgZjIpIHtcbiAgY29uc3QgbWVyZ2VkID0gKGEsIGIpID0+IHtcbiAgICAvLyBmbG93IGNvbXBsYWlucyBhYm91dCBleHRyYSBhcmdzIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYW55XG4gICAgZjEoYSwgYik7XG4gICAgZjIoYSwgYik7XG4gIH07XG4gIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIGNvbnN0IHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gIGNvbnN0IGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0J1xuICA7KGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgY29uc3Qgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBjb25zdCBleGlzdGluZyA9IG9uW2V2ZW50XTtcbiAgY29uc3QgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICBpZiAoaXNEZWYoZXhpc3RpbmcpKSB7XG4gICAgaWYgKFxuICAgICAgQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgICAgPyBleGlzdGluZy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTFcbiAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIG9uW2V2ZW50XSA9IFtjYWxsYmFja10uY29uY2F0KGV4aXN0aW5nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbmNvbnN0IFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xuY29uc3QgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICB3YXJuKFxuICAgICAgYEF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9XFxuYCArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIGxldCB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIGxldCBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCghZGF0YSB8fCAhZGF0YS5wcmUpICYmIGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAoaXNEZWYobnMpKSBhcHBseU5TKHZub2RlLCBucyk7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICBucyA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVmICM1MzE4XG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICB9XG4gIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gIGNvbnN0IG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgY29uc3QgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgY29uc3QgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IChhLCBiLCBjLCBkKSA9PiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSAoYSwgYiwgYywgZCkgPT4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICBjb25zdCBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsICgpID0+IHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihgJGF0dHJzIGlzIHJlYWRvbmx5LmAsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsICgpID0+IHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihgJGxpc3RlbmVycyBpcyByZWFkb25seS5gLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH1cbn1cblxubGV0IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBjb25zdCB7IHJlbmRlciwgX3BhcmVudFZub2RlIH0gPSB2bS4kb3B0aW9ucztcblxuICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcbiAgICAgIHZtLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdm0uJHNsb3RzLFxuICAgICAgICB2bS4kc2NvcGVkU2xvdHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcbiAgICAvLyByZW5kZXIgc2VsZlxuICAgIGxldCB2bm9kZTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIG1haW50YWluIGEgc3RhY2sgYmVjYXVlcyBhbGwgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHdoZW4gcGFyZW50IGNvbXBvbmVudCBpcyBwYXRjaGVkLlxuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gdm07XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgcmVuZGVyYCk7XG4gICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGByZW5kZXJFcnJvcmApO1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bm9kZSA9IHZub2RlWzBdO1xuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBjb25zdCBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yXG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgY29uc3Qgb3duZXIgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gIGlmIChpc0RlZihmYWN0b3J5Lm93bmVycykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5Lm93bmVycy5wdXNoKG93bmVyKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvd25lcnMgPSBmYWN0b3J5Lm93bmVycyA9IFtvd25lcl07XG4gICAgbGV0IHN5bmMgPSB0cnVlO1xuXG4gICAgY29uc3QgZm9yY2VSZW5kZXIgPSAocmVuZGVyQ29tcGxldGVkKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG93bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgKG93bmVyc1tpXSkuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJDb21wbGV0ZWQpIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHJlc29sdmUgPSBvbmNlKChyZXMpID0+IHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCByZWplY3QgPSBvbmNlKHJlYXNvbiA9PiB7XG4gICAgICB3YXJuKFxuICAgICAgICBgRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiAke1N0cmluZyhmYWN0b3J5KX1gICtcbiAgICAgICAgKHJlYXNvbiA/IGBcXG5SZWFzb246ICR7cmVhc29ufWAgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlcy5jb21wb25lbnQpKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIGB0aW1lb3V0ICgke3Jlcy50aW1lb3V0fW1zKWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIGNvbnN0IGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxubGV0IHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyIChldmVudCwgZm4pIHtcbiAgY29uc3QgX3RhcmdldCA9IHRhcmdldDtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICBjb25zdCByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgY29uc3QgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZtLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZtLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIGNvbnN0IGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICBsZXQgY2I7XG4gICAgbGV0IGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICB7XG4gICAgICBjb25zdCBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IGAgK1xuICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUodm0pfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V2ZW50fVwiLiBgICtcbiAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgYCArXG4gICAgICAgICAgYHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBgICtcbiAgICAgICAgICBgWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2h5cGhlbmF0ZShldmVudCl9XCIgaW5zdGVhZCBvZiBcIiR7ZXZlbnR9XCIuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICBjb25zdCBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgY29uc3QgaW5mbyA9IGBldmVudCBoYW5kbGVyIGZvciBcIiR7ZXZlbnR9XCJgO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG5sZXQgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xubGV0IGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xuICBjb25zdCBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICBjb25zdCBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgbGV0IHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgY29uc3QgcHJldkVsID0gdm0uJGVsO1xuICAgIGNvbnN0IHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICBjb25zdCByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG4gICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlc1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICBjb25zdCBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICBsZXQgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcbiAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAvLyBmaXJlIGRlc3Ryb3llZCBob29rXG4gICAgY2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcbiAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgIHZtLiRvZmYoKTtcbiAgICAvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICBpZiAodm0uJHZub2RlKSB7XG4gICAgICB2bS4kdm5vZGUucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIGxldCB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gdm0uX25hbWU7XG4gICAgICBjb25zdCBpZCA9IHZtLl91aWQ7XG4gICAgICBjb25zdCBzdGFydFRhZyA9IGB2dWUtcGVyZi1zdGFydDoke2lkfWA7XG4gICAgICBjb25zdCBlbmRUYWcgPSBgdnVlLXBlcmYtZW5kOiR7aWR9YDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICBjb25zdCB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoYHZ1ZSAke25hbWV9IHJlbmRlcmAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKGB2dWUgJHtuYW1lfSBwYXRjaGAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwge1xuICAgIGJlZm9yZSAoKSB7XG4gICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IHRydWU7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4uXG5cbiAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGR5bmFtaWMgc2NvcGVkU2xvdHMgKGhhbmQtd3JpdHRlbiBvciBjb21waWxlZCBidXQgd2l0aFxuICAvLyBkeW5hbWljIHNsb3QgbmFtZXMpLiBTdGF0aWMgc2NvcGVkIHNsb3RzIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaGFzIHRoZVxuICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXG4gIGNvbnN0IGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoXG4gICAgKHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgJiYgIXBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAodm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJiAhdm0uJHNjb3BlZFNsb3RzLiRzdGFibGUpXG4gICk7XG5cbiAgLy8gQW55IHN0YXRpYyBzbG90IGNoaWxkcmVuIGZyb20gdGhlIHBhcmVudCBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyBwYXJlbnQnc1xuICAvLyB1cGRhdGUuIER5bmFtaWMgc2NvcGVkIHNsb3RzIG1heSBhbHNvIGhhdmUgY2hhbmdlZC4gSW4gc3VjaCBjYXNlcywgYSBmb3JjZWRcbiAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gIGNvbnN0IG5lZWRzRm9yY2VVcGRhdGUgPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIGhhc0R5bmFtaWNTY29wZWRTbG90XG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIGNvbnN0IHByb3BzID0gdm0uX3Byb3BzO1xuICAgIGNvbnN0IHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgY29uc3QgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICBjb25zdCBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAobmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICBjb25zdCBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuICBjb25zdCBpbmZvID0gYCR7aG9va30gaG9va2A7XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyc1tpXSwgdm0sIG51bGwsIHZtLCBpbmZvKTtcbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG5jb25zdCBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG5jb25zdCBxdWV1ZSA9IFtdO1xuY29uc3QgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbmxldCBoYXMgPSB7fTtcbmxldCBjaXJjdWxhciA9IHt9O1xubGV0IHdhaXRpbmcgPSBmYWxzZTtcbmxldCBmbHVzaGluZyA9IGZhbHNlO1xubGV0IGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLy8gQXN5bmMgZWRnZSBjYXNlICM2NTY2IHJlcXVpcmVzIHNhdmluZyB0aGUgdGltZXN0YW1wIHdoZW4gZXZlbnQgbGlzdGVuZXJzIGFyZVxuLy8gYXR0YWNoZWQuIEhvd2V2ZXIsIGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCkgaGFzIGEgcGVyZiBvdmVyaGVhZCBlc3BlY2lhbGx5XG4vLyBpZiB0aGUgcGFnZSBoYXMgdGhvdXNhbmRzIG9mIGV2ZW50IGxpc3RlbmVycy4gSW5zdGVhZCwgd2UgdGFrZSBhIHRpbWVzdGFtcFxuLy8gZXZlcnkgdGltZSB0aGUgc2NoZWR1bGVyIGZsdXNoZXMgYW5kIHVzZSB0aGF0IGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzXG4vLyBhdHRhY2hlZCBkdXJpbmcgdGhhdCBmbHVzaC5cbmxldCBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSAwO1xuXG4vLyBBc3luYyBlZGdlIGNhc2UgZml4IHJlcXVpcmVzIHN0b3JpbmcgYW4gZXZlbnQgbGlzdGVuZXIncyBhdHRhY2ggdGltZXN0YW1wLlxubGV0IGdldE5vdyA9IERhdGUubm93O1xuXG4vLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxuLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcbi8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxuLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxuaWYgKGluQnJvd3NlciAmJiBnZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xuICAvLyBpZiB0aGUgbG93LXJlcyB0aW1lc3RhbXAgd2hpY2ggaXMgYmlnZ2VyIHRoYW4gdGhlIGV2ZW50IHRpbWVzdGFtcFxuICAvLyAod2hpY2ggaXMgZXZhbHVhdGVkIEFGVEVSKSBpdCBtZWFucyB0aGUgZXZlbnQgaXMgdXNpbmcgYSBoaS1yZXMgdGltZXN0YW1wLFxuICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cbiAgZ2V0Tm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSBnZXROb3coKTtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICBsZXQgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydCgoYSwgYikgPT4gYS5pZCAtIGIuaWQpO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZiAod2F0Y2hlci5iZWZvcmUpIHtcbiAgICAgIHdhdGNoZXIuYmVmb3JlKCk7XG4gICAgfVxuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAoaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gYGluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFwiJHt3YXRjaGVyLmV4cHJlc3Npb259XCJgXG4gICAgICAgICAgICAgIDogYGluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5gXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICBjb25zdCBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIGNvbnN0IHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICBsZXQgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICBjb25zdCB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgY29uc3QgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIGxldCBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghY29uZmlnLmFzeW5jKSB7XG4gICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cblxuXG5sZXQgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG5jbGFzcyBXYXRjaGVyIHtcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuXG4gIGNvbnN0cnVjdG9yIChcbiAgICB2bSxcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnMsXG4gICAgaXNSZW5kZXJXYXRjaGVyXG4gICkge1xuICAgIHRoaXMudm0gPSB2bTtcbiAgICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gICAgfVxuICAgIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAgIC8vIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jYiA9IGNiO1xuICAgIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gICAgdGhpcy5kZXBzID0gW107XG4gICAgdGhpcy5uZXdEZXBzID0gW107XG4gICAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XG4gICAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gICAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYEZhaWxlZCB3YXRjaGluZyBwYXRoOiBcIiR7ZXhwT3JGbn1cIiBgICtcbiAgICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogdGhpcy5nZXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBnZXQgKCkge1xuICAgIHB1c2hUYXJnZXQodGhpcyk7XG4gICAgbGV0IHZhbHVlO1xuICAgIGNvbnN0IHZtID0gdGhpcy52bTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgYGdldHRlciBmb3Igd2F0Y2hlciBcIiR7dGhpcy5leHByZXNzaW9ufVwiYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHBvcFRhcmdldCgpO1xuICAgICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgKi9cbiAgYWRkRGVwIChkZXApIHtcbiAgICBjb25zdCBpZCA9IGRlcC5pZDtcbiAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gICAqL1xuICBjbGVhbnVwRGVwcyAoKSB7XG4gICAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRtcCA9IHRoaXMuZGVwSWRzO1xuICAgIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gICAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gICAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgICB0bXAgPSB0aGlzLmRlcHM7XG4gICAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICAgIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAgICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAgICovXG4gIHVwZGF0ZSAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAgICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAgICovXG4gIHJ1biAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICAgIHRoaXMuZGVlcFxuICAgICAgKSB7XG4gICAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgYGNhbGxiYWNrIGZvciB3YXRjaGVyIFwiJHt0aGlzLmV4cHJlc3Npb259XCJgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICAgKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gICAqL1xuICBldmFsdWF0ZSAoKSB7XG4gICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICAgKi9cbiAgZGVwZW5kICgpIHtcbiAgICBsZXQgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAgICovXG4gIHRlYXJkb3duICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgY29uc3Qgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTtcbiAgaWYgKG9wdHMubWV0aG9kcykgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpO1xuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIGNvbnN0IHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgY29uc3QgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIGNvbnN0IGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgY29uc3QgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBpZiAoIWlzUm9vdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgY29uc3QgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgY29uc3QgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgXCIke2h5cGhlbmF0ZWRLZXl9XCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLmAsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCAoKSA9PiB7XG4gICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgYEF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBgICtcbiAgICAgICAgICAgIGBvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBgICtcbiAgICAgICAgICAgIGBJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgYCArXG4gICAgICAgICAgICBgdmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXCIke2tleX1cImAsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIGBfcHJvcHNgLCBrZXkpO1xuICAgIH1cbiAgfVxuICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICBsZXQgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgY29uc3QgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgY29uc3QgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuYCxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgVGhlIGRhdGEgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gYCArXG4gICAgICAgIGBVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuYCxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICBwcm94eSh2bSwgYF9kYXRhYCwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgYGRhdGEoKWApO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbmNvbnN0IGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGNvbnN0IHdhdGNoZXJzID0gdm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICBjb25zdCBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBjb25zdCB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICBjb25zdCBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAoZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIi5gLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oYFRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLmAsIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oYFRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuYCwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgY29uc3Qgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmKTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmLmdldClcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcbiAgfVxuICBpZiAoc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgQ29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiB3YXMgYXNzaWduZWQgdG8gYnV0IGl0IGhhcyBubyBzZXR0ZXIuYCxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIGNvbnN0IHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcbiAgICBpZiAod2F0Y2hlcikge1xuICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICBjb25zdCBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RzW2tleV19XCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBgICtcbiAgICAgICAgICBgRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuYCxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKChrZXkgaW4gdm0pICYmIGlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBgICtcbiAgICAgICAgICBgQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2gpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgaGFuZGxlcixcbiAgb3B0aW9uc1xuKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHJldHVybiB2bS4kd2F0Y2goZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucylcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICBjb25zdCBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICBjb25zdCBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihgJHByb3BzIGlzIHJlYWRvbmx5LmAsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIGNvbnN0IHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnJvciwgdm0sIGBjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXCIke3dhdGNoZXIuZXhwcmVzc2lvbn1cImApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5sZXQgdWlkJDMgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgLy8gYSB1aWRcbiAgICB2bS5fdWlkID0gdWlkJDMrKztcblxuICAgIGxldCBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBgdnVlLXBlcmYtc3RhcnQ6JHt2bS5fdWlkfWA7XG4gICAgICBlbmRUYWcgPSBgdnVlLXBlcmYtZW5kOiR7dm0uX3VpZH1gO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZShgdnVlICR7dm0uX25hbWV9IGluaXRgLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIGNvbnN0IHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG5cbiAgY29uc3Qgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICBsZXQgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICBjb25zdCBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIGNvbnN0IGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIGNvbnN0IG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICBsZXQgbW9kaWZpZWQ7XG4gIGNvbnN0IGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgY29uc3Qgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKGNvbnN0IGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSBtb2RpZmllZCA9IHt9O1xuICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlKTtcbnN0YXRlTWl4aW4oVnVlKTtcbmV2ZW50c01peGluKFZ1ZSk7XG5saWZlY3ljbGVNaXhpbihWdWUpO1xucmVuZGVyTWl4aW4oVnVlKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgY29uc3QgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIGxldCBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgY29uc3QgU3VwZXIgPSB0aGlzO1xuICAgIGNvbnN0IFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgY29uc3QgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIGNvbnN0IHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBgX3Byb3BzYCwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICBjb25zdCBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2godHlwZSA9PiB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIGNvbnN0IHsgY2FjaGUsIGtleXMsIF92bm9kZSB9ID0ga2VlcEFsaXZlSW5zdGFuY2U7XG4gIGZvciAoY29uc3Qga2V5IGluIGNhY2hlKSB7XG4gICAgY29uc3QgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgY29uc3QgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG5jb25zdCBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkICgpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcy5jYWNoZSwga2V5LCB0aGlzLmtleXMpO1xuICAgIH1cbiAgfSxcblxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIHZhbCA9PiB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMsIG5hbWUgPT4gbWF0Y2hlcyh2YWwsIG5hbWUpKTtcbiAgICB9KTtcbiAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIHZhbCA9PiB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMsIG5hbWUgPT4gIW1hdGNoZXModmFsLCBuYW1lKSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyICgpIHtcbiAgICBjb25zdCBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBjb25zdCB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgY29uc3QgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlIH0gPSB0aGlzO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGNhY2hlLCBrZXlzIH0gPSB0aGlzO1xuICAgICAgY29uc3Qga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyBgOjoke2NvbXBvbmVudE9wdGlvbnMudGFnfWAgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICBjb25zdCBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9ICgpID0+IGNvbmZpZztcbiAge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSAoKSA9PiB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuLFxuICAgIGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXG4gIFZ1ZS5vYnNlcnZhYmxlID0gKG9iaikgPT4ge1xuICAgIG9ic2VydmUob2JqKTtcbiAgICByZXR1cm4gb2JqXG4gIH07XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbn0pO1xuXG5WdWUudmVyc2lvbiA9ICcyLjYuNic7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxuY29uc3QgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG5jb25zdCBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbmNvbnN0IG11c3RVc2VQcm9wID0gKHRhZywgdHlwZSwgYXR0cikgPT4ge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbmNvbnN0IGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxuY29uc3QgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlID0gbWFrZU1hcCgnZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seScpO1xuXG5jb25zdCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXG4gICAgPyAnZmFsc2UnXG4gICAgLy8gYWxsb3cgYXJiaXRyYXJ5IHN0cmluZyB2YWx1ZSBmb3IgY29udGVudGVkaXRhYmxlXG4gICAgOiBrZXkgPT09ICdjb250ZW50ZWRpdGFibGUnICYmIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSh2YWx1ZSlcbiAgICAgID8gdmFsdWVcbiAgICAgIDogJ3RydWUnXG59O1xuXG5jb25zdCBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxuY29uc3QgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxuY29uc3QgaXNYbGluayA9IChuYW1lKSA9PiB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbmNvbnN0IGdldFhsaW5rUHJvcCA9IChuYW1lKSA9PiB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxuY29uc3QgaXNGYWxzeUF0dHJWYWx1ZSA9ICh2YWwpID0+IHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICBsZXQgZGF0YSA9IHZub2RlLmRhdGE7XG4gIGxldCBwYXJlbnROb2RlID0gdm5vZGU7XG4gIGxldCBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBsZXQgc3RyaW5naWZpZWQ7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHJlcyArPSAnICc7XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICBsZXQgcmVzID0gJyc7XG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHJlcyArPSAnICc7XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5jb25zdCBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG5jb25zdCBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbmNvbnN0IGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbmNvbnN0IGlzUHJlVGFnID0gKHRhZykgPT4gdGFnID09PSAncHJlJztcblxuY29uc3QgaXNSZXNlcnZlZFRhZyA9ICh0YWcpID0+IHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbmNvbnN0IHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG5jb25zdCBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIGNvbnN0IGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybiBlbG1cbiAgfVxuICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICBpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gIH1cbiAgcmV0dXJuIGVsbVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxufVxuXG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGVcbn1cblxuZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcbn1cblxuZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lXG59XG5cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlIChub2RlLCBzY29wZUlkKSB7XG4gIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICBjb25zdCBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFpc0RlZihrZXkpKSByZXR1cm5cblxuICBjb25zdCB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIGNvbnN0IHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgY29uc3QgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxuY29uc3QgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG5jb25zdCBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgKFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgKSB8fCAoXG4gICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSByZXR1cm4gdHJ1ZVxuICBsZXQgaTtcbiAgY29uc3QgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICBjb25zdCB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICBsZXQgaSwga2V5O1xuICBjb25zdCBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIG1hcFtrZXldID0gaTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgbGV0IGksIGo7XG4gIGNvbnN0IGNicyA9IHt9O1xuXG4gIGNvbnN0IHsgbW9kdWxlcywgbm9kZU9wcyB9ID0gYmFja2VuZDtcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGlnbm9yZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xuICAgICAgICB9KVxuICAgICAgKSAmJlxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgIClcbiAgfVxuXG4gIGxldCBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxtIChcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbSxcbiAgICBuZXN0ZWQsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleFxuICApIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgIC8vIG5vdyBpdCdzIHVzZWQgYXMgYSBuZXcgbm9kZSwgb3ZlcndyaXRpbmcgaXRzIGVsbSB3b3VsZCBjYXVzZVxuICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgIC8vIGFzc29jaWF0ZWQgRE9NIGVsZW1lbnQgZm9yIGl0LlxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBsZXQgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBjb25zdCBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLyk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGxldCBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICBsZXQgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChub2RlT3BzLnBhcmVudE5vZGUocmVmJCQxKSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICBsZXQgaTtcbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmZuU2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICB9XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmb3Igc2xvdCBjb250ZW50IHRoZXkgc2hvdWxkIGFsc28gZ2V0IHRoZSBzY29wZUlkIGZyb20gdGhlIGhvc3QgaW5zdGFuY2UuXG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgIGkgIT09IHZub2RlLmZuQ29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBmYWxzZSwgdm5vZGVzLCBzdGFydElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgbGV0IGksIGo7XG4gICAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIGkodm5vZGUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSBjYnMuZGVzdHJveVtpXSh2bm9kZSk7XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjb25zdCBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICBsZXQgaTtcbiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmIChpc0RlZihybSkpIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgIHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgbGV0IG9sZFN0YXJ0SWR4ID0gMDtcbiAgICBsZXQgbmV3U3RhcnRJZHggPSAwO1xuICAgIGxldCBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIGxldCBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgbGV0IG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICBsZXQgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIGxldCBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgbGV0IG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIGNvbnN0IGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIGNvbnN0IHNlZW5LZXlzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJyR7a2V5fScuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5gLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAoXG4gICAgb2xkVm5vZGUsXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXgsXG4gICAgcmVtb3ZlT25seVxuICApIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXG4gICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgaTtcbiAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICBjb25zdCBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgY29uc3QgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgeyB0YWcsIGRhdGEsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgIHZub2RlLmVsbSA9IGVsbTtcblxuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gYXNzZXJ0IG5vZGUgbWF0Y2hcbiAgICB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICBsZXQgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGxldCBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xuICAgICAgICAgICAgZnVsbEludm9rZSA9IHRydWU7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIGVsbS5kYXRhID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUsIGluVlByZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fCAoXG4gICAgICAgICFpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBpblZQcmUpICYmXG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIGNvbnN0IGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIGNvbnN0IG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgY29uc3QgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgbGV0IGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIGNvbnN0IHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGluc2VydC5mbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaV0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICBjb25zdCBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gIGNvbnN0IGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIGNvbnN0IG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgY29uc3QgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIGNvbnN0IGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIGNvbnN0IGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgbGV0IGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIGNvbnN0IGNhbGxJbnNlcnQgPSAoKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCAoKSA9PiB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgY29uc3QgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIGxldCBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8IGAke2Rpci5uYW1lfS4ke09iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKX1gXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgY29uc3QgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIGBkaXJlY3RpdmUgJHtkaXIubmFtZX0gJHtob29rfSBob29rYCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBjb25zdCBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IGtleSwgY3VyLCBvbGQ7XG4gIGNvbnN0IGVsbSA9IHZub2RlLmVsbTtcbiAgY29uc3Qgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICBsZXQgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoZWwudGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxuICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgID8gJ3RydWUnXG4gICAgICAgIDoga2V5O1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlU2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgLy8gaW1tZWRpYXRlbHkuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFxuICAgICAgaXNJRSAmJiAhaXNJRTkgJiZcbiAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiB2YWx1ZSAhPT0gJycgJiYgIWVsLl9faWVwaFxuICAgICkge1xuICAgICAgY29uc3QgYmxvY2tlciA9IGUgPT4ge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgfTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICBjb25zdCBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgY29uc3QgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG5jb25zdCB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICBsZXQgaW5TaW5nbGUgPSBmYWxzZTtcbiAgbGV0IGluRG91YmxlID0gZmFsc2U7XG4gIGxldCBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIGxldCBpblJlZ2V4ID0gZmFsc2U7XG4gIGxldCBjdXJseSA9IDA7XG4gIGxldCBzcXVhcmUgPSAwO1xuICBsZXQgcGFyZW4gPSAwO1xuICBsZXQgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgbGV0IGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIGluU2luZ2xlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpbkRvdWJsZSkge1xuICAgICAgaWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIGluUmVnZXggPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYyA9PT0gMHg3QyAmJiAvLyBwaXBlXG4gICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gMHg3QyAmJlxuICAgICAgIWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG4gICAgKSB7XG4gICAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAweDIyOiBpbkRvdWJsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gXCJcbiAgICAgICAgY2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgIGNhc2UgMHgyODogcGFyZW4rKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgY2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgIGNhc2UgMHg1RDogc3F1YXJlLS07IGJyZWFrICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgY2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgICBpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG4gICAgICAgIGxldCBqID0gaSAtIDE7XG4gICAgICAgIGxldCBwO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgaW5SZWdleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgcHVzaEZpbHRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgKGZpbHRlcnMgfHwgKGZpbHRlcnMgPSBbXSkpLnB1c2goZXhwLnNsaWNlKGxhc3RGaWx0ZXJJbmRleCwgaSkudHJpbSgpKTtcbiAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgfVxuXG4gIGlmIChmaWx0ZXJzKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByZXNzaW9uXG59XG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIGNvbnN0IGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiBgX2YoXCIke2ZpbHRlcn1cIikoJHtleHB9KWBcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIGNvbnN0IGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiBgX2YoXCIke25hbWV9XCIpKCR7ZXhwfSR7YXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3N9YFxuICB9XG59XG5cbi8qICAqL1xuXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2csIHJhbmdlKSB7XG4gIGNvbnNvbGUuZXJyb3IoYFtWdWUgY29tcGlsZXJdOiAke21zZ31gKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChtID0+IG1ba2V5XSkuZmlsdGVyKF8gPT4gXylcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lLCB2YWx1ZSwgZHluYW1pYyB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIGNvbnN0IGF0dHJzID0gZHluYW1pY1xuICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZSwgdmFsdWUsIGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG5mdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlKSB7XG4gIGVsLmF0dHJzTWFwW25hbWVdID0gdmFsdWU7XG4gIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWUsIHZhbHVlIH0sIHJhbmdlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBpc0R5bmFtaWNBcmcsXG4gIG1vZGlmaWVycyxcbiAgcmFuZ2Vcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oe1xuICAgIG5hbWUsXG4gICAgcmF3TmFtZSxcbiAgICB2YWx1ZSxcbiAgICBhcmcsXG4gICAgaXNEeW5hbWljQXJnLFxuICAgIG1vZGlmaWVyc1xuICB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXJNYXJrZXIgKHN5bWJvbCwgbmFtZSwgZHluYW1pYykge1xuICByZXR1cm4gZHluYW1pY1xuICAgID8gYF9wKCR7bmFtZX0sXCIke3N5bWJvbH1cIilgXG4gICAgOiBzeW1ib2wgKyBuYW1lIC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuLFxuICByYW5nZSxcbiAgZHluYW1pY1xuKSB7XG4gIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG5cbiAgLy8gbm9ybWFsaXplIGNsaWNrLnJpZ2h0IGFuZCBjbGljay5taWRkbGUgc2luY2UgdGhleSBkb24ndCBhY3R1YWxseSBmaXJlXG4gIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBgKCR7bmFtZX0pPT09J2NsaWNrJz8nY29udGV4dG1lbnUnOigke25hbWV9KWA7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICBuYW1lID0gJ2NvbnRleHRtZW51JztcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgbmFtZSA9IGAoJHtuYW1lfSk9PT0nY2xpY2snPydtb3VzZXVwJzooJHtuYW1lfSlgO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdtb3VzZXVwJztcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCchJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyYnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuXG4gIGxldCBldmVudHM7XG4gIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cblxuICBjb25zdCBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYyB9LCByYW5nZSk7XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICBjb25zdCBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxuXG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWVcbikge1xuICByZXR1cm4gZWwucmF3QXR0cnNNYXBbJzonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFsndi1iaW5kOicgKyBuYW1lXSB8fFxuICAgIGVsLnJhd0F0dHJzTWFwW25hbWVdXG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIGNvbnN0IGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIGNvbnN0IHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgbGV0IHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleCAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgY29uc3QgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGF0dHIgPSBsaXN0W2ldO1xuICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm4gYXR0clxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICBpdGVtLFxuICByYW5nZVxuKSB7XG4gIGlmIChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IHsgbnVtYmVyLCB0cmltIH0gPSBtb2RpZmllcnMgfHwge307XG5cbiAgY29uc3QgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICBsZXQgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgYCh0eXBlb2YgJHtiYXNlVmFsdWVFeHByZXNzaW9ufSA9PT0gJ3N0cmluZydgICtcbiAgICAgIGA/ICR7YmFzZVZhbHVlRXhwcmVzc2lvbn0udHJpbSgpYCArXG4gICAgICBgOiAke2Jhc2VWYWx1ZUV4cHJlc3Npb259KWA7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IGBfbigke3ZhbHVlRXhwcmVzc2lvbn0pYDtcbiAgfVxuICBjb25zdCBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cbiAgZWwubW9kZWwgPSB7XG4gICAgdmFsdWU6IGAoJHt2YWx1ZX0pYCxcbiAgICBleHByZXNzaW9uOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksXG4gICAgY2FsbGJhY2s6IGBmdW5jdGlvbiAoJHtiYXNlVmFsdWVFeHByZXNzaW9ufSkgeyR7YXNzaWdubWVudH19YFxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgY29uc3QgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChyZXMua2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGAke3ZhbHVlfT0ke2Fzc2lnbm1lbnR9YFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHNldCgke3Jlcy5leHB9LCAke3Jlcy5rZXl9LCAke2Fzc2lnbm1lbnR9KWBcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cblxubGV0IGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG5mdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcbiAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICB2YWwgPSB2YWwudHJpbSgpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIGxldCBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgaW5CcmFja2V0Kys7XG4gICAgaWYgKGNociA9PT0gMHg1RCkgaW5CcmFja2V0LS07XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIGNvbnN0IHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxubGV0IHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbmNvbnN0IFJBTkdFX1RPS0VOID0gJ19fcic7XG5jb25zdCBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIGNvbnN0IHZhbHVlID0gZGlyLnZhbHVlO1xuICBjb25zdCBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICBjb25zdCB0YWcgPSBlbC50YWc7XG4gIGNvbnN0IHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIHtcbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGA8JHtlbC50YWd9IHYtbW9kZWw9XCIke3ZhbHVlfVwiIHR5cGU9XCJmaWxlXCI+OlxcbmAgK1xuICAgICAgICBgRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICB3YXJuJDEoXG4gICAgICBgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIj46IGAgK1xuICAgICAgYHYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gYCArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICk7XG4gIH1cblxuICAvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIGNvbnN0IHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIGNvbnN0IHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIGNvbnN0IGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBgQXJyYXkuaXNBcnJheSgke3ZhbHVlfSlgICtcbiAgICBgP19pKCR7dmFsdWV9LCR7dmFsdWVCaW5kaW5nfSk+LTFgICsgKFxuICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgID8gYDooJHt2YWx1ZX0pYFxuICAgICAgICA6IGA6X3EoJHt2YWx1ZX0sJHt0cnVlVmFsdWVCaW5kaW5nfSlgXG4gICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICBgdmFyICQkYT0ke3ZhbHVlfSxgICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgYCQkYz0kJGVsLmNoZWNrZWQ/KCR7dHJ1ZVZhbHVlQmluZGluZ30pOigke2ZhbHNlVmFsdWVCaW5kaW5nfSk7YCArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBgdmFyICQkdj0ke251bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nfSxgICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgYGlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJigke2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKX0pfWAgK1xuICAgICAgYGVsc2V7JCRpPi0xJiYoJHtnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpJyl9KX1gICtcbiAgICBgfWVsc2V7JHtnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpfX1gLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIGxldCB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyBgX24oJHt2YWx1ZUJpbmRpbmd9KWAgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgYF9xKCR7dmFsdWV9LCR7dmFsdWVCaW5kaW5nfSlgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICBjb25zdCBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgK1xuICAgIGAuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KWAgK1xuICAgIGAubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcIl92YWx1ZVwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7YCArXG4gICAgYHJldHVybiAke251bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnfX0pYDtcblxuICBjb25zdCBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIGxldCBjb2RlID0gYHZhciAkJHNlbGVjdGVkVmFsID0gJHtzZWxlY3RlZFZhbH07YDtcbiAgY29kZSA9IGAke2NvZGV9ICR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpfWA7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICBjb25zdCB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAge1xuICAgIGNvbnN0IHZhbHVlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcbiAgICBjb25zdCB0eXBlQmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh2YWx1ZSAmJiAhdHlwZUJpbmRpbmcpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgd2FybiQxKFxuICAgICAgICBgJHtiaW5kaW5nfT1cIiR7dmFsdWV9XCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IGAgK1xuICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwW2JpbmRpbmddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHsgbGF6eSwgbnVtYmVyLCB0cmltIH0gPSBtb2RpZmllcnMgfHwge307XG4gIGNvbnN0IG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgY29uc3QgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIGxldCB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gYCRldmVudC50YXJnZXQudmFsdWUudHJpbSgpYDtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gYF9uKCR7dmFsdWVFeHByZXNzaW9ufSlgO1xuICB9XG5cbiAgbGV0IGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IGBpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47JHtjb2RlfWA7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCBgKCR7dmFsdWV9KWApO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBjb25zdCBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbmxldCB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIkMSAoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgY29uc3QgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIGNvbnN0IHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuLy8gaW1wbGVtZW50YXRpb24gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzb1xuLy8gc2FmZSB0byBleGNsdWRlLlxuY29uc3QgdXNlTWljcm90YXNrRml4ID0gaXNVc2luZ01pY3JvVGFzayAmJiAhKGlzRkYgJiYgTnVtYmVyKGlzRkZbMV0pIDw9IDUzKTtcblxuZnVuY3Rpb24gYWRkJDEgKFxuICBuYW1lLFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xuICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXG4gIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgIGNvbnN0IGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgIGNvbnN0IG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gb3JpZ2luYWwuX3dyYXBwZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKFxuICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAvLyB0aGlzIGlzIGp1c3QgYSBzYWZldHkgbmV0IGluIGNhc2UgZXZlbnQudGltZVN0YW1wIGlzIHVucmVsaWFibGUgaW5cbiAgICAgICAgLy8gY2VydGFpbiB3ZWlyZCBlbnZpcm9ubWVudHMuLi5cbiAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAvLyBldmVudCBpcyBmaXJlZCBhZnRlciBoYW5kbGVyIGF0dGFjaG1lbnRcbiAgICAgICAgZS50aW1lU3RhbXAgPj0gYXR0YWNoZWRUaW1lc3RhbXAgfHxcbiAgICAgICAgLy8gIzk0NjIgYmFpbCBmb3IgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICBlLnRpbWVTdGFtcCA9PT0gMCB8fFxuICAgICAgICAvLyAjOTQ0OCBiYWlsIGlmIGV2ZW50IGlzIGZpcmVkIGluIGFub3RoZXIgZG9jdW1lbnQgaW4gYSBtdWx0aS1wYWdlXG4gICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gc3RhcnRpbmcgcmVmZXJlbmNlXG4gICAgICAgIGUudGFyZ2V0Lm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgbmFtZSxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmUsIHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgY29uc3Qgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbmxldCBzdmdDb250YWluZXI7XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBrZXksIGN1cjtcbiAgY29uc3QgZWxtID0gdm5vZGUuZWxtO1xuICBjb25zdCBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIGxldCBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pIGNvbnRpbnVlXG4gICAgICAvLyAjNjYwMSB3b3JrIGFyb3VuZCBDaHJvbWUgdmVyc2lvbiA8PSA1NSBidWcgd2hlcmUgc2luZ2xlIHRleHROb2RlXG4gICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxuICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNraXAgdGhlIHVwZGF0ZSBpZiBvbGQgYW5kIG5ldyBWRE9NIHN0YXRlIGlzIHRoZSBzYW1lLlxuICAgIC8vIHRoZSBvbmx5IGV4Y2VwdGlvbiBpcyBgdmFsdWVgIHdoZXJlIHRoZSBET00gdmFsdWUgbWF5IGJlIHRlbXBvcmFyaWx5XG4gICAgLy8gb3V0IG9mIHN5bmMgd2l0aCBWRE9NIHN0YXRlIGR1ZSB0byBmb2N1cywgY29tcG9zaXRpb24gYW5kIG1vZGlmaWVycy5cbiAgICAvLyBUaGlzIGFsc28gY292ZXJzICM0NTIxIGJ5IHNraXBwaW5nIHRoZSB1bm5lY2VzYXJyeSBgY2hlY2tlZGAgdXBkYXRlLlxuICAgIGlmIChrZXkgIT09ICd2YWx1ZScgJiYgY3VyID09PSBvbGRQcm9wc1trZXldKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScpIHtcbiAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICBjb25zdCBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJIVE1MIGZvciBTVkcgZWxlbWVudHNcbiAgICAgIHN2Z0NvbnRhaW5lciA9IHN2Z0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBgPHN2Zz4ke2N1cn08L3N2Zz5gO1xuICAgICAgY29uc3Qgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoZWxtLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xuICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICBsZXQgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICBjb25zdCB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgY29uc3QgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKGlzRGVmKG1vZGlmaWVycykpIHtcbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxuY29uc3QgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgY29uc3QgcmVzID0ge307XG4gIGNvbnN0IGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICBjb25zdCBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBjb25zdCB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICBjb25zdCBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgY29uc3QgcmVzID0ge307XG4gIGxldCBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICBsZXQgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIGxldCBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuY29uc3QgY3NzVmFyUkUgPSAvXi0tLztcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5jb25zdCBzZXRQcm9wID0gKGVsLCBuYW1lLCB2YWwpID0+IHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbmxldCBlbXB0eVN0eWxlO1xuY29uc3Qgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgY29uc3QgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gIGNvbnN0IG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgY3VyLCBuYW1lO1xuICBjb25zdCBlbCA9IHZub2RlLmVsbTtcbiAgY29uc3Qgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICBjb25zdCBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIGNvbnN0IG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIGNvbnN0IHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIGNvbnN0IG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG5jb25zdCB3aGl0ZXNwYWNlUkUgPSAvXFxzKy87XG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFKS5mb3JFYWNoKGMgPT4gZWwuY2xhc3NMaXN0LmFkZChjKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY3VyID0gYCAke2VsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJ30gYDtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChjID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgY3VyID0gYCAke2VsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJ30gYDtcbiAgICBjb25zdCB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgaWYgKGRlZiQkMS5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmJCQxKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxKVxuICB9XG59XG5cbmNvbnN0IGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKG5hbWUgPT4ge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IGAke25hbWV9LWVudGVyYCxcbiAgICBlbnRlclRvQ2xhc3M6IGAke25hbWV9LWVudGVyLXRvYCxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBgJHtuYW1lfS1lbnRlci1hY3RpdmVgLFxuICAgIGxlYXZlQ2xhc3M6IGAke25hbWV9LWxlYXZlYCxcbiAgICBsZWF2ZVRvQ2xhc3M6IGAke25hbWV9LWxlYXZlLXRvYCxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBgJHtuYW1lfS1sZWF2ZS1hY3RpdmVgXG4gIH1cbn0pO1xuXG5jb25zdCBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbmNvbnN0IFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG5jb25zdCBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xubGV0IHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xubGV0IHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbmxldCBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG5sZXQgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbmNvbnN0IHJhZiA9IGluQnJvd3NlclxuICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgOiBzZXRUaW1lb3V0XG4gIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZm4gPT4gZm4oKTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoKCkgPT4ge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgY29uc3QgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgaWYgKCF0eXBlKSByZXR1cm4gY2IoKVxuICBjb25zdCBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgbGV0IGVuZGVkID0gMDtcbiAgY29uc3QgZW5kID0gKCkgPT4ge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICBjb25zdCBvbkVuZCA9IGUgPT4ge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxuY29uc3QgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICBjb25zdCB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICBjb25zdCBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgbGV0IHR5cGU7XG4gIGxldCB0aW1lb3V0ID0gMDtcbiAgbGV0IHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICBjb25zdCBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIHRpbWVvdXQsXG4gICAgcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKChkLCBpKSA9PiB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyIG51bWJlcnNcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbi8vIElmIGNvbW1hIGlzIG5vdCByZXBsYWNlZCB3aXRoIGEgZG90LCB0aGUgaW5wdXQgd2lsbCBiZSByb3VuZGVkIGRvd24gKGkuZS4gYWN0aW5nXG4vLyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIGNvbnN0IGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICBjb25zdCBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCB7XG4gICAgY3NzLFxuICAgIHR5cGUsXG4gICAgZW50ZXJDbGFzcyxcbiAgICBlbnRlclRvQ2xhc3MsXG4gICAgZW50ZXJBY3RpdmVDbGFzcyxcbiAgICBhcHBlYXJDbGFzcyxcbiAgICBhcHBlYXJUb0NsYXNzLFxuICAgIGFwcGVhckFjdGl2ZUNsYXNzLFxuICAgIGJlZm9yZUVudGVyLFxuICAgIGVudGVyLFxuICAgIGFmdGVyRW50ZXIsXG4gICAgZW50ZXJDYW5jZWxsZWQsXG4gICAgYmVmb3JlQXBwZWFyLFxuICAgIGFwcGVhcixcbiAgICBhZnRlckFwcGVhcixcbiAgICBhcHBlYXJDYW5jZWxsZWQsXG4gICAgZHVyYXRpb25cbiAgfSA9IGRhdGE7XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIGxldCBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIGxldCB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgY29uc3QgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgY29uc3QgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIGNvbnN0IHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgY29uc3QgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgY29uc3QgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgY29uc3QgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICBjb25zdCBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIGNvbnN0IGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICBjb25zdCBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIGNvbnN0IHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgY29uc3QgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoKCkgPT4ge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICBjb25zdCBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICBjb25zdCBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCB7XG4gICAgY3NzLFxuICAgIHR5cGUsXG4gICAgbGVhdmVDbGFzcyxcbiAgICBsZWF2ZVRvQ2xhc3MsXG4gICAgbGVhdmVBY3RpdmVDbGFzcyxcbiAgICBiZWZvcmVMZWF2ZSxcbiAgICBsZWF2ZSxcbiAgICBhZnRlckxlYXZlLFxuICAgIGxlYXZlQ2FuY2VsbGVkLFxuICAgIGRlbGF5TGVhdmUsXG4gICAgZHVyYXRpb25cbiAgfSA9IGRhdGE7XG5cbiAgY29uc3QgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICBjb25zdCB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgY29uc3QgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgY29uc3QgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoKCkgPT4ge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgJHtuYW1lfSBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBgICtcbiAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBgPHRyYW5zaXRpb24+IGV4cGxpY2l0ICR7bmFtZX0gZHVyYXRpb24gaXMgTmFOIC0gYCArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGNvbnN0IGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmUgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbmNvbnN0IG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxuY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wcywgbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsICgpID0+IHtcbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgZGlyZWN0aXZlID0ge1xuICBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsICgpID0+IHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIGNvbnN0IHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgY29uc3QgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoKG8sIGkpID0+ICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgY29uc3QgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZSh2ID0+IGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucykpXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGNvbnN0IHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgYDxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cIiR7YmluZGluZy5leHByZXNzaW9ufVwiPiBgICtcbiAgICAgIGBleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke1xuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxuICAgICAgfWAsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAobGV0IGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmV2ZXJ5KG8gPT4gIWxvb3NlRXF1YWwobywgdmFsdWUpKVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgcmV0dXJuXG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuICB0cmlnZ2VyKGUudGFyZ2V0LCAnaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcbiAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZCAoZWwsIHsgdmFsdWUgfSwgdm5vZGUpIHtcbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIGNvbnN0IHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBjb25zdCBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuICAgIGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsICgpID0+IHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZSAoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSByZXR1cm5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIGNvbnN0IHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgKCkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsICgpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvd1xufTtcblxuLyogICovXG5cbmNvbnN0IHRyYW5zaXRpb25Qcm9wcyA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICBhcHBlYXI6IEJvb2xlYW4sXG4gIGNzczogQm9vbGVhbixcbiAgbW9kZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGVudGVyQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cbn07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCAodm5vZGUpIHtcbiAgY29uc3QgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgY29uc3QgZGF0YSA9IHt9O1xuICBjb25zdCBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgLy8gcHJvcHNcbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgY29uc3QgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSldID0gbGlzdGVuZXJzW2tleV07XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG4gIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcbiAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG5jb25zdCBpc05vdFRleHROb2RlID0gKGMpID0+IGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTtcblxuY29uc3QgaXNWU2hvd0RpcmVjdGl2ZSA9IGQgPT4gZC5uYW1lID09PSAnc2hvdyc7XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlciAoaCkge1xuICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihpc05vdFRleHROb2RlKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgY29uc3QgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIGNvbnN0IGlkID0gYF9fdHJhbnNpdGlvbi0ke3RoaXMuX3VpZH0tYDtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICBjb25zdCBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgY29uc3Qgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICBjb25zdCBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoaXNWU2hvd0RpcmVjdGl2ZSkpIHtcbiAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiYgb2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudClcbiAgICApIHtcbiAgICAgIC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxuICAgICAgY29uc3Qgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVsYXllZExlYXZlO1xuICAgICAgICBjb25zdCBwZXJmb3JtTGVhdmUgPSAoKSA9PiB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgbGVhdmUgPT4geyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG5jb25zdCBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzLFxuXG4gIGJlZm9yZU1vdW50ICgpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XG4gICAgdGhpcy5fdXBkYXRlID0gKHZub2RlLCBoeWRyYXRpbmcpID0+IHtcbiAgICAgIGNvbnN0IHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgICB0aGlzLmtlcHQsXG4gICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgICApO1xuICAgICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgIHVwZGF0ZS5jYWxsKHRoaXMsIHZub2RlLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyIChoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIGNvbnN0IHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICBjb25zdCB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICBjb25zdCBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oYDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8JHtuYW1lfT5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIGNvbnN0IGtlcHQgPSBbXTtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmV2Q2hpbGRyZW5baV07XG4gICAgICAgIGMuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMuZGF0YS5wb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgdXBkYXRlZCAoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICBjb25zdCBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICBjb25zdCBlbCA9IGMuZWxtO1xuICAgICAgICBjb25zdCBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goKGNscykgPT4geyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICBjb25zdCBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIGNvbnN0IG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIGNvbnN0IG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICBjb25zdCBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtkeH1weCwke2R5fXB4KWA7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgYFlvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5gICtcbiAgICAgICAgYE1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5gICtcbiAgICAgICAgYFNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sYFxuICAgICAgKTtcbiAgICB9XG4gIH0sIDApO1xufVxuXG4vKiAgKi9cblxuY29uc3QgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxccj9cXG4pKz8pXFx9XFx9L2c7XG5jb25zdCByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxuY29uc3QgYnVpbGRSZWdleCA9IGNhY2hlZChkZWxpbWl0ZXJzID0+IHtcbiAgY29uc3Qgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIGNvbnN0IGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgdGV4dCxcbiAgZGVsaW1pdGVyc1xuKSB7XG4gIGNvbnN0IHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCByYXdUb2tlbnMgPSBbXTtcbiAgbGV0IGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIGxldCBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSk7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIGNvbnN0IGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKGBfcygke2V4cH0pYCk7XG4gICAgcmF3VG9rZW5zLnB1c2goeyAnQGJpbmRpbmcnOiBleHAgfSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4KSk7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICB0b2tlbnM6IHJhd1Rva2Vuc1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBjb25zdCB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICBjb25zdCBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBjb25zdCByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgaWYgKHJlcykge1xuICAgICAgd2FybihcbiAgICAgICAgYGNsYXNzPVwiJHtzdGF0aWNDbGFzc31cIjogYCArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICBjb25zdCBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICBsZXQgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IGBzdGF0aWNDbGFzczoke2VsLnN0YXRpY0NsYXNzfSxgO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IGBjbGFzczoke2VsLmNsYXNzQmluZGluZ30sYDtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuICBjb25zdCB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICBjb25zdCBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICBjb25zdCByZXMgPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYHN0eWxlPVwiJHtzdGF0aWNTdHlsZX1cIjogYCArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LicsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3N0eWxlJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgY29uc3Qgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICBsZXQgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IGBzdGF0aWNTdHlsZToke2VsLnN0YXRpY1N0eWxlfSxgO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IGBzdHlsZTooJHtlbC5zdHlsZUJpbmRpbmd9KSxgO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59O1xuXG4vKiAgKi9cblxubGV0IGRlY29kZXI7XG5cbnZhciBoZSA9IHtcbiAgZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG5jb25zdCBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbmNvbnN0IGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuY29uc3QgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbmNvbnN0IGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xuY29uc3QgZHluYW1pY0FyZ0F0dHJpYnV0ZSA9IC9eXFxzKigoPzp2LVtcXHctXSs6fEB8OnwjKVxcW1tePV0rXFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbmNvbnN0IG5jbmFtZSA9IGBbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVoke3VuaWNvZGVMZXR0ZXJzfV0qYDtcbmNvbnN0IHFuYW1lQ2FwdHVyZSA9IGAoKD86JHtuY25hbWV9XFxcXDopPyR7bmNuYW1lfSlgO1xuY29uc3Qgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cChgXjwke3FuYW1lQ2FwdHVyZX1gKTtcbmNvbnN0IHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbmNvbnN0IGVuZFRhZyA9IG5ldyBSZWdFeHAoYF48XFxcXC8ke3FuYW1lQ2FwdHVyZX1bXj5dKj5gKTtcbmNvbnN0IGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNlZCBhcyBIVE1MIGNvbW1lbnQgd2hlbiBpbmxpbmVkIGluIHBhZ2VcbmNvbnN0IGNvbW1lbnQgPSAvXjwhXFwtLS87XG5jb25zdCBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG5jb25zdCBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbmNvbnN0IHJlQ2FjaGUgPSB7fTtcblxuY29uc3QgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCcsXG4gICcmIzM5Oyc6IFwiJ1wiXG59O1xuY29uc3QgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOSk7L2c7XG5jb25zdCBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5fCMxMHwjOSk7L2c7XG5cbi8vICM1OTkyXG5jb25zdCBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbmNvbnN0IHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9ICh0YWcsIGh0bWwpID0+IHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJztcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIGNvbnN0IHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgbWF0Y2ggPT4gZGVjb2RpbmdNYXBbbWF0Y2hdKVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgY29uc3QgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgY29uc3QgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgY29uc3QgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgbGV0IHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICBjb25zdCBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSwgaW5kZXgsIGluZGV4ICsgY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICBjb25zdCBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIGNvbnN0IGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICBjb25zdCBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgY29uc3QgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgY29uc3Qgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YXJ0VGFnTWF0Y2gudGFnTmFtZSwgaHRtbCkpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHRleHQsIHJlc3QsIG5leHQ7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIGJyZWFrXG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICBjb25zdCBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICBjb25zdCByZXN0ID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0Lmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0O1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xuICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgaWYgKCFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybihgTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcIiR7aHRtbH1cImAsIHsgc3RhcnQ6IGluZGV4ICsgaHRtbC5sZW5ndGggfSk7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICBwYXJzZUVuZFRhZygpO1xuXG4gIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICBpbmRleCArPSBuO1xuICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIGxldCBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICBhdHRyLnN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgY29uc3QgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgY29uc3QgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgY29uc3QgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICBjb25zdCBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIGNvbnN0IHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBhcmdzLnN0YXJ0ICsgYXJnc1swXS5tYXRjaCgvXlxccyovKS5sZW5ndGg7XG4gICAgICAgIGF0dHJzW2ldLmVuZCA9IGFyZ3MuZW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzLCBzdGFydDogbWF0Y2guc3RhcnQsIGVuZDogbWF0Y2guZW5kIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIGxldCBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSBzdGFydCA9IGluZGV4O1xuICAgIGlmIChlbmQgPT0gbnVsbCkgZW5kID0gaW5kZXg7XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAoaSA+IHBvcyB8fCAhdGFnTmFtZSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICBgdGFnIDwke3N0YWNrW2ldLnRhZ30+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLmAsXG4gICAgICAgICAgICB7IHN0YXJ0OiBzdGFja1tpXS5zdGFydCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBvblJFID0gL15AfF52LW9uOi87XG5jb25zdCBkaXJSRSA9IC9edi18XkB8XjovO1xuY29uc3QgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbmNvbnN0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG5jb25zdCBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuY29uc3QgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuXG5jb25zdCBhcmdSRSA9IC86KC4qKSQvO1xuY29uc3QgYmluZFJFID0gL146fF5cXC58XnYtYmluZDovO1xuY29uc3QgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG5jb25zdCBzbG90UkUgPSAvXnYtc2xvdCg6fCQpfF4jLztcblxuY29uc3QgbGluZUJyZWFrUkUgPSAvW1xcclxcbl0vO1xuY29uc3Qgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy9nO1xuXG5jb25zdCBpbnZhbGlkQXR0cmlidXRlUkUgPSAvW1xcc1wiJzw+XFwvPV0vO1xuXG5jb25zdCBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbmNvbnN0IGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBgX2VtcHR5X2A7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxubGV0IHdhcm4kMjtcbmxldCBkZWxpbWl0ZXJzO1xubGV0IHRyYW5zZm9ybXM7XG5sZXQgcHJlVHJhbnNmb3JtcztcbmxldCBwb3N0VHJhbnNmb3JtcztcbmxldCBwbGF0Zm9ybUlzUHJlVGFnO1xubGV0IHBsYXRmb3JtTXVzdFVzZVByb3A7XG5sZXQgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5sZXQgbWF5YmVDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICB0YWcsXG4gIGF0dHJzLFxuICBwYXJlbnRcbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDEsXG4gICAgdGFnLFxuICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgcmF3QXR0cnNNYXA6IHt9LFxuICAgIHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcbiAgY29uc3QgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgbWF5YmVDb21wb25lbnQgPSAoZWwpID0+ICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7XG5cbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgY29uc3QgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICBjb25zdCB3aGl0ZXNwYWNlT3B0aW9uID0gb3B0aW9ucy53aGl0ZXNwYWNlO1xuICBsZXQgcm9vdDtcbiAgbGV0IGN1cnJlbnRQYXJlbnQ7XG4gIGxldCBpblZQcmUgPSBmYWxzZTtcbiAgbGV0IGluUHJlID0gZmFsc2U7XG4gIGxldCB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnLCByYW5nZSkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZywgcmFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb3NlRWxlbWVudCAoZWxlbWVudCkge1xuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuICAgIGlmICghaW5WUHJlICYmICFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgZWxlbWVudCA9IHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBlbGVtZW50ICE9PSByb290KSB7XG4gICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICBibG9jazogZWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIGBDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBgICtcbiAgICAgICAgICBgSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBgICtcbiAgICAgICAgICBgdXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuYCxcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cbiAgICAgICAgICBjb25zdCBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIidcbiAgICAgICAgICA7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaW5hbCBjaGlsZHJlbiBjbGVhbnVwXG4gICAgLy8gZmlsdGVyIG91dCBzY29wZWQgc2xvdHNcbiAgICBlbGVtZW50LmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbi5maWx0ZXIoYyA9PiAhKGMpLnNsb3RTY29wZSk7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZSBhZ2FpblxuICAgIHRyaW1FbmRpbmdXaGl0ZXNwYWNlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlXG4gICAgaWYgKCFpblByZSkge1xuICAgICAgbGV0IGxhc3ROb2RlO1xuICAgICAgd2hpbGUgKFxuICAgICAgICAobGFzdE5vZGUgPSBlbC5jaGlsZHJlbltlbC5jaGlsZHJlbi5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICBsYXN0Tm9kZS50ZXh0ID09PSAnICdcbiAgICAgICkge1xuICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgYENhbm5vdCB1c2UgPCR7ZWwudGFnfT4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBgICtcbiAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJyxcbiAgICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICBvdXRwdXRTb3VyY2VSYW5nZTogb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSxcbiAgICBzdGFydCAodGFnLCBhdHRycywgdW5hcnksIHN0YXJ0KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIGNvbnN0IG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgZWxlbWVudC5yYXdBdHRyc01hcCA9IGVsZW1lbnQuYXR0cnNMaXN0LnJlZHVjZSgoY3VtdWxhdGVkLCBhdHRyKSA9PiB7XG4gICAgICAgICAgICBjdW11bGF0ZWRbYXR0ci5uYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICByZXR1cm4gY3VtdWxhdGVkXG4gICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgaWYgKGludmFsaWRBdHRyaWJ1dGVSRS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgYEludmFsaWQgZHluYW1pYyBhcmd1bWVudCBleHByZXNzaW9uOiBhdHRyaWJ1dGUgbmFtZXMgY2Fubm90IGNvbnRhaW4gYCArXG4gICAgICAgICAgICAgIGBzcGFjZXMsIHF1b3RlcywgPCwgPiwgLyBvciA9LmAsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5pbmRleE9mKGBbYCksXG4gICAgICAgICAgICAgICAgZW5kOiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmxlbmd0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgYDwke3RhZ30+YCArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLicsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZCAodGFnLCBzdGFydCwgZW5kKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQ7XG4gICAgICB9XG4gICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nLFxuICAgICAgICAgICAgICB7IHN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIGB0ZXh0IFwiJHt0ZXh0fVwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5gLFxuICAgICAgICAgICAgICB7IHN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgIGlmIChpblByZSB8fCB0ZXh0LnRyaW0oKSkge1xuICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlLW9ubHkgbm9kZSByaWdodCBhZnRlciBhbiBvcGVuaW5nIHRhZ1xuICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBpbiBjb25kZW5zZSBtb2RlLCByZW1vdmUgdGhlIHdoaXRlc3BhY2Ugbm9kZSBpZiBpdCBjb250YWluc1xuICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAvLyBjb25kZW5zZSBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlcyBpbnRvIHNpbmdsZSBzcGFjZVxuICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2Uod2hpdGVzcGFjZVJFJDEsICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgbGV0IGNoaWxkO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiByZXMuZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRva2VuczogcmVzLnRva2VucyxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudCAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgLy8gYWRkaW5nIGFueXRpbmcgYXMgYSBzaWJsaW5nIHRvIHRoZSByb290IG5vZGUgaXMgZm9yYmlkZGVuXG4gICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcbiAgICAgIGlmIChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0ge1xuICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGNvbnN0IGxlbiA9IGxpc3QubGVuZ3RoO1xuICBpZiAobGVuKSB7XG4gICAgY29uc3QgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShsaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0W2ldLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBsaXN0W2ldLnN0YXJ0O1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKFxuICBlbGVtZW50LFxuICBvcHRpb25zXG4pIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAhZWxlbWVudC5rZXkgJiZcbiAgICAhZWxlbWVudC5zY29wZWRTbG90cyAmJlxuICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgKTtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgY29uc3QgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIGA8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuYCxcbiAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZWwuZm9yKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gZWwuaXRlcmF0b3IyIHx8IGVsLml0ZXJhdG9yMTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICBpZiAoaXRlcmF0b3IgJiYgaXRlcmF0b3IgPT09IGV4cCAmJiBwYXJlbnQgJiYgcGFyZW50LnRhZyA9PT0gJ3RyYW5zaXRpb24tZ3JvdXAnKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgYERvIG5vdCB1c2Ugdi1mb3IgaW5kZXggYXMga2V5IG9uIDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiwgYCArXG4gICAgICAgICAgICBgdGhpcyBpcyB0aGUgc2FtZSBhcyBub3QgdXNpbmcga2V5cy5gLFxuICAgICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKSxcbiAgICAgICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgY29uc3QgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIGxldCBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgY29uc3QgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYEludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogJHtleHB9YCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cblxuXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XG4gIGNvbnN0IGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gIGlmICghaW5NYXRjaCkgcmV0dXJuXG4gIGNvbnN0IHJlcyA9IHt9O1xuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIGNvbnN0IGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gIGNvbnN0IGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XG4gICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICBjb25zdCBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICBjb25zdCBwcmV2ID0gZmluZFByZXZFbGVtZW50KHBhcmVudC5jaGlsZHJlbik7XG4gIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICBleHA6IGVsLmVsc2VpZixcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHdhcm4kMihcbiAgICAgIGB2LSR7ZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnfSBgICtcbiAgICAgIGB1c2VkIG9uIGVsZW1lbnQgPCR7ZWwudGFnfT4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuYCxcbiAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBgdGV4dCBcIiR7Y2hpbGRyZW5baV0udGV4dC50cmltKCl9XCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBgICtcbiAgICAgICAgICBgd2lsbCBiZSBpZ25vcmVkLmAsXG4gICAgICAgICAgY2hpbGRyZW5baV1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICBjb25zdCBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXG4vLyBlLmcuIDx0ZW1wbGF0ZSBzbG90PVwieHh4XCI+LCA8ZGl2IHNsb3Qtc2NvcGU9XCJ4eHhcIj5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgbGV0IHNsb3RTY29wZTtcbiAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChzbG90U2NvcGUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYHRoZSBcInNjb3BlXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIGAgK1xuICAgICAgICBgcmVwbGFjZWQgYnkgXCJzbG90LXNjb3BlXCIgc2luY2UgMi41LiBUaGUgbmV3IFwic2xvdC1zY29wZVwiIGF0dHJpYnV0ZSBgICtcbiAgICAgICAgYGNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBgICtcbiAgICAgICAgYGRlbm90ZSBzY29wZWQgc2xvdHMuYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICB9IGVsc2UgaWYgKChzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpKSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBgQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDwke2VsLnRhZ30+IGAgK1xuICAgICAgICBgKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIGAgK1xuICAgICAgICBgc2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLmAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcbiAgfVxuXG4gIC8vIHNsb3Q9XCJ4eHhcIlxuICBjb25zdCBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0LCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gMi42IHYtc2xvdCBzeW50YXhcbiAge1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIC8vIHYtc2xvdCBvbiA8dGVtcGxhdGU+XG4gICAgICBjb25zdCBzbG90QmluZGluZyA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgaWYgKHNsb3RCaW5kaW5nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgYFVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuYCxcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5wYXJlbnQgJiYgIW1heWJlQ29tcG9uZW50KGVsLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgYDx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgYCArXG4gICAgICAgICAgICAgIGB0aGUgcmVjZWl2aW5nIHRoZSBjb21wb25lbnRgLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBuYW1lLCBkeW5hbWljIH0gPSBnZXRTbG90TmFtZShzbG90QmluZGluZyk7XG4gICAgICAgIGVsLnNsb3RUYXJnZXQgPSBuYW1lO1xuICAgICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgY29uc3Qgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFtYXliZUNvbXBvbmVudChlbCkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgYHYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5gLFxuICAgICAgICAgICAgICBzbG90QmluZGluZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLmAsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgYFRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgYCArXG4gICAgICAgICAgICAgIGA8dGVtcGxhdGU+IHN5bnRheCB3aGVuIHRoZXJlIGFyZSBvdGhlciBuYW1lZCBzbG90cy5gLFxuICAgICAgICAgICAgICBzbG90QmluZGluZ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHRoZSBjb21wb25lbnQncyBjaGlsZHJlbiB0byBpdHMgZGVmYXVsdCBzbG90XG4gICAgICAgIGNvbnN0IHNsb3RzID0gZWwuc2NvcGVkU2xvdHMgfHwgKGVsLnNjb3BlZFNsb3RzID0ge30pO1xuICAgICAgICBjb25zdCB7IG5hbWUsIGR5bmFtaWMgfSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgY29uc3Qgc2xvdENvbnRhaW5lciA9IHNsb3RzW25hbWVdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXQgPSBuYW1lO1xuICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcbiAgICAgICAgc2xvdENvbnRhaW5lci5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmZpbHRlcigoYykgPT4ge1xuICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIGMucGFyZW50ID0gc2xvdENvbnRhaW5lcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuO1xuICAgICAgICAvLyByZW1vdmUgY2hpbGRyZW4gYXMgdGhleSBhcmUgcmV0dXJuZWQgZnJvbSBzY29wZWRTbG90cyBub3dcbiAgICAgICAgZWwuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgLy8gbWFyayBlbCBub24tcGxhaW4gc28gZGF0YSBnZXRzIGdlbmVyYXRlZFxuICAgICAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTbG90TmFtZSAoYmluZGluZykge1xuICBsZXQgbmFtZSA9IGJpbmRpbmcubmFtZS5yZXBsYWNlKHNsb3RSRSwgJycpO1xuICBpZiAoIW5hbWUpIHtcbiAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcbiAgICAgIG5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYHYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLmAsXG4gICAgICAgIGJpbmRpbmdcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkeW5hbWljQXJnUkUudGVzdChuYW1lKVxuICAgIC8vIGR5bmFtaWMgW25hbWVdXG4gICAgPyB7IG5hbWU6IG5hbWUuc2xpY2UoMSwgLTEpLCBkeW5hbWljOiB0cnVlIH1cbiAgICAvLyBzdGF0aWMgbmFtZVxuICAgIDogeyBuYW1lOiBgXCIke25hbWV9XCJgLCBkeW5hbWljOiBmYWxzZSB9XG59XG5cbi8vIGhhbmRsZSA8c2xvdC8+IG91dGxldHNcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChlbC5rZXkpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYFxcYGtleVxcYCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIGAgK1xuICAgICAgICBgYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gYCArXG4gICAgICAgIGBVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5gLFxuICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICBsZXQgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgY29uc3QgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgbGV0IGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XG4gICAgICAvLyBzdXBwb3J0IC5mb28gc2hvcnRoYW5kIHN5bnRheCBmb3IgdGhlIC5wcm9wIG1vZGlmaWVyXG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIGBUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcInYtYmluZDoke25hbWV9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgbmFtZSA9ICdpbm5lckhUTUwnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBzeW5jR2VuID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGAkZXZlbnRgKTtcbiAgICAgICAgICAgIGlmICghaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgYHVwZGF0ZToke2NhbWVsaXplKG5hbWUpfWAsXG4gICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChoeXBoZW5hdGUobmFtZSkgIT09IGNhbWVsaXplKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgYHVwZGF0ZToke2h5cGhlbmF0ZShuYW1lKX1gLFxuICAgICAgICAgICAgICAgICAgc3luY0dlbixcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHdhcm4kMixcbiAgICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBoYW5kbGVyIHcvIGR5bmFtaWMgZXZlbnQgbmFtZVxuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGBcInVwZGF0ZTpcIisoJHtuYW1lfSlgLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXSxcbiAgICAgICAgICAgICAgICB0cnVlIC8vIGR5bmFtaWNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByb3ApIHx8IChcbiAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxuICAgICAgICApKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICBjb25zdCBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuICAgICAgICBsZXQgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG4gICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XG4gICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWMsIG1vZGlmaWVycywgbGlzdFtpXSk7XG4gICAgICAgIGlmIChuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIHtcbiAgICAgICAgY29uc3QgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIGAke25hbWV9PVwiJHt2YWx1ZX1cIjogYCArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LicsXG4gICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBsaXN0W2ldKTtcbiAgICAgIC8vICM2ODg3IGZpcmVmb3ggZG9lc24ndCB1cGRhdGUgbXV0ZWQgc3RhdGUgaWYgc2V0IHZpYSBhdHRyaWJ1dGVcbiAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiZcbiAgICAgICAgICBuYW1lID09PSAnbXV0ZWQnICYmXG4gICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgIGFkZFByb3AoZWwsIG5hbWUsICd0cnVlJywgbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIGxldCBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIGNvbnN0IG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChtID0+IHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgY29uc3QgbWFwID0ge307XG4gIGZvciAobGV0IGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxuY29uc3QgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbmNvbnN0IGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgbGV0IF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIj46IGAgK1xuICAgICAgICBgWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIGAgK1xuICAgICAgICBgVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgYCArXG4gICAgICAgIGB3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBgICtcbiAgICAgICAgYENvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLmAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICBjb25zdCBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICBpZiAoIW1hcFsndi1tb2RlbCddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgdHlwZUJpbmRpbmc7XG4gICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgfVxuICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gYCgke21hcFsndi1iaW5kJ119KS50eXBlYDtcbiAgICB9XG5cbiAgICBpZiAodHlwZUJpbmRpbmcpIHtcbiAgICAgIGNvbnN0IGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgIGNvbnN0IGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IGAmJigke2lmQ29uZGl0aW9ufSlgIDogYGA7XG4gICAgICBjb25zdCBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XG4gICAgICBjb25zdCBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgY29uc3QgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAvLyBwcm9jZXNzIGZvciBvbiB0aGUgbWFpbiBub2RlXG4gICAgICBwcm9jZXNzRm9yKGJyYW5jaDApO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMCwgb3B0aW9ucyk7XG4gICAgICBicmFuY2gwLnByb2Nlc3NlZCA9IHRydWU7IC8vIHByZXZlbnQgaXQgZnJvbSBkb3VibGUtcHJvY2Vzc2VkXG4gICAgICBicmFuY2gwLmlmID0gYCgke3R5cGVCaW5kaW5nfSk9PT0nY2hlY2tib3gnYCArIGlmQ29uZGl0aW9uRXh0cmE7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogYnJhbmNoMC5pZixcbiAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgIH0pO1xuICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXG4gICAgICBjb25zdCBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBgKCR7dHlwZUJpbmRpbmd9KT09PSdyYWRpbydgICsgaWZDb25kaXRpb25FeHRyYSxcbiAgICAgICAgYmxvY2s6IGJyYW5jaDFcbiAgICAgIH0pO1xuICAgICAgLy8gMy4gb3RoZXJcbiAgICAgIGNvbnN0IGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCBgX3MoJHtkaXIudmFsdWV9KWAsIGRpcik7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICdpbm5lckhUTUwnLCBgX3MoJHtkaXIudmFsdWV9KWAsIGRpcik7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWwsXG4gIHRleHQsXG4gIGh0bWxcbn07XG5cbi8qICAqL1xuXG5jb25zdCBiYXNlT3B0aW9ucyA9IHtcbiAgZXhwZWN0SFRNTDogdHJ1ZSxcbiAgbW9kdWxlczogbW9kdWxlcyQxLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbi8qICAqL1xuXG5sZXQgaXNTdGF0aWNLZXk7XG5sZXQgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG5jb25zdCBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgcmV0dXJuXG4gIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG4gIG1hcmtTdGF0aWMkMShyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yIChsZXQgaSA9IDEsIGwgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yIChsZXQgaSA9IDEsIGwgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2ldLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbmNvbnN0IGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xuY29uc3QgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xuY29uc3Qgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcbmNvbnN0IGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gS2V5Ym9hcmRFdmVudC5rZXkgYWxpYXNlc1xuY29uc3Qga2V5TmFtZXMgPSB7XG4gIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICBlc2M6IFsnRXNjJywgJ0VzY2FwZSddLFxuICB0YWI6ICdUYWInLFxuICBlbnRlcjogJ0VudGVyJyxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgU3BhY2ViYXJgIGZvciBTcGFjZSBrZXkgbmFtZS5cbiAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbmNvbnN0IGdlbkd1YXJkID0gY29uZGl0aW9uID0+IGBpZigke2NvbmRpdGlvbn0pcmV0dXJuIG51bGw7YDtcblxuY29uc3QgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChgJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRgKSxcbiAgY3RybDogZ2VuR3VhcmQoYCEkZXZlbnQuY3RybEtleWApLFxuICBzaGlmdDogZ2VuR3VhcmQoYCEkZXZlbnQuc2hpZnRLZXlgKSxcbiAgYWx0OiBnZW5HdWFyZChgISRldmVudC5hbHRLZXlgKSxcbiAgbWV0YTogZ2VuR3VhcmQoYCEkZXZlbnQubWV0YUtleWApLFxuICBsZWZ0OiBnZW5HdWFyZChgJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDBgKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChgJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFgKSxcbiAgcmlnaHQ6IGdlbkd1YXJkKGAnYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMmApXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gIGV2ZW50cyxcbiAgaXNOYXRpdmVcbikge1xuICBjb25zdCBwcmVmaXggPSBpc05hdGl2ZSA/ICduYXRpdmVPbjonIDogJ29uOic7XG4gIGxldCBzdGF0aWNIYW5kbGVycyA9IGBgO1xuICBsZXQgZHluYW1pY0hhbmRsZXJzID0gYGA7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBldmVudHMpIHtcbiAgICBjb25zdCBoYW5kbGVyQ29kZSA9IGdlbkhhbmRsZXIoZXZlbnRzW25hbWVdKTtcbiAgICBpZiAoZXZlbnRzW25hbWVdICYmIGV2ZW50c1tuYW1lXS5keW5hbWljKSB7XG4gICAgICBkeW5hbWljSGFuZGxlcnMgKz0gYCR7bmFtZX0sJHtoYW5kbGVyQ29kZX0sYDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGljSGFuZGxlcnMgKz0gYFwiJHtuYW1lfVwiOiR7aGFuZGxlckNvZGV9LGA7XG4gICAgfVxuICB9XG4gIHN0YXRpY0hhbmRsZXJzID0gYHske3N0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKX19YDtcbiAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgIHJldHVybiBwcmVmaXggKyBgX2QoJHtzdGF0aWNIYW5kbGVyc30sWyR7ZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKX1dKWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gYFske2hhbmRsZXIubWFwKGhhbmRsZXIgPT4gZ2VuSGFuZGxlcihoYW5kbGVyKSkuam9pbignLCcpfV1gXG4gIH1cblxuICBjb25zdCBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgY29uc3QgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIGNvbnN0IGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIHJldHVybiBgZnVuY3Rpb24oJGV2ZW50KXske1xuICAgICAgaXNGdW5jdGlvbkludm9jYXRpb24gPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX1gIDogaGFuZGxlci52YWx1ZVxuICAgIH19YCAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgbGV0IGNvZGUgPSAnJztcbiAgICBsZXQgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xuICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXVxuICAgICAgICAgICAgLmZpbHRlcihrZXlNb2RpZmllciA9PiAhbW9kaWZpZXJzW2tleU1vZGlmaWVyXSlcbiAgICAgICAgICAgIC5tYXAoa2V5TW9kaWZpZXIgPT4gYCRldmVudC4ke2tleU1vZGlmaWVyfUtleWApXG4gICAgICAgICAgICAuam9pbignfHwnKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IGByZXR1cm4gJHtoYW5kbGVyLnZhbHVlfSgkZXZlbnQpYFxuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IGByZXR1cm4gKCR7aGFuZGxlci52YWx1ZX0pKCRldmVudClgXG4gICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cbiAgICAgICAgICA/IGByZXR1cm4gJHtoYW5kbGVyLnZhbHVlfWBcbiAgICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgcmV0dXJuIGBmdW5jdGlvbigkZXZlbnQpeyR7Y29kZX0ke2hhbmRsZXJDb2RlfX1gXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBrZXkgZmlsdGVycyBvbmx5IGFwcGx5IHRvIEtleWJvYXJkRXZlbnRzXG4gICAgLy8gIzk0NDE6IGNhbid0IHVzZSAna2V5Q29kZScgaW4gJGV2ZW50IGJlY2F1c2UgQ2hyb21lIGF1dG9maWxsIGZpcmVzIGZha2VcbiAgICAvLyBrZXkgZXZlbnRzIHRoYXQgZG8gbm90IGhhdmUga2V5Q29kZSBwcm9wZXJ0eS4uLlxuICAgIGBpZighJGV2ZW50LnR5cGUuaW5kZXhPZigna2V5JykmJmAgK1xuICAgIGAke2tleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJyl9KXJldHVybiBudWxsO2BcbiAgKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgY29uc3Qga2V5VmFsID0gcGFyc2VJbnQoa2V5LCAxMCk7XG4gIGlmIChrZXlWYWwpIHtcbiAgICByZXR1cm4gYCRldmVudC5rZXlDb2RlIT09JHtrZXlWYWx9YFxuICB9XG4gIGNvbnN0IGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICBjb25zdCBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgcmV0dXJuIChcbiAgICBgX2soJGV2ZW50LmtleUNvZGUsYCArXG4gICAgYCR7SlNPTi5zdHJpbmdpZnkoa2V5KX0sYCArXG4gICAgYCR7SlNPTi5zdHJpbmdpZnkoa2V5Q29kZSl9LGAgK1xuICAgIGAkZXZlbnQua2V5LGAgK1xuICAgIGAke0pTT04uc3RyaW5naWZ5KGtleU5hbWUpfWAgK1xuICAgIGApYFxuICApXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICBpZiAoZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oYHYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5gKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gKGNvZGUpID0+IGBfZygke2NvZGV9LCR7ZGlyLnZhbHVlfSlgO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gKGNvZGUpID0+IHtcbiAgICByZXR1cm4gYF9iKCR7Y29kZX0sJyR7ZWwudGFnfScsJHtkaXIudmFsdWV9LCR7XG4gICAgICBkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZSdcbiAgICB9JHtcbiAgICAgIGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnXG4gICAgfSlgXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59O1xuXG4vKiAgKi9cblxuXG5cblxuXG5jbGFzcyBDb2RlZ2VuU3RhdGUge1xuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuXG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gICAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gICAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gICAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICAgIGNvbnN0IGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gICAgdGhpcy5tYXliZUNvbXBvbmVudCA9IChlbCkgPT4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTtcbiAgICB0aGlzLm9uY2VJZCA9IDA7XG4gICAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbiAgICB0aGlzLnByZSA9IGZhbHNlO1xuICB9XG59XG5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIGNvbnN0IHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgY29uc3QgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogYHdpdGgodGhpcyl7cmV0dXJuICR7Y29kZX19YCxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICBpZiAoZWwucGFyZW50KSB7XG4gICAgZWwucHJlID0gZWwucHJlIHx8IGVsLnBhcmVudC5wcmU7XG4gIH1cblxuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0ICYmICFzdGF0ZS5wcmUpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgbGV0IGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkYXRhO1xuICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSkpIHtcbiAgICAgICAgZGF0YSA9IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICBjb2RlID0gYF9jKCcke2VsLnRhZ30nJHtcbiAgICAgICAgZGF0YSA/IGAsJHtkYXRhfWAgOiAnJyAvLyBkYXRhXG4gICAgICB9JHtcbiAgICAgICAgY2hpbGRyZW4gPyBgLCR7Y2hpbGRyZW59YCA6ICcnIC8vIGNoaWxkcmVuXG4gICAgICB9KWA7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cbiAgY29uc3Qgb3JpZ2luYWxQcmVTdGF0ZSA9IHN0YXRlLnByZTtcbiAgaWYgKGVsLnByZSkge1xuICAgIHN0YXRlLnByZSA9IGVsLnByZTtcbiAgfVxuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaChgd2l0aCh0aGlzKXtyZXR1cm4gJHtnZW5FbGVtZW50KGVsLCBzdGF0ZSl9fWApO1xuICBzdGF0ZS5wcmUgPSBvcmlnaW5hbFByZVN0YXRlO1xuICByZXR1cm4gYF9tKCR7XG4gICAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDFcbiAgfSR7XG4gICAgZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJydcbiAgfSlgXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIGxldCBrZXkgPSAnJztcbiAgICBsZXQgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgc3RhdGUud2FybihcbiAgICAgICAgYHYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBgLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1vbmNlJ11cbiAgICAgICk7XG4gICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfVxuICAgIHJldHVybiBgX28oJHtnZW5FbGVtZW50KGVsLCBzdGF0ZSl9LCR7c3RhdGUub25jZUlkKyt9LCR7a2V5fSlgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgY29uc3QgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICBpZiAoY29uZGl0aW9uLmV4cCkge1xuICAgIHJldHVybiBgKCR7Y29uZGl0aW9uLmV4cH0pPyR7XG4gICAgICBnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaylcbiAgICB9OiR7XG4gICAgICBnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG4gICAgfWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7Z2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spfWBcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgY29uc3QgZXhwID0gZWwuZm9yO1xuICBjb25zdCBhbGlhcyA9IGVsLmFsaWFzO1xuICBjb25zdCBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyBgLCR7ZWwuaXRlcmF0b3IxfWAgOiAnJztcbiAgY29uc3QgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gYCwke2VsLml0ZXJhdG9yMn1gIDogJyc7XG5cbiAgaWYgKHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgYDwke2VsLnRhZ30gdi1mb3I9XCIke2FsaWFzfSBpbiAke2V4cH1cIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIGAgK1xuICAgICAgYHYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIGAgK1xuICAgICAgYFNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uYCxcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddLFxuICAgICAgdHJ1ZSAvKiB0aXAgKi9cbiAgICApO1xuICB9XG5cbiAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBgJHthbHRIZWxwZXIgfHwgJ19sJ30oKCR7ZXhwfSksYCArXG4gICAgYGZ1bmN0aW9uKCR7YWxpYXN9JHtpdGVyYXRvcjF9JHtpdGVyYXRvcjJ9KXtgICtcbiAgICAgIGByZXR1cm4gJHsoYWx0R2VuIHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSl9YCArXG4gICAgJ30pJ1xufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDIgKGVsLCBzdGF0ZSkge1xuICBsZXQgZGF0YSA9ICd7JztcblxuICAvLyBkaXJlY3RpdmVzIGZpcnN0LlxuICAvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuICBjb25zdCBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICBpZiAoZGlycykgZGF0YSArPSBkaXJzICsgJywnO1xuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBga2V5OiR7ZWwua2V5fSxgO1xuICB9XG4gIC8vIHJlZlxuICBpZiAoZWwucmVmKSB7XG4gICAgZGF0YSArPSBgcmVmOiR7ZWwucmVmfSxgO1xuICB9XG4gIGlmIChlbC5yZWZJbkZvcikge1xuICAgIGRhdGEgKz0gYHJlZkluRm9yOnRydWUsYDtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gYHByZTp0cnVlLGA7XG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGRhdGEgKz0gYHRhZzpcIiR7ZWwudGFnfVwiLGA7XG4gIH1cbiAgLy8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgZGF0YSArPSBzdGF0ZS5kYXRhR2VuRm5zW2ldKGVsKTtcbiAgfVxuICAvLyBhdHRyaWJ1dGVzXG4gIGlmIChlbC5hdHRycykge1xuICAgIGRhdGEgKz0gYGF0dHJzOiR7Z2VuUHJvcHMoZWwuYXR0cnMpfSxgO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IGBkb21Qcm9wczoke2dlblByb3BzKGVsLnByb3BzKX0sYDtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSBgJHtnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlKX0sYDtcbiAgfVxuICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgZGF0YSArPSBgJHtnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUpfSxgO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gYHNsb3Q6JHtlbC5zbG90VGFyZ2V0fSxgO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IGAke2dlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpfSxgO1xuICB9XG4gIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gIGlmIChlbC5tb2RlbCkge1xuICAgIGRhdGEgKz0gYG1vZGVsOnt2YWx1ZToke1xuICAgICAgZWwubW9kZWwudmFsdWVcbiAgICB9LGNhbGxiYWNrOiR7XG4gICAgICBlbC5tb2RlbC5jYWxsYmFja1xuICAgIH0sZXhwcmVzc2lvbjoke1xuICAgICAgZWwubW9kZWwuZXhwcmVzc2lvblxuICAgIH19LGA7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIGNvbnN0IGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gYCR7aW5saW5lVGVtcGxhdGV9LGA7XG4gICAgfVxuICB9XG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXG4gIC8vIHYtYmluZCB3aXRoIGR5bmFtaWMgYXJndW1lbnRzIG11c3QgYmUgYXBwbGllZCB1c2luZyB0aGUgc2FtZSB2LWJpbmQgb2JqZWN0XG4gIC8vIG1lcmdlIGhlbHBlciBzbyB0aGF0IGNsYXNzL3N0eWxlL211c3RVc2VQcm9wIGF0dHJzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbiAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xuICAgIGRhdGEgPSBgX2IoJHtkYXRhfSxcIiR7ZWwudGFnfVwiLCR7Z2VuUHJvcHMoZWwuZHluYW1pY0F0dHJzKX0pYDtcbiAgfVxuICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwRGF0YSkge1xuICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcbiAgfVxuICAvLyB2LW9uIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcExpc3RlbmVycykge1xuICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsLCBzdGF0ZSkge1xuICBjb25zdCBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSByZXR1cm5cbiAgbGV0IHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICBsZXQgaGFzUnVudGltZSA9IGZhbHNlO1xuICBsZXQgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgY29uc3QgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgaWYgKGdlbikge1xuICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgIC8vIHJldHVybnMgdHJ1ZSBpZiBpdCBhbHNvIG5lZWRzIGEgcnVudGltZSBjb3VudGVycGFydC5cbiAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gYHtuYW1lOlwiJHtkaXIubmFtZX1cIixyYXdOYW1lOlwiJHtkaXIucmF3TmFtZX1cIiR7XG4gICAgICAgIGRpci52YWx1ZSA/IGAsdmFsdWU6KCR7ZGlyLnZhbHVlfSksZXhwcmVzc2lvbjoke0pTT04uc3RyaW5naWZ5KGRpci52YWx1ZSl9YCA6ICcnXG4gICAgICB9JHtcbiAgICAgICAgZGlyLmFyZyA/IGAsYXJnOiR7ZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiBgXCIke2Rpci5hcmd9XCJgfWAgOiAnJ1xuICAgICAgfSR7XG4gICAgICAgIGRpci5tb2RpZmllcnMgPyBgLG1vZGlmaWVyczoke0pTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpfWAgOiAnJ1xuICAgICAgfX0sYDtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgY29uc3QgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDEpIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicsXG4gICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgKTtcbiAgfVxuICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XG4gICAgY29uc3QgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBzdGF0ZS5vcHRpb25zKTtcbiAgICByZXR1cm4gYGlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXske1xuICAgICAgaW5saW5lUmVuZGVyRm5zLnJlbmRlclxuICAgIH19LHN0YXRpY1JlbmRlckZuczpbJHtcbiAgICAgIGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGNvZGUgPT4gYGZ1bmN0aW9uKCl7JHtjb2RlfX1gKS5qb2luKCcsJylcbiAgICB9XX1gXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBlbCxcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gIC8vIGJ1dCBpbiBzb21lIGNhc2VzIHdlIGhhdmUgdG8gYmFpbC1vdXQgb2YgdGhpcyBvcHRpbWl6YXRpb25cbiAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICBsZXQgbmVlZHNGb3JjZVVwZGF0ZSA9IE9iamVjdC5rZXlzKHNsb3RzKS5zb21lKGtleSA9PiB7XG4gICAgY29uc3Qgc2xvdCA9IHNsb3RzW2tleV07XG4gICAgcmV0dXJuIChcbiAgICAgIHNsb3Quc2xvdFRhcmdldER5bmFtaWMgfHxcbiAgICAgIHNsb3QuaWYgfHxcbiAgICAgIHNsb3QuZm9yIHx8XG4gICAgICBjb250YWluc1Nsb3RDaGlsZChzbG90KSAvLyBpcyBwYXNzaW5nIGRvd24gc2xvdCBmcm9tIHBhcmVudCB3aGljaCBtYXkgYmUgZHluYW1pY1xuICAgIClcbiAgfSk7XG4gIC8vIE9SIHdoZW4gaXQgaXMgaW5zaWRlIGFub3RoZXIgc2NvcGVkIHNsb3QgKHRoZSByZWFjdGl2aXR5IGlzIGRpc2Nvbm5lY3RlZClcbiAgLy8gIzk0MzhcbiAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgbGV0IHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB7XG4gICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYHNjb3BlZFNsb3RzOl91KFske1xuICAgIE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoa2V5ID0+IHtcbiAgICAgIHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKVxuICAgIH0pLmpvaW4oJywnKVxuICB9XSR7bmVlZHNGb3JjZVVwZGF0ZSA/IGAsdHJ1ZWAgOiBgYH0pYFxufVxuXG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBlbC5jaGlsZHJlbi5zb21lKGNvbnRhaW5zU2xvdENoaWxkKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgY29uc3QgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkICYmICFpc0xlZ2FjeVN5bnRheCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QsIGBudWxsYClcbiAgfVxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgfVxuICBjb25zdCBzbG90U2NvcGUgPSBlbC5zbG90U2NvcGUgPT09IGVtcHR5U2xvdFNjb3BlVG9rZW5cbiAgICA/IGBgXG4gICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgY29uc3QgZm4gPSBgZnVuY3Rpb24oJHtzbG90U2NvcGV9KXtgICtcbiAgICBgcmV0dXJuICR7ZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgID8gYCgke2VsLmlmfSk/JHtnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnfTp1bmRlZmluZWRgXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9fWA7XG4gIC8vIHJldmVyc2UgcHJveHkgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgY29uc3QgcmV2ZXJzZVByb3h5ID0gc2xvdFNjb3BlID8gYGAgOiBgLHByb3h5OnRydWVgO1xuICByZXR1cm4gYHtrZXk6JHtlbC5zbG90VGFyZ2V0IHx8IGBcImRlZmF1bHRcImB9LGZuOiR7Zm59JHtyZXZlcnNlUHJveHl9fWBcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjb25zdCBlbCA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsLmZvciAmJlxuICAgICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbC50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgY29uc3Qgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXBcbiAgICAgICAgPyBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgPyBgLDFgIDogYCwwYFxuICAgICAgICA6IGBgO1xuICAgICAgcmV0dXJuIGAkeyhhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSl9JHtub3JtYWxpemF0aW9uVHlwZX1gXG4gICAgfVxuICAgIGNvbnN0IG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICBjb25zdCBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIGBbJHtjaGlsZHJlbi5tYXAoYyA9PiBnZW4oYywgc3RhdGUpKS5qb2luKCcsJyl9XSR7XG4gICAgICBub3JtYWxpemF0aW9uVHlwZSA/IGAsJHtub3JtYWxpemF0aW9uVHlwZX1gIDogJydcbiAgICB9YFxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIGxldCByZXMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShjID0+IG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGMgPT4gbWF5YmVDb21wb25lbnQoYy5ibG9jaykpKSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG4gIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCdcbn1cblxuZnVuY3Rpb24gZ2VuTm9kZSAobm9kZSwgc3RhdGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiBgX3YoJHt0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSlcbiAgfSlgXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIGBfZSgke0pTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCl9KWBcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIGNvbnN0IHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgY29uc3QgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICBsZXQgcmVzID0gYF90KCR7c2xvdE5hbWV9JHtjaGlsZHJlbiA/IGAsJHtjaGlsZHJlbn1gIDogJyd9YDtcbiAgY29uc3QgYXR0cnMgPSBlbC5hdHRycyB8fCBlbC5keW5hbWljQXR0cnNcbiAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGF0dHIgPT4gKHtcbiAgICAgICAgLy8gc2xvdCBwcm9wcyBhcmUgY2FtZWxpemVkXG4gICAgICAgIG5hbWU6IGNhbWVsaXplKGF0dHIubmFtZSksXG4gICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICBkeW5hbWljOiBhdHRyLmR5bmFtaWNcbiAgICAgIH0pKSlcbiAgICA6IG51bGw7XG4gIGNvbnN0IGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IGAsbnVsbGA7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IGAsJHthdHRyc31gO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IGAke2F0dHJzID8gJycgOiAnLG51bGwnfSwke2JpbmQkJDF9YDtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgcmV0dXJuIGBfYygke2NvbXBvbmVudE5hbWV9LCR7Z2VuRGF0YSQyKGVsLCBzdGF0ZSl9JHtcbiAgICBjaGlsZHJlbiA/IGAsJHtjaGlsZHJlbn1gIDogJydcbiAgfSlgXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICBsZXQgc3RhdGljUHJvcHMgPSBgYDtcbiAgbGV0IGR5bmFtaWNQcm9wcyA9IGBgO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgIGNvbnN0IHZhbHVlID0gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpO1xuICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNQcm9wcyArPSBgJHtwcm9wLm5hbWV9LCR7dmFsdWV9LGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY1Byb3BzICs9IGBcIiR7cHJvcC5uYW1lfVwiOiR7dmFsdWV9LGA7XG4gICAgfVxuICB9XG4gIHN0YXRpY1Byb3BzID0gYHske3N0YXRpY1Byb3BzLnNsaWNlKDAsIC0xKX19YDtcbiAgaWYgKGR5bmFtaWNQcm9wcykge1xuICAgIHJldHVybiBgX2QoJHtzdGF0aWNQcm9wc30sWyR7ZHluYW1pY1Byb3BzLnNsaWNlKDAsIC0xKX1dKWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGljUHJvcHNcbiAgfVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG5jb25zdCBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xuY29uc3QgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG5jb25zdCBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCwgd2Fybikge1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgd2Fybik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCB3YXJuKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBjb25zdCByYW5nZSA9IG5vZGUucmF3QXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIGB2LWZvcj1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIGAke25hbWV9PVwiJHt2YWx1ZX1cImAsIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCBgJHtuYW1lfT1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIHdhcm4sIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgY29uc3Qgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgY29uc3Qga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgd2FybihcbiAgICAgIGBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IGAgK1xuICAgICAgYFwiJHtrZXl3b3JkTWF0Y2hbMF19XCIgaW4gZXhwcmVzc2lvbiAke3RleHQudHJpbSgpfWAsXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgaWRlbnQsXG4gIHR5cGUsXG4gIHRleHQsXG4gIHdhcm4sXG4gIHJhbmdlXG4pIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKGB2YXIgJHtpZGVudH09X2ApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oYGludmFsaWQgJHt0eXBlfSBcIiR7aWRlbnR9XCIgaW4gZXhwcmVzc2lvbjogJHt0ZXh0LnRyaW0oKX1gLCByYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihgcmV0dXJuICR7ZXhwfWApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc3Qga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogYCArXG4gICAgICAgIGBcIiR7a2V5d29yZE1hdGNoWzBdfVwiXFxuICBSYXcgZXhwcmVzc2lvbjogJHt0ZXh0LnRyaW0oKX1gLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgYGludmFsaWQgZXhwcmVzc2lvbjogJHtlLm1lc3NhZ2V9IGluXFxuXFxuYCArXG4gICAgICAgIGAgICAgJHtleHB9XFxuXFxuYCArXG4gICAgICAgIGAgIFJhdyBleHByZXNzaW9uOiAke3RleHQudHJpbSgpfVxcbmAsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3QgcmFuZ2UgPSAyO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUNvZGVGcmFtZSAoXG4gIHNvdXJjZSxcbiAgc3RhcnQgPSAwLFxuICBlbmQgPSBzb3VyY2UubGVuZ3RoXG4pIHtcbiAgY29uc3QgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIGNvbnRpbnVlXG4gICAgICAgIHJlcy5wdXNoKGAke2ogKyAxfSR7cmVwZWF0KGAgYCwgMyAtIFN0cmluZyhqICsgMSkubGVuZ3RoKX18ICAke2xpbmVzW2pdfWApO1xuICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICBpZiAoaiA9PT0gaSkge1xuICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgY29uc3QgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyByZXBlYXQoYCBgLCBwYWQpICsgcmVwZWF0KGBeYCwgbGVuZ3RoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiA+IGkpIHtcbiAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgcmVwZWF0KGBeYCwgbGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvdW50ICs9IGxpbmVMZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpXG59XG5cbmZ1bmN0aW9uIHJlcGVhdCAoc3RyLCBuKSB7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChuICYgMSkgcmVzdWx0ICs9IHN0cjtcbiAgICBuID4+Pj0gMTtcbiAgICBpZiAobiA8PSAwKSBicmVha1xuICAgIHN0ciArPSBzdHI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyLCBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICBjb25zdCB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICBjb25zdCBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgY29uc3QgY29tcGlsZWQgPSBjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG4gICAge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICBgRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcbiR7ZS5tc2d9XFxuXFxuYCArXG4gICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICBgRXJyb3IgY29tcGlsaW5nIHRlbXBsYXRlOlxcblxcbiR7dGVtcGxhdGV9XFxuXFxuYCArXG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGUgPT4gYC0gJHtlfWApLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGUgPT4gdGlwKGUubXNnLCB2bSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChtc2cgPT4gdGlwKG1zZywgdm0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGNvbnN0IGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGNvZGUgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBgRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5gICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoKHsgZXJyLCBjb2RlIH0pID0+IGAke2Vyci50b1N0cmluZygpfSBpblxcblxcbiR7Y29kZX1cXG5gKS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yIChiYXNlQ29tcGlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICBjb25zdCB0aXBzID0gW107XG5cbiAgICAgIGxldCB3YXJuID0gKG1zZywgcmFuZ2UsIHRpcCkgPT4ge1xuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICBjb25zdCBsZWFkaW5nU3BhY2VMZW5ndGggPSB0ZW1wbGF0ZS5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG5cbiAgICAgICAgICB3YXJuID0gKG1zZywgcmFuZ2UsIHRpcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHsgbXNnIH07XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5lbmQgPSByYW5nZS5lbmQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKGRhdGEpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMgfHwgbnVsbCksXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xuXG4gICAgICBjb25zdCBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcbiAgICAgIHtcbiAgICAgICAgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCwgd2Fybik7XG4gICAgICB9XG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICAgIHJldHVybiBjb21waWxlZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlLFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cbmNvbnN0IGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG5jb25zdCB7IGNvbXBpbGUsIGNvbXBpbGVUb0Z1bmN0aW9ucyB9ID0gY3JlYXRlQ29tcGlsZXIoYmFzZU9wdGlvbnMpO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmxldCBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IGA8YSBocmVmPVwiXFxuXCIvPmAgOiBgPGRpdiBhPVwiXFxuXCIvPmA7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG5jb25zdCBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZShmYWxzZSkgOiBmYWxzZTtcbi8vICM2ODI4OiBjaHJvbWUgZW5jb2RlcyBjb250ZW50IGluIGFbaHJlZl1cbmNvbnN0IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZSh0cnVlKSA6IGZhbHNlO1xuXG4vKiAgKi9cblxuY29uc3QgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGlkID0+IHtcbiAgY29uc3QgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG5jb25zdCBtb3VudCA9IFZ1ZS5wcm90b3R5cGUuJG1vdW50O1xuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICB3YXJuKFxuICAgICAgYERvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLmBcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIGxldCB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgYFRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiAke29wdGlvbnMudGVtcGxhdGV9YCxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZShgdnVlICR7dGhpcy5fbmFtZX0gY29tcGlsZWAsICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8c2VsZWN0IGNsYXNzPSdzZWxlY3QnIHYtbW9kZWw9J3NlbGVjdGVkJyBAaW5wdXQ9J2V2ZW50ID0+IHsgJGVtaXQoXCJpbnB1dFwiLCBldmVudC50YXJnZXQudmFsdWUpIH0nPlxuICAgICAgPG9wdGlvbiB2LWZvcj0nb3B0aW9uIGluIG9wdGlvbnMnIDprZXk9J29wdGlvbi52YWx1ZScgOnZhbHVlPSdvcHRpb24udmFsdWUnPlxuICAgICAgICB7eyBvcHRpb24udGV4dCB9fVxuICAgICAgPC9vcHRpb24+XG4gICAgPC9zZWxlY3Q+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHN0eWxlPjwvc3R5bGU+XG5cbjxzY3JpcHQ+XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczogWydvcHRpb25zJywgJ3ZhbHVlJ10sXG4gICAgZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdGVkOiBudWxsLFxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnZhbHVlO1xuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNlbGVjdERhdGEgPSBbXG4gIHsgdGV4dDogJ0FsbCBCb3JvdWdocycsIHZhbHVlOiAnYWxsJyB9LFxuICB7IHRleHQ6ICdCcm9va2x5bicsIHZhbHVlOiAnYnJvb2tseW4nIH0sXG4gIHsgdGV4dDogJ1F1ZWVucycsIHZhbHVlOiAncXVlZW5zJyB9LFxuICB7IHRleHQ6ICdNYW5oYXR0YW4nLCB2YWx1ZTogJ21hbmhhdHRhbicgfSxcbiAgeyB0ZXh0OiAnU3RhdGVuIElzbGFuZCcsIHZhbHVlOiAnc3RhdGVuIGlzbGFuZCcgfSxcbiAgeyB0ZXh0OiAnVGhlIEJyb254JywgdmFsdWU6ICdicm9ueCcgfVxuXTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0RGF0YTsiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBWdWUgZnJvbSAndnVlL2Rpc3QvdnVlLmVzbS5icm93c2VyJzsgLy9cbmltcG9ydCBTZWxlY3RDb21wb25lbnQgZnJvbSAnLi9zZWxlY3QudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IFNlbGVjdERhdGEgZnJvbSAnLi9zZWxlY3QuZGF0YS5qcyc7IC8vIE91ciBzYW1wbGUgZGF0YVxuXG5jbGFzcyBTZWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoJ255Y28tc2VsZWN0JywgU2VsZWN0Q29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6ICdbZGF0YS1qcz1cImFwcFwiXScsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3B0aW9uczogU2VsZWN0LmRhdGEsXG4gICAgICAgICAgc2VsZWN0ZWQ6ICdhbGwnLFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cblNlbGVjdC5kYXRhID0gU2VsZWN0RGF0YTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0OyIsImZ1bmN0aW9uIGRhdGFIYW5kbGVyKG5ld0RhdGEsIG9sZERhdGEpIHtcbiAgaWYgKG9sZERhdGEpIHtcbiAgICB2YXIgY2hhcnQgPSB0aGlzLiRkYXRhLl9jaGFydDtcbiAgICB2YXIgbmV3RGF0YXNldExhYmVscyA9IG5ld0RhdGEuZGF0YXNldHMubWFwKGZ1bmN0aW9uIChkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YXNldC5sYWJlbDtcbiAgICB9KTtcbiAgICB2YXIgb2xkRGF0YXNldExhYmVscyA9IG9sZERhdGEuZGF0YXNldHMubWFwKGZ1bmN0aW9uIChkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YXNldC5sYWJlbDtcbiAgICB9KTtcbiAgICB2YXIgb2xkTGFiZWxzID0gSlNPTi5zdHJpbmdpZnkob2xkRGF0YXNldExhYmVscyk7XG4gICAgdmFyIG5ld0xhYmVscyA9IEpTT04uc3RyaW5naWZ5KG5ld0RhdGFzZXRMYWJlbHMpO1xuXG4gICAgaWYgKG5ld0xhYmVscyA9PT0gb2xkTGFiZWxzICYmIG9sZERhdGEuZGF0YXNldHMubGVuZ3RoID09PSBuZXdEYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgbmV3RGF0YS5kYXRhc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhc2V0LCBpKSB7XG4gICAgICAgIHZhciBvbGREYXRhc2V0S2V5cyA9IE9iamVjdC5rZXlzKG9sZERhdGEuZGF0YXNldHNbaV0pO1xuICAgICAgICB2YXIgbmV3RGF0YXNldEtleXMgPSBPYmplY3Qua2V5cyhkYXRhc2V0KTtcbiAgICAgICAgdmFyIGRlbGV0aW9uS2V5cyA9IG9sZERhdGFzZXRLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGtleSAhPT0gJ19tZXRhJyAmJiBuZXdEYXRhc2V0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGRlbGV0aW9uS2V5KSB7XG4gICAgICAgICAgZGVsZXRlIGNoYXJ0LmRhdGEuZGF0YXNldHNbaV1bZGVsZXRpb25LZXldO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gZGF0YXNldCkge1xuICAgICAgICAgIGlmIChkYXRhc2V0Lmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgIGNoYXJ0LmRhdGEuZGF0YXNldHNbaV1bYXR0cmlidXRlXSA9IGRhdGFzZXRbYXR0cmlidXRlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobmV3RGF0YS5oYXNPd25Qcm9wZXJ0eSgnbGFiZWxzJykpIHtcbiAgICAgICAgY2hhcnQuZGF0YS5sYWJlbHMgPSBuZXdEYXRhLmxhYmVscztcbiAgICAgICAgdGhpcy4kZW1pdCgnbGFiZWxzOnVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3RGF0YS5oYXNPd25Qcm9wZXJ0eSgneExhYmVscycpKSB7XG4gICAgICAgIGNoYXJ0LmRhdGEueExhYmVscyA9IG5ld0RhdGEueExhYmVscztcbiAgICAgICAgdGhpcy4kZW1pdCgneGxhYmVsczp1cGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0RhdGEuaGFzT3duUHJvcGVydHkoJ3lMYWJlbHMnKSkge1xuICAgICAgICBjaGFydC5kYXRhLnlMYWJlbHMgPSBuZXdEYXRhLnlMYWJlbHM7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3lsYWJlbHM6dXBkYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgdGhpcy4kZW1pdCgnY2hhcnQ6dXBkYXRlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaGFydCkge1xuICAgICAgICBjaGFydC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OmRlc3Ryb3knKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OnJlbmRlcicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy4kZGF0YS5fY2hhcnQpIHtcbiAgICAgIHRoaXMuJGRhdGEuX2NoYXJ0LmRlc3Ryb3koKTtcblxuICAgICAgdGhpcy4kZW1pdCgnY2hhcnQ6ZGVzdHJveScpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy4kZW1pdCgnY2hhcnQ6cmVuZGVyJyk7XG4gIH1cbn1cblxuZXhwb3J0IHZhciByZWFjdGl2ZURhdGEgPSB7XG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXJ0RGF0YTogbnVsbFxuICAgIH07XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgJ2NoYXJ0RGF0YSc6IGRhdGFIYW5kbGVyXG4gIH1cbn07XG5leHBvcnQgdmFyIHJlYWN0aXZlUHJvcCA9IHtcbiAgcHJvcHM6IHtcbiAgICBjaGFydERhdGE6IHtcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgICdjaGFydERhdGEnOiBkYXRhSGFuZGxlclxuICB9XG59O1xuZXhwb3J0IGRlZmF1bHQge1xuICByZWFjdGl2ZURhdGE6IHJlYWN0aXZlRGF0YSxcbiAgcmVhY3RpdmVQcm9wOiByZWFjdGl2ZVByb3Bcbn07IiwiLy8hIG1vbWVudC5qc1xuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICBmdW5jdGlvbiBob29rcyAoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgICAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2VkRGF0ZVBhcnRzIDogW10sXG4gICAgICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgcmZjMjgyMiAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB3ZWVrZGF5TWlzbWF0Y2ggOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgfVxuXG4gICAgdmFyIHNvbWU7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgbGVuID0gdC5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgICAgICB2YXIgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpc05vd1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3Mud2Vla2RheU1pc21hdGNoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID0gaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuID09IG51bGwgfHwgIU9iamVjdC5pc0Zyb3plbihtKSkge1xuICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSBob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQgKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vciAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAvLyAtMCAtPiAwXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgICAgICBpZiAoaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihudWxsLCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGFyZztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0gJ1xcblsnICsgaSArICddICc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9IGtleSArICc6ICcgKyBhcmd1bWVudHNbMF1ba2V5XSArICcsICc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhcm4obXNnICsgJ1xcbkFyZ3VtZW50czogJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQgKGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbJ18nICsgaV0gPSBwcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICAgICAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLCBwcm9wO1xuICAgICAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pICYmIGlzT2JqZWN0KGNoaWxkQ29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgY2hpbGRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChwYXJlbnRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGNoYW5nZXMgdG8gcHJvcGVydGllcyBkb24ndCBtb2RpZnkgcGFyZW50IGNvbmZpZ1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvY2FsZShjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXM7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICB2YXIgaSwgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG4gICAgdmFyIGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcblxuICAgIGZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgIHBhc3QgICA6ICclcyBhZ28nLFxuICAgICAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgc3MgOiAnJWQgc2Vjb25kcycsXG4gICAgICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgIGggIDogJ2FuIGhvdXInLFxuICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgIGQgIDogJ2EgZGF5JyxcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgIE0gIDogJ2EgbW9udGgnLFxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICB5ICA6ICdhIHllYXInLFxuICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICByZXR1cm4gKGlzRnVuY3Rpb24ob3V0cHV0KSkgP1xuICAgICAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICAgICAgb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhbGlhc2VzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICB2YXIgcHJpb3JpdGllcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgICAgIHByaW9yaXRpZXNbdW5pdF0gPSBwcmlvcml0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgICAgIHZhciB1bml0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciB1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgICAgICB1bml0cy5wdXNoKHt1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XX0pO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1bml0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxuICAgIHZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG4gICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJycsIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSkgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbiAgICB2YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG4gICAgdmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxuICAgIHZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxuICAgIHZhciBtYXRjaDV0bzYgICAgICA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LzsgLy8gICA5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbiAgICB2YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcblxuICAgIHZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbiAgICB2YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbiAgICB2YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgIHZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbiAgICB2YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4gICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgIHZhciBtYXRjaFdvcmQgPSAvWzAtOV17MCwyNTZ9WydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGMDdcXHVGRjEwLVxcdUZGRUZdezEsMjU2fXxbXFx1MDYwMC1cXHUwNkZGXFwvXXsxLDI1Nn0oXFxzKj9bXFx1MDYwMC1cXHUwNkZGXXsxLDI1Nn0pezEsMn0vaTtcblxuICAgIHZhciByZWdleGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuICh0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDA7XG4gICAgdmFyIE1PTlRIID0gMTtcbiAgICB2YXIgREFURSA9IDI7XG4gICAgdmFyIEhPVVIgPSAzO1xuICAgIHZhciBNSU5VVEUgPSA0O1xuICAgIHZhciBTRUNPTkQgPSA1O1xuICAgIHZhciBNSUxMSVNFQ09ORCA9IDY7XG4gICAgdmFyIFdFRUsgPSA3O1xuICAgIHZhciBXRUVLREFZID0gODtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0ICh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNldCQxKHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCAobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uaXNWYWxpZCgpID9cbiAgICAgICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCQxIChtb20sIHVuaXQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChtb20uaXNWYWxpZCgpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnRnVsbFllYXInICYmIGlzTGVhcFllYXIobW9tLnllYXIoKSkgJiYgbW9tLm1vbnRoKCkgPT09IDEgJiYgbW9tLmRhdGUoKSA9PT0gMjkpIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUsIG1vbS5tb250aCgpLCBkYXlzSW5Nb250aCh2YWx1ZSwgbW9tLm1vbnRoKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0ICh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9kKG4sIHgpIHtcbiAgICAgICAgcmV0dXJuICgobiAlIHgpICsgeCkgJSB4O1xuICAgIH1cblxuICAgIHZhciBpbmRleE9mO1xuXG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIC8vIEkga25vd1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RNb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgICAgICB5ZWFyICs9IChtb250aCAtIG1vZE1vbnRoKSAvIDEyO1xuICAgICAgICByZXR1cm4gbW9kTW9udGggPT09IDEgPyAoaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpIDogKDMxIC0gbW9kTW9udGggJSA3ICUgMik7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vO1xuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzID0gJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzIChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzWyh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnQgOlxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAgICAgLy8gY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcbiAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSArIDQwMCwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0RnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQ0RhdGUgKHkpIHtcbiAgICAgICAgdmFyIGRhdGU7XG4gICAgICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgYXJnc1swXSA9IHkgKyA0MDA7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICAgICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1vbSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgICAgIHJlc1dlZWssIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgICAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95IDogNiAgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNnRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOYU4oaW5wdXQpID8gbnVsbCA6IGlucHV0O1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcbiAgICBmdW5jdGlvbiBzaGlmdFdlZWtkYXlzICh3cywgbikge1xuICAgICAgICByZXR1cm4gd3Muc2xpY2UobiwgNykuY29uY2F0KHdzLnNsaWNlKDAsIG4pKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIHdlZWtkYXlzID0gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5cyA6XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1sobSAmJiBtICE9PSB0cnVlICYmIHRoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ107XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHdlZWtkYXlzLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gd2Vla2RheXNbbS5kYXkoKV0gOiB3ZWVrZGF5cztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIChtID09PSB0cnVlKSA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNTaG9ydCwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICAgICAgcmV0dXJuIChtID09PSB0cnVlKSA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNNaW4sIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlJDEod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGQnICYmIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNNaW5SZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tLCBtaW5wLCBzaG9ydHAsIGxvbmdwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgbG9uZ3AgPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpO1xuICAgICAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobG9uZ3ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdBJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2trJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaycsICdrayddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUlzUE0gKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoKGlucHV0ICsgJycpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApID09PSAncCcpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1lcmlkaWVtIChob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgLy8gdGhpcyBydWxlLlxuICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgIHZhciBiYXNlQ29uZmlnID0ge1xuICAgICAgICBjYWxlbmRhcjogZGVmYXVsdENhbGVuZGFyLFxuICAgICAgICBsb25nRGF0ZUZvcm1hdDogZGVmYXVsdExvbmdEYXRlRm9ybWF0LFxuICAgICAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxuICAgICAgICBvcmRpbmFsOiBkZWZhdWx0T3JkaW5hbCxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UsXG4gICAgICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcblxuICAgICAgICBtb250aHM6IGRlZmF1bHRMb2NhbGVNb250aHMsXG4gICAgICAgIG1vbnRoc1Nob3J0OiBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQsXG5cbiAgICAgICAgd2VlazogZGVmYXVsdExvY2FsZVdlZWssXG5cbiAgICAgICAgd2Vla2RheXM6IGRlZmF1bHRMb2NhbGVXZWVrZGF5cyxcbiAgICAgICAgd2Vla2RheXNNaW46IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbixcbiAgICAgICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXG5cbiAgICAgICAgbWVyaWRpZW1QYXJzZTogZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2VcbiAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge307XG4gICAgdmFyIGxvY2FsZUZhbWlsaWVzID0ge307XG4gICAgdmFyIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xuICAgIH1cblxuICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuICAgIC8vIHRyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4gICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgICAgICB2YXIgaSA9IDAsIGosIG5leHQsIGxvY2FsZSwgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsO1xuICAgICAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgdmFyIGFsaWFzZWRSZXF1aXJlID0gcmVxdWlyZTtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgY29uc29sZSAhPT0gICd1bmRlZmluZWQnKSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy93YXJuIHVzZXIgaWYgYXJndW1lbnRzIGFyZSBwYXNzZWQgYnV0IHRoZSBsb2NhbGUgY291bGQgbm90IGJlIHNldFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0xvY2FsZSAnICsga2V5ICsgICcgbm90IGZvdW5kLiBEaWQgeW91IGZvcmdldCB0byBsb2FkIGl0PycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoJ2RlZmluZUxvY2FsZU92ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoY29uZmlnLnBhcmVudExvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVMb2NhbGUoeC5uYW1lLCB4LmNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgbG9jYWxlIEFGVEVSIGFsbCBjaGlsZCBsb2NhbGVzIGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gY3JlYXRlZCwgc28gd2Ugd29uJ3QgZW5kIHVwIHdpdGggdGhlIGNoaWxkIGxvY2FsZSBzZXQuXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSwgdG1wTG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgIHRtcExvY2FsZSA9IGxvYWRMb2NhbGUobmFtZSk7XG4gICAgICAgICAgICBpZiAodG1wTG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XG4gICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICBmdW5jdGlvbiBnZXRMb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyAobSkge1xuICAgICAgICB2YXIgb3ZlcmZsb3c7XG4gICAgICAgIHZhciBhID0gbS5fYTtcblxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgICAgIGFbREFURV0gICAgICAgIDwgMSB8fCBhW0RBVEVdICAgICAgICA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKSA/IERBVEUgOlxuICAgICAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgICAgICBhW1NFQ09ORF0gICAgICA8IDAgfHwgYVtTRUNPTkRdICAgICAgPiA1OSAgPyBTRUNPTkQgOlxuICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dEYXlPZlllYXIgJiYgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksIG5vd1ZhbHVlLmdldFVUQ01vbnRoKCksIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5IChjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCBleHBlY3RlZFdlZWtkYXksIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSB8fCBjb25maWcuX2RheU9mWWVhciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDID8gY29uZmlnLl9kLmdldFVUQ0RheSgpIDogY29uZmlnLl9kLmdldERheSgpO1xuXG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIHR5cGVvZiBjb25maWcuX3cuZCAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uZmlnLl93LmQgIT09IGV4cGVjdGVkV2Vla2RheSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgIHZhciBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpc28gODYwMSByZWdleFxuICAgIC8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxuICAgIHZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuICAgIHZhciBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxuICAgIHZhciB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vO1xuXG4gICAgdmFyIGlzb0RhdGVzID0gW1xuICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcbiAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZREREJywgL1xcZHs3fS9dXG4gICAgXTtcblxuICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICB2YXIgaXNvVGltZXMgPSBbXG4gICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISCcsIC9cXGRcXGQvXVxuICAgIF07XG5cbiAgICB2YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLCBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUkZDIDI4MjIgcmVnZXg6IEZvciBkZXRhaWxzIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNzZWN0aW9uLTMuM1xuICAgIHZhciByZmMyODIyID0gL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLztcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKVxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChzZWNvbmRTdHIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhclN0cikge1xuICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KHllYXJTdHIsIDEwKTtcbiAgICAgICAgaWYgKHllYXIgPD0gNDkpIHtcbiAgICAgICAgICAgIHJldHVybiAyMDAwICsgeWVhcjtcbiAgICAgICAgfSBlbHNlIGlmICh5ZWFyIDw9IDk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ZWFyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKS5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKS5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKS5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW50ZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKHBhcnNlZElucHV0WzBdLCBwYXJzZWRJbnB1dFsxXSwgcGFyc2VkSW5wdXRbMl0pLmdldERheSgpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXlQcm92aWRlZCAhPT0gd2Vla2RheUFjdHVhbCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBvYnNPZmZzZXRzID0ge1xuICAgICAgICBVVDogMCxcbiAgICAgICAgR01UOiAwLFxuICAgICAgICBFRFQ6IC00ICogNjAsXG4gICAgICAgIEVTVDogLTUgKiA2MCxcbiAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICBDU1Q6IC02ICogNjAsXG4gICAgICAgIE1EVDogLTYgKiA2MCxcbiAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICBQRFQ6IC03ICogNjAsXG4gICAgICAgIFBTVDogLTggKiA2MFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gICAgICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKTtcbiAgICAgICAgICAgIHZhciBtID0gaG0gJSAxMDAsIGggPSAoaG0gLSBtKSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBoICogNjAgKyBtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2ggPSByZmMyODIyLmV4ZWMocHJlcHJvY2Vzc1JGQzI4MjIoY29uZmlnLl9pKSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhtYXRjaFs0XSwgbWF0Y2hbM10sIG1hdGNoWzJdLCBtYXRjaFs1XSwgbWF0Y2hbNl0sIG1hdGNoWzddKTtcbiAgICAgICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXG4gICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhbiB1cGNvbWluZyBtYWpvciByZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG4gICAgaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuJywgdG9rZW4sICdwYXJzZWRJbnB1dCcsIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgIHZhciBpc1BtO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAvL1xuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcbiAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICB2YXIgcmVzLCBpO1xuICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuICAgIGZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4ICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xuICAgIH07XG5cbiAgICB2YXIgb3JkZXJpbmcgPSBbJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTtcblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtKSB7XG4gICAgICAgICAgICBpZiAoIShpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXRIYXNEZWNpbWFsID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgbm9ybWFsaXplZElucHV0Lmlzb1dlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSBpc0R1cmF0aW9uVmFsaWQobm9ybWFsaXplZElucHV0KTtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0byB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNSb3VuZCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcik7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBtaW51dGVzID09PSAwID9cbiAgICAgICAgICAwIDpcbiAgICAgICAgICBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICBob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAvL1xuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gL14oXFwtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspKFxcLlxcZCopPyk/JC87XG5cbiAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgdmFyIGlzb1JlZ2V4ID0gL14oLXxcXCspP1AoPzooWy0rXT9bMC05LC5dKilZKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilXKT8oPzooWy0rXT9bMC05LC5dKilEKT8oPzpUKD86KFstK10/WzAtOSwuXSopSCk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopUyk/KT8kLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBoICA6IHRvSW50KG1hdGNoW0hPVVJdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtcyA6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24gLy8gdGhlIG1pbGxpc2Vjb25kIGRlY2ltYWwgcG9pbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG1hdGNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuICAgIGNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7fTtcblxuICAgICAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSAodGltZSwgZm9ybWF0cykge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICAgICAgdmFyIGxvY2FsRnJvbSA9IGlzTW9tZW50KGZyb20pID8gZnJvbSA6IGNyZWF0ZUxvY2FsKGZyb20pLFxuICAgICAgICAgICAgbG9jYWxUbyA9IGlzTW9tZW50KHRvKSA/IHRvIDogY3JlYXRlTG9jYWwodG8pO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbEZyb20uaXNWYWxpZCgpICYmIGxvY2FsVG8uaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICAgICAgcmV0dXJuIChpbmNsdXNpdml0eVswXSA9PT0gJygnID8gdGhpcy5pc0FmdGVyKGxvY2FsRnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUobG9jYWxGcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJyA/IHRoaXMuaXNCZWZvcmUobG9jYWxUbywgdW5pdHMpIDogIXRoaXMuaXNBZnRlcihsb2NhbFRvLCB1bml0cykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCksXG4gICAgICAgICAgICBpbnB1dE1zO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckFmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0LFxuICAgICAgICAgICAgem9uZURlbHRhLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMTI7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDFlMzsgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7IGJyZWFrOyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gODY0ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBkZWZhdWx0OiBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nKGtlZXBPZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHV0YyA9IGtlZXBPZmZzZXQgIT09IHRydWU7XG4gICAgICAgIHZhciBtID0gdXRjID8gdGhpcy5jbG9uZSgpLnV0YygpIDogdGhpcztcbiAgICAgICAgaWYgKG0ueWVhcigpIDwgMCB8fCBtLnllYXIoKSA+IDk5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLnJlcGxhY2UoJ1onLCBmb3JtYXRNb21lbnQobSwgJ1onKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW9tZW50LmludmFsaWQoLyogJyArIHRoaXMuX2kgKyAnICovKSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSAnbW9tZW50JztcbiAgICAgICAgdmFyIHpvbmUgPSAnJztcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XG4gICAgICAgICAgICB6b25lID0gJ1onO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgICAgICB2YXIgeWVhciA9ICgwIDw9IHRoaXMueWVhcigpICYmIHRoaXMueWVhcigpIDw9IDk5OTkpID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIHZhciBNU19QRVJfU0VDT05EID0gMTAwMDtcbiAgICB2YXIgTVNfUEVSX01JTlVURSA9IDYwICogTVNfUEVSX1NFQ09ORDtcbiAgICB2YXIgTVNfUEVSX0hPVVIgPSA2MCAqIE1TX1BFUl9NSU5VVEU7XG4gICAgdmFyIE1TX1BFUl80MDBfWUVBUlMgPSAoMzY1ICogNDAwICsgOTcpICogMjQgKiBNU19QRVJfSE9VUjtcblxuICAgIC8vIGFjdHVhbCBtb2R1bG8gLSBoYW5kbGVzIG5lZ2F0aXZlIG51bWJlcnMgKGZvciBkYXRlcyBiZWZvcmUgMTk3MCk6XG4gICAgZnVuY3Rpb24gbW9kJDEoZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuIChkaXZpZGVuZCAlIGRpdmlzb3IgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0Y1N0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gRGF0ZS5VVEMgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSwgbSwgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgICAgICB2YXIgdGltZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRPZkRhdGUgPSB0aGlzLl9pc1VUQyA/IHV0Y1N0YXJ0T2ZEYXRlIDogbG9jYWxTdGFydE9mRGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIDAsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgLSB0aGlzLm1vbnRoKCkgJSAzLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUgKyAodGhpcy5faXNVVEMgPyAwIDogdGhpcy51dGNPZmZzZXQoKSAqIE1TX1BFUl9NSU5VVEUpLCBNU19QRVJfSE9VUik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfU0VDT05EKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpICsgMSwgMCwgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgLSB0aGlzLm1vbnRoKCkgJSAzICsgMywgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpICsgMSwgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkgKyA3KSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKSArIDcpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfSE9VUiAtIG1vZCQxKHRpbWUgKyAodGhpcy5faXNVVEMgPyAwIDogdGhpcy51dGNPZmZzZXQoKSAqIE1TX1BFUl9NSU5VVEUpLCBNU19QRVJfSE9VUikgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfTUlOVVRFIC0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfU0VDT05EIC0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMiAoKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgICAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdxdWFydGVyJywgNyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/XG4gICAgICAgICAgKGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZSB8fCBsb2NhbGUuX29yZGluYWxQYXJzZSkgOlxuICAgICAgICAgIGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbiAgICBhZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdKTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uYWRkICAgICAgICAgICAgICAgPSBhZGQ7XG4gICAgcHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBjYWxlbmRhciQxO1xuICAgIHByb3RvLmNsb25lICAgICAgICAgICAgID0gY2xvbmU7XG4gICAgcHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xuICAgIHByb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG4gICAgcHJvdG8uZm9ybWF0ICAgICAgICAgICAgPSBmb3JtYXQ7XG4gICAgcHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xuICAgIHByb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbiAgICBwcm90by50byAgICAgICAgICAgICAgICA9IHRvO1xuICAgIHByb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XG4gICAgcHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdHZXQ7XG4gICAgcHJvdG8uaW52YWxpZEF0ICAgICAgICAgPSBpbnZhbGlkQXQ7XG4gICAgcHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xuICAgIHByb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG4gICAgcHJvdG8uaXNCZXR3ZWVuICAgICAgICAgPSBpc0JldHdlZW47XG4gICAgcHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XG4gICAgcHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xuICAgIHByb3RvLmlzU2FtZU9yQmVmb3JlICAgID0gaXNTYW1lT3JCZWZvcmU7XG4gICAgcHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBpc1ZhbGlkJDI7XG4gICAgcHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xuICAgIHByb3RvLmxvY2FsZSAgICAgICAgICAgID0gbG9jYWxlO1xuICAgIHByb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcbiAgICBwcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICBwcm90by5taW4gICAgICAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbiAgICBwcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcbiAgICBwcm90by5zZXQgICAgICAgICAgICAgICA9IHN0cmluZ1NldDtcbiAgICBwcm90by5zdGFydE9mICAgICAgICAgICA9IHN0YXJ0T2Y7XG4gICAgcHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBzdWJ0cmFjdDtcbiAgICBwcm90by50b0FycmF5ICAgICAgICAgICA9IHRvQXJyYXk7XG4gICAgcHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbiAgICBwcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcbiAgICBwcm90by50b0lTT1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nO1xuICAgIHByb3RvLmluc3BlY3QgICAgICAgICAgID0gaW5zcGVjdDtcbiAgICBwcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcbiAgICBwcm90by50b1N0cmluZyAgICAgICAgICA9IHRvU3RyaW5nO1xuICAgIHByb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbiAgICBwcm90by52YWx1ZU9mICAgICAgICAgICA9IHZhbHVlT2Y7XG4gICAgcHJvdG8uY3JlYXRpb25EYXRhICAgICAgPSBjcmVhdGlvbkRhdGE7XG4gICAgcHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG4gICAgcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG4gICAgcHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuICAgIHByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG4gICAgcHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbiAgICBwcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuICAgIHByb3RvLndlZWsgICAgICAgICAgID0gcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbiAgICBwcm90by5pc29XZWVrICAgICAgICA9IHByb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG4gICAgcHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBwcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIHByb3RvLmRheSAgICAgICAgPSBwcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIHByb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBwcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuICAgIHByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XG4gICAgcHJvdG8ubWludXRlID0gcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcbiAgICBwcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuICAgIHByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG4gICAgcHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG4gICAgcHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBwcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgcHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICBwcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xuICAgIHByb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgcHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xuICAgIHByb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XG4gICAgcHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBwcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIHByb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcbiAgICBwcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG4gICAgcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG4gICAgcHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG4gICAgcHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsIGdldFNldFpvbmUpO1xuICAgIHByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZSgnaXNEU1RTaGlmdGVkIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RzdC1zaGlmdGVkLyBmb3IgbW9yZSBpbmZvcm1hdGlvbicsIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVbml4IChpbnB1dCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJblpvbmUgKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBwcm90byQxID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDEuY2FsZW5kYXIgICAgICAgID0gY2FsZW5kYXI7XG4gICAgcHJvdG8kMS5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90byQxLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xuICAgIHByb3RvJDEub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbiAgICBwcm90byQxLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlVGltZTtcbiAgICBwcm90byQxLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG8kMS5zZXQgICAgICAgICAgICAgPSBzZXQ7XG5cbiAgICBwcm90byQxLm1vbnRocyAgICAgICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvJDEubW9udGhzUGFyc2UgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG4gICAgcHJvdG8kMS5tb250aHNSZWdleCAgICAgICA9IG1vbnRoc1JlZ2V4O1xuICAgIHByb3RvJDEubW9udGhzU2hvcnRSZWdleCAgPSBtb250aHNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIHByb3RvJDEud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5c1JlZ2V4ICAgICAgID0gICAgICAgIHdlZWtkYXlzUmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggID0gICAgICAgIHdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzTWluUmVnZXggICAgPSAgICAgICAgd2Vla2RheXNNaW5SZWdleDtcblxuICAgIHByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gZ2V0JDEgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpO1xuICAgICAgICB2YXIgdXRjID0gY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwgKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vICgpXG4gICAgLy8gKDUpXG4gICAgLy8gKGZtdCwgNSlcbiAgICAvLyAoZm10KVxuICAgIC8vICh0cnVlKVxuICAgIC8vICh0cnVlLCA1KVxuICAgIC8vICh0cnVlLCBmbXQsIDUpXG4gICAgLy8gKHRydWUsIGZtdClcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgIH1cblxuICAgIGdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgaG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBnZXRTZXRHbG9iYWxMb2NhbGUpO1xuICAgIGhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgZ2V0TG9jYWxlKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBhYnMgKCkge1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QkMSAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICAgICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gYWRkJDEgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gc3VidHJhY3QkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICAgICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICAgICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcyAodW5pdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5cztcbiAgICAgICAgdmFyIG1vbnRocztcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogICByZXR1cm4gbW9udGhzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiByZXR1cm4gbW9udGhzIC8gMztcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFyJzogICAgcmV0dXJuIG1vbnRocyAvIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiB2YWx1ZU9mJDEgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG4gICAgdmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG4gICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgdmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG4gICAgdmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG4gICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgdmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG4gICAgdmFyIGFzUXVhcnRlcnMgICAgID0gbWFrZUFzKCdRJyk7XG4gICAgdmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBjbG9uZSQxICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCQyICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgIHZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG4gICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgc3M6IDQ0LCAgICAgICAgIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICBzIDogNDUsICAgICAgICAgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgbSA6IDQ1LCAgICAgICAgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICBoIDogMjIsICAgICAgICAgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgIGQgOiAyNiwgICAgICAgICAvLyBkYXlzIHRvIG1vbnRoXG4gICAgICAgIE0gOiAxMSAgICAgICAgICAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICAgICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICAgICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgICAgICB2YXIgYSA9IHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSAgfHxcbiAgICAgICAgICAgICAgICBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICAgJiYgWydzcycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gICAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAgICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICAgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPCB0aHJlc2hvbGRzLk0gICAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mKHJvdW5kaW5nRnVuY3Rpb24pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xuICAgICAgICByZXR1cm4gKCh4ID4gMCkgLSAoeCA8IDApKSB8fCAreDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gYWJzJDEodGhpcy5fZGF5cyk7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSBhYnMkMSh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgdmFyIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsU2lnbiArICdQJyArXG4gICAgICAgICAgICAoWSA/IHltU2lnbiArIFkgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKE0gPyB5bVNpZ24gKyBNICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChEID8gZGF5c1NpZ24gKyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaG1zU2lnbiArIGggKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG0gPyBobXNTaWduICsgbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAocyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMi5pc1ZhbGlkICAgICAgICA9IGlzVmFsaWQkMTtcbiAgICBwcm90byQyLmFicyAgICAgICAgICAgID0gYWJzO1xuICAgIHByb3RvJDIuYWRkICAgICAgICAgICAgPSBhZGQkMTtcbiAgICBwcm90byQyLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3QkMTtcbiAgICBwcm90byQyLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgcHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBwcm90byQyLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBwcm90byQyLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIHByb3RvJDIuYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIHByb3RvJDIuYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBwcm90byQyLmFzUXVhcnRlcnMgICAgID0gYXNRdWFydGVycztcbiAgICBwcm90byQyLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBwcm90byQyLnZhbHVlT2YgICAgICAgID0gdmFsdWVPZiQxO1xuICAgIHByb3RvJDIuX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG4gICAgcHJvdG8kMi5jbG9uZSAgICAgICAgICA9IGNsb25lJDE7XG4gICAgcHJvdG8kMi5nZXQgICAgICAgICAgICA9IGdldCQyO1xuICAgIHByb3RvJDIubWlsbGlzZWNvbmRzICAgPSBtaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG4gICAgcHJvdG8kMi5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG4gICAgcHJvdG8kMi5ob3VycyAgICAgICAgICA9IGhvdXJzO1xuICAgIHByb3RvJDIuZGF5cyAgICAgICAgICAgPSBkYXlzO1xuICAgIHByb3RvJDIud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbiAgICBwcm90byQyLm1vbnRocyAgICAgICAgID0gbW9udGhzO1xuICAgIHByb3RvJDIueWVhcnMgICAgICAgICAgPSB5ZWFycztcbiAgICBwcm90byQyLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b0pTT04gICAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi5sb2NhbGUgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90byQyLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuICAgIHByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJywgdG9JU09TdHJpbmckMSk7XG4gICAgcHJvdG8kMi5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIGhvb2tzLnZlcnNpb24gPSAnMi4yNC4wJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbiAgICBob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBwcm90bztcbiAgICBob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG4gICAgaG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIGhvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbiAgICBob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVVEM7XG4gICAgaG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gY3JlYXRlVW5peDtcbiAgICBob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0TW9udGhzO1xuICAgIGhvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICBob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgaG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gY3JlYXRlSW52YWxpZDtcbiAgICBob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVEdXJhdGlvbjtcbiAgICBob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICBob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0V2Vla2RheXM7XG4gICAgaG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gY3JlYXRlSW5ab25lO1xuICAgIGhvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGdldExvY2FsZTtcbiAgICBob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuICAgIGhvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RNb250aHNTaG9ydDtcbiAgICBob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0V2Vla2RheXNNaW47XG4gICAgaG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgIGhvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbiAgICBob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsaXN0TG9jYWxlcztcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0V2Vla2RheXNTaG9ydDtcbiAgICBob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyAgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgaG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG4gICAgaG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gcHJvdG87XG5cbiAgICAvLyBjdXJyZW50bHkgSFRNTDUgaW5wdXQgdHlwZSBvbmx5IHN1cHBvcnRzIDI0LWhvdXIgZm9ybWF0c1xuICAgIGhvb2tzLkhUTUw1X0ZNVCA9IHtcbiAgICAgICAgREFURVRJTUVfTE9DQUw6ICdZWVlZLU1NLUREVEhIOm1tJywgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX1NFQ09ORFM6ICdZWVlZLU1NLUREVEhIOm1tOnNzJywgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBEQVRFOiAnWVlZWS1NTS1ERCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgICAgICBUSU1FOiAnSEg6bW0nLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgICAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIFdFRUs6ICdHR0dHLVtXXVdXJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxuICAgIH07XG5cbiAgICByZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iLCIvKiFcbiAqIENoYXJ0LmpzIHYyLjguMFxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDE5IENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZnVuY3Rpb24oKSB7IHRyeSB7IHJldHVybiByZXF1aXJlKCdtb21lbnQnKTsgfSBjYXRjaChlKSB7IH0gfSgpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydyZXF1aXJlJ10sIGZ1bmN0aW9uKHJlcXVpcmUpIHsgcmV0dXJuIGZhY3RvcnkoZnVuY3Rpb24oKSB7IHRyeSB7IHJldHVybiByZXF1aXJlKCdtb21lbnQnKTsgfSBjYXRjaChlKSB7IH0gfSgpKTsgfSkgOlxuKGdsb2JhbC5DaGFydCA9IGZhY3RvcnkoZ2xvYmFsLm1vbWVudCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cbm1vbWVudCA9IG1vbWVudCAmJiBtb21lbnQuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSA/IG1vbWVudFsnZGVmYXVsdCddIDogbW9tZW50O1xuXG4vKiBNSVQgbGljZW5zZSAqL1xuXG52YXIgY29udmVyc2lvbnMgPSB7XG4gIHJnYjJoc2w6IHJnYjJoc2wsXG4gIHJnYjJoc3Y6IHJnYjJoc3YsXG4gIHJnYjJod2I6IHJnYjJod2IsXG4gIHJnYjJjbXlrOiByZ2IyY215ayxcbiAgcmdiMmtleXdvcmQ6IHJnYjJrZXl3b3JkLFxuICByZ2IyeHl6OiByZ2IyeHl6LFxuICByZ2IybGFiOiByZ2IybGFiLFxuICByZ2IybGNoOiByZ2IybGNoLFxuXG4gIGhzbDJyZ2I6IGhzbDJyZ2IsXG4gIGhzbDJoc3Y6IGhzbDJoc3YsXG4gIGhzbDJod2I6IGhzbDJod2IsXG4gIGhzbDJjbXlrOiBoc2wyY215ayxcbiAgaHNsMmtleXdvcmQ6IGhzbDJrZXl3b3JkLFxuXG4gIGhzdjJyZ2I6IGhzdjJyZ2IsXG4gIGhzdjJoc2w6IGhzdjJoc2wsXG4gIGhzdjJod2I6IGhzdjJod2IsXG4gIGhzdjJjbXlrOiBoc3YyY215ayxcbiAgaHN2MmtleXdvcmQ6IGhzdjJrZXl3b3JkLFxuXG4gIGh3YjJyZ2I6IGh3YjJyZ2IsXG4gIGh3YjJoc2w6IGh3YjJoc2wsXG4gIGh3YjJoc3Y6IGh3YjJoc3YsXG4gIGh3YjJjbXlrOiBod2IyY215ayxcbiAgaHdiMmtleXdvcmQ6IGh3YjJrZXl3b3JkLFxuXG4gIGNteWsycmdiOiBjbXlrMnJnYixcbiAgY215azJoc2w6IGNteWsyaHNsLFxuICBjbXlrMmhzdjogY215azJoc3YsXG4gIGNteWsyaHdiOiBjbXlrMmh3YixcbiAgY215azJrZXl3b3JkOiBjbXlrMmtleXdvcmQsXG5cbiAga2V5d29yZDJyZ2I6IGtleXdvcmQycmdiLFxuICBrZXl3b3JkMmhzbDoga2V5d29yZDJoc2wsXG4gIGtleXdvcmQyaHN2OiBrZXl3b3JkMmhzdixcbiAga2V5d29yZDJod2I6IGtleXdvcmQyaHdiLFxuICBrZXl3b3JkMmNteWs6IGtleXdvcmQyY215ayxcbiAga2V5d29yZDJsYWI6IGtleXdvcmQybGFiLFxuICBrZXl3b3JkMnh5ejoga2V5d29yZDJ4eXosXG5cbiAgeHl6MnJnYjogeHl6MnJnYixcbiAgeHl6MmxhYjogeHl6MmxhYixcbiAgeHl6MmxjaDogeHl6MmxjaCxcblxuICBsYWIyeHl6OiBsYWIyeHl6LFxuICBsYWIycmdiOiBsYWIycmdiLFxuICBsYWIybGNoOiBsYWIybGNoLFxuXG4gIGxjaDJsYWI6IGxjaDJsYWIsXG4gIGxjaDJ4eXo6IGxjaDJ4eXosXG4gIGxjaDJyZ2I6IGxjaDJyZ2Jcbn07XG5cblxuZnVuY3Rpb24gcmdiMmhzbChyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0vMjU1LFxuICAgICAgZyA9IHJnYlsxXS8yNTUsXG4gICAgICBiID0gcmdiWzJdLzI1NSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBkZWx0YSA9IG1heCAtIG1pbixcbiAgICAgIGgsIHMsIGw7XG5cbiAgaWYgKG1heCA9PSBtaW4pXG4gICAgaCA9IDA7XG4gIGVsc2UgaWYgKHIgPT0gbWF4KVxuICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGcgPT0gbWF4KVxuICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICBlbHNlIGlmIChiID09IG1heClcbiAgICBoID0gNCArIChyIC0gZykvIGRlbHRhO1xuXG4gIGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cbiAgaWYgKGggPCAwKVxuICAgIGggKz0gMzYwO1xuXG4gIGwgPSAobWluICsgbWF4KSAvIDI7XG5cbiAgaWYgKG1heCA9PSBtaW4pXG4gICAgcyA9IDA7XG4gIGVsc2UgaWYgKGwgPD0gMC41KVxuICAgIHMgPSBkZWx0YSAvIChtYXggKyBtaW4pO1xuICBlbHNlXG4gICAgcyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXG4gIHJldHVybiBbaCwgcyAqIDEwMCwgbCAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJoc3YocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLFxuICAgICAgZyA9IHJnYlsxXSxcbiAgICAgIGIgPSByZ2JbMl0sXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCB2O1xuXG4gIGlmIChtYXggPT0gMClcbiAgICBzID0gMDtcbiAgZWxzZVxuICAgIHMgPSAoZGVsdGEvbWF4ICogMTAwMCkvMTA7XG5cbiAgaWYgKG1heCA9PSBtaW4pXG4gICAgaCA9IDA7XG4gIGVsc2UgaWYgKHIgPT0gbWF4KVxuICAgIGggPSAoZyAtIGIpIC8gZGVsdGE7XG4gIGVsc2UgaWYgKGcgPT0gbWF4KVxuICAgIGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuICBlbHNlIGlmIChiID09IG1heClcbiAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICB2ID0gKChtYXggLyAyNTUpICogMTAwMCkgLyAxMDtcblxuICByZXR1cm4gW2gsIHMsIHZdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHdiKHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgaCA9IHJnYjJoc2wocmdiKVswXSxcbiAgICAgIHcgPSAxLzI1NSAqIE1hdGgubWluKHIsIE1hdGgubWluKGcsIGIpKSxcbiAgICAgIGIgPSAxIC0gMS8yNTUgKiBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG5cbiAgcmV0dXJuIFtoLCB3ICogMTAwLCBiICogMTAwXTtcbn1cblxuZnVuY3Rpb24gcmdiMmNteWsocmdiKSB7XG4gIHZhciByID0gcmdiWzBdIC8gMjU1LFxuICAgICAgZyA9IHJnYlsxXSAvIDI1NSxcbiAgICAgIGIgPSByZ2JbMl0gLyAyNTUsXG4gICAgICBjLCBtLCB5LCBrO1xuXG4gIGsgPSBNYXRoLm1pbigxIC0gciwgMSAtIGcsIDEgLSBiKTtcbiAgYyA9ICgxIC0gciAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICBtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHkgPSAoMSAtIGIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgcmV0dXJuIFtjICogMTAwLCBtICogMTAwLCB5ICogMTAwLCBrICogMTAwXTtcbn1cblxuZnVuY3Rpb24gcmdiMmtleXdvcmQocmdiKSB7XG4gIHJldHVybiByZXZlcnNlS2V5d29yZHNbSlNPTi5zdHJpbmdpZnkocmdiKV07XG59XG5cbmZ1bmN0aW9uIHJnYjJ4eXoocmdiKSB7XG4gIHZhciByID0gcmdiWzBdIC8gMjU1LFxuICAgICAgZyA9IHJnYlsxXSAvIDI1NSxcbiAgICAgIGIgPSByZ2JbMl0gLyAyNTU7XG5cbiAgLy8gYXNzdW1lIHNSR0JcbiAgciA9IHIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChyICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKHIgLyAxMi45Mik7XG4gIGcgPSBnID4gMC4wNDA0NSA/IE1hdGgucG93KCgoZyArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChnIC8gMTIuOTIpO1xuICBiID0gYiA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoYiAvIDEyLjkyKTtcblxuICB2YXIgeCA9IChyICogMC40MTI0KSArIChnICogMC4zNTc2KSArIChiICogMC4xODA1KTtcbiAgdmFyIHkgPSAociAqIDAuMjEyNikgKyAoZyAqIDAuNzE1MikgKyAoYiAqIDAuMDcyMik7XG4gIHZhciB6ID0gKHIgKiAwLjAxOTMpICsgKGcgKiAwLjExOTIpICsgKGIgKiAwLjk1MDUpO1xuXG4gIHJldHVybiBbeCAqIDEwMCwgeSAqMTAwLCB6ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gcmdiMmxhYihyZ2IpIHtcbiAgdmFyIHh5eiA9IHJnYjJ4eXoocmdiKSxcbiAgICAgICAgeCA9IHh5elswXSxcbiAgICAgICAgeSA9IHh5elsxXSxcbiAgICAgICAgeiA9IHh5elsyXSxcbiAgICAgICAgbCwgYSwgYjtcblxuICB4IC89IDk1LjA0NztcbiAgeSAvPSAxMDA7XG4gIHogLz0gMTA4Ljg4MztcblxuICB4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMS8zKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcbiAgeSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEvMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG4gIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxLzMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG4gIGwgPSAoMTE2ICogeSkgLSAxNjtcbiAgYSA9IDUwMCAqICh4IC0geSk7XG4gIGIgPSAyMDAgKiAoeSAtIHopO1xuXG4gIHJldHVybiBbbCwgYSwgYl07XG59XG5cbmZ1bmN0aW9uIHJnYjJsY2goYXJncykge1xuICByZXR1cm4gbGFiMmxjaChyZ2IybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMnJnYihoc2wpIHtcbiAgdmFyIGggPSBoc2xbMF0gLyAzNjAsXG4gICAgICBzID0gaHNsWzFdIC8gMTAwLFxuICAgICAgbCA9IGhzbFsyXSAvIDEwMCxcbiAgICAgIHQxLCB0MiwgdDMsIHJnYiwgdmFsO1xuXG4gIGlmIChzID09IDApIHtcbiAgICB2YWwgPSBsICogMjU1O1xuICAgIHJldHVybiBbdmFsLCB2YWwsIHZhbF07XG4gIH1cblxuICBpZiAobCA8IDAuNSlcbiAgICB0MiA9IGwgKiAoMSArIHMpO1xuICBlbHNlXG4gICAgdDIgPSBsICsgcyAtIGwgKiBzO1xuICB0MSA9IDIgKiBsIC0gdDI7XG5cbiAgcmdiID0gWzAsIDAsIDBdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHQzID0gaCArIDEgLyAzICogLSAoaSAtIDEpO1xuICAgIHQzIDwgMCAmJiB0MysrO1xuICAgIHQzID4gMSAmJiB0My0tO1xuXG4gICAgaWYgKDYgKiB0MyA8IDEpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqIDYgKiB0MztcbiAgICBlbHNlIGlmICgyICogdDMgPCAxKVxuICAgICAgdmFsID0gdDI7XG4gICAgZWxzZSBpZiAoMyAqIHQzIDwgMilcbiAgICAgIHZhbCA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNjtcbiAgICBlbHNlXG4gICAgICB2YWwgPSB0MTtcblxuICAgIHJnYltpXSA9IHZhbCAqIDI1NTtcbiAgfVxuXG4gIHJldHVybiByZ2I7XG59XG5cbmZ1bmN0aW9uIGhzbDJoc3YoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICBzdiwgdjtcblxuICBpZihsID09PSAwKSB7XG4gICAgICAvLyBubyBuZWVkIHRvIGRvIGNhbGMgb24gYmxhY2tcbiAgICAgIC8vIGFsc28gYXZvaWRzIGRpdmlkZSBieSAwIGVycm9yXG4gICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICB9XG5cbiAgbCAqPSAyO1xuICBzICo9IChsIDw9IDEpID8gbCA6IDIgLSBsO1xuICB2ID0gKGwgKyBzKSAvIDI7XG4gIHN2ID0gKDIgKiBzKSAvIChsICsgcyk7XG4gIHJldHVybiBbaCwgc3YgKiAxMDAsIHYgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiBoc2wyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2IoaHNsMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChoc2wycmdiKGFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiBoc3YycmdiKGhzdikge1xuICB2YXIgaCA9IGhzdlswXSAvIDYwLFxuICAgICAgcyA9IGhzdlsxXSAvIDEwMCxcbiAgICAgIHYgPSBoc3ZbMl0gLyAxMDAsXG4gICAgICBoaSA9IE1hdGguZmxvb3IoaCkgJSA2O1xuXG4gIHZhciBmID0gaCAtIE1hdGguZmxvb3IoaCksXG4gICAgICBwID0gMjU1ICogdiAqICgxIC0gcyksXG4gICAgICBxID0gMjU1ICogdiAqICgxIC0gKHMgKiBmKSksXG4gICAgICB0ID0gMjU1ICogdiAqICgxIC0gKHMgKiAoMSAtIGYpKSksXG4gICAgICB2ID0gMjU1ICogdjtcblxuICBzd2l0Y2goaGkpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gW3YsIHQsIHBdO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBbcSwgdiwgcF07XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFtwLCB2LCB0XTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gW3AsIHEsIHZdO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBbdCwgcCwgdl07XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIFt2LCBwLCBxXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoc3YyaHNsKGhzdikge1xuICB2YXIgaCA9IGhzdlswXSxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgc2wsIGw7XG5cbiAgbCA9ICgyIC0gcykgKiB2O1xuICBzbCA9IHMgKiB2O1xuICBzbCAvPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgc2wgPSBzbCB8fCAwO1xuICBsIC89IDI7XG4gIHJldHVybiBbaCwgc2wgKiAxMDAsIGwgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiBoc3YyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2IoaHN2MnJnYihhcmdzKSlcbn1cblxuZnVuY3Rpb24gaHN2MmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHN2MnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzdjJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGhzdjJyZ2IoYXJncykpO1xufVxuXG4vLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtY29sb3IvI2h3Yi10by1yZ2JcbmZ1bmN0aW9uIGh3YjJyZ2IoaHdiKSB7XG4gIHZhciBoID0gaHdiWzBdIC8gMzYwLFxuICAgICAgd2ggPSBod2JbMV0gLyAxMDAsXG4gICAgICBibCA9IGh3YlsyXSAvIDEwMCxcbiAgICAgIHJhdGlvID0gd2ggKyBibCxcbiAgICAgIGksIHYsIGYsIG47XG5cbiAgLy8gd2ggKyBibCBjYW50IGJlID4gMVxuICBpZiAocmF0aW8gPiAxKSB7XG4gICAgd2ggLz0gcmF0aW87XG4gICAgYmwgLz0gcmF0aW87XG4gIH1cblxuICBpID0gTWF0aC5mbG9vcig2ICogaCk7XG4gIHYgPSAxIC0gYmw7XG4gIGYgPSA2ICogaCAtIGk7XG4gIGlmICgoaSAmIDB4MDEpICE9IDApIHtcbiAgICBmID0gMSAtIGY7XG4gIH1cbiAgbiA9IHdoICsgZiAqICh2IC0gd2gpOyAgLy8gbGluZWFyIGludGVycG9sYXRpb25cblxuICBzd2l0Y2ggKGkpIHtcbiAgICBkZWZhdWx0OlxuICAgIGNhc2UgNjpcbiAgICBjYXNlIDA6IHIgPSB2OyBnID0gbjsgYiA9IHdoOyBicmVhaztcbiAgICBjYXNlIDE6IHIgPSBuOyBnID0gdjsgYiA9IHdoOyBicmVhaztcbiAgICBjYXNlIDI6IHIgPSB3aDsgZyA9IHY7IGIgPSBuOyBicmVhaztcbiAgICBjYXNlIDM6IHIgPSB3aDsgZyA9IG47IGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDQ6IHIgPSBuOyBnID0gd2g7IGIgPSB2OyBicmVhaztcbiAgICBjYXNlIDU6IHIgPSB2OyBnID0gd2g7IGIgPSBuOyBicmVhaztcbiAgfVxuXG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIGh3YjJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmhzdihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHN2KGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBod2IyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsycmdiKGNteWspIHtcbiAgdmFyIGMgPSBjbXlrWzBdIC8gMTAwLFxuICAgICAgbSA9IGNteWtbMV0gLyAxMDAsXG4gICAgICB5ID0gY215a1syXSAvIDEwMCxcbiAgICAgIGsgPSBjbXlrWzNdIC8gMTAwLFxuICAgICAgciwgZywgYjtcblxuICByID0gMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgayk7XG4gIGcgPSAxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKTtcbiAgYiA9IDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspO1xuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiBjbXlrMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2IoY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoY215azJyZ2IoYXJncykpO1xufVxuXG5cbmZ1bmN0aW9uIHh5ejJyZ2IoeHl6KSB7XG4gIHZhciB4ID0geHl6WzBdIC8gMTAwLFxuICAgICAgeSA9IHh5elsxXSAvIDEwMCxcbiAgICAgIHogPSB4eXpbMl0gLyAxMDAsXG4gICAgICByLCBnLCBiO1xuXG4gIHIgPSAoeCAqIDMuMjQwNikgKyAoeSAqIC0xLjUzNzIpICsgKHogKiAtMC40OTg2KTtcbiAgZyA9ICh4ICogLTAuOTY4OSkgKyAoeSAqIDEuODc1OCkgKyAoeiAqIDAuMDQxNSk7XG4gIGIgPSAoeCAqIDAuMDU1NykgKyAoeSAqIC0wLjIwNDApICsgKHogKiAxLjA1NzApO1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KHIsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiByID0gKHIgKiAxMi45Mik7XG5cbiAgZyA9IGcgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coZywgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IGcgPSAoZyAqIDEyLjkyKTtcblxuICBiID0gYiA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhiLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogYiA9IChiICogMTIuOTIpO1xuXG4gIHIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCByKSwgMSk7XG4gIGcgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBnKSwgMSk7XG4gIGIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBiKSwgMSk7XG5cbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24geHl6MmxhYih4eXopIHtcbiAgdmFyIHggPSB4eXpbMF0sXG4gICAgICB5ID0geHl6WzFdLFxuICAgICAgeiA9IHh5elsyXSxcbiAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiB4eXoybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2goeHl6MmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGxhYjJ4eXoobGFiKSB7XG4gIHZhciBsID0gbGFiWzBdLFxuICAgICAgYSA9IGxhYlsxXSxcbiAgICAgIGIgPSBsYWJbMl0sXG4gICAgICB4LCB5LCB6LCB5MjtcblxuICBpZiAobCA8PSA4KSB7XG4gICAgeSA9IChsICogMTAwKSAvIDkwMy4zO1xuICAgIHkyID0gKDcuNzg3ICogKHkgLyAxMDApKSArICgxNiAvIDExNik7XG4gIH0gZWxzZSB7XG4gICAgeSA9IDEwMCAqIE1hdGgucG93KChsICsgMTYpIC8gMTE2LCAzKTtcbiAgICB5MiA9IE1hdGgucG93KHkgLyAxMDAsIDEvMyk7XG4gIH1cblxuICB4ID0geCAvIDk1LjA0NyA8PSAwLjAwODg1NiA/IHggPSAoOTUuMDQ3ICogKChhIC8gNTAwKSArIHkyIC0gKDE2IC8gMTE2KSkpIC8gNy43ODcgOiA5NS4wNDcgKiBNYXRoLnBvdygoYSAvIDUwMCkgKyB5MiwgMyk7XG5cbiAgeiA9IHogLyAxMDguODgzIDw9IDAuMDA4ODU5ID8geiA9ICgxMDguODgzICogKHkyIC0gKGIgLyAyMDApIC0gKDE2IC8gMTE2KSkpIC8gNy43ODcgOiAxMDguODgzICogTWF0aC5wb3coeTIgLSAoYiAvIDIwMCksIDMpO1xuXG4gIHJldHVybiBbeCwgeSwgel07XG59XG5cbmZ1bmN0aW9uIGxhYjJsY2gobGFiKSB7XG4gIHZhciBsID0gbGFiWzBdLFxuICAgICAgYSA9IGxhYlsxXSxcbiAgICAgIGIgPSBsYWJbMl0sXG4gICAgICBociwgaCwgYztcblxuICBociA9IE1hdGguYXRhbjIoYiwgYSk7XG4gIGggPSBociAqIDM2MCAvIDIgLyBNYXRoLlBJO1xuICBpZiAoaCA8IDApIHtcbiAgICBoICs9IDM2MDtcbiAgfVxuICBjID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICByZXR1cm4gW2wsIGMsIGhdO1xufVxuXG5mdW5jdGlvbiBsYWIycmdiKGFyZ3MpIHtcbiAgcmV0dXJuIHh5ejJyZ2IobGFiMnh5eihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGxjaDJsYWIobGNoKSB7XG4gIHZhciBsID0gbGNoWzBdLFxuICAgICAgYyA9IGxjaFsxXSxcbiAgICAgIGggPSBsY2hbMl0sXG4gICAgICBhLCBiLCBocjtcblxuICBociA9IGggLyAzNjAgKiAyICogTWF0aC5QSTtcbiAgYSA9IGMgKiBNYXRoLmNvcyhocik7XG4gIGIgPSBjICogTWF0aC5zaW4oaHIpO1xuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiBsY2gyeHl6KGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJ4eXoobGNoMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGxjaDJyZ2IoYXJncykge1xuICByZXR1cm4gbGFiMnJnYihsY2gybGFiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJyZ2Ioa2V5d29yZCkge1xuICByZXR1cm4gY3NzS2V5d29yZHNba2V5d29yZF07XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmhzdihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHN2KGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJod2IoYXJncykge1xuICByZXR1cm4gcmdiMmh3YihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQybGFiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJsYWIoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMnh5eihhcmdzKSB7XG4gIHJldHVybiByZ2IyeHl6KGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxudmFyIGNzc0tleXdvcmRzID0ge1xuICBhbGljZWJsdWU6ICBbMjQwLDI0OCwyNTVdLFxuICBhbnRpcXVld2hpdGU6IFsyNTAsMjM1LDIxNV0sXG4gIGFxdWE6IFswLDI1NSwyNTVdLFxuICBhcXVhbWFyaW5lOiBbMTI3LDI1NSwyMTJdLFxuICBhenVyZTogIFsyNDAsMjU1LDI1NV0sXG4gIGJlaWdlOiAgWzI0NSwyNDUsMjIwXSxcbiAgYmlzcXVlOiBbMjU1LDIyOCwxOTZdLFxuICBibGFjazogIFswLDAsMF0sXG4gIGJsYW5jaGVkYWxtb25kOiBbMjU1LDIzNSwyMDVdLFxuICBibHVlOiBbMCwwLDI1NV0sXG4gIGJsdWV2aW9sZXQ6IFsxMzgsNDMsMjI2XSxcbiAgYnJvd246ICBbMTY1LDQyLDQyXSxcbiAgYnVybHl3b29kOiAgWzIyMiwxODQsMTM1XSxcbiAgY2FkZXRibHVlOiAgWzk1LDE1OCwxNjBdLFxuICBjaGFydHJldXNlOiBbMTI3LDI1NSwwXSxcbiAgY2hvY29sYXRlOiAgWzIxMCwxMDUsMzBdLFxuICBjb3JhbDogIFsyNTUsMTI3LDgwXSxcbiAgY29ybmZsb3dlcmJsdWU6IFsxMDAsMTQ5LDIzN10sXG4gIGNvcm5zaWxrOiBbMjU1LDI0OCwyMjBdLFxuICBjcmltc29uOiAgWzIyMCwyMCw2MF0sXG4gIGN5YW46IFswLDI1NSwyNTVdLFxuICBkYXJrYmx1ZTogWzAsMCwxMzldLFxuICBkYXJrY3lhbjogWzAsMTM5LDEzOV0sXG4gIGRhcmtnb2xkZW5yb2Q6ICBbMTg0LDEzNCwxMV0sXG4gIGRhcmtncmF5OiBbMTY5LDE2OSwxNjldLFxuICBkYXJrZ3JlZW46ICBbMCwxMDAsMF0sXG4gIGRhcmtncmV5OiBbMTY5LDE2OSwxNjldLFxuICBkYXJra2hha2k6ICBbMTg5LDE4MywxMDddLFxuICBkYXJrbWFnZW50YTogIFsxMzksMCwxMzldLFxuICBkYXJrb2xpdmVncmVlbjogWzg1LDEwNyw0N10sXG4gIGRhcmtvcmFuZ2U6IFsyNTUsMTQwLDBdLFxuICBkYXJrb3JjaGlkOiBbMTUzLDUwLDIwNF0sXG4gIGRhcmtyZWQ6ICBbMTM5LDAsMF0sXG4gIGRhcmtzYWxtb246IFsyMzMsMTUwLDEyMl0sXG4gIGRhcmtzZWFncmVlbjogWzE0MywxODgsMTQzXSxcbiAgZGFya3NsYXRlYmx1ZTogIFs3Miw2MSwxMzldLFxuICBkYXJrc2xhdGVncmF5OiAgWzQ3LDc5LDc5XSxcbiAgZGFya3NsYXRlZ3JleTogIFs0Nyw3OSw3OV0sXG4gIGRhcmt0dXJxdW9pc2U6ICBbMCwyMDYsMjA5XSxcbiAgZGFya3Zpb2xldDogWzE0OCwwLDIxMV0sXG4gIGRlZXBwaW5rOiBbMjU1LDIwLDE0N10sXG4gIGRlZXBza3libHVlOiAgWzAsMTkxLDI1NV0sXG4gIGRpbWdyYXk6ICBbMTA1LDEwNSwxMDVdLFxuICBkaW1ncmV5OiAgWzEwNSwxMDUsMTA1XSxcbiAgZG9kZ2VyYmx1ZTogWzMwLDE0NCwyNTVdLFxuICBmaXJlYnJpY2s6ICBbMTc4LDM0LDM0XSxcbiAgZmxvcmFsd2hpdGU6ICBbMjU1LDI1MCwyNDBdLFxuICBmb3Jlc3RncmVlbjogIFszNCwxMzksMzRdLFxuICBmdWNoc2lhOiAgWzI1NSwwLDI1NV0sXG4gIGdhaW5zYm9ybzogIFsyMjAsMjIwLDIyMF0sXG4gIGdob3N0d2hpdGU6IFsyNDgsMjQ4LDI1NV0sXG4gIGdvbGQ6IFsyNTUsMjE1LDBdLFxuICBnb2xkZW5yb2Q6ICBbMjE4LDE2NSwzMl0sXG4gIGdyYXk6IFsxMjgsMTI4LDEyOF0sXG4gIGdyZWVuOiAgWzAsMTI4LDBdLFxuICBncmVlbnllbGxvdzogIFsxNzMsMjU1LDQ3XSxcbiAgZ3JleTogWzEyOCwxMjgsMTI4XSxcbiAgaG9uZXlkZXc6IFsyNDAsMjU1LDI0MF0sXG4gIGhvdHBpbms6ICBbMjU1LDEwNSwxODBdLFxuICBpbmRpYW5yZWQ6ICBbMjA1LDkyLDkyXSxcbiAgaW5kaWdvOiBbNzUsMCwxMzBdLFxuICBpdm9yeTogIFsyNTUsMjU1LDI0MF0sXG4gIGtoYWtpOiAgWzI0MCwyMzAsMTQwXSxcbiAgbGF2ZW5kZXI6IFsyMzAsMjMwLDI1MF0sXG4gIGxhdmVuZGVyYmx1c2g6ICBbMjU1LDI0MCwyNDVdLFxuICBsYXduZ3JlZW46ICBbMTI0LDI1MiwwXSxcbiAgbGVtb25jaGlmZm9uOiBbMjU1LDI1MCwyMDVdLFxuICBsaWdodGJsdWU6ICBbMTczLDIxNiwyMzBdLFxuICBsaWdodGNvcmFsOiBbMjQwLDEyOCwxMjhdLFxuICBsaWdodGN5YW46ICBbMjI0LDI1NSwyNTVdLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwyNTAsMjEwXSxcbiAgbGlnaHRncmF5OiAgWzIxMSwyMTEsMjExXSxcbiAgbGlnaHRncmVlbjogWzE0NCwyMzgsMTQ0XSxcbiAgbGlnaHRncmV5OiAgWzIxMSwyMTEsMjExXSxcbiAgbGlnaHRwaW5rOiAgWzI1NSwxODIsMTkzXSxcbiAgbGlnaHRzYWxtb246ICBbMjU1LDE2MCwxMjJdLFxuICBsaWdodHNlYWdyZWVuOiAgWzMyLDE3OCwxNzBdLFxuICBsaWdodHNreWJsdWU6IFsxMzUsMjA2LDI1MF0sXG4gIGxpZ2h0c2xhdGVncmF5OiBbMTE5LDEzNiwxNTNdLFxuICBsaWdodHNsYXRlZ3JleTogWzExOSwxMzYsMTUzXSxcbiAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsMTk2LDIyMl0sXG4gIGxpZ2h0eWVsbG93OiAgWzI1NSwyNTUsMjI0XSxcbiAgbGltZTogWzAsMjU1LDBdLFxuICBsaW1lZ3JlZW46ICBbNTAsMjA1LDUwXSxcbiAgbGluZW46ICBbMjUwLDI0MCwyMzBdLFxuICBtYWdlbnRhOiAgWzI1NSwwLDI1NV0sXG4gIG1hcm9vbjogWzEyOCwwLDBdLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBbMTAyLDIwNSwxNzBdLFxuICBtZWRpdW1ibHVlOiBbMCwwLDIwNV0sXG4gIG1lZGl1bW9yY2hpZDogWzE4Niw4NSwyMTFdLFxuICBtZWRpdW1wdXJwbGU6IFsxNDcsMTEyLDIxOV0sXG4gIG1lZGl1bXNlYWdyZWVuOiBbNjAsMTc5LDExM10sXG4gIG1lZGl1bXNsYXRlYmx1ZTogIFsxMjMsMTA0LDIzOF0sXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAgWzAsMjUwLDE1NF0sXG4gIG1lZGl1bXR1cnF1b2lzZTogIFs3MiwyMDksMjA0XSxcbiAgbWVkaXVtdmlvbGV0cmVkOiAgWzE5OSwyMSwxMzNdLFxuICBtaWRuaWdodGJsdWU6IFsyNSwyNSwxMTJdLFxuICBtaW50Y3JlYW06ICBbMjQ1LDI1NSwyNTBdLFxuICBtaXN0eXJvc2U6ICBbMjU1LDIyOCwyMjVdLFxuICBtb2NjYXNpbjogWzI1NSwyMjgsMTgxXSxcbiAgbmF2YWpvd2hpdGU6ICBbMjU1LDIyMiwxNzNdLFxuICBuYXZ5OiBbMCwwLDEyOF0sXG4gIG9sZGxhY2U6ICBbMjUzLDI0NSwyMzBdLFxuICBvbGl2ZTogIFsxMjgsMTI4LDBdLFxuICBvbGl2ZWRyYWI6ICBbMTA3LDE0MiwzNV0sXG4gIG9yYW5nZTogWzI1NSwxNjUsMF0sXG4gIG9yYW5nZXJlZDogIFsyNTUsNjksMF0sXG4gIG9yY2hpZDogWzIxOCwxMTIsMjE0XSxcbiAgcGFsZWdvbGRlbnJvZDogIFsyMzgsMjMyLDE3MF0sXG4gIHBhbGVncmVlbjogIFsxNTIsMjUxLDE1Ml0sXG4gIHBhbGV0dXJxdW9pc2U6ICBbMTc1LDIzOCwyMzhdLFxuICBwYWxldmlvbGV0cmVkOiAgWzIxOSwxMTIsMTQ3XSxcbiAgcGFwYXlhd2hpcDogWzI1NSwyMzksMjEzXSxcbiAgcGVhY2hwdWZmOiAgWzI1NSwyMTgsMTg1XSxcbiAgcGVydTogWzIwNSwxMzMsNjNdLFxuICBwaW5rOiBbMjU1LDE5MiwyMDNdLFxuICBwbHVtOiBbMjIxLDE2MCwyMjFdLFxuICBwb3dkZXJibHVlOiBbMTc2LDIyNCwyMzBdLFxuICBwdXJwbGU6IFsxMjgsMCwxMjhdLFxuICByZWJlY2NhcHVycGxlOiBbMTAyLCA1MSwgMTUzXSxcbiAgcmVkOiAgWzI1NSwwLDBdLFxuICByb3N5YnJvd246ICBbMTg4LDE0MywxNDNdLFxuICByb3lhbGJsdWU6ICBbNjUsMTA1LDIyNV0sXG4gIHNhZGRsZWJyb3duOiAgWzEzOSw2OSwxOV0sXG4gIHNhbG1vbjogWzI1MCwxMjgsMTE0XSxcbiAgc2FuZHlicm93bjogWzI0NCwxNjQsOTZdLFxuICBzZWFncmVlbjogWzQ2LDEzOSw4N10sXG4gIHNlYXNoZWxsOiBbMjU1LDI0NSwyMzhdLFxuICBzaWVubmE6IFsxNjAsODIsNDVdLFxuICBzaWx2ZXI6IFsxOTIsMTkyLDE5Ml0sXG4gIHNreWJsdWU6ICBbMTM1LDIwNiwyMzVdLFxuICBzbGF0ZWJsdWU6ICBbMTA2LDkwLDIwNV0sXG4gIHNsYXRlZ3JheTogIFsxMTIsMTI4LDE0NF0sXG4gIHNsYXRlZ3JleTogIFsxMTIsMTI4LDE0NF0sXG4gIHNub3c6IFsyNTUsMjUwLDI1MF0sXG4gIHNwcmluZ2dyZWVuOiAgWzAsMjU1LDEyN10sXG4gIHN0ZWVsYmx1ZTogIFs3MCwxMzAsMTgwXSxcbiAgdGFuOiAgWzIxMCwxODAsMTQwXSxcbiAgdGVhbDogWzAsMTI4LDEyOF0sXG4gIHRoaXN0bGU6ICBbMjE2LDE5MSwyMTZdLFxuICB0b21hdG86IFsyNTUsOTksNzFdLFxuICB0dXJxdW9pc2U6ICBbNjQsMjI0LDIwOF0sXG4gIHZpb2xldDogWzIzOCwxMzAsMjM4XSxcbiAgd2hlYXQ6ICBbMjQ1LDIyMiwxNzldLFxuICB3aGl0ZTogIFsyNTUsMjU1LDI1NV0sXG4gIHdoaXRlc21va2U6IFsyNDUsMjQ1LDI0NV0sXG4gIHllbGxvdzogWzI1NSwyNTUsMF0sXG4gIHllbGxvd2dyZWVuOiAgWzE1NCwyMDUsNTBdXG59O1xuXG52YXIgcmV2ZXJzZUtleXdvcmRzID0ge307XG5mb3IgKHZhciBrZXkgaW4gY3NzS2V5d29yZHMpIHtcbiAgcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KGNzc0tleXdvcmRzW2tleV0pXSA9IGtleTtcbn1cblxudmFyIGNvbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBuZXcgQ29udmVydGVyKCk7XG59O1xuXG5mb3IgKHZhciBmdW5jIGluIGNvbnZlcnNpb25zKSB7XG4gIC8vIGV4cG9ydCBSYXcgdmVyc2lvbnNcbiAgY29udmVydFtmdW5jICsgXCJSYXdcIl0gPSAgKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBhY2NlcHQgYXJyYXkgb3IgcGxhaW4gYXJnc1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09IFwibnVtYmVyXCIpXG4gICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY29udmVyc2lvbnNbZnVuY10oYXJnKTtcbiAgICB9XG4gIH0pKGZ1bmMpO1xuXG4gIHZhciBwYWlyID0gLyhcXHcrKTIoXFx3KykvLmV4ZWMoZnVuYyksXG4gICAgICBmcm9tID0gcGFpclsxXSxcbiAgICAgIHRvID0gcGFpclsyXTtcblxuICAvLyBleHBvcnQgcmdiMmhzbCBhbmQgW1wicmdiXCJdW1wiaHNsXCJdXG4gIGNvbnZlcnRbZnJvbV0gPSBjb252ZXJ0W2Zyb21dIHx8IHt9O1xuXG4gIGNvbnZlcnRbZnJvbV1bdG9dID0gY29udmVydFtmdW5jXSA9IChmdW5jdGlvbihmdW5jKSB7IFxuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09IFwibnVtYmVyXCIpXG4gICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBcbiAgICAgIHZhciB2YWwgPSBjb252ZXJzaW9uc1tmdW5jXShhcmcpO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIiB8fCB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHZhbDsgLy8ga2V5d29yZFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKylcbiAgICAgICAgdmFsW2ldID0gTWF0aC5yb3VuZCh2YWxbaV0pO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH0pKGZ1bmMpO1xufVxuXG5cbi8qIENvbnZlcnRlciBkb2VzIGxhenkgY29udmVyc2lvbiBhbmQgY2FjaGluZyAqL1xudmFyIENvbnZlcnRlciA9IGZ1bmN0aW9uKCkge1xuICAgdGhpcy5jb252cyA9IHt9O1xufTtcblxuLyogRWl0aGVyIGdldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlIG9yXG4gIHNldCB0aGUgdmFsdWVzIGZvciBhIHNwYWNlLCBkZXBlbmRpbmcgb24gYXJncyAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5yb3V0ZVNwYWNlID0gZnVuY3Rpb24oc3BhY2UsIGFyZ3MpIHtcbiAgIHZhciB2YWx1ZXMgPSBhcmdzWzBdO1xuICAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjb2xvci5yZ2IoKVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcbiAgIH1cbiAgIC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT0gXCJudW1iZXJcIikge1xuICAgICAgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7ICAgICAgICBcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuc2V0VmFsdWVzKHNwYWNlLCB2YWx1ZXMpO1xufTtcbiAgXG4vKiBTZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSwgaW52YWxpZGF0aW5nIGNhY2hlICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLnNldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlLCB2YWx1ZXMpIHtcbiAgIHRoaXMuc3BhY2UgPSBzcGFjZTtcbiAgIHRoaXMuY29udnMgPSB7fTtcbiAgIHRoaXMuY29udnNbc3BhY2VdID0gdmFsdWVzO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiBHZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZS4gSWYgdGhlcmUncyBhbHJlYWR5XG4gIGEgY29udmVyc2lvbiBmb3IgdGhlIHNwYWNlLCBmZXRjaCBpdCwgb3RoZXJ3aXNlXG4gIGNvbXB1dGUgaXQgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24oc3BhY2UpIHtcbiAgIHZhciB2YWxzID0gdGhpcy5jb252c1tzcGFjZV07XG4gICBpZiAoIXZhbHMpIHtcbiAgICAgIHZhciBmc3BhY2UgPSB0aGlzLnNwYWNlLFxuICAgICAgICAgIGZyb20gPSB0aGlzLmNvbnZzW2ZzcGFjZV07XG4gICAgICB2YWxzID0gY29udmVydFtmc3BhY2VdW3NwYWNlXShmcm9tKTtcblxuICAgICAgdGhpcy5jb252c1tzcGFjZV0gPSB2YWxzO1xuICAgfVxuICByZXR1cm4gdmFscztcbn07XG5cbltcInJnYlwiLCBcImhzbFwiLCBcImhzdlwiLCBcImNteWtcIiwgXCJrZXl3b3JkXCJdLmZvckVhY2goZnVuY3Rpb24oc3BhY2UpIHtcbiAgIENvbnZlcnRlci5wcm90b3R5cGVbc3BhY2VdID0gZnVuY3Rpb24odmFscykge1xuICAgICAgcmV0dXJuIHRoaXMucm91dGVTcGFjZShzcGFjZSwgYXJndW1lbnRzKTtcbiAgIH07XG59KTtcblxudmFyIGNvbG9yQ29udmVydCA9IGNvbnZlcnQ7XG5cbnZhciBjb2xvck5hbWUgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59O1xuXG4vKiBNSVQgbGljZW5zZSAqL1xuXG5cbnZhciBjb2xvclN0cmluZyA9IHtcbiAgIGdldFJnYmE6IGdldFJnYmEsXG4gICBnZXRIc2xhOiBnZXRIc2xhLFxuICAgZ2V0UmdiOiBnZXRSZ2IsXG4gICBnZXRIc2w6IGdldEhzbCxcbiAgIGdldEh3YjogZ2V0SHdiLFxuICAgZ2V0QWxwaGE6IGdldEFscGhhLFxuXG4gICBoZXhTdHJpbmc6IGhleFN0cmluZyxcbiAgIHJnYlN0cmluZzogcmdiU3RyaW5nLFxuICAgcmdiYVN0cmluZzogcmdiYVN0cmluZyxcbiAgIHBlcmNlbnRTdHJpbmc6IHBlcmNlbnRTdHJpbmcsXG4gICBwZXJjZW50YVN0cmluZzogcGVyY2VudGFTdHJpbmcsXG4gICBoc2xTdHJpbmc6IGhzbFN0cmluZyxcbiAgIGhzbGFTdHJpbmc6IGhzbGFTdHJpbmcsXG4gICBod2JTdHJpbmc6IGh3YlN0cmluZyxcbiAgIGtleXdvcmQ6IGtleXdvcmRcbn07XG5cbmZ1bmN0aW9uIGdldFJnYmEoc3RyaW5nKSB7XG4gICBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuO1xuICAgfVxuICAgdmFyIGFiYnIgPSAgL14jKFthLWZBLUYwLTldezMsNH0pJC9pLFxuICAgICAgIGhleCA9ICAvXiMoW2EtZkEtRjAtOV17Nn0oW2EtZkEtRjAtOV17Mn0pPykkL2ksXG4gICAgICAgcmdiYSA9IC9ecmdiYT9cXChcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyosXFxzKihbKy1dP1xcZCspXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvaSxcbiAgICAgICBwZXIgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkL2ksXG4gICAgICAga2V5d29yZCA9IC8oXFx3KykvO1xuXG4gICB2YXIgcmdiID0gWzAsIDAsIDBdLFxuICAgICAgIGEgPSAxLFxuICAgICAgIG1hdGNoID0gc3RyaW5nLm1hdGNoKGFiYnIpLFxuICAgICAgIGhleEFscGhhID0gXCJcIjtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGhleEFscGhhID0gbWF0Y2hbM107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaV0gKyBtYXRjaFtpXSwgMTYpO1xuICAgICAgfVxuICAgICAgaWYgKGhleEFscGhhKSB7XG4gICAgICAgICBhID0gTWF0aC5yb3VuZCgocGFyc2VJbnQoaGV4QWxwaGEgKyBoZXhBbHBoYSwgMTYpIC8gMjU1KSAqIDEwMCkgLyAxMDA7XG4gICAgICB9XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChoZXgpKSB7XG4gICAgICBoZXhBbHBoYSA9IG1hdGNoWzJdO1xuICAgICAgbWF0Y2ggPSBtYXRjaFsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaC5zbGljZShpICogMiwgaSAqIDIgKyAyKSwgMTYpO1xuICAgICAgfVxuICAgICAgaWYgKGhleEFscGhhKSB7XG4gICAgICAgICBhID0gTWF0aC5yb3VuZCgocGFyc2VJbnQoaGV4QWxwaGEsIDE2KSAvIDI1NSkgKiAxMDApIC8gMTAwO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0pO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChtYXRjaFtpICsgMV0pICogMi41NSk7XG4gICAgICB9XG4gICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICB9XG4gICBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaChrZXl3b3JkKSkge1xuICAgICAgaWYgKG1hdGNoWzFdID09IFwidHJhbnNwYXJlbnRcIikge1xuICAgICAgICAgcmV0dXJuIFswLCAwLCAwLCAwXTtcbiAgICAgIH1cbiAgICAgIHJnYiA9IGNvbG9yTmFtZVttYXRjaFsxXV07XG4gICAgICBpZiAoIXJnYikge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgfVxuXG4gICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgcmdiW2ldID0gc2NhbGUocmdiW2ldLCAwLCAyNTUpO1xuICAgfVxuICAgaWYgKCFhICYmIGEgIT0gMCkge1xuICAgICAgYSA9IDE7XG4gICB9XG4gICBlbHNlIHtcbiAgICAgIGEgPSBzY2FsZShhLCAwLCAxKTtcbiAgIH1cbiAgIHJnYlszXSA9IGE7XG4gICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBnZXRIc2xhKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBoc2wgPSAvXmhzbGE/XFwoXFxzKihbKy1dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKS87XG4gICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHNsKTtcbiAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICBzID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgbCA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuICAgICAgcmV0dXJuIFtoLCBzLCBsLCBhXTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0SHdiKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBod2IgPSAvXmh3YlxcKFxccyooWystXT9cXGQrKSg/OmRlZyk/XFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkvO1xuICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGh3Yik7XG4gICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgICAgIHZhciBoID0gc2NhbGUocGFyc2VJbnQobWF0Y2hbMV0pLCAwLCAzNjApLFxuICAgICAgICAgIHcgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzJdKSwgMCwgMTAwKSxcbiAgICAgICAgICBiID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCksXG4gICAgICAgICAgYSA9IHNjYWxlKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG4gICAgICByZXR1cm4gW2gsIHcsIGIsIGFdO1xuICAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZ2Ioc3RyaW5nKSB7XG4gICB2YXIgcmdiYSA9IGdldFJnYmEoc3RyaW5nKTtcbiAgIHJldHVybiByZ2JhICYmIHJnYmEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEhzbChzdHJpbmcpIHtcbiAgdmFyIGhzbGEgPSBnZXRIc2xhKHN0cmluZyk7XG4gIHJldHVybiBoc2xhICYmIGhzbGEuc2xpY2UoMCwgMyk7XG59XG5cbmZ1bmN0aW9uIGdldEFscGhhKHN0cmluZykge1xuICAgdmFyIHZhbHMgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICBpZiAodmFscykge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHNsYShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gdmFsc1szXTtcbiAgIH1cbiAgIGVsc2UgaWYgKHZhbHMgPSBnZXRId2Ioc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG59XG5cbi8vIGdlbmVyYXRvcnNcbmZ1bmN0aW9uIGhleFN0cmluZyhyZ2JhLCBhKSB7XG4gICB2YXIgYSA9IChhICE9PSB1bmRlZmluZWQgJiYgcmdiYS5sZW5ndGggPT09IDMpID8gYSA6IHJnYmFbM107XG4gICByZXR1cm4gXCIjXCIgKyBoZXhEb3VibGUocmdiYVswXSkgXG4gICAgICAgICAgICAgICsgaGV4RG91YmxlKHJnYmFbMV0pXG4gICAgICAgICAgICAgICsgaGV4RG91YmxlKHJnYmFbMl0pXG4gICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAoYSA+PSAwICYmIGEgPCAxKVxuICAgICAgICAgICAgICAgICA/IGhleERvdWJsZShNYXRoLnJvdW5kKGEgKiAyNTUpKVxuICAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgICAgICAgKTtcbn1cblxuZnVuY3Rpb24gcmdiU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPCAxIHx8IChyZ2JhWzNdICYmIHJnYmFbM10gPCAxKSkge1xuICAgICAgcmV0dXJuIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHJnYmFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChyZ2JhWzNdICE9PSB1bmRlZmluZWQgPyByZ2JhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJyZ2JhKFwiICsgcmdiYVswXSArIFwiLCBcIiArIHJnYmFbMV0gKyBcIiwgXCIgKyByZ2JhWzJdXG4gICAgICAgICAgICsgXCIsIFwiICsgYWxwaGEgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudFN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSk7XG4gICB9XG4gICB2YXIgciA9IE1hdGgucm91bmQocmdiYVswXS8yNTUgKiAxMDApLFxuICAgICAgIGcgPSBNYXRoLnJvdW5kKHJnYmFbMV0vMjU1ICogMTAwKSxcbiAgICAgICBiID0gTWF0aC5yb3VuZChyZ2JhWzJdLzI1NSAqIDEwMCk7XG5cbiAgIHJldHVybiBcInJnYihcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBwZXJjZW50YVN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuICAgcmV0dXJuIFwicmdiYShcIiArIHIgKyBcIiUsIFwiICsgZyArIFwiJSwgXCIgKyBiICsgXCIlLCBcIiArIChhbHBoYSB8fCByZ2JhWzNdIHx8IDEpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbFN0cmluZyhoc2xhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAoaHNsYVszXSAmJiBoc2xhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcImhzbChcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUpXCI7XG59XG5cbmZ1bmN0aW9uIGhzbGFTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChoc2xhWzNdICE9PSB1bmRlZmluZWQgPyBoc2xhWzNdIDogMSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2xhKFwiICsgaHNsYVswXSArIFwiLCBcIiArIGhzbGFbMV0gKyBcIiUsIFwiICsgaHNsYVsyXSArIFwiJSwgXCJcbiAgICAgICAgICAgKyBhbHBoYSArIFwiKVwiO1xufVxuXG4vLyBod2IgaXMgYSBiaXQgZGlmZmVyZW50IHRoYW4gcmdiKGEpICYgaHNsKGEpIHNpbmNlIHRoZXJlIGlzIG5vIGFscGhhIHNwZWNpZmljIHN5bnRheFxuLy8gKGh3YiBoYXZlIGFscGhhIG9wdGlvbmFsICYgMSBpcyBkZWZhdWx0IHZhbHVlKVxuZnVuY3Rpb24gaHdiU3RyaW5nKGh3YiwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IChod2JbM10gIT09IHVuZGVmaW5lZCA/IGh3YlszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHdiKFwiICsgaHdiWzBdICsgXCIsIFwiICsgaHdiWzFdICsgXCIlLCBcIiArIGh3YlsyXSArIFwiJVwiXG4gICAgICAgICAgICsgKGFscGhhICE9PSB1bmRlZmluZWQgJiYgYWxwaGEgIT09IDEgPyBcIiwgXCIgKyBhbHBoYSA6IFwiXCIpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQocmdiKSB7XG4gIHJldHVybiByZXZlcnNlTmFtZXNbcmdiLnNsaWNlKDAsIDMpXTtcbn1cblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gc2NhbGUobnVtLCBtaW4sIG1heCkge1xuICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgbnVtKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gaGV4RG91YmxlKG51bSkge1xuICB2YXIgc3RyID0gbnVtLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICByZXR1cm4gKHN0ci5sZW5ndGggPCAyKSA/IFwiMFwiICsgc3RyIDogc3RyO1xufVxuXG5cbi8vY3JlYXRlIGEgbGlzdCBvZiByZXZlcnNlIGNvbG9yIG5hbWVzXG52YXIgcmV2ZXJzZU5hbWVzID0ge307XG5mb3IgKHZhciBuYW1lIGluIGNvbG9yTmFtZSkge1xuICAgcmV2ZXJzZU5hbWVzW2NvbG9yTmFtZVtuYW1lXV0gPSBuYW1lO1xufVxuXG4vKiBNSVQgbGljZW5zZSAqL1xuXG5cblxudmFyIENvbG9yID0gZnVuY3Rpb24gKG9iaikge1xuXHRpZiAob2JqIGluc3RhbmNlb2YgQ29sb3IpIHtcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2xvcikpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKG9iaik7XG5cdH1cblxuXHR0aGlzLnZhbGlkID0gZmFsc2U7XG5cdHRoaXMudmFsdWVzID0ge1xuXHRcdHJnYjogWzAsIDAsIDBdLFxuXHRcdGhzbDogWzAsIDAsIDBdLFxuXHRcdGhzdjogWzAsIDAsIDBdLFxuXHRcdGh3YjogWzAsIDAsIDBdLFxuXHRcdGNteWs6IFswLCAwLCAwLCAwXSxcblx0XHRhbHBoYTogMVxuXHR9O1xuXG5cdC8vIHBhcnNlIENvbG9yKCkgYXJndW1lbnRcblx0dmFyIHZhbHM7XG5cdGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuXHRcdHZhbHMgPSBjb2xvclN0cmluZy5nZXRSZ2JhKG9iaik7XG5cdFx0aWYgKHZhbHMpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMgPSBjb2xvclN0cmluZy5nZXRIc2xhKG9iaikpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMgPSBjb2xvclN0cmluZy5nZXRId2Iob2JqKSkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIHZhbHMpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuXHRcdHZhbHMgPSBvYmo7XG5cdFx0aWYgKHZhbHMuciAhPT0gdW5kZWZpbmVkIHx8IHZhbHMucmVkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMubCAhPT0gdW5kZWZpbmVkIHx8IHZhbHMubGlnaHRuZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMudiAhPT0gdW5kZWZpbmVkIHx8IHZhbHMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzdicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy53ICE9PSB1bmRlZmluZWQgfHwgdmFscy53aGl0ZW5lc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIHZhbHMpO1xuXHRcdH0gZWxzZSBpZiAodmFscy5jICE9PSB1bmRlZmluZWQgfHwgdmFscy5jeWFuICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdjbXlrJywgdmFscyk7XG5cdFx0fVxuXHR9XG59O1xuXG5Db2xvci5wcm90b3R5cGUgPSB7XG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWxpZDtcblx0fSxcblx0cmdiOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ3JnYicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGhzbDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdoc2wnLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRoc3Y6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHN2JywgYXJndW1lbnRzKTtcblx0fSxcblx0aHdiOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2h3YicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGNteWs6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnY215aycsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0cmdiQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMucmdiO1xuXHR9LFxuXHRoc2xBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5oc2w7XG5cdH0sXG5cdGhzdkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLmhzdjtcblx0fSxcblx0aHdiQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0aWYgKHZhbHVlcy5hbHBoYSAhPT0gMSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlcy5od2IuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlcy5od2I7XG5cdH0sXG5cdGNteWtBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5jbXlrO1xuXHR9LFxuXHRyZ2JhQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdFx0cmV0dXJuIHZhbHVlcy5yZ2IuY29uY2F0KFt2YWx1ZXMuYWxwaGFdKTtcblx0fSxcblx0aHNsYUFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXMuaHNsLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdH0sXG5cdGFscGhhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0fVxuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIHZhbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVkOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMCwgdmFsKTtcblx0fSxcblx0Z3JlZW46IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdyZ2InLCAxLCB2YWwpO1xuXHR9LFxuXHRibHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMiwgdmFsKTtcblx0fSxcblx0aHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKHZhbCkge1xuXHRcdFx0dmFsICU9IDM2MDtcblx0XHRcdHZhbCA9IHZhbCA8IDAgPyAzNjAgKyB2YWwgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzbCcsIDAsIHZhbCk7XG5cdH0sXG5cdHNhdHVyYXRpb246IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAxLCB2YWwpO1xuXHR9LFxuXHRsaWdodG5lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAyLCB2YWwpO1xuXHR9LFxuXHRzYXR1cmF0aW9udjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzdicsIDEsIHZhbCk7XG5cdH0sXG5cdHdoaXRlbmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2h3YicsIDEsIHZhbCk7XG5cdH0sXG5cdGJsYWNrbmVzczogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2h3YicsIDIsIHZhbCk7XG5cdH0sXG5cdHZhbHVlOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHN2JywgMiwgdmFsKTtcblx0fSxcblx0Y3lhbjogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAwLCB2YWwpO1xuXHR9LFxuXHRtYWdlbnRhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnY215aycsIDEsIHZhbCk7XG5cdH0sXG5cdHllbGxvdzogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAyLCB2YWwpO1xuXHR9LFxuXHRibGFjazogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAzLCB2YWwpO1xuXHR9LFxuXG5cdGhleFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5oZXhTdHJpbmcodGhpcy52YWx1ZXMucmdiKTtcblx0fSxcblx0cmdiU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnJnYlN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0cmdiYVN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5yZ2JhU3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRwZXJjZW50U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnBlcmNlbnRTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGhzbFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5oc2xTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGhzbGFTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaHNsYVN0cmluZyh0aGlzLnZhbHVlcy5oc2wsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0aHdiU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmh3YlN0cmluZyh0aGlzLnZhbHVlcy5od2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0a2V5d29yZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5rZXl3b3JkKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXG5cdHJnYk51bWJlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0cmV0dXJuIChyZ2JbMF0gPDwgMTYpIHwgKHJnYlsxXSA8PCA4KSB8IHJnYlsyXTtcblx0fSxcblxuXHRsdW1pbm9zaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0dmFyIGx1bSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hhbiA9IHJnYltpXSAvIDI1NTtcblx0XHRcdGx1bVtpXSA9IChjaGFuIDw9IDAuMDM5MjgpID8gY2hhbiAvIDEyLjkyIDogTWF0aC5wb3coKChjaGFuICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC4yMTI2ICogbHVtWzBdICsgMC43MTUyICogbHVtWzFdICsgMC4wNzIyICogbHVtWzJdO1xuXHR9LFxuXG5cdGNvbnRyYXN0OiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNjb250cmFzdC1yYXRpb2RlZlxuXHRcdHZhciBsdW0xID0gdGhpcy5sdW1pbm9zaXR5KCk7XG5cdFx0dmFyIGx1bTIgPSBjb2xvcjIubHVtaW5vc2l0eSgpO1xuXHRcdGlmIChsdW0xID4gbHVtMikge1xuXHRcdFx0cmV0dXJuIChsdW0xICsgMC4wNSkgLyAobHVtMiArIDAuMDUpO1xuXHRcdH1cblx0XHRyZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG5cdH0sXG5cblx0bGV2ZWw6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHR2YXIgY29udHJhc3RSYXRpbyA9IHRoaXMuY29udHJhc3QoY29sb3IyKTtcblx0XHRpZiAoY29udHJhc3RSYXRpbyA+PSA3LjEpIHtcblx0XHRcdHJldHVybiAnQUFBJztcblx0XHR9XG5cblx0XHRyZXR1cm4gKGNvbnRyYXN0UmF0aW8gPj0gNC41KSA/ICdBQScgOiAnJztcblx0fSxcblxuXHRkYXJrOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gWUlRIGVxdWF0aW9uIGZyb20gaHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxuXHRcdHZhciByZ2IgPSB0aGlzLnZhbHVlcy5yZ2I7XG5cdFx0dmFyIHlpcSA9IChyZ2JbMF0gKiAyOTkgKyByZ2JbMV0gKiA1ODcgKyByZ2JbMl0gKiAxMTQpIC8gMTAwMDtcblx0XHRyZXR1cm4geWlxIDwgMTI4O1xuXHR9LFxuXG5cdGxpZ2h0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICF0aGlzLmRhcmsoKTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYltpXSA9IDI1NSAtIHRoaXMudmFsdWVzLnJnYltpXTtcblx0XHR9XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ3JnYicsIHJnYik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0bGlnaHRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMl0gKz0gaHNsWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGFya2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdGhzbFsyXSAtPSBoc2xbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMV0gKz0gaHNsWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZGVzYXR1cmF0ZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMV0gLT0gaHNsWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d2hpdGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy52YWx1ZXMuaHdiO1xuXHRcdGh3YlsxXSArPSBod2JbMV0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgaHdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRibGFja2VuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHdiID0gdGhpcy52YWx1ZXMuaHdiO1xuXHRcdGh3YlsyXSArPSBod2JbMl0gKiByYXRpbztcblx0XHR0aGlzLnNldFZhbHVlcygnaHdiJywgaHdiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRncmV5c2NhbGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JheXNjYWxlI0NvbnZlcnRpbmdfY29sb3JfdG9fZ3JheXNjYWxlXG5cdFx0dmFyIHZhbCA9IHJnYlswXSAqIDAuMyArIHJnYlsxXSAqIDAuNTkgKyByZ2JbMl0gKiAwLjExO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCBbdmFsLCB2YWwsIHZhbF0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsZWFyZXI6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBhbHBoYSA9IHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdhbHBoYScsIGFscGhhIC0gKGFscGhhICogcmF0aW8pKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvcGFxdWVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgYWxwaGEgPSB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCBhbHBoYSArIChhbHBoYSAqIHJhdGlvKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbiAoZGVncmVlcykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0dmFyIGh1ZSA9IChoc2xbMF0gKyBkZWdyZWVzKSAlIDM2MDtcblx0XHRoc2xbMF0gPSBodWUgPCAwID8gMzYwICsgaHVlIDogaHVlO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQb3J0ZWQgZnJvbSBzYXNzIGltcGxlbWVudGF0aW9uIGluIENcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL3Nhc3MvbGlic2Fzcy9ibG9iLzBlNmI0YTI4NTAwOTIzNTZhYTNlY2UwN2M2YjI0OWYwMjIxY2FjZWQvZnVuY3Rpb25zLmNwcCNMMjA5XG5cdCAqL1xuXHRtaXg6IGZ1bmN0aW9uIChtaXhpbkNvbG9yLCB3ZWlnaHQpIHtcblx0XHR2YXIgY29sb3IxID0gdGhpcztcblx0XHR2YXIgY29sb3IyID0gbWl4aW5Db2xvcjtcblx0XHR2YXIgcCA9IHdlaWdodCA9PT0gdW5kZWZpbmVkID8gMC41IDogd2VpZ2h0O1xuXG5cdFx0dmFyIHcgPSAyICogcCAtIDE7XG5cdFx0dmFyIGEgPSBjb2xvcjEuYWxwaGEoKSAtIGNvbG9yMi5hbHBoYSgpO1xuXG5cdFx0dmFyIHcxID0gKCgodyAqIGEgPT09IC0xKSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG5cdFx0dmFyIHcyID0gMSAtIHcxO1xuXG5cdFx0cmV0dXJuIHRoaXNcblx0XHRcdC5yZ2IoXG5cdFx0XHRcdHcxICogY29sb3IxLnJlZCgpICsgdzIgKiBjb2xvcjIucmVkKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmdyZWVuKCkgKyB3MiAqIGNvbG9yMi5ncmVlbigpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ibHVlKCkgKyB3MiAqIGNvbG9yMi5ibHVlKClcblx0XHRcdClcblx0XHRcdC5hbHBoYShjb2xvcjEuYWxwaGEoKSAqIHAgKyBjb2xvcjIuYWxwaGEoKSAqICgxIC0gcCkpO1xuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnJnYigpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gTk9URShTQik6IHVzaW5nIG5vZGUtY2xvbmUgY3JlYXRlcyBhIGRlcGVuZGVuY3kgdG8gQnVmZmVyIHdoZW4gdXNpbmcgYnJvd3NlcmlmeSxcblx0XHQvLyBtYWtpbmcgdGhlIGZpbmFsIGJ1aWxkIHdheSB0byBiaWcgdG8gZW1iZWQgaW4gQ2hhcnQuanMuIFNvIGxldCdzIGRvIGl0IG1hbnVhbGx5LFxuXHRcdC8vIGFzc3VtaW5nIHRoYXQgdmFsdWVzIHRvIGNsb25lIGFyZSAxIGRpbWVuc2lvbiBhcnJheXMgY29udGFpbmluZyBvbmx5IG51bWJlcnMsXG5cdFx0Ly8gZXhjZXB0ICdhbHBoYScgd2hpY2ggaXMgYSBudW1iZXIuXG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBDb2xvcigpO1xuXHRcdHZhciBzb3VyY2UgPSB0aGlzLnZhbHVlcztcblx0XHR2YXIgdGFyZ2V0ID0gcmVzdWx0LnZhbHVlcztcblx0XHR2YXIgdmFsdWUsIHR5cGU7XG5cblx0XHRmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuXHRcdFx0aWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcblx0XHRcdFx0dHlwZSA9ICh7fSkudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gdmFsdWUuc2xpY2UoMCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcblx0XHRcdFx0XHR0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCd1bmV4cGVjdGVkIGNvbG9yIHZhbHVlOicsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zcGFjZXMgPSB7XG5cdHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG5cdGhzdjogWydodWUnLCAnc2F0dXJhdGlvbicsICd2YWx1ZSddLFxuXHRod2I6IFsnaHVlJywgJ3doaXRlbmVzcycsICdibGFja25lc3MnXSxcblx0Y215azogWydjeWFuJywgJ21hZ2VudGEnLCAneWVsbG93JywgJ2JsYWNrJ11cbn07XG5cbkNvbG9yLnByb3RvdHlwZS5tYXhlcyA9IHtcblx0cmdiOiBbMjU1LCAyNTUsIDI1NV0sXG5cdGhzbDogWzM2MCwgMTAwLCAxMDBdLFxuXHRoc3Y6IFszNjAsIDEwMCwgMTAwXSxcblx0aHdiOiBbMzYwLCAxMDAsIDEwMF0sXG5cdGNteWs6IFsxMDAsIDEwMCwgMTAwLCAxMDBdXG59O1xuXG5Db2xvci5wcm90b3R5cGUuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwYWNlKSB7XG5cdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0dmFyIHZhbHMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFsc1tzcGFjZS5jaGFyQXQoaSldID0gdmFsdWVzW3NwYWNlXVtpXTtcblx0fVxuXG5cdGlmICh2YWx1ZXMuYWxwaGEgIT09IDEpIHtcblx0XHR2YWxzLmEgPSB2YWx1ZXMuYWxwaGE7XG5cdH1cblxuXHQvLyB7cjogMjU1LCBnOiAyNTUsIGI6IDI1NSwgYTogMC40fVxuXHRyZXR1cm4gdmFscztcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAoc3BhY2UsIHZhbHMpIHtcblx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHR2YXIgc3BhY2VzID0gdGhpcy5zcGFjZXM7XG5cdHZhciBtYXhlcyA9IHRoaXMubWF4ZXM7XG5cdHZhciBhbHBoYSA9IDE7XG5cdHZhciBpO1xuXG5cdHRoaXMudmFsaWQgPSB0cnVlO1xuXG5cdGlmIChzcGFjZSA9PT0gJ2FscGhhJykge1xuXHRcdGFscGhhID0gdmFscztcblx0fSBlbHNlIGlmICh2YWxzLmxlbmd0aCkge1xuXHRcdC8vIFsxMCwgMTAsIDEwXVxuXHRcdHZhbHVlc1tzcGFjZV0gPSB2YWxzLnNsaWNlKDAsIHNwYWNlLmxlbmd0aCk7XG5cdFx0YWxwaGEgPSB2YWxzW3NwYWNlLmxlbmd0aF07XG5cdH0gZWxzZSBpZiAodmFsc1tzcGFjZS5jaGFyQXQoMCldICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyB7cjogMTAsIGc6IDEwLCBiOiAxMH1cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW3NwYWNlLmNoYXJBdChpKV07XG5cdFx0fVxuXG5cdFx0YWxwaGEgPSB2YWxzLmE7XG5cdH0gZWxzZSBpZiAodmFsc1tzcGFjZXNbc3BhY2VdWzBdXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8ge3JlZDogMTAsIGdyZWVuOiAxMCwgYmx1ZTogMTB9XG5cdFx0dmFyIGNoYW5zID0gc3BhY2VzW3NwYWNlXTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFsdWVzW3NwYWNlXVtpXSA9IHZhbHNbY2hhbnNbaV1dO1xuXHRcdH1cblxuXHRcdGFscGhhID0gdmFscy5hbHBoYTtcblx0fVxuXG5cdHZhbHVlcy5hbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChhbHBoYSA9PT0gdW5kZWZpbmVkID8gdmFsdWVzLmFscGhhIDogYWxwaGEpKSk7XG5cblx0aWYgKHNwYWNlID09PSAnYWxwaGEnKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIGNhcHBlZDtcblxuXHQvLyBjYXAgdmFsdWVzIG9mIHRoZSBzcGFjZSBwcmlvciBjb252ZXJ0aW5nIGFsbCB2YWx1ZXNcblx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2FwcGVkID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4ZXNbc3BhY2VdW2ldLCB2YWx1ZXNbc3BhY2VdW2ldKSk7XG5cdFx0dmFsdWVzW3NwYWNlXVtpXSA9IE1hdGgucm91bmQoY2FwcGVkKTtcblx0fVxuXG5cdC8vIGNvbnZlcnQgdG8gYWxsIHRoZSBvdGhlciBjb2xvciBzcGFjZXNcblx0Zm9yICh2YXIgc25hbWUgaW4gc3BhY2VzKSB7XG5cdFx0aWYgKHNuYW1lICE9PSBzcGFjZSkge1xuXHRcdFx0dmFsdWVzW3NuYW1lXSA9IGNvbG9yQ29udmVydFtzcGFjZV1bc25hbWVdKHZhbHVlc1tzcGFjZV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldFNwYWNlID0gZnVuY3Rpb24gKHNwYWNlLCBhcmdzKSB7XG5cdHZhciB2YWxzID0gYXJnc1swXTtcblxuXHRpZiAodmFscyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gY29sb3IucmdiKClcblx0XHRyZXR1cm4gdGhpcy5nZXRWYWx1ZXMoc3BhY2UpO1xuXHR9XG5cblx0Ly8gY29sb3IucmdiKDEwLCAxMCwgMTApXG5cdGlmICh0eXBlb2YgdmFscyA9PT0gJ251bWJlcicpIHtcblx0XHR2YWxzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG5cdH1cblxuXHR0aGlzLnNldFZhbHVlcyhzcGFjZSwgdmFscyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuQ29sb3IucHJvdG90eXBlLnNldENoYW5uZWwgPSBmdW5jdGlvbiAoc3BhY2UsIGluZGV4LCB2YWwpIHtcblx0dmFyIHN2YWx1ZXMgPSB0aGlzLnZhbHVlc1tzcGFjZV07XG5cdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIGNvbG9yLnJlZCgpXG5cdFx0cmV0dXJuIHN2YWx1ZXNbaW5kZXhdO1xuXHR9IGVsc2UgaWYgKHZhbCA9PT0gc3ZhbHVlc1tpbmRleF0pIHtcblx0XHQvLyBjb2xvci5yZWQoY29sb3IucmVkKCkpXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvLyBjb2xvci5yZWQoMTAwKVxuXHRzdmFsdWVzW2luZGV4XSA9IHZhbDtcblx0dGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHN2YWx1ZXMpO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5Db2xvciA9IENvbG9yO1xufVxuXG52YXIgY2hhcnRqc0NvbG9yID0gQ29sb3I7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzXG4gKi9cbnZhciBoZWxwZXJzID0ge1xuXHQvKipcblx0ICogQW4gZW1wdHkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIGZvciBvcHRpb25hbCBjYWxsYmFjay5cblx0ICovXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB1bmlxdWUgaWQsIHNlcXVlbnRpYWxseSBnZW5lcmF0ZWQgZnJvbSBhIGdsb2JhbCB2YXJpYWJsZS5cblx0ICogQHJldHVybnMge251bWJlcn1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHR1aWQ6IChmdW5jdGlvbigpIHtcblx0XHR2YXIgaWQgPSAwO1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBpZCsrO1xuXHRcdH07XG5cdH0oKSksXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG5laXRoZXIgbnVsbCBub3IgdW5kZWZpbmVkLCBlbHNlIHJldHVybnMgZmFsc2UuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0aXNOdWxsT3JVbmRlZjogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgKGluY2x1ZGluZyB0eXBlZCBhcnJheXMpLCBlbHNlIHJldHVybnMgZmFsc2UuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0aXNBcnJheTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblx0XHRpZiAodHlwZS5zdWJzdHIoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnN1YnN0cigtNikgPT09ICdBcnJheV0nKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QgKGV4Y2x1ZGluZyBudWxsKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGlzT2JqZWN0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIHJldHVybnMgZmFsc2Vcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0Zpbml0ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKHZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBgdmFsdWVgIGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cblx0ICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdHZhbHVlT3JEZWZhdWx0OiBmdW5jdGlvbih2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB2YWx1ZSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiBhcnJheSBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlIC0gVGhlIGFycmF5IHRvIGxvb2t1cCBmb3IgdmFsdWUgYXQgYGluZGV4YC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGluIGB2YWx1ZWAgdG8gbG9va3VwIGZvciB2YWx1ZS5cblx0ICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZVtpbmRleF1gIGlzIHVuZGVmaW5lZC5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHR2YWx1ZUF0SW5kZXhPckRlZmF1bHQ6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMudmFsdWVPckRlZmF1bHQoaGVscGVycy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlW2luZGV4XSA6IHZhbHVlLCBkZWZhdWx0VmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxscyBgZm5gIHdpdGggdGhlIGdpdmVuIGBhcmdzYCBpbiB0aGUgc2NvcGUgZGVmaW5lZCBieSBgdGhpc0FyZ2AgYW5kIHJldHVybnMgdGhlXG5cdCAqIHZhbHVlIHJldHVybmVkIGJ5IGBmbmAuIElmIGBmbmAgaXMgbm90IGEgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuXHQgKiBAcGFyYW0ge0FycmF5fHVuZGVmaW5lZHxudWxsfSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB3aXRoIHdoaWNoIGBmbmAgc2hvdWxkIGJlIGNhbGxlZC5cblx0ICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGlzQXJnKSB7XG5cdFx0aWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBOb3RlKFNCKSBmb3IgcGVyZm9ybWFuY2Ugc2FrZSwgdGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIGxvb3BhYmxlIHR5cGVcblx0ICogaXMgdW5rbm93biBvciBpbiBub25lIGludGVuc2l2ZSBjb2RlIChub3QgY2FsbGVkIG9mdGVuIGFuZCBzbWFsbCBsb29wYWJsZSkuIEVsc2Vcblx0ICogaXQncyBwcmVmZXJhYmxlIHRvIHVzZSBhIHJlZ3VsYXIgZm9yKCkgbG9vcCBhbmQgc2F2ZSBleHRyYSBmdW5jdGlvbiBjYWxscy5cblx0ICogQHBhcmFtIHtvYmplY3R8QXJyYXl9IGxvb3BhYmxlIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSBpdGVyYXRlZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gLSBJZiB0cnVlLCBpdGVyYXRlcyBiYWNrd2FyZCBvbiB0aGUgbG9vcGFibGUuXG5cdCAqL1xuXHRlYWNoOiBmdW5jdGlvbihsb29wYWJsZSwgZm4sIHRoaXNBcmcsIHJldmVyc2UpIHtcblx0XHR2YXIgaSwgbGVuLCBrZXlzO1xuXHRcdGlmIChoZWxwZXJzLmlzQXJyYXkobG9vcGFibGUpKSB7XG5cdFx0XHRsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG5cdFx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0XHRmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaGVscGVycy5pc09iamVjdChsb29wYWJsZSkpIHtcblx0XHRcdGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG5cdFx0XHRsZW4gPSBrZXlzLmxlbmd0aDtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYGEwYCBhbmQgYGExYCBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LCBlbHNlIHJldHVybnMgZmFsc2UuXG5cdCAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0ODUzOTc0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IGEwIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcblx0ICogQHBhcmFtIHtBcnJheX0gYTEgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGFycmF5RXF1YWxzOiBmdW5jdGlvbihhMCwgYTEpIHtcblx0XHR2YXIgaSwgaWxlbiwgdjAsIHYxO1xuXG5cdFx0aWYgKCFhMCB8fCAhYTEgfHwgYTAubGVuZ3RoICE9PSBhMS5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR2MCA9IGEwW2ldO1xuXHRcdFx0djEgPSBhMVtpXTtcblxuXHRcdFx0aWYgKHYwIGluc3RhbmNlb2YgQXJyYXkgJiYgdjEgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRpZiAoIWhlbHBlcnMuYXJyYXlFcXVhbHModjAsIHYxKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh2MCAhPT0gdjEpIHtcblx0XHRcdFx0Ly8gTk9URTogdHdvIGRpZmZlcmVudCBvYmplY3QgaW5zdGFuY2VzIHdpbGwgbmV2ZXIgYmUgZXF1YWw6IHt4OjIwfSAhPSB7eDoyMH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cblx0ICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgdmFsdWUgdG8gY2xvbmUuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0Y2xvbmU6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdGlmIChoZWxwZXJzLmlzQXJyYXkoc291cmNlKSkge1xuXHRcdFx0cmV0dXJuIHNvdXJjZS5tYXAoaGVscGVycy5jbG9uZSk7XG5cdFx0fVxuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3Qoc291cmNlKSkge1xuXHRcdFx0dmFyIHRhcmdldCA9IHt9O1xuXHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuXHRcdFx0dmFyIGtsZW4gPSBrZXlzLmxlbmd0aDtcblx0XHRcdHZhciBrID0gMDtcblxuXHRcdFx0Zm9yICg7IGsgPCBrbGVuOyArK2spIHtcblx0XHRcdFx0dGFyZ2V0W2tleXNba11dID0gaGVscGVycy5jbG9uZShzb3VyY2Vba2V5c1trXV0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdHJldHVybiBzb3VyY2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0IG1lcmdlciB3aGVuIENoYXJ0LmhlbHBlcnMubWVyZ2UgaXMgY2FsbGVkIHdpdGhvdXQgbWVyZ2VyIG9wdGlvbi5cblx0ICogTm90ZShTQik6IGFsc28gdXNlZCBieSBtZXJnZUNvbmZpZyBhbmQgbWVyZ2VTY2FsZUNvbmZpZyBhcyBmYWxsYmFjay5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9tZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldO1xuXHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XG5cblx0XHRpZiAoaGVscGVycy5pc09iamVjdCh0dmFsKSAmJiBoZWxwZXJzLmlzT2JqZWN0KHN2YWwpKSB7XG5cdFx0XHRoZWxwZXJzLm1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMuY2xvbmUoc3ZhbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBNZXJnZXMgc291cmNlW2tleV0gaW4gdGFyZ2V0W2tleV0gb25seSBpZiB0YXJnZXRba2V5XSBpcyB1bmRlZmluZWQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbWVyZ2VySWY6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UpIHtcblx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldO1xuXHRcdHZhciBzdmFsID0gc291cmNlW2tleV07XG5cblx0XHRpZiAoaGVscGVycy5pc09iamVjdCh0dmFsKSAmJiBoZWxwZXJzLmlzT2JqZWN0KHN2YWwpKSB7XG5cdFx0XHRoZWxwZXJzLm1lcmdlSWYodHZhbCwgc3ZhbCk7XG5cdFx0fSBlbHNlIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHRhcmdldFtrZXldID0gaGVscGVycy5jbG9uZShzdmFsKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG5cdCAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cblx0ICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gTWVyZ2luZyBvcHRpb25zOlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbb3B0aW9ucy5tZXJnZXJdIC0gVGhlIG1lcmdlIG1ldGhvZCAoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cblx0ICovXG5cdG1lcmdlOiBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdHZhciBzb3VyY2VzID0gaGVscGVycy5pc0FycmF5KHNvdXJjZSkgPyBzb3VyY2UgOiBbc291cmNlXTtcblx0XHR2YXIgaWxlbiA9IHNvdXJjZXMubGVuZ3RoO1xuXHRcdHZhciBtZXJnZSwgaSwga2V5cywga2xlbiwgaztcblxuXHRcdGlmICghaGVscGVycy5pc09iamVjdCh0YXJnZXQpKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdG1lcmdlID0gb3B0aW9ucy5tZXJnZXIgfHwgaGVscGVycy5fbWVyZ2VyO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0c291cmNlID0gc291cmNlc1tpXTtcblx0XHRcdGlmICghaGVscGVycy5pc09iamVjdChzb3VyY2UpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblx0XHRcdGZvciAoayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsraykge1xuXHRcdFx0XHRtZXJnZShrZXlzW2tdLCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSxcblxuXHQvKipcblx0ICogUmVjdXJzaXZlbHkgZGVlcCBjb3BpZXMgYHNvdXJjZWAgcHJvcGVydGllcyBpbnRvIGB0YXJnZXRgICpvbmx5KiBpZiBub3QgZGVmaW5lZCBpbiB0YXJnZXQuXG5cdCAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cblx0ICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W119IHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgYHRhcmdldGAgb2JqZWN0LlxuXHQgKi9cblx0bWVyZ2VJZjogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcblx0XHRyZXR1cm4gaGVscGVycy5tZXJnZSh0YXJnZXQsIHNvdXJjZSwge21lcmdlcjogaGVscGVycy5fbWVyZ2VySWZ9KTtcblx0fSxcblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgY29udGVudHMgb2YgdHdvIG9yIG1vcmUgb2JqZWN0cyB0b2dldGhlciBpbnRvIHRoZSBmaXJzdCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgb2JqZWN0cyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmcxIC0gT2JqZWN0IGNvbnRhaW5pbmcgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIG1lcmdlIGluIHRhcmdldC5cblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ04gLSBBZGRpdGlvbmFsIG9iamVjdHMgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIG1lcmdlIGluIHRhcmdldC5cblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cblx0ICovXG5cdGV4dGVuZDogZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0dmFyIHNldEZuID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0dGFyZ2V0W2tleV0gPSB2YWx1ZTtcblx0XHR9O1xuXHRcdGZvciAodmFyIGkgPSAxLCBpbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aGVscGVycy5lYWNoKGFyZ3VtZW50c1tpXSwgc2V0Rm4pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBCYXNpYyBqYXZhc2NyaXB0IGluaGVyaXRhbmNlIGJhc2VkIG9uIHRoZSBtb2RlbCBjcmVhdGVkIGluIEJhY2tib25lLmpzXG5cdCAqL1xuXHRpbmhlcml0czogZnVuY3Rpb24oZXh0ZW5zaW9ucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIENoYXJ0RWxlbWVudCA9IChleHRlbnNpb25zICYmIGV4dGVuc2lvbnMuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykpID8gZXh0ZW5zaW9ucy5jb25zdHJ1Y3RvciA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY29uc3RydWN0b3IgPSBDaGFydEVsZW1lbnQ7XG5cdFx0fTtcblxuXHRcdFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBtZS5wcm90b3R5cGU7XG5cdFx0Q2hhcnRFbGVtZW50LnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGUoKTtcblx0XHRDaGFydEVsZW1lbnQuZXh0ZW5kID0gaGVscGVycy5pbmhlcml0cztcblxuXHRcdGlmIChleHRlbnNpb25zKSB7XG5cdFx0XHRoZWxwZXJzLmV4dGVuZChDaGFydEVsZW1lbnQucHJvdG90eXBlLCBleHRlbnNpb25zKTtcblx0XHR9XG5cblx0XHRDaGFydEVsZW1lbnQuX19zdXBlcl9fID0gbWUucHJvdG90eXBlO1xuXHRcdHJldHVybiBDaGFydEVsZW1lbnQ7XG5cdH1cbn07XG5cbnZhciBoZWxwZXJzX2NvcmUgPSBoZWxwZXJzO1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FsbGJhY2sgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmNhbGxDYWxsYmFja1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5jYWxsQ2FsbGJhY2sgPSBoZWxwZXJzLmNhbGxiYWNrO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgaW5zdGVhZC5cbiAqIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGNvbXBhdGliaWxpdHk6IENocm9tZSwgT3BlcmEsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5pbmRleE9mXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbUluZGV4KSB7XG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGFycmF5LCBpdGVtLCBmcm9tSW5kZXgpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMudmFsdWVPckRlZmF1bHQgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmdldFZhbHVlT3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZU9yRGVmYXVsdDtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0IGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5nZXRWYWx1ZUF0SW5kZXhPckRlZmF1bHRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0ID0gaGVscGVycy52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gUm9iZXJ0IFBlbm5lcidzIGVhc2luZyBlcXVhdGlvbnMuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nRWZmZWN0c1xuICogQHNlZSBodHRwOi8vd3d3LnJvYmVydHBlbm5lci5jb20vZWFzaW5nL1xuICovXG52YXIgZWZmZWN0cyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQ7XG5cdH0sXG5cblx0ZWFzZUluUXVhZDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtdCAqICh0IC0gMik7XG5cdH0sXG5cblx0ZWFzZUluT3V0UXVhZDogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLTAuNSAqICgoLS10KSAqICh0IC0gMikgLSAxKTtcblx0fSxcblxuXHRlYXNlSW5DdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dEN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqIHQgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKyAyKTtcblx0fSxcblxuXHRlYXNlSW5RdWFydDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRRdWFydDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtKCh0ID0gdCAtIDEpICogdCAqIHQgKiB0IC0gMSk7XG5cdH0sXG5cblx0ZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLTAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpO1xuXHR9LFxuXG5cdGVhc2VJblF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRRdWludDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdCAqIHQ7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XG5cdH0sXG5cblx0ZWFzZUluU2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtTWF0aC5jb3ModCAqIChNYXRoLlBJIC8gMikpICsgMTtcblx0fSxcblxuXHRlYXNlT3V0U2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNpbih0ICogKE1hdGguUEkgLyAyKSk7XG5cdH0sXG5cblx0ZWFzZUluT3V0U2luZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAtMC41ICogKE1hdGguY29zKE1hdGguUEkgKiB0KSAtIDEpO1xuXHR9LFxuXG5cdGVhc2VJbkV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG5cdH0sXG5cblx0ZWFzZU91dEV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPT09IDEpID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0RXhwbzogZnVuY3Rpb24odCkge1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAtLXQpICsgMik7XG5cdH0sXG5cblx0ZWFzZUluQ2lyYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICh0ID49IDEpIHtcblx0XHRcdHJldHVybiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuXHR9LFxuXG5cdGVhc2VPdXRDaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydCgxIC0gKHQgPSB0IC0gMSkgKiB0KTtcblx0fSxcblxuXHRlYXNlSW5PdXRDaXJjOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpO1xuXHR9LFxuXG5cdGVhc2VJbkVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHZhciBhID0gMTtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCFwKSB7XG5cdFx0XHRwID0gMC4zO1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0fSxcblxuXHRlYXNlT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxO1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKHQgPT09IDEpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoIXApIHtcblx0XHRcdHAgPSAwLjM7XG5cdFx0fVxuXHRcdGlmIChhIDwgMSkge1xuXHRcdFx0YSA9IDE7XG5cdFx0XHRzID0gcCAvIDQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cdFx0fVxuXHRcdHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHZhciBwID0gMDtcblx0XHR2YXIgYSA9IDE7XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRpZiAoKHQgLz0gMC41KSA9PT0gMikge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdGlmICghcCkge1xuXHRcdFx0cCA9IDAuNDU7XG5cdFx0fVxuXHRcdGlmIChhIDwgMSkge1xuXHRcdFx0YSA9IDE7XG5cdFx0XHRzID0gcCAvIDQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG5cdFx0fVxuXHRcdGlmICh0IDwgMSkge1xuXHRcdFx0cmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdFx0fVxuXHRcdHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG5cdH0sXG5cdGVhc2VJbkJhY2s6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0cmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG5cdH0sXG5cblx0ZWFzZU91dEJhY2s6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0cmV0dXJuICh0ID0gdCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG5cdFx0fVxuXHRcdHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG5cdH0sXG5cblx0ZWFzZUluQm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuIDEgLSBlZmZlY3RzLmVhc2VPdXRCb3VuY2UoMSAtIHQpO1xuXHR9LFxuXG5cdGVhc2VPdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA8ICgxIC8gMi43NSkpIHtcblx0XHRcdHJldHVybiA3LjU2MjUgKiB0ICogdDtcblx0XHR9XG5cdFx0aWYgKHQgPCAoMiAvIDIuNzUpKSB7XG5cdFx0XHRyZXR1cm4gNy41NjI1ICogKHQgLT0gKDEuNSAvIDIuNzUpKSAqIHQgKyAwLjc1O1xuXHRcdH1cblx0XHRpZiAodCA8ICgyLjUgLyAyLjc1KSkge1xuXHRcdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgyLjI1IC8gMi43NSkpICogdCArIDAuOTM3NTtcblx0XHR9XG5cdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgyLjYyNSAvIDIuNzUpKSAqIHQgKyAwLjk4NDM3NTtcblx0fSxcblxuXHRlYXNlSW5PdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA8IDAuNSkge1xuXHRcdFx0cmV0dXJuIGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNTtcblx0XHR9XG5cdFx0cmV0dXJuIGVmZmVjdHMuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41O1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19lYXNpbmcgPSB7XG5cdGVmZmVjdHM6IGVmZmVjdHNcbn07XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5lYXNpbmcuZWZmZWN0cyBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZWFzaW5nRWZmZWN0c1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVyc19jb3JlLmVhc2luZ0VmZmVjdHMgPSBlZmZlY3RzO1xuXG52YXIgUEkgPSBNYXRoLlBJO1xudmFyIFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG52YXIgRE9VQkxFX1BJID0gUEkgKiAyO1xudmFyIEhBTEZfUEkgPSBQSSAvIDI7XG52YXIgUVVBUlRFUl9QSSA9IFBJIC8gNDtcbnZhciBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuY2FudmFzXG4gKi9cbnZhciBleHBvcnRzJDEgPSB7XG5cdC8qKlxuXHQgKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMgYXNzb2NpYXRlZCB0byB0aGUgZ2l2ZW4gYGNoYXJ0YC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgZm9yIHdoaWNoIHRvIGNsZWFyIHRoZSBjYW52YXMuXG5cdCAqL1xuXHRjbGVhcjogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRjaGFydC5jdHguY2xlYXJSZWN0KDAsIDAsIGNoYXJ0LndpZHRoLCBjaGFydC5oZWlnaHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgXCJwYXRoXCIgZm9yIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIGF0IHBvc2l0aW9uICh4LCB5KSB3aXRoIGFcblx0ICogZ2l2ZW4gc2l6ZSAod2lkdGgsIGhlaWdodCkgYW5kIHRoZSBzYW1lIGByYWRpdXNgIGZvciBhbGwgY29ybmVycy5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIFRoZSBjYW52YXMgMkQgQ29udGV4dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgeCBheGlzIG9mIHRoZSBjb29yZGluYXRlIGZvciB0aGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGF4aXMgb2YgdGhlIGNvb3JkaW5hdGUgZm9yIHRoZSByZWN0YW5nbGUgc3RhcnRpbmcgcG9pbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSByZWN0YW5nbGUncyB3aWR0aC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSByZWN0YW5nbGUncyBoZWlnaHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcm91bmRlZCBhbW91bnQgKGluIHBpeGVscykgZm9yIHRoZSBmb3VyIGNvcm5lcnMuXG5cdCAqIEB0b2RvIGhhbmRsZSBgcmFkaXVzYCBhcyB0b3AtbGVmdCwgdG9wLXJpZ2h0LCBib3R0b20tcmlnaHQsIGJvdHRvbS1sZWZ0IGFycmF5L29iamVjdD9cblx0ICovXG5cdHJvdW5kZWRSZWN0OiBmdW5jdGlvbihjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuXHRcdGlmIChyYWRpdXMpIHtcblx0XHRcdHZhciByID0gTWF0aC5taW4ocmFkaXVzLCBoZWlnaHQgLyAyLCB3aWR0aCAvIDIpO1xuXHRcdFx0dmFyIGxlZnQgPSB4ICsgcjtcblx0XHRcdHZhciB0b3AgPSB5ICsgcjtcblx0XHRcdHZhciByaWdodCA9IHggKyB3aWR0aCAtIHI7XG5cdFx0XHR2YXIgYm90dG9tID0geSArIGhlaWdodCAtIHI7XG5cblx0XHRcdGN0eC5tb3ZlVG8oeCwgdG9wKTtcblx0XHRcdGlmIChsZWZ0IDwgcmlnaHQgJiYgdG9wIDwgYm90dG9tKSB7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCAtUEksIC1IQUxGX1BJKTtcblx0XHRcdFx0Y3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgMCk7XG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIGJvdHRvbSwgciwgMCwgSEFMRl9QSSk7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCBIQUxGX1BJLCBQSSk7XG5cdFx0XHR9IGVsc2UgaWYgKGxlZnQgPCByaWdodCkge1xuXHRcdFx0XHRjdHgubW92ZVRvKGxlZnQsIHkpO1xuXHRcdFx0XHRjdHguYXJjKHJpZ2h0LCB0b3AsIHIsIC1IQUxGX1BJLCBIQUxGX1BJKTtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIEhBTEZfUEksIFBJICsgSEFMRl9QSSk7XG5cdFx0XHR9IGVsc2UgaWYgKHRvcCA8IGJvdHRvbSkge1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCAwKTtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIDAsIFBJKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCAtUEksIFBJKTtcblx0XHRcdH1cblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuXHRcdH1cblx0fSxcblxuXHRkcmF3UG9pbnQ6IGZ1bmN0aW9uKGN0eCwgc3R5bGUsIHJhZGl1cywgeCwgeSwgcm90YXRpb24pIHtcblx0XHR2YXIgdHlwZSwgeE9mZnNldCwgeU9mZnNldCwgc2l6ZSwgY29ybmVyUmFkaXVzO1xuXHRcdHZhciByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcblxuXHRcdGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHR0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcblx0XHRcdGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuXHRcdFx0XHRjdHguZHJhd0ltYWdlKHN0eWxlLCB4IC0gc3R5bGUud2lkdGggLyAyLCB5IC0gc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdHN3aXRjaCAoc3R5bGUpIHtcblx0XHQvLyBEZWZhdWx0IGluY2x1ZGVzIGNpcmNsZVxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgRE9VQkxFX1BJKTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3RyaWFuZ2xlJzpcblx0XHRcdGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcblx0XHRcdHJhZCArPSBUV09fVEhJUkRTX1BJO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuXHRcdFx0cmFkICs9IFRXT19USElSRFNfUEk7XG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdyZWN0Um91bmRlZCc6XG5cdFx0XHQvLyBOT1RFOiB0aGUgcm91bmRlZCByZWN0IGltcGxlbWVudGF0aW9uIGNoYW5nZWQgdG8gdXNlIGBhcmNgIGluc3RlYWQgb2Zcblx0XHRcdC8vIGBxdWFkcmF0aWNDdXJ2ZVRvYCBzaW5jZSBpdCBnZW5lcmF0ZXMgYmV0dGVyIHJlc3VsdHMgd2hlbiByZWN0IGlzXG5cdFx0XHQvLyBhbG1vc3QgYSBjaXJjbGUuIDAuNTE2IChpbnN0ZWFkIG9mIDAuNSkgcHJvZHVjZXMgcmVzdWx0cyB3aXRoIHZpc3VhbGx5XG5cdFx0XHQvLyBjbG9zZXIgcHJvcG9ydGlvbiB0byB0aGUgcHJldmlvdXMgaW1wbCBhbmQgaXQgaXMgaW5zY3JpYmVkIGluIHRoZVxuXHRcdFx0Ly8gY2lyY2xlIHdpdGggYHJhZGl1c2AuIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGUgZm9sbG93aW5nIFBSczpcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81NTk3XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTg1OFxuXHRcdFx0Y29ybmVyUmFkaXVzID0gcmFkaXVzICogMC41MTY7XG5cdFx0XHRzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG5cdFx0XHRjdHguYXJjKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG5cdFx0XHRjdHguYXJjKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xuXHRcdFx0Y3R4LmFyYyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcblx0XHRcdGN0eC5hcmMoeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3JlY3QnOlxuXHRcdFx0aWYgKCFyb3RhdGlvbikge1xuXHRcdFx0XHRzaXplID0gTWF0aC5TUVJUMV8yICogcmFkaXVzO1xuXHRcdFx0XHRjdHgucmVjdCh4IC0gc2l6ZSwgeSAtIHNpemUsIDIgKiBzaXplLCAyICogc2l6ZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmFkICs9IFFVQVJURVJfUEk7XG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0Y2FzZSAncmVjdFJvdCc6XG5cdFx0XHR4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcblx0XHRcdHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuXHRcdFx0Y3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuXHRcdFx0Y3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnY3Jvc3NSb3QnOlxuXHRcdFx0cmFkICs9IFFVQVJURVJfUEk7XG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0Y2FzZSAnY3Jvc3MnOlxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ3N0YXInOlxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2xpbmUnOlxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2Rhc2gnOlxuXHRcdFx0Y3R4Lm1vdmVUbyh4LCB5KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiByYWRpdXMsIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGN0eC5maWxsKCk7XG5cdFx0Y3R4LnN0cm9rZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludCAtIFRoZSBwb2ludCB0byB0ZXN0XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmVhIC0gVGhlIHJlY3RhbmdsZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9pc1BvaW50SW5BcmVhOiBmdW5jdGlvbihwb2ludCwgYXJlYSkge1xuXHRcdHZhciBlcHNpbG9uID0gMWUtNjsgLy8gMWUtNiBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBhY2N1bXVsYXRlZCBlcnJvci5cblxuXHRcdHJldHVybiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gZXBzaWxvbiAmJiBwb2ludC54IDwgYXJlYS5yaWdodCArIGVwc2lsb24gJiZcblx0XHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIGVwc2lsb24gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgZXBzaWxvbjtcblx0fSxcblxuXHRjbGlwQXJlYTogZnVuY3Rpb24oY3R4LCBhcmVhKSB7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3QoYXJlYS5sZWZ0LCBhcmVhLnRvcCwgYXJlYS5yaWdodCAtIGFyZWEubGVmdCwgYXJlYS5ib3R0b20gLSBhcmVhLnRvcCk7XG5cdFx0Y3R4LmNsaXAoKTtcblx0fSxcblxuXHR1bmNsaXBBcmVhOiBmdW5jdGlvbihjdHgpIHtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9LFxuXG5cdGxpbmVUbzogZnVuY3Rpb24oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwKSB7XG5cdFx0dmFyIHN0ZXBwZWQgPSB0YXJnZXQuc3RlcHBlZExpbmU7XG5cdFx0aWYgKHN0ZXBwZWQpIHtcblx0XHRcdGlmIChzdGVwcGVkID09PSAnbWlkZGxlJykge1xuXHRcdFx0XHR2YXIgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcblx0XHRcdFx0Y3R4LmxpbmVUbyhtaWRwb2ludCwgZmxpcCA/IHRhcmdldC55IDogcHJldmlvdXMueSk7XG5cdFx0XHRcdGN0eC5saW5lVG8obWlkcG9pbnQsIGZsaXAgPyBwcmV2aW91cy55IDogdGFyZ2V0LnkpO1xuXHRcdFx0fSBlbHNlIGlmICgoc3RlcHBlZCA9PT0gJ2FmdGVyJyAmJiAhZmxpcCkgfHwgKHN0ZXBwZWQgIT09ICdhZnRlcicgJiYgZmxpcCkpIHtcblx0XHRcdFx0Y3R4LmxpbmVUbyhwcmV2aW91cy54LCB0YXJnZXQueSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcblx0XHRcdH1cblx0XHRcdGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRhcmdldC50ZW5zaW9uKSB7XG5cdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LmJlemllckN1cnZlVG8oXG5cdFx0XHRmbGlwID8gcHJldmlvdXMuY29udHJvbFBvaW50UHJldmlvdXNYIDogcHJldmlvdXMuY29udHJvbFBvaW50TmV4dFgsXG5cdFx0XHRmbGlwID8gcHJldmlvdXMuY29udHJvbFBvaW50UHJldmlvdXNZIDogcHJldmlvdXMuY29udHJvbFBvaW50TmV4dFksXG5cdFx0XHRmbGlwID8gdGFyZ2V0LmNvbnRyb2xQb2ludE5leHRYIDogdGFyZ2V0LmNvbnRyb2xQb2ludFByZXZpb3VzWCxcblx0XHRcdGZsaXAgPyB0YXJnZXQuY29udHJvbFBvaW50TmV4dFkgOiB0YXJnZXQuY29udHJvbFBvaW50UHJldmlvdXNZLFxuXHRcdFx0dGFyZ2V0LngsXG5cdFx0XHR0YXJnZXQueSk7XG5cdH1cbn07XG5cbnZhciBoZWxwZXJzX2NhbnZhcyA9IGV4cG9ydHMkMTtcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbnZhcy5jbGVhciBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNsZWFyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzX2NvcmUuY2xlYXIgPSBleHBvcnRzJDEuY2xlYXI7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbnZhcy5yb3VuZGVkUmVjdCBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmRyYXdSb3VuZGVkUmVjdGFuZ2xlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzX2NvcmUuZHJhd1JvdW5kZWRSZWN0YW5nbGUgPSBmdW5jdGlvbihjdHgpIHtcblx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRleHBvcnRzJDEucm91bmRlZFJlY3QuYXBwbHkoZXhwb3J0cyQxLCBhcmd1bWVudHMpO1xufTtcblxudmFyIGRlZmF1bHRzID0ge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9zZXQ6IGZ1bmN0aW9uKHNjb3BlLCB2YWx1ZXMpIHtcblx0XHRyZXR1cm4gaGVscGVyc19jb3JlLm1lcmdlKHRoaXNbc2NvcGVdIHx8ICh0aGlzW3Njb3BlXSA9IHt9KSwgdmFsdWVzKTtcblx0fVxufTtcblxuZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRkZWZhdWx0Q29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLFxuXHRkZWZhdWx0Rm9udENvbG9yOiAnIzY2NicsXG5cdGRlZmF1bHRGb250RmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG5cdGRlZmF1bHRGb250U2l6ZTogMTIsXG5cdGRlZmF1bHRGb250U3R5bGU6ICdub3JtYWwnLFxuXHRkZWZhdWx0TGluZUhlaWdodDogMS4yLFxuXHRzaG93TGluZXM6IHRydWVcbn0pO1xuXG52YXIgY29yZV9kZWZhdWx0cyA9IGRlZmF1bHRzO1xuXG52YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzX2NvcmUudmFsdWVPckRlZmF1bHQ7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGZvbnQgb2JqZWN0IGludG8gYSBDU1MgZm9udCBzdHJpbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gZm9udCAtIEEgZm9udCBvYmplY3QuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBDU1MgZm9udCBzdHJpbmcuIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQpIHtcblx0aWYgKCFmb250IHx8IGhlbHBlcnNfY29yZS5pc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaGVscGVyc19jb3JlLmlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRyZXR1cm4gKGZvbnQuc3R5bGUgPyBmb250LnN0eWxlICsgJyAnIDogJycpXG5cdFx0KyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKVxuXHRcdCsgZm9udC5zaXplICsgJ3B4ICdcblx0XHQrIGZvbnQuZmFtaWx5O1xufVxuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm9wdGlvbnNcbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIGhlbHBlcnNfb3B0aW9ucyA9IHtcblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiBsaW5lIGhlaWdodCBgdmFsdWVgIGluIHBpeGVscyBmb3IgYSBzcGVjaWZpYyBmb250IGBzaXplYC5cblx0ICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB2YWx1ZSAtIFRoZSBsaW5lSGVpZ2h0IHRvIHBhcnNlIChlZy4gMS42LCAnMTRweCcsICc3NSUnLCAnMS42ZW0nKS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgZm9udCBzaXplIChpbiBwaXhlbHMpIHVzZWQgdG8gcmVzb2x2ZSByZWxhdGl2ZSBgdmFsdWVgLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGluIHBpeGVscyAoc2l6ZSAqIDEuMiBpZiB2YWx1ZSBpcyBpbnZhbGlkKS5cblx0ICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbGluZS1oZWlnaHRcblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHR0b0xpbmVIZWlnaHQ6IGZ1bmN0aW9uKHZhbHVlLCBzaXplKSB7XG5cdFx0dmFyIG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8pO1xuXHRcdGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuXHRcdFx0cmV0dXJuIHNpemUgKiAxLjI7XG5cdFx0fVxuXG5cdFx0dmFsdWUgPSArbWF0Y2hlc1syXTtcblxuXHRcdHN3aXRjaCAobWF0Y2hlc1szXSkge1xuXHRcdGNhc2UgJ3B4Jzpcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRjYXNlICclJzpcblx0XHRcdHZhbHVlIC89IDEwMDtcblx0XHRcdGJyZWFrO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gc2l6ZSAqIHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIHBhZGRpbmcgb2JqZWN0IHdpdGggcHJlLWNvbXB1dGVkIHdpZHRoL2hlaWdodC5cblx0ICogQHBhcmFtIHtudW1iZXJ8b2JqZWN0fSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcblx0ICogIGVsc2UsIGlmIGFuZCBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQpXG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0dG9QYWRkaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciB0LCByLCBiLCBsO1xuXG5cdFx0aWYgKGhlbHBlcnNfY29yZS5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHRcdHQgPSArdmFsdWUudG9wIHx8IDA7XG5cdFx0XHRyID0gK3ZhbHVlLnJpZ2h0IHx8IDA7XG5cdFx0XHRiID0gK3ZhbHVlLmJvdHRvbSB8fCAwO1xuXHRcdFx0bCA9ICt2YWx1ZS5sZWZ0IHx8IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHQgPSByID0gYiA9IGwgPSArdmFsdWUgfHwgMDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiB0LFxuXHRcdFx0cmlnaHQ6IHIsXG5cdFx0XHRib3R0b206IGIsXG5cdFx0XHRsZWZ0OiBsLFxuXHRcdFx0aGVpZ2h0OiB0ICsgYixcblx0XHRcdHdpZHRoOiBsICsgclxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIFBhcnNlcyBmb250IG9wdGlvbnMgYW5kIHJldHVybnMgdGhlIGZvbnQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZm9udCBvcHRpb25zIHRvIGJlIHBhcnNlZC5cblx0ICogQHJldHVybiB7b2JqZWN0fSBUaGUgZm9udCBvYmplY3QuXG5cdCAqIEB0b2RvIFN1cHBvcnQgZm9udC4qIG9wdGlvbnMgYW5kIHJlbmFtZWQgdG8gdG9Gb250KCkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcGFyc2VGb250OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdHZhciBmb250ID0ge1xuXHRcdFx0ZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRcdGxpbmVIZWlnaHQ6IGhlbHBlcnNfY29yZS5vcHRpb25zLnRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRMaW5lSGVpZ2h0KSwgc2l6ZSksXG5cdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0c3R5bGU6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRcdHdlaWdodDogbnVsbCxcblx0XHRcdHN0cmluZzogJydcblx0XHR9O1xuXG5cdFx0Zm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG5cdFx0cmV0dXJuIGZvbnQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gYGlucHV0c2Agc2VxdWVudGlhbGx5IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBpbnB1dHMgLSBBbiBhcnJheSBvZiB2YWx1ZXMsIGZhbGxpbmcgYmFjayB0byB0aGUgbGFzdCB2YWx1ZS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSB2YWx1ZVxuXHQgKiBpcyBjYWxsZWQgd2l0aCBgY29udGV4dGAgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZSByZXN1bHQgYmVjb21lcyB0aGUgbmV3IGlucHV0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XSAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGFuIGFycmF5LCB0aGUgdmFsdWVcblx0ICogYXQgYGluZGV4YCBiZWNvbWUgdGhlIG5ldyBpbnB1dC5cblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRyZXNvbHZlOiBmdW5jdGlvbihpbnB1dHMsIGNvbnRleHQsIGluZGV4KSB7XG5cdFx0dmFyIGksIGlsZW4sIHZhbHVlO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHZhbHVlID0gaW5wdXRzW2ldO1xuXHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaGVscGVyc19jb3JlLmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbaW5kZXhdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxudmFyIGhlbHBlcnMkMSA9IGhlbHBlcnNfY29yZTtcbnZhciBlYXNpbmcgPSBoZWxwZXJzX2Vhc2luZztcbnZhciBjYW52YXMgPSBoZWxwZXJzX2NhbnZhcztcbnZhciBvcHRpb25zID0gaGVscGVyc19vcHRpb25zO1xuaGVscGVycyQxLmVhc2luZyA9IGVhc2luZztcbmhlbHBlcnMkMS5jYW52YXMgPSBjYW52YXM7XG5oZWxwZXJzJDEub3B0aW9ucyA9IG9wdGlvbnM7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHN0YXJ0LCB2aWV3LCBtb2RlbCwgZWFzZSkge1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1vZGVsKTtcblx0dmFyIGksIGlsZW4sIGtleSwgYWN0dWFsLCBvcmlnaW4sIHRhcmdldCwgdHlwZSwgYzAsIGMxO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGtleSA9IGtleXNbaV07XG5cblx0XHR0YXJnZXQgPSBtb2RlbFtrZXldO1xuXG5cdFx0Ly8gaWYgYSB2YWx1ZSBpcyBhZGRlZCB0byB0aGUgbW9kZWwgYWZ0ZXIgcGl2b3QoKSBoYXMgYmVlbiBjYWxsZWQsIHRoZSB2aWV3XG5cdFx0Ly8gZG9lc24ndCBjb250YWluIGl0LCBzbyBsZXQncyBpbml0aWFsaXplIHRoZSB2aWV3IHRvIHRoZSB0YXJnZXQgdmFsdWUuXG5cdFx0aWYgKCF2aWV3Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHZpZXdba2V5XSA9IHRhcmdldDtcblx0XHR9XG5cblx0XHRhY3R1YWwgPSB2aWV3W2tleV07XG5cblx0XHRpZiAoYWN0dWFsID09PSB0YXJnZXQgfHwga2V5WzBdID09PSAnXycpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghc3RhcnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0c3RhcnRba2V5XSA9IGFjdHVhbDtcblx0XHR9XG5cblx0XHRvcmlnaW4gPSBzdGFydFtrZXldO1xuXG5cdFx0dHlwZSA9IHR5cGVvZiB0YXJnZXQ7XG5cblx0XHRpZiAodHlwZSA9PT0gdHlwZW9mIG9yaWdpbikge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGMwID0gY2hhcnRqc0NvbG9yKG9yaWdpbik7XG5cdFx0XHRcdGlmIChjMC52YWxpZCkge1xuXHRcdFx0XHRcdGMxID0gY2hhcnRqc0NvbG9yKHRhcmdldCk7XG5cdFx0XHRcdFx0aWYgKGMxLnZhbGlkKSB7XG5cdFx0XHRcdFx0XHR2aWV3W2tleV0gPSBjMS5taXgoYzAsIGVhc2UpLnJnYlN0cmluZygpO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGhlbHBlcnMkMS5pc0Zpbml0ZShvcmlnaW4pICYmIGhlbHBlcnMkMS5pc0Zpbml0ZSh0YXJnZXQpKSB7XG5cdFx0XHRcdHZpZXdba2V5XSA9IG9yaWdpbiArICh0YXJnZXQgLSBvcmlnaW4pICogZWFzZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmlld1trZXldID0gdGFyZ2V0O1xuXHR9XG59XG5cbnZhciBFbGVtZW50ID0gZnVuY3Rpb24oY29uZmlndXJhdGlvbikge1xuXHRoZWxwZXJzJDEuZXh0ZW5kKHRoaXMsIGNvbmZpZ3VyYXRpb24pO1xuXHR0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbmhlbHBlcnMkMS5leHRlbmQoRWxlbWVudC5wcm90b3R5cGUsIHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhpZGRlbiA9IGZhbHNlO1xuXHR9LFxuXG5cdHBpdm90OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmICghbWUuX3ZpZXcpIHtcblx0XHRcdG1lLl92aWV3ID0gaGVscGVycyQxLmNsb25lKG1lLl9tb2RlbCk7XG5cdFx0fVxuXHRcdG1lLl9zdGFydCA9IHt9O1xuXHRcdHJldHVybiBtZTtcblx0fSxcblxuXHR0cmFuc2l0aW9uOiBmdW5jdGlvbihlYXNlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbW9kZWwgPSBtZS5fbW9kZWw7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuX3N0YXJ0O1xuXHRcdHZhciB2aWV3ID0gbWUuX3ZpZXc7XG5cblx0XHQvLyBObyBhbmltYXRpb24gLT4gTm8gVHJhbnNpdGlvblxuXHRcdGlmICghbW9kZWwgfHwgZWFzZSA9PT0gMSkge1xuXHRcdFx0bWUuX3ZpZXcgPSBtb2RlbDtcblx0XHRcdG1lLl9zdGFydCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gbWU7XG5cdFx0fVxuXG5cdFx0aWYgKCF2aWV3KSB7XG5cdFx0XHR2aWV3ID0gbWUuX3ZpZXcgPSB7fTtcblx0XHR9XG5cblx0XHRpZiAoIXN0YXJ0KSB7XG5cdFx0XHRzdGFydCA9IG1lLl9zdGFydCA9IHt9O1xuXHRcdH1cblxuXHRcdGludGVycG9sYXRlKHN0YXJ0LCB2aWV3LCBtb2RlbCwgZWFzZSk7XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdGhpcy5fbW9kZWwueCxcblx0XHRcdHk6IHRoaXMuX21vZGVsLnlcblx0XHR9O1xuXHR9LFxuXG5cdGhhc1ZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaGVscGVycyQxLmlzTnVtYmVyKHRoaXMuX21vZGVsLngpICYmIGhlbHBlcnMkMS5pc051bWJlcih0aGlzLl9tb2RlbC55KTtcblx0fVxufSk7XG5cbkVsZW1lbnQuZXh0ZW5kID0gaGVscGVycyQxLmluaGVyaXRzO1xuXG52YXIgY29yZV9lbGVtZW50ID0gRWxlbWVudDtcblxudmFyIGV4cG9ydHMkMiA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRjaGFydDogbnVsbCwgLy8gdGhlIGFuaW1hdGlvbiBhc3NvY2lhdGVkIGNoYXJ0IGluc3RhbmNlXG5cdGN1cnJlbnRTdGVwOiAwLCAvLyB0aGUgY3VycmVudCBhbmltYXRpb24gc3RlcFxuXHRudW1TdGVwczogNjAsIC8vIGRlZmF1bHQgbnVtYmVyIG9mIHN0ZXBzXG5cdGVhc2luZzogJycsIC8vIHRoZSBlYXNpbmcgdG8gdXNlIGZvciB0aGlzIGFuaW1hdGlvblxuXHRyZW5kZXI6IG51bGwsIC8vIHJlbmRlciBmdW5jdGlvbiB1c2VkIGJ5IHRoZSBhbmltYXRpb24gc2VydmljZVxuXG5cdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IG51bGwsIC8vIHVzZXIgc3BlY2lmaWVkIGNhbGxiYWNrIHRvIGZpcmUgb24gZWFjaCBzdGVwIG9mIHRoZSBhbmltYXRpb25cblx0b25BbmltYXRpb25Db21wbGV0ZTogbnVsbCwgLy8gdXNlciBzcGVjaWZpZWQgY2FsbGJhY2sgdG8gZmlyZSB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXNcbn0pO1xuXG52YXIgY29yZV9hbmltYXRpb24gPSBleHBvcnRzJDI7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuQW5pbWF0aW9uIGluc3RlYWRcbiAqIEBwcm9wIENoYXJ0LkFuaW1hdGlvbiNhbmltYXRpb25PYmplY3RcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMkMi5wcm90b3R5cGUsICdhbmltYXRpb25PYmplY3QnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuQW5pbWF0aW9uI2NoYXJ0IGluc3RlYWRcbiAqIEBwcm9wIENoYXJ0LkFuaW1hdGlvbiNjaGFydEluc3RhbmNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzJDIucHJvdG90eXBlLCAnY2hhcnRJbnN0YW5jZScsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFydDtcblx0fSxcblx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXMuY2hhcnQgPSB2YWx1ZTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRhbmltYXRpb246IHtcblx0XHRkdXJhdGlvbjogMTAwMCxcblx0XHRlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuXHRcdG9uUHJvZ3Jlc3M6IGhlbHBlcnMkMS5ub29wLFxuXHRcdG9uQ29tcGxldGU6IGhlbHBlcnMkMS5ub29wXG5cdH1cbn0pO1xuXG52YXIgY29yZV9hbmltYXRpb25zID0ge1xuXHRhbmltYXRpb25zOiBbXSxcblx0cmVxdWVzdDogbnVsbCxcblxuXHQvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgdG8gYW5pbWF0ZS5cblx0ICogQHBhcmFtIHtDaGFydC5BbmltYXRpb259IGFuaW1hdGlvbiAtIFRoZSBhbmltYXRpb24gdGhhdCB3ZSB3aWxsIGFuaW1hdGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbXMuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gbGF6eSAtIGlmIHRydWUsIHRoZSBjaGFydCBpcyBub3QgbWFya2VkIGFzIGFuaW1hdGluZyB0byBlbmFibGUgbW9yZSByZXNwb25zaXZlIGludGVyYWN0aW9uc1xuXHQgKi9cblx0YWRkQW5pbWF0aW9uOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgbGF6eSkge1xuXHRcdHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0YW5pbWF0aW9uLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0YW5pbWF0aW9uLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cdFx0YW5pbWF0aW9uLmR1cmF0aW9uID0gZHVyYXRpb247XG5cblx0XHRpZiAoIWxhenkpIHtcblx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFuaW1hdGlvbnMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAoYW5pbWF0aW9uc1tpXS5jaGFydCA9PT0gY2hhcnQpIHtcblx0XHRcdFx0YW5pbWF0aW9uc1tpXSA9IGFuaW1hdGlvbjtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG5vIGFuaW1hdGlvbnMgcXVldWVkLCBtYW51YWxseSBraWNrc3RhcnQgYSBkaWdlc3QsIGZvciBsYWNrIG9mIGEgYmV0dGVyIHdvcmRcblx0XHRpZiAoYW5pbWF0aW9ucy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNhbmNlbEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgaW5kZXggPSBoZWxwZXJzJDEuZmluZEluZGV4KHRoaXMuYW5pbWF0aW9ucywgZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9uLmNoYXJ0ID09PSBjaGFydDtcblx0XHR9KTtcblxuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0Y2hhcnQuYW5pbWF0aW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdHJlcXVlc3RBbmltYXRpb25GcmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAobWUucmVxdWVzdCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gU2tpcCBhbmltYXRpb24gZnJhbWUgcmVxdWVzdHMgdW50aWwgdGhlIGFjdGl2ZSBvbmUgaXMgZXhlY3V0ZWQuXG5cdFx0XHQvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiBwcm9jZXNzaW5nIG1vdXNlIGV2ZW50cywgZS5nLiAnbW91c2Vtb3ZlJ1xuXHRcdFx0Ly8gYW5kICdtb3VzZW91dCcgZXZlbnRzIHdpbGwgdHJpZ2dlciBtdWx0aXBsZSByZW5kZXJzLlxuXHRcdFx0bWUucmVxdWVzdCA9IGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWUucmVxdWVzdCA9IG51bGw7XG5cdFx0XHRcdG1lLnN0YXJ0RGlnZXN0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzdGFydERpZ2VzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdG1lLmFkdmFuY2UoKTtcblxuXHRcdC8vIERvIHdlIGhhdmUgbW9yZSBzdHVmZiB0byBhbmltYXRlP1xuXHRcdGlmIChtZS5hbmltYXRpb25zLmxlbmd0aCA+IDApIHtcblx0XHRcdG1lLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGFkdmFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zO1xuXHRcdHZhciBhbmltYXRpb24sIGNoYXJ0LCBudW1TdGVwcywgbmV4dFN0ZXA7XG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0Ly8gMSBhbmltYXRpb24gcGVyIGNoYXJ0LCBzbyB3ZSBhcmUgbG9vcGluZyBjaGFydHMgaGVyZVxuXHRcdHdoaWxlIChpIDwgYW5pbWF0aW9ucy5sZW5ndGgpIHtcblx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbaV07XG5cdFx0XHRjaGFydCA9IGFuaW1hdGlvbi5jaGFydDtcblx0XHRcdG51bVN0ZXBzID0gYW5pbWF0aW9uLm51bVN0ZXBzO1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBjdXJyZW50U3RlcCBzdGFydHMgYXQgMVxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzYxMDRcblx0XHRcdG5leHRTdGVwID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAtIGFuaW1hdGlvbi5zdGFydFRpbWUpIC8gYW5pbWF0aW9uLmR1cmF0aW9uICogbnVtU3RlcHMpICsgMTtcblx0XHRcdGFuaW1hdGlvbi5jdXJyZW50U3RlcCA9IE1hdGgubWluKG5leHRTdGVwLCBudW1TdGVwcyk7XG5cblx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb24ucmVuZGVyLCBbY2hhcnQsIGFuaW1hdGlvbl0sIGNoYXJ0KTtcblx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb24ub25BbmltYXRpb25Qcm9ncmVzcywgW2FuaW1hdGlvbl0sIGNoYXJ0KTtcblxuXHRcdFx0aWYgKGFuaW1hdGlvbi5jdXJyZW50U3RlcCA+PSBudW1TdGVwcykge1xuXHRcdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLm9uQW5pbWF0aW9uQ29tcGxldGUsIFthbmltYXRpb25dLCBjaGFydCk7XG5cdFx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRhbmltYXRpb25zLnNwbGljZShpLCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCsraTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbnZhciByZXNvbHZlID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxudmFyIGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xuXG4vKipcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG4gKiBjYWxsZWQgb24gdGhlICdvbkRhdGEqJyBjYWxsYmFja3MgKGUuZy4gb25EYXRhUHVzaCwgZXRjLikgd2l0aCBzYW1lIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG5cdGlmIChhcnJheS5fY2hhcnRqcykge1xuXHRcdGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0dmFsdWU6IHtcblx0XHRcdGxpc3RlbmVyczogW2xpc3RlbmVyXVxuXHRcdH1cblx0fSk7XG5cblx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgbWV0aG9kID0gJ29uRGF0YScgKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7XG5cdFx0dmFyIGJhc2UgPSBhcnJheVtrZXldO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHZhciByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycywgZnVuY3Rpb24ob2JqZWN0KSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0b2JqZWN0W21ldGhvZF0uYXBwbHkob2JqZWN0LCBhcmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIGFycmF5IGV2ZW50IGxpc3RlbmVyIGFuZCBjbGVhbnVwIGV4dHJhIGF0dGFjaGVkIHByb3BlcnRpZXMgKHN1Y2ggYXNcbiAqIHRoZSBfY2hhcnRqcyBzdHViIGFuZCBvdmVycmlkZGVuIG1ldGhvZHMpIGlmIGFycmF5IGRvZXNuJ3QgaGF2ZSBhbnkgbW9yZSBsaXN0ZW5lcnMuXG4gKi9cbmZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG5cdHZhciBzdHViID0gYXJyYXkuX2NoYXJ0anM7XG5cdGlmICghc3R1Yikge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcblx0dmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuXHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0bGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXHRpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRhcnJheUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGRlbGV0ZSBhcnJheVtrZXldO1xuXHR9KTtcblxuXHRkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5cbi8vIEJhc2UgY2xhc3MgZm9yIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIChsaW5lLCBiYXIsIGV0YylcbnZhciBEYXRhc2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcblx0dGhpcy5pbml0aWFsaXplKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xufTtcblxuaGVscGVycyQxLmV4dGVuZChEYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUsIHtcblxuXHQvKipcblx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGFzZXQgKGUuZy4gQ2hhcnQuZWxlbWVudC5MaW5lKS5cblx0ICogQHR5cGUge0NoYXJ0LmNvcmUuZWxlbWVudH1cblx0ICovXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogbnVsbCxcblxuXHQvKipcblx0ICogRWxlbWVudCB0eXBlIHVzZWQgdG8gZ2VuZXJhdGUgYSBtZXRhIGRhdGEgKGUuZy4gQ2hhcnQuZWxlbWVudC5Qb2ludCkuXG5cdCAqIEB0eXBlIHtDaGFydC5jb3JlLmVsZW1lbnR9XG5cdCAqL1xuXHRkYXRhRWxlbWVudFR5cGU6IG51bGwsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0bWUuY2hhcnQgPSBjaGFydDtcblx0XHRtZS5pbmRleCA9IGRhdGFzZXRJbmRleDtcblx0XHRtZS5saW5rU2NhbGVzKCk7XG5cdFx0bWUuYWRkRWxlbWVudHMoKTtcblx0fSxcblxuXHR1cGRhdGVJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcblx0fSxcblxuXHRsaW5rU2NhbGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXG5cdFx0aWYgKG1ldGEueEF4aXNJRCA9PT0gbnVsbCB8fCAhKG1ldGEueEF4aXNJRCBpbiBtZS5jaGFydC5zY2FsZXMpKSB7XG5cdFx0XHRtZXRhLnhBeGlzSUQgPSBkYXRhc2V0LnhBeGlzSUQgfHwgbWUuY2hhcnQub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0uaWQ7XG5cdFx0fVxuXHRcdGlmIChtZXRhLnlBeGlzSUQgPT09IG51bGwgfHwgIShtZXRhLnlBeGlzSUQgaW4gbWUuY2hhcnQuc2NhbGVzKSkge1xuXHRcdFx0bWV0YS55QXhpc0lEID0gZGF0YXNldC55QXhpc0lEIHx8IG1lLmNoYXJ0Lm9wdGlvbnMuc2NhbGVzLnlBeGVzWzBdLmlkO1xuXHRcdH1cblx0fSxcblxuXHRnZXREYXRhc2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuXHR9LFxuXG5cdGdldE1ldGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuXHR9LFxuXG5cdGdldFNjYWxlRm9ySWQ6IGZ1bmN0aW9uKHNjYWxlSUQpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0VmFsdWVTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS54QXhpc0lEO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFNjYWxlRm9ySWQodGhpcy5fZ2V0VmFsdWVTY2FsZUlkKCkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldEluZGV4U2NhbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFNjYWxlRm9ySWQodGhpcy5fZ2V0SW5kZXhTY2FsZUlkKCkpO1xuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnVwZGF0ZSh0cnVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9kYXRhKSB7XG5cdFx0XHR1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRjcmVhdGVNZXRhRGF0YXNldDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdHlwZSA9IG1lLmRhdGFzZXRFbGVtZW50VHlwZTtcblx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XG5cdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9KTtcblx0fSxcblxuXHRjcmVhdGVNZXRhRGF0YTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0eXBlID0gbWUuZGF0YUVsZW1lbnRUeXBlO1xuXHRcdHJldHVybiB0eXBlICYmIG5ldyB0eXBlKHtcblx0XHRcdF9jaGFydDogbWUuY2hhcnQsXG5cdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdF9pbmRleDogaW5kZXhcblx0XHR9KTtcblx0fSxcblxuXHRhZGRFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhIHx8IFtdO1xuXHRcdHZhciBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWV0YURhdGFbaV0gPSBtZXRhRGF0YVtpXSB8fCBtZS5jcmVhdGVNZXRhRGF0YShpKTtcblx0XHR9XG5cblx0XHRtZXRhLmRhdGFzZXQgPSBtZXRhLmRhdGFzZXQgfHwgbWUuY3JlYXRlTWV0YURhdGFzZXQoKTtcblx0fSxcblxuXHRhZGRFbGVtZW50QW5kUmVzZXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmNyZWF0ZU1ldGFEYXRhKGluZGV4KTtcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNwbGljZShpbmRleCwgMCwgZWxlbWVudCk7XG5cdFx0dGhpcy51cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCB0cnVlKTtcblx0fSxcblxuXHRidWlsZE9yVXBkYXRlRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcblxuXHRcdC8vIEluIG9yZGVyIHRvIGNvcnJlY3RseSBoYW5kbGUgZGF0YSBhZGRpdGlvbi9kZWxldGlvbiBhbmltYXRpb24gKGFuIHRodXMgc2ltdWxhdGVcblx0XHQvLyByZWFsLXRpbWUgY2hhcnRzKSwgd2UgbmVlZCB0byBtb25pdG9yIHRoZXNlIGRhdGEgbW9kaWZpY2F0aW9ucyBhbmQgc3luY2hyb25pemVcblx0XHQvLyB0aGUgaW50ZXJuYWwgbWV0YSBkYXRhIGFjY29yZGluZ2x5LlxuXHRcdGlmIChtZS5fZGF0YSAhPT0gZGF0YSkge1xuXHRcdFx0aWYgKG1lLl9kYXRhKSB7XG5cdFx0XHRcdC8vIFRoaXMgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgaW5zdGFuY2UuXG5cdFx0XHRcdHVubGlzdGVuQXJyYXlFdmVudHMobWUuX2RhdGEsIG1lKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuXHRcdFx0XHRsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCBtZSk7XG5cdFx0XHR9XG5cdFx0XHRtZS5fZGF0YSA9IGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gUmUtc3luYyBtZXRhIGRhdGEgaW4gY2FzZSB0aGUgdXNlciByZXBsYWNlZCB0aGUgZGF0YSBhcnJheSBvciBpZiB3ZSBtaXNzZWRcblx0XHQvLyBhbnkgdXBkYXRlcyBhbmQgc28gbWFrZSBzdXJlIHRoYXQgd2UgaGFuZGxlIG51bWJlciBvZiBkYXRhcG9pbnRzIGNoYW5naW5nLlxuXHRcdG1lLnJlc3luY0VsZW1lbnRzKCk7XG5cdH0sXG5cblx0dXBkYXRlOiBoZWxwZXJzJDEubm9vcCxcblxuXHR0cmFuc2l0aW9uOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRlbGVtZW50c1tpXS50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0XHR9XG5cblx0XHRpZiAobWV0YS5kYXRhc2V0KSB7XG5cdFx0XHRtZXRhLmRhdGFzZXQudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGlmIChtZXRhLmRhdGFzZXQpIHtcblx0XHRcdG1ldGEuZGF0YXNldC5kcmF3KCk7XG5cdFx0fVxuXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGVsZW1lbnRzW2ldLmRyYXcoKTtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlSG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdGhlbHBlcnMkMS5tZXJnZShlbGVtZW50Ll9tb2RlbCwgZWxlbWVudC4kcHJldmlvdXNTdHlsZSB8fCB7fSk7XG5cdFx0ZGVsZXRlIGVsZW1lbnQuJHByZXZpb3VzU3R5bGU7XG5cdH0sXG5cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2VsZW1lbnQuX2RhdGFzZXRJbmRleF07XG5cdFx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBtb2RlbCA9IGVsZW1lbnQuX21vZGVsO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRlbGVtZW50LiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGhcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gcmVzb2x2ZShbY3VzdG9tLmhvdmVyQmFja2dyb3VuZENvbG9yLCBkYXRhc2V0LmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG1vZGVsLmJhY2tncm91bmRDb2xvcildLCB1bmRlZmluZWQsIGluZGV4KTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJvcmRlckNvbG9yLCBkYXRhc2V0LmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3IobW9kZWwuYm9yZGVyQ29sb3IpXSwgdW5kZWZpbmVkLCBpbmRleCk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSByZXNvbHZlKFtjdXN0b20uaG92ZXJCb3JkZXJXaWR0aCwgZGF0YXNldC5ob3ZlckJvcmRlcldpZHRoLCBtb2RlbC5ib3JkZXJXaWR0aF0sIHVuZGVmaW5lZCwgaW5kZXgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVzeW5jRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGRhdGEgPSBtZS5nZXREYXRhc2V0KCkuZGF0YTtcblx0XHR2YXIgbnVtTWV0YSA9IG1ldGEuZGF0YS5sZW5ndGg7XG5cdFx0dmFyIG51bURhdGEgPSBkYXRhLmxlbmd0aDtcblxuXHRcdGlmIChudW1EYXRhIDwgbnVtTWV0YSkge1xuXHRcdFx0bWV0YS5kYXRhLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG5cdFx0fSBlbHNlIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuXHRcdFx0bWUuaW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGluc2VydEVsZW1lbnRzOiBmdW5jdGlvbihzdGFydCwgY291bnQpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcblx0XHRcdHRoaXMuYWRkRWxlbWVudEFuZFJlc2V0KHN0YXJ0ICsgaSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhUHVzaDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHR0aGlzLmluc2VydEVsZW1lbnRzKHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50KTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVBvcDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5wb3AoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVNoaWZ0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNoaWZ0KCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFTcGxpY2U6IGZ1bmN0aW9uKHN0YXJ0LCBjb3VudCkge1xuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG5cdFx0dGhpcy5pbnNlcnRFbGVtZW50cyhzdGFydCwgYXJndW1lbnRzLmxlbmd0aCAtIDIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhVW5zaGlmdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5pbnNlcnRFbGVtZW50cygwLCBhcmd1bWVudHMubGVuZ3RoKTtcblx0fVxufSk7XG5cbkRhdGFzZXRDb250cm9sbGVyLmV4dGVuZCA9IGhlbHBlcnMkMS5pbmhlcml0cztcblxudmFyIGNvcmVfZGF0YXNldENvbnRyb2xsZXIgPSBEYXRhc2V0Q29udHJvbGxlcjtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7XG5cdFx0YXJjOiB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiAnI2ZmZicsXG5cdFx0XHRib3JkZXJXaWR0aDogMixcblx0XHRcdGJvcmRlckFsaWduOiAnY2VudGVyJ1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBlbGVtZW50X2FyYyA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRpbkxhYmVsUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cblx0XHRpZiAodm0pIHtcblx0XHRcdHJldHVybiAoTWF0aC5wb3cobW91c2VYIC0gdm0ueCwgMikgPCBNYXRoLnBvdyh2bS5yYWRpdXMgKyB2bS5ob3ZlclJhZGl1cywgMikpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aW5SYW5nZTogZnVuY3Rpb24oY2hhcnRYLCBjaGFydFkpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtKSB7XG5cdFx0XHR2YXIgcG9pbnRSZWxhdGl2ZVBvc2l0aW9uID0gaGVscGVycyQxLmdldEFuZ2xlRnJvbVBvaW50KHZtLCB7eDogY2hhcnRYLCB5OiBjaGFydFl9KTtcblx0XHRcdHZhclx0YW5nbGUgPSBwb2ludFJlbGF0aXZlUG9zaXRpb24uYW5nbGU7XG5cdFx0XHR2YXIgZGlzdGFuY2UgPSBwb2ludFJlbGF0aXZlUG9zaXRpb24uZGlzdGFuY2U7XG5cblx0XHRcdC8vIFNhbml0aXNlIGFuZ2xlIHJhbmdlXG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IHZtLnN0YXJ0QW5nbGU7XG5cdFx0XHR2YXIgZW5kQW5nbGUgPSB2bS5lbmRBbmdsZTtcblx0XHRcdHdoaWxlIChlbmRBbmdsZSA8IHN0YXJ0QW5nbGUpIHtcblx0XHRcdFx0ZW5kQW5nbGUgKz0gMi4wICogTWF0aC5QSTtcblx0XHRcdH1cblx0XHRcdHdoaWxlIChhbmdsZSA+IGVuZEFuZ2xlKSB7XG5cdFx0XHRcdGFuZ2xlIC09IDIuMCAqIE1hdGguUEk7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoYW5nbGUgPCBzdGFydEFuZ2xlKSB7XG5cdFx0XHRcdGFuZ2xlICs9IDIuMCAqIE1hdGguUEk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgdGhlIG9wZW4vY2xvc2UgYW5nbGVcblx0XHRcdHZhciBiZXR3ZWVuQW5nbGVzID0gKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIHdpdGhpblJhZGl1cyA9IChkaXN0YW5jZSA+PSB2bS5pbm5lclJhZGl1cyAmJiBkaXN0YW5jZSA8PSB2bS5vdXRlclJhZGl1cyk7XG5cblx0XHRcdHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Z2V0Q2VudGVyUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGhhbGZBbmdsZSA9ICh2bS5zdGFydEFuZ2xlICsgdm0uZW5kQW5nbGUpIC8gMjtcblx0XHR2YXIgaGFsZlJhZGl1cyA9ICh2bS5pbm5lclJhZGl1cyArIHZtLm91dGVyUmFkaXVzKSAvIDI7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLnggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcblx0XHRcdHk6IHZtLnkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuXHRcdH07XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gTWF0aC5QSSAqICgodm0uZW5kQW5nbGUgLSB2bS5zdGFydEFuZ2xlKSAvICgyICogTWF0aC5QSSkpICogKE1hdGgucG93KHZtLm91dGVyUmFkaXVzLCAyKSAtIE1hdGgucG93KHZtLmlubmVyUmFkaXVzLCAyKSk7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBjZW50cmVBbmdsZSA9IHZtLnN0YXJ0QW5nbGUgKyAoKHZtLmVuZEFuZ2xlIC0gdm0uc3RhcnRBbmdsZSkgLyAyKTtcblx0XHR2YXIgcmFuZ2VGcm9tQ2VudHJlID0gKHZtLm91dGVyUmFkaXVzIC0gdm0uaW5uZXJSYWRpdXMpIC8gMiArIHZtLmlubmVyUmFkaXVzO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHZtLnggKyAoTWF0aC5jb3MoY2VudHJlQW5nbGUpICogcmFuZ2VGcm9tQ2VudHJlKSxcblx0XHRcdHk6IHZtLnkgKyAoTWF0aC5zaW4oY2VudHJlQW5nbGUpICogcmFuZ2VGcm9tQ2VudHJlKVxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBzQSA9IHZtLnN0YXJ0QW5nbGU7XG5cdFx0dmFyIGVBID0gdm0uZW5kQW5nbGU7XG5cdFx0dmFyIHBpeGVsTWFyZ2luID0gKHZtLmJvcmRlckFsaWduID09PSAnaW5uZXInKSA/IDAuMzMgOiAwO1xuXHRcdHZhciBhbmdsZU1hcmdpbjtcblxuXHRcdGN0eC5zYXZlKCk7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LmFyYyh2bS54LCB2bS55LCBNYXRoLm1heCh2bS5vdXRlclJhZGl1cyAtIHBpeGVsTWFyZ2luLCAwKSwgc0EsIGVBKTtcblx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLmlubmVyUmFkaXVzLCBlQSwgc0EsIHRydWUpO1xuXHRcdGN0eC5jbG9zZVBhdGgoKTtcblxuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0Y3R4LmZpbGwoKTtcblxuXHRcdGlmICh2bS5ib3JkZXJXaWR0aCkge1xuXHRcdFx0aWYgKHZtLmJvcmRlckFsaWduID09PSAnaW5uZXInKSB7XG5cdFx0XHRcdC8vIERyYXcgYW4gaW5uZXIgYm9yZGVyIGJ5IGNsaXBpbmcgdGhlIGFyYyBhbmQgZHJhd2luZyBhIGRvdWJsZS13aWR0aCBib3JkZXJcblx0XHRcdFx0Ly8gRW5sYXJnZSB0aGUgY2xpcHBpbmcgYXJjIGJ5IDAuMzMgcGl4ZWxzIHRvIGVsaW1pbmF0ZSBnbGl0Y2hlcyBiZXR3ZWVuIGJvcmRlcnNcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gdm0ub3V0ZXJSYWRpdXM7XG5cdFx0XHRcdGN0eC5hcmModm0ueCwgdm0ueSwgdm0ub3V0ZXJSYWRpdXMsIHNBIC0gYW5nbGVNYXJnaW4sIGVBICsgYW5nbGVNYXJnaW4pO1xuXHRcdFx0XHRpZiAodm0uaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xuXHRcdFx0XHRcdGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyB2bS5pbm5lclJhZGl1cztcblx0XHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLmlubmVyUmFkaXVzIC0gcGl4ZWxNYXJnaW4sIGVBICsgYW5nbGVNYXJnaW4sIHNBIC0gYW5nbGVNYXJnaW4sIHRydWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eC5hcmModm0ueCwgdm0ueSwgcGl4ZWxNYXJnaW4sIGVBICsgTWF0aC5QSSAvIDIsIHNBIC0gTWF0aC5QSSAvIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0Y3R4LmNsaXAoKTtcblxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5hcmModm0ueCwgdm0ueSwgdm0ub3V0ZXJSYWRpdXMsIHNBLCBlQSk7XG5cdFx0XHRcdGN0eC5hcmModm0ueCwgdm0ueSwgdm0uaW5uZXJSYWRpdXMsIGVBLCBzQSwgdHJ1ZSk7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblxuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gdm0uYm9yZGVyV2lkdGggKiAyO1xuXHRcdFx0XHRjdHgubGluZUpvaW4gPSAncm91bmQnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoO1xuXHRcdFx0XHRjdHgubGluZUpvaW4gPSAnYmV2ZWwnO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvcjtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9XG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDEgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbnZhciBkZWZhdWx0Q29sb3IgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdGxpbmU6IHtcblx0XHRcdHRlbnNpb246IDAuNCxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDMsXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yLFxuXHRcdFx0Ym9yZGVyQ2FwU3R5bGU6ICdidXR0Jyxcblx0XHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdFx0Ym9yZGVyRGFzaE9mZnNldDogMC4wLFxuXHRcdFx0Ym9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuXHRcdFx0Y2FwQmV6aWVyUG9pbnRzOiB0cnVlLFxuXHRcdFx0ZmlsbDogdHJ1ZSwgLy8gZG8gd2UgZmlsbCBpbiB0aGUgYXJlYSBiZXR3ZWVuIHRoZSBsaW5lIGFuZCBpdHMgYmFzZSBheGlzXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGVsZW1lbnRfbGluZSA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB2bSA9IG1lLl92aWV3O1xuXHRcdHZhciBjdHggPSBtZS5fY2hhcnQuY3R4O1xuXHRcdHZhciBzcGFuR2FwcyA9IHZtLnNwYW5HYXBzO1xuXHRcdHZhciBwb2ludHMgPSBtZS5fY2hpbGRyZW4uc2xpY2UoKTsgLy8gY2xvbmUgYXJyYXlcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzID0gZ2xvYmFsRGVmYXVsdHMuZWxlbWVudHMubGluZTtcblx0XHR2YXIgbGFzdERyYXduSW5kZXggPSAtMTtcblx0XHR2YXIgaW5kZXgsIGN1cnJlbnQsIHByZXZpb3VzLCBjdXJyZW50Vk07XG5cblx0XHQvLyBJZiB3ZSBhcmUgbG9vcGluZywgYWRkaW5nIHRoZSBmaXJzdCBwb2ludCBhZ2FpblxuXHRcdGlmIChtZS5fbG9vcCAmJiBwb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRwb2ludHMucHVzaChwb2ludHNbMF0pO1xuXHRcdH1cblxuXHRcdGN0eC5zYXZlKCk7XG5cblx0XHQvLyBTdHJva2UgTGluZSBPcHRpb25zXG5cdFx0Y3R4LmxpbmVDYXAgPSB2bS5ib3JkZXJDYXBTdHlsZSB8fCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyQ2FwU3R5bGU7XG5cblx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcblx0XHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0XHRjdHguc2V0TGluZURhc2godm0uYm9yZGVyRGFzaCB8fCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyRGFzaCk7XG5cdFx0fVxuXG5cdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQkMSh2bS5ib3JkZXJEYXNoT2Zmc2V0LCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyRGFzaE9mZnNldCk7XG5cdFx0Y3R4LmxpbmVKb2luID0gdm0uYm9yZGVySm9pblN0eWxlIHx8IGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJKb2luU3R5bGU7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDEodm0uYm9yZGVyV2lkdGgsIGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cy5ib3JkZXJXaWR0aCk7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3IgfHwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yO1xuXG5cdFx0Ly8gU3Ryb2tlIExpbmVcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0bGFzdERyYXduSW5kZXggPSAtMTtcblxuXHRcdGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBvaW50cy5sZW5ndGg7ICsraW5kZXgpIHtcblx0XHRcdGN1cnJlbnQgPSBwb2ludHNbaW5kZXhdO1xuXHRcdFx0cHJldmlvdXMgPSBoZWxwZXJzJDEucHJldmlvdXNJdGVtKHBvaW50cywgaW5kZXgpO1xuXHRcdFx0Y3VycmVudFZNID0gY3VycmVudC5fdmlldztcblxuXHRcdFx0Ly8gRmlyc3QgcG9pbnQgbW92ZXMgdG8gaXQncyBzdGFydGluZyBwb3NpdGlvbiBubyBtYXR0ZXIgd2hhdFxuXHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRcdGlmICghY3VycmVudFZNLnNraXApIHtcblx0XHRcdFx0XHRjdHgubW92ZVRvKGN1cnJlbnRWTS54LCBjdXJyZW50Vk0ueSk7XG5cdFx0XHRcdFx0bGFzdERyYXduSW5kZXggPSBpbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJldmlvdXMgPSBsYXN0RHJhd25JbmRleCA9PT0gLTEgPyBwcmV2aW91cyA6IHBvaW50c1tsYXN0RHJhd25JbmRleF07XG5cblx0XHRcdFx0aWYgKCFjdXJyZW50Vk0uc2tpcCkge1xuXHRcdFx0XHRcdGlmICgobGFzdERyYXduSW5kZXggIT09IChpbmRleCAtIDEpICYmICFzcGFuR2FwcykgfHwgbGFzdERyYXduSW5kZXggPT09IC0xKSB7XG5cdFx0XHRcdFx0XHQvLyBUaGVyZSB3YXMgYSBnYXAgYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHBvaW50IGFmdGVyIHRoZSBnYXBcblx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8oY3VycmVudFZNLngsIGN1cnJlbnRWTS55KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gTGluZSB0byBuZXh0IHBvaW50XG5cdFx0XHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLmxpbmVUbyhjdHgsIHByZXZpb3VzLl92aWV3LCBjdXJyZW50Ll92aWV3KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGFzdERyYXduSW5kZXggPSBpbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGN0eC5zdHJva2UoKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9XG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDIgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbnZhciBkZWZhdWx0Q29sb3IkMSA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7XG5cdFx0cG9pbnQ6IHtcblx0XHRcdHJhZGl1czogMyxcblx0XHRcdHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0Q29sb3IkMSxcblx0XHRcdGJvcmRlckNvbG9yOiBkZWZhdWx0Q29sb3IkMSxcblx0XHRcdGJvcmRlcldpZHRoOiAxLFxuXHRcdFx0Ly8gSG92ZXJcblx0XHRcdGhpdFJhZGl1czogMSxcblx0XHRcdGhvdmVyUmFkaXVzOiA0LFxuXHRcdFx0aG92ZXJCb3JkZXJXaWR0aDogMVxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIHhSYW5nZShtb3VzZVgpIHtcblx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0cmV0dXJuIHZtID8gKE1hdGguYWJzKG1vdXNlWCAtIHZtLngpIDwgdm0ucmFkaXVzICsgdm0uaGl0UmFkaXVzKSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiB5UmFuZ2UobW91c2VZKSB7XG5cdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdHJldHVybiB2bSA/IChNYXRoLmFicyhtb3VzZVkgLSB2bS55KSA8IHZtLnJhZGl1cyArIHZtLmhpdFJhZGl1cykgOiBmYWxzZTtcbn1cblxudmFyIGVsZW1lbnRfcG9pbnQgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0aW5SYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB2bSA/ICgoTWF0aC5wb3cobW91c2VYIC0gdm0ueCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB2bS55LCAyKSkgPCBNYXRoLnBvdyh2bS5oaXRSYWRpdXMgKyB2bS5yYWRpdXMsIDIpKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGluTGFiZWxSYW5nZTogeFJhbmdlLFxuXHRpblhSYW5nZTogeFJhbmdlLFxuXHRpbllSYW5nZTogeVJhbmdlLFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54LFxuXHRcdFx0eTogdm0ueVxuXHRcdH07XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguUEkgKiBNYXRoLnBvdyh0aGlzLl92aWV3LnJhZGl1cywgMik7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54LFxuXHRcdFx0eTogdm0ueSxcblx0XHRcdHBhZGRpbmc6IHZtLnJhZGl1cyArIHZtLmJvcmRlcldpZHRoXG5cdFx0fTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihjaGFydEFyZWEpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHBvaW50U3R5bGUgPSB2bS5wb2ludFN0eWxlO1xuXHRcdHZhciByb3RhdGlvbiA9IHZtLnJvdGF0aW9uO1xuXHRcdHZhciByYWRpdXMgPSB2bS5yYWRpdXM7XG5cdFx0dmFyIHggPSB2bS54O1xuXHRcdHZhciB5ID0gdm0ueTtcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgZGVmYXVsdENvbG9yID0gZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuXG5cdFx0aWYgKHZtLnNraXApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDbGlwcGluZyBmb3IgUG9pbnRzLlxuXHRcdGlmIChjaGFydEFyZWEgPT09IHVuZGVmaW5lZCB8fCBoZWxwZXJzJDEuY2FudmFzLl9pc1BvaW50SW5BcmVhKHZtLCBjaGFydEFyZWEpKSB7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2bS5ib3JkZXJDb2xvciB8fCBkZWZhdWx0Q29sb3I7XG5cdFx0XHRjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkMih2bS5ib3JkZXJXaWR0aCwgZ2xvYmFsRGVmYXVsdHMuZWxlbWVudHMucG9pbnQuYm9yZGVyV2lkdGgpO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvciB8fCBkZWZhdWx0Q29sb3I7XG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmRyYXdQb2ludChjdHgsIHBvaW50U3R5bGUsIHJhZGl1cywgeCwgeSwgcm90YXRpb24pO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBkZWZhdWx0Q29sb3IkMiA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGVsZW1lbnRzOiB7XG5cdFx0cmVjdGFuZ2xlOiB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvciQyLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvciQyLFxuXHRcdFx0Ym9yZGVyU2tpcHBlZDogJ2JvdHRvbScsXG5cdFx0XHRib3JkZXJXaWR0aDogMFxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGlzVmVydGljYWwodm0pIHtcblx0cmV0dXJuIHZtICYmIHZtLndpZHRoICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSBiYXIge0NoYXJ0LkVsZW1lbnQuUmVjdGFuZ2xlfSB0aGUgYmFyXG4gKiBAcmV0dXJuIHtCb3VuZHN9IGJvdW5kcyBvZiB0aGUgYmFyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHModm0pIHtcblx0dmFyIHgxLCB4MiwgeTEsIHkyLCBoYWxmO1xuXG5cdGlmIChpc1ZlcnRpY2FsKHZtKSkge1xuXHRcdGhhbGYgPSB2bS53aWR0aCAvIDI7XG5cdFx0eDEgPSB2bS54IC0gaGFsZjtcblx0XHR4MiA9IHZtLnggKyBoYWxmO1xuXHRcdHkxID0gTWF0aC5taW4odm0ueSwgdm0uYmFzZSk7XG5cdFx0eTIgPSBNYXRoLm1heCh2bS55LCB2bS5iYXNlKTtcblx0fSBlbHNlIHtcblx0XHRoYWxmID0gdm0uaGVpZ2h0IC8gMjtcblx0XHR4MSA9IE1hdGgubWluKHZtLngsIHZtLmJhc2UpO1xuXHRcdHgyID0gTWF0aC5tYXgodm0ueCwgdm0uYmFzZSk7XG5cdFx0eTEgPSB2bS55IC0gaGFsZjtcblx0XHR5MiA9IHZtLnkgKyBoYWxmO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRsZWZ0OiB4MSxcblx0XHR0b3A6IHkxLFxuXHRcdHJpZ2h0OiB4Mixcblx0XHRib3R0b206IHkyXG5cdH07XG59XG5cbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XG5cdHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyU2tpcHBlZCh2bSkge1xuXHR2YXIgZWRnZSA9IHZtLmJvcmRlclNraXBwZWQ7XG5cdHZhciByZXMgPSB7fTtcblxuXHRpZiAoIWVkZ2UpIHtcblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0aWYgKHZtLmhvcml6b250YWwpIHtcblx0XHRpZiAodm0uYmFzZSA+IHZtLngpIHtcblx0XHRcdGVkZ2UgPSBzd2FwKGVkZ2UsICdsZWZ0JywgJ3JpZ2h0Jyk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHZtLmJhc2UgPCB2bS55KSB7XG5cdFx0ZWRnZSA9IHN3YXAoZWRnZSwgJ2JvdHRvbScsICd0b3AnKTtcblx0fVxuXG5cdHJlc1tlZGdlXSA9IHRydWU7XG5cdHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgodm0sIG1heFcsIG1heEgpIHtcblx0dmFyIHZhbHVlID0gdm0uYm9yZGVyV2lkdGg7XG5cdHZhciBza2lwID0gcGFyc2VCb3JkZXJTa2lwcGVkKHZtKTtcblx0dmFyIHQsIHIsIGIsIGw7XG5cblx0aWYgKGhlbHBlcnMkMS5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHR0ID0gK3ZhbHVlLnRvcCB8fCAwO1xuXHRcdHIgPSArdmFsdWUucmlnaHQgfHwgMDtcblx0XHRiID0gK3ZhbHVlLmJvdHRvbSB8fCAwO1xuXHRcdGwgPSArdmFsdWUubGVmdCB8fCAwO1xuXHR9IGVsc2Uge1xuXHRcdHQgPSByID0gYiA9IGwgPSArdmFsdWUgfHwgMDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0dDogc2tpcC50b3AgfHwgKHQgPCAwKSA/IDAgOiB0ID4gbWF4SCA/IG1heEggOiB0LFxuXHRcdHI6IHNraXAucmlnaHQgfHwgKHIgPCAwKSA/IDAgOiByID4gbWF4VyA/IG1heFcgOiByLFxuXHRcdGI6IHNraXAuYm90dG9tIHx8IChiIDwgMCkgPyAwIDogYiA+IG1heEggPyBtYXhIIDogYixcblx0XHRsOiBza2lwLmxlZnQgfHwgKGwgPCAwKSA/IDAgOiBsID4gbWF4VyA/IG1heFcgOiBsXG5cdH07XG59XG5cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHModm0pIHtcblx0dmFyIGJvdW5kcyA9IGdldEJhckJvdW5kcyh2bSk7XG5cdHZhciB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuXHR2YXIgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG5cdHZhciBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKHZtLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXG5cdHJldHVybiB7XG5cdFx0b3V0ZXI6IHtcblx0XHRcdHg6IGJvdW5kcy5sZWZ0LFxuXHRcdFx0eTogYm91bmRzLnRvcCxcblx0XHRcdHc6IHdpZHRoLFxuXHRcdFx0aDogaGVpZ2h0XG5cdFx0fSxcblx0XHRpbm5lcjoge1xuXHRcdFx0eDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcblx0XHRcdHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcblx0XHRcdHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcblx0XHRcdGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmJcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIGluUmFuZ2Uodm0sIHgsIHkpIHtcblx0dmFyIHNraXBYID0geCA9PT0gbnVsbDtcblx0dmFyIHNraXBZID0geSA9PT0gbnVsbDtcblx0dmFyIGJvdW5kcyA9ICF2bSB8fCAoc2tpcFggJiYgc2tpcFkpID8gZmFsc2UgOiBnZXRCYXJCb3VuZHModm0pO1xuXG5cdHJldHVybiBib3VuZHNcblx0XHQmJiAoc2tpcFggfHwgeCA+PSBib3VuZHMubGVmdCAmJiB4IDw9IGJvdW5kcy5yaWdodClcblx0XHQmJiAoc2tpcFkgfHwgeSA+PSBib3VuZHMudG9wICYmIHkgPD0gYm91bmRzLmJvdHRvbSk7XG59XG5cbnZhciBlbGVtZW50X3JlY3RhbmdsZSA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIHJlY3RzID0gYm91bmRpbmdSZWN0cyh2bSk7XG5cdFx0dmFyIG91dGVyID0gcmVjdHMub3V0ZXI7XG5cdFx0dmFyIGlubmVyID0gcmVjdHMuaW5uZXI7XG5cblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5maWxsUmVjdChvdXRlci54LCBvdXRlci55LCBvdXRlci53LCBvdXRlci5oKTtcblxuXHRcdGlmIChvdXRlci53ID09PSBpbm5lci53ICYmIG91dGVyLmggPT09IGlubmVyLmgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguc2F2ZSgpO1xuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgucmVjdChvdXRlci54LCBvdXRlci55LCBvdXRlci53LCBvdXRlci5oKTtcblx0XHRjdHguY2xpcCgpO1xuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5ib3JkZXJDb2xvcjtcblx0XHRjdHgucmVjdChpbm5lci54LCBpbm5lci55LCBpbm5lci53LCBpbm5lci5oKTtcblx0XHRjdHguZmlsbCgnZXZlbm9kZCcpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdH0sXG5cblx0aGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB2bS5iYXNlIC0gdm0ueTtcblx0fSxcblxuXHRpblJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdHJldHVybiBpblJhbmdlKHRoaXMuX3ZpZXcsIG1vdXNlWCwgbW91c2VZKTtcblx0fSxcblxuXHRpbkxhYmVsUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gaXNWZXJ0aWNhbCh2bSlcblx0XHRcdD8gaW5SYW5nZSh2bSwgbW91c2VYLCBudWxsKVxuXHRcdFx0OiBpblJhbmdlKHZtLCBudWxsLCBtb3VzZVkpO1xuXHR9LFxuXG5cdGluWFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBtb3VzZVgsIG51bGwpO1xuXHR9LFxuXG5cdGluWVJhbmdlOiBmdW5jdGlvbihtb3VzZVkpIHtcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBudWxsLCBtb3VzZVkpO1xuXHR9LFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciB4LCB5O1xuXHRcdGlmIChpc1ZlcnRpY2FsKHZtKSkge1xuXHRcdFx0eCA9IHZtLng7XG5cdFx0XHR5ID0gKHZtLnkgKyB2bS5iYXNlKSAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHggPSAodm0ueCArIHZtLmJhc2UpIC8gMjtcblx0XHRcdHkgPSB2bS55O1xuXHRcdH1cblxuXHRcdHJldHVybiB7eDogeCwgeTogeX07XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdHJldHVybiBpc1ZlcnRpY2FsKHZtKVxuXHRcdFx0PyB2bS53aWR0aCAqIE1hdGguYWJzKHZtLnkgLSB2bS5iYXNlKVxuXHRcdFx0OiB2bS5oZWlnaHQgKiBNYXRoLmFicyh2bS54IC0gdm0uYmFzZSk7XG5cdH0sXG5cblx0dG9vbHRpcFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54LFxuXHRcdFx0eTogdm0ueVxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgZWxlbWVudHMgPSB7fTtcbnZhciBBcmMgPSBlbGVtZW50X2FyYztcbnZhciBMaW5lID0gZWxlbWVudF9saW5lO1xudmFyIFBvaW50ID0gZWxlbWVudF9wb2ludDtcbnZhciBSZWN0YW5nbGUgPSBlbGVtZW50X3JlY3RhbmdsZTtcbmVsZW1lbnRzLkFyYyA9IEFyYztcbmVsZW1lbnRzLkxpbmUgPSBMaW5lO1xuZWxlbWVudHMuUG9pbnQgPSBQb2ludDtcbmVsZW1lbnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcblxudmFyIHJlc29sdmUkMSA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnYmFyJywge1xuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdsYWJlbCdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdjYXRlZ29yeScsXG5cdFx0XHRjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcblx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOSxcblx0XHRcdG9mZnNldDogdHJ1ZSxcblx0XHRcdGdyaWRMaW5lczoge1xuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcblx0XHRcdH1cblx0XHR9XSxcblxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcidcblx0XHR9XVxuXHR9XG59KTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgXCJvcHRpbWFsXCIgc2FtcGxlIHNpemUgdG8gbWFpbnRhaW4gYmFycyBlcXVhbGx5IHNpemVkIHdoaWxlIHByZXZlbnRpbmcgb3ZlcmxhcC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKHNjYWxlLCBwaXhlbHMpIHtcblx0dmFyIG1pbiA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpID8gc2NhbGUud2lkdGggOiBzY2FsZS5oZWlnaHQ7XG5cdHZhciB0aWNrcyA9IHNjYWxlLmdldFRpY2tzKCk7XG5cdHZhciBwcmV2LCBjdXJyLCBpLCBpbGVuO1xuXG5cdGZvciAoaSA9IDEsIGlsZW4gPSBwaXhlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0bWluID0gTWF0aC5taW4obWluLCBNYXRoLmFicyhwaXhlbHNbaV0gLSBwaXhlbHNbaSAtIDFdKSk7XG5cdH1cblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0Y3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcblx0XHRtaW4gPSBpID4gMCA/IE1hdGgubWluKG1pbiwgY3VyciAtIHByZXYpIDogbWluO1xuXHRcdHByZXYgPSBjdXJyO1xuXHR9XG5cblx0cmV0dXJuIG1pbjtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhbiBcImlkZWFsXCIgY2F0ZWdvcnkgYmFzZWQgb24gdGhlIGFic29sdXRlIGJhciB0aGlja25lc3Mgb3IsIGlmIHVuZGVmaW5lZCBvciBudWxsLFxuICogdXNlcyB0aGUgc21hbGxlc3QgaW50ZXJ2YWwgKHNlZSBjb21wdXRlTWluU2FtcGxlU2l6ZSkgdGhhdCBwcmV2ZW50cyBiYXIgb3ZlcmxhcHBpbmcuIFRoaXNcbiAqIG1vZGUgY3VycmVudGx5IGFsd2F5cyBnZW5lcmF0ZXMgYmFycyBlcXVhbGx5IHNpemVkICh1bnRpbCB3ZSBpbnRyb2R1Y2Ugc2NyaXB0YWJsZSBvcHRpb25zPykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKSB7XG5cdHZhciB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcblx0dmFyIGNvdW50ID0gcnVsZXIuc3RhY2tDb3VudDtcblx0dmFyIGN1cnIgPSBydWxlci5waXhlbHNbaW5kZXhdO1xuXHR2YXIgc2l6ZSwgcmF0aW87XG5cblx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcblx0XHRzaXplID0gcnVsZXIubWluICogb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG5cdFx0cmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gV2hlbiBiYXIgdGhpY2tuZXNzIGlzIGVuZm9yY2VkLCBjYXRlZ29yeSBhbmQgYmFyIHBlcmNlbnRhZ2VzIGFyZSBpZ25vcmVkLlxuXHRcdC8vIE5vdGUoU0IpOiB3ZSBjb3VsZCBhZGQgc3VwcG9ydCBmb3IgcmVsYXRpdmUgYmFyIHRoaWNrbmVzcyAoZS5nLiBiYXJUaGlja25lc3M6ICc1MCUnKVxuXHRcdC8vIGFuZCBkZXByZWNhdGUgYmFyUGVyY2VudGFnZSBzaW5jZSB0aGlzIHZhbHVlIGlzIGlnbm9yZWQgd2hlbiB0aGlja25lc3MgaXMgYWJzb2x1dGUuXG5cdFx0c2l6ZSA9IHRoaWNrbmVzcyAqIGNvdW50O1xuXHRcdHJhdGlvID0gMTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Y2h1bms6IHNpemUgLyBjb3VudCxcblx0XHRyYXRpbzogcmF0aW8sXG5cdFx0c3RhcnQ6IGN1cnIgLSAoc2l6ZSAvIDIpXG5cdH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJvcHRpbWFsXCIgY2F0ZWdvcnkgdGhhdCBnbG9iYWxseSBhcnJhbmdlcyBiYXJzIHNpZGUgYnkgc2lkZSAobm8gZ2FwIHdoZW5cbiAqIHBlcmNlbnRhZ2Ugb3B0aW9ucyBhcmUgMSksIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBhbmQgZm9sbG93aW5nIGNhdGVnb3JpZXMuIFRoaXMgbW9kZVxuICogZ2VuZXJhdGVzIGJhcnMgd2l0aCBkaWZmZXJlbnQgd2lkdGhzIHdoZW4gZGF0YSBhcmUgbm90IGV2ZW5seSBzcGFjZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucykge1xuXHR2YXIgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuXHR2YXIgY3VyciA9IHBpeGVsc1tpbmRleF07XG5cdHZhciBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xuXHR2YXIgbmV4dCA9IGluZGV4IDwgcGl4ZWxzLmxlbmd0aCAtIDEgPyBwaXhlbHNbaW5kZXggKyAxXSA6IG51bGw7XG5cdHZhciBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG5cdHZhciBzdGFydCwgc2l6ZTtcblxuXHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdC8vIGZpcnN0IGRhdGE6IGl0cyBzaXplIGlzIGRvdWJsZSBiYXNlZCBvbiB0aGUgbmV4dCBwb2ludCBvcixcblx0XHQvLyBpZiBpdCdzIGFsc28gdGhlIGxhc3QgZGF0YSwgd2UgdXNlIHRoZSBzY2FsZSBzaXplLlxuXHRcdHByZXYgPSBjdXJyIC0gKG5leHQgPT09IG51bGwgPyBydWxlci5lbmQgLSBydWxlci5zdGFydCA6IG5leHQgLSBjdXJyKTtcblx0fVxuXG5cdGlmIChuZXh0ID09PSBudWxsKSB7XG5cdFx0Ly8gbGFzdCBkYXRhOiBpdHMgc2l6ZSBpcyBhbHNvIGRvdWJsZSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcG9pbnQuXG5cdFx0bmV4dCA9IGN1cnIgKyBjdXJyIC0gcHJldjtcblx0fVxuXG5cdHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XG5cdHNpemUgPSBNYXRoLmFicyhuZXh0IC0gcHJldikgLyAyICogcGVyY2VudDtcblxuXHRyZXR1cm4ge1xuXHRcdGNodW5rOiBzaXplIC8gcnVsZXIuc3RhY2tDb3VudCxcblx0XHRyYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxuXHRcdHN0YXJ0OiBzdGFydFxuXHR9O1xufVxuXG52YXIgY29udHJvbGxlcl9iYXIgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5SZWN0YW5nbGUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YTtcblxuXHRcdGNvcmVfZGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cblx0XHRtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdG1ldGEuc3RhY2sgPSBtZS5nZXREYXRhc2V0KCkuc3RhY2s7XG5cdFx0bWV0YS5iYXIgPSB0cnVlO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciByZWN0cyA9IG1lLmdldE1ldGEoKS5kYXRhO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0bWUuX3J1bGVyID0gbWUuZ2V0UnVsZXIoKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSByZWN0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocmVjdHNbaV0sIGksIHJlc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhyZWN0YW5nbGUsIGluZGV4KTtcblxuXHRcdHJlY3RhbmdsZS5feFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xuXHRcdHJlY3RhbmdsZS5feVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHJlY3RhbmdsZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0cmVjdGFuZ2xlLl9pbmRleCA9IGluZGV4O1xuXHRcdHJlY3RhbmdsZS5fbW9kZWwgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJTa2lwcGVkOiBvcHRpb25zLmJvcmRlclNraXBwZWQsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdGRhdGFzZXRMYWJlbDogZGF0YXNldC5sYWJlbCxcblx0XHRcdGxhYmVsOiBtZS5jaGFydC5kYXRhLmxhYmVsc1tpbmRleF1cblx0XHR9O1xuXG5cdFx0bWUuX3VwZGF0ZUVsZW1lbnRHZW9tZXRyeShyZWN0YW5nbGUsIGluZGV4LCByZXNldCk7XG5cblx0XHRyZWN0YW5nbGUucGl2b3QoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF91cGRhdGVFbGVtZW50R2VvbWV0cnk6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbW9kZWwgPSByZWN0YW5nbGUuX21vZGVsO1xuXHRcdHZhciB2c2NhbGUgPSBtZS5fZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdHZhciBiYXNlID0gdnNjYWxlLmdldEJhc2VQaXhlbCgpO1xuXHRcdHZhciBob3Jpem9udGFsID0gdnNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBydWxlciA9IG1lLl9ydWxlciB8fCBtZS5nZXRSdWxlcigpO1xuXHRcdHZhciB2cGl4ZWxzID0gbWUuY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMobWUuaW5kZXgsIGluZGV4KTtcblx0XHR2YXIgaXBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKG1lLmluZGV4LCBpbmRleCwgcnVsZXIpO1xuXG5cdFx0bW9kZWwuaG9yaXpvbnRhbCA9IGhvcml6b250YWw7XG5cdFx0bW9kZWwuYmFzZSA9IHJlc2V0ID8gYmFzZSA6IHZwaXhlbHMuYmFzZTtcblx0XHRtb2RlbC54ID0gaG9yaXpvbnRhbCA/IHJlc2V0ID8gYmFzZSA6IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyO1xuXHRcdG1vZGVsLnkgPSBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmhlYWQ7XG5cdFx0bW9kZWwuaGVpZ2h0ID0gaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IHVuZGVmaW5lZDtcblx0XHRtb2RlbC53aWR0aCA9IGhvcml6b250YWwgPyB1bmRlZmluZWQgOiBpcGl4ZWxzLnNpemU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xhc3RdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgbGlzdCBvZiBzdGFjayBJRHNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRTdGFja3M6IGZ1bmN0aW9uKGxhc3QpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRJbmRleFNjYWxlKCk7XG5cdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG5cdFx0dmFyIGlsZW4gPSBsYXN0ID09PSB1bmRlZmluZWQgPyBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCA6IGxhc3QgKyAxO1xuXHRcdHZhciBzdGFja3MgPSBbXTtcblx0XHR2YXIgaSwgbWV0YTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdGlmIChtZXRhLmJhciAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpICYmXG5cdFx0XHRcdChzdGFja2VkID09PSBmYWxzZSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdHJ1ZSAmJiBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEpIHx8XG5cdFx0XHRcdChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgKG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEpKSkpIHtcblx0XHRcdFx0c3RhY2tzLnB1c2gobWV0YS5zdGFjayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0YWNrcztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIG51bWJlciBvZiBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFN0YWNrQ291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRTdGFja3MoKS5sZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFzZXRJbmRleF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgc3RhY2sgaW5kZXhcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFN0YWNrSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgbmFtZSkge1xuXHRcdHZhciBzdGFja3MgPSB0aGlzLl9nZXRTdGFja3MoZGF0YXNldEluZGV4KTtcblx0XHR2YXIgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0PyBzdGFja3MuaW5kZXhPZihuYW1lKVxuXHRcdFx0OiAtMTsgLy8gaW5kZXhPZiByZXR1cm5zIC0xIGlmIGVsZW1lbnQgaXMgbm90IHByZXNlbnRcblxuXHRcdHJldHVybiAoaW5kZXggPT09IC0xKVxuXHRcdFx0PyBzdGFja3MubGVuZ3RoIC0gMVxuXHRcdFx0OiBpbmRleDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldFJ1bGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRJbmRleFNjYWxlKCk7XG5cdFx0dmFyIHN0YWNrQ291bnQgPSBtZS5nZXRTdGFja0NvdW50KCk7XG5cdFx0dmFyIGRhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgc3RhcnQgPSBpc0hvcml6b250YWwgPyBzY2FsZS5sZWZ0IDogc2NhbGUudG9wO1xuXHRcdHZhciBlbmQgPSBzdGFydCArIChpc0hvcml6b250YWwgPyBzY2FsZS53aWR0aCA6IHNjYWxlLmhlaWdodCk7XG5cdFx0dmFyIHBpeGVscyA9IFtdO1xuXHRcdHZhciBpLCBpbGVuLCBtaW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbWUuZ2V0TWV0YSgpLmRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRwaXhlbHMucHVzaChzY2FsZS5nZXRQaXhlbEZvclZhbHVlKG51bGwsIGksIGRhdGFzZXRJbmRleCkpO1xuXHRcdH1cblxuXHRcdG1pbiA9IGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHNjYWxlLm9wdGlvbnMuYmFyVGhpY2tuZXNzKVxuXHRcdFx0PyBjb21wdXRlTWluU2FtcGxlU2l6ZShzY2FsZSwgcGl4ZWxzKVxuXHRcdFx0OiAtMTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRtaW46IG1pbixcblx0XHRcdHBpeGVsczogcGl4ZWxzLFxuXHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0ZW5kOiBlbmQsXG5cdFx0XHRzdGFja0NvdW50OiBzdGFja0NvdW50LFxuXHRcdFx0c2NhbGU6IHNjYWxlXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogTm90ZTogcGl4ZWwgdmFsdWVzIGFyZSBub3QgY2xhbXBlZCB0byB0aGUgc2NhbGUgYXJlYS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciB2YWx1ZSA9ICtzY2FsZS5nZXRSaWdodFZhbHVlKGRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHRcdHZhciBtaW5CYXJMZW5ndGggPSBzY2FsZS5vcHRpb25zLm1pbkJhckxlbmd0aDtcblx0XHR2YXIgc3RhY2tlZCA9IHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcblx0XHR2YXIgc3RhY2sgPSBtZXRhLnN0YWNrO1xuXHRcdHZhciBzdGFydCA9IDA7XG5cdFx0dmFyIGksIGltZXRhLCBpdmFsdWUsIGJhc2UsIGhlYWQsIHNpemU7XG5cblx0XHRpZiAoc3RhY2tlZCB8fCAoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIHN0YWNrICE9PSB1bmRlZmluZWQpKSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcblx0XHRcdFx0aW1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblxuXHRcdFx0XHRpZiAoaW1ldGEuYmFyICYmXG5cdFx0XHRcdFx0aW1ldGEuc3RhY2sgPT09IHN0YWNrICYmXG5cdFx0XHRcdFx0aW1ldGEuY29udHJvbGxlci5fZ2V0VmFsdWVTY2FsZUlkKCkgPT09IHNjYWxlLmlkICYmXG5cdFx0XHRcdFx0Y2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXG5cdFx0XHRcdFx0aXZhbHVlID0gK3NjYWxlLmdldFJpZ2h0VmFsdWUoZGF0YXNldHNbaV0uZGF0YVtpbmRleF0pO1xuXHRcdFx0XHRcdGlmICgodmFsdWUgPCAwICYmIGl2YWx1ZSA8IDApIHx8ICh2YWx1ZSA+PSAwICYmIGl2YWx1ZSA+IDApKSB7XG5cdFx0XHRcdFx0XHRzdGFydCArPSBpdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YmFzZSA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQpO1xuXHRcdGhlYWQgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgdmFsdWUpO1xuXHRcdHNpemUgPSBoZWFkIC0gYmFzZTtcblxuXHRcdGlmIChtaW5CYXJMZW5ndGggIT09IHVuZGVmaW5lZCAmJiBNYXRoLmFicyhzaXplKSA8IG1pbkJhckxlbmd0aCkge1xuXHRcdFx0c2l6ZSA9IG1pbkJhckxlbmd0aDtcblx0XHRcdGlmICh2YWx1ZSA+PSAwICYmICFpc0hvcml6b250YWwgfHwgdmFsdWUgPCAwICYmIGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRoZWFkID0gYmFzZSAtIG1pbkJhckxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhlYWQgPSBiYXNlICsgbWluQmFyTGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0YmFzZTogYmFzZSxcblx0XHRcdGhlYWQ6IGhlYWQsXG5cdFx0XHRjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjYWxjdWxhdGVCYXJJbmRleFBpeGVsczogZnVuY3Rpb24oZGF0YXNldEluZGV4LCBpbmRleCwgcnVsZXIpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gcnVsZXIuc2NhbGUub3B0aW9ucztcblx0XHR2YXIgcmFuZ2UgPSBvcHRpb25zLmJhclRoaWNrbmVzcyA9PT0gJ2ZsZXgnXG5cdFx0XHQ/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKVxuXHRcdFx0OiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zKTtcblxuXHRcdHZhciBzdGFja0luZGV4ID0gbWUuZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG1lLmdldE1ldGEoKS5zdGFjayk7XG5cdFx0dmFyIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcblx0XHR2YXIgc2l6ZSA9IE1hdGgubWluKFxuXHRcdFx0aGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubWF4QmFyVGhpY2tuZXNzLCBJbmZpbml0eSksXG5cdFx0XHRyYW5nZS5jaHVuayAqIHJhbmdlLnJhdGlvKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcblx0XHRcdGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuXHRcdFx0Y2VudGVyOiBjZW50ZXIsXG5cdFx0XHRzaXplOiBzaXplXG5cdFx0fTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBzY2FsZSA9IG1lLl9nZXRWYWx1ZVNjYWxlKCk7XG5cdFx0dmFyIHJlY3RzID0gbWUuZ2V0TWV0YSgpLmRhdGE7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGlsZW4gPSByZWN0cy5sZW5ndGg7XG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0aGVscGVycyQxLmNhbnZhcy5jbGlwQXJlYShjaGFydC5jdHgsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKCFpc05hTihzY2FsZS5nZXRSaWdodFZhbHVlKGRhdGFzZXQuZGF0YVtpXSkpKSB7XG5cdFx0XHRcdHJlY3RzW2ldLmRyYXcoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY2hhcnQuY3R4KTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlRWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGRhdGFzZXQgPSBkYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IHJlY3RhbmdsZS5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLnJlY3RhbmdsZTtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlclNraXBwZWQnLFxuXHRcdFx0J2JvcmRlcldpZHRoJ1xuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkMShbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH1cbn0pO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkMyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcbnZhciByZXNvbHZlJDIgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2J1YmJsZScsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsIC8vIGJ1YmJsZSBzaG91bGQgcHJvYmFibHkgdXNlIGEgbGluZWFyIHNjYWxlIGJ5IGRlZmF1bHRcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJyxcblx0XHRcdGlkOiAneC1heGlzLTAnIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0Jyxcblx0XHRcdGlkOiAneS1heGlzLTAnXG5cdFx0fV1cblx0fSxcblxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBUaXRsZSBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2Ugd2UgZm9ybWF0IHRoZSBkYXRhIGFzIGEgcG9pbnRcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBkYXRhc2V0TGFiZWwgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcblx0XHRcdFx0dmFyIGRhdGFQb2ludCA9IGRhdGEuZGF0YXNldHNbaXRlbS5kYXRhc2V0SW5kZXhdLmRhdGFbaXRlbS5pbmRleF07XG5cdFx0XHRcdHJldHVybiBkYXRhc2V0TGFiZWwgKyAnOiAoJyArIGl0ZW0ueExhYmVsICsgJywgJyArIGl0ZW0ueUxhYmVsICsgJywgJyArIGRhdGFQb2ludC5yICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX2J1YmJsZSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGE7XG5cblx0XHQvLyBVcGRhdGUgUG9pbnRzXG5cdFx0aGVscGVycyQxLmVhY2gocG9pbnRzLCBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGluZGV4LCByZXNldCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIHhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHR2YXIgeVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhwb2ludCwgaW5kZXgpO1xuXHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGFbaW5kZXhdO1xuXHRcdHZhciBkc0luZGV4ID0gbWUuaW5kZXg7XG5cblx0XHR2YXIgeCA9IHJlc2V0ID8geFNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogeFNjYWxlLmdldFBpeGVsRm9yVmFsdWUodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gZGF0YSA6IE5hTiwgaW5kZXgsIGRzSW5kZXgpO1xuXHRcdHZhciB5ID0gcmVzZXQgPyB5U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShkYXRhLCBpbmRleCwgZHNJbmRleCk7XG5cblx0XHRwb2ludC5feFNjYWxlID0geFNjYWxlO1xuXHRcdHBvaW50Ll95U2NhbGUgPSB5U2NhbGU7XG5cdFx0cG9pbnQuX29wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHBvaW50Ll9kYXRhc2V0SW5kZXggPSBkc0luZGV4O1xuXHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xuXHRcdHBvaW50Ll9tb2RlbCA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1cyxcblx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuXHRcdFx0cmFkaXVzOiByZXNldCA/IDAgOiBvcHRpb25zLnJhZGl1cyxcblx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuXHRcdFx0eDogeCxcblx0XHRcdHk6IHksXG5cdFx0fTtcblxuXHRcdHBvaW50LnBpdm90KCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gcG9pbnQuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblxuXHRcdHBvaW50LiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQzKG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDMob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDMob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0XHRtb2RlbC5yYWRpdXMgPSBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaG92ZXJSYWRpdXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihwb2ludCwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGRhdGFzZXQgPSBkYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMucG9pbnQ7XG5cdFx0dmFyIGRhdGEgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2hvdmVyQmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdob3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdCdob3ZlckJvcmRlcldpZHRoJyxcblx0XHRcdCdob3ZlclJhZGl1cycsXG5cdFx0XHQnaGl0UmFkaXVzJyxcblx0XHRcdCdwb2ludFN0eWxlJyxcblx0XHRcdCdyb3RhdGlvbidcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDIoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHR9XG5cblx0XHQvLyBDdXN0b20gcmFkaXVzIHJlc29sdXRpb25cblx0XHR2YWx1ZXMucmFkaXVzID0gcmVzb2x2ZSQyKFtcblx0XHRcdGN1c3RvbS5yYWRpdXMsXG5cdFx0XHRkYXRhID8gZGF0YS5yIDogdW5kZWZpbmVkLFxuXHRcdFx0ZGF0YXNldC5yYWRpdXMsXG5cdFx0XHRvcHRpb25zLnJhZGl1c1xuXHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH1cbn0pO1xuXG52YXIgcmVzb2x2ZSQzID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcbnZhciB2YWx1ZU9yRGVmYXVsdCQ0ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2RvdWdobnV0Jywge1xuXHRhbmltYXRpb246IHtcblx0XHQvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgRG91Z2hudXRcblx0XHRhbmltYXRlUm90YXRlOiB0cnVlLFxuXHRcdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHdlIGFuaW1hdGUgc2NhbGluZyB0aGUgRG91Z2hudXQgZnJvbSB0aGUgY2VudHJlXG5cdFx0YW5pbWF0ZVNjYWxlOiBmYWxzZVxuXHR9LFxuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdzaW5nbGUnXG5cdH0sXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0ZXh0ID0gW107XG5cdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xuXG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xuXG5cdFx0aWYgKGRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgZGF0YXNldHNbMF0uYmFja2dyb3VuZENvbG9yW2ldICsgJ1wiPjwvc3Bhbj4nKTtcblx0XHRcdFx0aWYgKGxhYmVsc1tpXSkge1xuXHRcdFx0XHRcdHRleHQucHVzaChsYWJlbHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRleHQucHVzaCgnPC9saT4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdH0sXG5cdGxlZ2VuZDoge1xuXHRcdGxhYmVsczoge1xuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHRcdFx0aWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcblx0XHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG5cdFx0XHRcdFx0XHR2YXIgZHMgPSBkYXRhLmRhdGFzZXRzWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGFyYyA9IG1ldGEuZGF0YVtpXTtcblx0XHRcdFx0XHRcdHZhciBjdXN0b20gPSBhcmMgJiYgYXJjLmN1c3RvbSB8fCB7fTtcblx0XHRcdFx0XHRcdHZhciBhcmNPcHRzID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmM7XG5cdFx0XHRcdFx0XHR2YXIgZmlsbCA9IHJlc29sdmUkMyhbY3VzdG9tLmJhY2tncm91bmRDb2xvciwgZHMuYmFja2dyb3VuZENvbG9yLCBhcmNPcHRzLmJhY2tncm91bmRDb2xvcl0sIHVuZGVmaW5lZCwgaSk7XG5cdFx0XHRcdFx0XHR2YXIgc3Ryb2tlID0gcmVzb2x2ZSQzKFtjdXN0b20uYm9yZGVyQ29sb3IsIGRzLmJvcmRlckNvbG9yLCBhcmNPcHRzLmJvcmRlckNvbG9yXSwgdW5kZWZpbmVkLCBpKTtcblx0XHRcdFx0XHRcdHZhciBidyA9IHJlc29sdmUkMyhbY3VzdG9tLmJvcmRlcldpZHRoLCBkcy5ib3JkZXJXaWR0aCwgYXJjT3B0cy5ib3JkZXJXaWR0aF0sIHVuZGVmaW5lZCwgaSk7XG5cblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHRleHQ6IGxhYmVsLFxuXHRcdFx0XHRcdFx0XHRmaWxsU3R5bGU6IGZpbGwsXG5cdFx0XHRcdFx0XHRcdHN0cm9rZVN0eWxlOiBzdHJva2UsXG5cdFx0XHRcdFx0XHRcdGxpbmVXaWR0aDogYncsXG5cdFx0XHRcdFx0XHRcdGhpZGRlbjogaXNOYU4oZHMuZGF0YVtpXSkgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbixcblxuXHRcdFx0XHRcdFx0XHQvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cblx0XHRcdFx0XHRcdFx0aW5kZXg6IGlcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmluZGV4O1xuXHRcdFx0dmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcblx0XHRcdHZhciBpLCBpbGVuLCBtZXRhO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdC8vIHRvZ2dsZSB2aXNpYmlsaXR5IG9mIGluZGV4IGlmIGV4aXN0c1xuXHRcdFx0XHRpZiAobWV0YS5kYXRhW2luZGV4XSkge1xuXHRcdFx0XHRcdG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuID0gIW1ldGEuZGF0YVtpbmRleF0uaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnVwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG5cdGN1dG91dFBlcmNlbnRhZ2U6IDUwLFxuXG5cdC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG5cdHJvdGF0aW9uOiBNYXRoLlBJICogLTAuNSxcblxuXHQvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG5cdGNpcmN1bWZlcmVuY2U6IE1hdGguUEkgKiAyLjAsXG5cblx0Ly8gTmVlZCB0byBvdmVycmlkZSB0aGVzZSB0byBnaXZlIGEgbmljZSBkZWZhdWx0XG5cdHRvb2x0aXBzOiB7XG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGRhdGEpIHtcblx0XHRcdFx0dmFyIGRhdGFMYWJlbCA9IGRhdGEubGFiZWxzW3Rvb2x0aXBJdGVtLmluZGV4XTtcblx0XHRcdFx0dmFyIHZhbHVlID0gJzogJyArIGRhdGEuZGF0YXNldHNbdG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4XS5kYXRhW3Rvb2x0aXBJdGVtLmluZGV4XTtcblxuXHRcdFx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkoZGF0YUxhYmVsKSkge1xuXHRcdFx0XHRcdC8vIHNob3cgdmFsdWUgb24gZmlyc3QgbGluZSBvZiBtdWx0aWxpbmUgbGFiZWxcblx0XHRcdFx0XHQvLyBuZWVkIHRvIGNsb25lIGJlY2F1c2Ugd2UgYXJlIGNoYW5naW5nIHRoZSB2YWx1ZVxuXHRcdFx0XHRcdGRhdGFMYWJlbCA9IGRhdGFMYWJlbC5zbGljZSgpO1xuXHRcdFx0XHRcdGRhdGFMYWJlbFswXSArPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhTGFiZWwgKz0gdmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZGF0YUxhYmVsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX2RvdWdobnV0ID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuQXJjLFxuXG5cdGxpbmtTY2FsZXM6IGhlbHBlcnMkMS5ub29wLFxuXG5cdC8vIEdldCBpbmRleCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cy4gVGhpcyBhbGxvd3MgZGV0ZXJtaW5pbmcgdGhlIGlubmVyIGFuZCBvdXRlciByYWRpdXMgY29ycmVjdGx5XG5cdGdldFJpbmdJbmRleDogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIHJpbmdJbmRleCA9IDA7XG5cblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFzZXRJbmRleDsgKytqKSB7XG5cdFx0XHRpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGopKSB7XG5cdFx0XHRcdCsrcmluZ0luZGV4O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByaW5nSW5kZXg7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGF2YWlsYWJsZVdpZHRoID0gY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQ7XG5cdFx0dmFyIGF2YWlsYWJsZUhlaWdodCA9IGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wO1xuXHRcdHZhciBtaW5TaXplID0gTWF0aC5taW4oYXZhaWxhYmxlV2lkdGgsIGF2YWlsYWJsZUhlaWdodCk7XG5cdFx0dmFyIG9mZnNldCA9IHt4OiAwLCB5OiAwfTtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgYXJjcyA9IG1ldGEuZGF0YTtcblx0XHR2YXIgY3V0b3V0UGVyY2VudGFnZSA9IG9wdHMuY3V0b3V0UGVyY2VudGFnZTtcblx0XHR2YXIgY2lyY3VtZmVyZW5jZSA9IG9wdHMuY2lyY3VtZmVyZW5jZTtcblx0XHR2YXIgY2hhcnRXZWlnaHQgPSBtZS5fZ2V0UmluZ1dlaWdodChtZS5pbmRleCk7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHQvLyBJZiB0aGUgY2hhcnQncyBjaXJjdW1mZXJlbmNlIGlzbid0IGEgZnVsbCBjaXJjbGUsIGNhbGN1bGF0ZSBtaW5TaXplIGFzIGEgcmF0aW8gb2YgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYXJjXG5cdFx0aWYgKGNpcmN1bWZlcmVuY2UgPCBNYXRoLlBJICogMi4wKSB7XG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb24gJSAoTWF0aC5QSSAqIDIuMCk7XG5cdFx0XHRzdGFydEFuZ2xlICs9IE1hdGguUEkgKiAyLjAgKiAoc3RhcnRBbmdsZSA+PSBNYXRoLlBJID8gLTEgOiBzdGFydEFuZ2xlIDwgLU1hdGguUEkgPyAxIDogMCk7XG5cdFx0XHR2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcblx0XHRcdHZhciBzdGFydCA9IHt4OiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgeTogTWF0aC5zaW4oc3RhcnRBbmdsZSl9O1xuXHRcdFx0dmFyIGVuZCA9IHt4OiBNYXRoLmNvcyhlbmRBbmdsZSksIHk6IE1hdGguc2luKGVuZEFuZ2xlKX07XG5cdFx0XHR2YXIgY29udGFpbnMwID0gKHN0YXJ0QW5nbGUgPD0gMCAmJiBlbmRBbmdsZSA+PSAwKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMi4wICYmIE1hdGguUEkgKiAyLjAgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIGNvbnRhaW5zOTAgPSAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMC41ICYmIE1hdGguUEkgKiAwLjUgPD0gZW5kQW5nbGUpIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgKiAyLjUgJiYgTWF0aC5QSSAqIDIuNSA8PSBlbmRBbmdsZSk7XG5cdFx0XHR2YXIgY29udGFpbnMxODAgPSAoc3RhcnRBbmdsZSA8PSAtTWF0aC5QSSAmJiAtTWF0aC5QSSA8PSBlbmRBbmdsZSkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAmJiBNYXRoLlBJIDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciBjb250YWluczI3MCA9IChzdGFydEFuZ2xlIDw9IC1NYXRoLlBJICogMC41ICYmIC1NYXRoLlBJICogMC41IDw9IGVuZEFuZ2xlKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMS41ICYmIE1hdGguUEkgKiAxLjUgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIGN1dG91dCA9IGN1dG91dFBlcmNlbnRhZ2UgLyAxMDAuMDtcblx0XHRcdHZhciBtaW4gPSB7eDogY29udGFpbnMxODAgPyAtMSA6IE1hdGgubWluKHN0YXJ0LnggKiAoc3RhcnQueCA8IDAgPyAxIDogY3V0b3V0KSwgZW5kLnggKiAoZW5kLnggPCAwID8gMSA6IGN1dG91dCkpLCB5OiBjb250YWluczI3MCA/IC0xIDogTWF0aC5taW4oc3RhcnQueSAqIChzdGFydC55IDwgMCA/IDEgOiBjdXRvdXQpLCBlbmQueSAqIChlbmQueSA8IDAgPyAxIDogY3V0b3V0KSl9O1xuXHRcdFx0dmFyIG1heCA9IHt4OiBjb250YWluczAgPyAxIDogTWF0aC5tYXgoc3RhcnQueCAqIChzdGFydC54ID4gMCA/IDEgOiBjdXRvdXQpLCBlbmQueCAqIChlbmQueCA+IDAgPyAxIDogY3V0b3V0KSksIHk6IGNvbnRhaW5zOTAgPyAxIDogTWF0aC5tYXgoc3RhcnQueSAqIChzdGFydC55ID4gMCA/IDEgOiBjdXRvdXQpLCBlbmQueSAqIChlbmQueSA+IDAgPyAxIDogY3V0b3V0KSl9O1xuXHRcdFx0dmFyIHNpemUgPSB7d2lkdGg6IChtYXgueCAtIG1pbi54KSAqIDAuNSwgaGVpZ2h0OiAobWF4LnkgLSBtaW4ueSkgKiAwLjV9O1xuXHRcdFx0bWluU2l6ZSA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoIC8gc2l6ZS53aWR0aCwgYXZhaWxhYmxlSGVpZ2h0IC8gc2l6ZS5oZWlnaHQpO1xuXHRcdFx0b2Zmc2V0ID0ge3g6IChtYXgueCArIG1pbi54KSAqIC0wLjUsIHk6IChtYXgueSArIG1pbi55KSAqIC0wLjV9O1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0YXJjc1tpXS5fb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMoYXJjc1tpXSwgaSk7XG5cdFx0fVxuXG5cdFx0Y2hhcnQuYm9yZGVyV2lkdGggPSBtZS5nZXRNYXhCb3JkZXJXaWR0aCgpO1xuXHRcdGNoYXJ0Lm91dGVyUmFkaXVzID0gTWF0aC5tYXgoKG1pblNpemUgLSBjaGFydC5ib3JkZXJXaWR0aCkgLyAyLCAwKTtcblx0XHRjaGFydC5pbm5lclJhZGl1cyA9IE1hdGgubWF4KGN1dG91dFBlcmNlbnRhZ2UgPyAoY2hhcnQub3V0ZXJSYWRpdXMgLyAxMDApICogKGN1dG91dFBlcmNlbnRhZ2UpIDogMCwgMCk7XG5cdFx0Y2hhcnQucmFkaXVzTGVuZ3RoID0gKGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQuaW5uZXJSYWRpdXMpIC8gKG1lLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkgfHwgMSk7XG5cdFx0Y2hhcnQub2Zmc2V0WCA9IG9mZnNldC54ICogY2hhcnQub3V0ZXJSYWRpdXM7XG5cdFx0Y2hhcnQub2Zmc2V0WSA9IG9mZnNldC55ICogY2hhcnQub3V0ZXJSYWRpdXM7XG5cblx0XHRtZXRhLnRvdGFsID0gbWUuY2FsY3VsYXRlVG90YWwoKTtcblxuXHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGggKiBtZS5fZ2V0UmluZ1dlaWdodE9mZnNldChtZS5pbmRleCk7XG5cdFx0bWUuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChtZS5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aCAqIGNoYXJ0V2VpZ2h0LCAwKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmNzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKGFyYywgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuXHRcdHZhciBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG5cdFx0dmFyIGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcblx0XHR2YXIgc3RhcnRBbmdsZSA9IG9wdHMucm90YXRpb247IC8vIG5vbiByZXNldCBjYXNlIGhhbmRsZWQgbGF0ZXJcblx0XHR2YXIgZW5kQW5nbGUgPSBvcHRzLnJvdGF0aW9uOyAvLyBub24gcmVzZXQgY2FzZSBoYW5kbGVkIGxhdGVyXG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyAwIDogYXJjLmhpZGRlbiA/IDAgOiBtZS5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKGRhdGFzZXQuZGF0YVtpbmRleF0pICogKG9wdHMuY2lyY3VtZmVyZW5jZSAvICgyLjAgKiBNYXRoLlBJKSk7XG5cdFx0dmFyIGlubmVyUmFkaXVzID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogbWUuaW5uZXJSYWRpdXM7XG5cdFx0dmFyIG91dGVyUmFkaXVzID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogbWUub3V0ZXJSYWRpdXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnMgfHwge307XG5cblx0XHRoZWxwZXJzJDEuZXh0ZW5kKGFyYywge1xuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRfaW5kZXg6IGluZGV4LFxuXG5cdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdFx0X21vZGVsOiB7XG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdFx0Ym9yZGVyQWxpZ246IG9wdGlvbnMuYm9yZGVyQWxpZ24sXG5cdFx0XHRcdHg6IGNlbnRlclggKyBjaGFydC5vZmZzZXRYLFxuXHRcdFx0XHR5OiBjZW50ZXJZICsgY2hhcnQub2Zmc2V0WSxcblx0XHRcdFx0c3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcblx0XHRcdFx0ZW5kQW5nbGU6IGVuZEFuZ2xlLFxuXHRcdFx0XHRjaXJjdW1mZXJlbmNlOiBjaXJjdW1mZXJlbmNlLFxuXHRcdFx0XHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXG5cdFx0XHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcblx0XHRcdFx0bGFiZWw6IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQoZGF0YXNldC5sYWJlbCwgaW5kZXgsIGNoYXJ0LmRhdGEubGFiZWxzW2luZGV4XSlcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHZhciBtb2RlbCA9IGFyYy5fbW9kZWw7XG5cblx0XHQvLyBTZXQgY29ycmVjdCBhbmdsZXMgaWYgbm90IHJlc2V0dGluZ1xuXHRcdGlmICghcmVzZXQgfHwgIWFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuXHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bW9kZWwuc3RhcnRBbmdsZSA9IG1lLmdldE1ldGEoKS5kYXRhW2luZGV4IC0gMV0uX21vZGVsLmVuZEFuZ2xlO1xuXHRcdFx0fVxuXG5cdFx0XHRtb2RlbC5lbmRBbmdsZSA9IG1vZGVsLnN0YXJ0QW5nbGUgKyBtb2RlbC5jaXJjdW1mZXJlbmNlO1xuXHRcdH1cblxuXHRcdGFyYy5waXZvdCgpO1xuXHR9LFxuXG5cdGNhbGN1bGF0ZVRvdGFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIHRvdGFsID0gMDtcblx0XHR2YXIgdmFsdWU7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChtZXRhLmRhdGEsIGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cdFx0XHR2YWx1ZSA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSAmJiAhZWxlbWVudC5oaWRkZW4pIHtcblx0XHRcdFx0dG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0LyogaWYgKHRvdGFsID09PSAwKSB7XG5cdFx0XHR0b3RhbCA9IE5hTjtcblx0XHR9Ki9cblxuXHRcdHJldHVybiB0b3RhbDtcblx0fSxcblxuXHRjYWxjdWxhdGVDaXJjdW1mZXJlbmNlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciB0b3RhbCA9IHRoaXMuZ2V0TWV0YSgpLnRvdGFsO1xuXHRcdGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIChNYXRoLlBJICogMi4wKSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIGdldHMgdGhlIG1heCBib3JkZXIgb3IgaG92ZXIgd2lkdGggdG8gcHJvcGVybHkgc2NhbGUgcGllIGNoYXJ0c1xuXHRnZXRNYXhCb3JkZXJXaWR0aDogZnVuY3Rpb24oYXJjcykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1heCA9IDA7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGksIGlsZW4sIG1ldGEsIGFyYywgY29udHJvbGxlciwgb3B0aW9ucywgYm9yZGVyV2lkdGgsIGhvdmVyV2lkdGg7XG5cblx0XHRpZiAoIWFyY3MpIHtcblx0XHRcdC8vIEZpbmQgdGhlIG91dG1vc3QgdmlzaWJsZSBkYXRhc2V0XG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdFx0YXJjcyA9IG1ldGEuZGF0YTtcblx0XHRcdFx0XHRpZiAoaSAhPT0gbWUuaW5kZXgpIHtcblx0XHRcdFx0XHRcdGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFhcmNzKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyYyA9IGFyY3NbaV07XG5cdFx0XHRvcHRpb25zID0gY29udHJvbGxlciA/IGNvbnRyb2xsZXIuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhhcmMsIGkpIDogYXJjLl9vcHRpb25zO1xuXHRcdFx0aWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcblx0XHRcdFx0Ym9yZGVyV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuXHRcdFx0XHRob3ZlcldpZHRoID0gb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoO1xuXG5cdFx0XHRcdG1heCA9IGJvcmRlcldpZHRoID4gbWF4ID8gYm9yZGVyV2lkdGggOiBtYXg7XG5cdFx0XHRcdG1heCA9IGhvdmVyV2lkdGggPiBtYXggPyBob3ZlcldpZHRoIDogbWF4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWF4O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihhcmMpIHtcblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRhcmMuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ0KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ0KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihhcmMsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgY3VzdG9tID0gYXJjLmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2JvcmRlckFsaWduJyxcblx0XHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQzKFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHJhZGl1cyBsZW5ndGggb2Zmc2V0IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzIHdlaWdodHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFJpbmdXZWlnaHRPZmZzZXQ6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciByaW5nV2VpZ2h0T2Zmc2V0ID0gMDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcblx0XHRcdGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0cmluZ1dlaWdodE9mZnNldCArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KGkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFJpbmdXZWlnaHQ6IGZ1bmN0aW9uKGRhdGFTZXRJbmRleCkge1xuXHRcdHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCQ0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhU2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdW0gb2YgYWxsIHZpc2liaWxlIGRhdGEgc2V0IHdlaWdodHMuICBUaGlzIHZhbHVlIGNhbiBiZSAwLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpO1xuXHR9XG59KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdob3Jpem9udGFsQmFyJywge1xuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdpbmRleCcsXG5cdFx0YXhpczogJ3knXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcblx0XHRcdHBvc2l0aW9uOiAnYm90dG9tJ1xuXHRcdH1dLFxuXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0Jyxcblx0XHRcdGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuXHRcdFx0YmFyUGVyY2VudGFnZTogMC45LFxuXHRcdFx0b2Zmc2V0OiB0cnVlLFxuXHRcdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRcdG9mZnNldEdyaWRMaW5lczogdHJ1ZVxuXHRcdFx0fVxuXHRcdH1dXG5cdH0sXG5cblx0ZWxlbWVudHM6IHtcblx0XHRyZWN0YW5nbGU6IHtcblx0XHRcdGJvcmRlclNraXBwZWQ6ICdsZWZ0J1xuXHRcdH1cblx0fSxcblxuXHR0b29sdGlwczoge1xuXHRcdG1vZGU6ICdpbmRleCcsXG5cdFx0YXhpczogJ3knXG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9ob3Jpem9udGFsQmFyID0gY29udHJvbGxlcl9iYXIuZXh0ZW5kKHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0VmFsdWVTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueEF4aXNJRDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRJbmRleFNjYWxlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGEoKS55QXhpc0lEO1xuXHR9XG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDUgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgcmVzb2x2ZSQ0ID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcbnZhciBpc1BvaW50SW5BcmVhID0gaGVscGVycyQxLmNhbnZhcy5faXNQb2ludEluQXJlYTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdsaW5lJywge1xuXHRzaG93TGluZXM6IHRydWUsXG5cdHNwYW5HYXBzOiBmYWxzZSxcblxuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdsYWJlbCdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdjYXRlZ29yeScsXG5cdFx0XHRpZDogJ3gtYXhpcy0wJ1xuXHRcdH1dLFxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRpZDogJ3ktYXhpcy0wJ1xuXHRcdH1dXG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBsaW5lRW5hYmxlZChkYXRhc2V0LCBvcHRpb25zKSB7XG5cdHJldHVybiB2YWx1ZU9yRGVmYXVsdCQ1KGRhdGFzZXQuc2hvd0xpbmUsIG9wdGlvbnMuc2hvd0xpbmVzKTtcbn1cblxudmFyIGNvbnRyb2xsZXJfbGluZSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRkYXRhc2V0RWxlbWVudFR5cGU6IGVsZW1lbnRzLkxpbmUsXG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5Qb2ludCxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgbGluZSA9IG1ldGEuZGF0YXNldDtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBzY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgc2hvd0xpbmUgPSBsaW5lRW5hYmxlZChkYXRhc2V0LCBtZS5jaGFydC5vcHRpb25zKTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdC8vIFVwZGF0ZSBMaW5lXG5cdFx0aWYgKHNob3dMaW5lKSB7XG5cdFx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0XHRpZiAoKGRhdGFzZXQudGVuc2lvbiAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YXNldC5saW5lVGVuc2lvbiA9PT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0XHRkYXRhc2V0LmxpbmVUZW5zaW9uID0gZGF0YXNldC50ZW5zaW9uO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRsaW5lLl9zY2FsZSA9IHNjYWxlO1xuXHRcdFx0bGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0XHQvLyBEYXRhXG5cdFx0XHRsaW5lLl9jaGlsZHJlbiA9IHBvaW50cztcblx0XHRcdC8vIE1vZGVsXG5cdFx0XHRsaW5lLl9tb2RlbCA9IG1lLl9yZXNvbHZlTGluZU9wdGlvbnMobGluZSk7XG5cblx0XHRcdGxpbmUucGl2b3QoKTtcblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgUG9pbnRzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnRzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXG5cdFx0aWYgKHNob3dMaW5lICYmIGxpbmUuX21vZGVsLnRlbnNpb24gIT09IDApIHtcblx0XHRcdG1lLnVwZGF0ZUJlemllckNvbnRyb2xQb2ludHMoKTtcblx0XHR9XG5cblx0XHQvLyBOb3cgcGl2b3QgdGhlIHBvaW50IGZvciBhbmltYXRpb25cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cG9pbnRzW2ldLnBpdm90KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGRhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdHZhciB2YWx1ZSA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG5cdFx0dmFyIHlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHR2YXIgeFNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnhBeGlzSUQpO1xuXHRcdHZhciBsaW5lTW9kZWwgPSBtZXRhLmRhdGFzZXQuX21vZGVsO1xuXHRcdHZhciB4LCB5O1xuXG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZVBvaW50T3B0aW9ucyhwb2ludCwgaW5kZXgpO1xuXG5cdFx0eCA9IHhTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSA6IE5hTiwgaW5kZXgsIGRhdGFzZXRJbmRleCk7XG5cdFx0eSA9IHJlc2V0ID8geVNjYWxlLmdldEJhc2VQaXhlbCgpIDogbWUuY2FsY3VsYXRlUG9pbnRZKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KTtcblxuXHRcdC8vIFV0aWxpdHlcblx0XHRwb2ludC5feFNjYWxlID0geFNjYWxlO1xuXHRcdHBvaW50Ll95U2NhbGUgPSB5U2NhbGU7XG5cdFx0cG9pbnQuX29wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHBvaW50Ll9kYXRhc2V0SW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XG5cblx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdHBvaW50Ll9tb2RlbCA9IHtcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5LFxuXHRcdFx0c2tpcDogY3VzdG9tLnNraXAgfHwgaXNOYU4oeCkgfHwgaXNOYU4oeSksXG5cdFx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0XHRyYWRpdXM6IG9wdGlvbnMucmFkaXVzLFxuXHRcdFx0cG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuXHRcdFx0cm90YXRpb246IG9wdGlvbnMucm90YXRpb24sXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdHRlbnNpb246IHZhbHVlT3JEZWZhdWx0JDUoY3VzdG9tLnRlbnNpb24sIGxpbmVNb2RlbCA/IGxpbmVNb2RlbC50ZW5zaW9uIDogMCksXG5cdFx0XHRzdGVwcGVkTGluZTogbGluZU1vZGVsID8gbGluZU1vZGVsLnN0ZXBwZWRMaW5lIDogZmFsc2UsXG5cdFx0XHQvLyBUb29sdGlwXG5cdFx0XHRoaXRSYWRpdXM6IG9wdGlvbnMuaGl0UmFkaXVzXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlUG9pbnRPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBjaGFydC5kYXRhLmRhdGFzZXRzW21lLmluZGV4XTtcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50O1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIEVMRU1FTlRfT1BUSU9OUyA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogJ3BvaW50QmFja2dyb3VuZENvbG9yJyxcblx0XHRcdGJvcmRlckNvbG9yOiAncG9pbnRCb3JkZXJDb2xvcicsXG5cdFx0XHRib3JkZXJXaWR0aDogJ3BvaW50Qm9yZGVyV2lkdGgnLFxuXHRcdFx0aGl0UmFkaXVzOiAncG9pbnRIaXRSYWRpdXMnLFxuXHRcdFx0aG92ZXJCYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEhvdmVyQmFja2dyb3VuZENvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyQ29sb3I6ICdwb2ludEhvdmVyQm9yZGVyQ29sb3InLFxuXHRcdFx0aG92ZXJCb3JkZXJXaWR0aDogJ3BvaW50SG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XHRob3ZlclJhZGl1czogJ3BvaW50SG92ZXJSYWRpdXMnLFxuXHRcdFx0cG9pbnRTdHlsZTogJ3BvaW50U3R5bGUnLFxuXHRcdFx0cmFkaXVzOiAncG9pbnRSYWRpdXMnLFxuXHRcdFx0cm90YXRpb246ICdwb2ludFJvdGF0aW9uJ1xuXHRcdH07XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhFTEVNRU5UX09QVElPTlMpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDQoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtFTEVNRU5UX09QVElPTlNba2V5XV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlTGluZU9wdGlvbnM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgZWxlbWVudE9wdGlvbnMgPSBvcHRpb25zLmVsZW1lbnRzLmxpbmU7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ2FwU3R5bGUnLFxuXHRcdFx0J2JvcmRlckRhc2gnLFxuXHRcdFx0J2JvcmRlckRhc2hPZmZzZXQnLFxuXHRcdFx0J2JvcmRlckpvaW5TdHlsZScsXG5cdFx0XHQnZmlsbCcsXG5cdFx0XHQnY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSdcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDQoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRlbGVtZW50T3B0aW9uc1trZXldXG5cdFx0XHRdKTtcblx0XHR9XG5cblx0XHQvLyBUaGUgZGVmYXVsdCBiZWhhdmlvciBvZiBsaW5lcyBpcyB0byBicmVhayBhdCBudWxsIHZhbHVlcywgYWNjb3JkaW5nXG5cdFx0Ly8gdG8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI0MzUjaXNzdWVjb21tZW50LTIxNjcxODE1OFxuXHRcdC8vIFRoaXMgb3B0aW9uIGdpdmVzIGxpbmVzIHRoZSBhYmlsaXR5IHRvIHNwYW4gZ2Fwc1xuXHRcdHZhbHVlcy5zcGFuR2FwcyA9IHZhbHVlT3JEZWZhdWx0JDUoZGF0YXNldC5zcGFuR2Fwcywgb3B0aW9ucy5zcGFuR2Fwcyk7XG5cdFx0dmFsdWVzLnRlbnNpb24gPSB2YWx1ZU9yRGVmYXVsdCQ1KGRhdGFzZXQubGluZVRlbnNpb24sIGVsZW1lbnRPcHRpb25zLnRlbnNpb24pO1xuXHRcdHZhbHVlcy5zdGVwcGVkTGluZSA9IHJlc29sdmUkNChbY3VzdG9tLnN0ZXBwZWRMaW5lLCBkYXRhc2V0LnN0ZXBwZWRMaW5lLCBlbGVtZW50T3B0aW9ucy5zdGVwcGVkXSk7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdGNhbGN1bGF0ZVBvaW50WTogZnVuY3Rpb24odmFsdWUsIGluZGV4LCBkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0dmFyIHN1bVBvcyA9IDA7XG5cdFx0dmFyIHN1bU5lZyA9IDA7XG5cdFx0dmFyIGksIGRzLCBkc01ldGE7XG5cblx0XHRpZiAoeVNjYWxlLm9wdGlvbnMuc3RhY2tlZCkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgaSsrKSB7XG5cdFx0XHRcdGRzID0gY2hhcnQuZGF0YS5kYXRhc2V0c1tpXTtcblx0XHRcdFx0ZHNNZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdGlmIChkc01ldGEudHlwZSA9PT0gJ2xpbmUnICYmIGRzTWV0YS55QXhpc0lEID09PSB5U2NhbGUuaWQgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRcdHZhciBzdGFja2VkUmlnaHRWYWx1ZSA9IE51bWJlcih5U2NhbGUuZ2V0UmlnaHRWYWx1ZShkcy5kYXRhW2luZGV4XSkpO1xuXHRcdFx0XHRcdGlmIChzdGFja2VkUmlnaHRWYWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdHN1bU5lZyArPSBzdGFja2VkUmlnaHRWYWx1ZSB8fCAwO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdW1Qb3MgKz0gc3RhY2tlZFJpZ2h0VmFsdWUgfHwgMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHJpZ2h0VmFsdWUgPSBOdW1iZXIoeVNjYWxlLmdldFJpZ2h0VmFsdWUodmFsdWUpKTtcblx0XHRcdGlmIChyaWdodFZhbHVlIDwgMCkge1xuXHRcdFx0XHRyZXR1cm4geVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3VtTmVnICsgcmlnaHRWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3VtUG9zICsgcmlnaHRWYWx1ZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcblx0fSxcblxuXHR1cGRhdGVCZXppZXJDb250cm9sUG9pbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBsaW5lTW9kZWwgPSBtZXRhLmRhdGFzZXQuX21vZGVsO1xuXHRcdHZhciBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0dmFyIGksIGlsZW4sIG1vZGVsLCBjb250cm9sUG9pbnRzO1xuXG5cdFx0Ly8gT25seSBjb25zaWRlciBwb2ludHMgdGhhdCBhcmUgZHJhd24gaW4gY2FzZSB0aGUgc3BhbkdhcHMgb3B0aW9uIGlzIHVzZWRcblx0XHRpZiAobGluZU1vZGVsLnNwYW5HYXBzKSB7XG5cdFx0XHRwb2ludHMgPSBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uKHB0KSB7XG5cdFx0XHRcdHJldHVybiAhcHQuX21vZGVsLnNraXA7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG5cdFx0fVxuXG5cdFx0aWYgKGxpbmVNb2RlbC5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG5cdFx0XHRoZWxwZXJzJDEuc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XG5cdFx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzJDEuc3BsaW5lQ3VydmUoXG5cdFx0XHRcdFx0aGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGkpLl9tb2RlbCxcblx0XHRcdFx0XHRtb2RlbCxcblx0XHRcdFx0XHRoZWxwZXJzJDEubmV4dEl0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXG5cdFx0XHRcdFx0bGluZU1vZGVsLnRlbnNpb25cblx0XHRcdFx0KTtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMubGluZS5jYXBCZXppZXJQb2ludHMpIHtcblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcblx0XHRcdFx0aWYgKGlzUG9pbnRJbkFyZWEobW9kZWwsIGFyZWEpKSB7XG5cdFx0XHRcdFx0aWYgKGkgPiAwICYmIGlzUG9pbnRJbkFyZWEocG9pbnRzW2kgLSAxXS5fbW9kZWwsIGFyZWEpKSB7XG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGkgPCBwb2ludHMubGVuZ3RoIC0gMSAmJiBpc1BvaW50SW5BcmVhKHBvaW50c1tpICsgMV0uX21vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50TmV4dFgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG5cdFx0XHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnROZXh0WSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBpbGVuID0gcG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaGFsZkJvcmRlcldpZHRoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGlmIChsaW5lRW5hYmxlZChtZS5nZXREYXRhc2V0KCksIGNoYXJ0Lm9wdGlvbnMpKSB7XG5cdFx0XHRoYWxmQm9yZGVyV2lkdGggPSAobWV0YS5kYXRhc2V0Ll9tb2RlbC5ib3JkZXJXaWR0aCB8fCAwKSAvIDI7XG5cblx0XHRcdGhlbHBlcnMkMS5jYW52YXMuY2xpcEFyZWEoY2hhcnQuY3R4LCB7XG5cdFx0XHRcdGxlZnQ6IGFyZWEubGVmdCxcblx0XHRcdFx0cmlnaHQ6IGFyZWEucmlnaHQsXG5cdFx0XHRcdHRvcDogYXJlYS50b3AgLSBoYWxmQm9yZGVyV2lkdGgsXG5cdFx0XHRcdGJvdHRvbTogYXJlYS5ib3R0b20gKyBoYWxmQm9yZGVyV2lkdGhcblx0XHRcdH0pO1xuXG5cdFx0XHRtZXRhLmRhdGFzZXQuZHJhdygpO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLnVuY2xpcEFyZWEoY2hhcnQuY3R4KTtcblx0XHR9XG5cblx0XHQvLyBEcmF3IHRoZSBwb2ludHNcblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cG9pbnRzW2ldLmRyYXcoYXJlYSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ1KG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQ1KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0bW9kZWwucmFkaXVzID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyUmFkaXVzLCBvcHRpb25zLnJhZGl1cyk7XG5cdH0sXG59KTtcblxudmFyIHJlc29sdmUkNSA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncG9sYXJBcmVhJywge1xuXHRzY2FsZToge1xuXHRcdHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuXHRcdGFuZ2xlTGluZXM6IHtcblx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0fSxcblx0XHRncmlkTGluZXM6IHtcblx0XHRcdGNpcmN1bGFyOiB0cnVlXG5cdFx0fSxcblx0XHRwb2ludExhYmVsczoge1xuXHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHR9LFxuXHRcdHRpY2tzOiB7XG5cdFx0XHRiZWdpbkF0WmVybzogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnRcblx0YW5pbWF0aW9uOiB7XG5cdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcblx0XHRhbmltYXRlU2NhbGU6IHRydWVcblx0fSxcblxuXHRzdGFydEFuZ2xlOiAtMC41ICogTWF0aC5QSSxcblx0bGVnZW5kQ2FsbGJhY2s6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHRleHQgPSBbXTtcblx0XHR0ZXh0LnB1c2goJzx1bCBjbGFzcz1cIicgKyBjaGFydC5pZCArICctbGVnZW5kXCI+Jyk7XG5cblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XG5cblx0XHRpZiAoZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRzWzBdLmRhdGEubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0dGV4dC5wdXNoKCc8bGk+PHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBkYXRhc2V0c1swXS5iYWNrZ3JvdW5kQ29sb3JbaV0gKyAnXCI+PC9zcGFuPicpO1xuXHRcdFx0XHRpZiAobGFiZWxzW2ldKSB7XG5cdFx0XHRcdFx0dGV4dC5wdXNoKGxhYmVsc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGV4dC5wdXNoKCc8L2xpPicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRleHQucHVzaCgnPC91bD4nKTtcblx0XHRyZXR1cm4gdGV4dC5qb2luKCcnKTtcblx0fSxcblx0bGVnZW5kOiB7XG5cdFx0bGFiZWxzOiB7XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzLm1hcChmdW5jdGlvbihsYWJlbCwgaSkge1xuXHRcdFx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcblx0XHRcdFx0XHRcdHZhciBkcyA9IGRhdGEuZGF0YXNldHNbMF07XG5cdFx0XHRcdFx0XHR2YXIgYXJjID0gbWV0YS5kYXRhW2ldO1xuXHRcdFx0XHRcdFx0dmFyIGN1c3RvbSA9IGFyYy5jdXN0b20gfHwge307XG5cdFx0XHRcdFx0XHR2YXIgYXJjT3B0cyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdFx0XHRcdFx0dmFyIGZpbGwgPSByZXNvbHZlJDUoW2N1c3RvbS5iYWNrZ3JvdW5kQ29sb3IsIGRzLmJhY2tncm91bmRDb2xvciwgYXJjT3B0cy5iYWNrZ3JvdW5kQ29sb3JdLCB1bmRlZmluZWQsIGkpO1xuXHRcdFx0XHRcdFx0dmFyIHN0cm9rZSA9IHJlc29sdmUkNShbY3VzdG9tLmJvcmRlckNvbG9yLCBkcy5ib3JkZXJDb2xvciwgYXJjT3B0cy5ib3JkZXJDb2xvcl0sIHVuZGVmaW5lZCwgaSk7XG5cdFx0XHRcdFx0XHR2YXIgYncgPSByZXNvbHZlJDUoW2N1c3RvbS5ib3JkZXJXaWR0aCwgZHMuYm9yZGVyV2lkdGgsIGFyY09wdHMuYm9yZGVyV2lkdGhdLCB1bmRlZmluZWQsIGkpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcblx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBmaWxsLFxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3Ryb2tlLFxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGJ3LFxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRzLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXG5cblx0XHRcdFx0XHRcdFx0Ly8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5pbmRleDtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiA9ICFtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Y2hhcnQudXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKGl0ZW0sIGRhdGEpIHtcblx0XHRcdFx0cmV0dXJuIGRhdGEubGFiZWxzW2l0ZW0uaW5kZXhdICsgJzogJyArIGl0ZW0ueUxhYmVsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX3BvbGFyQXJlYSA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLkFyYyxcblxuXHRsaW5rU2NhbGVzOiBoZWxwZXJzJDEubm9vcCxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgc3RhcnQgPSBtZS5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcblx0XHR2YXIgc3RhcnRzID0gbWUuX3N0YXJ0cyA9IFtdO1xuXHRcdHZhciBhbmdsZXMgPSBtZS5fYW5nbGVzID0gW107XG5cdFx0dmFyIGFyY3MgPSBtZXRhLmRhdGE7XG5cdFx0dmFyIGksIGlsZW4sIGFuZ2xlO1xuXG5cdFx0bWUuX3VwZGF0ZVJhZGl1cygpO1xuXG5cdFx0bWV0YS5jb3VudCA9IG1lLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldC5kYXRhLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuXHRcdFx0c3RhcnRzW2ldID0gc3RhcnQ7XG5cdFx0XHRhbmdsZSA9IG1lLl9jb21wdXRlQW5nbGUoaSk7XG5cdFx0XHRhbmdsZXNbaV0gPSBhbmdsZTtcblx0XHRcdHN0YXJ0ICs9IGFuZ2xlO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0YXJjc1tpXS5fb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMoYXJjc1tpXSwgaSk7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KGFyY3NbaV0sIGksIHJlc2V0KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdXBkYXRlUmFkaXVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIG9wdHMgPSBjaGFydC5vcHRpb25zO1xuXHRcdHZhciBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcblxuXHRcdGNoYXJ0Lm91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuXHRcdGNoYXJ0LmlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKGNoYXJ0Lm91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG5cdFx0Y2hhcnQucmFkaXVzTGVuZ3RoID0gKGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQuaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuXG5cdFx0bWUub3V0ZXJSYWRpdXMgPSBjaGFydC5vdXRlclJhZGl1cyAtIChjaGFydC5yYWRpdXNMZW5ndGggKiBtZS5pbmRleCk7XG5cdFx0bWUuaW5uZXJSYWRpdXMgPSBtZS5vdXRlclJhZGl1cyAtIGNoYXJ0LnJhZGl1c0xlbmd0aDtcblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG9wdHMgPSBjaGFydC5vcHRpb25zO1xuXHRcdHZhciBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG5cdFx0dmFyIHNjYWxlID0gY2hhcnQuc2NhbGU7XG5cdFx0dmFyIGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzO1xuXG5cdFx0dmFyIGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuXHRcdHZhciBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcblxuXHRcdC8vIHZhciBuZWdIYWxmUEkgPSAtMC41ICogTWF0aC5QSTtcblx0XHR2YXIgZGF0YXNldFN0YXJ0QW5nbGUgPSBvcHRzLnN0YXJ0QW5nbGU7XG5cdFx0dmFyIGRpc3RhbmNlID0gYXJjLmhpZGRlbiA/IDAgOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShkYXRhc2V0LmRhdGFbaW5kZXhdKTtcblx0XHR2YXIgc3RhcnRBbmdsZSA9IG1lLl9zdGFydHNbaW5kZXhdO1xuXHRcdHZhciBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoYXJjLmhpZGRlbiA/IDAgOiBtZS5fYW5nbGVzW2luZGV4XSk7XG5cblx0XHR2YXIgcmVzZXRSYWRpdXMgPSBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSA/IDAgOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShkYXRhc2V0LmRhdGFbaW5kZXhdKTtcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucyB8fCB7fTtcblxuXHRcdGhlbHBlcnMkMS5leHRlbmQoYXJjLCB7XG5cdFx0XHQvLyBVdGlsaXR5XG5cdFx0XHRfZGF0YXNldEluZGV4OiBtZS5pbmRleCxcblx0XHRcdF9pbmRleDogaW5kZXgsXG5cdFx0XHRfc2NhbGU6IHNjYWxlLFxuXG5cdFx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdFx0X21vZGVsOiB7XG5cdFx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdFx0Ym9yZGVyQWxpZ246IG9wdGlvbnMuYm9yZGVyQWxpZ24sXG5cdFx0XHRcdHg6IGNlbnRlclgsXG5cdFx0XHRcdHk6IGNlbnRlclksXG5cdFx0XHRcdGlubmVyUmFkaXVzOiAwLFxuXHRcdFx0XHRvdXRlclJhZGl1czogcmVzZXQgPyByZXNldFJhZGl1cyA6IGRpc3RhbmNlLFxuXHRcdFx0XHRzdGFydEFuZ2xlOiByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyBkYXRhc2V0U3RhcnRBbmdsZSA6IHN0YXJ0QW5nbGUsXG5cdFx0XHRcdGVuZEFuZ2xlOiByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUgPyBkYXRhc2V0U3RhcnRBbmdsZSA6IGVuZEFuZ2xlLFxuXHRcdFx0XHRsYWJlbDogaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdChsYWJlbHMsIGluZGV4LCBsYWJlbHNbaW5kZXhdKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXJjLnBpdm90KCk7XG5cdH0sXG5cblx0Y291bnRWaXNpYmxlRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldE1ldGEoKTtcblx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdFx0aWYgKCFpc05hTihkYXRhc2V0LmRhdGFbaW5kZXhdKSAmJiAhZWxlbWVudC5oaWRkZW4pIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBjb3VudDtcblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXHRcdHZhciB2YWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuXHRcdGFyYy4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlRWxlbWVudE9wdGlvbnM6IGZ1bmN0aW9uKGFyYywgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBjdXN0b20gPSBhcmMuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5hcmM7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0XHQnYm9yZGVyQWxpZ24nLFxuXHRcdFx0J2hvdmVyQmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdob3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdCdob3ZlckJvcmRlcldpZHRoJyxcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDUoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NvbXB1dGVBbmdsZTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjb3VudCA9IHRoaXMuZ2V0TWV0YSgpLmNvdW50O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXG5cdFx0aWYgKGlzTmFOKGRhdGFzZXQuZGF0YVtpbmRleF0pIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBtZS5jaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHRyZXR1cm4gcmVzb2x2ZSQ1KFtcblx0XHRcdG1lLmNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjLmFuZ2xlLFxuXHRcdFx0KDIgKiBNYXRoLlBJKSAvIGNvdW50XG5cdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHR9XG59KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdwaWUnLCBoZWxwZXJzJDEuY2xvbmUoY29yZV9kZWZhdWx0cy5kb3VnaG51dCkpO1xuY29yZV9kZWZhdWx0cy5fc2V0KCdwaWUnLCB7XG5cdGN1dG91dFBlcmNlbnRhZ2U6IDBcbn0pO1xuXG4vLyBQaWUgY2hhcnRzIGFyZSBEb3VnaG51dCBjaGFydCB3aXRoIGRpZmZlcmVudCBkZWZhdWx0c1xudmFyIGNvbnRyb2xsZXJfcGllID0gY29udHJvbGxlcl9kb3VnaG51dDtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDYgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgcmVzb2x2ZSQ2ID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdyYWRhcicsIHtcblx0c2NhbGU6IHtcblx0XHR0eXBlOiAncmFkaWFsTGluZWFyJ1xuXHR9LFxuXHRlbGVtZW50czoge1xuXHRcdGxpbmU6IHtcblx0XHRcdHRlbnNpb246IDAgLy8gbm8gYmV6aWVyIGluIHJhZGFyXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfcmFkYXIgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YXNldEVsZW1lbnRUeXBlOiBlbGVtZW50cy5MaW5lLFxuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0bGlua1NjYWxlczogaGVscGVycyQxLm5vb3AsXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgc2NhbGUgPSBtZS5jaGFydC5zY2FsZTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdC8vIENvbXBhdGliaWxpdHk6IElmIHRoZSBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIHdpdGggb25seSB0aGUgb2xkIG5hbWUsIHVzZSB0aG9zZSB2YWx1ZXNcblx0XHRpZiAoKGRhdGFzZXQudGVuc2lvbiAhPT0gdW5kZWZpbmVkKSAmJiAoZGF0YXNldC5saW5lVGVuc2lvbiA9PT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0ZGF0YXNldC5saW5lVGVuc2lvbiA9IGRhdGFzZXQudGVuc2lvbjtcblx0XHR9XG5cblx0XHQvLyBVdGlsaXR5XG5cdFx0bGluZS5fc2NhbGUgPSBzY2FsZTtcblx0XHRsaW5lLl9kYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHQvLyBEYXRhXG5cdFx0bGluZS5fY2hpbGRyZW4gPSBwb2ludHM7XG5cdFx0bGluZS5fbG9vcCA9IHRydWU7XG5cdFx0Ly8gTW9kZWxcblx0XHRsaW5lLl9tb2RlbCA9IG1lLl9yZXNvbHZlTGluZU9wdGlvbnMobGluZSk7XG5cblx0XHRsaW5lLnBpdm90KCk7XG5cblx0XHQvLyBVcGRhdGUgUG9pbnRzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQocG9pbnRzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIGJlemllciBjb250cm9sIHBvaW50c1xuXHRcdG1lLnVwZGF0ZUJlemllckNvbnRyb2xQb2ludHMoKTtcblxuXHRcdC8vIE5vdyBwaXZvdCB0aGUgcG9pbnQgZm9yIGFuaW1hdGlvblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRwb2ludHNbaV0ucGl2b3QoKTtcblx0XHR9XG5cdH0sXG5cblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24ocG9pbnQsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGN1c3RvbSA9IHBvaW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgc2NhbGUgPSBtZS5jaGFydC5zY2FsZTtcblx0XHR2YXIgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCwgZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fcmVzb2x2ZVBvaW50T3B0aW9ucyhwb2ludCwgaW5kZXgpO1xuXHRcdHZhciBsaW5lTW9kZWwgPSBtZS5nZXRNZXRhKCkuZGF0YXNldC5fbW9kZWw7XG5cdFx0dmFyIHggPSByZXNldCA/IHNjYWxlLnhDZW50ZXIgOiBwb2ludFBvc2l0aW9uLng7XG5cdFx0dmFyIHkgPSByZXNldCA/IHNjYWxlLnlDZW50ZXIgOiBwb2ludFBvc2l0aW9uLnk7XG5cblx0XHQvLyBVdGlsaXR5XG5cdFx0cG9pbnQuX3NjYWxlID0gc2NhbGU7XG5cdFx0cG9pbnQuX29wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHBvaW50Ll9kYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHRwb2ludC5faW5kZXggPSBpbmRleDtcblxuXHRcdC8vIERlc2lyZWQgdmlldyBwcm9wZXJ0aWVzXG5cdFx0cG9pbnQuX21vZGVsID0ge1xuXHRcdFx0eDogeCwgLy8gdmFsdWUgbm90IHVzZWQgaW4gZGF0YXNldCBzY2FsZSwgYnV0IHdlIHdhbnQgYSBjb25zaXN0ZW50IEFQSSBiZXR3ZWVuIHNjYWxlc1xuXHRcdFx0eTogeSxcblx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuXHRcdFx0Ly8gQXBwZWFyYW5jZVxuXHRcdFx0cmFkaXVzOiBvcHRpb25zLnJhZGl1cyxcblx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHR0ZW5zaW9uOiB2YWx1ZU9yRGVmYXVsdCQ2KGN1c3RvbS50ZW5zaW9uLCBsaW5lTW9kZWwgPyBsaW5lTW9kZWwudGVuc2lvbiA6IDApLFxuXG5cdFx0XHQvLyBUb29sdGlwXG5cdFx0XHRoaXRSYWRpdXM6IG9wdGlvbnMuaGl0UmFkaXVzXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlUG9pbnRPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBjaGFydC5kYXRhLmRhdGFzZXRzW21lLmluZGV4XTtcblx0XHR2YXIgY3VzdG9tID0gZWxlbWVudC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50O1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIEVMRU1FTlRfT1BUSU9OUyA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogJ3BvaW50QmFja2dyb3VuZENvbG9yJyxcblx0XHRcdGJvcmRlckNvbG9yOiAncG9pbnRCb3JkZXJDb2xvcicsXG5cdFx0XHRib3JkZXJXaWR0aDogJ3BvaW50Qm9yZGVyV2lkdGgnLFxuXHRcdFx0aGl0UmFkaXVzOiAncG9pbnRIaXRSYWRpdXMnLFxuXHRcdFx0aG92ZXJCYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEhvdmVyQmFja2dyb3VuZENvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyQ29sb3I6ICdwb2ludEhvdmVyQm9yZGVyQ29sb3InLFxuXHRcdFx0aG92ZXJCb3JkZXJXaWR0aDogJ3BvaW50SG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XHRob3ZlclJhZGl1czogJ3BvaW50SG92ZXJSYWRpdXMnLFxuXHRcdFx0cG9pbnRTdHlsZTogJ3BvaW50U3R5bGUnLFxuXHRcdFx0cmFkaXVzOiAncG9pbnRSYWRpdXMnLFxuXHRcdFx0cm90YXRpb246ICdwb2ludFJvdGF0aW9uJ1xuXHRcdH07XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhFTEVNRU5UX09QVElPTlMpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDYoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtFTEVNRU5UX09QVElPTlNba2V5XV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZXNvbHZlTGluZU9wdGlvbnM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlckNhcFN0eWxlJyxcblx0XHRcdCdib3JkZXJEYXNoJyxcblx0XHRcdCdib3JkZXJEYXNoT2Zmc2V0Jyxcblx0XHRcdCdib3JkZXJKb2luU3R5bGUnLFxuXHRcdFx0J2ZpbGwnXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ2KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdKTtcblx0XHR9XG5cblx0XHR2YWx1ZXMudGVuc2lvbiA9IHZhbHVlT3JEZWZhdWx0JDYoZGF0YXNldC5saW5lVGVuc2lvbiwgb3B0aW9ucy50ZW5zaW9uKTtcblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgYXJlYSA9IG1lLmNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpLCBpbGVuLCBtb2RlbCwgY29udHJvbFBvaW50cztcblxuXHRcdGZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdCwgbWluLCBtYXgpIHtcblx0XHRcdHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xuXHRcdFx0Y29udHJvbFBvaW50cyA9IGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZShcblx0XHRcdFx0aGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGksIHRydWUpLl9tb2RlbCxcblx0XHRcdFx0bW9kZWwsXG5cdFx0XHRcdGhlbHBlcnMkMS5uZXh0SXRlbShwb2ludHMsIGksIHRydWUpLl9tb2RlbCxcblx0XHRcdFx0bW9kZWwudGVuc2lvblxuXHRcdFx0KTtcblxuXHRcdFx0Ly8gUHJldmVudCB0aGUgYmV6aWVyIGdvaW5nIG91dHNpZGUgb2YgdGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhcblx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IGNhcENvbnRyb2xQb2ludChjb250cm9sUG9pbnRzLnByZXZpb3VzLngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1kgPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5wcmV2aW91cy55LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5uZXh0LngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNhcENvbnRyb2xQb2ludChjb250cm9sUG9pbnRzLm5leHQueSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHR9XG5cdH0sXG5cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0cG9pbnQuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHRcdHJhZGl1czogbW9kZWwucmFkaXVzXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNihvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHRcdG1vZGVsLnJhZGl1cyA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlclJhZGl1cywgb3B0aW9ucy5yYWRpdXMpO1xuXHR9XG59KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdzY2F0dGVyJywge1xuXHRob3Zlcjoge1xuXHRcdG1vZGU6ICdzaW5nbGUnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHRpZDogJ3gtYXhpcy0xJywgICAgLy8gbmVlZCBhbiBJRCBzbyBkYXRhc2V0cyBjYW4gcmVmZXJlbmNlIHRoZSBzY2FsZVxuXHRcdFx0dHlwZTogJ2xpbmVhcicsICAgIC8vIHNjYXR0ZXIgc2hvdWxkIG5vdCB1c2UgYSBjYXRlZ29yeSBheGlzXG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbSdcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdGlkOiAneS1heGlzLTEnLFxuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRwb3NpdGlvbjogJ2xlZnQnXG5cdFx0fV1cblx0fSxcblxuXHRzaG93TGluZXM6IGZhbHNlLFxuXG5cdHRvb2x0aXBzOiB7XG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHR0aXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJzsgICAgIC8vIGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3Igc2NhdHRlciBzaW5jZSBkYXRhIGFyZSBmb3JtYXR0ZWQgYXMgYSBwb2ludFxuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiAnKCcgKyBpdGVtLnhMYWJlbCArICcsICcgKyBpdGVtLnlMYWJlbCArICcpJztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBTY2F0dGVyIGNoYXJ0cyB1c2UgbGluZSBjb250cm9sbGVyc1xudmFyIGNvbnRyb2xsZXJfc2NhdHRlciA9IGNvbnRyb2xsZXJfbGluZTtcblxuLy8gTk9URSBleHBvcnQgYSBtYXAgaW4gd2hpY2ggdGhlIGtleSByZXByZXNlbnRzIHRoZSBjb250cm9sbGVyIHR5cGUsIG5vdFxuLy8gdGhlIGNsYXNzLCBhbmQgc28gbXVzdCBiZSBDYW1lbENhc2UgaW4gb3JkZXIgdG8gYmUgY29ycmVjdGx5IHJldHJpZXZlZFxuLy8gYnkgdGhlIGNvbnRyb2xsZXIgaW4gY29yZS5jb250cm9sbGVyLmpzIChgY29udHJvbGxlcnNbbWV0YS50eXBlXWApLlxuXG52YXIgY29udHJvbGxlcnMgPSB7XG5cdGJhcjogY29udHJvbGxlcl9iYXIsXG5cdGJ1YmJsZTogY29udHJvbGxlcl9idWJibGUsXG5cdGRvdWdobnV0OiBjb250cm9sbGVyX2RvdWdobnV0LFxuXHRob3Jpem9udGFsQmFyOiBjb250cm9sbGVyX2hvcml6b250YWxCYXIsXG5cdGxpbmU6IGNvbnRyb2xsZXJfbGluZSxcblx0cG9sYXJBcmVhOiBjb250cm9sbGVyX3BvbGFyQXJlYSxcblx0cGllOiBjb250cm9sbGVyX3BpZSxcblx0cmFkYXI6IGNvbnRyb2xsZXJfcmFkYXIsXG5cdHNjYXR0ZXI6IGNvbnRyb2xsZXJfc2NhdHRlclxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHJlbGF0aXZlIHBvc2l0aW9uIGZvciBhbiBldmVudFxuICogQHBhcmFtIHtFdmVudHxJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGdldCB0aGUgcG9zaXRpb24gZm9yXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydFxuICogQHJldHVybnMge29iamVjdH0gdGhlIGV2ZW50IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpIHtcblx0aWYgKGUubmF0aXZlKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IGUueCxcblx0XHRcdHk6IGUueVxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gaGVscGVycyQxLmdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB0cmF2ZXJzZSBhbGwgb2YgdGhlIHZpc2libGUgZWxlbWVudHMgaW4gdGhlIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIHRoZSBjYWxsYmFjayB0byBleGVjdXRlIGZvciBlYWNoIHZpc2libGUgaXRlbVxuICovXG5mdW5jdGlvbiBwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgaGFuZGxlcikge1xuXHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHR2YXIgbWV0YSwgaSwgaiwgaWxlbiwgamxlbjtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aWYgKCFjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0Zm9yIChqID0gMCwgamxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdHZhciBlbGVtZW50ID0gbWV0YS5kYXRhW2pdO1xuXHRcdFx0aWYgKCFlbGVtZW50Ll92aWV3LnNraXApIHtcblx0XHRcdFx0aGFuZGxlcihlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgZXZlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Q2hhcnRFbGVtZW50W119IGl0ZW1zIC0gZWxlbWVudHMgdG8gZmlsdGVyXG4gKiBAcGFyYW0ge29iamVjdH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xuICogQHJldHVybiB7Q2hhcnRFbGVtZW50W119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikge1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblxuXHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gY29uc2lkZXJpbmcgYWxsIHZpc2libGUgaXRlbXMgaW4gdGVoIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7b2JqZWN0fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludGVyc2VjdCAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkaXN0YW5jZU1ldHJpYyAtIGZ1bmN0aW9uIHRvIHByb3ZpZGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzXG4gKiBAcmV0dXJuIHtDaGFydEVsZW1lbnRbXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgaW50ZXJzZWN0LCBkaXN0YW5jZU1ldHJpYykge1xuXHR2YXIgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdHZhciBuZWFyZXN0SXRlbXMgPSBbXTtcblxuXHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdGlmIChpbnRlcnNlY3QgJiYgIWVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KCk7XG5cdFx0dmFyIGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG5cdFx0aWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdG5lYXJlc3RJdGVtcyA9IFtlbGVtZW50XTtcblx0XHRcdG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0fSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcblx0XHRcdC8vIENhbiBoYXZlIG11bHRpcGxlIGl0ZW1zIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGluIHdoaWNoIGNhc2Ugd2Ugc29ydCBieSBzaXplXG5cdFx0XHRuZWFyZXN0SXRlbXMucHVzaChlbGVtZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBuZWFyZXN0SXRlbXM7XG59XG5cbi8qKlxuICogR2V0IGEgZGlzdGFuY2UgbWV0cmljIGZ1bmN0aW9uIGZvciB0d28gcG9pbnRzIGJhc2VkIG9uIHRoZVxuICogYXhpcyBtb2RlIHNldHRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5XG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG5cdHZhciB1c2VYID0gYXhpcy5pbmRleE9mKCd4JykgIT09IC0xO1xuXHR2YXIgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcblxuXHRyZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcblx0XHR2YXIgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcblx0XHR2YXIgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gaW5kZXhNb2RlKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHQvLyBEZWZhdWx0IGF4aXMgZm9yIGluZGV4IG1vZGUgaXMgJ3gnIHRvIG1hdGNoIG9sZCBiZWhhdmlvdXJcblx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4Jztcblx0dmFyIGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKG9wdGlvbnMuYXhpcyk7XG5cdHZhciBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0ID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGZhbHNlLCBkaXN0YW5jZU1ldHJpYyk7XG5cdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdGlmICghaXRlbXMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0Y2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkpIHtcblx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdHZhciBlbGVtZW50ID0gbWV0YS5kYXRhW2l0ZW1zWzBdLl9pbmRleF07XG5cblx0XHRcdC8vIGRvbid0IGNvdW50IGl0ZW1zIHRoYXQgYXJlIHNraXBwZWQgKG51bGwgZGF0YSlcblx0XHRcdGlmIChlbGVtZW50ICYmICFlbGVtZW50Ll92aWV3LnNraXApIHtcblx0XHRcdFx0ZWxlbWVudHMucHVzaChlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIElJbnRlcmFjdGlvbk9wdGlvbnNcbiAqL1xuLyoqXG4gKiBJZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb2ludFxuICogQG5hbWUgSUludGVyZmFjZU9wdGlvbnMjYm9vbGVhblxuICogQHR5cGUgQm9vbGVhblxuICovXG5cbi8qKlxuICogQ29udGFpbnMgaW50ZXJhY3Rpb24gcmVsYXRlZCBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuSW50ZXJhY3Rpb25cbiAqL1xudmFyIGNvcmVfaW50ZXJhY3Rpb24gPSB7XG5cdC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZGlmZmVyZW50IG1vZGVzXG5cdG1vZGVzOiB7XG5cdFx0c2luZ2xlOiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSBbXTtcblxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW1lbnRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGVsZW1lbnRzLnNsaWNlKDAsIDEpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMubGFiZWxcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNC4wXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0bGFiZWw6IGluZGV4TW9kZSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXguIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBtb2RlIGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXggYXMgdGhhdCBpdGVtXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmluZGV4XG5cdFx0ICogQHNpbmNlIHYyLjQuMFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2UgZHVyaW5nIGludGVyYWN0aW9uXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdGluZGV4OiBpbmRleE1vZGUsXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGluIHRoZSBzYW1lIGRhdGFzZXQuIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGluIHRoYXQgZGF0YXNldFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5kYXRhc2V0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZSBkdXJpbmcgaW50ZXJhY3Rpb25cblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0ZGF0YXNldDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG5cdFx0XHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcblx0XHRcdHZhciBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0ID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKSA6IGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGZhbHNlLCBkaXN0YW5jZU1ldHJpYyk7XG5cblx0XHRcdGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGl0ZW1zID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uX2RhdGFzZXRJbmRleCkuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueC1heGlzXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjQuMC4gVXNlIGluZGV4IG1vZGUgYW5kIGludGVyc2VjdCA9PSB0cnVlXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0J3gtYXhpcyc6IGZ1bmN0aW9uKGNoYXJ0LCBlKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhNb2RlKGNoYXJ0LCBlLCB7aW50ZXJzZWN0OiBmYWxzZX0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQb2ludCBtb2RlIHJldHVybnMgYWxsIGVsZW1lbnRzIHRoYXQgaGl0IHRlc3QgYmFzZWQgb24gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdFx0ICogb2YgdGhlIGV2ZW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdHBvaW50OiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHRyZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogbmVhcmVzdCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnQgY2xvc2VzdCB0byB0aGUgcG9pbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRuZWFyZXN0OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHRvcHRpb25zLmF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5Jztcblx0XHRcdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xuXHRcdFx0cmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIG9wdGlvbnMuaW50ZXJzZWN0LCBkaXN0YW5jZU1ldHJpYyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIHggbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHggY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHR4OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRcdHZhciBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5pblhSYW5nZShwb3NpdGlvbi54KSkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c0l0ZW0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcblx0XHRcdC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcblx0XHRcdGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcblx0XHRcdFx0aXRlbXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogeSBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnlcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdHk6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdFx0dmFyIGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LmluWVJhbmdlKHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0aXRlbXMucHVzaChlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRpbnRlcnNlY3RzSXRlbSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuXHRcdFx0Ly8gdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uLCByZXR1cm4gbm90aGluZ1xuXHRcdFx0aWYgKG9wdGlvbnMuaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuXHRcdFx0XHRpdGVtcyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH1cblx0fVxufTtcblxuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcblx0cmV0dXJuIGhlbHBlcnMkMS53aGVyZShhcnJheSwgZnVuY3Rpb24odikge1xuXHRcdHJldHVybiB2LnBvc2l0aW9uID09PSBwb3NpdGlvbjtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuXHRhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpIHtcblx0XHR2Ll90bXBJbmRleF8gPSBpO1xuXHRcdHJldHVybiB2O1xuXHR9KTtcblx0YXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0dmFyIHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuXHRcdHZhciB2MSA9IHJldmVyc2UgPyBhIDogYjtcblx0XHRyZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgP1xuXHRcdFx0djAuX3RtcEluZGV4XyAtIHYxLl90bXBJbmRleF8gOlxuXHRcdFx0djAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuXHR9KTtcblx0YXJyYXkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG5cdFx0ZGVsZXRlIHYuX3RtcEluZGV4Xztcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRNYXhQYWRkaW5nKGJveGVzKSB7XG5cdHZhciB0b3AgPSAwO1xuXHR2YXIgbGVmdCA9IDA7XG5cdHZhciBib3R0b20gPSAwO1xuXHR2YXIgcmlnaHQgPSAwO1xuXHRoZWxwZXJzJDEuZWFjaChib3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0aWYgKGJveC5nZXRQYWRkaW5nKSB7XG5cdFx0XHR2YXIgYm94UGFkZGluZyA9IGJveC5nZXRQYWRkaW5nKCk7XG5cdFx0XHR0b3AgPSBNYXRoLm1heCh0b3AsIGJveFBhZGRpbmcudG9wKTtcblx0XHRcdGxlZnQgPSBNYXRoLm1heChsZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuXHRcdFx0Ym90dG9tID0gTWF0aC5tYXgoYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XG5cdFx0XHRyaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4ge1xuXHRcdHRvcDogdG9wLFxuXHRcdGxlZnQ6IGxlZnQsXG5cdFx0Ym90dG9tOiBib3R0b20sXG5cdFx0cmlnaHQ6IHJpZ2h0XG5cdH07XG59XG5cbmZ1bmN0aW9uIGFkZFNpemVCeVBvc2l0aW9uKGJveGVzLCBzaXplKSB7XG5cdGhlbHBlcnMkMS5lYWNoKGJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRzaXplW2JveC5wb3NpdGlvbl0gKz0gYm94LmlzSG9yaXpvbnRhbCgpID8gYm94LmhlaWdodCA6IGJveC53aWR0aDtcblx0fSk7XG59XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRsYXlvdXQ6IHtcblx0XHRwYWRkaW5nOiB7XG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRyaWdodDogMCxcblx0XHRcdGJvdHRvbTogMCxcblx0XHRcdGxlZnQ6IDBcblx0XHR9XG5cdH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgSUxheW91dEl0ZW1cbiAqIEBwcm9wIHtzdHJpbmd9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBjaGFydCBsYXlvdXQuIFBvc3NpYmxlIHZhbHVlcyBhcmVcbiAqICdsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCBhbmQgJ2NoYXJ0QXJlYSdcbiAqIEBwcm9wIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQgdXNlZCB0byBzb3J0IHRoZSBpdGVtLiBIaWdoZXIgd2VpZ2h0cyBhcmUgZnVydGhlciBhd2F5IGZyb20gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwcm9wIHtib29sZWFufSBmdWxsV2lkdGggLSBpZiB0cnVlLCBhbmQgdGhlIGl0ZW0gaXMgaG9yaXpvbnRhbCwgdGhlbiBwdXNoIHZlcnRpY2FsIGJveGVzIGRvd25cbiAqIEBwcm9wIHtmdW5jdGlvbn0gaXNIb3Jpem9udGFsIC0gcmV0dXJucyB0cnVlIGlmIHRoZSBsYXlvdXQgaXRlbSBpcyBob3Jpem9udGFsIChpZS4gdG9wIG9yIGJvdHRvbSlcbiAqIEBwcm9wIHtmdW5jdGlvbn0gdXBkYXRlIC0gVGFrZXMgdHdvIHBhcmFtZXRlcnM6IHdpZHRoIGFuZCBoZWlnaHQuIFJldHVybnMgc2l6ZSBvZiBpdGVtXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGdldFBhZGRpbmcgLSAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBwYWRkaW5nIG9uIHRoZSBlZGdlc1xuICogQHByb3Age251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXG4gKiBAcHJvcCB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gbGVmdCAtIExlZnQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gdG9wIC0gVG9wIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHJpZ2h0IC0gUmlnaHQgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gYm90dG9tIC0gQm90dG9tIGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqL1xuXG4vLyBUaGUgbGF5b3V0IHNlcnZpY2UgaXMgdmVyeSBzZWxmIGV4cGxhbmF0b3J5LiAgSXQncyByZXNwb25zaWJsZSBmb3IgdGhlIGxheW91dCB3aXRoaW4gYSBjaGFydC5cbi8vIFNjYWxlcywgTGVnZW5kcyBhbmQgUGx1Z2lucyBhbGwgcmVseSBvbiB0aGUgbGF5b3V0IHNlcnZpY2UgYW5kIGNhbiBlYXNpbHkgcmVnaXN0ZXIgdG8gYmUgcGxhY2VkIGFueXdoZXJlIHRoZXkgbmVlZFxuLy8gSXQgaXMgdGhpcyBzZXJ2aWNlJ3MgcmVzcG9uc2liaWxpdHkgb2YgY2Fycnlpbmcgb3V0IHRoYXQgbGF5b3V0LlxudmFyIGNvcmVfbGF5b3V0cyA9IHtcblx0ZGVmYXVsdHM6IHt9LFxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhIGJveCB0byBhIGNoYXJ0LlxuXHQgKiBBIGJveCBpcyBzaW1wbHkgYSByZWZlcmVuY2UgdG8gYW4gb2JqZWN0IHRoYXQgcmVxdWlyZXMgbGF5b3V0LiBlZy4gU2NhbGVzLCBMZWdlbmQsIFRpdGxlLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byB1c2Vcblx0ICogQHBhcmFtIHtJTGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGFkZCB0byBiZSBsYXllZCBvdXRcblx0ICovXG5cdGFkZEJveDogZnVuY3Rpb24oY2hhcnQsIGl0ZW0pIHtcblx0XHRpZiAoIWNoYXJ0LmJveGVzKSB7XG5cdFx0XHRjaGFydC5ib3hlcyA9IFtdO1xuXHRcdH1cblxuXHRcdC8vIGluaXRpYWxpemUgaXRlbSB3aXRoIGRlZmF1bHQgdmFsdWVzXG5cdFx0aXRlbS5mdWxsV2lkdGggPSBpdGVtLmZ1bGxXaWR0aCB8fCBmYWxzZTtcblx0XHRpdGVtLnBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbiB8fCAndG9wJztcblx0XHRpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XG5cblx0XHRjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYSBsYXlvdXRJdGVtIGZyb20gYSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byByZW1vdmUgdGhlIGJveCBmcm9tXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGxheW91dEl0ZW0gLSB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGF5b3V0XG5cdCAqL1xuXHRyZW1vdmVCb3g6IGZ1bmN0aW9uKGNoYXJ0LCBsYXlvdXRJdGVtKSB7XG5cdFx0dmFyIGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0Y2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgKG9yIHVwZGF0ZXMpIG9wdGlvbnMgb24gdGhlIGdpdmVuIGBpdGVtYC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgaW4gd2hpY2ggdGhlIGl0ZW0gbGl2ZXMgKG9yIHdpbGwgYmUgYWRkZWQgdG8pXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBjb25maWd1cmUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHRoZSBuZXcgaXRlbSBvcHRpb25zLlxuXHQgKi9cblx0Y29uZmlndXJlOiBmdW5jdGlvbihjaGFydCwgaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBwcm9wcyA9IFsnZnVsbFdpZHRoJywgJ3Bvc2l0aW9uJywgJ3dlaWdodCddO1xuXHRcdHZhciBpbGVuID0gcHJvcHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblx0XHR2YXIgcHJvcDtcblxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbaV07XG5cdFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuXHRcdFx0XHRpdGVtW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZpdHMgYm94ZXMgb2YgdGhlIGdpdmVuIGNoYXJ0IGludG8gdGhlIGdpdmVuIHNpemUgYnkgaGF2aW5nIGVhY2ggYm94IG1lYXN1cmUgaXRzZWxmXG5cdCAqIHRoZW4gcnVubmluZyBhIGZpdHRpbmcgYWxnb3JpdGhtXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCB0byBmaXQgaW50b1xuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCB0byBmaXQgaW50b1xuXHQgKi9cblx0dXBkYXRlOiBmdW5jdGlvbihjaGFydCwgd2lkdGgsIGhlaWdodCkge1xuXHRcdGlmICghY2hhcnQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbGF5b3V0T3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMubGF5b3V0IHx8IHt9O1xuXHRcdHZhciBwYWRkaW5nID0gaGVscGVycyQxLm9wdGlvbnMudG9QYWRkaW5nKGxheW91dE9wdGlvbnMucGFkZGluZyk7XG5cdFx0dmFyIGxlZnRQYWRkaW5nID0gcGFkZGluZy5sZWZ0O1xuXHRcdHZhciByaWdodFBhZGRpbmcgPSBwYWRkaW5nLnJpZ2h0O1xuXHRcdHZhciB0b3BQYWRkaW5nID0gcGFkZGluZy50b3A7XG5cdFx0dmFyIGJvdHRvbVBhZGRpbmcgPSBwYWRkaW5nLmJvdHRvbTtcblxuXHRcdHZhciBsZWZ0Qm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnbGVmdCcpO1xuXHRcdHZhciByaWdodEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ3JpZ2h0Jyk7XG5cdFx0dmFyIHRvcEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ3RvcCcpO1xuXHRcdHZhciBib3R0b21Cb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICdib3R0b20nKTtcblx0XHR2YXIgY2hhcnRBcmVhQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnY2hhcnRBcmVhJyk7XG5cblx0XHQvLyBTb3J0IGJveGVzIGJ5IHdlaWdodC4gQSBoaWdoZXIgd2VpZ2h0IGlzIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBjaGFydCBhcmVhXG5cdFx0c29ydEJ5V2VpZ2h0KGxlZnRCb3hlcywgdHJ1ZSk7XG5cdFx0c29ydEJ5V2VpZ2h0KHJpZ2h0Qm94ZXMsIGZhbHNlKTtcblx0XHRzb3J0QnlXZWlnaHQodG9wQm94ZXMsIHRydWUpO1xuXHRcdHNvcnRCeVdlaWdodChib3R0b21Cb3hlcywgZmFsc2UpO1xuXG5cdFx0dmFyIHZlcnRpY2FsQm94ZXMgPSBsZWZ0Qm94ZXMuY29uY2F0KHJpZ2h0Qm94ZXMpO1xuXHRcdHZhciBob3Jpem9udGFsQm94ZXMgPSB0b3BCb3hlcy5jb25jYXQoYm90dG9tQm94ZXMpO1xuXHRcdHZhciBvdXRlckJveGVzID0gdmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKTtcblxuXHRcdC8vIEVzc2VudGlhbGx5IHdlIG5vdyBoYXZlIGFueSBudW1iZXIgb2YgYm94ZXMgb24gZWFjaCBvZiB0aGUgNCBzaWRlcy5cblx0XHQvLyBPdXIgY2FudmFzIGxvb2tzIGxpa2UgdGhlIGZvbGxvd2luZy5cblx0XHQvLyBUaGUgYXJlYXMgTDEgYW5kIEwyIGFyZSB0aGUgbGVmdCBheGVzLiBSMSBpcyB0aGUgcmlnaHQgYXhpcywgVDEgaXMgdGhlIHRvcCBheGlzIGFuZFxuXHRcdC8vIEIxIGlzIHRoZSBib3R0b20gYXhpc1xuXHRcdC8vIFRoZXJlIGFyZSBhbHNvIDQgcXVhZHJhbnQtbGlrZSBsb2NhdGlvbnMgKGxlZnQgdG8gcmlnaHQgaW5zdGVhZCBvZiBjbG9ja3dpc2UpIHJlc2VydmVkIGZvciBjaGFydCBvdmVybGF5c1xuXHRcdC8vIFRoZXNlIGxvY2F0aW9ucyBhcmUgc2luZ2xlLWJveCBsb2NhdGlvbnMgb25seSwgd2hlbiB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBjaGFydEFyZWEgbG9jYXRpb24gdGhhdCBpcyBhbHJlYWR5IHRha2VuLFxuXHRcdC8vIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuXHRcdC8vXG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly8gfCAgICAgICAgICAgICAgICAgIFQxIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIFQyICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG5cdFx0Ly8gfCAgICB8ICAgIHwgQzEgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzIgfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfCBMMSB8IEwyIHwgICAgICAgICAgIENoYXJ0QXJlYSAoQzApICAgICAgICAgICAgfCBSMSB8XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG5cdFx0Ly8gfCAgICB8ICAgIHwgQzMgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzQgfCAgICB8XG5cdFx0Ly8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG5cdFx0Ly8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIEIxICAgICAgICAgICAgICAgICAgfCAgICB8XG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly8gfCAgICAgICAgICAgICAgICAgIEIyIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG5cdFx0Ly8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdFx0Ly9cblx0XHQvLyBXaGF0IHdlIGRvIHRvIGZpbmQgdGhlIGJlc3Qgc2l6aW5nLCB3ZSBkbyB0aGUgZm9sbG93aW5nXG5cdFx0Ly8gMS4gRGV0ZXJtaW5lIHRoZSBtaW5pbXVtIHNpemUgb2YgdGhlIGNoYXJ0IGFyZWEuXG5cdFx0Ly8gMi4gU3BsaXQgdGhlIHJlbWFpbmluZyB3aWR0aCBlcXVhbGx5IGJldHdlZW4gZWFjaCB2ZXJ0aWNhbCBheGlzXG5cdFx0Ly8gMy4gU3BsaXQgdGhlIHJlbWFpbmluZyBoZWlnaHQgZXF1YWxseSBiZXR3ZWVuIGVhY2ggaG9yaXpvbnRhbCBheGlzXG5cdFx0Ly8gNC4gR2l2ZSBlYWNoIGxheW91dCB0aGUgbWF4aW11bSBzaXplIGl0IGNhbiBiZS4gVGhlIGxheW91dCB3aWxsIHJldHVybiBpdCdzIG1pbmltdW0gc2l6ZVxuXHRcdC8vIDUuIEFkanVzdCB0aGUgc2l6ZXMgb2YgZWFjaCBheGlzIGJhc2VkIG9uIGl0J3MgbWluaW11bSByZXBvcnRlZCBzaXplLlxuXHRcdC8vIDYuIFJlZml0IGVhY2ggYXhpc1xuXHRcdC8vIDcuIFBvc2l0aW9uIGVhY2ggYXhpcyBpbiB0aGUgZmluYWwgbG9jYXRpb25cblx0XHQvLyA4LiBUZWxsIHRoZSBjaGFydCB0aGUgZmluYWwgbG9jYXRpb24gb2YgdGhlIGNoYXJ0IGFyZWFcblx0XHQvLyA5LiBUZWxsIGFueSBheGVzIHRoYXQgb3ZlcmxheSB0aGUgY2hhcnQgYXJlYSB0aGUgcG9zaXRpb25zIG9mIHRoZSBjaGFydCBhcmVhXG5cblx0XHQvLyBTdGVwIDFcblx0XHR2YXIgY2hhcnRXaWR0aCA9IHdpZHRoIC0gbGVmdFBhZGRpbmcgLSByaWdodFBhZGRpbmc7XG5cdFx0dmFyIGNoYXJ0SGVpZ2h0ID0gaGVpZ2h0IC0gdG9wUGFkZGluZyAtIGJvdHRvbVBhZGRpbmc7XG5cdFx0dmFyIGNoYXJ0QXJlYVdpZHRoID0gY2hhcnRXaWR0aCAvIDI7IC8vIG1pbiA1MCVcblxuXHRcdC8vIFN0ZXAgMlxuXHRcdHZhciB2ZXJ0aWNhbEJveFdpZHRoID0gKHdpZHRoIC0gY2hhcnRBcmVhV2lkdGgpIC8gdmVydGljYWxCb3hlcy5sZW5ndGg7XG5cblx0XHQvLyBTdGVwIDNcblx0XHQvLyBUT0RPIHJlLWxpbWl0IGhvcml6b250YWwgYXhpcyBoZWlnaHQgKHRoaXMgbGltaXQgaGFzIGFmZmVjdGVkIG9ubHkgcGFkZGluZyBjYWxjdWxhdGlvbiBzaW5jZSBQUiAxODM3KVxuXHRcdC8vIHZhciBob3Jpem9udGFsQm94SGVpZ2h0ID0gKGhlaWdodCAtIGNoYXJ0QXJlYUhlaWdodCkgLyBob3Jpem9udGFsQm94ZXMubGVuZ3RoO1xuXG5cdFx0Ly8gU3RlcCA0XG5cdFx0dmFyIG1heENoYXJ0QXJlYVdpZHRoID0gY2hhcnRXaWR0aDtcblx0XHR2YXIgbWF4Q2hhcnRBcmVhSGVpZ2h0ID0gY2hhcnRIZWlnaHQ7XG5cdFx0dmFyIG91dGVyQm94U2l6ZXMgPSB7dG9wOiB0b3BQYWRkaW5nLCBsZWZ0OiBsZWZ0UGFkZGluZywgYm90dG9tOiBib3R0b21QYWRkaW5nLCByaWdodDogcmlnaHRQYWRkaW5nfTtcblx0XHR2YXIgbWluQm94U2l6ZXMgPSBbXTtcblx0XHR2YXIgbWF4UGFkZGluZztcblxuXHRcdGZ1bmN0aW9uIGdldE1pbmltdW1Cb3hTaXplKGJveCkge1xuXHRcdFx0dmFyIG1pblNpemU7XG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gYm94LmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdG1pblNpemUgPSBib3gudXBkYXRlKGJveC5mdWxsV2lkdGggPyBjaGFydFdpZHRoIDogbWF4Q2hhcnRBcmVhV2lkdGgsIGNoYXJ0SGVpZ2h0IC8gMik7XG5cdFx0XHRcdG1heENoYXJ0QXJlYUhlaWdodCAtPSBtaW5TaXplLmhlaWdodDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pblNpemUgPSBib3gudXBkYXRlKHZlcnRpY2FsQm94V2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCk7XG5cdFx0XHRcdG1heENoYXJ0QXJlYVdpZHRoIC09IG1pblNpemUud2lkdGg7XG5cdFx0XHR9XG5cblx0XHRcdG1pbkJveFNpemVzLnB1c2goe1xuXHRcdFx0XHRob3Jpem9udGFsOiBpc0hvcml6b250YWwsXG5cdFx0XHRcdHdpZHRoOiBtaW5TaXplLndpZHRoLFxuXHRcdFx0XHRib3g6IGJveCxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGhlbHBlcnMkMS5lYWNoKG91dGVyQm94ZXMsIGdldE1pbmltdW1Cb3hTaXplKTtcblxuXHRcdC8vIElmIGEgaG9yaXpvbnRhbCBib3ggaGFzIHBhZGRpbmcsIHdlIG1vdmUgdGhlIGxlZnQgYm94ZXMgb3ZlciB0byBhdm9pZCB1Z2x5IGNoYXJ0cyAoc2VlIGlzc3VlICMyNDc4KVxuXHRcdG1heFBhZGRpbmcgPSBmaW5kTWF4UGFkZGluZyhvdXRlckJveGVzKTtcblxuXHRcdC8vIEF0IHRoaXMgcG9pbnQsIG1heENoYXJ0QXJlYUhlaWdodCBhbmQgbWF4Q2hhcnRBcmVhV2lkdGggYXJlIHRoZSBzaXplIHRoZSBjaGFydCBhcmVhIGNvdWxkXG5cdFx0Ly8gYmUgaWYgdGhlIGF4ZXMgYXJlIGRyYXduIGF0IHRoZWlyIG1pbmltdW0gc2l6ZXMuXG5cdFx0Ly8gU3RlcHMgNSAmIDZcblxuXHRcdC8vIEZ1bmN0aW9uIHRvIGZpdCBhIGJveFxuXHRcdGZ1bmN0aW9uIGZpdEJveChib3gpIHtcblx0XHRcdHZhciBtaW5Cb3hTaXplID0gaGVscGVycyQxLmZpbmROZXh0V2hlcmUobWluQm94U2l6ZXMsIGZ1bmN0aW9uKG1pbkJveCkge1xuXHRcdFx0XHRyZXR1cm4gbWluQm94LmJveCA9PT0gYm94O1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChtaW5Cb3hTaXplKSB7XG5cdFx0XHRcdGlmIChtaW5Cb3hTaXplLmhvcml6b250YWwpIHtcblx0XHRcdFx0XHR2YXIgc2NhbGVNYXJnaW4gPSB7XG5cdFx0XHRcdFx0XHRsZWZ0OiBNYXRoLm1heChvdXRlckJveFNpemVzLmxlZnQsIG1heFBhZGRpbmcubGVmdCksXG5cdFx0XHRcdFx0XHRyaWdodDogTWF0aC5tYXgob3V0ZXJCb3hTaXplcy5yaWdodCwgbWF4UGFkZGluZy5yaWdodCksXG5cdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHRib3R0b206IDBcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgdXNlIG1pbiBzaXplIGhlcmUgYmVjYXVzZSBvZiBsYWJlbCByb3RhdGlvbi4gV2hlbiB0aGUgbGFiZWxzIGFyZSByb3RhdGVkLCB0aGVpciByb3RhdGlvbiBoaWdobHkgZGVwZW5kc1xuXHRcdFx0XHRcdC8vIG9uIHRoZSBtYXJnaW4uIFNvbWV0aW1lcyB0aGV5IG5lZWQgdG8gaW5jcmVhc2UgaW4gc2l6ZSBzbGlnaHRseVxuXHRcdFx0XHRcdGJveC51cGRhdGUoYm94LmZ1bGxXaWR0aCA/IGNoYXJ0V2lkdGggOiBtYXhDaGFydEFyZWFXaWR0aCwgY2hhcnRIZWlnaHQgLyAyLCBzY2FsZU1hcmdpbik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ym94LnVwZGF0ZShtaW5Cb3hTaXplLndpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlLCBhbmQgY2FsY3VsYXRlIHRoZSBsZWZ0IGFuZCByaWdodCBtYXJnaW5zIGZvciB0aGUgaG9yaXpvbnRhbCBib3hlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKHZlcnRpY2FsQm94ZXMsIGZpdEJveCk7XG5cdFx0YWRkU2l6ZUJ5UG9zaXRpb24odmVydGljYWxCb3hlcywgb3V0ZXJCb3hTaXplcyk7XG5cblx0XHQvLyBTZXQgdGhlIExlZnQgYW5kIFJpZ2h0IG1hcmdpbnMgZm9yIHRoZSBob3Jpem9udGFsIGJveGVzXG5cdFx0aGVscGVycyQxLmVhY2goaG9yaXpvbnRhbEJveGVzLCBmaXRCb3gpO1xuXHRcdGFkZFNpemVCeVBvc2l0aW9uKGhvcml6b250YWxCb3hlcywgb3V0ZXJCb3hTaXplcyk7XG5cblx0XHRmdW5jdGlvbiBmaW5hbEZpdFZlcnRpY2FsQm94KGJveCkge1xuXHRcdFx0dmFyIG1pbkJveFNpemUgPSBoZWxwZXJzJDEuZmluZE5leHRXaGVyZShtaW5Cb3hTaXplcywgZnVuY3Rpb24obWluU2l6ZSkge1xuXHRcdFx0XHRyZXR1cm4gbWluU2l6ZS5ib3ggPT09IGJveDtcblx0XHRcdH0pO1xuXG5cdFx0XHR2YXIgc2NhbGVNYXJnaW4gPSB7XG5cdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdHJpZ2h0OiAwLFxuXHRcdFx0XHR0b3A6IG91dGVyQm94U2l6ZXMudG9wLFxuXHRcdFx0XHRib3R0b206IG91dGVyQm94U2l6ZXMuYm90dG9tXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAobWluQm94U2l6ZSkge1xuXHRcdFx0XHRib3gudXBkYXRlKG1pbkJveFNpemUud2lkdGgsIG1heENoYXJ0QXJlYUhlaWdodCwgc2NhbGVNYXJnaW4pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIExldCB0aGUgbGVmdCBsYXlvdXQga25vdyB0aGUgZmluYWwgbWFyZ2luXG5cdFx0aGVscGVycyQxLmVhY2godmVydGljYWxCb3hlcywgZmluYWxGaXRWZXJ0aWNhbEJveCk7XG5cblx0XHQvLyBSZWNhbGN1bGF0ZSBiZWNhdXNlIHRoZSBzaXplIG9mIGVhY2ggbGF5b3V0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbGlnaHRseSBkdWUgdG8gdGhlIG1hcmdpbnMgKGxhYmVsIHJvdGF0aW9uIGZvciBpbnN0YW5jZSlcblx0XHRvdXRlckJveFNpemVzID0ge3RvcDogdG9wUGFkZGluZywgbGVmdDogbGVmdFBhZGRpbmcsIGJvdHRvbTogYm90dG9tUGFkZGluZywgcmlnaHQ6IHJpZ2h0UGFkZGluZ307XG5cdFx0YWRkU2l6ZUJ5UG9zaXRpb24ob3V0ZXJCb3hlcywgb3V0ZXJCb3hTaXplcyk7XG5cblx0XHQvLyBXZSBtYXkgYmUgYWRkaW5nIHNvbWUgcGFkZGluZyB0byBhY2NvdW50IGZvciByb3RhdGVkIHggYXhpcyBsYWJlbHNcblx0XHR2YXIgbGVmdFBhZGRpbmdBZGRpdGlvbiA9IE1hdGgubWF4KG1heFBhZGRpbmcubGVmdCAtIG91dGVyQm94U2l6ZXMubGVmdCwgMCk7XG5cdFx0b3V0ZXJCb3hTaXplcy5sZWZ0ICs9IGxlZnRQYWRkaW5nQWRkaXRpb247XG5cdFx0b3V0ZXJCb3hTaXplcy5yaWdodCArPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0IC0gb3V0ZXJCb3hTaXplcy5yaWdodCwgMCk7XG5cblx0XHR2YXIgdG9wUGFkZGluZ0FkZGl0aW9uID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AgLSBvdXRlckJveFNpemVzLnRvcCwgMCk7XG5cdFx0b3V0ZXJCb3hTaXplcy50b3AgKz0gdG9wUGFkZGluZ0FkZGl0aW9uO1xuXHRcdG91dGVyQm94U2l6ZXMuYm90dG9tICs9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tIC0gb3V0ZXJCb3hTaXplcy5ib3R0b20sIDApO1xuXG5cdFx0Ly8gRmlndXJlIG91dCBpZiBvdXIgY2hhcnQgYXJlYSBjaGFuZ2VkLiBUaGlzIHdvdWxkIG9jY3VyIGlmIHRoZSBkYXRhc2V0IGxheW91dCBsYWJlbCByb3RhdGlvblxuXHRcdC8vIGNoYW5nZWQgZHVlIHRvIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGUgbWFyZ2lucyBpbiBzdGVwIDYuIFNpbmNlIHdlIGNhbiBvbmx5IGdldCBiaWdnZXIsIHRoaXMgaXMgc2FmZSB0byBkb1xuXHRcdC8vIHdpdGhvdXQgY2FsbGluZyBgZml0YCBhZ2FpblxuXHRcdHZhciBuZXdNYXhDaGFydEFyZWFIZWlnaHQgPSBoZWlnaHQgLSBvdXRlckJveFNpemVzLnRvcCAtIG91dGVyQm94U2l6ZXMuYm90dG9tO1xuXHRcdHZhciBuZXdNYXhDaGFydEFyZWFXaWR0aCA9IHdpZHRoIC0gb3V0ZXJCb3hTaXplcy5sZWZ0IC0gb3V0ZXJCb3hTaXplcy5yaWdodDtcblxuXHRcdGlmIChuZXdNYXhDaGFydEFyZWFXaWR0aCAhPT0gbWF4Q2hhcnRBcmVhV2lkdGggfHwgbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0ICE9PSBtYXhDaGFydEFyZWFIZWlnaHQpIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKHZlcnRpY2FsQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHRib3guaGVpZ2h0ID0gbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXHRcdFx0fSk7XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGhvcml6b250YWxCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRcdGlmICghYm94LmZ1bGxXaWR0aCkge1xuXHRcdFx0XHRcdGJveC53aWR0aCA9IG5ld01heENoYXJ0QXJlYVdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0bWF4Q2hhcnRBcmVhSGVpZ2h0ID0gbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXHRcdFx0bWF4Q2hhcnRBcmVhV2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHR9XG5cblx0XHQvLyBTdGVwIDcgLSBQb3NpdGlvbiB0aGUgYm94ZXNcblx0XHR2YXIgbGVmdCA9IGxlZnRQYWRkaW5nICsgbGVmdFBhZGRpbmdBZGRpdGlvbjtcblx0XHR2YXIgdG9wID0gdG9wUGFkZGluZyArIHRvcFBhZGRpbmdBZGRpdGlvbjtcblxuXHRcdGZ1bmN0aW9uIHBsYWNlQm94KGJveCkge1xuXHRcdFx0aWYgKGJveC5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHRib3gubGVmdCA9IGJveC5mdWxsV2lkdGggPyBsZWZ0UGFkZGluZyA6IG91dGVyQm94U2l6ZXMubGVmdDtcblx0XHRcdFx0Ym94LnJpZ2h0ID0gYm94LmZ1bGxXaWR0aCA/IHdpZHRoIC0gcmlnaHRQYWRkaW5nIDogb3V0ZXJCb3hTaXplcy5sZWZ0ICsgbWF4Q2hhcnRBcmVhV2lkdGg7XG5cdFx0XHRcdGJveC50b3AgPSB0b3A7XG5cdFx0XHRcdGJveC5ib3R0b20gPSB0b3AgKyBib3guaGVpZ2h0O1xuXG5cdFx0XHRcdC8vIE1vdmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHR0b3AgPSBib3guYm90dG9tO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGJveC5sZWZ0ID0gbGVmdDtcblx0XHRcdFx0Ym94LnJpZ2h0ID0gbGVmdCArIGJveC53aWR0aDtcblx0XHRcdFx0Ym94LnRvcCA9IG91dGVyQm94U2l6ZXMudG9wO1xuXHRcdFx0XHRib3guYm90dG9tID0gb3V0ZXJCb3hTaXplcy50b3AgKyBtYXhDaGFydEFyZWFIZWlnaHQ7XG5cblx0XHRcdFx0Ly8gTW92ZSB0byBuZXh0IHBvaW50XG5cdFx0XHRcdGxlZnQgPSBib3gucmlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmVhY2gobGVmdEJveGVzLmNvbmNhdCh0b3BCb3hlcyksIHBsYWNlQm94KTtcblxuXHRcdC8vIEFjY291bnQgZm9yIGNoYXJ0IHdpZHRoIGFuZCBoZWlnaHRcblx0XHRsZWZ0ICs9IG1heENoYXJ0QXJlYVdpZHRoO1xuXHRcdHRvcCArPSBtYXhDaGFydEFyZWFIZWlnaHQ7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChyaWdodEJveGVzLCBwbGFjZUJveCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm90dG9tQm94ZXMsIHBsYWNlQm94KTtcblxuXHRcdC8vIFN0ZXAgOFxuXHRcdGNoYXJ0LmNoYXJ0QXJlYSA9IHtcblx0XHRcdGxlZnQ6IG91dGVyQm94U2l6ZXMubGVmdCxcblx0XHRcdHRvcDogb3V0ZXJCb3hTaXplcy50b3AsXG5cdFx0XHRyaWdodDogb3V0ZXJCb3hTaXplcy5sZWZ0ICsgbWF4Q2hhcnRBcmVhV2lkdGgsXG5cdFx0XHRib3R0b206IG91dGVyQm94U2l6ZXMudG9wICsgbWF4Q2hhcnRBcmVhSGVpZ2h0XG5cdFx0fTtcblxuXHRcdC8vIFN0ZXAgOVxuXHRcdGhlbHBlcnMkMS5lYWNoKGNoYXJ0QXJlYUJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdGJveC5sZWZ0ID0gY2hhcnQuY2hhcnRBcmVhLmxlZnQ7XG5cdFx0XHRib3gudG9wID0gY2hhcnQuY2hhcnRBcmVhLnRvcDtcblx0XHRcdGJveC5yaWdodCA9IGNoYXJ0LmNoYXJ0QXJlYS5yaWdodDtcblx0XHRcdGJveC5ib3R0b20gPSBjaGFydC5jaGFydEFyZWEuYm90dG9tO1xuXG5cdFx0XHRib3gudXBkYXRlKG1heENoYXJ0QXJlYVdpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQpO1xuXHRcdH0pO1xuXHR9XG59O1xuXG4vKipcbiAqIFBsYXRmb3JtIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIChtaW5pbWFsKS5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTkxI2lzc3VlY29tbWVudC0zMTk1NzU5MzlcbiAqL1xuXG52YXIgcGxhdGZvcm1fYmFzaWMgPSB7XG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0aWYgKGl0ZW0gJiYgaXRlbS5jYW52YXMpIHtcblx0XHRcdC8vIFN1cHBvcnQgZm9yIGFueSBvYmplY3QgYXNzb2NpYXRlZCB0byBhIGNhbnZhcyAoaW5jbHVkaW5nIGEgY29udGV4dDJkKVxuXHRcdFx0aXRlbSA9IGl0ZW0uY2FudmFzO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuXHR9XG59O1xuXG52YXIgcGxhdGZvcm1fZG9tID0gXCIvKlxcbiAqIERPTSBlbGVtZW50IHJlbmRlcmluZyBkZXRlY3Rpb25cXG4gKiBodHRwczovL2Rhdmlkd2Fsc2gubmFtZS9kZXRlY3Qtbm9kZS1pbnNlcnRpb25cXG4gKi9cXG5Aa2V5ZnJhbWVzIGNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbiB7XFxuXFx0ZnJvbSB7IG9wYWNpdHk6IDAuOTk7IH1cXG5cXHR0byB7IG9wYWNpdHk6IDE7IH1cXG59XFxuXFxuLmNoYXJ0anMtcmVuZGVyLW1vbml0b3Ige1xcblxcdGFuaW1hdGlvbjogY2hhcnRqcy1yZW5kZXItYW5pbWF0aW9uIDAuMDAxcztcXG59XFxuXFxuLypcXG4gKiBET00gZWxlbWVudCByZXNpemluZyBkZXRlY3Rpb25cXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllc1xcbiAqL1xcbi5jaGFydGpzLXNpemUtbW9uaXRvcixcXG4uY2hhcnRqcy1zaXplLW1vbml0b3ItZXhwYW5kLFxcbi5jaGFydGpzLXNpemUtbW9uaXRvci1zaHJpbmsge1xcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHRkaXJlY3Rpb246IGx0cjtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG5cXHRyaWdodDogMDtcXG5cXHRib3R0b206IDA7XFxuXFx0b3ZlcmZsb3c6IGhpZGRlbjtcXG5cXHRwb2ludGVyLWV2ZW50czogbm9uZTtcXG5cXHR2aXNpYmlsaXR5OiBoaWRkZW47XFxuXFx0ei1pbmRleDogLTE7XFxufVxcblxcbi5jaGFydGpzLXNpemUtbW9uaXRvci1leHBhbmQgPiBkaXYge1xcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG5cXHR3aWR0aDogMTAwMDAwMHB4O1xcblxcdGhlaWdodDogMTAwMDAwMHB4O1xcblxcdGxlZnQ6IDA7XFxuXFx0dG9wOiAwO1xcbn1cXG5cXG4uY2hhcnRqcy1zaXplLW1vbml0b3Itc2hyaW5rID4gZGl2IHtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0d2lkdGg6IDIwMCU7XFxuXFx0aGVpZ2h0OiAyMDAlO1xcblxcdGxlZnQ6IDA7XFxuXFx0dG9wOiAwO1xcbn1cXG5cIjtcblxudmFyIHBsYXRmb3JtX2RvbSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuZGVmYXVsdDogcGxhdGZvcm1fZG9tXG59KTtcblxuZnVuY3Rpb24gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZSAobikge1xuXHRyZXR1cm4gbiAmJiBuLmRlZmF1bHQgfHwgbjtcbn1cblxudmFyIHN0eWxlc2hlZXQgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKHBsYXRmb3JtX2RvbSQxKTtcblxudmFyIEVYUEFORE9fS0VZID0gJyRjaGFydGpzJztcbnZhciBDU1NfUFJFRklYID0gJ2NoYXJ0anMtJztcbnZhciBDU1NfU0laRV9NT05JVE9SID0gQ1NTX1BSRUZJWCArICdzaXplLW1vbml0b3InO1xudmFyIENTU19SRU5ERVJfTU9OSVRPUiA9IENTU19QUkVGSVggKyAncmVuZGVyLW1vbml0b3InO1xudmFyIENTU19SRU5ERVJfQU5JTUFUSU9OID0gQ1NTX1BSRUZJWCArICdyZW5kZXItYW5pbWF0aW9uJztcbnZhciBBTklNQVRJT05fU1RBUlRfRVZFTlRTID0gWydhbmltYXRpb25zdGFydCcsICd3ZWJraXRBbmltYXRpb25TdGFydCddO1xuXG4vKipcbiAqIERPTSBldmVudCB0eXBlcyAtPiBDaGFydC5qcyBldmVudCB0eXBlcy5cbiAqIE5vdGU6IG9ubHkgZXZlbnRzIHdpdGggZGlmZmVyZW50IHR5cGVzIGFyZSBtYXBwZWQuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50c1xuICovXG52YXIgRVZFTlRfVFlQRVMgPSB7XG5cdHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuXHR0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuXHR0b3VjaGVuZDogJ21vdXNldXAnLFxuXHRwb2ludGVyZW50ZXI6ICdtb3VzZWVudGVyJyxcblx0cG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxuXHRwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXG5cdHBvaW50ZXJ1cDogJ21vdXNldXAnLFxuXHRwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXG5cdHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcbn07XG5cbi8qKlxuICogVGhlIFwidXNlZFwiIHNpemUgaXMgdGhlIGZpbmFsIHZhbHVlIG9mIGEgZGltZW5zaW9uIHByb3BlcnR5IGFmdGVyIGFsbCBjYWxjdWxhdGlvbnMgaGF2ZVxuICogYmVlbiBwZXJmb3JtZWQuIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIGBlbGVtZW50YCBidXQgcmV0dXJucyB1bmRlZmluZWRcbiAqIGlmIHRoZSBjb21wdXRlZCBzdHlsZSBpcyBub3QgZXhwcmVzc2VkIGluIHBpeGVscy4gVGhhdCBjYW4gaGFwcGVuIGluIHNvbWUgY2FzZXMgd2hlcmVcbiAqIGBlbGVtZW50YCBoYXMgYSBzaXplIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgYW5kIHRoaXMgbGFzdCBvbmUgaXMgbm90IHlldCBkaXNwbGF5ZWQsXG4gKiBmb3IgZXhhbXBsZSBiZWNhdXNlIG9mIGBkaXNwbGF5OiBub25lYCBvbiBhIHBhcmVudCBub2RlLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdXNlZF92YWx1ZVxuICogQHJldHVybnMge251bWJlcn0gU2l6ZSBpbiBwaXhlbHMgb3IgdW5kZWZpbmVkIGlmIHVua25vd24uXG4gKi9cbmZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuXHR2YXIgdmFsdWUgPSBoZWxwZXJzJDEuZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuXHR2YXIgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuXHRyZXR1cm4gbWF0Y2hlcyA/IE51bWJlcihtYXRjaGVzWzFdKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIHN0eWxlIGFuZCByZW5kZXIgc2l6ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2FudmFzIGRpc3BsYXkgc2l6ZSxcbiAqIHNpbmNlIHJlc3BvbnNpdmVuZXNzIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRyb2xsZXIucmVzaXplKCkgbWV0aG9kLiBUaGUgY29uZmlnIGlzIHVzZWRcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cbiAqL1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGNvbmZpZykge1xuXHR2YXIgc3R5bGUgPSBjYW52YXMuc3R5bGU7XG5cblx0Ly8gTk9URShTQikgY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAhPT0gY2FudmFzLndpZHRoOiBpbiB0aGUgZmlyc3QgY2FzZSBpdFxuXHQvLyByZXR1cm5zIG51bGwgb3IgJycgaWYgbm8gZXhwbGljaXQgdmFsdWUgaGFzIGJlZW4gc2V0IHRvIHRoZSBjYW52YXMgYXR0cmlidXRlLlxuXHR2YXIgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG5cdHZhciByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG5cblx0Ly8gQ2hhcnQuanMgbW9kaWZpZXMgc29tZSBjYW52YXMgdmFsdWVzIHRoYXQgd2Ugd2FudCB0byByZXN0b3JlIG9uIGRlc3Ryb3lcblx0Y2FudmFzW0VYUEFORE9fS0VZXSA9IHtcblx0XHRpbml0aWFsOiB7XG5cdFx0XHRoZWlnaHQ6IHJlbmRlckhlaWdodCxcblx0XHRcdHdpZHRoOiByZW5kZXJXaWR0aCxcblx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdGRpc3BsYXk6IHN0eWxlLmRpc3BsYXksXG5cdFx0XHRcdGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuXHRcdFx0XHR3aWR0aDogc3R5bGUud2lkdGhcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gRm9yY2UgY2FudmFzIHRvIGRpc3BsYXkgYXMgYmxvY2sgdG8gYXZvaWQgZXh0cmEgc3BhY2UgY2F1c2VkIGJ5IGlubGluZVxuXHQvLyBlbGVtZW50cywgd2hpY2ggd291bGQgaW50ZXJmZXJlIHdpdGggdGhlIHJlc3BvbnNpdmUgcmVzaXplIHByb2Nlc3MuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNTM4XG5cdHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG5cblx0aWYgKHJlbmRlcldpZHRoID09PSBudWxsIHx8IHJlbmRlcldpZHRoID09PSAnJykge1xuXHRcdHZhciBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcblx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IGRpc3BsYXlXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRpZiAocmVuZGVySGVpZ2h0ID09PSBudWxsIHx8IHJlbmRlckhlaWdodCA9PT0gJycpIHtcblx0XHRpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcblx0XHRcdC8vIElmIG5vIGV4cGxpY2l0IHJlbmRlciBoZWlnaHQgYW5kIHN0eWxlIGhlaWdodCwgbGV0J3MgYXBwbHkgdGhlIGFzcGVjdCByYXRpbyxcblx0XHRcdC8vIHdoaWNoIG9uZSBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIGJ1dCBhbHNvIGJ5IGNoYXJ0cyBhcyBkZWZhdWx0IG9wdGlvblxuXHRcdFx0Ly8gKGkuZS4gb3B0aW9ucy5hc3BlY3RSYXRpbykuIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBjYW52YXMgYXNwZWN0IHJhdGlvIG9mIDIuXG5cdFx0XHRjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGNvbmZpZy5vcHRpb25zLmFzcGVjdFJhdGlvIHx8IDIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZGlzcGxheUhlaWdodCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICdoZWlnaHQnKTtcblx0XHRcdGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2FudmFzO1xufVxuXG4vKipcbiAqIERldGVjdHMgc3VwcG9ydCBmb3Igb3B0aW9ucyBvYmplY3QgYXJndW1lbnQgaW4gYWRkRXZlbnRMaXN0ZW5lci5cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgc3VwcG9ydHMgPSBmYWxzZTtcblx0dHJ5IHtcblx0XHR2YXIgb3B0aW9ucyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ2V0dGVyLXJldHVyblxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3VwcG9ydHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlJywgbnVsbCwgb3B0aW9ucyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG5cdH1cblx0cmV0dXJuIHN1cHBvcnRzO1xufSgpKTtcblxuLy8gRGVmYXVsdCBwYXNzaXZlIHRvIHRydWUgYXMgZXhwZWN0ZWQgYnkgQ2hyb21lIGZvciAndG91Y2hzdGFydCcgYW5kICd0b3VjaGVuZCcgZXZlbnRzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQyODdcbnZhciBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcblx0bm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgeCwgeSwgbmF0aXZlRXZlbnQpIHtcblx0cmV0dXJuIHtcblx0XHR0eXBlOiB0eXBlLFxuXHRcdGNoYXJ0OiBjaGFydCxcblx0XHRuYXRpdmU6IG5hdGl2ZUV2ZW50IHx8IG51bGwsXG5cdFx0eDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG5cdFx0eTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG5cdH07XG59XG5cbmZ1bmN0aW9uIGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpIHtcblx0dmFyIHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuXHR2YXIgcG9zID0gaGVscGVycyQxLmdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcblx0cmV0dXJuIGNyZWF0ZUV2ZW50KHR5cGUsIGNoYXJ0LCBwb3MueCwgcG9zLnksIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gdGhyb3R0bGVkKGZuLCB0aGlzQXJnKSB7XG5cdHZhciB0aWNraW5nID0gZmFsc2U7XG5cdHZhciBhcmdzID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdHRoaXNBcmcgPSB0aGlzQXJnIHx8IHRoaXM7XG5cblx0XHRpZiAoIXRpY2tpbmcpIHtcblx0XHRcdHRpY2tpbmcgPSB0cnVlO1xuXHRcdFx0aGVscGVycyQxLnJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aWNraW5nID0gZmFsc2U7XG5cdFx0XHRcdGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEaXYoY2xzKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRlbC5jbGFzc05hbWUgPSBjbHMgfHwgJyc7XG5cdHJldHVybiBlbDtcbn1cblxuLy8gSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXNcbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZXIoaGFuZGxlcikge1xuXHR2YXIgbWF4U2l6ZSA9IDEwMDAwMDA7XG5cblx0Ly8gTk9URShTQikgRG9uJ3QgdXNlIGlubmVySFRNTCBiZWNhdXNlIGl0IGNvdWxkIGJlIGNvbnNpZGVyZWQgdW5zYWZlLlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTkwMlxuXHR2YXIgcmVzaXplciA9IGNyZWF0ZURpdihDU1NfU0laRV9NT05JVE9SKTtcblx0dmFyIGV4cGFuZCA9IGNyZWF0ZURpdihDU1NfU0laRV9NT05JVE9SICsgJy1leHBhbmQnKTtcblx0dmFyIHNocmluayA9IGNyZWF0ZURpdihDU1NfU0laRV9NT05JVE9SICsgJy1zaHJpbmsnKTtcblxuXHRleHBhbmQuYXBwZW5kQ2hpbGQoY3JlYXRlRGl2KCkpO1xuXHRzaHJpbmsuYXBwZW5kQ2hpbGQoY3JlYXRlRGl2KCkpO1xuXG5cdHJlc2l6ZXIuYXBwZW5kQ2hpbGQoZXhwYW5kKTtcblx0cmVzaXplci5hcHBlbmRDaGlsZChzaHJpbmspO1xuXHRyZXNpemVyLl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHRcdGV4cGFuZC5zY3JvbGxMZWZ0ID0gbWF4U2l6ZTtcblx0XHRleHBhbmQuc2Nyb2xsVG9wID0gbWF4U2l6ZTtcblx0XHRzaHJpbmsuc2Nyb2xsTGVmdCA9IG1heFNpemU7XG5cdFx0c2hyaW5rLnNjcm9sbFRvcCA9IG1heFNpemU7XG5cdH07XG5cblx0dmFyIG9uU2Nyb2xsID0gZnVuY3Rpb24oKSB7XG5cdFx0cmVzaXplci5fcmVzZXQoKTtcblx0XHRoYW5kbGVyKCk7XG5cdH07XG5cblx0YWRkTGlzdGVuZXIoZXhwYW5kLCAnc2Nyb2xsJywgb25TY3JvbGwuYmluZChleHBhbmQsICdleHBhbmQnKSk7XG5cdGFkZExpc3RlbmVyKHNocmluaywgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoc2hyaW5rLCAnc2hyaW5rJykpO1xuXG5cdHJldHVybiByZXNpemVyO1xufVxuXG4vLyBodHRwczovL2Rhdmlkd2Fsc2gubmFtZS9kZXRlY3Qtbm9kZS1pbnNlcnRpb25cbmZ1bmN0aW9uIHdhdGNoRm9yUmVuZGVyKG5vZGUsIGhhbmRsZXIpIHtcblx0dmFyIGV4cGFuZG8gPSBub2RlW0VYUEFORE9fS0VZXSB8fCAobm9kZVtFWFBBTkRPX0tFWV0gPSB7fSk7XG5cdHZhciBwcm94eSA9IGV4cGFuZG8ucmVuZGVyUHJveHkgPSBmdW5jdGlvbihlKSB7XG5cdFx0aWYgKGUuYW5pbWF0aW9uTmFtZSA9PT0gQ1NTX1JFTkRFUl9BTklNQVRJT04pIHtcblx0XHRcdGhhbmRsZXIoKTtcblx0XHR9XG5cdH07XG5cblx0aGVscGVycyQxLmVhY2goQU5JTUFUSU9OX1NUQVJUX0VWRU5UUywgZnVuY3Rpb24odHlwZSkge1xuXHRcdGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcblx0fSk7XG5cblx0Ly8gIzQ3Mzc6IENocm9tZSBtaWdodCBza2lwIHRoZSBDU1MgYW5pbWF0aW9uIHdoZW4gdGhlIENTU19SRU5ERVJfTU9OSVRPUiBjbGFzc1xuXHQvLyBpcyByZW1vdmVkIHRoZW4gYWRkZWQgYmFjayBpbW1lZGlhdGVseSAoc2FtZSBhbmltYXRpb24gZnJhbWU/KS4gQWNjZXNzaW5nIHRoZVxuXHQvLyBgb2Zmc2V0UGFyZW50YCBwcm9wZXJ0eSB3aWxsIGZvcmNlIGEgcmVmbG93IGFuZCByZS1ldmFsdWF0ZSB0aGUgQ1NTIGFuaW1hdGlvbi5cblx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzVkNTJmYjA4MWIzNTcwYzgxZTNhI2JveC1tZXRyaWNzXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80NzM3XG5cdGV4cGFuZG8ucmVmbG93ID0gISFub2RlLm9mZnNldFBhcmVudDtcblxuXHRub2RlLmNsYXNzTGlzdC5hZGQoQ1NTX1JFTkRFUl9NT05JVE9SKTtcbn1cblxuZnVuY3Rpb24gdW53YXRjaEZvclJlbmRlcihub2RlKSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwge307XG5cdHZhciBwcm94eSA9IGV4cGFuZG8ucmVuZGVyUHJveHk7XG5cblx0aWYgKHByb3h5KSB7XG5cdFx0aGVscGVycyQxLmVhY2goQU5JTUFUSU9OX1NUQVJUX0VWRU5UUywgZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0cmVtb3ZlTGlzdGVuZXIobm9kZSwgdHlwZSwgcHJveHkpO1xuXHRcdH0pO1xuXG5cdFx0ZGVsZXRlIGV4cGFuZG8ucmVuZGVyUHJveHk7XG5cdH1cblxuXHRub2RlLmNsYXNzTGlzdC5yZW1vdmUoQ1NTX1JFTkRFUl9NT05JVE9SKTtcbn1cblxuZnVuY3Rpb24gYWRkUmVzaXplTGlzdGVuZXIobm9kZSwgbGlzdGVuZXIsIGNoYXJ0KSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwgKG5vZGVbRVhQQU5ET19LRVldID0ge30pO1xuXG5cdC8vIExldCdzIGtlZXAgdHJhY2sgb2YgdGhpcyBhZGRlZCByZXNpemVyIGFuZCB0aHVzIGF2b2lkIERPTSBxdWVyeSB3aGVuIHJlbW92aW5nIGl0LlxuXHR2YXIgcmVzaXplciA9IGV4cGFuZG8ucmVzaXplciA9IGNyZWF0ZVJlc2l6ZXIodGhyb3R0bGVkKGZ1bmN0aW9uKCkge1xuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcblx0XHRcdHZhciBjb250YWluZXIgPSBjaGFydC5vcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgbm9kZS5wYXJlbnROb2RlO1xuXHRcdFx0dmFyIHcgPSBjb250YWluZXIgPyBjb250YWluZXIuY2xpZW50V2lkdGggOiAwO1xuXHRcdFx0bGlzdGVuZXIoY3JlYXRlRXZlbnQoJ3Jlc2l6ZScsIGNoYXJ0KSk7XG5cdFx0XHRpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lci5jbGllbnRXaWR0aCA8IHcgJiYgY2hhcnQuY2FudmFzKSB7XG5cdFx0XHRcdC8vIElmIHRoZSBjb250YWluZXIgc2l6ZSBzaHJhbmsgZHVyaW5nIGNoYXJ0IHJlc2l6ZSwgbGV0J3MgYXNzdW1lXG5cdFx0XHRcdC8vIHNjcm9sbGJhciBhcHBlYXJlZC4gU28gd2UgcmVzaXplIGFnYWluIHdpdGggdGhlIHNjcm9sbGJhciB2aXNpYmxlIC1cblx0XHRcdFx0Ly8gZWZmZWN0aXZlbHkgbWFraW5nIGNoYXJ0IHNtYWxsZXIgYW5kIHRoZSBzY3JvbGxiYXIgaGlkZGVuIGFnYWluLlxuXHRcdFx0XHQvLyBCZWNhdXNlIHdlIGFyZSBpbnNpZGUgYHRocm90dGxlZGAsIGFuZCBjdXJyZW50bHkgYHRpY2tpbmdgLCBzY3JvbGxcblx0XHRcdFx0Ly8gZXZlbnRzIGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIHdob2xlIDIgcmVzaXplIHByb2Nlc3MuXG5cdFx0XHRcdC8vIElmIHdlIGFzc3VtZWQgd3JvbmcgYW5kIHNvbWV0aGluZyBlbHNlIGhhcHBlbmVkLCB3ZSBhcmUgcmVzaXppbmdcblx0XHRcdFx0Ly8gdHdpY2UgaW4gYSBmcmFtZSAocG90ZW50aWFsIHBlcmZvcm1hbmNlIGlzc3VlKVxuXHRcdFx0XHRsaXN0ZW5lcihjcmVhdGVFdmVudCgncmVzaXplJywgY2hhcnQpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pKTtcblxuXHQvLyBUaGUgcmVzaXplciBuZWVkcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZSBwYXJlbnQsIHNvIHdlIGZpcnN0IG5lZWQgdG8gYmVcblx0Ly8gc3VyZSB0aGF0IGBub2RlYCBpcyBhdHRhY2hlZCB0byB0aGUgRE9NIGJlZm9yZSBpbmplY3RpbmcgdGhlIHJlc2l6ZXIgZWxlbWVudC5cblx0d2F0Y2hGb3JSZW5kZXIobm9kZSwgZnVuY3Rpb24oKSB7XG5cdFx0aWYgKGV4cGFuZG8ucmVzaXplcikge1xuXHRcdFx0dmFyIGNvbnRhaW5lciA9IG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdGlmIChjb250YWluZXIgJiYgY29udGFpbmVyICE9PSByZXNpemVyLnBhcmVudE5vZGUpIHtcblx0XHRcdFx0Y29udGFpbmVyLmluc2VydEJlZm9yZShyZXNpemVyLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBjb250YWluZXIgc2l6ZSBtaWdodCBoYXZlIGNoYW5nZWQsIGxldCdzIHJlc2V0IHRoZSByZXNpemVyIHN0YXRlLlxuXHRcdFx0cmVzaXplci5fcmVzZXQoKTtcblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVSZXNpemVMaXN0ZW5lcihub2RlKSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwge307XG5cdHZhciByZXNpemVyID0gZXhwYW5kby5yZXNpemVyO1xuXG5cdGRlbGV0ZSBleHBhbmRvLnJlc2l6ZXI7XG5cdHVud2F0Y2hGb3JSZW5kZXIobm9kZSk7XG5cblx0aWYgKHJlc2l6ZXIgJiYgcmVzaXplci5wYXJlbnROb2RlKSB7XG5cdFx0cmVzaXplci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJlc2l6ZXIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGluamVjdENTUyhwbGF0Zm9ybSwgY3NzKSB7XG5cdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTIyMTM5XG5cdHZhciBzdHlsZSA9IHBsYXRmb3JtLl9zdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXHRpZiAoIXBsYXRmb3JtLl9zdHlsZSkge1xuXHRcdHBsYXRmb3JtLl9zdHlsZSA9IHN0eWxlO1xuXHRcdGNzcyA9ICcvKiBDaGFydC5qcyAqL1xcbicgKyBjc3M7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQvY3NzJyk7XG5cdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH1cblxuXHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbn1cblxudmFyIHBsYXRmb3JtX2RvbSQyID0ge1xuXHQvKipcblx0ICogV2hlbiBgdHJ1ZWAsIHByZXZlbnRzIHRoZSBhdXRvbWF0aWMgaW5qZWN0aW9uIG9mIHRoZSBzdHlsZXNoZWV0IHJlcXVpcmVkIHRvXG5cdCAqIGNvcnJlY3RseSBkZXRlY3Qgd2hlbiB0aGUgY2hhcnQgaXMgYWRkZWQgdG8gdGhlIERPTSBhbmQgdGhlbiByZXNpemVkLiBUaGlzXG5cdCAqIHN3aXRjaCBoYXMgYmVlbiBhZGRlZCB0byBhbGxvdyBleHRlcm5hbCBzdHlsZXNoZWV0IChgZGlzdC9DaGFydCgubWluKT8uanNgKVxuXHQgKiB0byBiZSBtYW51YWxseSBpbXBvcnRlZCB0byBtYWtlIHRoaXMgbGlicmFyeSBjb21wYXRpYmxlIHdpdGggYW55IENTUC5cblx0ICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MjA4XG5cdCAqL1xuXHRkaXNhYmxlQ1NTSW5qZWN0aW9uOiBmYWxzZSxcblxuXHQvKipcblx0ICogVGhpcyBwcm9wZXJ0eSBob2xkcyB3aGV0aGVyIHRoaXMgcGxhdGZvcm0gaXMgZW5hYmxlZCBmb3IgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG5cdCAqIEN1cnJlbnRseSB1c2VkIGJ5IHBsYXRmb3JtLmpzIHRvIHNlbGVjdCB0aGUgcHJvcGVyIGltcGxlbWVudGF0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2VuYWJsZWQ6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZW5zdXJlTG9hZGVkOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcblxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MjA4XG5cdFx0aWYgKCF0aGlzLmRpc2FibGVDU1NJbmplY3Rpb24pIHtcblx0XHRcdGluamVjdENTUyh0aGlzLCBzdHlsZXNoZWV0KTtcblx0XHR9XG5cdH0sXG5cblx0YWNxdWlyZUNvbnRleHQ6IGZ1bmN0aW9uKGl0ZW0sIGNvbmZpZykge1xuXHRcdGlmICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcblx0XHR9IGVsc2UgaWYgKGl0ZW0ubGVuZ3RoKSB7XG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhcnJheSBiYXNlZCBxdWVyaWVzIChzdWNoIGFzIGpRdWVyeSlcblx0XHRcdGl0ZW0gPSBpdGVtWzBdO1xuXHRcdH1cblxuXHRcdGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcblx0XHRcdGl0ZW0gPSBpdGVtLmNhbnZhcztcblx0XHR9XG5cblx0XHQvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG5cdFx0Ly8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuXHRcdHZhciBjb250ZXh0ID0gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpO1xuXG5cdFx0Ly8gTG9hZCBwbGF0Zm9ybSByZXNvdXJjZXMgb24gZmlyc3QgY2hhcnQgY3JlYXRpb24sIHRvIG1ha2UgcG9zc2libGUgdG8gY2hhbmdlXG5cdFx0Ly8gcGxhdGZvcm0gb3B0aW9ucyBhZnRlciBpbXBvcnRpbmcgdGhlIGxpYnJhcnkgKGUuZy4gYGRpc2FibGVDU1NJbmplY3Rpb25gKS5cblx0XHR0aGlzLl9lbnN1cmVMb2FkZWQoKTtcblxuXHRcdC8vIGBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50L0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgZmFpbHMgd2hlbiB0aGUgaXRlbSBpc1xuXHRcdC8vIGluc2lkZSBhbiBpZnJhbWUgb3Igd2hlbiBydW5uaW5nIGluIGEgcHJvdGVjdGVkIGVudmlyb25tZW50LiBXZSBjb3VsZCBndWVzcyB0aGVcblx0XHQvLyB0eXBlcyBmcm9tIHRoZWlyIHRvU3RyaW5nKCkgdmFsdWUgYnV0IGxldCdzIGtlZXAgdGhpbmdzIGZsZXhpYmxlIGFuZCBhc3N1bWUgaXQnc1xuXHRcdC8vIGEgc3VmZmljaWVudCBjb25kaXRpb24gaWYgdGhlIGl0ZW0gaGFzIGEgY29udGV4dDJEIHdoaWNoIGhhcyBpdGVtIGFzIGBjYW52YXNgLlxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE1MlxuXHRcdGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBpdGVtKSB7XG5cdFx0XHRpbml0Q2FudmFzKGl0ZW0sIGNvbmZpZyk7XG5cdFx0XHRyZXR1cm4gY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRyZWxlYXNlQ29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdHZhciBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcblx0XHRpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgaW5pdGlhbCA9IGNhbnZhc1tFWFBBTkRPX0tFWV0uaW5pdGlhbDtcblx0XHRbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuXHRcdFx0dmFyIHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcblx0XHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcblx0XHRcdFx0Y2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aGVscGVycyQxLmVhY2goaW5pdGlhbC5zdHlsZSB8fCB7fSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0Y2FudmFzLnN0eWxlW2tleV0gPSB2YWx1ZTtcblx0XHR9KTtcblxuXHRcdC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxuXHRcdC8vIHdlIGNhbid0IHVzZSBzYXZlKCkgYW5kIHJlc3RvcmUoKSB0byByZXN0b3JlIHRoZSBpbml0aWFsIHN0YXRlLiBTbyBtYWtlIHN1cmUgdGhhdCBhdFxuXHRcdC8vIGxlYXN0IHRoZSBjYW52YXMgY29udGV4dCBpcyByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBieSBzZXR0aW5nIHRoZSBjYW52YXMgd2lkdGguXG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cblx0XHRjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cblx0XHRkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcblx0fSxcblxuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdGlmICh0eXBlID09PSAncmVzaXplJykge1xuXHRcdFx0Ly8gTm90ZTogdGhlIHJlc2l6ZSBldmVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFsbCBicm93c2Vycy5cblx0XHRcdGFkZFJlc2l6ZUxpc3RlbmVyKGNhbnZhcywgbGlzdGVuZXIsIGNoYXJ0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZXhwYW5kbyA9IGxpc3RlbmVyW0VYUEFORE9fS0VZXSB8fCAobGlzdGVuZXJbRVhQQU5ET19LRVldID0ge30pO1xuXHRcdHZhciBwcm94aWVzID0gZXhwYW5kby5wcm94aWVzIHx8IChleHBhbmRvLnByb3hpZXMgPSB7fSk7XG5cdFx0dmFyIHByb3h5ID0gcHJveGllc1tjaGFydC5pZCArICdfJyArIHR5cGVdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGxpc3RlbmVyKGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpKTtcblx0XHR9O1xuXG5cdFx0YWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG5cdH0sXG5cblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblx0XHRpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcblx0XHRcdC8vIE5vdGU6IHRoZSByZXNpemUgZXZlbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBhbGwgYnJvd3NlcnMuXG5cdFx0XHRyZW1vdmVSZXNpemVMaXN0ZW5lcihjYW52YXMpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBleHBhbmRvID0gbGlzdGVuZXJbRVhQQU5ET19LRVldIHx8IHt9O1xuXHRcdHZhciBwcm94aWVzID0gZXhwYW5kby5wcm94aWVzIHx8IHt9O1xuXHRcdHZhciBwcm94eSA9IHByb3hpZXNbY2hhcnQuaWQgKyAnXycgKyB0eXBlXTtcblx0XHRpZiAoIXByb3h5KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmVtb3ZlTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG5cdH1cbn07XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLlxuICogRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhIDcsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5hZGRFdmVudFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycyQxLmFkZEV2ZW50ID0gYWRkTGlzdGVuZXI7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyIGluc3RlYWQuXG4gKiBFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyIGNvbXBhdGliaWxpdHk6IENocm9tZSwgT3BlcmEgNywgU2FmYXJpLCBGRjEuNSssIElFOStcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L3JlbW92ZUV2ZW50TGlzdGVuZXJcbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLnJlbW92ZUV2ZW50XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzJDEucmVtb3ZlRXZlbnQgPSByZW1vdmVMaXN0ZW5lcjtcblxuLy8gQFRPRE8gTWFrZSBwb3NzaWJsZSB0byBzZWxlY3QgYW5vdGhlciBwbGF0Zm9ybSBhdCBidWlsZCB0aW1lLlxudmFyIGltcGxlbWVudGF0aW9uID0gcGxhdGZvcm1fZG9tJDIuX2VuYWJsZWQgPyBwbGF0Zm9ybV9kb20kMiA6IHBsYXRmb3JtX2Jhc2ljO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQucGxhdGZvcm1cbiAqIEBzZWUgaHR0cHM6Ly9jaGFydGpzLmdpdGJvb2tzLmlvL3Byb3Bvc2Fscy9jb250ZW50L1BsYXRmb3JtLmh0bWxcbiAqIEBzaW5jZSAyLjQuMFxuICovXG52YXIgcGxhdGZvcm0gPSBoZWxwZXJzJDEuZXh0ZW5kKHtcblx0LyoqXG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGNvbnN0cnVjdGlvbiB0aW1lLCByZXR1cm5zIGEgY29udGV4dDJkIGluc3RhbmNlIGltcGxlbWVudGluZ1xuXHQgKiB0aGUgW1czQyBDYW52YXMgMkQgQ29udGV4dCBBUEkgc3RhbmRhcmRde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvfS5cblx0ICogQHBhcmFtIHsqfSBpdGVtIC0gVGhlIG5hdGl2ZSBpdGVtIGZyb20gd2hpY2ggdG8gYWNxdWlyZSBjb250ZXh0IChwbGF0Zm9ybSBzcGVjaWZpYylcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgY2hhcnQgb3B0aW9uc1xuXHQgKiBAcmV0dXJucyB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0MmQgaW5zdGFuY2Vcblx0ICovXG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgZGVzdHJ1Y3Rpb24gdGltZSwgcmVsZWFzZXMgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZXh0XG5cdCAqIHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgdGhlIGFjcXVpcmVDb250ZXh0KCkgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0MmQgaW5zdGFuY2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1ldGhvZCBzdWNjZWVkZWQsIGVsc2UgZmFsc2Vcblx0ICovXG5cdHJlbGVhc2VDb250ZXh0OiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBvbiB0aGUgZ2l2ZW4gY2hhcnQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byBsaXN0ZW4gZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgSUV2ZW50fSkgdHlwZSB0byBsaXN0ZW4gZm9yXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gUmVjZWl2ZXMgYSBub3RpZmljYXRpb24gKGFuIG9iamVjdCB0aGF0IGltcGxlbWVudHNcblx0ICogdGhlIHtAbGluayBJRXZlbnR9IGludGVyZmFjZSkgd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzLlxuXHQgKi9cblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFkZEV2ZW50TGlzdGVuZXIuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgSUV2ZW50fSkgdHlwZSB0byByZW1vdmVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cblx0ICovXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge31cblxufSwgaW1wbGVtZW50YXRpb24pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0cGx1Z2luczoge31cbn0pO1xuXG4vKipcbiAqIFRoZSBwbHVnaW4gc2VydmljZSBzaW5nbGV0b25cbiAqIEBuYW1lc3BhY2UgQ2hhcnQucGx1Z2luc1xuICogQHNpbmNlIDIuMS4wXG4gKi9cbnZhciBjb3JlX3BsdWdpbnMgPSB7XG5cdC8qKlxuXHQgKiBHbG9iYWxseSByZWdpc3RlcmVkIHBsdWdpbnMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcGx1Z2luczogW10sXG5cblx0LyoqXG5cdCAqIFRoaXMgaWRlbnRpZmllciBpcyB1c2VkIHRvIGludmFsaWRhdGUgdGhlIGRlc2NyaXB0b3JzIGNhY2hlIGF0dGFjaGVkIHRvIGVhY2ggY2hhcnRcblx0ICogd2hlbiBhIGdsb2JhbCBwbHVnaW4gaXMgcmVnaXN0ZXJlZCBvciB1bnJlZ2lzdGVyZWQuIEluIHRoaXMgY2FzZSwgdGhlIGNhY2hlIElEIGlzXG5cdCAqIGluY3JlbWVudGVkIGFuZCBkZXNjcmlwdG9ycyBhcmUgcmVnZW5lcmF0ZWQgZHVyaW5nIGZvbGxvd2luZyBBUEkgY2FsbHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY2FjaGVJZDogMCxcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBwbHVnaW4ocykgaWYgbm90IGFscmVhZHkgcmVnaXN0ZXJlZC5cblx0ICogQHBhcmFtIHtJUGx1Z2luW118SVBsdWdpbn0gcGx1Z2lucyBwbHVnaW4gaW5zdGFuY2UocykuXG5cdCAqL1xuXHRyZWdpc3RlcjogZnVuY3Rpb24ocGx1Z2lucykge1xuXHRcdHZhciBwID0gdGhpcy5fcGx1Z2lucztcblx0XHQoW10pLmNvbmNhdChwbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0aWYgKHAuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuXHRcdFx0XHRwLnB1c2gocGx1Z2luKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuX2NhY2hlSWQrKztcblx0fSxcblxuXHQvKipcblx0ICogVW5yZWdpc3RlcnMgdGhlIGdpdmVuIHBsdWdpbihzKSBvbmx5IGlmIHJlZ2lzdGVyZWQuXG5cdCAqIEBwYXJhbSB7SVBsdWdpbltdfElQbHVnaW59IHBsdWdpbnMgcGx1Z2luIGluc3RhbmNlKHMpLlxuXHQgKi9cblx0dW5yZWdpc3RlcjogZnVuY3Rpb24ocGx1Z2lucykge1xuXHRcdHZhciBwID0gdGhpcy5fcGx1Z2lucztcblx0XHQoW10pLmNvbmNhdChwbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0dmFyIGlkeCA9IHAuaW5kZXhPZihwbHVnaW4pO1xuXHRcdFx0aWYgKGlkeCAhPT0gLTEpIHtcblx0XHRcdFx0cC5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuX2NhY2hlSWQrKztcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCByZWdpc3RlcmVkIHBsdWdpbnMuXG5cdCAqIEBzaW5jZSAyLjEuNVxuXHQgKi9cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3BsdWdpbnMgPSBbXTtcblx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiByZWdpc3RlcmVkIHBsdWdpbnM/XG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqIEBzaW5jZSAyLjEuNVxuXHQgKi9cblx0Y291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wbHVnaW5zLmxlbmd0aDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBwbHVnaW4gaW5zdGFuY2VzLlxuXHQgKiBAcmV0dXJucyB7SVBsdWdpbltdfSBhcnJheSBvZiBwbHVnaW4gb2JqZWN0cy5cblx0ICogQHNpbmNlIDIuMS41XG5cdCAqL1xuXHRnZXRBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wbHVnaW5zO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgZm9yIGBjaGFydGAgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UgZm9yIHdoaWNoIHBsdWdpbnMgc2hvdWxkIGJlIGNhbGxlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtBcnJheX0gW2FyZ3NdIC0gRXh0cmEgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBob29rIGNhbGwuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBhbnkgb2YgdGhlIHBsdWdpbnMgcmV0dXJuIGZhbHNlLCBlbHNlIHJldHVybnMgdHJ1ZS5cblx0ICovXG5cdG5vdGlmeTogZnVuY3Rpb24oY2hhcnQsIGhvb2ssIGFyZ3MpIHtcblx0XHR2YXIgZGVzY3JpcHRvcnMgPSB0aGlzLmRlc2NyaXB0b3JzKGNoYXJ0KTtcblx0XHR2YXIgaWxlbiA9IGRlc2NyaXB0b3JzLmxlbmd0aDtcblx0XHR2YXIgaSwgZGVzY3JpcHRvciwgcGx1Z2luLCBwYXJhbXMsIG1ldGhvZDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yc1tpXTtcblx0XHRcdHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuXHRcdFx0bWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuXHRcdFx0aWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cGFyYW1zID0gW2NoYXJ0XS5jb25jYXQoYXJncyB8fCBbXSk7XG5cdFx0XHRcdHBhcmFtcy5wdXNoKGRlc2NyaXB0b3Iub3B0aW9ucyk7XG5cdFx0XHRcdGlmIChtZXRob2QuYXBwbHkocGx1Z2luLCBwYXJhbXMpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGRlc2NyaXB0b3JzIG9mIGVuYWJsZWQgcGx1Z2lucyBmb3IgdGhlIGdpdmVuIGNoYXJ0LlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0W119IFt7IHBsdWdpbiwgb3B0aW9ucyB9XVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZGVzY3JpcHRvcnM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIGNhY2hlID0gY2hhcnQuJHBsdWdpbnMgfHwgKGNoYXJ0LiRwbHVnaW5zID0ge30pO1xuXHRcdGlmIChjYWNoZS5pZCA9PT0gdGhpcy5fY2FjaGVJZCkge1xuXHRcdFx0cmV0dXJuIGNhY2hlLmRlc2NyaXB0b3JzO1xuXHRcdH1cblxuXHRcdHZhciBwbHVnaW5zID0gW107XG5cdFx0dmFyIGRlc2NyaXB0b3JzID0gW107XG5cdFx0dmFyIGNvbmZpZyA9IChjaGFydCAmJiBjaGFydC5jb25maWcpIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gKGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMpIHx8IHt9O1xuXG5cdFx0dGhpcy5fcGx1Z2lucy5jb25jYXQoY29uZmlnLnBsdWdpbnMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG5cdFx0XHR2YXIgaWR4ID0gcGx1Z2lucy5pbmRleE9mKHBsdWdpbik7XG5cdFx0XHRpZiAoaWR4ICE9PSAtMSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpZCA9IHBsdWdpbi5pZDtcblx0XHRcdHZhciBvcHRzID0gb3B0aW9uc1tpZF07XG5cdFx0XHRpZiAob3B0cyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0cyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRvcHRzID0gaGVscGVycyQxLmNsb25lKGNvcmVfZGVmYXVsdHMuZ2xvYmFsLnBsdWdpbnNbaWRdKTtcblx0XHRcdH1cblxuXHRcdFx0cGx1Z2lucy5wdXNoKHBsdWdpbik7XG5cdFx0XHRkZXNjcmlwdG9ycy5wdXNoKHtcblx0XHRcdFx0cGx1Z2luOiBwbHVnaW4sXG5cdFx0XHRcdG9wdGlvbnM6IG9wdHMgfHwge31cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Y2FjaGUuZGVzY3JpcHRvcnMgPSBkZXNjcmlwdG9ycztcblx0XHRjYWNoZS5pZCA9IHRoaXMuX2NhY2hlSWQ7XG5cdFx0cmV0dXJuIGRlc2NyaXB0b3JzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbnZhbGlkYXRlcyBjYWNoZSBmb3IgdGhlIGdpdmVuIGNoYXJ0OiBkZXNjcmlwdG9ycyBob2xkIGEgcmVmZXJlbmNlIG9uIHBsdWdpbiBvcHRpb24sXG5cdCAqIGJ1dCBpbiBzb21lIGNhc2VzLCB0aGlzIHJlZmVyZW5jZSBjYW4gYmUgY2hhbmdlZCBieSB0aGUgdXNlciB3aGVuIHVwZGF0aW5nIG9wdGlvbnMuXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9pbnZhbGlkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdGRlbGV0ZSBjaGFydC4kcGx1Z2lucztcblx0fVxufTtcblxudmFyIGNvcmVfc2NhbGVTZXJ2aWNlID0ge1xuXHQvLyBTY2FsZSByZWdpc3RyYXRpb24gb2JqZWN0LiBFeHRlbnNpb25zIGNhbiByZWdpc3RlciBuZXcgc2NhbGUgdHlwZXMgKHN1Y2ggYXMgbG9nIG9yIERCIHNjYWxlcykgYW5kIHRoZW5cblx0Ly8gdXNlIHRoZSBuZXcgY2hhcnQgb3B0aW9ucyB0byBncmFiIHRoZSBjb3JyZWN0IHNjYWxlXG5cdGNvbnN0cnVjdG9yczoge30sXG5cdC8vIFVzZSBhIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBzbyB0aGF0IHdlIGNhbiBtb3ZlIHRvIGFuIEVTNiBtYXAgd2hlbiB3ZSBubyBsb25nZXIgbmVlZCB0byBzdXBwb3J0XG5cdC8vIG9sZCBicm93c2Vyc1xuXG5cdC8vIFNjYWxlIGNvbmZpZyBkZWZhdWx0c1xuXHRkZWZhdWx0czoge30sXG5cdHJlZ2lzdGVyU2NhbGVUeXBlOiBmdW5jdGlvbih0eXBlLCBzY2FsZUNvbnN0cnVjdG9yLCBzY2FsZURlZmF1bHRzKSB7XG5cdFx0dGhpcy5jb25zdHJ1Y3RvcnNbdHlwZV0gPSBzY2FsZUNvbnN0cnVjdG9yO1xuXHRcdHRoaXMuZGVmYXVsdHNbdHlwZV0gPSBoZWxwZXJzJDEuY2xvbmUoc2NhbGVEZWZhdWx0cyk7XG5cdH0sXG5cdGdldFNjYWxlQ29uc3RydWN0b3I6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcnMuaGFzT3duUHJvcGVydHkodHlwZSkgPyB0aGlzLmNvbnN0cnVjdG9yc1t0eXBlXSA6IHVuZGVmaW5lZDtcblx0fSxcblx0Z2V0U2NhbGVEZWZhdWx0czogZnVuY3Rpb24odHlwZSkge1xuXHRcdC8vIFJldHVybiB0aGUgc2NhbGUgZGVmYXVsdHMgbWVyZ2VkIHdpdGggdGhlIGdsb2JhbCBzZXR0aW5ncyBzbyB0aGF0IHdlIGFsd2F5cyB1c2UgdGhlIGxhdGVzdCBvbmVzXG5cdFx0cmV0dXJuIHRoaXMuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkodHlwZSkgPyBoZWxwZXJzJDEubWVyZ2Uoe30sIFtjb3JlX2RlZmF1bHRzLnNjYWxlLCB0aGlzLmRlZmF1bHRzW3R5cGVdXSkgOiB7fTtcblx0fSxcblx0dXBkYXRlU2NhbGVEZWZhdWx0czogZnVuY3Rpb24odHlwZSwgYWRkaXRpb25zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAobWUuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcblx0XHRcdG1lLmRlZmF1bHRzW3R5cGVdID0gaGVscGVycyQxLmV4dGVuZChtZS5kZWZhdWx0c1t0eXBlXSwgYWRkaXRpb25zKTtcblx0XHR9XG5cdH0sXG5cdGFkZFNjYWxlc1RvTGF5b3V0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdC8vIEFkZHMgZWFjaCBzY2FsZSB0byB0aGUgY2hhcnQuYm94ZXMgYXJyYXkgdG8gYmUgc2l6ZWQgYWNjb3JkaW5nbHlcblx0XHRoZWxwZXJzJDEuZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG5cdFx0XHQvLyBTZXQgSUxheW91dEl0ZW0gcGFyYW1ldGVycyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdHNjYWxlLmZ1bGxXaWR0aCA9IHNjYWxlLm9wdGlvbnMuZnVsbFdpZHRoO1xuXHRcdFx0c2NhbGUucG9zaXRpb24gPSBzY2FsZS5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdFx0c2NhbGUud2VpZ2h0ID0gc2NhbGUub3B0aW9ucy53ZWlnaHQ7XG5cdFx0XHRjb3JlX2xheW91dHMuYWRkQm94KGNoYXJ0LCBzY2FsZSk7XG5cdFx0fSk7XG5cdH1cbn07XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ3ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0dG9vbHRpcHM6IHtcblx0XHRlbmFibGVkOiB0cnVlLFxuXHRcdGN1c3RvbTogbnVsbCxcblx0XHRtb2RlOiAnbmVhcmVzdCcsXG5cdFx0cG9zaXRpb246ICdhdmVyYWdlJyxcblx0XHRpbnRlcnNlY3Q6IHRydWUsXG5cdFx0YmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcblx0XHR0aXRsZUZvbnRTdHlsZTogJ2JvbGQnLFxuXHRcdHRpdGxlU3BhY2luZzogMixcblx0XHR0aXRsZU1hcmdpbkJvdHRvbTogNixcblx0XHR0aXRsZUZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdHRpdGxlQWxpZ246ICdsZWZ0Jyxcblx0XHRib2R5U3BhY2luZzogMixcblx0XHRib2R5Rm9udENvbG9yOiAnI2ZmZicsXG5cdFx0Ym9keUFsaWduOiAnbGVmdCcsXG5cdFx0Zm9vdGVyRm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0Zm9vdGVyU3BhY2luZzogMixcblx0XHRmb290ZXJNYXJnaW5Ub3A6IDYsXG5cdFx0Zm9vdGVyRm9udENvbG9yOiAnI2ZmZicsXG5cdFx0Zm9vdGVyQWxpZ246ICdsZWZ0Jyxcblx0XHR5UGFkZGluZzogNixcblx0XHR4UGFkZGluZzogNixcblx0XHRjYXJldFBhZGRpbmc6IDIsXG5cdFx0Y2FyZXRTaXplOiA1LFxuXHRcdGNvcm5lclJhZGl1czogNixcblx0XHRtdWx0aUtleUJhY2tncm91bmQ6ICcjZmZmJyxcblx0XHRkaXNwbGF5Q29sb3JzOiB0cnVlLFxuXHRcdGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG5cdFx0Ym9yZGVyV2lkdGg6IDAsXG5cdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGJlZm9yZVRpdGxlOiBoZWxwZXJzJDEubm9vcCxcblx0XHRcdHRpdGxlOiBmdW5jdGlvbih0b29sdGlwSXRlbXMsIGRhdGEpIHtcblx0XHRcdFx0dmFyIHRpdGxlID0gJyc7XG5cdFx0XHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcblx0XHRcdFx0dmFyIGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcblxuXHRcdFx0XHRpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcblx0XHRcdFx0XHRpZiAoaXRlbS5sYWJlbCkge1xuXHRcdFx0XHRcdFx0dGl0bGUgPSBpdGVtLmxhYmVsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaXRlbS54TGFiZWwpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS54TGFiZWw7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmluZGV4IDwgbGFiZWxDb3VudCkge1xuXHRcdFx0XHRcdFx0dGl0bGUgPSBsYWJlbHNbaXRlbS5pbmRleF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRpdGxlO1xuXHRcdFx0fSxcblx0XHRcdGFmdGVyVGl0bGU6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGJlZm9yZUJvZHk6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRcdFx0YmVmb3JlTGFiZWw6IGhlbHBlcnMkMS5ub29wLFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBsYWJlbCA9IGRhdGEuZGF0YXNldHNbdG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJztcblxuXHRcdFx0XHRpZiAobGFiZWwpIHtcblx0XHRcdFx0XHRsYWJlbCArPSAnOiAnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodG9vbHRpcEl0ZW0udmFsdWUpKSB7XG5cdFx0XHRcdFx0bGFiZWwgKz0gdG9vbHRpcEl0ZW0udmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGFiZWwgKz0gdG9vbHRpcEl0ZW0ueUxhYmVsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBsYWJlbDtcblx0XHRcdH0sXG5cdFx0XHRsYWJlbENvbG9yOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgY2hhcnQpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIgYWN0aXZlRWxlbWVudCA9IG1ldGEuZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XG5cdFx0XHRcdHZhciB2aWV3ID0gYWN0aXZlRWxlbWVudC5fdmlldztcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRib3JkZXJDb2xvcjogdmlldy5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IHZpZXcuYmFja2dyb3VuZENvbG9yXG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWxUZXh0Q29sb3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fb3B0aW9ucy5ib2R5Rm9udENvbG9yO1xuXHRcdFx0fSxcblx0XHRcdGFmdGVyTGFiZWw6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGFmdGVyQm9keTogaGVscGVycyQxLm5vb3AsXG5cblx0XHRcdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuXHRcdFx0YmVmb3JlRm9vdGVyOiBoZWxwZXJzJDEubm9vcCxcblx0XHRcdGZvb3RlcjogaGVscGVycyQxLm5vb3AsXG5cdFx0XHRhZnRlckZvb3RlcjogaGVscGVycyQxLm5vb3Bcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgcG9zaXRpb25lcnMgPSB7XG5cdC8qKlxuXHQgKiBBdmVyYWdlIG1vZGUgcGxhY2VzIHRoZSB0b29sdGlwIGF0IHRoZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50cyBzaG93blxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVycy5hdmVyYWdlXG5cdCAqIEBwYXJhbSBlbGVtZW50cyB7Q2hhcnRFbGVtZW50W119IHRoZSBlbGVtZW50cyBiZWluZyBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXBcblx0ICogQHJldHVybnMge29iamVjdH0gdG9vbHRpcCBwb3NpdGlvblxuXHQgKi9cblx0YXZlcmFnZTogZnVuY3Rpb24oZWxlbWVudHMpIHtcblx0XHRpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBpLCBsZW47XG5cdFx0dmFyIHggPSAwO1xuXHRcdHZhciB5ID0gMDtcblx0XHR2YXIgY291bnQgPSAwO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdHZhciBlbCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcblx0XHRcdFx0dmFyIHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuXHRcdFx0XHR4ICs9IHBvcy54O1xuXHRcdFx0XHR5ICs9IHBvcy55O1xuXHRcdFx0XHQrK2NvdW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4IC8gY291bnQsXG5cdFx0XHR5OiB5IC8gY291bnRcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0b29sdGlwIHBvc2l0aW9uIG5lYXJlc3Qgb2YgdGhlIGl0ZW0gbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb25cblx0ICogQGZ1bmN0aW9uIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMubmVhcmVzdFxuXHQgKiBAcGFyYW0gZWxlbWVudHMge0NoYXJ0LkVsZW1lbnRbXX0gdGhlIHRvb2x0aXAgZWxlbWVudHNcblx0ICogQHBhcmFtIGV2ZW50UG9zaXRpb24ge29iamVjdH0gdGhlIHBvc2l0aW9uIG9mIHRoZSBldmVudCBpbiBjYW52YXMgY29vcmRpbmF0ZXNcblx0ICogQHJldHVybnMge29iamVjdH0gdGhlIHRvb2x0aXAgcG9zaXRpb25cblx0ICovXG5cdG5lYXJlc3Q6IGZ1bmN0aW9uKGVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG5cdFx0dmFyIHggPSBldmVudFBvc2l0aW9uLng7XG5cdFx0dmFyIHkgPSBldmVudFBvc2l0aW9uLnk7XG5cdFx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdHZhciBpLCBsZW4sIG5lYXJlc3RFbGVtZW50O1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcblx0XHRcdHZhciBlbCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcblx0XHRcdFx0dmFyIGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG5cdFx0XHRcdHZhciBkID0gaGVscGVycyQxLmRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuXG5cdFx0XHRcdGlmIChkIDwgbWluRGlzdGFuY2UpIHtcblx0XHRcdFx0XHRtaW5EaXN0YW5jZSA9IGQ7XG5cdFx0XHRcdFx0bmVhcmVzdEVsZW1lbnQgPSBlbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChuZWFyZXN0RWxlbWVudCkge1xuXHRcdFx0dmFyIHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG5cdFx0XHR4ID0gdHAueDtcblx0XHRcdHkgPSB0cC55O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeVxuXHRcdH07XG5cdH1cbn07XG5cbi8vIEhlbHBlciB0byBwdXNoIG9yIGNvbmNhdCBiYXNlZCBvbiBpZiB0aGUgMm5kIHBhcmFtZXRlciBpcyBhbiBhcnJheSBvciBub3RcbmZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcblx0aWYgKHRvUHVzaCkge1xuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0b1B1c2gpKSB7XG5cdFx0XHQvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJhc2UucHVzaCh0b1B1c2gpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBiYXNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2Ygc3RyaW5ncyBzcGxpdCBieSBuZXdsaW5lXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3BsaXQgYnkgbmV3bGluZS5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gdmFsdWUgaWYgbmV3bGluZSBwcmVzZW50IC0gUmV0dXJuZWQgZnJvbSBTdHJpbmcgc3BsaXQoKSBtZXRob2RcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuXHRpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcblx0XHRyZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcblx0fVxuXHRyZXR1cm4gc3RyO1xufVxuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdG8gY3JlYXRlIGEgdG9vbHRpcCBpdGVtIG1vZGVsXG4gKiBAcGFyYW0gZWxlbWVudCAtIHRoZSBjaGFydCBlbGVtZW50IChwb2ludCwgYXJjLCBiYXIpIHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBpdGVtIGZvclxuICogQHJldHVybiBuZXcgdG9vbHRpcCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGVsZW1lbnQpIHtcblx0dmFyIHhTY2FsZSA9IGVsZW1lbnQuX3hTY2FsZTtcblx0dmFyIHlTY2FsZSA9IGVsZW1lbnQuX3lTY2FsZSB8fCBlbGVtZW50Ll9zY2FsZTsgLy8gaGFuZGxlIHJhZGFyIHx8IHBvbGFyQXJlYSBjaGFydHNcblx0dmFyIGluZGV4ID0gZWxlbWVudC5faW5kZXg7XG5cdHZhciBkYXRhc2V0SW5kZXggPSBlbGVtZW50Ll9kYXRhc2V0SW5kZXg7XG5cdHZhciBjb250cm9sbGVyID0gZWxlbWVudC5fY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuXHR2YXIgaW5kZXhTY2FsZSA9IGNvbnRyb2xsZXIuX2dldEluZGV4U2NhbGUoKTtcblx0dmFyIHZhbHVlU2NhbGUgPSBjb250cm9sbGVyLl9nZXRWYWx1ZVNjYWxlKCk7XG5cblx0cmV0dXJuIHtcblx0XHR4TGFiZWw6IHhTY2FsZSA/IHhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0eUxhYmVsOiB5U2NhbGUgPyB5U2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdGxhYmVsOiBpbmRleFNjYWxlID8gJycgKyBpbmRleFNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcblx0XHR2YWx1ZTogdmFsdWVTY2FsZSA/ICcnICsgdmFsdWVTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0aW5kZXg6IGluZGV4LFxuXHRcdGRhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LFxuXHRcdHg6IGVsZW1lbnQuX21vZGVsLngsXG5cdFx0eTogZWxlbWVudC5fbW9kZWwueVxuXHR9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIHJlc2V0IG1vZGVsIGZvciB0aGUgdG9vbHRpcFxuICogQHBhcmFtIHRvb2x0aXBPcHRzIHtvYmplY3R9IHRoZSB0b29sdGlwIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0QmFzZU1vZGVsKHRvb2x0aXBPcHRzKSB7XG5cdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXG5cdHJldHVybiB7XG5cdFx0Ly8gUG9zaXRpb25pbmdcblx0XHR4UGFkZGluZzogdG9vbHRpcE9wdHMueFBhZGRpbmcsXG5cdFx0eVBhZGRpbmc6IHRvb2x0aXBPcHRzLnlQYWRkaW5nLFxuXHRcdHhBbGlnbjogdG9vbHRpcE9wdHMueEFsaWduLFxuXHRcdHlBbGlnbjogdG9vbHRpcE9wdHMueUFsaWduLFxuXG5cdFx0Ly8gQm9keVxuXHRcdGJvZHlGb250Q29sb3I6IHRvb2x0aXBPcHRzLmJvZHlGb250Q29sb3IsXG5cdFx0X2JvZHlGb250RmFtaWx5OiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLmJvZHlGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0X2JvZHlGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuYm9keUZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXG5cdFx0X2JvZHlBbGlnbjogdG9vbHRpcE9wdHMuYm9keUFsaWduLFxuXHRcdGJvZHlGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5ib2R5Rm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0Ym9keVNwYWNpbmc6IHRvb2x0aXBPcHRzLmJvZHlTcGFjaW5nLFxuXG5cdFx0Ly8gVGl0bGVcblx0XHR0aXRsZUZvbnRDb2xvcjogdG9vbHRpcE9wdHMudGl0bGVGb250Q29sb3IsXG5cdFx0X3RpdGxlRm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy50aXRsZUZvbnRGYW1pbHksIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250RmFtaWx5KSxcblx0XHRfdGl0bGVGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMudGl0bGVGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdHRpdGxlRm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMudGl0bGVGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRfdGl0bGVBbGlnbjogdG9vbHRpcE9wdHMudGl0bGVBbGlnbixcblx0XHR0aXRsZVNwYWNpbmc6IHRvb2x0aXBPcHRzLnRpdGxlU3BhY2luZyxcblx0XHR0aXRsZU1hcmdpbkJvdHRvbTogdG9vbHRpcE9wdHMudGl0bGVNYXJnaW5Cb3R0b20sXG5cblx0XHQvLyBGb290ZXJcblx0XHRmb290ZXJGb250Q29sb3I6IHRvb2x0aXBPcHRzLmZvb3RlckZvbnRDb2xvcixcblx0XHRfZm9vdGVyRm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5mb290ZXJGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0X2Zvb3RlckZvbnRTdHlsZTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5mb290ZXJGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdGZvb3RlckZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLmZvb3RlckZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpLFxuXHRcdF9mb290ZXJBbGlnbjogdG9vbHRpcE9wdHMuZm9vdGVyQWxpZ24sXG5cdFx0Zm9vdGVyU3BhY2luZzogdG9vbHRpcE9wdHMuZm9vdGVyU3BhY2luZyxcblx0XHRmb290ZXJNYXJnaW5Ub3A6IHRvb2x0aXBPcHRzLmZvb3Rlck1hcmdpblRvcCxcblxuXHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRjYXJldFNpemU6IHRvb2x0aXBPcHRzLmNhcmV0U2l6ZSxcblx0XHRjb3JuZXJSYWRpdXM6IHRvb2x0aXBPcHRzLmNvcm5lclJhZGl1cyxcblx0XHRiYWNrZ3JvdW5kQ29sb3I6IHRvb2x0aXBPcHRzLmJhY2tncm91bmRDb2xvcixcblx0XHRvcGFjaXR5OiAwLFxuXHRcdGxlZ2VuZENvbG9yQmFja2dyb3VuZDogdG9vbHRpcE9wdHMubXVsdGlLZXlCYWNrZ3JvdW5kLFxuXHRcdGRpc3BsYXlDb2xvcnM6IHRvb2x0aXBPcHRzLmRpc3BsYXlDb2xvcnMsXG5cdFx0Ym9yZGVyQ29sb3I6IHRvb2x0aXBPcHRzLmJvcmRlckNvbG9yLFxuXHRcdGJvcmRlcldpZHRoOiB0b29sdGlwT3B0cy5ib3JkZXJXaWR0aFxuXHR9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdG9vbHRpcFxuICovXG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBtb2RlbCkge1xuXHR2YXIgY3R4ID0gdG9vbHRpcC5fY2hhcnQuY3R4O1xuXG5cdHZhciBoZWlnaHQgPSBtb2RlbC55UGFkZGluZyAqIDI7IC8vIFRvb2x0aXAgUGFkZGluZ1xuXHR2YXIgd2lkdGggPSAwO1xuXG5cdC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxuXHR2YXIgYm9keSA9IG1vZGVsLmJvZHk7XG5cdHZhciBjb21iaW5lZEJvZHlMZW5ndGggPSBib2R5LnJlZHVjZShmdW5jdGlvbihjb3VudCwgYm9keUl0ZW0pIHtcblx0XHRyZXR1cm4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoO1xuXHR9LCAwKTtcblx0Y29tYmluZWRCb2R5TGVuZ3RoICs9IG1vZGVsLmJlZm9yZUJvZHkubGVuZ3RoICsgbW9kZWwuYWZ0ZXJCb2R5Lmxlbmd0aDtcblxuXHR2YXIgdGl0bGVMaW5lQ291bnQgPSBtb2RlbC50aXRsZS5sZW5ndGg7XG5cdHZhciBmb290ZXJMaW5lQ291bnQgPSBtb2RlbC5mb290ZXIubGVuZ3RoO1xuXHR2YXIgdGl0bGVGb250U2l6ZSA9IG1vZGVsLnRpdGxlRm9udFNpemU7XG5cdHZhciBib2R5Rm9udFNpemUgPSBtb2RlbC5ib2R5Rm9udFNpemU7XG5cdHZhciBmb290ZXJGb250U2l6ZSA9IG1vZGVsLmZvb3RlckZvbnRTaXplO1xuXG5cdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udFNpemU7IC8vIFRpdGxlIExpbmVzXG5cdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCA/ICh0aXRsZUxpbmVDb3VudCAtIDEpICogbW9kZWwudGl0bGVTcGFjaW5nIDogMDsgLy8gVGl0bGUgTGluZSBTcGFjaW5nXG5cdGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCA/IG1vZGVsLnRpdGxlTWFyZ2luQm90dG9tIDogMDsgLy8gVGl0bGUncyBib3R0b20gTWFyZ2luXG5cdGhlaWdodCArPSBjb21iaW5lZEJvZHlMZW5ndGggKiBib2R5Rm9udFNpemU7IC8vIEJvZHkgTGluZXNcblx0aGVpZ2h0ICs9IGNvbWJpbmVkQm9keUxlbmd0aCA/IChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG1vZGVsLmJvZHlTcGFjaW5nIDogMDsgLy8gQm9keSBMaW5lIFNwYWNpbmdcblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IG1vZGVsLmZvb3Rlck1hcmdpblRvcCA6IDA7IC8vIEZvb3RlciBNYXJnaW5cblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCAqIChmb290ZXJGb250U2l6ZSk7IC8vIEZvb3RlciBMaW5lc1xuXHRoZWlnaHQgKz0gZm9vdGVyTGluZUNvdW50ID8gKGZvb3RlckxpbmVDb3VudCAtIDEpICogbW9kZWwuZm9vdGVyU3BhY2luZyA6IDA7IC8vIEZvb3RlciBMaW5lIFNwYWNpbmdcblxuXHQvLyBUaXRsZSB3aWR0aFxuXHR2YXIgd2lkdGhQYWRkaW5nID0gMDtcblx0dmFyIG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHR3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuXHR9O1xuXG5cdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcodGl0bGVGb250U2l6ZSwgbW9kZWwuX3RpdGxlRm9udFN0eWxlLCBtb2RlbC5fdGl0bGVGb250RmFtaWx5KTtcblx0aGVscGVycyQxLmVhY2gobW9kZWwudGl0bGUsIG1heExpbmVXaWR0aCk7XG5cblx0Ly8gQm9keSB3aWR0aFxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGJvZHlGb250U2l6ZSwgbW9kZWwuX2JvZHlGb250U3R5bGUsIG1vZGVsLl9ib2R5Rm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLmJlZm9yZUJvZHkuY29uY2F0KG1vZGVsLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG5cblx0Ly8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIHdpZHRoIGR1ZSB0byB0aGUgY29sb3IgYm94XG5cdHdpZHRoUGFkZGluZyA9IG1vZGVsLmRpc3BsYXlDb2xvcnMgPyAoYm9keUZvbnRTaXplICsgMikgOiAwO1xuXHRoZWxwZXJzJDEuZWFjaChib2R5LCBmdW5jdGlvbihib2R5SXRlbSkge1xuXHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcblx0fSk7XG5cblx0Ly8gUmVzZXQgYmFjayB0byAwXG5cdHdpZHRoUGFkZGluZyA9IDA7XG5cblx0Ly8gRm9vdGVyIHdpZHRoXG5cdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcoZm9vdGVyRm9udFNpemUsIG1vZGVsLl9mb290ZXJGb250U3R5bGUsIG1vZGVsLl9mb290ZXJGb250RmFtaWx5KTtcblx0aGVscGVycyQxLmVhY2gobW9kZWwuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEFkZCBwYWRkaW5nXG5cdHdpZHRoICs9IDIgKiBtb2RlbC54UGFkZGluZztcblxuXHRyZXR1cm4ge1xuXHRcdHdpZHRoOiB3aWR0aCxcblx0XHRoZWlnaHQ6IGhlaWdodFxuXHR9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGFsaWdubWVudCBvZiBhIHRvb2x0aXAgZ2l2ZW4gdGhlIHNpemVcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KHRvb2x0aXAsIHNpemUpIHtcblx0dmFyIG1vZGVsID0gdG9vbHRpcC5fbW9kZWw7XG5cdHZhciBjaGFydCA9IHRvb2x0aXAuX2NoYXJ0O1xuXHR2YXIgY2hhcnRBcmVhID0gdG9vbHRpcC5fY2hhcnQuY2hhcnRBcmVhO1xuXHR2YXIgeEFsaWduID0gJ2NlbnRlcic7XG5cdHZhciB5QWxpZ24gPSAnY2VudGVyJztcblxuXHRpZiAobW9kZWwueSA8IHNpemUuaGVpZ2h0KSB7XG5cdFx0eUFsaWduID0gJ3RvcCc7XG5cdH0gZWxzZSBpZiAobW9kZWwueSA+IChjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodCkpIHtcblx0XHR5QWxpZ24gPSAnYm90dG9tJztcblx0fVxuXG5cdHZhciBsZiwgcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgbGVmdCwgcmlnaHQgYWxpZ25tZW50XG5cdHZhciBvbGYsIG9yZjsgLy8gZnVuY3Rpb25zIHRvIGRldGVybWluZSBpZiBsZWZ0L3JpZ2h0IGFsaWdubWVudCBjYXVzZXMgdG9vbHRpcCB0byBnbyBvdXRzaWRlIGNoYXJ0XG5cdHZhciB5ZjsgLy8gZnVuY3Rpb24gdG8gZ2V0IHRoZSB5IGFsaWdubWVudCBpZiB0aGUgdG9vbHRpcCBnb2VzIG91dHNpZGUgb2YgdGhlIGxlZnQgb3IgcmlnaHQgZWRnZXNcblx0dmFyIG1pZFggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcblx0dmFyIG1pZFkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcblxuXHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuXHRcdGxmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPD0gbWlkWDtcblx0XHR9O1xuXHRcdHJmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPiBtaWRYO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0bGYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4geCA8PSAoc2l6ZS53aWR0aCAvIDIpO1xuXHRcdH07XG5cdFx0cmYgPSBmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4geCA+PSAoY2hhcnQud2lkdGggLSAoc2l6ZS53aWR0aCAvIDIpKTtcblx0XHR9O1xuXHR9XG5cblx0b2xmID0gZnVuY3Rpb24oeCkge1xuXHRcdHJldHVybiB4ICsgc2l6ZS53aWR0aCArIG1vZGVsLmNhcmV0U2l6ZSArIG1vZGVsLmNhcmV0UGFkZGluZyA+IGNoYXJ0LndpZHRoO1xuXHR9O1xuXHRvcmYgPSBmdW5jdGlvbih4KSB7XG5cdFx0cmV0dXJuIHggLSBzaXplLndpZHRoIC0gbW9kZWwuY2FyZXRTaXplIC0gbW9kZWwuY2FyZXRQYWRkaW5nIDwgMDtcblx0fTtcblx0eWYgPSBmdW5jdGlvbih5KSB7XG5cdFx0cmV0dXJuIHkgPD0gbWlkWSA/ICd0b3AnIDogJ2JvdHRvbSc7XG5cdH07XG5cblx0aWYgKGxmKG1vZGVsLngpKSB7XG5cdFx0eEFsaWduID0gJ2xlZnQnO1xuXG5cdFx0Ly8gSXMgdG9vbHRpcCB0b28gd2lkZSBhbmQgZ29lcyBvdmVyIHRoZSByaWdodCBzaWRlIG9mIHRoZSBjaGFydC4/XG5cdFx0aWYgKG9sZihtb2RlbC54KSkge1xuXHRcdFx0eEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHR5QWxpZ24gPSB5Zihtb2RlbC55KTtcblx0XHR9XG5cdH0gZWxzZSBpZiAocmYobW9kZWwueCkpIHtcblx0XHR4QWxpZ24gPSAncmlnaHQnO1xuXG5cdFx0Ly8gSXMgdG9vbHRpcCB0b28gd2lkZSBhbmQgZ29lcyBvdXRzaWRlIGxlZnQgZWRnZSBvZiBjYW52YXM/XG5cdFx0aWYgKG9yZihtb2RlbC54KSkge1xuXHRcdFx0eEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHR5QWxpZ24gPSB5Zihtb2RlbC55KTtcblx0XHR9XG5cdH1cblxuXHR2YXIgb3B0cyA9IHRvb2x0aXAuX29wdGlvbnM7XG5cdHJldHVybiB7XG5cdFx0eEFsaWduOiBvcHRzLnhBbGlnbiA/IG9wdHMueEFsaWduIDogeEFsaWduLFxuXHRcdHlBbGlnbjogb3B0cy55QWxpZ24gPyBvcHRzLnlBbGlnbiA6IHlBbGlnblxuXHR9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGxvY2F0aW9uIGEgdG9vbHRpcCBuZWVkcyB0byBiZSBwbGFjZWQgYXQgZ2l2ZW4gdGhlIGluaXRpYWwgcG9zaXRpb24gKHZpYSB0aGUgdm0pIGFuZCB0aGUgc2l6ZSBhbmQgYWxpZ25tZW50XG4gKi9cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludCh2bSwgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuXHQvLyBCYWNrZ3JvdW5kIFBvc2l0aW9uXG5cdHZhciB4ID0gdm0ueDtcblx0dmFyIHkgPSB2bS55O1xuXG5cdHZhciBjYXJldFNpemUgPSB2bS5jYXJldFNpemU7XG5cdHZhciBjYXJldFBhZGRpbmcgPSB2bS5jYXJldFBhZGRpbmc7XG5cdHZhciBjb3JuZXJSYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XG5cdHZhciB4QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuXHR2YXIgeUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcblx0dmFyIHBhZGRpbmdBbmRTaXplID0gY2FyZXRTaXplICsgY2FyZXRQYWRkaW5nO1xuXHR2YXIgcmFkaXVzQW5kUGFkZGluZyA9IGNvcm5lclJhZGl1cyArIGNhcmV0UGFkZGluZztcblxuXHRpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0eCAtPSBzaXplLndpZHRoO1xuXHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHR4IC09IChzaXplLndpZHRoIC8gMik7XG5cdFx0aWYgKHggKyBzaXplLndpZHRoID4gY2hhcnQud2lkdGgpIHtcblx0XHRcdHggPSBjaGFydC53aWR0aCAtIHNpemUud2lkdGg7XG5cdFx0fVxuXHRcdGlmICh4IDwgMCkge1xuXHRcdFx0eCA9IDA7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHR5ICs9IHBhZGRpbmdBbmRTaXplO1xuXHR9IGVsc2UgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcblx0XHR5IC09IHNpemUuaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG5cdH0gZWxzZSB7XG5cdFx0eSAtPSAoc2l6ZS5oZWlnaHQgLyAyKTtcblx0fVxuXG5cdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHR4ICs9IHBhZGRpbmdBbmRTaXplO1xuXHRcdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0XHR4IC09IHBhZGRpbmdBbmRTaXplO1xuXHRcdH1cblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdHggLT0gcmFkaXVzQW5kUGFkZGluZztcblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHR4ICs9IHJhZGl1c0FuZFBhZGRpbmc7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHg6IHgsXG5cdFx0eTogeVxuXHR9O1xufVxuXG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh2bSwgYWxpZ24pIHtcblx0cmV0dXJuIGFsaWduID09PSAnY2VudGVyJ1xuXHRcdD8gdm0ueCArIHZtLndpZHRoIC8gMlxuXHRcdDogYWxpZ24gPT09ICdyaWdodCdcblx0XHRcdD8gdm0ueCArIHZtLndpZHRoIC0gdm0ueFBhZGRpbmdcblx0XHRcdDogdm0ueCArIHZtLnhQYWRkaW5nO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBidWlsZCBiZWZvcmUgYW5kIGFmdGVyIGJvZHkgbGluZXNcbiAqL1xuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcblx0cmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuXG52YXIgZXhwb3J0cyQzID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX21vZGVsID0gZ2V0QmFzZU1vZGVsKHRoaXMuX29wdGlvbnMpO1xuXHRcdHRoaXMuX2xhc3RBY3RpdmUgPSBbXTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIHRpdGxlXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdGdldFRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUuX29wdGlvbnM7XG5cdFx0dmFyIGNhbGxiYWNrcyA9IG9wdHMuY2FsbGJhY2tzO1xuXG5cdFx0dmFyIGJlZm9yZVRpdGxlID0gY2FsbGJhY2tzLmJlZm9yZVRpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdHZhciB0aXRsZSA9IGNhbGxiYWNrcy50aXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgYWZ0ZXJUaXRsZSA9IGNhbGxiYWNrcy5hZnRlclRpdGxlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0dmFyIGxpbmVzID0gW107XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlVGl0bGUpKTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyh0aXRsZSkpO1xuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyVGl0bGUpKTtcblxuXHRcdHJldHVybiBsaW5lcztcblx0fSxcblxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRCZWZvcmVCb2R5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXModGhpcy5fb3B0aW9ucy5jYWxsYmFja3MuYmVmb3JlQm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0fSxcblxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRCb2R5OiBmdW5jdGlvbih0b29sdGlwSXRlbXMsIGRhdGEpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjYWxsYmFja3MgPSBtZS5fb3B0aW9ucy5jYWxsYmFja3M7XG5cdFx0dmFyIGJvZHlJdGVtcyA9IFtdO1xuXG5cdFx0aGVscGVycyQxLmVhY2godG9vbHRpcEl0ZW1zLCBmdW5jdGlvbih0b29sdGlwSXRlbSkge1xuXHRcdFx0dmFyIGJvZHlJdGVtID0ge1xuXHRcdFx0XHRiZWZvcmU6IFtdLFxuXHRcdFx0XHRsaW5lczogW10sXG5cdFx0XHRcdGFmdGVyOiBbXVxuXHRcdFx0fTtcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIHNwbGl0TmV3bGluZXMoY2FsbGJhY2tzLmJlZm9yZUxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSkpO1xuXHRcdFx0cHVzaE9yQ29uY2F0KGJvZHlJdGVtLmxpbmVzLCBjYWxsYmFja3MubGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKTtcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhjYWxsYmFja3MuYWZ0ZXJMYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpKTtcblxuXHRcdFx0Ym9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGJvZHlJdGVtcztcblx0fSxcblxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRBZnRlckJvZHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyh0aGlzLl9vcHRpb25zLmNhbGxiYWNrcy5hZnRlckJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBmb290ZXIgYW5kIGJlZm9yZUZvb3RlciBhbmQgYWZ0ZXJGb290ZXIgbGluZXNcblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0Rm9vdGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjYWxsYmFja3MgPSBtZS5fb3B0aW9ucy5jYWxsYmFja3M7XG5cblx0XHR2YXIgYmVmb3JlRm9vdGVyID0gY2FsbGJhY2tzLmJlZm9yZUZvb3Rlci5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgZm9vdGVyID0gY2FsbGJhY2tzLmZvb3Rlci5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgYWZ0ZXJGb290ZXIgPSBjYWxsYmFja3MuYWZ0ZXJGb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cblx0XHR2YXIgbGluZXMgPSBbXTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuXG5cdFx0cmV0dXJuIGxpbmVzO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oY2hhbmdlZCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5fb3B0aW9ucztcblxuXHRcdC8vIE5lZWQgdG8gcmVnZW5lcmF0ZSB0aGUgbW9kZWwgYmVjYXVzZSBpdHMgZmFzdGVyIHRoYW4gdXNpbmcgZXh0ZW5kIGFuZCBpdCBpcyBuZWNlc3NhcnkgZHVlIHRvIHRoZSBvcHRpbWl6YXRpb24gaW4gQ2hhcnQuRWxlbWVudC50cmFuc2l0aW9uXG5cdFx0Ly8gdGhhdCBkb2VzIF92aWV3ID0gX21vZGVsIGlmIGVhc2UgPT09IDEuIFRoaXMgY2F1c2VzIHRoZSAybmQgdG9vbHRpcCB1cGRhdGUgdG8gc2V0IHByb3BlcnRpZXMgaW4gYm90aCB0aGUgdmlldyBhbmQgbW9kZWwgYXQgdGhlIHNhbWUgdGltZVxuXHRcdC8vIHdoaWNoIGJyZWFrcyBhbnkgYW5pbWF0aW9ucy5cblx0XHR2YXIgZXhpc3RpbmdNb2RlbCA9IG1lLl9tb2RlbDtcblx0XHR2YXIgbW9kZWwgPSBtZS5fbW9kZWwgPSBnZXRCYXNlTW9kZWwob3B0cyk7XG5cdFx0dmFyIGFjdGl2ZSA9IG1lLl9hY3RpdmU7XG5cblx0XHR2YXIgZGF0YSA9IG1lLl9kYXRhO1xuXG5cdFx0Ly8gSW4gdGhlIGNhc2Ugd2hlcmUgYWN0aXZlLmxlbmd0aCA9PT0gMCB3ZSBuZWVkIHRvIGtlZXAgdGhlc2UgYXQgZXhpc3RpbmcgdmFsdWVzIGZvciBnb29kIGFuaW1hdGlvbnNcblx0XHR2YXIgYWxpZ25tZW50ID0ge1xuXHRcdFx0eEFsaWduOiBleGlzdGluZ01vZGVsLnhBbGlnbixcblx0XHRcdHlBbGlnbjogZXhpc3RpbmdNb2RlbC55QWxpZ25cblx0XHR9O1xuXHRcdHZhciBiYWNrZ3JvdW5kUG9pbnQgPSB7XG5cdFx0XHR4OiBleGlzdGluZ01vZGVsLngsXG5cdFx0XHR5OiBleGlzdGluZ01vZGVsLnlcblx0XHR9O1xuXHRcdHZhciB0b29sdGlwU2l6ZSA9IHtcblx0XHRcdHdpZHRoOiBleGlzdGluZ01vZGVsLndpZHRoLFxuXHRcdFx0aGVpZ2h0OiBleGlzdGluZ01vZGVsLmhlaWdodFxuXHRcdH07XG5cdFx0dmFyIHRvb2x0aXBQb3NpdGlvbiA9IHtcblx0XHRcdHg6IGV4aXN0aW5nTW9kZWwuY2FyZXRYLFxuXHRcdFx0eTogZXhpc3RpbmdNb2RlbC5jYXJldFlcblx0XHR9O1xuXG5cdFx0dmFyIGksIGxlbjtcblxuXHRcdGlmIChhY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRtb2RlbC5vcGFjaXR5ID0gMTtcblxuXHRcdFx0dmFyIGxhYmVsQ29sb3JzID0gW107XG5cdFx0XHR2YXIgbGFiZWxUZXh0Q29sb3JzID0gW107XG5cdFx0XHR0b29sdGlwUG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRzLnBvc2l0aW9uXS5jYWxsKG1lLCBhY3RpdmUsIG1lLl9ldmVudFBvc2l0aW9uKTtcblxuXHRcdFx0dmFyIHRvb2x0aXBJdGVtcyA9IFtdO1xuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHRcdHRvb2x0aXBJdGVtcy5wdXNoKGNyZWF0ZVRvb2x0aXBJdGVtKGFjdGl2ZVtpXSkpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIGZpbHRlciBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuXHRcdFx0aWYgKG9wdHMuZmlsdGVyKSB7XG5cdFx0XHRcdHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoZnVuY3Rpb24oYSkge1xuXHRcdFx0XHRcdHJldHVybiBvcHRzLmZpbHRlcihhLCBkYXRhKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSB1c2VyIHByb3ZpZGVkIGEgc29ydGluZyBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuXHRcdFx0aWYgKG9wdHMuaXRlbVNvcnQpIHtcblx0XHRcdFx0dG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdHJldHVybiBvcHRzLml0ZW1Tb3J0KGEsIGIsIGRhdGEpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGNvbG9ycyBmb3IgYm94ZXNcblx0XHRcdGhlbHBlcnMkMS5lYWNoKHRvb2x0aXBJdGVtcywgZnVuY3Rpb24odG9vbHRpcEl0ZW0pIHtcblx0XHRcdFx0bGFiZWxDb2xvcnMucHVzaChvcHRzLmNhbGxiYWNrcy5sYWJlbENvbG9yLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBtZS5fY2hhcnQpKTtcblx0XHRcdFx0bGFiZWxUZXh0Q29sb3JzLnB1c2gob3B0cy5jYWxsYmFja3MubGFiZWxUZXh0Q29sb3IuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIG1lLl9jaGFydCkpO1xuXHRcdFx0fSk7XG5cblxuXHRcdFx0Ly8gQnVpbGQgdGhlIFRleHQgTGluZXNcblx0XHRcdG1vZGVsLnRpdGxlID0gbWUuZ2V0VGl0bGUodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdG1vZGVsLmJlZm9yZUJvZHkgPSBtZS5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRtb2RlbC5ib2R5ID0gbWUuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuYWZ0ZXJCb2R5ID0gbWUuZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRtb2RlbC5mb290ZXIgPSBtZS5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblxuXHRcdFx0Ly8gSW5pdGlhbCBwb3NpdGlvbmluZyBhbmQgY29sb3JzXG5cdFx0XHRtb2RlbC54ID0gdG9vbHRpcFBvc2l0aW9uLng7XG5cdFx0XHRtb2RlbC55ID0gdG9vbHRpcFBvc2l0aW9uLnk7XG5cdFx0XHRtb2RlbC5jYXJldFBhZGRpbmcgPSBvcHRzLmNhcmV0UGFkZGluZztcblx0XHRcdG1vZGVsLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG5cdFx0XHRtb2RlbC5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG5cblx0XHRcdC8vIGRhdGEgcG9pbnRzXG5cdFx0XHRtb2RlbC5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuXG5cdFx0XHQvLyBXZSBuZWVkIHRvIGRldGVybWluZSBhbGlnbm1lbnQgb2YgdGhlIHRvb2x0aXBcblx0XHRcdHRvb2x0aXBTaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgbW9kZWwpO1xuXHRcdFx0YWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMsIHRvb2x0aXBTaXplKTtcblx0XHRcdC8vIEZpbmFsIFNpemUgYW5kIFBvc2l0aW9uXG5cdFx0XHRiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQobW9kZWwsIHRvb2x0aXBTaXplLCBhbGlnbm1lbnQsIG1lLl9jaGFydCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1vZGVsLm9wYWNpdHkgPSAwO1xuXHRcdH1cblxuXHRcdG1vZGVsLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG5cdFx0bW9kZWwueUFsaWduID0gYWxpZ25tZW50LnlBbGlnbjtcblx0XHRtb2RlbC54ID0gYmFja2dyb3VuZFBvaW50Lng7XG5cdFx0bW9kZWwueSA9IGJhY2tncm91bmRQb2ludC55O1xuXHRcdG1vZGVsLndpZHRoID0gdG9vbHRpcFNpemUud2lkdGg7XG5cdFx0bW9kZWwuaGVpZ2h0ID0gdG9vbHRpcFNpemUuaGVpZ2h0O1xuXG5cdFx0Ly8gUG9pbnQgd2hlcmUgdGhlIGNhcmV0IG9uIHRoZSB0b29sdGlwIHBvaW50cyB0b1xuXHRcdG1vZGVsLmNhcmV0WCA9IHRvb2x0aXBQb3NpdGlvbi54O1xuXHRcdG1vZGVsLmNhcmV0WSA9IHRvb2x0aXBQb3NpdGlvbi55O1xuXG5cdFx0bWUuX21vZGVsID0gbW9kZWw7XG5cblx0XHRpZiAoY2hhbmdlZCAmJiBvcHRzLmN1c3RvbSkge1xuXHRcdFx0b3B0cy5jdXN0b20uY2FsbChtZSwgbW9kZWwpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZTtcblx0fSxcblxuXHRkcmF3Q2FyZXQ6IGZ1bmN0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgY2FyZXRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIHZtKTtcblxuXHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG5cdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcblx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuXHR9LFxuXHRnZXRDYXJldFBvc2l0aW9uOiBmdW5jdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIHZtKSB7XG5cdFx0dmFyIHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG5cdFx0dmFyIGNhcmV0U2l6ZSA9IHZtLmNhcmV0U2l6ZTtcblx0XHR2YXIgY29ybmVyUmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXHRcdHZhciB4QWxpZ24gPSB2bS54QWxpZ247XG5cdFx0dmFyIHlBbGlnbiA9IHZtLnlBbGlnbjtcblx0XHR2YXIgcHRYID0gdG9vbHRpcFBvaW50Lng7XG5cdFx0dmFyIHB0WSA9IHRvb2x0aXBQb2ludC55O1xuXHRcdHZhciB3aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0dmFyIGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuXG5cdFx0XHRpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdFx0eDEgPSBwdFg7XG5cdFx0XHRcdHgyID0geDEgLSBjYXJldFNpemU7XG5cdFx0XHRcdHgzID0geDE7XG5cblx0XHRcdFx0eTEgPSB5MiArIGNhcmV0U2l6ZTtcblx0XHRcdFx0eTMgPSB5MiAtIGNhcmV0U2l6ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHgxID0gcHRYICsgd2lkdGg7XG5cdFx0XHRcdHgyID0geDEgKyBjYXJldFNpemU7XG5cdFx0XHRcdHgzID0geDE7XG5cblx0XHRcdFx0eTEgPSB5MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eTMgPSB5MiArIGNhcmV0U2l6ZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdHgyID0gcHRYICsgY29ybmVyUmFkaXVzICsgKGNhcmV0U2l6ZSk7XG5cdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XG5cdFx0XHRcdHgzID0geDIgKyBjYXJldFNpemU7XG5cdFx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0XHR4MiA9IHB0WCArIHdpZHRoIC0gY29ybmVyUmFkaXVzIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eDIgPSB2bS5jYXJldFg7XG5cdFx0XHRcdHgxID0geDIgLSBjYXJldFNpemU7XG5cdFx0XHRcdHgzID0geDIgKyBjYXJldFNpemU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoeUFsaWduID09PSAndG9wJykge1xuXHRcdFx0XHR5MSA9IHB0WTtcblx0XHRcdFx0eTIgPSB5MSAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eTMgPSB5MTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHkxID0gcHRZICsgaGVpZ2h0O1xuXHRcdFx0XHR5MiA9IHkxICsgY2FyZXRTaXplO1xuXHRcdFx0XHR5MyA9IHkxO1xuXHRcdFx0XHQvLyBpbnZlcnQgZHJhd2luZyBvcmRlclxuXHRcdFx0XHR2YXIgdG1wID0geDM7XG5cdFx0XHRcdHgzID0geDE7XG5cdFx0XHRcdHgxID0gdG1wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4ge3gxOiB4MSwgeDI6IHgyLCB4MzogeDMsIHkxOiB5MSwgeTI6IHkyLCB5MzogeTN9O1xuXHR9LFxuXG5cdGRyYXdUaXRsZTogZnVuY3Rpb24ocHQsIHZtLCBjdHgpIHtcblx0XHR2YXIgdGl0bGUgPSB2bS50aXRsZTtcblxuXHRcdGlmICh0aXRsZS5sZW5ndGgpIHtcblx0XHRcdHB0LnggPSBnZXRBbGlnbmVkWCh2bSwgdm0uX3RpdGxlQWxpZ24pO1xuXG5cdFx0XHRjdHgudGV4dEFsaWduID0gdm0uX3RpdGxlQWxpZ247XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cblx0XHRcdHZhciB0aXRsZUZvbnRTaXplID0gdm0udGl0bGVGb250U2l6ZTtcblx0XHRcdHZhciB0aXRsZVNwYWNpbmcgPSB2bS50aXRsZVNwYWNpbmc7XG5cblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS50aXRsZUZvbnRDb2xvcjtcblx0XHRcdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcodGl0bGVGb250U2l6ZSwgdm0uX3RpdGxlRm9udFN0eWxlLCB2bS5fdGl0bGVGb250RmFtaWx5KTtcblxuXHRcdFx0dmFyIGksIGxlbjtcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IHRpdGxlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcHQueCwgcHQueSk7XG5cdFx0XHRcdHB0LnkgKz0gdGl0bGVGb250U2l6ZSArIHRpdGxlU3BhY2luZzsgLy8gTGluZSBIZWlnaHQgYW5kIHNwYWNpbmdcblxuXHRcdFx0XHRpZiAoaSArIDEgPT09IHRpdGxlLmxlbmd0aCkge1xuXHRcdFx0XHRcdHB0LnkgKz0gdm0udGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7IC8vIElmIExhc3QsIGFkZCBtYXJnaW4sIHJlbW92ZSBzcGFjaW5nXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZHJhd0JvZHk6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XG5cdFx0dmFyIGJvZHlGb250U2l6ZSA9IHZtLmJvZHlGb250U2l6ZTtcblx0XHR2YXIgYm9keVNwYWNpbmcgPSB2bS5ib2R5U3BhY2luZztcblx0XHR2YXIgYm9keUFsaWduID0gdm0uX2JvZHlBbGlnbjtcblx0XHR2YXIgYm9keSA9IHZtLmJvZHk7XG5cdFx0dmFyIGRyYXdDb2xvckJveGVzID0gdm0uZGlzcGxheUNvbG9ycztcblx0XHR2YXIgbGFiZWxDb2xvcnMgPSB2bS5sYWJlbENvbG9ycztcblx0XHR2YXIgeExpbmVQYWRkaW5nID0gMDtcblx0XHR2YXIgY29sb3JYID0gZHJhd0NvbG9yQm94ZXMgPyBnZXRBbGlnbmVkWCh2bSwgJ2xlZnQnKSA6IDA7XG5cdFx0dmFyIHRleHRDb2xvcjtcblxuXHRcdGN0eC50ZXh0QWxpZ24gPSBib2R5QWxpZ247XG5cdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXHRcdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcoYm9keUZvbnRTaXplLCB2bS5fYm9keUZvbnRTdHlsZSwgdm0uX2JvZHlGb250RmFtaWx5KTtcblxuXHRcdHB0LnggPSBnZXRBbGlnbmVkWCh2bSwgYm9keUFsaWduKTtcblxuXHRcdC8vIEJlZm9yZSBCb2R5XG5cdFx0dmFyIGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuXHRcdFx0Y3R4LmZpbGxUZXh0KGxpbmUsIHB0LnggKyB4TGluZVBhZGRpbmcsIHB0LnkpO1xuXHRcdFx0cHQueSArPSBib2R5Rm9udFNpemUgKyBib2R5U3BhY2luZztcblx0XHR9O1xuXG5cdFx0Ly8gQmVmb3JlIGJvZHkgbGluZXNcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYm9keUZvbnRDb2xvcjtcblx0XHRoZWxwZXJzJDEuZWFjaCh2bS5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG5cblx0XHR4TGluZVBhZGRpbmcgPSBkcmF3Q29sb3JCb3hlcyAmJiBib2R5QWxpZ24gIT09ICdyaWdodCdcblx0XHRcdD8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib2R5Rm9udFNpemUgLyAyICsgMSkgOiAoYm9keUZvbnRTaXplICsgMilcblx0XHRcdDogMDtcblxuXHRcdC8vIERyYXcgYm9keSBsaW5lcyBub3dcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5LCBmdW5jdGlvbihib2R5SXRlbSwgaSkge1xuXHRcdFx0dGV4dENvbG9yID0gdm0ubGFiZWxUZXh0Q29sb3JzW2ldO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5saW5lcywgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHQvLyBEcmF3IExlZ2VuZC1saWtlIGJveGVzIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoZHJhd0NvbG9yQm94ZXMpIHtcblx0XHRcdFx0XHQvLyBGaWxsIGEgd2hpdGUgcmVjdCBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5sZWdlbmRDb2xvckJhY2tncm91bmQ7XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KGNvbG9yWCwgcHQueSwgYm9keUZvbnRTaXplLCBib2R5Rm9udFNpemUpO1xuXG5cdFx0XHRcdFx0Ly8gQm9yZGVyXG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDE7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnNbaV0uYm9yZGVyQ29sb3I7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVJlY3QoY29sb3JYLCBwdC55LCBib2R5Rm9udFNpemUsIGJvZHlGb250U2l6ZSk7XG5cblx0XHRcdFx0XHQvLyBJbm5lciBzcXVhcmVcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnNbaV0uYmFja2dyb3VuZENvbG9yO1xuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChjb2xvclggKyAxLCBwdC55ICsgMSwgYm9keUZvbnRTaXplIC0gMiwgYm9keUZvbnRTaXplIC0gMik7XG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZpbGxMaW5lT2ZUZXh0KGxpbmUpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG5cdFx0fSk7XG5cblx0XHQvLyBSZXNldCBiYWNrIHRvIDAgZm9yIGFmdGVyIGJvZHlcblx0XHR4TGluZVBhZGRpbmcgPSAwO1xuXG5cdFx0Ly8gQWZ0ZXIgYm9keSBsaW5lc1xuXHRcdGhlbHBlcnMkMS5lYWNoKHZtLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXHRcdHB0LnkgLT0gYm9keVNwYWNpbmc7IC8vIFJlbW92ZSBsYXN0IGJvZHkgc3BhY2luZ1xuXHR9LFxuXG5cdGRyYXdGb290ZXI6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XG5cdFx0dmFyIGZvb3RlciA9IHZtLmZvb3RlcjtcblxuXHRcdGlmIChmb290ZXIubGVuZ3RoKSB7XG5cdFx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIHZtLl9mb290ZXJBbGlnbik7XG5cdFx0XHRwdC55ICs9IHZtLmZvb3Rlck1hcmdpblRvcDtcblxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IHZtLl9mb290ZXJBbGlnbjtcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmZvb3RlckZvbnRDb2xvcjtcblx0XHRcdGN0eC5mb250ID0gaGVscGVycyQxLmZvbnRTdHJpbmcodm0uZm9vdGVyRm9udFNpemUsIHZtLl9mb290ZXJGb250U3R5bGUsIHZtLl9mb290ZXJGb250RmFtaWx5KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goZm9vdGVyLCBmdW5jdGlvbihsaW5lKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBwdC54LCBwdC55KTtcblx0XHRcdFx0cHQueSArPSB2bS5mb290ZXJGb250U2l6ZSArIHZtLmZvb3RlclNwYWNpbmc7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhd0JhY2tncm91bmQ6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4LCB0b29sdGlwU2l6ZSkge1xuXHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3I7XG5cdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoO1xuXHRcdHZhciB4QWxpZ24gPSB2bS54QWxpZ247XG5cdFx0dmFyIHlBbGlnbiA9IHZtLnlBbGlnbjtcblx0XHR2YXIgeCA9IHB0Lng7XG5cdFx0dmFyIHkgPSBwdC55O1xuXHRcdHZhciB3aWR0aCA9IHRvb2x0aXBTaXplLndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSB0b29sdGlwU2l6ZS5oZWlnaHQ7XG5cdFx0dmFyIHJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcblxuXHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuXHRcdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0XHR0aGlzLmRyYXdDYXJldChwdCwgdG9vbHRpcFNpemUpO1xuXHRcdH1cblx0XHRjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHR9XG5cdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcblx0XHRpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHR9XG5cdFx0Y3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHR9XG5cdFx0Y3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRjdHguZmlsbCgpO1xuXG5cdFx0aWYgKHZtLmJvcmRlcldpZHRoID4gMCkge1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cblx0XHRpZiAodm0ub3BhY2l0eSA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciB0b29sdGlwU2l6ZSA9IHtcblx0XHRcdHdpZHRoOiB2bS53aWR0aCxcblx0XHRcdGhlaWdodDogdm0uaGVpZ2h0XG5cdFx0fTtcblx0XHR2YXIgcHQgPSB7XG5cdFx0XHR4OiB2bS54LFxuXHRcdFx0eTogdm0ueVxuXHRcdH07XG5cblx0XHQvLyBJRTExL0VkZ2UgZG9lcyBub3QgbGlrZSB2ZXJ5IHNtYWxsIG9wYWNpdGllcywgc28gc25hcCB0byAwXG5cdFx0dmFyIG9wYWNpdHkgPSBNYXRoLmFicyh2bS5vcGFjaXR5IDwgMWUtMykgPyAwIDogdm0ub3BhY2l0eTtcblxuXHRcdC8vIFRydXRoeS9mYWxzZXkgdmFsdWUgZm9yIGVtcHR5IHRvb2x0aXBcblx0XHR2YXIgaGFzVG9vbHRpcENvbnRlbnQgPSB2bS50aXRsZS5sZW5ndGggfHwgdm0uYmVmb3JlQm9keS5sZW5ndGggfHwgdm0uYm9keS5sZW5ndGggfHwgdm0uYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB2bS5mb290ZXIubGVuZ3RoO1xuXG5cdFx0aWYgKHRoaXMuX29wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cblx0XHRcdC8vIERyYXcgQmFja2dyb3VuZFxuXHRcdFx0dGhpcy5kcmF3QmFja2dyb3VuZChwdCwgdm0sIGN0eCwgdG9vbHRpcFNpemUpO1xuXG5cdFx0XHQvLyBEcmF3IFRpdGxlLCBCb2R5LCBhbmQgRm9vdGVyXG5cdFx0XHRwdC55ICs9IHZtLnlQYWRkaW5nO1xuXG5cdFx0XHQvLyBUaXRsZXNcblx0XHRcdHRoaXMuZHJhd1RpdGxlKHB0LCB2bSwgY3R4KTtcblxuXHRcdFx0Ly8gQm9keVxuXHRcdFx0dGhpcy5kcmF3Qm9keShwdCwgdm0sIGN0eCk7XG5cblx0XHRcdC8vIEZvb3RlclxuXHRcdFx0dGhpcy5kcmF3Rm9vdGVyKHB0LCB2bSwgY3R4KTtcblxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0b29sdGlwIGNoYW5nZWRcblx0ICovXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9vcHRpb25zO1xuXHRcdHZhciBjaGFuZ2VkID0gZmFsc2U7XG5cblx0XHRtZS5fbGFzdEFjdGl2ZSA9IG1lLl9sYXN0QWN0aXZlIHx8IFtdO1xuXG5cdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIHRvb2x0aXBzXG5cdFx0aWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuXHRcdFx0bWUuX2FjdGl2ZSA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5fYWN0aXZlID0gbWUuX2NoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcblx0XHRjaGFuZ2VkID0gIWhlbHBlcnMkMS5hcnJheUVxdWFscyhtZS5fYWN0aXZlLCBtZS5fbGFzdEFjdGl2ZSk7XG5cblx0XHQvLyBPbmx5IGhhbmRsZSB0YXJnZXQgZXZlbnQgb24gdG9vbHRpcCBjaGFuZ2Vcblx0XHRpZiAoY2hhbmdlZCkge1xuXHRcdFx0bWUuX2xhc3RBY3RpdmUgPSBtZS5fYWN0aXZlO1xuXG5cdFx0XHRpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuY3VzdG9tKSB7XG5cdFx0XHRcdG1lLl9ldmVudFBvc2l0aW9uID0ge1xuXHRcdFx0XHRcdHg6IGUueCxcblx0XHRcdFx0XHR5OiBlLnlcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRtZS51cGRhdGUodHJ1ZSk7XG5cdFx0XHRcdG1lLnBpdm90KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdH1cbn0pO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVyc1xuICovXG52YXIgcG9zaXRpb25lcnNfMSA9IHBvc2l0aW9uZXJzO1xuXG52YXIgY29yZV90b29sdGlwID0gZXhwb3J0cyQzO1xuY29yZV90b29sdGlwLnBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnNfMTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDggPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge30sXG5cdGV2ZW50czogW1xuXHRcdCdtb3VzZW1vdmUnLFxuXHRcdCdtb3VzZW91dCcsXG5cdFx0J2NsaWNrJyxcblx0XHQndG91Y2hzdGFydCcsXG5cdFx0J3RvdWNobW92ZSdcblx0XSxcblx0aG92ZXI6IHtcblx0XHRvbkhvdmVyOiBudWxsLFxuXHRcdG1vZGU6ICduZWFyZXN0Jyxcblx0XHRpbnRlcnNlY3Q6IHRydWUsXG5cdFx0YW5pbWF0aW9uRHVyYXRpb246IDQwMFxuXHR9LFxuXHRvbkNsaWNrOiBudWxsLFxuXHRtYWludGFpbkFzcGVjdFJhdGlvOiB0cnVlLFxuXHRyZXNwb25zaXZlOiB0cnVlLFxuXHRyZXNwb25zaXZlQW5pbWF0aW9uRHVyYXRpb246IDBcbn0pO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBnaXZlbiBjb25maWcgb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGBzY2FsZXNgIG9wdGlvblxuICogYnkgaW5jb3Jwb3JhdGluZyBzY2FsZSBkZWZhdWx0cyBpbiBgeEF4ZXNgIGFuZCBgeUF4ZXNgIGFycmF5IGl0ZW1zLCB0aGVuXG4gKiByZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSByZXN1bHQsIHRodXMgZG9lc24ndCBhbHRlciBpbnB1dHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoLyogY29uZmlnIG9iamVjdHMgLi4uICovKSB7XG5cdHJldHVybiBoZWxwZXJzJDEubWVyZ2Uoe30sIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwge1xuXHRcdG1lcmdlcjogZnVuY3Rpb24oa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRcdFx0aWYgKGtleSA9PT0gJ3hBeGVzJyB8fCBrZXkgPT09ICd5QXhlcycpIHtcblx0XHRcdFx0dmFyIHNsZW4gPSBzb3VyY2Vba2V5XS5sZW5ndGg7XG5cdFx0XHRcdHZhciBpLCB0eXBlLCBzY2FsZTtcblxuXHRcdFx0XHRpZiAoIXRhcmdldFtrZXldKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzbGVuOyArK2kpIHtcblx0XHRcdFx0XHRzY2FsZSA9IHNvdXJjZVtrZXldW2ldO1xuXHRcdFx0XHRcdHR5cGUgPSB2YWx1ZU9yRGVmYXVsdCQ4KHNjYWxlLnR5cGUsIGtleSA9PT0gJ3hBeGVzJyA/ICdjYXRlZ29yeScgOiAnbGluZWFyJyk7XG5cblx0XHRcdFx0XHRpZiAoaSA+PSB0YXJnZXRba2V5XS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtrZXldLnB1c2goe30pO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICghdGFyZ2V0W2tleV1baV0udHlwZSB8fCAoc2NhbGUudHlwZSAmJiBzY2FsZS50eXBlICE9PSB0YXJnZXRba2V5XVtpXS50eXBlKSkge1xuXHRcdFx0XHRcdFx0Ly8gbmV3L3VudHlwZWQgc2NhbGUgb3IgdHlwZSBjaGFuZ2VkOiBsZXQncyBhcHBseSB0aGUgbmV3IGRlZmF1bHRzXG5cdFx0XHRcdFx0XHQvLyB0aGVuIG1lcmdlIHNvdXJjZSBzY2FsZSB0byBjb3JyZWN0bHkgb3ZlcndyaXRlIHRoZSBkZWZhdWx0cy5cblx0XHRcdFx0XHRcdGhlbHBlcnMkMS5tZXJnZSh0YXJnZXRba2V5XVtpXSwgW2NvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHModHlwZSksIHNjYWxlXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHNjYWxlcyB0eXBlIGFyZSB0aGUgc2FtZVxuXHRcdFx0XHRcdFx0aGVscGVycyQxLm1lcmdlKHRhcmdldFtrZXldW2ldLCBzY2FsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoZWxwZXJzJDEuX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBnaXZlbiBjb25maWcgb2JqZWN0cyBhcyB0aGUgcm9vdCBvcHRpb25zIGJ5IGhhbmRsaW5nXG4gKiBkZWZhdWx0IHNjYWxlIG9wdGlvbnMgZm9yIHRoZSBgc2NhbGVzYCBhbmQgYHNjYWxlYCBwcm9wZXJ0aWVzLCB0aGVuIHJldHVybnNcbiAqIGEgZGVlcCBjb3B5IG9mIHRoZSByZXN1bHQsIHRodXMgZG9lc24ndCBhbHRlciBpbnB1dHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKC8qIGNvbmZpZyBvYmplY3RzIC4uLiAqLykge1xuXHRyZXR1cm4gaGVscGVycyQxLm1lcmdlKHt9LCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIHtcblx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRcdHZhciB0dmFsID0gdGFyZ2V0W2tleV0gfHwge307XG5cdFx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0XHRpZiAoa2V5ID09PSAnc2NhbGVzJykge1xuXHRcdFx0XHQvLyBzY2FsZSBjb25maWcgbWVyZ2luZyBpcyBjb21wbGV4LiBBZGQgb3VyIG93biBmdW5jdGlvbiBoZXJlIGZvciB0aGF0XG5cdFx0XHRcdHRhcmdldFtrZXldID0gbWVyZ2VTY2FsZUNvbmZpZyh0dmFsLCBzdmFsKTtcblx0XHRcdH0gZWxzZSBpZiAoa2V5ID09PSAnc2NhbGUnKSB7XG5cdFx0XHRcdC8vIHVzZWQgaW4gcG9sYXIgYXJlYSAmIHJhZGFyIGNoYXJ0cyBzaW5jZSB0aGVyZSBpcyBvbmx5IG9uZSBzY2FsZVxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMkMS5tZXJnZSh0dmFsLCBbY29yZV9zY2FsZVNlcnZpY2UuZ2V0U2NhbGVEZWZhdWx0cyhzdmFsLnR5cGUpLCBzdmFsXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoZWxwZXJzJDEuX21lcmdlcihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0Ly8gRG8gTk9UIHVzZSBtZXJnZUNvbmZpZyBmb3IgdGhlIGRhdGEgb2JqZWN0IGJlY2F1c2UgdGhpcyBtZXRob2QgbWVyZ2VzIGFycmF5c1xuXHQvLyBhbmQgc28gd291bGQgY2hhbmdlIHJlZmVyZW5jZXMgdG8gbGFiZWxzIGFuZCBkYXRhc2V0cywgcHJldmVudGluZyBkYXRhIHVwZGF0ZXMuXG5cdHZhciBkYXRhID0gY29uZmlnLmRhdGEgPSBjb25maWcuZGF0YSB8fCB7fTtcblx0ZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG5cdGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG5cblx0Y29uZmlnLm9wdGlvbnMgPSBtZXJnZUNvbmZpZyhcblx0XHRjb3JlX2RlZmF1bHRzLmdsb2JhbCxcblx0XHRjb3JlX2RlZmF1bHRzW2NvbmZpZy50eXBlXSxcblx0XHRjb25maWcub3B0aW9ucyB8fCB7fSk7XG5cblx0cmV0dXJuIGNvbmZpZztcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29uZmlnKGNoYXJ0KSB7XG5cdHZhciBuZXdPcHRpb25zID0gY2hhcnQub3B0aW9ucztcblxuXHRoZWxwZXJzJDEuZWFjaChjaGFydC5zY2FsZXMsIGZ1bmN0aW9uKHNjYWxlKSB7XG5cdFx0Y29yZV9sYXlvdXRzLnJlbW92ZUJveChjaGFydCwgc2NhbGUpO1xuXHR9KTtcblxuXHRuZXdPcHRpb25zID0gbWVyZ2VDb25maWcoXG5cdFx0Y29yZV9kZWZhdWx0cy5nbG9iYWwsXG5cdFx0Y29yZV9kZWZhdWx0c1tjaGFydC5jb25maWcudHlwZV0sXG5cdFx0bmV3T3B0aW9ucyk7XG5cblx0Y2hhcnQub3B0aW9ucyA9IGNoYXJ0LmNvbmZpZy5vcHRpb25zID0gbmV3T3B0aW9ucztcblx0Y2hhcnQuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuXHRjaGFydC5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG5cblx0Ly8gVG9vbHRpcFxuXHRjaGFydC50b29sdGlwLl9vcHRpb25zID0gbmV3T3B0aW9ucy50b29sdGlwcztcblx0Y2hhcnQudG9vbHRpcC5pbml0aWFsaXplKCk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uKSB7XG5cdHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nO1xufVxuXG52YXIgQ2hhcnQgPSBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0dGhpcy5jb25zdHJ1Y3QoaXRlbSwgY29uZmlnKTtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5oZWxwZXJzJDEuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwgLyoqIEBsZW5kcyBDaGFydCAqLyB7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y29uc3RydWN0OiBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Y29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuXG5cdFx0dmFyIGNvbnRleHQgPSBwbGF0Zm9ybS5hY3F1aXJlQ29udGV4dChpdGVtLCBjb25maWcpO1xuXHRcdHZhciBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuXHRcdHZhciBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcblx0XHR2YXIgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuXG5cdFx0bWUuaWQgPSBoZWxwZXJzJDEudWlkKCk7XG5cdFx0bWUuY3R4ID0gY29udGV4dDtcblx0XHRtZS5jYW52YXMgPSBjYW52YXM7XG5cdFx0bWUuY29uZmlnID0gY29uZmlnO1xuXHRcdG1lLndpZHRoID0gd2lkdGg7XG5cdFx0bWUuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdG1lLmFzcGVjdFJhdGlvID0gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuXHRcdG1lLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSBmYWxzZTtcblxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBDaGFydCBhbmQgQ2hhcnQuQ29udHJvbGxlciBoYXZlIGJlZW4gbWVyZ2VkLFxuXHRcdCAqIHRoZSBcImluc3RhbmNlXCIgc3RpbGwgbmVlZCB0byBiZSBkZWZpbmVkIHNpbmNlIGl0IG1pZ2h0IGJlIGNhbGxlZCBmcm9tIHBsdWdpbnMuXG5cdFx0ICogQHByb3AgQ2hhcnQjY2hhcnRcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0bWUuY2hhcnQgPSBtZTtcblx0XHRtZS5jb250cm9sbGVyID0gbWU7IC8vIGNoYXJ0LmNoYXJ0LmNvbnRyb2xsZXIgI2luY2VwdGlvblxuXG5cdFx0Ly8gQWRkIHRoZSBjaGFydCBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuXHRcdENoYXJ0Lmluc3RhbmNlc1ttZS5pZF0gPSBtZTtcblxuXHRcdC8vIERlZmluZSBhbGlhcyB0byB0aGUgY29uZmlnIGRhdGE6IGBjaGFydC5kYXRhID09PSBjaGFydC5jb25maWcuZGF0YWBcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobWUsICdkYXRhJywge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1lLmNvbmZpZy5kYXRhO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0bWUuY29uZmlnLmRhdGEgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG5cdFx0XHQvLyBUaGUgZ2l2ZW4gaXRlbSBpcyBub3QgYSBjb21wYXRpYmxlIGNvbnRleHQyZCBlbGVtZW50LCBsZXQncyByZXR1cm4gYmVmb3JlIGZpbmFsaXppbmdcblx0XHRcdC8vIHRoZSBjaGFydCBpbml0aWFsaXphdGlvbiBidXQgYWZ0ZXIgc2V0dGluZyBiYXNpYyBjaGFydCAvIGNvbnRyb2xsZXIgcHJvcGVydGllcyB0aGF0XG5cdFx0XHQvLyBjYW4gaGVscCB0byBmaWd1cmUgb3V0IHRoYXQgdGhlIGNoYXJ0IGlzIG5vdCB2YWxpZCAoZS5nIGNoYXJ0LmNhbnZhcyAhPT0gbnVsbCk7XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG1lLmluaXRpYWxpemUoKTtcblx0XHRtZS51cGRhdGUoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHQvLyBCZWZvcmUgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUluaXQnKTtcblxuXHRcdGhlbHBlcnMkMS5yZXRpbmFTY2FsZShtZSwgbWUub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuXHRcdG1lLmJpbmRFdmVudHMoKTtcblxuXHRcdGlmIChtZS5vcHRpb25zLnJlc3BvbnNpdmUpIHtcblx0XHRcdC8vIEluaXRpYWwgcmVzaXplIGJlZm9yZSBjaGFydCBkcmF3cyAobXVzdCBiZSBzaWxlbnQgdG8gcHJlc2VydmUgaW5pdGlhbCBhbmltYXRpb25zKS5cblx0XHRcdG1lLnJlc2l6ZSh0cnVlKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgc2NhbGVzIGhhdmUgSURzIGFuZCBhcmUgYnVpbHQgYmVmb3JlIHdlIGJ1aWxkIGFueSBjb250cm9sbGVycy5cblx0XHRtZS5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG5cdFx0bWUuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuXHRcdG1lLmluaXRUb29sVGlwKCk7XG5cblx0XHQvLyBBZnRlciBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJJbml0Jyk7XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMuY2xlYXIodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gU3RvcHMgYW55IGN1cnJlbnQgYW5pbWF0aW9uIGxvb3Agb2NjdXJyaW5nXG5cdFx0Y29yZV9hbmltYXRpb25zLmNhbmNlbEFuaW1hdGlvbih0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZXNpemU6IGZ1bmN0aW9uKHNpbGVudCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBjYW52YXMgPSBtZS5jYW52YXM7XG5cdFx0dmFyIGFzcGVjdFJhdGlvID0gKG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBtZS5hc3BlY3RSYXRpbykgfHwgbnVsbDtcblxuXHRcdC8vIHRoZSBjYW52YXMgcmVuZGVyIHdpZHRoIGFuZCBoZWlnaHQgd2lsbCBiZSBjYXN0ZWQgdG8gaW50ZWdlcnMgc28gbWFrZSBzdXJlIHRoYXRcblx0XHQvLyB0aGUgY2FudmFzIGRpc3BsYXkgc3R5bGUgdXNlcyB0aGUgc2FtZSBpbnRlZ2VyIHZhbHVlcyB0byBhdm9pZCBibHVycmluZyBlZmZlY3QuXG5cblx0XHQvLyBTZXQgdG8gMCBpbnN0ZWFkIG9mIGNhbnZhcy5zaXplIGJlY2F1c2UgdGhlIHNpemUgZGVmYXVsdHMgdG8gMzAweDE1MCBpZiB0aGUgZWxlbWVudCBpcyBjb2xsYXBzZWRcblx0XHR2YXIgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5nZXRNYXhpbXVtV2lkdGgoY2FudmFzKSkpO1xuXHRcdHZhciBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGFzcGVjdFJhdGlvID8gbmV3V2lkdGggLyBhc3BlY3RSYXRpbyA6IGhlbHBlcnMkMS5nZXRNYXhpbXVtSGVpZ2h0KGNhbnZhcykpKTtcblxuXHRcdGlmIChtZS53aWR0aCA9PT0gbmV3V2lkdGggJiYgbWUuaGVpZ2h0ID09PSBuZXdIZWlnaHQpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjYW52YXMud2lkdGggPSBtZS53aWR0aCA9IG5ld1dpZHRoO1xuXHRcdGNhbnZhcy5oZWlnaHQgPSBtZS5oZWlnaHQgPSBuZXdIZWlnaHQ7XG5cdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gbmV3V2lkdGggKyAncHgnO1xuXHRcdGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBuZXdIZWlnaHQgKyAncHgnO1xuXG5cdFx0aGVscGVycyQxLnJldGluYVNjYWxlKG1lLCBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0aWYgKCFzaWxlbnQpIHtcblx0XHRcdC8vIE5vdGlmeSBhbnkgcGx1Z2lucyBhYm91dCB0aGUgcmVzaXplXG5cdFx0XHR2YXIgbmV3U2l6ZSA9IHt3aWR0aDogbmV3V2lkdGgsIGhlaWdodDogbmV3SGVpZ2h0fTtcblx0XHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdyZXNpemUnLCBbbmV3U2l6ZV0pO1xuXG5cdFx0XHQvLyBOb3RpZnkgb2YgcmVzaXplXG5cdFx0XHRpZiAob3B0aW9ucy5vblJlc2l6ZSkge1xuXHRcdFx0XHRvcHRpb25zLm9uUmVzaXplKG1lLCBuZXdTaXplKTtcblx0XHRcdH1cblxuXHRcdFx0bWUuc3RvcCgpO1xuXHRcdFx0bWUudXBkYXRlKHtcblx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMucmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0ZW5zdXJlU2NhbGVzSGF2ZUlEczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0dmFyIHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcblx0XHR2YXIgc2NhbGVPcHRpb25zID0gb3B0aW9ucy5zY2FsZTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHNjYWxlc09wdGlvbnMueEF4ZXMsIGZ1bmN0aW9uKHhBeGlzT3B0aW9ucywgaW5kZXgpIHtcblx0XHRcdHhBeGlzT3B0aW9ucy5pZCA9IHhBeGlzT3B0aW9ucy5pZCB8fCAoJ3gtYXhpcy0nICsgaW5kZXgpO1xuXHRcdH0pO1xuXG5cdFx0aGVscGVycyQxLmVhY2goc2NhbGVzT3B0aW9ucy55QXhlcywgZnVuY3Rpb24oeUF4aXNPcHRpb25zLCBpbmRleCkge1xuXHRcdFx0eUF4aXNPcHRpb25zLmlkID0geUF4aXNPcHRpb25zLmlkIHx8ICgneS1heGlzLScgKyBpbmRleCk7XG5cdFx0fSk7XG5cblx0XHRpZiAoc2NhbGVPcHRpb25zKSB7XG5cdFx0XHRzY2FsZU9wdGlvbnMuaWQgPSBzY2FsZU9wdGlvbnMuaWQgfHwgJ3NjYWxlJztcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEJ1aWxkcyBhIG1hcCBvZiBzY2FsZSBJRCB0byBzY2FsZSBvYmplY3QgZm9yIGZ1dHVyZSBsb29rdXAuXG5cdCAqL1xuXHRidWlsZE9yVXBkYXRlU2NhbGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgc2NhbGVzID0gbWUuc2NhbGVzIHx8IHt9O1xuXHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdHZhciB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBpZCkge1xuXHRcdFx0b2JqW2lkXSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LCB7fSk7XG5cblx0XHRpZiAob3B0aW9ucy5zY2FsZXMpIHtcblx0XHRcdGl0ZW1zID0gaXRlbXMuY29uY2F0KFxuXHRcdFx0XHQob3B0aW9ucy5zY2FsZXMueEF4ZXMgfHwgW10pLm1hcChmdW5jdGlvbih4QXhpc09wdGlvbnMpIHtcblx0XHRcdFx0XHRyZXR1cm4ge29wdGlvbnM6IHhBeGlzT3B0aW9ucywgZHR5cGU6ICdjYXRlZ29yeScsIGRwb3NpdGlvbjogJ2JvdHRvbSd9O1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnlBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeUF4aXNPcHRpb25zKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtvcHRpb25zOiB5QXhpc09wdGlvbnMsIGR0eXBlOiAnbGluZWFyJywgZHBvc2l0aW9uOiAnbGVmdCd9O1xuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5zY2FsZSkge1xuXHRcdFx0aXRlbXMucHVzaCh7XG5cdFx0XHRcdG9wdGlvbnM6IG9wdGlvbnMuc2NhbGUsXG5cdFx0XHRcdGR0eXBlOiAncmFkaWFsTGluZWFyJyxcblx0XHRcdFx0aXNEZWZhdWx0OiB0cnVlLFxuXHRcdFx0XHRkcG9zaXRpb246ICdjaGFydEFyZWEnXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRoZWxwZXJzJDEuZWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0dmFyIHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcblx0XHRcdHZhciBpZCA9IHNjYWxlT3B0aW9ucy5pZDtcblx0XHRcdHZhciBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdCQ4KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcblxuXHRcdFx0aWYgKHBvc2l0aW9uSXNIb3Jpem9udGFsKHNjYWxlT3B0aW9ucy5wb3NpdGlvbikgIT09IHBvc2l0aW9uSXNIb3Jpem9udGFsKGl0ZW0uZHBvc2l0aW9uKSkge1xuXHRcdFx0XHRzY2FsZU9wdGlvbnMucG9zaXRpb24gPSBpdGVtLmRwb3NpdGlvbjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlZFtpZF0gPSB0cnVlO1xuXHRcdFx0dmFyIHNjYWxlID0gbnVsbDtcblx0XHRcdGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcblx0XHRcdFx0c2NhbGUgPSBzY2FsZXNbaWRdO1xuXHRcdFx0XHRzY2FsZS5vcHRpb25zID0gc2NhbGVPcHRpb25zO1xuXHRcdFx0XHRzY2FsZS5jdHggPSBtZS5jdHg7XG5cdFx0XHRcdHNjYWxlLmNoYXJ0ID0gbWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc2NhbGVDbGFzcyA9IGNvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlQ29uc3RydWN0b3Ioc2NhbGVUeXBlKTtcblx0XHRcdFx0aWYgKCFzY2FsZUNsYXNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuXHRcdFx0XHRcdGlkOiBpZCxcblx0XHRcdFx0XHR0eXBlOiBzY2FsZVR5cGUsXG5cdFx0XHRcdFx0b3B0aW9uczogc2NhbGVPcHRpb25zLFxuXHRcdFx0XHRcdGN0eDogbWUuY3R4LFxuXHRcdFx0XHRcdGNoYXJ0OiBtZVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuXHRcdFx0fVxuXG5cdFx0XHRzY2FsZS5tZXJnZVRpY2tzT3B0aW9ucygpO1xuXG5cdFx0XHQvLyBUT0RPKFNCKTogSSB0aGluayB3ZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyBjdXN0b20gY2FzZSAob3B0aW9ucy5zY2FsZSlcblx0XHRcdC8vIGFuZCBjb25zaWRlciBpdCBhcyBhIHJlZ3VsYXIgc2NhbGUgcGFydCBvZiB0aGUgXCJzY2FsZXNcIlwiIG1hcCBvbmx5ISBUaGlzIHdvdWxkXG5cdFx0XHQvLyBtYWtlIHRoZSBsb2dpYyBlYXNpZXIgYW5kIHJlbW92ZSBzb21lIHVzZWxlc3M/IGN1c3RvbSBjb2RlLlxuXHRcdFx0aWYgKGl0ZW0uaXNEZWZhdWx0KSB7XG5cdFx0XHRcdG1lLnNjYWxlID0gc2NhbGU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Ly8gY2xlYXIgdXAgZGlzY2FyZGVkIHNjYWxlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKHVwZGF0ZWQsIGZ1bmN0aW9uKGhhc1VwZGF0ZWQsIGlkKSB7XG5cdFx0XHRpZiAoIWhhc1VwZGF0ZWQpIHtcblx0XHRcdFx0ZGVsZXRlIHNjYWxlc1tpZF07XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRtZS5zY2FsZXMgPSBzY2FsZXM7XG5cblx0XHRjb3JlX3NjYWxlU2VydmljZS5hZGRTY2FsZXNUb0xheW91dCh0aGlzKTtcblx0fSxcblxuXHRidWlsZE9yVXBkYXRlQ29udHJvbGxlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG5ld0NvbnRyb2xsZXJzID0gW107XG5cblx0XHRoZWxwZXJzJDEuZWFjaChtZS5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdHZhciB0eXBlID0gZGF0YXNldC50eXBlIHx8IG1lLmNvbmZpZy50eXBlO1xuXG5cdFx0XHRpZiAobWV0YS50eXBlICYmIG1ldGEudHlwZSAhPT0gdHlwZSkge1xuXHRcdFx0XHRtZS5kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0bWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHR9XG5cdFx0XHRtZXRhLnR5cGUgPSB0eXBlO1xuXG5cdFx0XHRpZiAobWV0YS5jb250cm9sbGVyKSB7XG5cdFx0XHRcdG1ldGEuY29udHJvbGxlci51cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIENvbnRyb2xsZXJDbGFzcyA9IGNvbnRyb2xsZXJzW21ldGEudHlwZV07XG5cdFx0XHRcdGlmIChDb250cm9sbGVyQ2xhc3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignXCInICsgbWV0YS50eXBlICsgJ1wiIGlzIG5vdCBhIGNoYXJ0IHR5cGUuJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKG1lLCBkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG5cdFx0XHR9XG5cdFx0fSwgbWUpO1xuXG5cdFx0cmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgZWxlbWVudHMgb2YgYWxsIGRhdGFzZXRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRyZXNldEVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG5cdFx0fSwgbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIFJlc2V0cyB0aGUgY2hhcnQgYmFjayB0byBpdCdzIHN0YXRlIGJlZm9yZSB0aGUgaW5pdGlhbCBhbmltYXRpb25cblx0Ki9cblx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVzZXRFbGVtZW50cygpO1xuXHRcdHRoaXMudG9vbHRpcC5pbml0aWFsaXplKCk7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKCFjb25maWcgfHwgdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRjb25maWcgPSB7XG5cdFx0XHRcdGR1cmF0aW9uOiBjb25maWcsXG5cdFx0XHRcdGxhenk6IGFyZ3VtZW50c1sxXVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR1cGRhdGVDb25maWcobWUpO1xuXG5cdFx0Ly8gcGx1Z2lucyBvcHRpb25zIHJlZmVyZW5jZXMgbWlnaHQgaGF2ZSBjaGFuZ2UsIGxldCdzIGludmFsaWRhdGUgdGhlIGNhY2hlXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzUxMTEjaXNzdWVjb21tZW50LTM1NTkzNDE2N1xuXHRcdGNvcmVfcGx1Z2lucy5faW52YWxpZGF0ZShtZSk7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZVVwZGF0ZScpID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEluIGNhc2UgdGhlIGVudGlyZSBkYXRhIG9iamVjdCBjaGFuZ2VkXG5cdFx0bWUudG9vbHRpcC5fZGF0YSA9IG1lLmRhdGE7XG5cblx0XHQvLyBNYWtlIHN1cmUgZGF0YXNldCBjb250cm9sbGVycyBhcmUgdXBkYXRlZCBhbmQgbmV3IGNvbnRyb2xsZXJzIGFyZSByZXNldFxuXHRcdHZhciBuZXdDb250cm9sbGVycyA9IG1lLmJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGFsbCBkYXRhc2V0IGNvbnRyb2xsZXJzIGhhdmUgY29ycmVjdCBtZXRhIGRhdGEgY291bnRzXG5cdFx0aGVscGVycyQxLmVhY2gobWUuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHRtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKCk7XG5cdFx0fSwgbWUpO1xuXG5cdFx0bWUudXBkYXRlTGF5b3V0KCk7XG5cblx0XHQvLyBDYW4gb25seSByZXNldCB0aGUgbmV3IGNvbnRyb2xsZXJzIGFmdGVyIHRoZSBzY2FsZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcblx0XHRpZiAobWUub3B0aW9ucy5hbmltYXRpb24gJiYgbWUub3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24pIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKG5ld0NvbnRyb2xsZXJzLCBmdW5jdGlvbihjb250cm9sbGVyKSB7XG5cdFx0XHRcdGNvbnRyb2xsZXIucmVzZXQoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdG1lLnVwZGF0ZURhdGFzZXRzKCk7XG5cblx0XHQvLyBOZWVkIHRvIHJlc2V0IHRvb2x0aXAgaW4gY2FzZSBpdCBpcyBkaXNwbGF5ZWQgd2l0aCBlbGVtZW50cyB0aGF0IGFyZSByZW1vdmVkXG5cdFx0Ly8gYWZ0ZXIgdXBkYXRlLlxuXHRcdG1lLnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xuXG5cdFx0Ly8gTGFzdCBhY3RpdmUgY29udGFpbnMgaXRlbXMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgaW4gdGhlIHRvb2x0aXAuXG5cdFx0Ly8gV2hlbiB3ZSByZXNldCB0aGUgdG9vbHRpcCwgd2UgbmVlZCB0byBjbGVhciBpdFxuXHRcdG1lLmxhc3RBY3RpdmUgPSBbXTtcblxuXHRcdC8vIERvIHRoaXMgYmVmb3JlIHJlbmRlciBzbyB0aGF0IGFueSBwbHVnaW5zIHRoYXQgbmVlZCBmaW5hbCBzY2FsZSB1cGRhdGVzIGNhbiB1c2UgaXRcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJVcGRhdGUnKTtcblxuXHRcdGlmIChtZS5fYnVmZmVyZWRSZW5kZXIpIHtcblx0XHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSB7XG5cdFx0XHRcdGR1cmF0aW9uOiBjb25maWcuZHVyYXRpb24sXG5cdFx0XHRcdGVhc2luZzogY29uZmlnLmVhc2luZyxcblx0XHRcdFx0bGF6eTogY29uZmlnLmxhenlcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLnJlbmRlcihjb25maWcpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY2hhcnQgbGF5b3V0IHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVMYXlvdXRgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckxheW91dGAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVMYXlvdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZUxheW91dCcpID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvcmVfbGF5b3V0cy51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG5cdFx0LyoqXG5cdFx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBgYWZ0ZXJMYXlvdXRgIGluc3RlYWQuXG5cdFx0ICogQG1ldGhvZCBJUGx1Z2luI2FmdGVyU2NhbGVVcGRhdGVcblx0XHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNS4wXG5cdFx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICovXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyU2NhbGVVcGRhdGUnKTtcblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJMYXlvdXQnKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlcyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzVXBkYXRlYFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c1VwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVEYXRhc2V0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldHNVcGRhdGUnKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVEYXRhc2V0KGkpO1xuXHRcdH1cblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRzVXBkYXRlJyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR1cGRhdGVEYXRhc2V0OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0dmFyIGFyZ3MgPSB7XG5cdFx0XHRtZXRhOiBtZXRhLFxuXHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0fTtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRGF0YXNldFVwZGF0ZScsIFthcmdzXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bWV0YS5jb250cm9sbGVyLnVwZGF0ZSgpO1xuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldFVwZGF0ZScsIFthcmdzXSk7XG5cdH0sXG5cblx0cmVuZGVyOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKCFjb25maWcgfHwgdHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcblx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRjb25maWcgPSB7XG5cdFx0XHRcdGR1cmF0aW9uOiBjb25maWcsXG5cdFx0XHRcdGxhenk6IGFyZ3VtZW50c1sxXVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IG1lLm9wdGlvbnMuYW5pbWF0aW9uO1xuXHRcdHZhciBkdXJhdGlvbiA9IHZhbHVlT3JEZWZhdWx0JDgoY29uZmlnLmR1cmF0aW9uLCBhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMuZHVyYXRpb24pO1xuXHRcdHZhciBsYXp5ID0gY29uZmlnLmxhenk7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZVJlbmRlcicpID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvbkNvbXBsZXRlID0gZnVuY3Rpb24oYW5pbWF0aW9uKSB7XG5cdFx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJSZW5kZXInKTtcblx0XHRcdGhlbHBlcnMkMS5jYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2FuaW1hdGlvbl0sIG1lKTtcblx0XHR9O1xuXG5cdFx0aWYgKGFuaW1hdGlvbk9wdGlvbnMgJiYgZHVyYXRpb24pIHtcblx0XHRcdHZhciBhbmltYXRpb24gPSBuZXcgY29yZV9hbmltYXRpb24oe1xuXHRcdFx0XHRudW1TdGVwczogZHVyYXRpb24gLyAxNi42NiwgLy8gNjAgZnBzXG5cdFx0XHRcdGVhc2luZzogY29uZmlnLmVhc2luZyB8fCBhbmltYXRpb25PcHRpb25zLmVhc2luZyxcblxuXHRcdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKGNoYXJ0LCBhbmltYXRpb25PYmplY3QpIHtcblx0XHRcdFx0XHR2YXIgZWFzaW5nRnVuY3Rpb24gPSBoZWxwZXJzJDEuZWFzaW5nLmVmZmVjdHNbYW5pbWF0aW9uT2JqZWN0LmVhc2luZ107XG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRTdGVwID0gYW5pbWF0aW9uT2JqZWN0LmN1cnJlbnRTdGVwO1xuXHRcdFx0XHRcdHZhciBzdGVwRGVjaW1hbCA9IGN1cnJlbnRTdGVwIC8gYW5pbWF0aW9uT2JqZWN0Lm51bVN0ZXBzO1xuXG5cdFx0XHRcdFx0Y2hhcnQuZHJhdyhlYXNpbmdGdW5jdGlvbihzdGVwRGVjaW1hbCksIHN0ZXBEZWNpbWFsLCBjdXJyZW50U3RlcCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0b25BbmltYXRpb25Qcm9ncmVzczogYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLFxuXHRcdFx0XHRvbkFuaW1hdGlvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG5cdFx0XHR9KTtcblxuXHRcdFx0Y29yZV9hbmltYXRpb25zLmFkZEFuaW1hdGlvbihtZSwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgbGF6eSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmRyYXcoKTtcblxuXHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNzgxXG5cdFx0XHRvbkNvbXBsZXRlKG5ldyBjb3JlX2FuaW1hdGlvbih7bnVtU3RlcHM6IDAsIGNoYXJ0OiBtZX0pKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0bWUuY2xlYXIoKTtcblxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihlYXNpbmdWYWx1ZSkpIHtcblx0XHRcdGVhc2luZ1ZhbHVlID0gMTtcblx0XHR9XG5cblx0XHRtZS50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblxuXHRcdGlmIChtZS53aWR0aCA8PSAwIHx8IG1lLmhlaWdodCA8PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEcmF3JywgW2Vhc2luZ1ZhbHVlXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRHJhdyBhbGwgdGhlIHNjYWxlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdGJveC5kcmF3KG1lLmNoYXJ0QXJlYSk7XG5cdFx0fSwgbWUpO1xuXG5cdFx0bWUuZHJhd0RhdGFzZXRzKGVhc2luZ1ZhbHVlKTtcblx0XHRtZS5fZHJhd1Rvb2x0aXAoZWFzaW5nVmFsdWUpO1xuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRHJhdycsIFtlYXNpbmdWYWx1ZV0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSAobWUuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAobWUuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRtZS5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLnRvb2x0aXAudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXdzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNEcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c0RyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZHJhd0RhdGFzZXRzOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRzRHJhdycsIFtlYXNpbmdWYWx1ZV0pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERyYXcgZGF0YXNldHMgcmV2ZXJzZWQgdG8gc3VwcG9ydCBwcm9wZXIgbGluZSBzdGFja2luZ1xuXHRcdGZvciAodmFyIGkgPSAobWUuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0XHRcdGlmIChtZS5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdG1lLmRyYXdEYXRhc2V0KGksIGVhc2luZ1ZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKTtcblx0fSxcblxuXHQvKipcblx0ICogRHJhd3MgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldERyYXdgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXREcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRyYXdEYXRhc2V0OiBmdW5jdGlvbihpbmRleCwgZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXHRcdHZhciBhcmdzID0ge1xuXHRcdFx0bWV0YTogbWV0YSxcblx0XHRcdGluZGV4OiBpbmRleCxcblx0XHRcdGVhc2luZ1ZhbHVlOiBlYXNpbmdWYWx1ZVxuXHRcdH07XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXREcmF3JywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRtZXRhLmNvbnRyb2xsZXIuZHJhdyhlYXNpbmdWYWx1ZSk7XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0RHJhdycsIFthcmdzXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXdzIHRvb2x0aXAgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZVRvb2x0aXBEcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJUb29sdGlwRHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZHJhd1Rvb2x0aXA6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdG9vbHRpcCA9IG1lLnRvb2x0aXA7XG5cdFx0dmFyIGFyZ3MgPSB7XG5cdFx0XHR0b29sdGlwOiB0b29sdGlwLFxuXHRcdFx0ZWFzaW5nVmFsdWU6IGVhc2luZ1ZhbHVlXG5cdFx0fTtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlVG9vbHRpcERyYXcnLCBbYXJnc10pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRvb2x0aXAuZHJhdygpO1xuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVG9vbHRpcERyYXcnLCBbYXJnc10pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIHNpbmdsZSBlbGVtZW50IHRoYXQgd2FzIGNsaWNrZWQgb25cblx0ICogQHJldHVybiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YXNldCBpbmRleCBhbmQgZWxlbWVudCBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgZWxlbWVudC4gQWxzbyBjb250YWlucyB0aGUgcmVjdGFuZ2xlIHRoYXQgd2FzIGRyYXdcblx0ICovXG5cdGdldEVsZW1lbnRBdEV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMuc2luZ2xlKHRoaXMsIGUpO1xuXHR9LFxuXG5cdGdldEVsZW1lbnRzQXRFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLmxhYmVsKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0fSxcblxuXHRnZXRFbGVtZW50c0F0WEF4aXM6IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlc1sneC1heGlzJ10odGhpcywgZSwge2ludGVyc2VjdDogdHJ1ZX0pO1xuXHR9LFxuXG5cdGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGU6IGZ1bmN0aW9uKGUsIG1vZGUsIG9wdGlvbnMpIHtcblx0XHR2YXIgbWV0aG9kID0gY29yZV9pbnRlcmFjdGlvbi5tb2Rlc1ttb2RlXTtcblx0XHRpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gW107XG5cdH0sXG5cblx0Z2V0RGF0YXNldEF0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlcy5kYXRhc2V0KHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0fSxcblxuXHRnZXREYXRhc2V0TWV0YTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgZGF0YXNldCA9IG1lLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcblx0XHRpZiAoIWRhdGFzZXQuX21ldGEpIHtcblx0XHRcdGRhdGFzZXQuX21ldGEgPSB7fTtcblx0XHR9XG5cblx0XHR2YXIgbWV0YSA9IGRhdGFzZXQuX21ldGFbbWUuaWRdO1xuXHRcdGlmICghbWV0YSkge1xuXHRcdFx0bWV0YSA9IGRhdGFzZXQuX21ldGFbbWUuaWRdID0ge1xuXHRcdFx0XHR0eXBlOiBudWxsLFxuXHRcdFx0XHRkYXRhOiBbXSxcblx0XHRcdFx0ZGF0YXNldDogbnVsbCxcblx0XHRcdFx0Y29udHJvbGxlcjogbnVsbCxcblx0XHRcdFx0aGlkZGVuOiBudWxsLFx0XHRcdC8vIFNlZSBpc0RhdGFzZXRWaXNpYmxlKCkgY29tbWVudFxuXHRcdFx0XHR4QXhpc0lEOiBudWxsLFxuXHRcdFx0XHR5QXhpc0lEOiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiBtZXRhO1xuXHR9LFxuXG5cdGdldFZpc2libGVEYXRhc2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb3VudCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAodGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjb3VudDtcblx0fSxcblxuXHRpc0RhdGFzZXRWaXNpYmxlOiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuXHRcdC8vIG1ldGEuaGlkZGVuIGlzIGEgcGVyIGNoYXJ0IGRhdGFzZXQgaGlkZGVuIGZsYWcgb3ZlcnJpZGUgd2l0aCAzIHN0YXRlczogaWYgdHJ1ZSBvciBmYWxzZSxcblx0XHQvLyB0aGUgZGF0YXNldC5oaWRkZW4gdmFsdWUgaXMgaWdub3JlZCwgZWxzZSBpZiBudWxsLCB0aGUgZGF0YXNldCBoaWRkZW4gc3RhdGUgaXMgcmV0dXJuZWQuXG5cdFx0cmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIXRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmhpZGRlbjtcblx0fSxcblxuXHRnZW5lcmF0ZUxlZ2VuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5sZWdlbmRDYWxsYmFjayh0aGlzKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRlc3Ryb3lEYXRhc2V0TWV0YTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIGlkID0gdGhpcy5pZDtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuXHRcdHZhciBtZXRhID0gZGF0YXNldC5fbWV0YSAmJiBkYXRhc2V0Ll9tZXRhW2lkXTtcblxuXHRcdGlmIChtZXRhKSB7XG5cdFx0XHRtZXRhLmNvbnRyb2xsZXIuZGVzdHJveSgpO1xuXHRcdFx0ZGVsZXRlIGRhdGFzZXQuX21ldGFbaWRdO1xuXHRcdH1cblx0fSxcblxuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjYW52YXMgPSBtZS5jYW52YXM7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRtZS5zdG9wKCk7XG5cblx0XHQvLyBkYXRhc2V0IGNvbnRyb2xsZXJzIG5lZWQgdG8gY2xlYW51cCBhc3NvY2lhdGVkIGRhdGFcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbWUuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLmRlc3Ryb3lEYXRhc2V0TWV0YShpKTtcblx0XHR9XG5cblx0XHRpZiAoY2FudmFzKSB7XG5cdFx0XHRtZS51bmJpbmRFdmVudHMoKTtcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMuY2xlYXIobWUpO1xuXHRcdFx0cGxhdGZvcm0ucmVsZWFzZUNvbnRleHQobWUuY3R4KTtcblx0XHRcdG1lLmNhbnZhcyA9IG51bGw7XG5cdFx0XHRtZS5jdHggPSBudWxsO1xuXHRcdH1cblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdkZXN0cm95Jyk7XG5cblx0XHRkZWxldGUgQ2hhcnQuaW5zdGFuY2VzW21lLmlkXTtcblx0fSxcblxuXHR0b0Jhc2U2NEltYWdlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdGluaXRUb29sVGlwOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLnRvb2x0aXAgPSBuZXcgY29yZV90b29sdGlwKHtcblx0XHRcdF9jaGFydDogbWUsXG5cdFx0XHRfY2hhcnRJbnN0YW5jZTogbWUsIC8vIGRlcHJlY2F0ZWQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRcdF9kYXRhOiBtZS5kYXRhLFxuXHRcdFx0X29wdGlvbnM6IG1lLm9wdGlvbnMudG9vbHRpcHNcblx0XHR9LCBtZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRiaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsaXN0ZW5lcnMgPSBtZS5fbGlzdGVuZXJzID0ge307XG5cdFx0dmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRtZS5ldmVudEhhbmRsZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLm9wdGlvbnMuZXZlbnRzLCBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKG1lLCB0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcblx0XHR9KTtcblxuXHRcdC8vIEVsZW1lbnRzIHVzZWQgdG8gZGV0ZWN0IHNpemUgY2hhbmdlIHNob3VsZCBub3QgYmUgaW5qZWN0ZWQgZm9yIG5vbiByZXNwb25zaXZlIGNoYXJ0cy5cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIyMTBcblx0XHRpZiAobWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XG5cdFx0XHRsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRtZS5yZXNpemUoKTtcblx0XHRcdH07XG5cblx0XHRcdHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIobWUsICdyZXNpemUnLCBsaXN0ZW5lcik7XG5cdFx0XHRsaXN0ZW5lcnMucmVzaXplID0gbGlzdGVuZXI7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dW5iaW5kRXZlbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsaXN0ZW5lcnMgPSBtZS5fbGlzdGVuZXJzO1xuXHRcdGlmICghbGlzdGVuZXJzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIG1lLl9saXN0ZW5lcnM7XG5cdFx0aGVscGVycyQxLmVhY2gobGlzdGVuZXJzLCBmdW5jdGlvbihsaXN0ZW5lciwgdHlwZSkge1xuXHRcdFx0cGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdHVwZGF0ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnRzLCBtb2RlLCBlbmFibGVkKSB7XG5cdFx0dmFyIG1ldGhvZCA9IGVuYWJsZWQgPyAnc2V0SG92ZXJTdHlsZScgOiAncmVtb3ZlSG92ZXJTdHlsZSc7XG5cdFx0dmFyIGVsZW1lbnQsIGksIGlsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRlbGVtZW50ID0gZWxlbWVudHNbaV07XG5cdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmdldERhdGFzZXRNZXRhKGVsZW1lbnQuX2RhdGFzZXRJbmRleCkuY29udHJvbGxlclttZXRob2RdKGVsZW1lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGV2ZW50SGFuZGxlcjogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRvb2x0aXAgPSBtZS50b29sdGlwO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVFdmVudCcsIFtlXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQnVmZmVyIGFueSB1cGRhdGUgY2FsbHMgc28gdGhhdCByZW5kZXJzIGRvIG5vdCBvY2N1clxuXHRcdG1lLl9idWZmZXJlZFJlbmRlciA9IHRydWU7XG5cdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cblx0XHR2YXIgY2hhbmdlZCA9IG1lLmhhbmRsZUV2ZW50KGUpO1xuXHRcdC8vIGZvciBzbW9vdGggdG9vbHRpcCBhbmltYXRpb25zIGlzc3VlICM0OTg5XG5cdFx0Ly8gdGhlIHRvb2x0aXAgc2hvdWxkIGJlIHRoZSBzb3VyY2Ugb2YgY2hhbmdlXG5cdFx0Ly8gQW5pbWF0aW9uIGNoZWNrIHdvcmthcm91bmQ6XG5cdFx0Ly8gdG9vbHRpcC5fc3RhcnQgd2lsbCBiZSBudWxsIHdoZW4gdG9vbHRpcCBpc24ndCBhbmltYXRpbmdcblx0XHRpZiAodG9vbHRpcCkge1xuXHRcdFx0Y2hhbmdlZCA9IHRvb2x0aXAuX3N0YXJ0XG5cdFx0XHRcdD8gdG9vbHRpcC5oYW5kbGVFdmVudChlKVxuXHRcdFx0XHQ6IGNoYW5nZWQgfCB0b29sdGlwLmhhbmRsZUV2ZW50KGUpO1xuXHRcdH1cblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckV2ZW50JywgW2VdKTtcblxuXHRcdHZhciBidWZmZXJlZFJlcXVlc3QgPSBtZS5fYnVmZmVyZWRSZXF1ZXN0O1xuXHRcdGlmIChidWZmZXJlZFJlcXVlc3QpIHtcblx0XHRcdC8vIElmIHdlIGhhdmUgYW4gdXBkYXRlIHRoYXQgd2FzIHRyaWdnZXJlZCwgd2UgbmVlZCB0byBkbyBhIG5vcm1hbCByZW5kZXJcblx0XHRcdG1lLnJlbmRlcihidWZmZXJlZFJlcXVlc3QpO1xuXHRcdH0gZWxzZSBpZiAoY2hhbmdlZCAmJiAhbWUuYW5pbWF0aW5nKSB7XG5cdFx0XHQvLyBJZiBlbnRlcmluZywgbGVhdmluZywgb3IgY2hhbmdpbmcgZWxlbWVudHMsIGFuaW1hdGUgdGhlIGNoYW5nZSB2aWEgcGl2b3Rcblx0XHRcdG1lLnN0b3AoKTtcblxuXHRcdFx0Ly8gV2Ugb25seSBuZWVkIHRvIHJlbmRlciBhdCB0aGlzIHBvaW50LiBVcGRhdGluZyB3aWxsIGNhdXNlIHNjYWxlcyB0byBiZVxuXHRcdFx0Ly8gcmVjb21wdXRlZCBnZW5lcmF0aW5nIGZsaWNrZXIgJiB1c2luZyBtb3JlIG1lbW9yeSB0aGFuIG5lY2Vzc2FyeS5cblx0XHRcdG1lLnJlbmRlcih7XG5cdFx0XHRcdGR1cmF0aW9uOiBtZS5vcHRpb25zLmhvdmVyLmFuaW1hdGlvbkR1cmF0aW9uLFxuXHRcdFx0XHRsYXp5OiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSBmYWxzZTtcblx0XHRtZS5fYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuXHRcdHJldHVybiBtZTtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCB0aGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNoYXJ0IG5lZWRzIHRvIHJlLXJlbmRlclxuXHQgKi9cblx0aGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucyB8fCB7fTtcblx0XHR2YXIgaG92ZXJPcHRpb25zID0gb3B0aW9ucy5ob3Zlcjtcblx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0bWUubGFzdEFjdGl2ZSA9IG1lLmxhc3RBY3RpdmUgfHwgW107XG5cblx0XHQvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgaG92ZXIgYW5kIHRvb2x0aXBzXG5cdFx0aWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuXHRcdFx0bWUuYWN0aXZlID0gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmFjdGl2ZSA9IG1lLmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgaG92ZXJPcHRpb25zLm1vZGUsIGhvdmVyT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Ly8gSW52b2tlIG9uSG92ZXIgaG9va1xuXHRcdC8vIE5lZWQgdG8gY2FsbCB3aXRoIG5hdGl2ZSBldmVudCBoZXJlIHRvIG5vdCBicmVhayBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayhvcHRpb25zLm9uSG92ZXIgfHwgb3B0aW9ucy5ob3Zlci5vbkhvdmVyLCBbZS5uYXRpdmUsIG1lLmFjdGl2ZV0sIG1lKTtcblxuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdGlmIChvcHRpb25zLm9uQ2xpY2spIHtcblx0XHRcdFx0Ly8gVXNlIGUubmF0aXZlIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdGlvbnMub25DbGljay5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUuYWN0aXZlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgc3R5bGluZyBmb3IgbGFzdCBhY3RpdmUgKGV2ZW4gaWYgaXQgbWF5IHN0aWxsIGJlIGFjdGl2ZSlcblx0XHRpZiAobWUubGFzdEFjdGl2ZS5sZW5ndGgpIHtcblx0XHRcdG1lLnVwZGF0ZUhvdmVyU3R5bGUobWUubGFzdEFjdGl2ZSwgaG92ZXJPcHRpb25zLm1vZGUsIGZhbHNlKTtcblx0XHR9XG5cblx0XHQvLyBCdWlsdCBpbiBob3ZlciBzdHlsaW5nXG5cdFx0aWYgKG1lLmFjdGl2ZS5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcblx0XHRcdG1lLnVwZGF0ZUhvdmVyU3R5bGUobWUuYWN0aXZlLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Y2hhbmdlZCA9ICFoZWxwZXJzJDEuYXJyYXlFcXVhbHMobWUuYWN0aXZlLCBtZS5sYXN0QWN0aXZlKTtcblxuXHRcdC8vIFJlbWVtYmVyIExhc3QgQWN0aXZlc1xuXHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5hY3RpdmU7XG5cblx0XHRyZXR1cm4gY2hhbmdlZDtcblx0fVxufSk7XG5cbi8qKlxuICogTk9URShTQikgV2UgYWN0dWFsbHkgZG9uJ3QgdXNlIHRoaXMgY29udGFpbmVyIGFueW1vcmUgYnV0IHdlIG5lZWQgdG8ga2VlcCBpdFxuICogZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuIFRob3VnaCwgaXQgY2FuIHN0aWxsIGJlIHVzZWZ1bCBmb3IgcGx1Z2lucyB0aGF0XG4gKiB3b3VsZCBuZWVkIHRvIHdvcmsgb24gbXVsdGlwbGUgY2hhcnRzPyFcbiAqL1xuQ2hhcnQuaW5zdGFuY2VzID0ge307XG5cbnZhciBjb3JlX2NvbnRyb2xsZXIgPSBDaGFydDtcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydCBpbnN0ZWFkLlxuICogQGNsYXNzIENoYXJ0LkNvbnRyb2xsZXJcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5DaGFydC5Db250cm9sbGVyID0gQ2hhcnQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZS5cbiAqIEBuYW1lc3BhY2UgQ2hhcnRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5DaGFydC50eXBlcyA9IHt9O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuY29uZmlnTWVyZ2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5jb25maWdNZXJnZSA9IG1lcmdlQ29uZmlnO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuc2NhbGVNZXJnZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycyQxLnNjYWxlTWVyZ2UgPSBtZXJnZVNjYWxlQ29uZmlnO1xuXG52YXIgY29yZV9oZWxwZXJzID0gZnVuY3Rpb24oKSB7XG5cblx0Ly8gLS0gQmFzaWMganMgdXRpbGl0eSBtZXRob2RzXG5cblx0aGVscGVycyQxLndoZXJlID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgZmlsdGVyQ2FsbGJhY2spIHtcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkoY29sbGVjdGlvbikgJiYgQXJyYXkucHJvdG90eXBlLmZpbHRlcikge1xuXHRcdFx0cmV0dXJuIGNvbGxlY3Rpb24uZmlsdGVyKGZpbHRlckNhbGxiYWNrKTtcblx0XHR9XG5cdFx0dmFyIGZpbHRlcmVkID0gW107XG5cblx0XHRoZWxwZXJzJDEuZWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoZmlsdGVyQ2FsbGJhY2soaXRlbSkpIHtcblx0XHRcdFx0ZmlsdGVyZWQucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBmaWx0ZXJlZDtcblx0fTtcblx0aGVscGVycyQxLmZpbmRJbmRleCA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXggP1xuXHRcdGZ1bmN0aW9uKGFycmF5LCBjYWxsYmFjaywgc2NvcGUpIHtcblx0XHRcdHJldHVybiBhcnJheS5maW5kSW5kZXgoY2FsbGJhY2ssIHNjb3BlKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG5cdFx0XHRzY29wZSA9IHNjb3BlID09PSB1bmRlZmluZWQgPyBhcnJheSA6IHNjb3BlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0aWYgKGNhbGxiYWNrLmNhbGwoc2NvcGUsIGFycmF5W2ldLCBpLCBhcnJheSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH07XG5cdGhlbHBlcnMkMS5maW5kTmV4dFdoZXJlID0gZnVuY3Rpb24oYXJyYXlUb1NlYXJjaCwgZmlsdGVyQ2FsbGJhY2ssIHN0YXJ0SW5kZXgpIHtcblx0XHQvLyBEZWZhdWx0IHRvIHN0YXJ0IG9mIHRoZSBhcnJheVxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzdGFydEluZGV4KSkge1xuXHRcdFx0c3RhcnRJbmRleCA9IC0xO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gc3RhcnRJbmRleCArIDE7IGkgPCBhcnJheVRvU2VhcmNoLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY3VycmVudEl0ZW0gPSBhcnJheVRvU2VhcmNoW2ldO1xuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGN1cnJlbnRJdGVtKSkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudEl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRoZWxwZXJzJDEuZmluZFByZXZpb3VzV2hlcmUgPSBmdW5jdGlvbihhcnJheVRvU2VhcmNoLCBmaWx0ZXJDYWxsYmFjaywgc3RhcnRJbmRleCkge1xuXHRcdC8vIERlZmF1bHQgdG8gZW5kIG9mIHRoZSBhcnJheVxuXHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzdGFydEluZGV4KSkge1xuXHRcdFx0c3RhcnRJbmRleCA9IGFycmF5VG9TZWFyY2gubGVuZ3RoO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gc3RhcnRJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgY3VycmVudEl0ZW0gPSBhcnJheVRvU2VhcmNoW2ldO1xuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGN1cnJlbnRJdGVtKSkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudEl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIC0tIE1hdGggbWV0aG9kc1xuXHRoZWxwZXJzJDEuaXNOdW1iZXIgPSBmdW5jdGlvbihuKSB7XG5cdFx0cmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcblx0fTtcblx0aGVscGVycyQxLmFsbW9zdEVxdWFscyA9IGZ1bmN0aW9uKHgsIHksIGVwc2lsb24pIHtcblx0XHRyZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgZXBzaWxvbjtcblx0fTtcblx0aGVscGVycyQxLmFsbW9zdFdob2xlID0gZnVuY3Rpb24oeCwgZXBzaWxvbikge1xuXHRcdHZhciByb3VuZGVkID0gTWF0aC5yb3VuZCh4KTtcblx0XHRyZXR1cm4gKCgocm91bmRlZCAtIGVwc2lsb24pIDwgeCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPiB4KSk7XG5cdH07XG5cdGhlbHBlcnMkMS5tYXggPSBmdW5jdGlvbihhcnJheSkge1xuXHRcdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24obWF4LCB2YWx1ZSkge1xuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KG1heCwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1heDtcblx0XHR9LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuXHR9O1xuXHRoZWxwZXJzJDEubWluID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKG1pbiwgdmFsdWUpIHtcblx0XHRcdGlmICghaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLm1pbihtaW4sIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtaW47XG5cdFx0fSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcblx0fTtcblx0aGVscGVycyQxLnNpZ24gPSBNYXRoLnNpZ24gP1xuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiBNYXRoLnNpZ24oeCk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0eCA9ICt4OyAvLyBjb252ZXJ0IHRvIGEgbnVtYmVyXG5cdFx0XHRpZiAoeCA9PT0gMCB8fCBpc05hTih4KSkge1xuXHRcdFx0XHRyZXR1cm4geDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB4ID4gMCA/IDEgOiAtMTtcblx0XHR9O1xuXHRoZWxwZXJzJDEubG9nMTAgPSBNYXRoLmxvZzEwID9cblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5sb2cxMCh4KTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHR2YXIgZXhwb25lbnQgPSBNYXRoLmxvZyh4KSAqIE1hdGguTE9HMTBFOyAvLyBNYXRoLkxPRzEwRSA9IDEgLyBNYXRoLkxOMTAuXG5cdFx0XHQvLyBDaGVjayBmb3Igd2hvbGUgcG93ZXJzIG9mIDEwLFxuXHRcdFx0Ly8gd2hpY2ggZHVlIHRvIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9yIHNob3VsZCBiZSBjb3JyZWN0ZWQuXG5cdFx0XHR2YXIgcG93ZXJPZjEwID0gTWF0aC5yb3VuZChleHBvbmVudCk7XG5cdFx0XHR2YXIgaXNQb3dlck9mMTAgPSB4ID09PSBNYXRoLnBvdygxMCwgcG93ZXJPZjEwKTtcblxuXHRcdFx0cmV0dXJuIGlzUG93ZXJPZjEwID8gcG93ZXJPZjEwIDogZXhwb25lbnQ7XG5cdFx0fTtcblx0aGVscGVycyQxLnRvUmFkaWFucyA9IGZ1bmN0aW9uKGRlZ3JlZXMpIHtcblx0XHRyZXR1cm4gZGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcblx0fTtcblx0aGVscGVycyQxLnRvRGVncmVlcyA9IGZ1bmN0aW9uKHJhZGlhbnMpIHtcblx0XHRyZXR1cm4gcmFkaWFucyAqICgxODAgLyBNYXRoLlBJKTtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG5cdCAqIGkuZS4gdGhlIG51bWJlciBvZiBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIE51bWJlci5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggLSBBIG51bWJlci5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhlbHBlcnMkMS5fZGVjaW1hbFBsYWNlcyA9IGZ1bmN0aW9uKHgpIHtcblx0XHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh4KSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgZSA9IDE7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcblx0XHRcdGUgKj0gMTA7XG5cdFx0XHRwKys7XG5cdFx0fVxuXHRcdHJldHVybiBwO1xuXHR9O1xuXG5cdC8vIEdldHMgdGhlIGFuZ2xlIGZyb20gdmVydGljYWwgdXByaWdodCB0byB0aGUgcG9pbnQgYWJvdXQgYSBjZW50cmUuXG5cdGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCA9IGZ1bmN0aW9uKGNlbnRyZVBvaW50LCBhbmdsZVBvaW50KSB7XG5cdFx0dmFyIGRpc3RhbmNlRnJvbVhDZW50ZXIgPSBhbmdsZVBvaW50LnggLSBjZW50cmVQb2ludC54O1xuXHRcdHZhciBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcblx0XHR2YXIgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuXG5cdFx0dmFyIGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcblxuXHRcdGlmIChhbmdsZSA8ICgtMC41ICogTWF0aC5QSSkpIHtcblx0XHRcdGFuZ2xlICs9IDIuMCAqIE1hdGguUEk7IC8vIG1ha2Ugc3VyZSB0aGUgcmV0dXJuZWQgYW5nbGUgaXMgaW4gdGhlIHJhbmdlIG9mICgtUEkvMiwgM1BJLzJdXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFuZ2xlOiBhbmdsZSxcblx0XHRcdGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcblx0XHR9O1xuXHR9O1xuXHRoZWxwZXJzJDEuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzID0gZnVuY3Rpb24ocHQxLCBwdDIpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHB0Mi54IC0gcHQxLngsIDIpICsgTWF0aC5wb3cocHQyLnkgLSBwdDEueSwgMikpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXG5cdCAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmFsaWFzUGl4ZWxcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqL1xuXHRoZWxwZXJzJDEuYWxpYXNQaXhlbCA9IGZ1bmN0aW9uKHBpeGVsV2lkdGgpIHtcblx0XHRyZXR1cm4gKHBpeGVsV2lkdGggJSAyID09PSAwKSA/IDAgOiAwLjU7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUgdG8gYXZvaWQgYW50aS1hbGlhc2luZyBibHVyXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWwgLSBBIHBpeGVsIHZhbHVlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIGVsZW1lbnQuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0aGVscGVycyQxLl9hbGlnblBpeGVsID0gZnVuY3Rpb24oY2hhcnQsIHBpeGVsLCB3aWR0aCkge1xuXHRcdHZhciBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG5cdFx0dmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xuXHR9O1xuXG5cdGhlbHBlcnMkMS5zcGxpbmVDdXJ2ZSA9IGZ1bmN0aW9uKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG5cdFx0Ly8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXG5cdFx0Ly8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG5cblx0XHQvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYWxzbyByZXNwZWN0IFwic2tpcHBlZFwiIHBvaW50c1xuXG5cdFx0dmFyIHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xuXHRcdHZhciBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG5cdFx0dmFyIG5leHQgPSBhZnRlclBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGFmdGVyUG9pbnQ7XG5cblx0XHR2YXIgZDAxID0gTWF0aC5zcXJ0KE1hdGgucG93KGN1cnJlbnQueCAtIHByZXZpb3VzLngsIDIpICsgTWF0aC5wb3coY3VycmVudC55IC0gcHJldmlvdXMueSwgMikpO1xuXHRcdHZhciBkMTIgPSBNYXRoLnNxcnQoTWF0aC5wb3cobmV4dC54IC0gY3VycmVudC54LCAyKSArIE1hdGgucG93KG5leHQueSAtIGN1cnJlbnQueSwgMikpO1xuXG5cdFx0dmFyIHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuXHRcdHZhciBzMTIgPSBkMTIgLyAoZDAxICsgZDEyKTtcblxuXHRcdC8vIElmIGFsbCBwb2ludHMgYXJlIHRoZSBzYW1lLCBzMDEgJiBzMDIgd2lsbCBiZSBpbmZcblx0XHRzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcblx0XHRzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcblxuXHRcdHZhciBmYSA9IHQgKiBzMDE7IC8vIHNjYWxpbmcgZmFjdG9yIGZvciB0cmlhbmdsZSBUYVxuXHRcdHZhciBmYiA9IHQgKiBzMTI7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0cHJldmlvdXM6IHtcblx0XHRcdFx0eDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG5cdFx0XHRcdHk6IGN1cnJlbnQueSAtIGZhICogKG5leHQueSAtIHByZXZpb3VzLnkpXG5cdFx0XHR9LFxuXHRcdFx0bmV4dDoge1xuXHRcdFx0XHR4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcblx0XHRcdFx0eTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcblx0XHRcdH1cblx0XHR9O1xuXHR9O1xuXHRoZWxwZXJzJDEuRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXHRoZWxwZXJzJDEuc3BsaW5lQ3VydmVNb25vdG9uZSA9IGZ1bmN0aW9uKHBvaW50cykge1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxuXHRcdC8vIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcblx0XHQvLyBiZXR3ZWVuIHRoZSBkYXRhc2V0IGRpc2NyZXRlIHBvaW50cyBkdWUgdG8gdGhlIGludGVycG9sYXRpb24uXG5cdFx0Ly8gU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxuXG5cdFx0dmFyIHBvaW50c1dpdGhUYW5nZW50cyA9IChwb2ludHMgfHwgW10pLm1hcChmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bW9kZWw6IHBvaW50Ll9tb2RlbCxcblx0XHRcdFx0ZGVsdGFLOiAwLFxuXHRcdFx0XHRtSzogMFxuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuXHRcdHZhciBwb2ludHNMZW4gPSBwb2ludHNXaXRoVGFuZ2VudHMubGVuZ3RoO1xuXHRcdHZhciBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50LCBwb2ludEFmdGVyO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuXHRcdFx0cG9pbnRDdXJyZW50ID0gcG9pbnRzV2l0aFRhbmdlbnRzW2ldO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRwb2ludEJlZm9yZSA9IGkgPiAwID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgLSAxXSA6IG51bGw7XG5cdFx0XHRwb2ludEFmdGVyID0gaSA8IHBvaW50c0xlbiAtIDEgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdIDogbnVsbDtcblx0XHRcdGlmIChwb2ludEFmdGVyICYmICFwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0dmFyIHNsb3BlRGVsdGFYID0gKHBvaW50QWZ0ZXIubW9kZWwueCAtIHBvaW50Q3VycmVudC5tb2RlbC54KTtcblxuXHRcdFx0XHQvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcblx0XHRcdFx0cG9pbnRDdXJyZW50LmRlbHRhSyA9IHNsb3BlRGVsdGFYICE9PSAwID8gKHBvaW50QWZ0ZXIubW9kZWwueSAtIHBvaW50Q3VycmVudC5tb2RlbC55KSAvIHNsb3BlRGVsdGFYIDogMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFwb2ludEJlZm9yZSB8fCBwb2ludEJlZm9yZS5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHR9IGVsc2UgaWYgKCFwb2ludEFmdGVyIHx8IHBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEJlZm9yZS5kZWx0YUs7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuc2lnbihwb2ludEJlZm9yZS5kZWx0YUspICE9PSB0aGlzLnNpZ24ocG9pbnRDdXJyZW50LmRlbHRhSykpIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IChwb2ludEJlZm9yZS5kZWx0YUsgKyBwb2ludEN1cnJlbnQuZGVsdGFLKSAvIDI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xuXHRcdHZhciBhbHBoYUssIGJldGFLLCB0YXVLLCBzcXVhcmVkTWFnbml0dWRlO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdHBvaW50QWZ0ZXIgPSBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwIHx8IHBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGhlbHBlcnMkMS5hbG1vc3RFcXVhbHMocG9pbnRDdXJyZW50LmRlbHRhSywgMCwgdGhpcy5FUFNJTE9OKSkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEFmdGVyLm1LID0gMDtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGFscGhhSyA9IHBvaW50Q3VycmVudC5tSyAvIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0XHRiZXRhSyA9IHBvaW50QWZ0ZXIubUsgLyBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0c3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XG5cdFx0XHRpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcblx0XHRcdHBvaW50Q3VycmVudC5tSyA9IGFscGhhSyAqIHRhdUsgKiBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0cG9pbnRBZnRlci5tSyA9IGJldGFLICogdGF1SyAqIHBvaW50Q3VycmVudC5kZWx0YUs7XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcHV0ZSBjb250cm9sIHBvaW50c1xuXHRcdHZhciBkZWx0YVg7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XG5cdFx0XHRpZiAocG9pbnRDdXJyZW50Lm1vZGVsLnNraXApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHBvaW50QmVmb3JlID0gaSA+IDAgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSAtIDFdIDogbnVsbDtcblx0XHRcdHBvaW50QWZ0ZXIgPSBpIDwgcG9pbnRzTGVuIC0gMSA/IHBvaW50c1dpdGhUYW5nZW50c1tpICsgMV0gOiBudWxsO1xuXHRcdFx0aWYgKHBvaW50QmVmb3JlICYmICFwb2ludEJlZm9yZS5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGRlbHRhWCA9IChwb2ludEN1cnJlbnQubW9kZWwueCAtIHBvaW50QmVmb3JlLm1vZGVsLngpIC8gMztcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IHBvaW50Q3VycmVudC5tb2RlbC54IC0gZGVsdGFYO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gcG9pbnRDdXJyZW50Lm1vZGVsLnkgLSBkZWx0YVggKiBwb2ludEN1cnJlbnQubUs7XG5cdFx0XHR9XG5cdFx0XHRpZiAocG9pbnRBZnRlciAmJiAhcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGRlbHRhWCA9IChwb2ludEFmdGVyLm1vZGVsLnggLSBwb2ludEN1cnJlbnQubW9kZWwueCkgLyAzO1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubW9kZWwuY29udHJvbFBvaW50TmV4dFggPSBwb2ludEN1cnJlbnQubW9kZWwueCArIGRlbHRhWDtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludE5leHRZID0gcG9pbnRDdXJyZW50Lm1vZGVsLnkgKyBkZWx0YVggKiBwb2ludEN1cnJlbnQubUs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRoZWxwZXJzJDEubmV4dEl0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xuXHRcdGlmIChsb29wKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPj0gY29sbGVjdGlvbi5sZW5ndGggLSAxID8gY29sbGVjdGlvblswXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggKyAxXTtcblx0fTtcblx0aGVscGVycyQxLnByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGluZGV4LCBsb29wKSB7XG5cdFx0aWYgKGxvb3ApIHtcblx0XHRcdHJldHVybiBpbmRleCA8PSAwID8gY29sbGVjdGlvbltjb2xsZWN0aW9uLmxlbmd0aCAtIDFdIDogY29sbGVjdGlvbltpbmRleCAtIDFdO1xuXHRcdH1cblx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bMF0gOiBjb2xsZWN0aW9uW2luZGV4IC0gMV07XG5cdH07XG5cdC8vIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXG5cdGhlbHBlcnMkMS5uaWNlTnVtID0gZnVuY3Rpb24ocmFuZ2UsIHJvdW5kKSB7XG5cdFx0dmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAocmFuZ2UpKTtcblx0XHR2YXIgZnJhY3Rpb24gPSByYW5nZSAvIE1hdGgucG93KDEwLCBleHBvbmVudCk7XG5cdFx0dmFyIG5pY2VGcmFjdGlvbjtcblxuXHRcdGlmIChyb3VuZCkge1xuXHRcdFx0aWYgKGZyYWN0aW9uIDwgMS41KSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDwgMykge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAyO1xuXHRcdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8IDcpIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gNTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDEwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMS4wKSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAxO1xuXHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPD0gMikge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gMjtcblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDUpIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDEwO1xuXHRcdH1cblxuXHRcdHJldHVybiBuaWNlRnJhY3Rpb24gKiBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuXHR9O1xuXHQvLyBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbCAtIGh0dHBzOi8vd3d3LnBhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cblx0aGVscGVycyQxLnJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHR3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdFx0XHRmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG5cdFx0XHR9O1xuXHR9KCkpO1xuXHQvLyAtLSBET00gbWV0aG9kc1xuXHRoZWxwZXJzJDEuZ2V0UmVsYXRpdmVQb3NpdGlvbiA9IGZ1bmN0aW9uKGV2dCwgY2hhcnQpIHtcblx0XHR2YXIgbW91c2VYLCBtb3VzZVk7XG5cdFx0dmFyIGUgPSBldnQub3JpZ2luYWxFdmVudCB8fCBldnQ7XG5cdFx0dmFyIGNhbnZhcyA9IGV2dC50YXJnZXQgfHwgZXZ0LnNyY0VsZW1lbnQ7XG5cdFx0dmFyIGJvdW5kaW5nUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdHZhciB0b3VjaGVzID0gZS50b3VjaGVzO1xuXHRcdGlmICh0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0bW91c2VYID0gdG91Y2hlc1swXS5jbGllbnRYO1xuXHRcdFx0bW91c2VZID0gdG91Y2hlc1swXS5jbGllbnRZO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1vdXNlWCA9IGUuY2xpZW50WDtcblx0XHRcdG1vdXNlWSA9IGUuY2xpZW50WTtcblx0XHR9XG5cblx0XHQvLyBTY2FsZSBtb3VzZSBjb29yZGluYXRlcyBpbnRvIGNhbnZhcyBjb29yZGluYXRlc1xuXHRcdC8vIGJ5IGZvbGxvd2luZyB0aGUgcGF0dGVybiBsYWlkIG91dCBieSAnamVycnlqJyBpbiB0aGUgY29tbWVudHMgb2Zcblx0XHQvLyBodHRwczovL3d3dy5odG1sNWNhbnZhc3R1dG9yaWFscy5jb20vYWR2YW5jZWQvaHRtbDUtY2FudmFzLW1vdXNlLWNvb3JkaW5hdGVzL1xuXHRcdHZhciBwYWRkaW5nTGVmdCA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctbGVmdCcpKTtcblx0XHR2YXIgcGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctdG9wJykpO1xuXHRcdHZhciBwYWRkaW5nUmlnaHQgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLXJpZ2h0JykpO1xuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1ib3R0b20nKSk7XG5cdFx0dmFyIHdpZHRoID0gYm91bmRpbmdSZWN0LnJpZ2h0IC0gYm91bmRpbmdSZWN0LmxlZnQgLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodDtcblx0XHR2YXIgaGVpZ2h0ID0gYm91bmRpbmdSZWN0LmJvdHRvbSAtIGJvdW5kaW5nUmVjdC50b3AgLSBwYWRkaW5nVG9wIC0gcGFkZGluZ0JvdHRvbTtcblxuXHRcdC8vIFdlIGRpdmlkZSBieSB0aGUgY3VycmVudCBkZXZpY2UgcGl4ZWwgcmF0aW8sIGJlY2F1c2UgdGhlIGNhbnZhcyBpcyBzY2FsZWQgdXAgYnkgdGhhdCBhbW91bnQgaW4gZWFjaCBkaXJlY3Rpb24uIEhvd2V2ZXJcblx0XHQvLyB0aGUgYmFja2VuZCBtb2RlbCBpcyBpbiB1bnNjYWxlZCBjb29yZGluYXRlcy4gU2luY2Ugd2UgYXJlIGdvaW5nIHRvIGRlYWwgd2l0aCBvdXIgbW9kZWwgY29vcmRpbmF0ZXMsIHdlIGdvIGJhY2sgaGVyZVxuXHRcdG1vdXNlWCA9IE1hdGgucm91bmQoKG1vdXNlWCAtIGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFkZGluZ0xlZnQpIC8gKHdpZHRoKSAqIGNhbnZhcy53aWR0aCAvIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKTtcblx0XHRtb3VzZVkgPSBNYXRoLnJvdW5kKChtb3VzZVkgLSBib3VuZGluZ1JlY3QudG9wIC0gcGFkZGluZ1RvcCkgLyAoaGVpZ2h0KSAqIGNhbnZhcy5oZWlnaHQgLyBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogbW91c2VYLFxuXHRcdFx0eTogbW91c2VZXG5cdFx0fTtcblxuXHR9O1xuXG5cdC8vIFByaXZhdGUgaGVscGVyIGZ1bmN0aW9uIHRvIGNvbnZlcnQgbWF4LXdpZHRoL21heC1oZWlnaHQgdmFsdWVzIHRoYXQgbWF5IGJlIHBlcmNlbnRhZ2VzIGludG8gYSBudW1iZXJcblx0ZnVuY3Rpb24gcGFyc2VNYXhTdHlsZShzdHlsZVZhbHVlLCBub2RlLCBwYXJlbnRQcm9wZXJ0eSkge1xuXHRcdHZhciB2YWx1ZUluUGl4ZWxzO1xuXHRcdGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG5cblx0XHRcdGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcblx0XHRcdFx0Ly8gcGVyY2VudGFnZSAqIHNpemUgaW4gZGltZW5zaW9uXG5cdFx0XHRcdHZhbHVlSW5QaXhlbHMgPSB2YWx1ZUluUGl4ZWxzIC8gMTAwICogbm9kZS5wYXJlbnROb2RlW3BhcmVudFByb3BlcnR5XTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlSW5QaXhlbHM7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBpZiB0aGUgZ2l2ZW4gdmFsdWUgY29udGFpbnMgYW4gZWZmZWN0aXZlIGNvbnN0cmFpbnQuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0NvbnN0cmFpbmVkVmFsdWUodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gJ25vbmUnO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG1heCB3aWR0aCBvciBoZWlnaHQgb2YgdGhlIGdpdmVuIERPTSBub2RlIGluIGEgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxlIGZhc2hpb25cblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tTm9kZSAtIHRoZSBub2RlIHRvIGNoZWNrIHRoZSBjb25zdHJhaW50IG9uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtYXhTdHlsZSAtIHRoZSBzdHlsZSB0aGF0IGRlZmluZXMgdGhlIG1heGltdW0gZm9yIHRoZSBkaXJlY3Rpb24gd2UgYXJlIHVzaW5nICgnbWF4LXdpZHRoJyAvICdtYXgtaGVpZ2h0Jylcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBlcmNlbnRhZ2VQcm9wZXJ0eSAtIHByb3BlcnR5IG9mIHBhcmVudCB0byB1c2Ugd2hlbiBjYWxjdWxhdGluZyB3aWR0aCBhcyBhIHBlcmNlbnRhZ2Vcblx0ICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cubmF0aGFuYWVsam9uZXMuY29tL2Jsb2cvMjAxMy9yZWFkaW5nLW1heC13aWR0aC1jcm9zcy1icm93c2VyfVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCBtYXhTdHlsZSwgcGVyY2VudGFnZVByb3BlcnR5KSB7XG5cdFx0dmFyIHZpZXcgPSBkb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHR2YXIgcGFyZW50Tm9kZSA9IGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZShkb21Ob2RlKTtcblx0XHR2YXIgY29uc3RyYWluZWROb2RlID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpW21heFN0eWxlXTtcblx0XHR2YXIgY29uc3RyYWluZWRDb250YWluZXIgPSB2aWV3LmdldENvbXB1dGVkU3R5bGUocGFyZW50Tm9kZSlbbWF4U3R5bGVdO1xuXHRcdHZhciBoYXNDTm9kZSA9IGlzQ29uc3RyYWluZWRWYWx1ZShjb25zdHJhaW5lZE5vZGUpO1xuXHRcdHZhciBoYXNDQ29udGFpbmVyID0gaXNDb25zdHJhaW5lZFZhbHVlKGNvbnN0cmFpbmVkQ29udGFpbmVyKTtcblx0XHR2YXIgaW5maW5pdHkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cblx0XHRpZiAoaGFzQ05vZGUgfHwgaGFzQ0NvbnRhaW5lcikge1xuXHRcdFx0cmV0dXJuIE1hdGgubWluKFxuXHRcdFx0XHRoYXNDTm9kZSA/IHBhcnNlTWF4U3R5bGUoY29uc3RyYWluZWROb2RlLCBkb21Ob2RlLCBwZXJjZW50YWdlUHJvcGVydHkpIDogaW5maW5pdHksXG5cdFx0XHRcdGhhc0NDb250YWluZXIgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkQ29udGFpbmVyLCBwYXJlbnROb2RlLCBwZXJjZW50YWdlUHJvcGVydHkpIDogaW5maW5pdHkpO1xuXHRcdH1cblxuXHRcdHJldHVybiAnbm9uZSc7XG5cdH1cblx0Ly8gcmV0dXJucyBOdW1iZXIgb3IgdW5kZWZpbmVkIGlmIG5vIGNvbnN0cmFpbnRcblx0aGVscGVycyQxLmdldENvbnN0cmFpbnRXaWR0aCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHRyZXR1cm4gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCAnbWF4LXdpZHRoJywgJ2NsaWVudFdpZHRoJyk7XG5cdH07XG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XG5cdGhlbHBlcnMkMS5nZXRDb25zdHJhaW50SGVpZ2h0ID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHJldHVybiBnZXRDb25zdHJhaW50RGltZW5zaW9uKGRvbU5vZGUsICdtYXgtaGVpZ2h0JywgJ2NsaWVudEhlaWdodCcpO1xuXHR9O1xuXHQvKipcblx0ICogQHByaXZhdGVcbiBcdCAqL1xuXHRoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcgPSBmdW5jdGlvbihjb250YWluZXIsIHBhZGRpbmcsIHBhcmVudERpbWVuc2lvbikge1xuXHRcdHBhZGRpbmcgPSBoZWxwZXJzJDEuZ2V0U3R5bGUoY29udGFpbmVyLCBwYWRkaW5nKTtcblxuXHRcdHJldHVybiBwYWRkaW5nLmluZGV4T2YoJyUnKSA+IC0xID8gcGFyZW50RGltZW5zaW9uICogcGFyc2VJbnQocGFkZGluZywgMTApIC8gMTAwIDogcGFyc2VJbnQocGFkZGluZywgMTApO1xuXHR9O1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZSA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXHRcdGlmIChwYXJlbnQgJiYgcGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuXHRcdFx0cGFyZW50ID0gcGFyZW50Lmhvc3Q7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJlbnQ7XG5cdH07XG5cdGhlbHBlcnMkMS5nZXRNYXhpbXVtV2lkdGggPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0dmFyIGNvbnRhaW5lciA9IGhlbHBlcnMkMS5fZ2V0UGFyZW50Tm9kZShkb21Ob2RlKTtcblx0XHRpZiAoIWNvbnRhaW5lcikge1xuXHRcdFx0cmV0dXJuIGRvbU5vZGUuY2xpZW50V2lkdGg7XG5cdFx0fVxuXG5cdFx0dmFyIGNsaWVudFdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuXHRcdHZhciBwYWRkaW5nTGVmdCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLWxlZnQnLCBjbGllbnRXaWR0aCk7XG5cdFx0dmFyIHBhZGRpbmdSaWdodCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLXJpZ2h0JywgY2xpZW50V2lkdGgpO1xuXG5cdFx0dmFyIHcgPSBjbGllbnRXaWR0aCAtIHBhZGRpbmdMZWZ0IC0gcGFkZGluZ1JpZ2h0O1xuXHRcdHZhciBjdyA9IGhlbHBlcnMkMS5nZXRDb25zdHJhaW50V2lkdGgoZG9tTm9kZSk7XG5cdFx0cmV0dXJuIGlzTmFOKGN3KSA/IHcgOiBNYXRoLm1pbih3LCBjdyk7XG5cdH07XG5cdGhlbHBlcnMkMS5nZXRNYXhpbXVtSGVpZ2h0ID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHZhciBjb250YWluZXIgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XG5cdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdHJldHVybiBkb21Ob2RlLmNsaWVudEhlaWdodDtcblx0XHR9XG5cblx0XHR2YXIgY2xpZW50SGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcblx0XHR2YXIgcGFkZGluZ1RvcCA9IGhlbHBlcnMkMS5fY2FsY3VsYXRlUGFkZGluZyhjb250YWluZXIsICdwYWRkaW5nLXRvcCcsIGNsaWVudEhlaWdodCk7XG5cdFx0dmFyIHBhZGRpbmdCb3R0b20gPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1ib3R0b20nLCBjbGllbnRIZWlnaHQpO1xuXG5cdFx0dmFyIGggPSBjbGllbnRIZWlnaHQgLSBwYWRkaW5nVG9wIC0gcGFkZGluZ0JvdHRvbTtcblx0XHR2YXIgY2ggPSBoZWxwZXJzJDEuZ2V0Q29uc3RyYWludEhlaWdodChkb21Ob2RlKTtcblx0XHRyZXR1cm4gaXNOYU4oY2gpID8gaCA6IE1hdGgubWluKGgsIGNoKTtcblx0fTtcblx0aGVscGVycyQxLmdldFN0eWxlID0gZnVuY3Rpb24oZWwsIHByb3BlcnR5KSB7XG5cdFx0cmV0dXJuIGVsLmN1cnJlbnRTdHlsZSA/XG5cdFx0XHRlbC5jdXJyZW50U3R5bGVbcHJvcGVydHldIDpcblx0XHRcdGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuXHR9O1xuXHRoZWxwZXJzJDEucmV0aW5hU2NhbGUgPSBmdW5jdGlvbihjaGFydCwgZm9yY2VSYXRpbykge1xuXHRcdHZhciBwaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgfHwgMTtcblx0XHRpZiAocGl4ZWxSYXRpbyA9PT0gMSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0dmFyIGhlaWdodCA9IGNoYXJ0LmhlaWdodDtcblx0XHR2YXIgd2lkdGggPSBjaGFydC53aWR0aDtcblxuXHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcblx0XHRjaGFydC5jdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cblx0XHQvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxuXHRcdC8vIG1ha2luZyB0aGUgY2hhcnQgdmlzdWFsbHkgYmlnZ2VyLCBzbyBsZXQncyBlbmZvcmNlIGl0IHRvIHRoZSBcImNvcnJlY3RcIiB2YWx1ZXMuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNTc1XG5cdFx0aWYgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpIHtcblx0XHRcdGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdFx0Y2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHRcdH1cblx0fTtcblx0Ly8gLS0gQ2FudmFzIG1ldGhvZHNcblx0aGVscGVycyQxLmZvbnRTdHJpbmcgPSBmdW5jdGlvbihwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xuXHRcdHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG5cdH07XG5cdGhlbHBlcnMkMS5sb25nZXN0VGV4dCA9IGZ1bmN0aW9uKGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcblx0XHRjYWNoZSA9IGNhY2hlIHx8IHt9O1xuXHRcdHZhciBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG5cdFx0dmFyIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcblxuXHRcdGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XG5cdFx0XHRkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuXHRcdFx0Z2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuXHRcdFx0Y2FjaGUuZm9udCA9IGZvbnQ7XG5cdFx0fVxuXG5cdFx0Y3R4LmZvbnQgPSBmb250O1xuXHRcdHZhciBsb25nZXN0ID0gMDtcblx0XHRoZWxwZXJzJDEuZWFjaChhcnJheU9mVGhpbmdzLCBmdW5jdGlvbih0aGluZykge1xuXHRcdFx0Ly8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG5cdFx0XHRpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiBoZWxwZXJzJDEuaXNBcnJheSh0aGluZykgIT09IHRydWUpIHtcblx0XHRcdFx0bG9uZ2VzdCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG5cdFx0XHR9IGVsc2UgaWYgKGhlbHBlcnMkMS5pc0FycmF5KHRoaW5nKSkge1xuXHRcdFx0XHQvLyBpZiBpdCBpcyBhbiBhcnJheSBsZXRzIG1lYXN1cmUgZWFjaCBlbGVtZW50XG5cdFx0XHRcdC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cblx0XHRcdFx0aGVscGVycyQxLmVhY2godGhpbmcsIGZ1bmN0aW9uKG5lc3RlZFRoaW5nKSB7XG5cdFx0XHRcdFx0Ly8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG5cdFx0XHRcdFx0aWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWhlbHBlcnMkMS5pc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuXHRcdFx0XHRcdFx0bG9uZ2VzdCA9IGhlbHBlcnMkMS5tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHZhciBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG5cdFx0aWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuXHRcdFx0XHRkZWxldGUgZGF0YVtnY1tpXV07XG5cdFx0XHR9XG5cdFx0XHRnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9uZ2VzdDtcblx0fTtcblx0aGVscGVycyQxLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24oY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgc3RyaW5nKSB7XG5cdFx0dmFyIHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcblx0XHRpZiAoIXRleHRXaWR0aCkge1xuXHRcdFx0dGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG5cdFx0XHRnYy5wdXNoKHN0cmluZyk7XG5cdFx0fVxuXHRcdGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG5cdFx0XHRsb25nZXN0ID0gdGV4dFdpZHRoO1xuXHRcdH1cblx0XHRyZXR1cm4gbG9uZ2VzdDtcblx0fTtcblx0aGVscGVycyQxLm51bWJlck9mTGFiZWxMaW5lcyA9IGZ1bmN0aW9uKGFycmF5T2ZUaGluZ3MpIHtcblx0XHR2YXIgbnVtYmVyT2ZMaW5lcyA9IDE7XG5cdFx0aGVscGVycyQxLmVhY2goYXJyYXlPZlRoaW5ncywgZnVuY3Rpb24odGhpbmcpIHtcblx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aGluZykpIHtcblx0XHRcdFx0aWYgKHRoaW5nLmxlbmd0aCA+IG51bWJlck9mTGluZXMpIHtcblx0XHRcdFx0XHRudW1iZXJPZkxpbmVzID0gdGhpbmcubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIG51bWJlck9mTGluZXM7XG5cdH07XG5cblx0aGVscGVycyQxLmNvbG9yID0gIWNoYXJ0anNDb2xvciA/XG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0NvbG9yLmpzIG5vdCBmb3VuZCEnKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0LyogZ2xvYmFsIENhbnZhc0dyYWRpZW50ICovXG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCkge1xuXHRcdFx0XHR2YWx1ZSA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNoYXJ0anNDb2xvcih2YWx1ZSk7XG5cdFx0fTtcblxuXHRoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvciA9IGZ1bmN0aW9uKGNvbG9yVmFsdWUpIHtcblx0XHQvKiBnbG9iYWwgQ2FudmFzUGF0dGVybiAqL1xuXHRcdHJldHVybiAoY29sb3JWYWx1ZSBpbnN0YW5jZW9mIENhbnZhc1BhdHRlcm4gfHwgY29sb3JWYWx1ZSBpbnN0YW5jZW9mIENhbnZhc0dyYWRpZW50KSA/XG5cdFx0XHRjb2xvclZhbHVlIDpcblx0XHRcdGhlbHBlcnMkMS5jb2xvcihjb2xvclZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLnJnYlN0cmluZygpO1xuXHR9O1xufTtcblxuZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG5cdHRocm93IG5ldyBFcnJvcihcblx0XHQnVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBlaXRoZXIgbm8gYWRhcHRlciBjYW4gJyArXG5cdFx0J2JlIGZvdW5kIG9yIGFuIGluY29tcGxldGUgaW50ZWdyYXRpb24gd2FzIHByb3ZpZGVkLidcblx0KTtcbn1cblxuLyoqXG4gKiBEYXRlIGFkYXB0ZXIgKGN1cnJlbnQgdXNlZCBieSB0aGUgdGltZSBzY2FsZSlcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlXG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8qKlxuICogQ3VycmVudGx5IHN1cHBvcnRlZCB1bml0IHN0cmluZyB2YWx1ZXMuXG4gKiBAdHlwZWRlZiB7KCdtaWxsaXNlY29uZCd8J3NlY29uZCd8J21pbnV0ZSd8J2hvdXInfCdkYXknfCd3ZWVrJ3wnbW9udGgnfCdxdWFydGVyJ3wneWVhcicpfVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG5hbWUgVW5pdFxuICovXG5cbi8qKlxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIERhdGVBZGFwdGVyKG9wdGlvbnMpIHtcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbn1cblxuaGVscGVycyQxLmV4dGVuZChEYXRlQWRhcHRlci5wcm90b3R5cGUsIC8qKiBAbGVuZHMgRGF0ZUFkYXB0ZXIgKi8ge1xuXHQvKipcblx0ICogUmV0dXJucyBhIG1hcCBvZiB0aW1lIGZvcm1hdHMgZm9yIHRoZSBzdXBwb3J0ZWQgZm9ybWF0dGluZyB1bml0cyBkZWZpbmVkXG5cdCAqIGluIFVuaXQgYXMgd2VsbCBhcyAnZGF0ZXRpbWUnIHJlcHJlc2VudGluZyBhIGRldGFpbGVkIGRhdGUvdGltZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHt7c3RyaW5nOiBzdHJpbmd9fVxuXHQgKi9cblx0Zm9ybWF0czogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIFBhcnNlcyB0aGUgZ2l2ZW4gYHZhbHVlYCBhbmQgcmV0dXJuIHRoZSBhc3NvY2lhdGVkIHRpbWVzdGFtcC5cblx0ICogQHBhcmFtIHthbnl9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHBhcnNlICh1c3VhbGx5IGNvbWVzIGZyb20gdGhlIGRhdGEpXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbZm9ybWF0XSAtIHRoZSBleHBlY3RlZCBkYXRhIGZvcm1hdFxuXHQgKiBAcmV0dXJucyB7KG51bWJlcnxudWxsKX1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRwYXJzZTogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRlIGluIHRoZSBzcGVjaWZpZWQgYGZvcm1hdGAgZm9yIGEgZ2l2ZW4gYHRpbWVzdGFtcGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgdGltZXN0YW1wIHRvIGZvcm1hdFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IC0gdGhlIGRhdGUvdGltZSB0b2tlblxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0Zm9ybWF0OiBhYnN0cmFjdCxcblxuXHQvKipcblx0ICogQWRkcyB0aGUgc3BlY2lmaWVkIGBhbW91bnRgIG9mIGB1bml0YCB0byB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IHRvIGFkZFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGFkZDogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBgdW5pdGAgYmV0d2VlbiB0aGUgZ2l2ZW4gdGltZXN0YW1wcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIHRoZSBpbnB1dCB0aW1lc3RhbXAgKHJlZmVyZW5jZSlcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbiAtIHRoZSB0aW1lc3RhbXAgdG8gc3Vic3RyYWN0XG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0ZGlmZjogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgc3RhcnQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dlZWtkYXldIC0gdGhlIElTTyBkYXkgb2YgdGhlIHdlZWsgd2l0aCAxIGJlaW5nIE1vbmRheVxuXHQgKiBhbmQgNyBiZWluZyBTdW5kYXkgKG9ubHkgbmVlZGVkIGlmIHBhcmFtICp1bml0KiBpcyBgaXNvV2Vla2ApLlxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdHN0YXJ0T2Y6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGVuZCBvZiBgdW5pdGAgZm9yIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0ZW5kT2Y6IGFic3RyYWN0LFxuXG5cdC8vIERFUFJFQ0FUSU9OU1xuXG5cdC8qKlxuXHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3Igc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbCgpLFxuXHQgKiB0aGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBvbmx5IGJ5IHRoZSBtb21lbnQgYWRhcHRlci5cblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuXHQgKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY3JlYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxufSk7XG5cbkRhdGVBZGFwdGVyLm92ZXJyaWRlID0gZnVuY3Rpb24obWVtYmVycykge1xuXHRoZWxwZXJzJDEuZXh0ZW5kKERhdGVBZGFwdGVyLnByb3RvdHlwZSwgbWVtYmVycyk7XG59O1xuXG52YXIgX2RhdGUgPSBEYXRlQWRhcHRlcjtcblxudmFyIGNvcmVfYWRhcHRlcnMgPSB7XG5cdF9kYXRlOiBfZGF0ZVxufTtcblxuLyoqXG4gKiBOYW1lc3BhY2UgdG8gaG9sZCBzdGF0aWMgdGljayBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrc1xuICovXG52YXIgY29yZV90aWNrcyA9IHtcblx0LyoqXG5cdCAqIE5hbWVzcGFjZSB0byBob2xkIGZvcm1hdHRlcnMgZm9yIGRpZmZlcmVudCB0eXBlcyBvZiB0aWNrc1xuXHQgKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnNcblx0ICovXG5cdGZvcm1hdHRlcnM6IHtcblx0XHQvKipcblx0XHQgKiBGb3JtYXR0ZXIgZm9yIHZhbHVlIGxhYmVsc1xuXHRcdCAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy52YWx1ZXNcblx0XHQgKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGRpc3BsYXlcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW119IHRoZSBsYWJlbCB0byBkaXNwbGF5XG5cdFx0ICovXG5cdFx0dmFsdWVzOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGhlbHBlcnMkMS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogJycgKyB2YWx1ZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0dGVyIGZvciBsaW5lYXIgbnVtZXJpYyB0aWNrc1xuXHRcdCAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5saW5lYXJcblx0XHQgKiBAcGFyYW0gdGlja1ZhbHVlIHtudW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcblx0XHQgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuXHRcdCAqIEBwYXJhbSB0aWNrcyB7bnVtYmVyW119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXG5cdFx0ICovXG5cdFx0bGluZWFyOiBmdW5jdGlvbih0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBsb3RzIG9mIHRpY2tzLCBkb24ndCB1c2UgdGhlIG9uZXNcblx0XHRcdHZhciBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXSAtIHRpY2tzWzFdIDogdGlja3NbMV0gLSB0aWNrc1swXTtcblxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIG51bWJlciBsaWtlIDIuNSBhcyB0aGUgZGVsdGEsIGZpZ3VyZSBvdXQgaG93IG1hbnkgZGVjaW1hbCBwbGFjZXMgd2UgbmVlZFxuXHRcdFx0aWYgKE1hdGguYWJzKGRlbHRhKSA+IDEpIHtcblx0XHRcdFx0aWYgKHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XG5cdFx0XHRcdFx0Ly8gbm90IGFuIGludGVnZXJcblx0XHRcdFx0XHRkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbG9nRGVsdGEgPSBoZWxwZXJzJDEubG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcblx0XHRcdHZhciB0aWNrU3RyaW5nID0gJyc7XG5cblx0XHRcdGlmICh0aWNrVmFsdWUgIT09IDApIHtcblx0XHRcdFx0dmFyIG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdKSk7XG5cdFx0XHRcdGlmIChtYXhUaWNrIDwgMWUtNCkgeyAvLyBhbGwgdGlja3MgYXJlIHNtYWxsIG51bWJlcnM7IHVzZSBzY2llbnRpZmljIG5vdGF0aW9uXG5cdFx0XHRcdFx0dmFyIGxvZ1RpY2sgPSBoZWxwZXJzJDEubG9nMTAoTWF0aC5hYnModGlja1ZhbHVlKSk7XG5cdFx0XHRcdFx0dGlja1N0cmluZyA9IHRpY2tWYWx1ZS50b0V4cG9uZW50aWFsKE1hdGguZmxvb3IobG9nVGljaykgLSBNYXRoLmZsb29yKGxvZ0RlbHRhKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIG51bURlY2ltYWwgPSAtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpO1xuXHRcdFx0XHRcdG51bURlY2ltYWwgPSBNYXRoLm1heChNYXRoLm1pbihudW1EZWNpbWFsLCAyMCksIDApOyAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xuXHRcdFx0XHRcdHRpY2tTdHJpbmcgPSB0aWNrVmFsdWUudG9GaXhlZChudW1EZWNpbWFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGlja1N0cmluZyA9ICcwJzsgLy8gbmV2ZXIgc2hvdyBkZWNpbWFsIHBsYWNlcyBmb3IgMFxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGlja1N0cmluZztcblx0XHR9LFxuXG5cdFx0bG9nYXJpdGhtaWM6IGZ1bmN0aW9uKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG5cdFx0XHR2YXIgcmVtYWluID0gdGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh0aWNrVmFsdWUpKSkpO1xuXG5cdFx0XHRpZiAodGlja1ZhbHVlID09PSAwKSB7XG5cdFx0XHRcdHJldHVybiAnMCc7XG5cdFx0XHR9IGVsc2UgaWYgKHJlbWFpbiA9PT0gMSB8fCByZW1haW4gPT09IDIgfHwgcmVtYWluID09PSA1IHx8IGluZGV4ID09PSAwIHx8IGluZGV4ID09PSB0aWNrcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdHJldHVybiB0aWNrVmFsdWUudG9FeHBvbmVudGlhbCgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0fVxufTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDkgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgdmFsdWVBdEluZGV4T3JEZWZhdWx0ID0gaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdzY2FsZScsIHtcblx0ZGlzcGxheTogdHJ1ZSxcblx0cG9zaXRpb246ICdsZWZ0Jyxcblx0b2Zmc2V0OiBmYWxzZSxcblxuXHQvLyBncmlkIGxpbmUgc2V0dGluZ3Ncblx0Z3JpZExpbmVzOiB7XG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXG5cdFx0bGluZVdpZHRoOiAxLFxuXHRcdGRyYXdCb3JkZXI6IHRydWUsXG5cdFx0ZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuXHRcdGRyYXdUaWNrczogdHJ1ZSxcblx0XHR0aWNrTWFya0xlbmd0aDogMTAsXG5cdFx0emVyb0xpbmVXaWR0aDogMSxcblx0XHR6ZXJvTGluZUNvbG9yOiAncmdiYSgwLDAsMCwwLjI1KScsXG5cdFx0emVyb0xpbmVCb3JkZXJEYXNoOiBbXSxcblx0XHR6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcblx0XHRvZmZzZXRHcmlkTGluZXM6IGZhbHNlLFxuXHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuXHR9LFxuXG5cdC8vIHNjYWxlIGxhYmVsXG5cdHNjYWxlTGFiZWw6IHtcblx0XHQvLyBkaXNwbGF5IHByb3BlcnR5XG5cdFx0ZGlzcGxheTogZmFsc2UsXG5cblx0XHQvLyBhY3R1YWwgbGFiZWxcblx0XHRsYWJlbFN0cmluZzogJycsXG5cblx0XHQvLyB0b3AvYm90dG9tIHBhZGRpbmdcblx0XHRwYWRkaW5nOiB7XG5cdFx0XHR0b3A6IDQsXG5cdFx0XHRib3R0b206IDRcblx0XHR9XG5cdH0sXG5cblx0Ly8gbGFiZWwgc2V0dGluZ3Ncblx0dGlja3M6IHtcblx0XHRiZWdpbkF0WmVybzogZmFsc2UsXG5cdFx0bWluUm90YXRpb246IDAsXG5cdFx0bWF4Um90YXRpb246IDUwLFxuXHRcdG1pcnJvcjogZmFsc2UsXG5cdFx0cGFkZGluZzogMCxcblx0XHRyZXZlcnNlOiBmYWxzZSxcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdGF1dG9Ta2lwOiB0cnVlLFxuXHRcdGF1dG9Ta2lwUGFkZGluZzogMCxcblx0XHRsYWJlbE9mZnNldDogMCxcblx0XHQvLyBXZSBwYXNzIHRocm91Z2ggYXJyYXlzIHRvIGJlIHJlbmRlcmVkIGFzIG11bHRpbGluZSBsYWJlbHMsIHdlIGNvbnZlcnQgT3RoZXJzIHRvIHN0cmluZ3MgaGVyZS5cblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcblx0XHRtaW5vcjoge30sXG5cdFx0bWFqb3I6IHt9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBsYWJlbHNGcm9tVGlja3ModGlja3MpIHtcblx0dmFyIGxhYmVscyA9IFtdO1xuXHR2YXIgaSwgaWxlbjtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0bGFiZWxzLnB1c2godGlja3NbaV0ubGFiZWwpO1xuXHR9XG5cblx0cmV0dXJuIGxhYmVscztcbn1cblxuZnVuY3Rpb24gZ2V0UGl4ZWxGb3JHcmlkTGluZShzY2FsZSwgaW5kZXgsIG9mZnNldEdyaWRMaW5lcykge1xuXHR2YXIgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KTtcblxuXHRpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG5cdFx0aWYgKHNjYWxlLmdldFRpY2tzKCkubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRsaW5lVmFsdWUgLT0gc2NhbGUuaXNIb3Jpem9udGFsKCkgP1xuXHRcdFx0XHRNYXRoLm1heChsaW5lVmFsdWUgLSBzY2FsZS5sZWZ0LCBzY2FsZS5yaWdodCAtIGxpbmVWYWx1ZSkgOlxuXHRcdFx0XHRNYXRoLm1heChsaW5lVmFsdWUgLSBzY2FsZS50b3AsIHNjYWxlLmJvdHRvbSAtIGxpbmVWYWx1ZSk7XG5cdFx0fSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0bGluZVZhbHVlIC09IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGluZVZhbHVlIC09IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaW5kZXggLSAxKSkgLyAyO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbGluZVZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlVGV4dFNpemUoY29udGV4dCwgdGljaywgZm9udCkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzQXJyYXkodGljaykgP1xuXHRcdGhlbHBlcnMkMS5sb25nZXN0VGV4dChjb250ZXh0LCBmb250LCB0aWNrKSA6XG5cdFx0Y29udGV4dC5tZWFzdXJlVGV4dCh0aWNrKS53aWR0aDtcbn1cblxudmFyIGNvcmVfc2NhbGUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0LyoqXG5cdCAqIEdldCB0aGUgcGFkZGluZyBuZWVkZWQgZm9yIHRoZSBzY2FsZVxuXHQgKiBAbWV0aG9kIGdldFBhZGRpbmdcblx0ICogQHByaXZhdGVcblx0ICogQHJldHVybnMge1BhZGRpbmd9IHRoZSBuZWNlc3NhcnkgcGFkZGluZ1xuXHQgKi9cblx0Z2V0UGFkZGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRyZXR1cm4ge1xuXHRcdFx0bGVmdDogbWUucGFkZGluZ0xlZnQgfHwgMCxcblx0XHRcdHRvcDogbWUucGFkZGluZ1RvcCB8fCAwLFxuXHRcdFx0cmlnaHQ6IG1lLnBhZGRpbmdSaWdodCB8fCAwLFxuXHRcdFx0Ym90dG9tOiBtZS5wYWRkaW5nQm90dG9tIHx8IDBcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzY2FsZSB0aWNrIG9iamVjdHMgKHtsYWJlbCwgbWFqb3J9KVxuXHQgKiBAc2luY2UgMi43XG5cdCAqL1xuXHRnZXRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RpY2tzO1xuXHR9LFxuXG5cdC8vIFRoZXNlIG1ldGhvZHMgYXJlIG9yZGVyZWQgYnkgbGlmZWN5bGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblx0Ly8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIHNjYWxlIHR5cGVzLlxuXHQvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBzY2FsZSB0eXBlXG5cblx0bWVyZ2VUaWNrc09wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblx0XHRpZiAodGlja3MubWlub3IgPT09IGZhbHNlKSB7XG5cdFx0XHR0aWNrcy5taW5vciA9IHtcblx0XHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHRcdH07XG5cdFx0fVxuXHRcdGlmICh0aWNrcy5tYWpvciA9PT0gZmFsc2UpIHtcblx0XHRcdHRpY2tzLm1ham9yID0ge1xuXHRcdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0Zm9yICh2YXIga2V5IGluIHRpY2tzKSB7XG5cdFx0XHRpZiAoa2V5ICE9PSAnbWFqb3InICYmIGtleSAhPT0gJ21pbm9yJykge1xuXHRcdFx0XHRpZiAodHlwZW9mIHRpY2tzLm1pbm9yW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0dGlja3MubWlub3Jba2V5XSA9IHRpY2tzW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHR5cGVvZiB0aWNrcy5tYWpvcltrZXldID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHRpY2tzLm1ham9yW2tleV0gPSB0aWNrc1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24obWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGksIGlsZW4sIGxhYmVscywgbGFiZWwsIHRpY2tzLCB0aWNrO1xuXG5cdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcblxuXHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0bWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXHRcdG1lLm1hcmdpbnMgPSBoZWxwZXJzJDEuZXh0ZW5kKHtcblx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRyaWdodDogMCxcblx0XHRcdHRvcDogMCxcblx0XHRcdGJvdHRvbTogMFxuXHRcdH0sIG1hcmdpbnMpO1xuXG5cdFx0bWUuX21heExhYmVsTGluZXMgPSAwO1xuXHRcdG1lLmxvbmdlc3RMYWJlbFdpZHRoID0gMDtcblx0XHRtZS5sb25nZXN0VGV4dENhY2hlID0gbWUubG9uZ2VzdFRleHRDYWNoZSB8fCB7fTtcblxuXHRcdC8vIERpbWVuc2lvbnNcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXG5cdFx0Ly8gRGF0YSBtaW4vbWF4XG5cdFx0bWUuYmVmb3JlRGF0YUxpbWl0cygpO1xuXHRcdG1lLmRldGVybWluZURhdGFMaW1pdHMoKTtcblx0XHRtZS5hZnRlckRhdGFMaW1pdHMoKTtcblxuXHRcdC8vIFRpY2tzIC0gYHRoaXMudGlja3NgIGlzIG5vdyBERVBSRUNBVEVEIVxuXHRcdC8vIEludGVybmFsIHRpY2tzIGFyZSBub3cgc3RvcmVkIGFzIG9iamVjdHMgaW4gdGhlIFBSSVZBVEUgYHRoaXMuX3RpY2tzYCBtZW1iZXJcblx0XHQvLyBhbmQgbXVzdCBub3QgYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBvdXRzaWRlIHRoaXMgY2xhc3MuIGB0aGlzLnRpY2tzYCBiZWluZ1xuXHRcdC8vIGFyb3VuZCBmb3IgbG9uZyB0aW1lIGFuZCBub3QgbWFya2VkIGFzIHByaXZhdGUsIHdlIGNhbid0IGNoYW5nZSBpdHMgc3RydWN0dXJlXG5cdFx0Ly8gd2l0aG91dCB1bmV4cGVjdGVkIGJyZWFraW5nIGNoYW5nZXMuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2NhbGUgdGlja3MsXG5cdFx0Ly8gdXNlIHNjYWxlLmdldFRpY2tzKCkgaW5zdGVhZC5cblxuXHRcdG1lLmJlZm9yZUJ1aWxkVGlja3MoKTtcblxuXHRcdC8vIE5ldyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIGJ1dCBmb3IgQkFDS1dBUkQgQ09NUEFULFxuXHRcdC8vIHdlIHN0aWxsIHN1cHBvcnQgbm8gcmV0dXJuIChgdGhpcy50aWNrc2AgaW50ZXJuYWxseSBzZXQgYnkgY2FsbGluZyB0aGlzIG1ldGhvZCkuXG5cdFx0dGlja3MgPSBtZS5idWlsZFRpY2tzKCkgfHwgW107XG5cblx0XHQvLyBBbGxvdyBtb2RpZmljYXRpb24gb2YgdGlja3MgaW4gY2FsbGJhY2suXG5cdFx0dGlja3MgPSBtZS5hZnRlckJ1aWxkVGlja3ModGlja3MpIHx8IHRpY2tzO1xuXG5cdFx0bWUuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG5cblx0XHQvLyBOZXcgaW1wbGVtZW50YXRpb25zIHNob3VsZCByZXR1cm4gdGhlIGZvcm1hdHRlZCB0aWNrIGxhYmVscyBidXQgZm9yIEJBQ0tXQVJEXG5cdFx0Ly8gQ09NUEFULCB3ZSBzdGlsbCBzdXBwb3J0IG5vIHJldHVybiAoYHRoaXMudGlja3NgIGludGVybmFsbHkgY2hhbmdlZCBieSBjYWxsaW5nXG5cdFx0Ly8gdGhpcyBtZXRob2QgYW5kIHN1cHBvc2VkIHRvIGNvbnRhaW4gb25seSBzdHJpbmcgdmFsdWVzKS5cblx0XHRsYWJlbHMgPSBtZS5jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykgfHwgbWUudGlja3M7XG5cblx0XHRtZS5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG5cdFx0bWUudGlja3MgPSBsYWJlbHM7ICAgLy8gQkFDS1dBUkQgQ09NUEFUSUJJTElUWVxuXG5cdFx0Ly8gSU1QT1JUQU5UOiBmcm9tIHRoaXMgcG9pbnQsIHdlIGNvbnNpZGVyIHRoYXQgYHRoaXMudGlja3NgIHdpbGwgTkVWRVIgY2hhbmdlIVxuXG5cdFx0Ly8gQkFDS1dBUkQgQ09NUEFUOiBzeW5jaHJvbml6ZSBgX3RpY2tzYCB3aXRoIGxhYmVscyAoc28gcG90ZW50aWFsbHkgYHRoaXMudGlja3NgKVxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRsYWJlbCA9IGxhYmVsc1tpXTtcblx0XHRcdHRpY2sgPSB0aWNrc1tpXTtcblx0XHRcdGlmICghdGljaykge1xuXHRcdFx0XHR0aWNrcy5wdXNoKHRpY2sgPSB7XG5cdFx0XHRcdFx0bGFiZWw6IGxhYmVsLFxuXHRcdFx0XHRcdG1ham9yOiBmYWxzZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRpY2subGFiZWwgPSBsYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS5fdGlja3MgPSB0aWNrcztcblxuXHRcdC8vIFRpY2sgUm90YXRpb25cblx0XHRtZS5iZWZvcmVDYWxjdWxhdGVUaWNrUm90YXRpb24oKTtcblx0XHRtZS5jYWxjdWxhdGVUaWNrUm90YXRpb24oKTtcblx0XHRtZS5hZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbigpO1xuXHRcdC8vIEZpdFxuXHRcdG1lLmJlZm9yZUZpdCgpO1xuXHRcdG1lLmZpdCgpO1xuXHRcdG1lLmFmdGVyRml0KCk7XG5cdFx0Ly9cblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xuXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XG5cblx0fSxcblx0YWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly9cblxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG5cdH0sXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXHR9LFxuXHRhZnRlclNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vIERhdGEgbGltaXRzXG5cdGJlZm9yZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlRGF0YUxpbWl0cywgW3RoaXNdKTtcblx0fSxcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogaGVscGVycyQxLm5vb3AsXG5cdGFmdGVyRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckRhdGFMaW1pdHMsIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly9cblx0YmVmb3JlQnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVCdWlsZFRpY2tzLCBbdGhpc10pO1xuXHR9LFxuXHRidWlsZFRpY2tzOiBoZWxwZXJzJDEubm9vcCxcblx0YWZ0ZXJCdWlsZFRpY2tzOiBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gdGlja3MgaXMgZW1wdHkgZm9yIG9sZCBheGlzIGltcGxlbWVudGF0aW9ucyBoZXJlXG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRpY2tzKSAmJiB0aWNrcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBoZWxwZXJzJDEuY2FsbGJhY2sobWUub3B0aW9ucy5hZnRlckJ1aWxkVGlja3MsIFttZSwgdGlja3NdKTtcblx0XHR9XG5cdFx0Ly8gU3VwcG9ydCBvbGQgaW1wbGVtZW50YXRpb25zICh0aGF0IG1vZGlmaWVkIGB0aGlzLnRpY2tzYCBkaXJlY3RseSBpbiBidWlsZFRpY2tzKVxuXHRcdG1lLnRpY2tzID0gaGVscGVycyQxLmNhbGxiYWNrKG1lLm9wdGlvbnMuYWZ0ZXJCdWlsZFRpY2tzLCBbbWUsIG1lLnRpY2tzXSkgfHwgbWUudGlja3M7XG5cdFx0cmV0dXJuIHRpY2tzO1xuXHR9LFxuXG5cdGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG5cdH0sXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIENvbnZlcnQgdGlja3MgdG8gc3RyaW5nc1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0bWUudGlja3MgPSBtZS50aWNrcy5tYXAodGlja09wdHMudXNlckNhbGxiYWNrIHx8IHRpY2tPcHRzLmNhbGxiYWNrLCB0aGlzKTtcblx0fSxcblx0YWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb246IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly9cblxuXHRiZWZvcmVDYWxjdWxhdGVUaWNrUm90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uLCBbdGhpc10pO1xuXHR9LFxuXHRjYWxjdWxhdGVUaWNrUm90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNvbnRleHQgPSBtZS5jdHg7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgbGFiZWxzID0gbGFiZWxzRnJvbVRpY2tzKG1lLl90aWNrcyk7XG5cblx0XHQvLyBHZXQgdGhlIHdpZHRoIG9mIGVhY2ggZ3JpZCBieSBjYWxjdWxhdGluZyB0aGUgZGlmZmVyZW5jZVxuXHRcdC8vIGJldHdlZW4geCBvZmZzZXRzIGJldHdlZW4gMCBhbmQgMS5cblx0XHR2YXIgdGlja0ZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHRpY2tPcHRzKTtcblx0XHRjb250ZXh0LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG5cblx0XHR2YXIgbGFiZWxSb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG5cblx0XHRpZiAobGFiZWxzLmxlbmd0aCAmJiBtZS5vcHRpb25zLmRpc3BsYXkgJiYgbWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdHZhciBvcmlnaW5hbExhYmVsV2lkdGggPSBoZWxwZXJzJDEubG9uZ2VzdFRleHQoY29udGV4dCwgdGlja0ZvbnQuc3RyaW5nLCBsYWJlbHMsIG1lLmxvbmdlc3RUZXh0Q2FjaGUpO1xuXHRcdFx0dmFyIGxhYmVsV2lkdGggPSBvcmlnaW5hbExhYmVsV2lkdGg7XG5cdFx0XHR2YXIgY29zUm90YXRpb24sIHNpblJvdGF0aW9uO1xuXG5cdFx0XHQvLyBBbGxvdyAzIHBpeGVscyB4MiBwYWRkaW5nIGVpdGhlciBzaWRlIGZvciBsYWJlbCByZWFkYWJpbGl0eVxuXHRcdFx0dmFyIHRpY2tXaWR0aCA9IG1lLmdldFBpeGVsRm9yVGljaygxKSAtIG1lLmdldFBpeGVsRm9yVGljaygwKSAtIDY7XG5cblx0XHRcdC8vIE1heCBsYWJlbCByb3RhdGlvbiBjYW4gYmUgc2V0IG9yIGRlZmF1bHQgdG8gOTAgLSBhbHNvIGFjdCBhcyBhIGxvb3AgY291bnRlclxuXHRcdFx0d2hpbGUgKGxhYmVsV2lkdGggPiB0aWNrV2lkdGggJiYgbGFiZWxSb3RhdGlvbiA8IHRpY2tPcHRzLm1heFJvdGF0aW9uKSB7XG5cdFx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKGxhYmVsUm90YXRpb24pO1xuXHRcdFx0XHRjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XG5cdFx0XHRcdHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcblxuXHRcdFx0XHRpZiAoc2luUm90YXRpb24gKiBvcmlnaW5hbExhYmVsV2lkdGggPiBtZS5tYXhIZWlnaHQpIHtcblx0XHRcdFx0XHQvLyBnbyBiYWNrIG9uZSBzdGVwXG5cdFx0XHRcdFx0bGFiZWxSb3RhdGlvbi0tO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGFiZWxSb3RhdGlvbisrO1xuXHRcdFx0XHRsYWJlbFdpZHRoID0gY29zUm90YXRpb24gKiBvcmlnaW5hbExhYmVsV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG5cdH0sXG5cdGFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlVGlja1JvdGF0aW9uLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlRml0OiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUZpdCwgW3RoaXNdKTtcblx0fSxcblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFJlc2V0XG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplID0ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9O1xuXG5cdFx0dmFyIGxhYmVscyA9IGxhYmVsc0Zyb21UaWNrcyhtZS5fdGlja3MpO1xuXG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cdFx0dmFyIHNjYWxlTGFiZWxPcHRzID0gb3B0cy5zY2FsZUxhYmVsO1xuXHRcdHZhciBncmlkTGluZU9wdHMgPSBvcHRzLmdyaWRMaW5lcztcblx0XHR2YXIgZGlzcGxheSA9IG1lLl9pc1Zpc2libGUoKTtcblx0XHR2YXIgcG9zaXRpb24gPSBvcHRzLnBvc2l0aW9uO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdHZhciBwYXJzZUZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250O1xuXHRcdHZhciB0aWNrRm9udCA9IHBhcnNlRm9udCh0aWNrT3B0cyk7XG5cdFx0dmFyIHRpY2tNYXJrTGVuZ3RoID0gb3B0cy5ncmlkTGluZXMudGlja01hcmtMZW5ndGg7XG5cblx0XHQvLyBXaWR0aFxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdC8vIHN1YnRyYWN0IHRoZSBtYXJnaW5zIHRvIGxpbmUgdXAgd2l0aCB0aGUgY2hhcnRBcmVhIGlmIHdlIGFyZSBhIGZ1bGwgd2lkdGggc2NhbGVcblx0XHRcdG1pblNpemUud2lkdGggPSBtZS5pc0Z1bGxXaWR0aCgpID8gbWUubWF4V2lkdGggLSBtZS5tYXJnaW5zLmxlZnQgLSBtZS5tYXJnaW5zLnJpZ2h0IDogbWUubWF4V2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1pblNpemUud2lkdGggPSBkaXNwbGF5ICYmIGdyaWRMaW5lT3B0cy5kcmF3VGlja3MgPyB0aWNrTWFya0xlbmd0aCA6IDA7XG5cdFx0fVxuXG5cdFx0Ly8gaGVpZ2h0XG5cdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBkaXNwbGF5ICYmIGdyaWRMaW5lT3B0cy5kcmF3VGlja3MgPyB0aWNrTWFya0xlbmd0aCA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0fVxuXG5cdFx0Ly8gQXJlIHdlIHNob3dpbmcgYSB0aXRsZSBmb3IgdGhlIHNjYWxlP1xuXHRcdGlmIChzY2FsZUxhYmVsT3B0cy5kaXNwbGF5ICYmIGRpc3BsYXkpIHtcblx0XHRcdHZhciBzY2FsZUxhYmVsRm9udCA9IHBhcnNlRm9udChzY2FsZUxhYmVsT3B0cyk7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbFBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcoc2NhbGVMYWJlbE9wdHMucGFkZGluZyk7XG5cdFx0XHR2YXIgZGVsdGFIZWlnaHQgPSBzY2FsZUxhYmVsRm9udC5saW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcuaGVpZ2h0O1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ICs9IGRlbHRhSGVpZ2h0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWluU2l6ZS53aWR0aCArPSBkZWx0YUhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBEb24ndCBib3RoZXIgZml0dGluZyB0aGUgdGlja3MgaWYgd2UgYXJlIG5vdCBzaG93aW5nIHRoZSBsYWJlbHNcblx0XHRpZiAodGlja09wdHMuZGlzcGxheSAmJiBkaXNwbGF5KSB7XG5cdFx0XHR2YXIgbGFyZ2VzdFRleHRXaWR0aCA9IGhlbHBlcnMkMS5sb25nZXN0VGV4dChtZS5jdHgsIHRpY2tGb250LnN0cmluZywgbGFiZWxzLCBtZS5sb25nZXN0VGV4dENhY2hlKTtcblx0XHRcdHZhciB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzID0gaGVscGVycyQxLm51bWJlck9mTGFiZWxMaW5lcyhsYWJlbHMpO1xuXHRcdFx0dmFyIGxpbmVTcGFjZSA9IHRpY2tGb250LnNpemUgKiAwLjU7XG5cdFx0XHR2YXIgdGlja1BhZGRpbmcgPSBtZS5vcHRpb25zLnRpY2tzLnBhZGRpbmc7XG5cblx0XHRcdC8vIFN0b3JlIG1heCBudW1iZXIgb2YgbGluZXMgYW5kIHdpZGVzdCBsYWJlbCBmb3IgX2F1dG9Ta2lwXG5cdFx0XHRtZS5fbWF4TGFiZWxMaW5lcyA9IHRhbGxlc3RMYWJlbEhlaWdodEluTGluZXM7XG5cdFx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IGxhcmdlc3RUZXh0V2lkdGg7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0dmFyIGFuZ2xlUmFkaWFucyA9IGhlbHBlcnMkMS50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG5cdFx0XHRcdHZhciBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XG5cdFx0XHRcdHZhciBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cblx0XHRcdFx0Ly8gVE9ETyAtIGltcHJvdmUgdGhpcyBjYWxjdWxhdGlvblxuXHRcdFx0XHR2YXIgbGFiZWxIZWlnaHQgPSAoc2luUm90YXRpb24gKiBsYXJnZXN0VGV4dFdpZHRoKVxuXHRcdFx0XHRcdCsgKHRpY2tGb250LmxpbmVIZWlnaHQgKiB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzKVxuXHRcdFx0XHRcdCsgbGluZVNwYWNlOyAvLyBwYWRkaW5nXG5cblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbihtZS5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG5cblx0XHRcdFx0bWUuY3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG5cdFx0XHRcdHZhciBmaXJzdExhYmVsV2lkdGggPSBjb21wdXRlVGV4dFNpemUobWUuY3R4LCBsYWJlbHNbMF0sIHRpY2tGb250LnN0cmluZyk7XG5cdFx0XHRcdHZhciBsYXN0TGFiZWxXaWR0aCA9IGNvbXB1dGVUZXh0U2l6ZShtZS5jdHgsIGxhYmVsc1tsYWJlbHMubGVuZ3RoIC0gMV0sIHRpY2tGb250LnN0cmluZyk7XG5cdFx0XHRcdHZhciBvZmZzZXRMZWZ0ID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gbWUubGVmdDtcblx0XHRcdFx0dmFyIG9mZnNldFJpZ2h0ID0gbWUucmlnaHQgLSBtZS5nZXRQaXhlbEZvclRpY2sobGFiZWxzLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHR2YXIgcGFkZGluZ0xlZnQsIHBhZGRpbmdSaWdodDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhhdCBvdXIgdGlja3MgYXJlIGFsd2F5cyBpbnNpZGUgdGhlIGNhbnZhcy4gV2hlbiByb3RhdGVkLCB0aWNrcyBhcmUgcmlnaHQgYWxpZ25lZFxuXHRcdFx0XHQvLyB3aGljaCBtZWFucyB0aGF0IHRoZSByaWdodCBwYWRkaW5nIGlzIGRvbWluYXRlZCBieSB0aGUgZm9udCBoZWlnaHRcblx0XHRcdFx0aWYgKG1lLmxhYmVsUm90YXRpb24gIT09IDApIHtcblx0XHRcdFx0XHRwYWRkaW5nTGVmdCA9IHBvc2l0aW9uID09PSAnYm90dG9tJyA/IChjb3NSb3RhdGlvbiAqIGZpcnN0TGFiZWxXaWR0aCkgOiAoY29zUm90YXRpb24gKiBsaW5lU3BhY2UpO1xuXHRcdFx0XHRcdHBhZGRpbmdSaWdodCA9IHBvc2l0aW9uID09PSAnYm90dG9tJyA/IChjb3NSb3RhdGlvbiAqIGxpbmVTcGFjZSkgOiAoY29zUm90YXRpb24gKiBsYXN0TGFiZWxXaWR0aCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFkZGluZ0xlZnQgPSBmaXJzdExhYmVsV2lkdGggLyAyO1xuXHRcdFx0XHRcdHBhZGRpbmdSaWdodCA9IGxhc3RMYWJlbFdpZHRoIC8gMjtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZS5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCwgMCkgKyAzOyAvLyBhZGQgMyBweCB0byBtb3ZlIGF3YXkgZnJvbSBjYW52YXMgZWRnZXNcblx0XHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQsIDApICsgMztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEEgdmVydGljYWwgYXhpcyBpcyBtb3JlIGNvbnN0cmFpbmVkIGJ5IHRoZSB3aWR0aC4gTGFiZWxzIGFyZSB0aGVcblx0XHRcdFx0Ly8gZG9taW5hbnQgZmFjdG9yIGhlcmUsIHNvIGdldCB0aGF0IGxlbmd0aCBmaXJzdCBhbmQgYWNjb3VudCBmb3IgcGFkZGluZ1xuXHRcdFx0XHRpZiAodGlja09wdHMubWlycm9yKSB7XG5cdFx0XHRcdFx0bGFyZ2VzdFRleHRXaWR0aCA9IDA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdXNlIGxpbmVTcGFjZSBmb3IgY29uc2lzdGVuY3kgd2l0aCBob3Jpem9udGFsIGF4aXNcblx0XHRcdFx0XHQvLyB0aWNrUGFkZGluZyBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIGhvcml6b250YWxcblx0XHRcdFx0XHRsYXJnZXN0VGV4dFdpZHRoICs9IHRpY2tQYWRkaW5nICsgbGluZVNwYWNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWluU2l6ZS53aWR0aCA9IE1hdGgubWluKG1lLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFyZ2VzdFRleHRXaWR0aCk7XG5cblx0XHRcdFx0bWUucGFkZGluZ1RvcCA9IHRpY2tGb250LnNpemUgLyAyO1xuXHRcdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gdGlja0ZvbnQuc2l6ZSAvIDI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUuaGFuZGxlTWFyZ2lucygpO1xuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgbWFyZ2lucyBhbmQgcGFkZGluZyBpbnRlcmFjdGlvbnNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhhbmRsZU1hcmdpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLm1hcmdpbnMpIHtcblx0XHRcdG1lLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgobWUucGFkZGluZ0xlZnQgLSBtZS5tYXJnaW5zLmxlZnQsIDApO1xuXHRcdFx0bWUucGFkZGluZ1RvcCA9IE1hdGgubWF4KG1lLnBhZGRpbmdUb3AgLSBtZS5tYXJnaW5zLnRvcCwgMCk7XG5cdFx0XHRtZS5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heChtZS5wYWRkaW5nUmlnaHQgLSBtZS5tYXJnaW5zLnJpZ2h0LCAwKTtcblx0XHRcdG1lLnBhZGRpbmdCb3R0b20gPSBNYXRoLm1heChtZS5wYWRkaW5nQm90dG9tIC0gbWUubWFyZ2lucy5ib3R0b20sIDApO1xuXHRcdH1cblx0fSxcblxuXHRhZnRlckZpdDogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcblx0fSxcblxuXHQvLyBTaGFyZWQgTWV0aG9kc1xuXHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG5cdH0sXG5cdGlzRnVsbFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMub3B0aW9ucy5mdWxsV2lkdGgpO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgY29ycmVjdCB2YWx1ZS4gTmFOIGJhZCBpbnB1dHMsIElmIHRoZSB2YWx1ZSB0eXBlIGlzIG9iamVjdCBnZXQgdGhlIHggb3IgeSBiYXNlZCBvbiB3aGV0aGVyIHdlIGFyZSBob3Jpem9udGFsIG9yIG5vdFxuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbihyYXdWYWx1ZSkge1xuXHRcdC8vIE51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgZmlyc3Rcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYocmF3VmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gTmFOO1xuXHRcdH1cblx0XHQvLyBpc05hTihvYmplY3QpIHJldHVybnMgdHJ1ZSwgc28gbWFrZSBzdXJlIE5hTiBpcyBjaGVja2luZyBmb3IgYSBudW1iZXI7IERpc2NhcmQgSW5maW5pdGUgdmFsdWVzXG5cdFx0aWYgKCh0eXBlb2YgcmF3VmFsdWUgPT09ICdudW1iZXInIHx8IHJhd1ZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUocmF3VmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gTmFOO1xuXHRcdH1cblx0XHQvLyBJZiBpdCBpcyBpbiBmYWN0IGFuIG9iamVjdCwgZGl2ZSBpbiBvbmUgbW9yZSBsZXZlbFxuXHRcdGlmIChyYXdWYWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0aWYgKHJhd1ZhbHVlLnggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAocmF3VmFsdWUueSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUueSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gVmFsdWUgaXMgZ29vZCwgcmV0dXJuIGl0XG5cdFx0cmV0dXJuIHJhd1ZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgdmFsdWUgdG8gZGlzcGxheSBpbiB0aGUgdG9vbHRpcCBmb3IgdGhlIGRhdGEgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIEBwYXJhbSBpbmRleFxuXHQgKiBAcGFyYW0gZGF0YXNldEluZGV4XG5cdCAqL1xuXHRnZXRMYWJlbEZvckluZGV4OiBoZWxwZXJzJDEubm9vcCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIGdpdmVuIGRhdGEgcG9pbnQuIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB2YWx1ZVxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICogQHBhcmFtIGRhdGFzZXRJbmRleFxuXHQgKi9cblx0Z2V0UGl4ZWxGb3JWYWx1ZTogaGVscGVycyQxLm5vb3AsXG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gZ2V0IHRoZSBkYXRhIHZhbHVlIGZyb20gYSBnaXZlbiBwaXhlbC4gVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBnZXRQaXhlbEZvclZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0gcGl4ZWxcblx0ICovXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGhlbHBlcnMkMS5ub29wLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgdGljayBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqL1xuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgaW5uZXJXaWR0aCA9IG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KTtcblx0XHRcdHZhciB0aWNrV2lkdGggPSBpbm5lcldpZHRoIC8gTWF0aC5tYXgoKG1lLl90aWNrcy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpKSwgMSk7XG5cdFx0XHR2YXIgcGl4ZWwgPSAodGlja1dpZHRoICogaW5kZXgpICsgbWUucGFkZGluZ0xlZnQ7XG5cblx0XHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdFx0cGl4ZWwgKz0gdGlja1dpZHRoIC8gMjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGZpbmFsVmFsID0gbWUubGVmdCArIHBpeGVsO1xuXHRcdFx0ZmluYWxWYWwgKz0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1hcmdpbnMubGVmdCA6IDA7XG5cdFx0XHRyZXR1cm4gZmluYWxWYWw7XG5cdFx0fVxuXHRcdHZhciBpbm5lckhlaWdodCA9IG1lLmhlaWdodCAtIChtZS5wYWRkaW5nVG9wICsgbWUucGFkZGluZ0JvdHRvbSk7XG5cdFx0cmV0dXJuIG1lLnRvcCArIChpbmRleCAqIChpbm5lckhlaWdodCAvIChtZS5fdGlja3MubGVuZ3RoIC0gMSkpKTtcblx0fSxcblxuXHQvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgYSBwZXJjZW50YWdlIG9mIHNjYWxlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKi9cblx0Z2V0UGl4ZWxGb3JEZWNpbWFsOiBmdW5jdGlvbihkZWNpbWFsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdHZhciBpbm5lcldpZHRoID0gbWUud2lkdGggLSAobWUucGFkZGluZ0xlZnQgKyBtZS5wYWRkaW5nUmlnaHQpO1xuXHRcdFx0dmFyIHZhbHVlT2Zmc2V0ID0gKGlubmVyV2lkdGggKiBkZWNpbWFsKSArIG1lLnBhZGRpbmdMZWZ0O1xuXG5cdFx0XHR2YXIgZmluYWxWYWwgPSBtZS5sZWZ0ICsgdmFsdWVPZmZzZXQ7XG5cdFx0XHRmaW5hbFZhbCArPSBtZS5pc0Z1bGxXaWR0aCgpID8gbWUubWFyZ2lucy5sZWZ0IDogMDtcblx0XHRcdHJldHVybiBmaW5hbFZhbDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lLnRvcCArIChkZWNpbWFsICogbWUuaGVpZ2h0KTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcGl4ZWwgZm9yIHRoZSBtaW5pbXVtIGNoYXJ0IHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKi9cblx0Z2V0QmFzZVBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuXHR9LFxuXG5cdGdldEJhc2VWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWluID0gbWUubWluO1xuXHRcdHZhciBtYXggPSBtZS5tYXg7XG5cblx0XHRyZXR1cm4gbWUuYmVnaW5BdFplcm8gPyAwIDpcblx0XHRcdG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG5cdFx0XHRtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuXHRcdFx0MDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHN1YnNldCBvZiB0aWNrcyB0byBiZSBwbG90dGVkIHRvIGF2b2lkIG92ZXJsYXBwaW5nIGxhYmVscy5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9hdXRvU2tpcDogZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgb3B0aW9uVGlja3MgPSBtZS5vcHRpb25zLnRpY2tzLm1pbm9yO1xuXHRcdHZhciB0aWNrQ291bnQgPSB0aWNrcy5sZW5ndGg7XG5cdFx0dmFyIHNraXBSYXRpbyA9IGZhbHNlO1xuXHRcdHZhciBtYXhUaWNrcyA9IG9wdGlvblRpY2tzLm1heFRpY2tzTGltaXQ7XG5cblx0XHQvLyBUb3RhbCBzcGFjZSBuZWVkZWQgdG8gZGlzcGxheSBhbGwgdGlja3MuIEZpcnN0IGFuZCBsYXN0IHRpY2tzIGFyZVxuXHRcdC8vIGRyYXduIGFzIHRoZWlyIGNlbnRlciBhdCBlbmQgb2YgYXhpcywgc28gdGlja0NvdW50LTFcblx0XHR2YXIgdGlja3NMZW5ndGggPSBtZS5fdGlja1NpemUoKSAqICh0aWNrQ291bnQgLSAxKTtcblxuXHRcdC8vIEF4aXMgbGVuZ3RoXG5cdFx0dmFyIGF4aXNMZW5ndGggPSBpc0hvcml6b250YWxcblx0XHRcdD8gbWUud2lkdGggLSAobWUucGFkZGluZ0xlZnQgKyBtZS5wYWRkaW5nUmlnaHQpXG5cdFx0XHQ6IG1lLmhlaWdodCAtIChtZS5wYWRkaW5nVG9wICsgbWUuUGFkZGluZ0JvdHRvbSk7XG5cblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0dmFyIGksIHRpY2s7XG5cblx0XHRpZiAodGlja3NMZW5ndGggPiBheGlzTGVuZ3RoKSB7XG5cdFx0XHRza2lwUmF0aW8gPSAxICsgTWF0aC5mbG9vcih0aWNrc0xlbmd0aCAvIGF4aXNMZW5ndGgpO1xuXHRcdH1cblxuXHRcdC8vIGlmIHRoZXkgZGVmaW5lZCBhIG1heCBudW1iZXIgb2Ygb3B0aW9uVGlja3MsXG5cdFx0Ly8gaW5jcmVhc2Ugc2tpcFJhdGlvIHVudGlsIHRoYXQgbnVtYmVyIGlzIG1ldFxuXHRcdGlmICh0aWNrQ291bnQgPiBtYXhUaWNrcykge1xuXHRcdFx0c2tpcFJhdGlvID0gTWF0aC5tYXgoc2tpcFJhdGlvLCAxICsgTWF0aC5mbG9vcih0aWNrQ291bnQgLyBtYXhUaWNrcykpO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCB0aWNrQ291bnQ7IGkrKykge1xuXHRcdFx0dGljayA9IHRpY2tzW2ldO1xuXG5cdFx0XHRpZiAoc2tpcFJhdGlvID4gMSAmJiBpICUgc2tpcFJhdGlvID4gMCkge1xuXHRcdFx0XHQvLyBsZWF2ZSB0aWNrIGluIHBsYWNlIGJ1dCBtYWtlIHN1cmUgaXQncyBub3QgZGlzcGxheWVkICgjNDYzNSlcblx0XHRcdFx0ZGVsZXRlIHRpY2subGFiZWw7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQucHVzaCh0aWNrKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF90aWNrU2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcy5taW5vcjtcblxuXHRcdC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgYnkgbGFiZWwgaW4gYXhpcyBkaXJlY3Rpb24uXG5cdFx0dmFyIHJvdCA9IGhlbHBlcnMkMS50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG5cdFx0dmFyIGNvcyA9IE1hdGguYWJzKE1hdGguY29zKHJvdCkpO1xuXHRcdHZhciBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcblxuXHRcdHZhciBwYWRkaW5nID0gb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nIHx8IDA7XG5cdFx0dmFyIHcgPSAobWUubG9uZ2VzdExhYmVsV2lkdGggKyBwYWRkaW5nKSB8fCAwO1xuXG5cdFx0dmFyIHRpY2tGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRpb25UaWNrcyk7XG5cdFx0dmFyIGggPSAobWUuX21heExhYmVsTGluZXMgKiB0aWNrRm9udC5saW5lSGVpZ2h0ICsgcGFkZGluZykgfHwgMDtcblxuXHRcdC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgZm9yIDEgdGljayBpbiBheGlzIGRpcmVjdGlvbi5cblx0XHRyZXR1cm4gaXNIb3Jpem9udGFsXG5cdFx0XHQ/IGggKiBjb3MgPiB3ICogc2luID8gdyAvIGNvcyA6IGggLyBzaW5cblx0XHRcdDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9pc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRpc3BsYXkgPSBtZS5vcHRpb25zLmRpc3BsYXk7XG5cdFx0dmFyIGksIGlsZW4sIG1ldGE7XG5cblx0XHRpZiAoZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG5cdFx0XHRyZXR1cm4gISFkaXNwbGF5O1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gJ2F1dG8nLCB0aGUgc2NhbGUgaXMgdmlzaWJsZSBpZiBhdCBsZWFzdCBvbmUgYXNzb2NpYXRlZCBkYXRhc2V0IGlzIHZpc2libGUuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRcdGlmIChtZXRhLnhBeGlzSUQgPT09IG1lLmlkIHx8IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogQWN0dWFsbHkgZHJhdyB0aGUgc2NhbGUgb24gdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gY2hhcnRBcmVhIC0gdGhlIGFyZWEgb2YgdGhlIGNoYXJ0IHRvIGRyYXcgZnVsbCBncmlkIGxpbmVzIG9uXG5cdCAqL1xuXHRkcmF3OiBmdW5jdGlvbihjaGFydEFyZWEpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblxuXHRcdGlmICghbWUuX2lzVmlzaWJsZSgpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGNvbnRleHQgPSBtZS5jdHg7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGRlZmF1bHRGb250Q29sb3IgPSBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udENvbG9yO1xuXHRcdHZhciBvcHRpb25UaWNrcyA9IG9wdGlvbnMudGlja3MubWlub3I7XG5cdFx0dmFyIG9wdGlvbk1ham9yVGlja3MgPSBvcHRpb25zLnRpY2tzLm1ham9yIHx8IG9wdGlvblRpY2tzO1xuXHRcdHZhciBncmlkTGluZXMgPSBvcHRpb25zLmdyaWRMaW5lcztcblx0XHR2YXIgc2NhbGVMYWJlbCA9IG9wdGlvbnMuc2NhbGVMYWJlbDtcblx0XHR2YXIgcG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuXG5cdFx0dmFyIGlzUm90YXRlZCA9IG1lLmxhYmVsUm90YXRpb24gIT09IDA7XG5cdFx0dmFyIGlzTWlycm9yZWQgPSBvcHRpb25UaWNrcy5taXJyb3I7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0dmFyIHBhcnNlRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQ7XG5cdFx0dmFyIHRpY2tzID0gb3B0aW9uVGlja3MuZGlzcGxheSAmJiBvcHRpb25UaWNrcy5hdXRvU2tpcCA/IG1lLl9hdXRvU2tpcChtZS5nZXRUaWNrcygpKSA6IG1lLmdldFRpY2tzKCk7XG5cdFx0dmFyIHRpY2tGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ5KG9wdGlvblRpY2tzLmZvbnRDb2xvciwgZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0dmFyIHRpY2tGb250ID0gcGFyc2VGb250KG9wdGlvblRpY2tzKTtcblx0XHR2YXIgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG5cdFx0dmFyIG1ham9yVGlja0ZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDkob3B0aW9uTWFqb3JUaWNrcy5mb250Q29sb3IsIGRlZmF1bHRGb250Q29sb3IpO1xuXHRcdHZhciBtYWpvclRpY2tGb250ID0gcGFyc2VGb250KG9wdGlvbk1ham9yVGlja3MpO1xuXHRcdHZhciB0aWNrUGFkZGluZyA9IG9wdGlvblRpY2tzLnBhZGRpbmc7XG5cdFx0dmFyIGxhYmVsT2Zmc2V0ID0gb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG5cblx0XHR2YXIgdGwgPSBncmlkTGluZXMuZHJhd1RpY2tzID8gZ3JpZExpbmVzLnRpY2tNYXJrTGVuZ3RoIDogMDtcblxuXHRcdHZhciBzY2FsZUxhYmVsRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkOShzY2FsZUxhYmVsLmZvbnRDb2xvciwgZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0dmFyIHNjYWxlTGFiZWxGb250ID0gcGFyc2VGb250KHNjYWxlTGFiZWwpO1xuXHRcdHZhciBzY2FsZUxhYmVsUGFkZGluZyA9IGhlbHBlcnMkMS5vcHRpb25zLnRvUGFkZGluZyhzY2FsZUxhYmVsLnBhZGRpbmcpO1xuXHRcdHZhciBsYWJlbFJvdGF0aW9uUmFkaWFucyA9IGhlbHBlcnMkMS50b1JhZGlhbnMobWUubGFiZWxSb3RhdGlvbik7XG5cblx0XHR2YXIgaXRlbXNUb0RyYXcgPSBbXTtcblxuXHRcdHZhciBheGlzV2lkdGggPSBncmlkTGluZXMuZHJhd0JvcmRlciA/IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCAwLCAwKSA6IDA7XG5cdFx0dmFyIGFsaWduUGl4ZWwgPSBoZWxwZXJzJDEuX2FsaWduUGl4ZWw7XG5cdFx0dmFyIGJvcmRlclZhbHVlLCB0aWNrU3RhcnQsIHRpY2tFbmQ7XG5cblx0XHRpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLmJvdHRvbSwgYXhpc1dpZHRoKTtcblx0XHRcdHRpY2tTdGFydCA9IG1lLmJvdHRvbSAtIHRsO1xuXHRcdFx0dGlja0VuZCA9IGJvcmRlclZhbHVlIC0gYXhpc1dpZHRoIC8gMjtcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS50b3AsIGF4aXNXaWR0aCk7XG5cdFx0XHR0aWNrU3RhcnQgPSBib3JkZXJWYWx1ZSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHR0aWNrRW5kID0gbWUudG9wICsgdGw7XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLnJpZ2h0LCBheGlzV2lkdGgpO1xuXHRcdFx0dGlja1N0YXJ0ID0gbWUucmlnaHQgLSB0bDtcblx0XHRcdHRpY2tFbmQgPSBib3JkZXJWYWx1ZSAtIGF4aXNXaWR0aCAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25QaXhlbChjaGFydCwgbWUubGVmdCwgYXhpc1dpZHRoKTtcblx0XHRcdHRpY2tTdGFydCA9IGJvcmRlclZhbHVlICsgYXhpc1dpZHRoIC8gMjtcblx0XHRcdHRpY2tFbmQgPSBtZS5sZWZ0ICsgdGw7XG5cdFx0fVxuXG5cdFx0dmFyIGVwc2lsb24gPSAwLjAwMDAwMDE7IC8vIDAuMDAwMDAwMSBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBBY2N1bXVsYXRlZCBlcnJvci5cblxuXHRcdGhlbHBlcnMkMS5lYWNoKHRpY2tzLCBmdW5jdGlvbih0aWNrLCBpbmRleCkge1xuXHRcdFx0Ly8gYXV0b3NraXBwZXIgc2tpcHBlZCB0aGlzIHRpY2sgKCM0NjM1KVxuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRpY2subGFiZWwpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxhYmVsID0gdGljay5sYWJlbDtcblx0XHRcdHZhciBsaW5lV2lkdGgsIGxpbmVDb2xvciwgYm9yZGVyRGFzaCwgYm9yZGVyRGFzaE9mZnNldDtcblx0XHRcdGlmIChpbmRleCA9PT0gbWUuemVyb0xpbmVJbmRleCAmJiBvcHRpb25zLm9mZnNldCA9PT0gZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcykge1xuXHRcdFx0XHQvLyBEcmF3IHRoZSBmaXJzdCBpbmRleCBzcGVjaWFsbHlcblx0XHRcdFx0bGluZVdpZHRoID0gZ3JpZExpbmVzLnplcm9MaW5lV2lkdGg7XG5cdFx0XHRcdGxpbmVDb2xvciA9IGdyaWRMaW5lcy56ZXJvTGluZUNvbG9yO1xuXHRcdFx0XHRib3JkZXJEYXNoID0gZ3JpZExpbmVzLnplcm9MaW5lQm9yZGVyRGFzaCB8fCBbXTtcblx0XHRcdFx0Ym9yZGVyRGFzaE9mZnNldCA9IGdyaWRMaW5lcy56ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGluZVdpZHRoID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5saW5lV2lkdGgsIGluZGV4KTtcblx0XHRcdFx0bGluZUNvbG9yID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5jb2xvciwgaW5kZXgpO1xuXHRcdFx0XHRib3JkZXJEYXNoID0gZ3JpZExpbmVzLmJvcmRlckRhc2ggfHwgW107XG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBncmlkTGluZXMuYm9yZGVyRGFzaE9mZnNldCB8fCAwLjA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbW1vbiBwcm9wZXJ0aWVzXG5cdFx0XHR2YXIgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MiwgbGFiZWxYLCBsYWJlbFksIHRleHRPZmZzZXQsIHRleHRBbGlnbjtcblx0XHRcdHZhciBsYWJlbENvdW50ID0gaGVscGVycyQxLmlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcblx0XHRcdHZhciBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKG1lLCBpbmRleCwgZ3JpZExpbmVzLm9mZnNldEdyaWRMaW5lcyk7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0dmFyIGxhYmVsWU9mZnNldCA9IHRsICsgdGlja1BhZGRpbmc7XG5cblx0XHRcdFx0aWYgKGxpbmVWYWx1ZSA8IG1lLmxlZnQgLSBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0bGluZUNvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHgxID0gdHgyID0geDEgPSB4MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcblx0XHRcdFx0dHkxID0gdGlja1N0YXJ0O1xuXHRcdFx0XHR0eTIgPSB0aWNrRW5kO1xuXHRcdFx0XHRsYWJlbFggPSBtZS5nZXRQaXhlbEZvclRpY2soaW5kZXgpICsgbGFiZWxPZmZzZXQ7IC8vIHggdmFsdWVzIGZvciBvcHRpb25UaWNrcyAobmVlZCB0byBjb25zaWRlciBvZmZzZXRMYWJlbCBvcHRpb24pXG5cblx0XHRcdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuXHRcdFx0XHRcdHkxID0gYWxpZ25QaXhlbChjaGFydCwgY2hhcnRBcmVhLnRvcCwgYXhpc1dpZHRoKSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHRcdFx0eTIgPSBjaGFydEFyZWEuYm90dG9tO1xuXHRcdFx0XHRcdHRleHRPZmZzZXQgPSAoKCFpc1JvdGF0ZWQgPyAwLjUgOiAxKSAtIGxhYmVsQ291bnQpICogbGluZUhlaWdodDtcblx0XHRcdFx0XHR0ZXh0QWxpZ24gPSAhaXNSb3RhdGVkID8gJ2NlbnRlcicgOiAnbGVmdCc7XG5cdFx0XHRcdFx0bGFiZWxZID0gbWUuYm90dG9tIC0gbGFiZWxZT2Zmc2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHkxID0gY2hhcnRBcmVhLnRvcDtcblx0XHRcdFx0XHR5MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS5ib3R0b20sIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuXHRcdFx0XHRcdHRleHRPZmZzZXQgPSAoIWlzUm90YXRlZCA/IDAuNSA6IDApICogbGluZUhlaWdodDtcblx0XHRcdFx0XHR0ZXh0QWxpZ24gPSAhaXNSb3RhdGVkID8gJ2NlbnRlcicgOiAncmlnaHQnO1xuXHRcdFx0XHRcdGxhYmVsWSA9IG1lLnRvcCArIGxhYmVsWU9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGxhYmVsWE9mZnNldCA9IChpc01pcnJvcmVkID8gMCA6IHRsKSArIHRpY2tQYWRkaW5nO1xuXG5cdFx0XHRcdGlmIChsaW5lVmFsdWUgPCBtZS50b3AgLSBlcHNpbG9uKSB7XG5cdFx0XHRcdFx0bGluZUNvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHgxID0gdGlja1N0YXJ0O1xuXHRcdFx0XHR0eDIgPSB0aWNrRW5kO1xuXHRcdFx0XHR0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuXHRcdFx0XHRsYWJlbFkgPSBtZS5nZXRQaXhlbEZvclRpY2soaW5kZXgpICsgbGFiZWxPZmZzZXQ7XG5cdFx0XHRcdHRleHRPZmZzZXQgPSAoMSAtIGxhYmVsQ291bnQpICogbGluZUhlaWdodCAvIDI7XG5cblx0XHRcdFx0aWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcblx0XHRcdFx0XHR4MSA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS5sZWZ0LCBheGlzV2lkdGgpICsgYXhpc1dpZHRoIC8gMjtcblx0XHRcdFx0XHR4MiA9IGNoYXJ0QXJlYS5yaWdodDtcblx0XHRcdFx0XHR0ZXh0QWxpZ24gPSBpc01pcnJvcmVkID8gJ2xlZnQnIDogJ3JpZ2h0Jztcblx0XHRcdFx0XHRsYWJlbFggPSBtZS5yaWdodCAtIGxhYmVsWE9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuXHRcdFx0XHRcdHgyID0gYWxpZ25QaXhlbChjaGFydCwgY2hhcnRBcmVhLnJpZ2h0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcblx0XHRcdFx0XHR0ZXh0QWxpZ24gPSBpc01pcnJvcmVkID8gJ3JpZ2h0JyA6ICdsZWZ0Jztcblx0XHRcdFx0XHRsYWJlbFggPSBtZS5sZWZ0ICsgbGFiZWxYT2Zmc2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGl0ZW1zVG9EcmF3LnB1c2goe1xuXHRcdFx0XHR0eDE6IHR4MSxcblx0XHRcdFx0dHkxOiB0eTEsXG5cdFx0XHRcdHR4MjogdHgyLFxuXHRcdFx0XHR0eTI6IHR5Mixcblx0XHRcdFx0eDE6IHgxLFxuXHRcdFx0XHR5MTogeTEsXG5cdFx0XHRcdHgyOiB4Mixcblx0XHRcdFx0eTI6IHkyLFxuXHRcdFx0XHRsYWJlbFg6IGxhYmVsWCxcblx0XHRcdFx0bGFiZWxZOiBsYWJlbFksXG5cdFx0XHRcdGdsV2lkdGg6IGxpbmVXaWR0aCxcblx0XHRcdFx0Z2xDb2xvcjogbGluZUNvbG9yLFxuXHRcdFx0XHRnbEJvcmRlckRhc2g6IGJvcmRlckRhc2gsXG5cdFx0XHRcdGdsQm9yZGVyRGFzaE9mZnNldDogYm9yZGVyRGFzaE9mZnNldCxcblx0XHRcdFx0cm90YXRpb246IC0xICogbGFiZWxSb3RhdGlvblJhZGlhbnMsXG5cdFx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdFx0bWFqb3I6IHRpY2subWFqb3IsXG5cdFx0XHRcdHRleHRPZmZzZXQ6IHRleHRPZmZzZXQsXG5cdFx0XHRcdHRleHRBbGlnbjogdGV4dEFsaWduXG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdC8vIERyYXcgYWxsIG9mIHRoZSB0aWNrIGxhYmVscywgdGljayBtYXJrcywgYW5kIGdyaWQgbGluZXMgYXQgdGhlIGNvcnJlY3QgcGxhY2VzXG5cdFx0aGVscGVycyQxLmVhY2goaXRlbXNUb0RyYXcsIGZ1bmN0aW9uKGl0ZW1Ub0RyYXcpIHtcblx0XHRcdHZhciBnbFdpZHRoID0gaXRlbVRvRHJhdy5nbFdpZHRoO1xuXHRcdFx0dmFyIGdsQ29sb3IgPSBpdGVtVG9EcmF3LmdsQ29sb3I7XG5cblx0XHRcdGlmIChncmlkTGluZXMuZGlzcGxheSAmJiBnbFdpZHRoICYmIGdsQ29sb3IpIHtcblx0XHRcdFx0Y29udGV4dC5zYXZlKCk7XG5cdFx0XHRcdGNvbnRleHQubGluZVdpZHRoID0gZ2xXaWR0aDtcblx0XHRcdFx0Y29udGV4dC5zdHJva2VTdHlsZSA9IGdsQ29sb3I7XG5cdFx0XHRcdGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG5cdFx0XHRcdFx0Y29udGV4dC5zZXRMaW5lRGFzaChpdGVtVG9EcmF3LmdsQm9yZGVyRGFzaCk7XG5cdFx0XHRcdFx0Y29udGV4dC5saW5lRGFzaE9mZnNldCA9IGl0ZW1Ub0RyYXcuZ2xCb3JkZXJEYXNoT2Zmc2V0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29udGV4dC5iZWdpblBhdGgoKTtcblxuXHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdUaWNrcykge1xuXHRcdFx0XHRcdGNvbnRleHQubW92ZVRvKGl0ZW1Ub0RyYXcudHgxLCBpdGVtVG9EcmF3LnR5MSk7XG5cdFx0XHRcdFx0Y29udGV4dC5saW5lVG8oaXRlbVRvRHJhdy50eDIsIGl0ZW1Ub0RyYXcudHkyKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChncmlkTGluZXMuZHJhd09uQ2hhcnRBcmVhKSB7XG5cdFx0XHRcdFx0Y29udGV4dC5tb3ZlVG8oaXRlbVRvRHJhdy54MSwgaXRlbVRvRHJhdy55MSk7XG5cdFx0XHRcdFx0Y29udGV4dC5saW5lVG8oaXRlbVRvRHJhdy54MiwgaXRlbVRvRHJhdy55Mik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0XHRjb250ZXh0LnJlc3RvcmUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvblRpY2tzLmRpc3BsYXkpIHtcblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIGRyYXcgdGV4dCBpbiB0aGUgY29ycmVjdCBjb2xvciBhbmQgZm9udFxuXHRcdFx0XHRjb250ZXh0LnNhdmUoKTtcblx0XHRcdFx0Y29udGV4dC50cmFuc2xhdGUoaXRlbVRvRHJhdy5sYWJlbFgsIGl0ZW1Ub0RyYXcubGFiZWxZKTtcblx0XHRcdFx0Y29udGV4dC5yb3RhdGUoaXRlbVRvRHJhdy5yb3RhdGlvbik7XG5cdFx0XHRcdGNvbnRleHQuZm9udCA9IGl0ZW1Ub0RyYXcubWFqb3IgPyBtYWpvclRpY2tGb250LnN0cmluZyA6IHRpY2tGb250LnN0cmluZztcblx0XHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSBpdGVtVG9EcmF3Lm1ham9yID8gbWFqb3JUaWNrRm9udENvbG9yIDogdGlja0ZvbnRDb2xvcjtcblx0XHRcdFx0Y29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdFx0Y29udGV4dC50ZXh0QWxpZ24gPSBpdGVtVG9EcmF3LnRleHRBbGlnbjtcblxuXHRcdFx0XHR2YXIgbGFiZWwgPSBpdGVtVG9EcmF3LmxhYmVsO1xuXHRcdFx0XHR2YXIgeSA9IGl0ZW1Ub0RyYXcudGV4dE9mZnNldDtcblx0XHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGxhYmVsKSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGFiZWwubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRcdC8vIFdlIGp1c3QgbWFrZSBzdXJlIHRoZSBtdWx0aWxpbmUgZWxlbWVudCBpcyBhIHN0cmluZyBoZXJlLi5cblx0XHRcdFx0XHRcdGNvbnRleHQuZmlsbFRleHQoJycgKyBsYWJlbFtpXSwgMCwgeSk7XG5cdFx0XHRcdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRleHQuZmlsbFRleHQobGFiZWwsIDAsIHkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRleHQucmVzdG9yZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKHNjYWxlTGFiZWwuZGlzcGxheSkge1xuXHRcdFx0Ly8gRHJhdyB0aGUgc2NhbGUgbGFiZWxcblx0XHRcdHZhciBzY2FsZUxhYmVsWDtcblx0XHRcdHZhciBzY2FsZUxhYmVsWTtcblx0XHRcdHZhciByb3RhdGlvbiA9IDA7XG5cdFx0XHR2YXIgaGFsZkxpbmVIZWlnaHQgPSBzY2FsZUxhYmVsRm9udC5saW5lSGVpZ2h0IC8gMjtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRzY2FsZUxhYmVsWCA9IG1lLmxlZnQgKyAoKG1lLnJpZ2h0IC0gbWUubGVmdCkgLyAyKTsgLy8gbWlkcG9pbnQgb2YgdGhlIHdpZHRoXG5cdFx0XHRcdHNjYWxlTGFiZWxZID0gcG9zaXRpb24gPT09ICdib3R0b20nXG5cdFx0XHRcdFx0PyBtZS5ib3R0b20gLSBoYWxmTGluZUhlaWdodCAtIHNjYWxlTGFiZWxQYWRkaW5nLmJvdHRvbVxuXHRcdFx0XHRcdDogbWUudG9wICsgaGFsZkxpbmVIZWlnaHQgKyBzY2FsZUxhYmVsUGFkZGluZy50b3A7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgaXNMZWZ0ID0gcG9zaXRpb24gPT09ICdsZWZ0Jztcblx0XHRcdFx0c2NhbGVMYWJlbFggPSBpc0xlZnRcblx0XHRcdFx0XHQ/IG1lLmxlZnQgKyBoYWxmTGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLnRvcFxuXHRcdFx0XHRcdDogbWUucmlnaHQgLSBoYWxmTGluZUhlaWdodCAtIHNjYWxlTGFiZWxQYWRkaW5nLnRvcDtcblx0XHRcdFx0c2NhbGVMYWJlbFkgPSBtZS50b3AgKyAoKG1lLmJvdHRvbSAtIG1lLnRvcCkgLyAyKTtcblx0XHRcdFx0cm90YXRpb24gPSBpc0xlZnQgPyAtMC41ICogTWF0aC5QSSA6IDAuNSAqIE1hdGguUEk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0Y29udGV4dC50cmFuc2xhdGUoc2NhbGVMYWJlbFgsIHNjYWxlTGFiZWxZKTtcblx0XHRcdGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcblx0XHRcdGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0Y29udGV4dC5maWxsU3R5bGUgPSBzY2FsZUxhYmVsRm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblx0XHRcdGNvbnRleHQuZm9udCA9IHNjYWxlTGFiZWxGb250LnN0cmluZztcblx0XHRcdGNvbnRleHQuZmlsbFRleHQoc2NhbGVMYWJlbC5sYWJlbFN0cmluZywgMCwgMCk7XG5cdFx0XHRjb250ZXh0LnJlc3RvcmUoKTtcblx0XHR9XG5cblx0XHRpZiAoYXhpc1dpZHRoKSB7XG5cdFx0XHQvLyBEcmF3IHRoZSBsaW5lIGF0IHRoZSBlZGdlIG9mIHRoZSBheGlzXG5cdFx0XHR2YXIgZmlyc3RMaW5lV2lkdGggPSBheGlzV2lkdGg7XG5cdFx0XHR2YXIgbGFzdExpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCB0aWNrcy5sZW5ndGggLSAxLCAwKTtcblx0XHRcdHZhciB4MSwgeDIsIHkxLCB5MjtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHR4MSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLmxlZnQsIGZpcnN0TGluZVdpZHRoKSAtIGZpcnN0TGluZVdpZHRoIC8gMjtcblx0XHRcdFx0eDIgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcblx0XHRcdFx0eTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eTEgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS50b3AsIGZpcnN0TGluZVdpZHRoKSAtIGZpcnN0TGluZVdpZHRoIC8gMjtcblx0XHRcdFx0eTIgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5ib3R0b20sIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHgxID0geDIgPSBib3JkZXJWYWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGV4dC5saW5lV2lkdGggPSBheGlzV2lkdGg7XG5cdFx0XHRjb250ZXh0LnN0cm9rZVN0eWxlID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0KGdyaWRMaW5lcy5jb2xvciwgMCk7XG5cdFx0XHRjb250ZXh0LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y29udGV4dC5tb3ZlVG8oeDEsIHkxKTtcblx0XHRcdGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG5cdFx0XHRjb250ZXh0LnN0cm9rZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBkZWZhdWx0Q29uZmlnID0ge1xuXHRwb3NpdGlvbjogJ2JvdHRvbSdcbn07XG5cbnZhciBzY2FsZV9jYXRlZ29yeSA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0LyoqXG5cdCogSW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2V0IHRoZSBjb3JyZWN0IGxhYmVscy4gSWYgZGF0YS54TGFiZWxzIG9yIGRhdGEueUxhYmVscyBhcmUgZGVmaW5lZCwgdXNlIHRob3NlXG5cdCogZWxzZSBmYWxsIGJhY2sgdG8gZGF0YS5sYWJlbHNcblx0KiBAcHJpdmF0ZVxuXHQqL1xuXHRnZXRMYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscztcblx0fSxcblxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcblx0XHRtZS5taW5JbmRleCA9IDA7XG5cdFx0bWUubWF4SW5kZXggPSBsYWJlbHMubGVuZ3RoIC0gMTtcblx0XHR2YXIgZmluZEluZGV4O1xuXG5cdFx0aWYgKG1lLm9wdGlvbnMudGlja3MubWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIHVzZXIgc3BlY2lmaWVkIG1pbiB2YWx1ZVxuXHRcdFx0ZmluZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWUub3B0aW9ucy50aWNrcy5taW4pO1xuXHRcdFx0bWUubWluSW5kZXggPSBmaW5kSW5kZXggIT09IC0xID8gZmluZEluZGV4IDogbWUubWluSW5kZXg7XG5cdFx0fVxuXG5cdFx0aWYgKG1lLm9wdGlvbnMudGlja3MubWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vIHVzZXIgc3BlY2lmaWVkIG1heCB2YWx1ZVxuXHRcdFx0ZmluZEluZGV4ID0gbGFiZWxzLmluZGV4T2YobWUub3B0aW9ucy50aWNrcy5tYXgpO1xuXHRcdFx0bWUubWF4SW5kZXggPSBmaW5kSW5kZXggIT09IC0xID8gZmluZEluZGV4IDogbWUubWF4SW5kZXg7XG5cdFx0fVxuXG5cdFx0bWUubWluID0gbGFiZWxzW21lLm1pbkluZGV4XTtcblx0XHRtZS5tYXggPSBsYWJlbHNbbWUubWF4SW5kZXhdO1xuXHR9LFxuXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGxhYmVscyA9IG1lLmdldExhYmVscygpO1xuXHRcdC8vIElmIHdlIGFyZSB2aWV3aW5nIHNvbWUgc3Vic2V0IG9mIGxhYmVscywgc2xpY2UgdGhlIG9yaWdpbmFsIGFycmF5XG5cdFx0bWUudGlja3MgPSAobWUubWluSW5kZXggPT09IDAgJiYgbWUubWF4SW5kZXggPT09IGxhYmVscy5sZW5ndGggLSAxKSA/IGxhYmVscyA6IGxhYmVscy5zbGljZShtZS5taW5JbmRleCwgbWUubWF4SW5kZXggKyAxKTtcblx0fSxcblxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblxuXHRcdGlmIChjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuX2dldFZhbHVlU2NhbGVJZCgpID09PSBtZS5pZCkge1xuXHRcdFx0cmV0dXJuIG1lLmdldFJpZ2h0VmFsdWUoY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWUudGlja3NbaW5kZXggLSBtZS5taW5JbmRleF07XG5cdH0sXG5cblx0Ly8gVXNlZCB0byBnZXQgZGF0YSB2YWx1ZSBsb2NhdGlvbnMuICBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9mZnNldCA9IG1lLm9wdGlvbnMub2Zmc2V0O1xuXHRcdC8vIDEgaXMgYWRkZWQgYmVjYXVzZSB3ZSBuZWVkIHRoZSBsZW5ndGggYnV0IHdlIGhhdmUgdGhlIGluZGV4ZXNcblx0XHR2YXIgb2Zmc2V0QW10ID0gTWF0aC5tYXgoKG1lLm1heEluZGV4ICsgMSAtIG1lLm1pbkluZGV4IC0gKG9mZnNldCA/IDAgOiAxKSksIDEpO1xuXG5cdFx0Ly8gSWYgdmFsdWUgaXMgYSBkYXRhIG9iamVjdCwgdGhlbiBpbmRleCBpcyB0aGUgaW5kZXggaW4gdGhlIGRhdGEgYXJyYXksXG5cdFx0Ly8gbm90IHRoZSBpbmRleCBvZiB0aGUgc2NhbGUuIFdlIG5lZWQgdG8gY2hhbmdlIHRoYXQuXG5cdFx0dmFyIHZhbHVlQ2F0ZWdvcnk7XG5cdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcblx0XHRcdHZhbHVlQ2F0ZWdvcnkgPSBtZS5pc0hvcml6b250YWwoKSA/IHZhbHVlLnggOiB2YWx1ZS55O1xuXHRcdH1cblx0XHRpZiAodmFsdWVDYXRlZ29yeSAhPT0gdW5kZWZpbmVkIHx8ICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGlzTmFOKGluZGV4KSkpIHtcblx0XHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcblx0XHRcdHZhbHVlID0gdmFsdWVDYXRlZ29yeSB8fCB2YWx1ZTtcblx0XHRcdHZhciBpZHggPSBsYWJlbHMuaW5kZXhPZih2YWx1ZSk7XG5cdFx0XHRpbmRleCA9IGlkeCAhPT0gLTEgPyBpZHggOiBpbmRleDtcblx0XHR9XG5cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdHZhciB2YWx1ZVdpZHRoID0gbWUud2lkdGggLyBvZmZzZXRBbXQ7XG5cdFx0XHR2YXIgd2lkdGhPZmZzZXQgPSAodmFsdWVXaWR0aCAqIChpbmRleCAtIG1lLm1pbkluZGV4KSk7XG5cblx0XHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdFx0d2lkdGhPZmZzZXQgKz0gKHZhbHVlV2lkdGggLyAyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lLmxlZnQgKyB3aWR0aE9mZnNldDtcblx0XHR9XG5cdFx0dmFyIHZhbHVlSGVpZ2h0ID0gbWUuaGVpZ2h0IC8gb2Zmc2V0QW10O1xuXHRcdHZhciBoZWlnaHRPZmZzZXQgPSAodmFsdWVIZWlnaHQgKiAoaW5kZXggLSBtZS5taW5JbmRleCkpO1xuXG5cdFx0aWYgKG9mZnNldCkge1xuXHRcdFx0aGVpZ2h0T2Zmc2V0ICs9ICh2YWx1ZUhlaWdodCAvIDIpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZS50b3AgKyBoZWlnaHRPZmZzZXQ7XG5cdH0sXG5cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy50aWNrc1tpbmRleF0sIGluZGV4ICsgdGhpcy5taW5JbmRleCwgbnVsbCk7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG9mZnNldEFtdCA9IE1hdGgubWF4KChtZS5fdGlja3MubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSksIDEpO1xuXHRcdHZhciBob3J6ID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIHZhbHVlRGltZW5zaW9uID0gKGhvcnogPyBtZS53aWR0aCA6IG1lLmhlaWdodCkgLyBvZmZzZXRBbXQ7XG5cblx0XHRwaXhlbCAtPSBob3J6ID8gbWUubGVmdCA6IG1lLnRvcDtcblxuXHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdHBpeGVsIC09ICh2YWx1ZURpbWVuc2lvbiAvIDIpO1xuXHRcdH1cblxuXHRcdGlmIChwaXhlbCA8PSAwKSB7XG5cdFx0XHR2YWx1ZSA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlID0gTWF0aC5yb3VuZChwaXhlbCAvIHZhbHVlRGltZW5zaW9uKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWUgKyBtZS5taW5JbmRleDtcblx0fSxcblxuXHRnZXRCYXNlUGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmJvdHRvbTtcblx0fVxufSk7XG5cbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xudmFyIF9kZWZhdWx0cyA9IGRlZmF1bHRDb25maWc7XG5zY2FsZV9jYXRlZ29yeS5fZGVmYXVsdHMgPSBfZGVmYXVsdHM7XG5cbnZhciBub29wID0gaGVscGVycyQxLm5vb3A7XG52YXIgaXNOdWxsT3JVbmRlZiA9IGhlbHBlcnMkMS5pc051bGxPclVuZGVmO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxpbmVhciB0aWNrc1xuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge251bWJlcltdfSBhcnJheSBvZiB0aWNrIHZhbHVlc1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcblx0dmFyIHRpY2tzID0gW107XG5cdC8vIFRvIGdldCBhIFwibmljZVwiIHZhbHVlIGZvciB0aGUgdGljayBzcGFjaW5nLCB3ZSB3aWxsIHVzZSB0aGUgYXBwcm9wcmlhdGVseSBuYW1lZFxuXHQvLyBcIm5pY2UgbnVtYmVyXCIgYWxnb3JpdGhtLiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNjg4MS9uaWNlLWxhYmVsLWFsZ29yaXRobS1mb3ItY2hhcnRzLXdpdGgtbWluaW11bS10aWNrc1xuXHQvLyBmb3IgZGV0YWlscy5cblxuXHR2YXIgTUlOX1NQQUNJTkcgPSAxZS0xNDtcblx0dmFyIHN0ZXBTaXplID0gZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcFNpemU7XG5cdHZhciB1bml0ID0gc3RlcFNpemUgfHwgMTtcblx0dmFyIG1heE51bVNwYWNlcyA9IGdlbmVyYXRpb25PcHRpb25zLm1heFRpY2tzIC0gMTtcblx0dmFyIG1pbiA9IGdlbmVyYXRpb25PcHRpb25zLm1pbjtcblx0dmFyIG1heCA9IGdlbmVyYXRpb25PcHRpb25zLm1heDtcblx0dmFyIHByZWNpc2lvbiA9IGdlbmVyYXRpb25PcHRpb25zLnByZWNpc2lvbjtcblx0dmFyIHJtaW4gPSBkYXRhUmFuZ2UubWluO1xuXHR2YXIgcm1heCA9IGRhdGFSYW5nZS5tYXg7XG5cdHZhciBzcGFjaW5nID0gaGVscGVycyQxLm5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heE51bVNwYWNlcyAvIHVuaXQpICogdW5pdDtcblx0dmFyIGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xuXG5cdC8vIEJleW9uZCBNSU5fU1BBQ0lORyBmbG9hdGluZyBwb2ludCBudW1iZXJzIGJlaW5nIHRvIGxvc2UgcHJlY2lzaW9uXG5cdC8vIHN1Y2ggdGhhdCB3ZSBjYW4ndCBkbyB0aGUgbWF0aCBuZWNlc3NhcnkgdG8gZ2VuZXJhdGUgdGlja3Ncblx0aWYgKHNwYWNpbmcgPCBNSU5fU1BBQ0lORyAmJiBpc051bGxPclVuZGVmKG1pbikgJiYgaXNOdWxsT3JVbmRlZihtYXgpKSB7XG5cdFx0cmV0dXJuIFtybWluLCBybWF4XTtcblx0fVxuXG5cdG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcblx0aWYgKG51bVNwYWNlcyA+IG1heE51bVNwYWNlcykge1xuXHRcdC8vIElmIHRoZSBjYWxjdWxhdGVkIG51bSBvZiBzcGFjZXMgZXhjZWVkcyBtYXhOdW1TcGFjZXMsIHJlY2FsY3VsYXRlIGl0XG5cdFx0c3BhY2luZyA9IGhlbHBlcnMkMS5uaWNlTnVtKG51bVNwYWNlcyAqIHNwYWNpbmcgLyBtYXhOdW1TcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG5cdH1cblxuXHRpZiAoc3RlcFNpemUgfHwgaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG5cdFx0Ly8gSWYgYSBwcmVjaXNpb24gaXMgbm90IHNwZWNpZmllZCwgY2FsY3VsYXRlIGZhY3RvciBiYXNlZCBvbiBzcGFjaW5nXG5cdFx0ZmFjdG9yID0gTWF0aC5wb3coMTAsIGhlbHBlcnMkMS5fZGVjaW1hbFBsYWNlcyhzcGFjaW5nKSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgcHJlY2lzaW9uLCByb3VuZCB0byB0aGF0IG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuXHRcdGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuXHRcdHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG5cdH1cblxuXHRuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xuXHRuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG5cblx0Ly8gSWYgbWluLCBtYXggYW5kIHN0ZXBTaXplIGlzIHNldCBhbmQgdGhleSBtYWtlIGFuIGV2ZW5seSBzcGFjZWQgc2NhbGUgdXNlIGl0LlxuXHRpZiAoc3RlcFNpemUpIHtcblx0XHQvLyBJZiB2ZXJ5IGNsb3NlIHRvIG91ciB3aG9sZSBudW1iZXIsIHVzZSBpdC5cblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYobWluKSAmJiBoZWxwZXJzJDEuYWxtb3N0V2hvbGUobWluIC8gc3BhY2luZywgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0XHRuaWNlTWluID0gbWluO1xuXHRcdH1cblx0XHRpZiAoIWlzTnVsbE9yVW5kZWYobWF4KSAmJiBoZWxwZXJzJDEuYWxtb3N0V2hvbGUobWF4IC8gc3BhY2luZywgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0XHRuaWNlTWF4ID0gbWF4O1xuXHRcdH1cblx0fVxuXG5cdG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xuXHQvLyBJZiB2ZXJ5IGNsb3NlIHRvIG91ciByb3VuZGVkIHZhbHVlLCB1c2UgaXQuXG5cdGlmIChoZWxwZXJzJDEuYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcblx0XHRudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG5cdH0gZWxzZSB7XG5cdFx0bnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG5cdH1cblxuXHRuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3Rvcjtcblx0bmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG5cdHRpY2tzLnB1c2goaXNOdWxsT3JVbmRlZihtaW4pID8gbmljZU1pbiA6IG1pbik7XG5cdGZvciAodmFyIGogPSAxOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcblx0XHR0aWNrcy5wdXNoKE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yKTtcblx0fVxuXHR0aWNrcy5wdXNoKGlzTnVsbE9yVW5kZWYobWF4KSA/IG5pY2VNYXggOiBtYXgpO1xuXG5cdHJldHVybiB0aWNrcztcbn1cblxudmFyIHNjYWxlX2xpbmVhcmJhc2UgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XG5cdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiArdmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS5nZXRSaWdodFZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xuXHR9LFxuXG5cdGhhbmRsZVRpY2tSYW5nZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHQvLyBJZiB3ZSBhcmUgZm9yY2luZyBpdCB0byBiZWdpbiBhdCAwLCBidXQgMCB3aWxsIGFscmVhZHkgYmUgcmVuZGVyZWQgb24gdGhlIGNoYXJ0LFxuXHRcdC8vIGRvIG5vdGhpbmcgc2luY2UgdGhhdCB3b3VsZCBtYWtlIHRoZSBjaGFydCB3ZWlyZC4gSWYgdGhlIHVzZXIgcmVhbGx5IHdhbnRzIGEgd2VpcmQgY2hhcnRcblx0XHQvLyBheGlzLCB0aGV5IGNhbiBtYW51YWxseSBvdmVycmlkZSBpdFxuXHRcdGlmICh0aWNrT3B0cy5iZWdpbkF0WmVybykge1xuXHRcdFx0dmFyIG1pblNpZ24gPSBoZWxwZXJzJDEuc2lnbihtZS5taW4pO1xuXHRcdFx0dmFyIG1heFNpZ24gPSBoZWxwZXJzJDEuc2lnbihtZS5tYXgpO1xuXG5cdFx0XHRpZiAobWluU2lnbiA8IDAgJiYgbWF4U2lnbiA8IDApIHtcblx0XHRcdFx0Ly8gbW92ZSB0aGUgdG9wIHVwIHRvIDBcblx0XHRcdFx0bWUubWF4ID0gMDtcblx0XHRcdH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcblx0XHRcdFx0Ly8gbW92ZSB0aGUgYm90dG9tIGRvd24gdG8gMFxuXHRcdFx0XHRtZS5taW4gPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBzZXRNaW4gPSB0aWNrT3B0cy5taW4gIT09IHVuZGVmaW5lZCB8fCB0aWNrT3B0cy5zdWdnZXN0ZWRNaW4gIT09IHVuZGVmaW5lZDtcblx0XHR2YXIgc2V0TWF4ID0gdGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWF4ICE9PSB1bmRlZmluZWQ7XG5cblx0XHRpZiAodGlja09wdHMubWluICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdG1lLm1pbiA9IHRpY2tPcHRzLm1pbjtcblx0XHR9IGVsc2UgaWYgKHRpY2tPcHRzLnN1Z2dlc3RlZE1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdG1lLm1pbiA9IHRpY2tPcHRzLnN1Z2dlc3RlZE1pbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1pbiA9IE1hdGgubWluKG1lLm1pbiwgdGlja09wdHMuc3VnZ2VzdGVkTWluKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGlja09wdHMubWF4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdG1lLm1heCA9IHRpY2tPcHRzLm1heDtcblx0XHR9IGVsc2UgaWYgKHRpY2tPcHRzLnN1Z2dlc3RlZE1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRcdG1lLm1heCA9IHRpY2tPcHRzLnN1Z2dlc3RlZE1heDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1heCA9IE1hdGgubWF4KG1lLm1heCwgdGlja09wdHMuc3VnZ2VzdGVkTWF4KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoc2V0TWluICE9PSBzZXRNYXgpIHtcblx0XHRcdC8vIFdlIHNldCB0aGUgbWluIG9yIHRoZSBtYXggYnV0IG5vdCBib3RoLlxuXHRcdFx0Ly8gU28gZW5zdXJlIHRoYXQgb3VyIHJhbmdlIGlzIGdvb2Rcblx0XHRcdC8vIEludmVydGVkIG9yIDAgbGVuZ3RoIHJhbmdlIGNhbiBoYXBwZW4gd2hlblxuXHRcdFx0Ly8gdGlja3MubWluIGlzIHNldCwgYW5kIG5vIGRhdGFzZXRzIGFyZSB2aXNpYmxlXG5cdFx0XHRpZiAobWUubWluID49IG1lLm1heCkge1xuXHRcdFx0XHRpZiAoc2V0TWluKSB7XG5cdFx0XHRcdFx0bWUubWF4ID0gbWUubWluICsgMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtZS5taW4gPSBtZS5tYXggLSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1lLm1pbiA9PT0gbWUubWF4KSB7XG5cdFx0XHRtZS5tYXgrKztcblxuXHRcdFx0aWYgKCF0aWNrT3B0cy5iZWdpbkF0WmVybykge1xuXHRcdFx0XHRtZS5taW4tLTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0VGlja0xpbWl0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIHN0ZXBTaXplID0gdGlja09wdHMuc3RlcFNpemU7XG5cdFx0dmFyIG1heFRpY2tzTGltaXQgPSB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0O1xuXHRcdHZhciBtYXhUaWNrcztcblxuXHRcdGlmIChzdGVwU2l6ZSkge1xuXHRcdFx0bWF4VGlja3MgPSBNYXRoLmNlaWwobWUubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcihtZS5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXhUaWNrcyA9IG1lLl9jb21wdXRlVGlja0xpbWl0KCk7XG5cdFx0XHRtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcblx0XHR9XG5cblx0XHRpZiAobWF4VGlja3NMaW1pdCkge1xuXHRcdFx0bWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1heFRpY2tzO1xuXHR9LFxuXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHR9LFxuXG5cdGhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlczogbm9vcCxcblxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG5cdFx0Ly8gRmlndXJlIG91dCB3aGF0IHRoZSBtYXggbnVtYmVyIG9mIHRpY2tzIHdlIGNhbiBzdXBwb3J0IGl0IGlzIGJhc2VkIG9uIHRoZSBzaXplIG9mXG5cdFx0Ly8gdGhlIGF4aXMgYXJlYS4gRm9yIG5vdywgd2Ugc2F5IHRoYXQgdGhlIG1pbmltdW0gdGljayBzcGFjaW5nIGluIHBpeGVscyBtdXN0IGJlIDQwXG5cdFx0Ly8gV2UgYWxzbyBsaW1pdCB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgdG8gMTEgd2hpY2ggZ2l2ZXMgYSBuaWNlIDEwIHNxdWFyZXMgb25cblx0XHQvLyB0aGUgZ3JhcGguIE1ha2Ugc3VyZSB3ZSBhbHdheXMgaGF2ZSBhdCBsZWFzdCAyIHRpY2tzXG5cdFx0dmFyIG1heFRpY2tzID0gbWUuZ2V0VGlja0xpbWl0KCk7XG5cdFx0bWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG5cblx0XHR2YXIgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG5cdFx0XHRtYXhUaWNrczogbWF4VGlja3MsXG5cdFx0XHRtaW46IHRpY2tPcHRzLm1pbixcblx0XHRcdG1heDogdGlja09wdHMubWF4LFxuXHRcdFx0cHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG5cdFx0XHRzdGVwU2l6ZTogaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZpeGVkU3RlcFNpemUsIHRpY2tPcHRzLnN0ZXBTaXplKVxuXHRcdH07XG5cdFx0dmFyIHRpY2tzID0gbWUudGlja3MgPSBnZW5lcmF0ZVRpY2tzKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBtZSk7XG5cblx0XHRtZS5oYW5kbGVEaXJlY3Rpb25hbENoYW5nZXMoKTtcblxuXHRcdC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMgc2luY2Ugd2UgaGF2ZSBleHBhbmRlZCB0aGVcblx0XHQvLyByYW5nZSBvZiB0aGUgc2NhbGVcblx0XHRtZS5tYXggPSBoZWxwZXJzJDEubWF4KHRpY2tzKTtcblx0XHRtZS5taW4gPSBoZWxwZXJzJDEubWluKHRpY2tzKTtcblxuXHRcdGlmICh0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHR0aWNrcy5yZXZlcnNlKCk7XG5cblx0XHRcdG1lLnN0YXJ0ID0gbWUubWF4O1xuXHRcdFx0bWUuZW5kID0gbWUubWluO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5zdGFydCA9IG1lLm1pbjtcblx0XHRcdG1lLmVuZCA9IG1lLm1heDtcblx0XHR9XG5cdH0sXG5cblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0bWUudGlja3NBc051bWJlcnMgPSBtZS50aWNrcy5zbGljZSgpO1xuXHRcdG1lLnplcm9MaW5lSW5kZXggPSBtZS50aWNrcy5pbmRleE9mKDApO1xuXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XG5cdH1cbn0pO1xuXG52YXIgZGVmYXVsdENvbmZpZyQxID0ge1xuXHRwb3NpdGlvbjogJ2xlZnQnLFxuXHR0aWNrczoge1xuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdH1cbn07XG5cbnZhciBzY2FsZV9saW5lYXIgPSBzY2FsZV9saW5lYXJiYXNlLmV4dGVuZCh7XG5cdGRldGVybWluZURhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgREVGQVVMVF9NSU4gPSAwO1xuXHRcdHZhciBERUZBVUxUX01BWCA9IDE7XG5cblx0XHRmdW5jdGlvbiBJRE1hdGNoZXMobWV0YSkge1xuXHRcdFx0cmV0dXJuIGlzSG9yaXpvbnRhbCA/IG1ldGEueEF4aXNJRCA9PT0gbWUuaWQgOiBtZXRhLnlBeGlzSUQgPT09IG1lLmlkO1xuXHRcdH1cblxuXHRcdC8vIEZpcnN0IENhbGN1bGF0ZSB0aGUgcmFuZ2Vcblx0XHRtZS5taW4gPSBudWxsO1xuXHRcdG1lLm1heCA9IG51bGw7XG5cblx0XHR2YXIgaGFzU3RhY2tzID0gb3B0cy5zdGFja2VkO1xuXHRcdGlmIChoYXNTdGFja3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHRpZiAoaGFzU3RhY2tzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSAmJlxuXHRcdFx0XHRcdG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGhhc1N0YWNrcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChvcHRzLnN0YWNrZWQgfHwgaGFzU3RhY2tzKSB7XG5cdFx0XHR2YXIgdmFsdWVzUGVyU3RhY2sgPSB7fTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdHZhciBrZXkgPSBbXG5cdFx0XHRcdFx0bWV0YS50eXBlLFxuXHRcdFx0XHRcdC8vIHdlIGhhdmUgYSBzZXBhcmF0ZSBzdGFjayBmb3Igc3RhY2s9dW5kZWZpbmVkIGRhdGFzZXRzIHdoZW4gdGhlIG9wdHMuc3RhY2tlZCBpcyB1bmRlZmluZWRcblx0XHRcdFx0XHQoKG9wdHMuc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkgPyBkYXRhc2V0SW5kZXggOiAnJyksXG5cdFx0XHRcdFx0bWV0YS5zdGFja1xuXHRcdFx0XHRdLmpvaW4oJy4nKTtcblxuXHRcdFx0XHRpZiAodmFsdWVzUGVyU3RhY2tba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dmFsdWVzUGVyU3RhY2tba2V5XSA9IHtcblx0XHRcdFx0XHRcdHBvc2l0aXZlVmFsdWVzOiBbXSxcblx0XHRcdFx0XHRcdG5lZ2F0aXZlVmFsdWVzOiBbXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdG9yZSB0aGVzZSBwZXIgdHlwZVxuXHRcdFx0XHR2YXIgcG9zaXRpdmVWYWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldLnBvc2l0aXZlVmFsdWVzO1xuXHRcdFx0XHR2YXIgbmVnYXRpdmVWYWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldLm5lZ2F0aXZlVmFsdWVzO1xuXG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpKSB7XG5cdFx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlc1tpbmRleF0gPSBwb3NpdGl2ZVZhbHVlc1tpbmRleF0gfHwgMDtcblx0XHRcdFx0XHRcdG5lZ2F0aXZlVmFsdWVzW2luZGV4XSA9IG5lZ2F0aXZlVmFsdWVzW2luZGV4XSB8fCAwO1xuXG5cdFx0XHRcdFx0XHRpZiAob3B0cy5yZWxhdGl2ZVBvaW50cykge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlc1tpbmRleF0gPSAxMDA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlc1tpbmRleF0gKz0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlc1tpbmRleF0gKz0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh2YWx1ZXNQZXJTdGFjaywgZnVuY3Rpb24odmFsdWVzRm9yVHlwZSkge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gdmFsdWVzRm9yVHlwZS5wb3NpdGl2ZVZhbHVlcy5jb25jYXQodmFsdWVzRm9yVHlwZS5uZWdhdGl2ZVZhbHVlcyk7XG5cdFx0XHRcdHZhciBtaW5WYWwgPSBoZWxwZXJzJDEubWluKHZhbHVlcyk7XG5cdFx0XHRcdHZhciBtYXhWYWwgPSBoZWxwZXJzJDEubWF4KHZhbHVlcyk7XG5cdFx0XHRcdG1lLm1pbiA9IG1lLm1pbiA9PT0gbnVsbCA/IG1pblZhbCA6IE1hdGgubWluKG1lLm1pbiwgbWluVmFsKTtcblx0XHRcdFx0bWUubWF4ID0gbWUubWF4ID09PSBudWxsID8gbWF4VmFsIDogTWF0aC5tYXgobWUubWF4LCBtYXhWYWwpO1xuXHRcdFx0fSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpKSB7XG5cdFx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IG1lLm1pbikge1xuXHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPiBtZS5tYXgpIHtcblx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdG1lLm1pbiA9IGlzRmluaXRlKG1lLm1pbikgJiYgIWlzTmFOKG1lLm1pbikgPyBtZS5taW4gOiBERUZBVUxUX01JTjtcblx0XHRtZS5tYXggPSBpc0Zpbml0ZShtZS5tYXgpICYmICFpc05hTihtZS5tYXgpID8gbWUubWF4IDogREVGQVVMVF9NQVg7XG5cblx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXgsIHRpY2tzLmJlZ2luQXRaZXJvXG5cdFx0dGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja0ZvbnQ7XG5cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdHJldHVybiBNYXRoLmNlaWwobWUud2lkdGggLyA0MCk7XG5cdFx0fVxuXHRcdHRpY2tGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChtZS5vcHRpb25zLnRpY2tzKTtcblx0XHRyZXR1cm4gTWF0aC5jZWlsKG1lLmhlaWdodCAvIHRpY2tGb250LmxpbmVIZWlnaHQpO1xuXHR9LFxuXG5cdC8vIENhbGxlZCBhZnRlciB0aGUgdGlja3MgYXJlIGJ1aWx0LiBXZSBuZWVkXG5cdGhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBXZSBhcmUgaW4gYSB2ZXJ0aWNhbCBvcmllbnRhdGlvbi4gVGhlIHRvcCB2YWx1ZSBpcyB0aGUgaGlnaGVzdC4gU28gcmV2ZXJzZSB0aGUgYXJyYXlcblx0XHRcdHRoaXMudGlja3MucmV2ZXJzZSgpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0cmV0dXJuICt0aGlzLmdldFJpZ2h0VmFsdWUodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHR9LFxuXG5cdC8vIFV0aWxzXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0Ly8gVGhpcyBtdXN0IGJlIGNhbGxlZCBhZnRlciBmaXQgaGFzIGJlZW4gcnVuIHNvIHRoYXRcblx0XHQvLyB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLnJpZ2h0LCBhbmQgdGhpcy5ib3R0b20gaGF2ZSBiZWVuIGRlZmluZWRcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBzdGFydCA9IG1lLnN0YXJ0O1xuXG5cdFx0dmFyIHJpZ2h0VmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0dmFyIHBpeGVsO1xuXHRcdHZhciByYW5nZSA9IG1lLmVuZCAtIHN0YXJ0O1xuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRwaXhlbCA9IG1lLmxlZnQgKyAobWUud2lkdGggLyByYW5nZSAqIChyaWdodFZhbHVlIC0gc3RhcnQpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGl4ZWwgPSBtZS5ib3R0b20gLSAobWUuaGVpZ2h0IC8gcmFuZ2UgKiAocmlnaHRWYWx1ZSAtIHN0YXJ0KSk7XG5cdFx0fVxuXHRcdHJldHVybiBwaXhlbDtcblx0fSxcblxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBpbm5lckRpbWVuc2lvbiA9IGlzSG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBvZmZzZXQgPSAoaXNIb3Jpem9udGFsID8gcGl4ZWwgLSBtZS5sZWZ0IDogbWUuYm90dG9tIC0gcGl4ZWwpIC8gaW5uZXJEaW1lbnNpb247XG5cdFx0cmV0dXJuIG1lLnN0YXJ0ICsgKChtZS5lbmQgLSBtZS5zdGFydCkgKiBvZmZzZXQpO1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja3NBc051bWJlcnNbaW5kZXhdKTtcblx0fVxufSk7XG5cbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xudmFyIF9kZWZhdWx0cyQxID0gZGVmYXVsdENvbmZpZyQxO1xuc2NhbGVfbGluZWFyLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQxO1xuXG52YXIgdmFsdWVPckRlZmF1bHQkYSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsb2dhcml0aG1pYyB0aWNrc1xuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge251bWJlcltdfSBhcnJheSBvZiB0aWNrIHZhbHVlc1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzJDEoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuXHR2YXIgdGlja3MgPSBbXTtcblxuXHR2YXIgdGlja1ZhbCA9IHZhbHVlT3JEZWZhdWx0JGEoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAoZGF0YVJhbmdlLm1pbikpKSk7XG5cblx0dmFyIGVuZEV4cCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKGRhdGFSYW5nZS5tYXgpKTtcblx0dmFyIGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XG5cdHZhciBleHAsIHNpZ25pZmljYW5kO1xuXG5cdGlmICh0aWNrVmFsID09PSAwKSB7XG5cdFx0ZXhwID0gTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAoZGF0YVJhbmdlLm1pbk5vdFplcm8pKTtcblx0XHRzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IoZGF0YVJhbmdlLm1pbk5vdFplcm8gLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cblx0XHR0aWNrcy5wdXNoKHRpY2tWYWwpO1xuXHRcdHRpY2tWYWwgPSBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApO1xuXHR9IGVsc2Uge1xuXHRcdGV4cCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKHRpY2tWYWwpKTtcblx0XHRzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodGlja1ZhbCAvIE1hdGgucG93KDEwLCBleHApKTtcblx0fVxuXHR2YXIgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG5cblx0ZG8ge1xuXHRcdHRpY2tzLnB1c2godGlja1ZhbCk7XG5cblx0XHQrK3NpZ25pZmljYW5kO1xuXHRcdGlmIChzaWduaWZpY2FuZCA9PT0gMTApIHtcblx0XHRcdHNpZ25pZmljYW5kID0gMTtcblx0XHRcdCsrZXhwO1xuXHRcdFx0cHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xuXHRcdH1cblxuXHRcdHRpY2tWYWwgPSBNYXRoLnJvdW5kKHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuXHR9IHdoaWxlIChleHAgPCBlbmRFeHAgfHwgKGV4cCA9PT0gZW5kRXhwICYmIHNpZ25pZmljYW5kIDwgZW5kU2lnbmlmaWNhbmQpKTtcblxuXHR2YXIgbGFzdFRpY2sgPSB2YWx1ZU9yRGVmYXVsdCRhKGdlbmVyYXRpb25PcHRpb25zLm1heCwgdGlja1ZhbCk7XG5cdHRpY2tzLnB1c2gobGFzdFRpY2spO1xuXG5cdHJldHVybiB0aWNrcztcbn1cblxudmFyIGRlZmF1bHRDb25maWckMiA9IHtcblx0cG9zaXRpb246ICdsZWZ0JyxcblxuXHQvLyBsYWJlbCBzZXR0aW5nc1xuXHR0aWNrczoge1xuXHRcdGNhbGxiYWNrOiBjb3JlX3RpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWNcblx0fVxufTtcblxuLy8gVE9ETyh2Myk6IGNoYW5nZSB0aGlzIHRvIHBvc2l0aXZlT3JEZWZhdWx0XG5mdW5jdGlvbiBub25OZWdhdGl2ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG5cdHJldHVybiBoZWxwZXJzJDEuaXNGaW5pdGUodmFsdWUpICYmIHZhbHVlID49IDAgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbn1cblxudmFyIHNjYWxlX2xvZ2FyaXRobWljID0gY29yZV9zY2FsZS5leHRlbmQoe1xuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0ZnVuY3Rpb24gSURNYXRjaGVzKG1ldGEpIHtcblx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgUmFuZ2Vcblx0XHRtZS5taW4gPSBudWxsO1xuXHRcdG1lLm1heCA9IG51bGw7XG5cdFx0bWUubWluTm90WmVybyA9IG51bGw7XG5cblx0XHR2YXIgaGFzU3RhY2tzID0gb3B0cy5zdGFja2VkO1xuXHRcdGlmIChoYXNTdGFja3MgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHRpZiAoaGFzU3RhY2tzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSAmJlxuXHRcdFx0XHRcdG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGhhc1N0YWNrcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChvcHRzLnN0YWNrZWQgfHwgaGFzU3RhY2tzKSB7XG5cdFx0XHR2YXIgdmFsdWVzUGVyU3RhY2sgPSB7fTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdHZhciBrZXkgPSBbXG5cdFx0XHRcdFx0bWV0YS50eXBlLFxuXHRcdFx0XHRcdC8vIHdlIGhhdmUgYSBzZXBhcmF0ZSBzdGFjayBmb3Igc3RhY2s9dW5kZWZpbmVkIGRhdGFzZXRzIHdoZW4gdGhlIG9wdHMuc3RhY2tlZCBpcyB1bmRlZmluZWRcblx0XHRcdFx0XHQoKG9wdHMuc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkgPyBkYXRhc2V0SW5kZXggOiAnJyksXG5cdFx0XHRcdFx0bWV0YS5zdGFja1xuXHRcdFx0XHRdLmpvaW4oJy4nKTtcblxuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZXNQZXJTdGFja1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHZhbHVlc1BlclN0YWNrW2tleV0gPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRoZWxwZXJzJDEuZWFjaChkYXRhc2V0LmRhdGEsIGZ1bmN0aW9uKHJhd1ZhbHVlLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlcyA9IHZhbHVlc1BlclN0YWNrW2tleV07XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHQvLyBpbnZhbGlkLCBoaWRkZW4gYW5kIG5lZ2F0aXZlIHZhbHVlcyBhcmUgaWdub3JlZFxuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiB8fCB2YWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dmFsdWVzW2luZGV4XSA9IHZhbHVlc1tpbmRleF0gfHwgMDtcblx0XHRcdFx0XHRcdHZhbHVlc1tpbmRleF0gKz0gdmFsdWU7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh2YWx1ZXNQZXJTdGFjaywgZnVuY3Rpb24odmFsdWVzRm9yVHlwZSkge1xuXHRcdFx0XHRpZiAodmFsdWVzRm9yVHlwZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIG1pblZhbCA9IGhlbHBlcnMkMS5taW4odmFsdWVzRm9yVHlwZSk7XG5cdFx0XHRcdFx0dmFyIG1heFZhbCA9IGhlbHBlcnMkMS5tYXgodmFsdWVzRm9yVHlwZSk7XG5cdFx0XHRcdFx0bWUubWluID0gbWUubWluID09PSBudWxsID8gbWluVmFsIDogTWF0aC5taW4obWUubWluLCBtaW5WYWwpO1xuXHRcdFx0XHRcdG1lLm1heCA9IG1lLm1heCA9PT0gbnVsbCA/IG1heFZhbCA6IE1hdGgubWF4KG1lLm1heCwgbWF4VmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkgJiYgSURNYXRjaGVzKG1ldGEpKSB7XG5cdFx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlKTtcblx0XHRcdFx0XHRcdC8vIGludmFsaWQsIGhpZGRlbiBhbmQgbmVnYXRpdmUgdmFsdWVzIGFyZSBpZ25vcmVkXG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuIHx8IHZhbHVlIDwgMCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlIDwgbWUubWluKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+IG1lLm1heCkge1xuXHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICE9PSAwICYmIChtZS5taW5Ob3RaZXJvID09PSBudWxsIHx8IHZhbHVlIDwgbWUubWluTm90WmVybykpIHtcblx0XHRcdFx0XHRcdFx0bWUubWluTm90WmVybyA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBDb21tb24gYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBoYW5kbGUgdGlja3MubWluLCB0aWNrcy5tYXhcblx0XHR0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcblx0fSxcblxuXHRoYW5kbGVUaWNrUmFuZ2VPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIERFRkFVTFRfTUlOID0gMTtcblx0XHR2YXIgREVGQVVMVF9NQVggPSAxMDtcblxuXHRcdG1lLm1pbiA9IG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHRpY2tPcHRzLm1pbiwgbWUubWluKTtcblx0XHRtZS5tYXggPSBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5tYXgsIG1lLm1heCk7XG5cblx0XHRpZiAobWUubWluID09PSBtZS5tYXgpIHtcblx0XHRcdGlmIChtZS5taW4gIT09IDAgJiYgbWUubWluICE9PSBudWxsKSB7XG5cdFx0XHRcdG1lLm1pbiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChtZS5taW4pKSAtIDEpO1xuXHRcdFx0XHRtZS5tYXggPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWF4KSkgKyAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1pbiA9IERFRkFVTFRfTUlOO1xuXHRcdFx0XHRtZS5tYXggPSBERUZBVUxUX01BWDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0bWUubWluID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1heCkpIC0gMSk7XG5cdFx0fVxuXHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdG1lLm1heCA9IG1lLm1pbiAhPT0gMFxuXHRcdFx0XHQ/IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChtZS5taW4pKSArIDEpXG5cdFx0XHRcdDogREVGQVVMVF9NQVg7XG5cdFx0fVxuXHRcdGlmIChtZS5taW5Ob3RaZXJvID09PSBudWxsKSB7XG5cdFx0XHRpZiAobWUubWluID4gMCkge1xuXHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gbWUubWluO1xuXHRcdFx0fSBlbHNlIGlmIChtZS5tYXggPCAxKSB7XG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWF4KSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWUubWluTm90WmVybyA9IERFRkFVTFRfTUlOO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIHJldmVyc2UgPSAhbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHR2YXIgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG5cdFx0XHRtaW46IG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHRpY2tPcHRzLm1pbiksXG5cdFx0XHRtYXg6IG5vbk5lZ2F0aXZlT3JEZWZhdWx0KHRpY2tPcHRzLm1heClcblx0XHR9O1xuXHRcdHZhciB0aWNrcyA9IG1lLnRpY2tzID0gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBtZSk7XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXG5cdFx0Ly8gcmFuZ2Ugb2YgdGhlIHNjYWxlXG5cdFx0bWUubWF4ID0gaGVscGVycyQxLm1heCh0aWNrcyk7XG5cdFx0bWUubWluID0gaGVscGVycyQxLm1pbih0aWNrcyk7XG5cblx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0cmV2ZXJzZSA9ICFyZXZlcnNlO1xuXHRcdFx0bWUuc3RhcnQgPSBtZS5tYXg7XG5cdFx0XHRtZS5lbmQgPSBtZS5taW47XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLnN0YXJ0ID0gbWUubWluO1xuXHRcdFx0bWUuZW5kID0gbWUubWF4O1xuXHRcdH1cblx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXHRcdH1cblx0fSxcblxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50aWNrVmFsdWVzID0gdGhpcy50aWNrcy5zbGljZSgpO1xuXG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbCh0aGlzKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIGNvcnJlY3QgdG9vbHRpcCBsYWJlbFxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0cmV0dXJuICt0aGlzLmdldFJpZ2h0VmFsdWUodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja1ZhbHVlc1tpbmRleF0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgdGljay5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIG1pbmltdW0gbm90IHplcm8gdmFsdWUuXG5cdCAqIEByZXR1cm4ge251bWJlcn0gVGhlIGZpcnN0IHRpY2sgdmFsdWUuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0Rmlyc3RUaWNrVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIGV4cCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKHZhbHVlKSk7XG5cdFx0dmFyIHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcih2YWx1ZSAvIE1hdGgucG93KDEwLCBleHApKTtcblxuXHRcdHJldHVybiBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApO1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciByZXZlcnNlID0gdGlja09wdHMucmV2ZXJzZTtcblx0XHR2YXIgbG9nMTAgPSBoZWxwZXJzJDEubG9nMTA7XG5cdFx0dmFyIGZpcnN0VGlja1ZhbHVlID0gbWUuX2dldEZpcnN0VGlja1ZhbHVlKG1lLm1pbk5vdFplcm8pO1xuXHRcdHZhciBvZmZzZXQgPSAwO1xuXHRcdHZhciBpbm5lckRpbWVuc2lvbiwgcGl4ZWwsIHN0YXJ0LCBlbmQsIHNpZ247XG5cblx0XHR2YWx1ZSA9ICttZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcblx0XHRpZiAocmV2ZXJzZSkge1xuXHRcdFx0c3RhcnQgPSBtZS5lbmQ7XG5cdFx0XHRlbmQgPSBtZS5zdGFydDtcblx0XHRcdHNpZ24gPSAtMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RhcnQgPSBtZS5zdGFydDtcblx0XHRcdGVuZCA9IG1lLmVuZDtcblx0XHRcdHNpZ24gPSAxO1xuXHRcdH1cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUud2lkdGg7XG5cdFx0XHRwaXhlbCA9IHJldmVyc2UgPyBtZS5yaWdodCA6IG1lLmxlZnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUuaGVpZ2h0O1xuXHRcdFx0c2lnbiAqPSAtMTsgLy8gaW52ZXJ0LCBzaW5jZSB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhcyBpcyBhdCBwaXhlbCAoMCwgMClcblx0XHRcdHBpeGVsID0gcmV2ZXJzZSA/IG1lLnRvcCA6IG1lLmJvdHRvbTtcblx0XHR9XG5cdFx0aWYgKHZhbHVlICE9PSBzdGFydCkge1xuXHRcdFx0aWYgKHN0YXJ0ID09PSAwKSB7IC8vIGluY2x1ZGUgemVybyB0aWNrXG5cdFx0XHRcdG9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JGEodGlja09wdHMuZm9udFNpemUsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSk7XG5cdFx0XHRcdGlubmVyRGltZW5zaW9uIC09IG9mZnNldDtcblx0XHRcdFx0c3RhcnQgPSBmaXJzdFRpY2tWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gMCkge1xuXHRcdFx0XHRvZmZzZXQgKz0gaW5uZXJEaW1lbnNpb24gLyAobG9nMTAoZW5kKSAtIGxvZzEwKHN0YXJ0KSkgKiAobG9nMTAodmFsdWUpIC0gbG9nMTAoc3RhcnQpKTtcblx0XHRcdH1cblx0XHRcdHBpeGVsICs9IHNpZ24gKiBvZmZzZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBwaXhlbDtcblx0fSxcblxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgcmV2ZXJzZSA9IHRpY2tPcHRzLnJldmVyc2U7XG5cdFx0dmFyIGxvZzEwID0gaGVscGVycyQxLmxvZzEwO1xuXHRcdHZhciBmaXJzdFRpY2tWYWx1ZSA9IG1lLl9nZXRGaXJzdFRpY2tWYWx1ZShtZS5taW5Ob3RaZXJvKTtcblx0XHR2YXIgaW5uZXJEaW1lbnNpb24sIHN0YXJ0LCBlbmQsIHZhbHVlO1xuXG5cdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdHN0YXJ0ID0gbWUuZW5kO1xuXHRcdFx0ZW5kID0gbWUuc3RhcnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXJ0ID0gbWUuc3RhcnQ7XG5cdFx0XHRlbmQgPSBtZS5lbmQ7XG5cdFx0fVxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0aW5uZXJEaW1lbnNpb24gPSBtZS53aWR0aDtcblx0XHRcdHZhbHVlID0gcmV2ZXJzZSA/IG1lLnJpZ2h0IC0gcGl4ZWwgOiBwaXhlbCAtIG1lLmxlZnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUuaGVpZ2h0O1xuXHRcdFx0dmFsdWUgPSByZXZlcnNlID8gcGl4ZWwgLSBtZS50b3AgOiBtZS5ib3R0b20gLSBwaXhlbDtcblx0XHR9XG5cdFx0aWYgKHZhbHVlICE9PSBzdGFydCkge1xuXHRcdFx0aWYgKHN0YXJ0ID09PSAwKSB7IC8vIGluY2x1ZGUgemVybyB0aWNrXG5cdFx0XHRcdHZhciBvZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCRhKHRpY2tPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdFx0XHR2YWx1ZSAtPSBvZmZzZXQ7XG5cdFx0XHRcdGlubmVyRGltZW5zaW9uIC09IG9mZnNldDtcblx0XHRcdFx0c3RhcnQgPSBmaXJzdFRpY2tWYWx1ZTtcblx0XHRcdH1cblx0XHRcdHZhbHVlICo9IGxvZzEwKGVuZCkgLSBsb2cxMChzdGFydCk7XG5cdFx0XHR2YWx1ZSAvPSBpbm5lckRpbWVuc2lvbjtcblx0XHRcdHZhbHVlID0gTWF0aC5wb3coMTAsIGxvZzEwKHN0YXJ0KSArIHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDIgPSBkZWZhdWx0Q29uZmlnJDI7XG5zY2FsZV9sb2dhcml0aG1pYy5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkMjtcblxudmFyIHZhbHVlT3JEZWZhdWx0JGIgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEgPSBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xudmFyIHJlc29sdmUkNyA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbnZhciBkZWZhdWx0Q29uZmlnJDMgPSB7XG5cdGRpc3BsYXk6IHRydWUsXG5cblx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSBzY2FsaW5nIHRoZSBjaGFydCBmcm9tIHRoZSBjZW50cmVcblx0YW5pbWF0ZTogdHJ1ZSxcblx0cG9zaXRpb246ICdjaGFydEFyZWEnLFxuXG5cdGFuZ2xlTGluZXM6IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcblx0XHRsaW5lV2lkdGg6IDEsXG5cdFx0Ym9yZGVyRGFzaDogW10sXG5cdFx0Ym9yZGVyRGFzaE9mZnNldDogMC4wXG5cdH0sXG5cblx0Z3JpZExpbmVzOiB7XG5cdFx0Y2lyY3VsYXI6IGZhbHNlXG5cdH0sXG5cblx0Ly8gbGFiZWwgc2V0dGluZ3Ncblx0dGlja3M6IHtcblx0XHQvLyBCb29sZWFuIC0gU2hvdyBhIGJhY2tkcm9wIHRvIHRoZSBzY2FsZSBsYWJlbFxuXHRcdHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuXG5cdFx0Ly8gU3RyaW5nIC0gVGhlIGNvbG91ciBvZiB0aGUgbGFiZWwgYmFja2Ryb3Bcblx0XHRiYWNrZHJvcENvbG9yOiAncmdiYSgyNTUsMjU1LDI1NSwwLjc1KScsXG5cblx0XHQvLyBOdW1iZXIgLSBUaGUgYmFja2Ryb3AgcGFkZGluZyBhYm92ZSAmIGJlbG93IHRoZSBsYWJlbCBpbiBwaXhlbHNcblx0XHRiYWNrZHJvcFBhZGRpbmdZOiAyLFxuXG5cdFx0Ly8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgdG8gdGhlIHNpZGUgb2YgdGhlIGxhYmVsIGluIHBpeGVsc1xuXHRcdGJhY2tkcm9wUGFkZGluZ1g6IDIsXG5cblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxuXHR9LFxuXG5cdHBvaW50TGFiZWxzOiB7XG5cdFx0Ly8gQm9vbGVhbiAtIGlmIHRydWUsIHNob3cgcG9pbnQgbGFiZWxzXG5cdFx0ZGlzcGxheTogdHJ1ZSxcblxuXHRcdC8vIE51bWJlciAtIFBvaW50IGxhYmVsIGZvbnQgc2l6ZSBpbiBwaXhlbHNcblx0XHRmb250U2l6ZTogMTAsXG5cblx0XHQvLyBGdW5jdGlvbiAtIFVzZWQgdG8gY29udmVydCBwb2ludCBsYWJlbHNcblx0XHRjYWxsYmFjazogZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdHJldHVybiBsYWJlbDtcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGdldFZhbHVlQ291bnQoc2NhbGUpIHtcblx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuXHRyZXR1cm4gb3B0cy5hbmdsZUxpbmVzLmRpc3BsYXkgfHwgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5ID8gc2NhbGUuY2hhcnQuZGF0YS5sYWJlbHMubGVuZ3RoIDogMDtcbn1cblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcblx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcblx0XHRyZXR1cm4gdmFsdWVPckRlZmF1bHQkYih0aWNrT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKSArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kgKiAyO1xuXHR9XG5cdHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgbGluZUhlaWdodCwgbGFiZWwpIHtcblx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGxhYmVsKSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR3OiBoZWxwZXJzJDEubG9uZ2VzdFRleHQoY3R4LCBjdHguZm9udCwgbGFiZWwpLFxuXHRcdFx0aDogbGFiZWwubGVuZ3RoICogbGluZUhlaWdodFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHc6IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGgsXG5cdFx0aDogbGluZUhlaWdodFxuXHR9O1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvcywgc2l6ZSwgbWluLCBtYXgpIHtcblx0aWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzdGFydDogcG9zIC0gKHNpemUgLyAyKSxcblx0XHRcdGVuZDogcG9zICsgKHNpemUgLyAyKVxuXHRcdH07XG5cdH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IHBvcyAtIHNpemUsXG5cdFx0XHRlbmQ6IHBvc1xuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHN0YXJ0OiBwb3MsXG5cdFx0ZW5kOiBwb3MgKyBzaXplXG5cdH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpdCBhIHJhZGlhbCBsaW5lYXIgc2NhbGUgd2l0aCBwb2ludCBsYWJlbHNcbiAqL1xuZnVuY3Rpb24gZml0V2l0aFBvaW50TGFiZWxzKHNjYWxlKSB7XG5cblx0Ly8gUmlnaHQsIHRoaXMgaXMgcmVhbGx5IGNvbmZ1c2luZyBhbmQgdGhlcmUgaXMgYSBsb3Qgb2YgbWF0aHMgZ29pbmcgb24gaGVyZVxuXHQvLyBUaGUgZ2lzdCBvZiB0aGUgcHJvYmxlbSBpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ubm5pY2svNjk2Y2M5YzU1ZjRiMGJlYjhmZTlcblx0Ly9cblx0Ly8gUmVhY3Rpb246IGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3Rvb211Y2hzY2llbmNlLmdpZlxuXHQvL1xuXHQvLyBTb2x1dGlvbjpcblx0Ly9cblx0Ly8gV2UgYXNzdW1lIHRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24gaXMgaGFsZiB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIGF0IGZpcnN0XG5cdC8vIGF0IGVhY2ggaW5kZXggd2UgY2hlY2sgaWYgdGhlIHRleHQgb3ZlcmxhcHMuXG5cdC8vXG5cdC8vIFdoZXJlIGl0IGRvZXMsIHdlIHN0b3JlIHRoYXQgYW5nbGUgYW5kIHRoYXQgaW5kZXguXG5cdC8vXG5cdC8vIEFmdGVyIGZpbmRpbmcgdGhlIGxhcmdlc3QgaW5kZXggYW5kIGFuZ2xlIHdlIGNhbGN1bGF0ZSBob3cgbXVjaCB3ZSBuZWVkIHRvIHJlbW92ZVxuXHQvLyBmcm9tIHRoZSBzaGFwZSByYWRpdXMgdG8gbW92ZSB0aGUgcG9pbnQgaW53YXJkcyBieSB0aGF0IHguXG5cdC8vXG5cdC8vIFdlIGF2ZXJhZ2UgdGhlIGxlZnQgYW5kIHJpZ2h0IGRpc3RhbmNlcyB0byBnZXQgdGhlIG1heGltdW0gc2hhcGUgcmFkaXVzIHRoYXQgY2FuIGZpdCBpbiB0aGUgYm94XG5cdC8vIGFsb25nIHdpdGggbGFiZWxzLlxuXHQvL1xuXHQvLyBPbmNlIHdlIGhhdmUgdGhhdCwgd2UgY2FuIGZpbmQgdGhlIGNlbnRyZSBwb2ludCBmb3IgdGhlIGNoYXJ0LCBieSB0YWtpbmcgdGhlIHggdGV4dCBwcm90cnVzaW9uXG5cdC8vIG9uIGVhY2ggc2lkZSwgcmVtb3ZpbmcgdGhhdCBmcm9tIHRoZSBzaXplLCBoYWx2aW5nIGl0IGFuZCBhZGRpbmcgdGhlIGxlZnQgeCBwcm90cnVzaW9uIHdpZHRoLlxuXHQvL1xuXHQvLyBUaGlzIHdpbGwgbWVhbiB3ZSBoYXZlIGEgc2hhcGUgZml0dGVkIHRvIHRoZSBjYW52YXMsIGFzIGxhcmdlIGFzIGl0IGNhbiBiZSB3aXRoIHRoZSBsYWJlbHNcblx0Ly8gYW5kIHBvc2l0aW9uIGl0IGluIHRoZSBtb3N0IHNwYWNlIGVmZmljaWVudCBtYW5uZXJcblx0Ly9cblx0Ly8gaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMveWVhaHNjaWVuY2UuZ2lmXG5cblx0dmFyIHBsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQoc2NhbGUub3B0aW9ucy5wb2ludExhYmVscyk7XG5cblx0Ly8gR2V0IG1heGltdW0gcmFkaXVzIG9mIHRoZSBwb2x5Z29uLiBFaXRoZXIgaGFsZiB0aGUgaGVpZ2h0IChtaW51cyB0aGUgdGV4dCB3aWR0aCkgb3IgaGFsZiB0aGUgd2lkdGguXG5cdC8vIFVzZSB0aGlzIHRvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0ICsgY2hhbmdlLiAtIE1ha2Ugc3VyZSBML1IgcHJvdHJ1c2lvbiBpcyBhdCBsZWFzdCAwIHRvIHN0b3AgaXNzdWVzIHdpdGggY2VudHJlIHBvaW50c1xuXHR2YXIgZnVydGhlc3RMaW1pdHMgPSB7XG5cdFx0bDogMCxcblx0XHRyOiBzY2FsZS53aWR0aCxcblx0XHR0OiAwLFxuXHRcdGI6IHNjYWxlLmhlaWdodCAtIHNjYWxlLnBhZGRpbmdUb3Bcblx0fTtcblx0dmFyIGZ1cnRoZXN0QW5nbGVzID0ge307XG5cdHZhciBpLCB0ZXh0U2l6ZSwgcG9pbnRQb3NpdGlvbjtcblxuXHRzY2FsZS5jdHguZm9udCA9IHBsRm9udC5zdHJpbmc7XG5cdHNjYWxlLl9wb2ludExhYmVsU2l6ZXMgPSBbXTtcblxuXHR2YXIgdmFsdWVDb3VudCA9IGdldFZhbHVlQ291bnQoc2NhbGUpO1xuXHRmb3IgKGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG5cdFx0cG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyA1KTtcblx0XHR0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoc2NhbGUuY3R4LCBwbEZvbnQubGluZUhlaWdodCwgc2NhbGUucG9pbnRMYWJlbHNbaV0gfHwgJycpO1xuXHRcdHNjYWxlLl9wb2ludExhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcblxuXHRcdC8vIEFkZCBxdWFydGVyIGNpcmNsZSB0byBtYWtlIGRlZ3JlZSAwIG1lYW4gdG9wIG9mIGNpcmNsZVxuXHRcdHZhciBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xuXHRcdHZhciBhbmdsZSA9IGhlbHBlcnMkMS50b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSAlIDM2MDtcblx0XHR2YXIgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuXHRcdHZhciB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuXG5cdFx0aWYgKGhMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy5sKSB7XG5cdFx0XHRmdXJ0aGVzdExpbWl0cy5sID0gaExpbWl0cy5zdGFydDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLmwgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKGhMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMucikge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMuciA9IGhMaW1pdHMuZW5kO1xuXHRcdFx0ZnVydGhlc3RBbmdsZXMuciA9IGFuZ2xlUmFkaWFucztcblx0XHR9XG5cblx0XHRpZiAodkxpbWl0cy5zdGFydCA8IGZ1cnRoZXN0TGltaXRzLnQpIHtcblx0XHRcdGZ1cnRoZXN0TGltaXRzLnQgPSB2TGltaXRzLnN0YXJ0O1xuXHRcdFx0ZnVydGhlc3RBbmdsZXMudCA9IGFuZ2xlUmFkaWFucztcblx0XHR9XG5cblx0XHRpZiAodkxpbWl0cy5lbmQgPiBmdXJ0aGVzdExpbWl0cy5iKSB7XG5cdFx0XHRmdXJ0aGVzdExpbWl0cy5iID0gdkxpbWl0cy5lbmQ7XG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy5iID0gYW5nbGVSYWRpYW5zO1xuXHRcdH1cblx0fVxuXG5cdHNjYWxlLnNldFJlZHVjdGlvbnMoc2NhbGUuZHJhd2luZ0FyZWEsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcyk7XG59XG5cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG5cdGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG5cdFx0cmV0dXJuICdjZW50ZXInO1xuXHR9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG5cdFx0cmV0dXJuICdsZWZ0Jztcblx0fVxuXG5cdHJldHVybiAncmlnaHQnO1xufVxuXG5mdW5jdGlvbiBmaWxsVGV4dChjdHgsIHRleHQsIHBvc2l0aW9uLCBsaW5lSGVpZ2h0KSB7XG5cdHZhciB5ID0gcG9zaXRpb24ueSArIGxpbmVIZWlnaHQgLyAyO1xuXHR2YXIgaSwgaWxlbjtcblxuXHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGV4dCkpIHtcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0W2ldLCBwb3NpdGlvbi54LCB5KTtcblx0XHRcdHkgKz0gbGluZUhlaWdodDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Y3R4LmZpbGxUZXh0KHRleHQsIHBvc2l0aW9uLngsIHkpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodChhbmdsZSwgdGV4dFNpemUsIHBvc2l0aW9uKSB7XG5cdGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuXHRcdHBvc2l0aW9uLnkgLT0gKHRleHRTaXplLmggLyAyKTtcblx0fSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG5cdFx0cG9zaXRpb24ueSAtPSB0ZXh0U2l6ZS5oO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSkge1xuXHR2YXIgY3R4ID0gc2NhbGUuY3R4O1xuXHR2YXIgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG5cdHZhciBhbmdsZUxpbmVPcHRzID0gb3B0cy5hbmdsZUxpbmVzO1xuXHR2YXIgZ3JpZExpbmVPcHRzID0gb3B0cy5ncmlkTGluZXM7XG5cdHZhciBwb2ludExhYmVsT3B0cyA9IG9wdHMucG9pbnRMYWJlbHM7XG5cdHZhciBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCRiKGFuZ2xlTGluZU9wdHMubGluZVdpZHRoLCBncmlkTGluZU9wdHMubGluZVdpZHRoKTtcblx0dmFyIGxpbmVDb2xvciA9IHZhbHVlT3JEZWZhdWx0JGIoYW5nbGVMaW5lT3B0cy5jb2xvciwgZ3JpZExpbmVPcHRzLmNvbG9yKTtcblx0dmFyIHRpY2tCYWNrZHJvcEhlaWdodCA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKTtcblxuXHRjdHguc2F2ZSgpO1xuXHRjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXHRjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XG5cdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRjdHguc2V0TGluZURhc2gocmVzb2x2ZSQ3KFthbmdsZUxpbmVPcHRzLmJvcmRlckRhc2gsIGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoLCBbXV0pKTtcblx0XHRjdHgubGluZURhc2hPZmZzZXQgPSByZXNvbHZlJDcoW2FuZ2xlTGluZU9wdHMuYm9yZGVyRGFzaE9mZnNldCwgZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQsIDAuMF0pO1xuXHR9XG5cblx0dmFyIG91dGVyRGlzdGFuY2UgPSBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXgpO1xuXG5cdC8vIFBvaW50IExhYmVsIEZvbnRcblx0dmFyIHBsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQocG9pbnRMYWJlbE9wdHMpO1xuXG5cdGN0eC5mb250ID0gcGxGb250LnN0cmluZztcblx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG5cdGZvciAodmFyIGkgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0aWYgKGFuZ2xlTGluZU9wdHMuZGlzcGxheSAmJiBsaW5lV2lkdGggJiYgbGluZUNvbG9yKSB7XG5cdFx0XHR2YXIgb3V0ZXJQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgb3V0ZXJEaXN0YW5jZSk7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIpO1xuXHRcdFx0Y3R4LmxpbmVUbyhvdXRlclBvc2l0aW9uLngsIG91dGVyUG9zaXRpb24ueSk7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKHBvaW50TGFiZWxPcHRzLmRpc3BsYXkpIHtcblx0XHRcdC8vIEV4dHJhIHBpeGVscyBvdXQgZm9yIHNvbWUgbGFiZWwgc3BhY2luZ1xuXHRcdFx0dmFyIGV4dHJhID0gKGkgPT09IDAgPyB0aWNrQmFja2Ryb3BIZWlnaHQgLyAyIDogMCk7XG5cdFx0XHR2YXIgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyA1KTtcblxuXHRcdFx0Ly8gS2VlcCB0aGlzIGluIGxvb3Agc2luY2Ugd2UgbWF5IHN1cHBvcnQgYXJyYXkgcHJvcGVydGllcyBoZXJlXG5cdFx0XHR2YXIgcG9pbnRMYWJlbEZvbnRDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKHBvaW50TGFiZWxPcHRzLmZvbnRDb2xvciwgaSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gcG9pbnRMYWJlbEZvbnRDb2xvcjtcblxuXHRcdFx0dmFyIGFuZ2xlUmFkaWFucyA9IHNjYWxlLmdldEluZGV4QW5nbGUoaSk7XG5cdFx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzJDEudG9EZWdyZWVzKGFuZ2xlUmFkaWFucyk7XG5cdFx0XHRjdHgudGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuXHRcdFx0YWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0KGFuZ2xlLCBzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldLCBwb2ludExhYmVsUG9zaXRpb24pO1xuXHRcdFx0ZmlsbFRleHQoY3R4LCBzY2FsZS5wb2ludExhYmVsc1tpXSB8fCAnJywgcG9pbnRMYWJlbFBvc2l0aW9uLCBwbEZvbnQubGluZUhlaWdodCk7XG5cdFx0fVxuXHR9XG5cdGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgaW5kZXgpIHtcblx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcblx0dmFyIGNpcmN1bGFyID0gZ3JpZExpbmVPcHRzLmNpcmN1bGFyO1xuXHR2YXIgdmFsdWVDb3VudCA9IGdldFZhbHVlQ291bnQoc2NhbGUpO1xuXHR2YXIgbGluZUNvbG9yID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEoZ3JpZExpbmVPcHRzLmNvbG9yLCBpbmRleCAtIDEpO1xuXHR2YXIgbGluZVdpZHRoID0gdmFsdWVBdEluZGV4T3JEZWZhdWx0JDEoZ3JpZExpbmVPcHRzLmxpbmVXaWR0aCwgaW5kZXggLSAxKTtcblx0dmFyIHBvaW50UG9zaXRpb247XG5cblx0aWYgKCghY2lyY3VsYXIgJiYgIXZhbHVlQ291bnQpIHx8ICFsaW5lQ29sb3IgfHwgIWxpbmVXaWR0aCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGN0eC5zYXZlKCk7XG5cdGN0eC5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcblx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdGN0eC5zZXRMaW5lRGFzaChncmlkTGluZU9wdHMuYm9yZGVyRGFzaCB8fCBbXSk7XG5cdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xuXHR9XG5cblx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRpZiAoY2lyY3VsYXIpIHtcblx0XHQvLyBEcmF3IGNpcmN1bGFyIGFyY3MgYmV0d2VlbiB0aGUgcG9pbnRzXG5cdFx0Y3R4LmFyYyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcblx0fSBlbHNlIHtcblx0XHQvLyBEcmF3IHN0cmFpZ2h0IGxpbmVzIGNvbm5lY3RpbmcgZWFjaCBpbmRleFxuXHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XG5cdFx0Y3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG5cblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHRcdFx0cG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcblx0XHRcdGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXHRcdH1cblx0fVxuXHRjdHguY2xvc2VQYXRoKCk7XG5cdGN0eC5zdHJva2UoKTtcblx0Y3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyT3JaZXJvKHBhcmFtKSB7XG5cdHJldHVybiBoZWxwZXJzJDEuaXNOdW1iZXIocGFyYW0pID8gcGFyYW0gOiAwO1xufVxuXG52YXIgc2NhbGVfcmFkaWFsTGluZWFyID0gc2NhbGVfbGluZWFyYmFzZS5leHRlbmQoe1xuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblx0XHRtZS5wYWRkaW5nVG9wID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG1lLm9wdGlvbnMpIC8gMjtcblx0XHRtZS54Q2VudGVyID0gTWF0aC5mbG9vcihtZS53aWR0aCAvIDIpO1xuXHRcdG1lLnlDZW50ZXIgPSBNYXRoLmZsb29yKChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSAvIDIpO1xuXHRcdG1lLmRyYXdpbmdBcmVhID0gTWF0aC5taW4obWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCwgbWUud2lkdGgpIC8gMjtcblx0fSxcblxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdFx0dmFyIG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKGNoYXJ0LmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSkge1xuXHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cblx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1pbiA9IE1hdGgubWluKHZhbHVlLCBtaW4pO1xuXHRcdFx0XHRcdG1heCA9IE1hdGgubWF4KHZhbHVlLCBtYXgpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdG1lLm1pbiA9IChtaW4gPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA/IDAgOiBtaW4pO1xuXHRcdG1lLm1heCA9IChtYXggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA/IDAgOiBtYXgpO1xuXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4LCB0aWNrcy5iZWdpbkF0WmVyb1xuXHRcdG1lLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcblx0fSxcblxuXHQvLyBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdF9jb21wdXRlVGlja0xpbWl0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG5cdH0sXG5cblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRzY2FsZV9saW5lYXJiYXNlLnByb3RvdHlwZS5jb252ZXJ0VGlja3NUb0xhYmVscy5jYWxsKG1lKTtcblxuXHRcdC8vIFBvaW50IGxhYmVsc1xuXHRcdG1lLnBvaW50TGFiZWxzID0gbWUuY2hhcnQuZGF0YS5sYWJlbHMubWFwKG1lLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIG1lKTtcblx0fSxcblxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0cmV0dXJuICt0aGlzLmdldFJpZ2h0VmFsdWUodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0pO1xuXHR9LFxuXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuXHRcdFx0Zml0V2l0aFBvaW50TGFiZWxzKG1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuc2V0Q2VudGVyUG9pbnQoMCwgMCwgMCwgMCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgcmFkaXVzIHJlZHVjdGlvbnMgYW5kIGRldGVybWluZSBuZXcgcmFkaXVzIGFuZCBjZW50ZXIgcG9pbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHNldFJlZHVjdGlvbnM6IGZ1bmN0aW9uKGxhcmdlc3RQb3NzaWJsZVJhZGl1cywgZnVydGhlc3RMaW1pdHMsIGZ1cnRoZXN0QW5nbGVzKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uTGVmdCA9IGZ1cnRoZXN0TGltaXRzLmwgLyBNYXRoLnNpbihmdXJ0aGVzdEFuZ2xlcy5sKTtcblx0XHR2YXIgcmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBNYXRoLm1heChmdXJ0aGVzdExpbWl0cy5yIC0gbWUud2lkdGgsIDApIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMucik7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvblRvcCA9IC1mdXJ0aGVzdExpbWl0cy50IC8gTWF0aC5jb3MoZnVydGhlc3RBbmdsZXMudCk7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IC1NYXRoLm1heChmdXJ0aGVzdExpbWl0cy5iIC0gKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3ApLCAwKSAvIE1hdGguY29zKGZ1cnRoZXN0QW5nbGVzLmIpO1xuXG5cdFx0cmFkaXVzUmVkdWN0aW9uTGVmdCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25MZWZ0KTtcblx0XHRyYWRpdXNSZWR1Y3Rpb25SaWdodCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25SaWdodCk7XG5cdFx0cmFkaXVzUmVkdWN0aW9uVG9wID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvblRvcCk7XG5cdFx0cmFkaXVzUmVkdWN0aW9uQm90dG9tID0gbnVtYmVyT3JaZXJvKHJhZGl1c1JlZHVjdGlvbkJvdHRvbSk7XG5cblx0XHRtZS5kcmF3aW5nQXJlYSA9IE1hdGgubWluKFxuXHRcdFx0TWF0aC5mbG9vcihsYXJnZXN0UG9zc2libGVSYWRpdXMgLSAocmFkaXVzUmVkdWN0aW9uTGVmdCArIHJhZGl1c1JlZHVjdGlvblJpZ2h0KSAvIDIpLFxuXHRcdFx0TWF0aC5mbG9vcihsYXJnZXN0UG9zc2libGVSYWRpdXMgLSAocmFkaXVzUmVkdWN0aW9uVG9wICsgcmFkaXVzUmVkdWN0aW9uQm90dG9tKSAvIDIpKTtcblx0XHRtZS5zZXRDZW50ZXJQb2ludChyYWRpdXNSZWR1Y3Rpb25MZWZ0LCByYWRpdXNSZWR1Y3Rpb25SaWdodCwgcmFkaXVzUmVkdWN0aW9uVG9wLCByYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xuXHR9LFxuXG5cdHNldENlbnRlclBvaW50OiBmdW5jdGlvbihsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1heFJpZ2h0ID0gbWUud2lkdGggLSByaWdodE1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heExlZnQgPSBsZWZ0TW92ZW1lbnQgKyBtZS5kcmF3aW5nQXJlYTtcblx0XHR2YXIgbWF4VG9wID0gdG9wTW92ZW1lbnQgKyBtZS5kcmF3aW5nQXJlYTtcblx0XHR2YXIgbWF4Qm90dG9tID0gKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3ApIC0gYm90dG9tTW92ZW1lbnQgLSBtZS5kcmF3aW5nQXJlYTtcblxuXHRcdG1lLnhDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4TGVmdCArIG1heFJpZ2h0KSAvIDIpICsgbWUubGVmdCk7XG5cdFx0bWUueUNlbnRlciA9IE1hdGguZmxvb3IoKChtYXhUb3AgKyBtYXhCb3R0b20pIC8gMikgKyBtZS50b3AgKyBtZS5wYWRkaW5nVG9wKTtcblx0fSxcblxuXHRnZXRJbmRleEFuZ2xlOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBhbmdsZU11bHRpcGxpZXIgPSAoTWF0aC5QSSAqIDIpIC8gZ2V0VmFsdWVDb3VudCh0aGlzKTtcblx0XHR2YXIgc3RhcnRBbmdsZSA9IHRoaXMuY2hhcnQub3B0aW9ucyAmJiB0aGlzLmNoYXJ0Lm9wdGlvbnMuc3RhcnRBbmdsZSA/XG5cdFx0XHR0aGlzLmNoYXJ0Lm9wdGlvbnMuc3RhcnRBbmdsZSA6XG5cdFx0XHQwO1xuXG5cdFx0dmFyIHN0YXJ0QW5nbGVSYWRpYW5zID0gc3RhcnRBbmdsZSAqIE1hdGguUEkgKiAyIC8gMzYwO1xuXG5cdFx0Ly8gU3RhcnQgZnJvbSB0aGUgdG9wIGluc3RlYWQgb2YgcmlnaHQsIHNvIHJlbW92ZSBhIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXHRcdHJldHVybiBpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHN0YXJ0QW5nbGVSYWRpYW5zO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiAwOyAvLyBudWxsIGFsd2F5cyBpbiBjZW50ZXJcblx0XHR9XG5cblx0XHQvLyBUYWtlIGludG8gYWNjb3VudCBoYWxmIGZvbnQgc2l6ZSArIHRoZSB5UGFkZGluZyBvZiB0aGUgdG9wIHZhbHVlXG5cdFx0dmFyIHNjYWxpbmdGYWN0b3IgPSBtZS5kcmF3aW5nQXJlYSAvIChtZS5tYXggLSBtZS5taW4pO1xuXHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLnJldmVyc2UpIHtcblx0XHRcdHJldHVybiAobWUubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3Rvcjtcblx0XHR9XG5cdFx0cmV0dXJuICh2YWx1ZSAtIG1lLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuXHR9LFxuXG5cdGdldFBvaW50UG9zaXRpb246IGZ1bmN0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aGlzQW5nbGUgPSBtZS5nZXRJbmRleEFuZ2xlKGluZGV4KSAtIChNYXRoLlBJIC8gMik7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IE1hdGguY29zKHRoaXNBbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyBtZS54Q2VudGVyLFxuXHRcdFx0eTogTWF0aC5zaW4odGhpc0FuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIG1lLnlDZW50ZXJcblx0XHR9O1xuXHR9LFxuXG5cdGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZTogZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuXHR9LFxuXG5cdGdldEJhc2VQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWluID0gbWUubWluO1xuXHRcdHZhciBtYXggPSBtZS5tYXg7XG5cblx0XHRyZXR1cm4gbWUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKDAsXG5cdFx0XHRtZS5iZWdpbkF0WmVybyA/IDAgOlxuXHRcdFx0bWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcblx0XHRcdG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG5cdFx0XHQwKTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgZ3JpZExpbmVPcHRzID0gb3B0cy5ncmlkTGluZXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdGlmIChvcHRzLmRpc3BsYXkpIHtcblx0XHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0XHR2YXIgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcblx0XHRcdHZhciB0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQodGlja09wdHMpO1xuXG5cdFx0XHRpZiAob3B0cy5hbmdsZUxpbmVzLmRpc3BsYXkgfHwgb3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG5cdFx0XHRcdGRyYXdQb2ludExhYmVscyhtZSk7XG5cdFx0XHR9XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLnRpY2tzLCBmdW5jdGlvbihsYWJlbCwgaW5kZXgpIHtcblx0XHRcdFx0Ly8gRG9uJ3QgZHJhdyBhIGNlbnRyZSB2YWx1ZSAoaWYgaXQgaXMgbWluaW11bSlcblx0XHRcdFx0aWYgKGluZGV4ID4gMCB8fCB0aWNrT3B0cy5yZXZlcnNlKSB7XG5cdFx0XHRcdFx0dmFyIHlDZW50ZXJPZmZzZXQgPSBtZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShtZS50aWNrc0FzTnVtYmVyc1tpbmRleF0pO1xuXG5cdFx0XHRcdFx0Ly8gRHJhdyBjaXJjdWxhciBsaW5lcyBhcm91bmQgdGhlIHNjYWxlXG5cdFx0XHRcdFx0aWYgKGdyaWRMaW5lT3B0cy5kaXNwbGF5ICYmIGluZGV4ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRkcmF3UmFkaXVzTGluZShtZSwgZ3JpZExpbmVPcHRzLCB5Q2VudGVyT2Zmc2V0LCBpbmRleCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHRpY2tPcHRzLmRpc3BsYXkpIHtcblx0XHRcdFx0XHRcdHZhciB0aWNrRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkYih0aWNrT3B0cy5mb250Q29sb3IsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0XHRcdFx0Y3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG5cblx0XHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKG1lLnhDZW50ZXIsIG1lLnlDZW50ZXIpO1xuXHRcdFx0XHRcdFx0Y3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcblxuXHRcdFx0XHRcdFx0aWYgKHRpY2tPcHRzLnNob3dMYWJlbEJhY2tkcm9wKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBsYWJlbFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tPcHRzLmJhY2tkcm9wQ29sb3I7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsUmVjdChcblx0XHRcdFx0XHRcdFx0XHQtbGFiZWxXaWR0aCAvIDIgLSB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdYLFxuXHRcdFx0XHRcdFx0XHRcdC15Q2VudGVyT2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZLFxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsV2lkdGggKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdYICogMixcblx0XHRcdFx0XHRcdFx0XHR0aWNrRm9udC5zaXplICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSAqIDJcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRpY2tGb250Q29sb3I7XG5cdFx0XHRcdFx0XHRjdHguZmlsbFRleHQobGFiZWwsIDAsIC15Q2VudGVyT2Zmc2V0KTtcblx0XHRcdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMkMyA9IGRlZmF1bHRDb25maWckMztcbnNjYWxlX3JhZGlhbExpbmVhci5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkMztcblxudmFyIHZhbHVlT3JEZWZhdWx0JGMgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbi8vIEludGVnZXIgY29uc3RhbnRzIGFyZSBmcm9tIHRoZSBFUzYgc3BlYy5cbnZhciBNSU5fSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxO1xudmFyIE1BWF9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcblxudmFyIElOVEVSVkFMUyA9IHtcblx0bWlsbGlzZWNvbmQ6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMSxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAyMCwgNTAsIDEwMCwgMjUwLCA1MDBdXG5cdH0sXG5cdHNlY29uZDoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAxMDAwLFxuXHRcdHN0ZXBzOiBbMSwgMiwgNSwgMTAsIDE1LCAzMF1cblx0fSxcblx0bWludXRlOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDYwMDAwLFxuXHRcdHN0ZXBzOiBbMSwgMiwgNSwgMTAsIDE1LCAzMF1cblx0fSxcblx0aG91cjoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAzNjAwMDAwLFxuXHRcdHN0ZXBzOiBbMSwgMiwgMywgNiwgMTJdXG5cdH0sXG5cdGRheToge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiA4NjQwMDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDVdXG5cdH0sXG5cdHdlZWs6IHtcblx0XHRjb21tb246IGZhbHNlLFxuXHRcdHNpemU6IDYwNDgwMDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDMsIDRdXG5cdH0sXG5cdG1vbnRoOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDIuNjI4ZTksXG5cdFx0c3RlcHM6IFsxLCAyLCAzXVxuXHR9LFxuXHRxdWFydGVyOiB7XG5cdFx0Y29tbW9uOiBmYWxzZSxcblx0XHRzaXplOiA3Ljg4NGU5LFxuXHRcdHN0ZXBzOiBbMSwgMiwgMywgNF1cblx0fSxcblx0eWVhcjoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAzLjE1NGUxMFxuXHR9XG59O1xuXG52YXIgVU5JVFMgPSBPYmplY3Qua2V5cyhJTlRFUlZBTFMpO1xuXG5mdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuXHRyZXR1cm4gYSAtIGI7XG59XG5cbmZ1bmN0aW9uIGFycmF5VW5pcXVlKGl0ZW1zKSB7XG5cdHZhciBoYXNoID0ge307XG5cdHZhciBvdXQgPSBbXTtcblx0dmFyIGksIGlsZW4sIGl0ZW07XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRpZiAoIWhhc2hbaXRlbV0pIHtcblx0XHRcdGhhc2hbaXRlbV0gPSB0cnVlO1xuXHRcdFx0b3V0LnB1c2goaXRlbSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHt0aW1lLCBwb3N9IG9iamVjdHMgdXNlZCB0byBpbnRlcnBvbGF0ZSBhIHNwZWNpZmljIGB0aW1lYCBvciBwb3NpdGlvblxuICogKGBwb3NgKSBvbiB0aGUgc2NhbGUsIGJ5IHNlYXJjaGluZyBlbnRyaWVzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHJlcXVlc3RlZCB2YWx1ZS4gYHBvc2AgaXNcbiAqIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDE6IDAgYmVpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzY2FsZSAobGVmdCBvciB0b3ApIGFuZCAxIHRoZSBvdGhlclxuICogZXh0cmVtaXR5IChsZWZ0ICsgd2lkdGggb3IgdG9wICsgaGVpZ2h0KS4gTm90ZSB0aGF0IGl0IHdvdWxkIGJlIG1vcmUgb3B0aW1pemVkIHRvIGRpcmVjdGx5XG4gKiBzdG9yZSBwcmUtY29tcHV0ZWQgcGl4ZWxzLCBidXQgdGhlIHNjYWxlIGRpbWVuc2lvbnMgYXJlIG5vdCBndWFyYW50ZWVkIGF0IHRoZSB0aW1lIHdlIG5lZWRcbiAqIHRvIGNyZWF0ZSB0aGUgbG9va3VwIHRhYmxlLiBUaGUgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IHR3byBpdGVtczogbWluIGFuZCBtYXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gdGltZXN0YW1wcyAtIHRpbWVzdGFtcHMgc29ydGVkIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzdHJpYnV0aW9uIC0gSWYgJ2xpbmVhcicsIHRpbWVzdGFtcHMgd2lsbCBiZSBzcHJlYWQgbGluZWFybHkgYWxvbmcgdGhlIG1pblxuICogYW5kIG1heCByYW5nZSwgc28gYmFzaWNhbGx5LCB0aGUgdGFibGUgd2lsbCBjb250YWlucyBvbmx5IHR3byBpdGVtczoge21pbiwgMH0gYW5kIHttYXgsIDF9LlxuICogSWYgJ3NlcmllcycsIHRpbWVzdGFtcHMgd2lsbCBiZSBwb3NpdGlvbmVkIGF0IHRoZSBzYW1lIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci4gSW4gdGhpc1xuICogY2FzZSwgb25seSB0aW1lc3RhbXBzIHRoYXQgYnJlYWsgdGhlIHRpbWUgbGluZWFyaXR5IGFyZSByZWdpc3RlcmVkLCBtZWFuaW5nIHRoYXQgaW4gdGhlXG4gKiBiZXN0IGNhc2UsIGFsbCB0aW1lc3RhbXBzIGFyZSBsaW5lYXIsIHRoZSB0YWJsZSBjb250YWlucyBvbmx5IG1pbiBhbmQgbWF4LlxuICovXG5mdW5jdGlvbiBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMsIG1pbiwgbWF4LCBkaXN0cmlidXRpb24pIHtcblx0aWYgKGRpc3RyaWJ1dGlvbiA9PT0gJ2xpbmVhcicgfHwgIXRpbWVzdGFtcHMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHt0aW1lOiBtaW4sIHBvczogMH0sXG5cdFx0XHR7dGltZTogbWF4LCBwb3M6IDF9XG5cdFx0XTtcblx0fVxuXG5cdHZhciB0YWJsZSA9IFtdO1xuXHR2YXIgaXRlbXMgPSBbbWluXTtcblx0dmFyIGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0Y3VyciA9IHRpbWVzdGFtcHNbaV07XG5cdFx0aWYgKGN1cnIgPiBtaW4gJiYgY3VyciA8IG1heCkge1xuXHRcdFx0aXRlbXMucHVzaChjdXJyKTtcblx0XHR9XG5cdH1cblxuXHRpdGVtcy5wdXNoKG1heCk7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdG5leHQgPSBpdGVtc1tpICsgMV07XG5cdFx0cHJldiA9IGl0ZW1zW2kgLSAxXTtcblx0XHRjdXJyID0gaXRlbXNbaV07XG5cblx0XHQvLyBvbmx5IGFkZCBwb2ludHMgdGhhdCBicmVha3MgdGhlIHNjYWxlIGxpbmVhcml0eVxuXHRcdGlmIChwcmV2ID09PSB1bmRlZmluZWQgfHwgbmV4dCA9PT0gdW5kZWZpbmVkIHx8IE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG5cdFx0XHR0YWJsZS5wdXNoKHt0aW1lOiBjdXJyLCBwb3M6IGkgLyAoaWxlbiAtIDEpfSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRhYmxlO1xufVxuXG4vLyBAc2VlIGFkYXB0ZWQgZnJvbSBodHRwczovL3d3dy5hbnVqZ2FraGFyLmNvbS8yMDE0LzAzLzAxL2JpbmFyeS1zZWFyY2gtaW4tamF2YXNjcmlwdC9cbmZ1bmN0aW9uIGxvb2t1cCh0YWJsZSwga2V5LCB2YWx1ZSkge1xuXHR2YXIgbG8gPSAwO1xuXHR2YXIgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuXHR2YXIgbWlkLCBpMCwgaTE7XG5cblx0d2hpbGUgKGxvID49IDAgJiYgbG8gPD0gaGkpIHtcblx0XHRtaWQgPSAobG8gKyBoaSkgPj4gMTtcblx0XHRpMCA9IHRhYmxlW21pZCAtIDFdIHx8IG51bGw7XG5cdFx0aTEgPSB0YWJsZVttaWRdO1xuXG5cdFx0aWYgKCFpMCkge1xuXHRcdFx0Ly8gZ2l2ZW4gdmFsdWUgaXMgb3V0c2lkZSB0YWJsZSAoYmVmb3JlIGZpcnN0IGl0ZW0pXG5cdFx0XHRyZXR1cm4ge2xvOiBudWxsLCBoaTogaTF9O1xuXHRcdH0gZWxzZSBpZiAoaTFba2V5XSA8IHZhbHVlKSB7XG5cdFx0XHRsbyA9IG1pZCArIDE7XG5cdFx0fSBlbHNlIGlmIChpMFtrZXldID4gdmFsdWUpIHtcblx0XHRcdGhpID0gbWlkIC0gMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHtsbzogaTAsIGhpOiBpMX07XG5cdFx0fVxuXHR9XG5cblx0Ly8gZ2l2ZW4gdmFsdWUgaXMgb3V0c2lkZSB0YWJsZSAoYWZ0ZXIgbGFzdCBpdGVtKVxuXHRyZXR1cm4ge2xvOiBpMSwgaGk6IG51bGx9O1xufVxuXG4vKipcbiAqIExpbmVhcmx5IGludGVycG9sYXRlcyB0aGUgZ2l2ZW4gc291cmNlIGB2YWx1ZWAgdXNpbmcgdGhlIHRhYmxlIGl0ZW1zIGBza2V5YCB2YWx1ZXMgYW5kXG4gKiByZXR1cm5zIHRoZSBhc3NvY2lhdGVkIGB0a2V5YCB2YWx1ZS4gRm9yIGV4YW1wbGUsIGludGVycG9sYXRlKHRhYmxlLCAndGltZScsIDQyLCAncG9zJylcbiAqIHJldHVybnMgdGhlIHBvc2l0aW9uIGZvciBhIHRpbWVzdGFtcCBlcXVhbCB0byA0Mi4gSWYgdmFsdWUgaXMgb3V0IG9mIGJvdW5kcywgdmFsdWVzIGF0XG4gKiBpbmRleCBbMCwgMV0gb3IgW24gLSAxLCBuXSBhcmUgdXNlZCBmb3IgdGhlIGludGVycG9sYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlJDEodGFibGUsIHNrZXksIHN2YWwsIHRrZXkpIHtcblx0dmFyIHJhbmdlID0gbG9va3VwKHRhYmxlLCBza2V5LCBzdmFsKTtcblxuXHQvLyBOb3RlOiB0aGUgbG9va3VwIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCAyIGl0ZW1zIChtaW4gYW5kIG1heClcblx0dmFyIHByZXYgPSAhcmFuZ2UubG8gPyB0YWJsZVswXSA6ICFyYW5nZS5oaSA/IHRhYmxlW3RhYmxlLmxlbmd0aCAtIDJdIDogcmFuZ2UubG87XG5cdHZhciBuZXh0ID0gIXJhbmdlLmxvID8gdGFibGVbMV0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAxXSA6IHJhbmdlLmhpO1xuXG5cdHZhciBzcGFuID0gbmV4dFtza2V5XSAtIHByZXZbc2tleV07XG5cdHZhciByYXRpbyA9IHNwYW4gPyAoc3ZhbCAtIHByZXZbc2tleV0pIC8gc3BhbiA6IDA7XG5cdHZhciBvZmZzZXQgPSAobmV4dFt0a2V5XSAtIHByZXZbdGtleV0pICogcmF0aW87XG5cblx0cmV0dXJuIHByZXZbdGtleV0gKyBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIHRvVGltZXN0YW1wKHNjYWxlLCBpbnB1dCkge1xuXHR2YXIgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnMudGltZTtcblx0dmFyIHBhcnNlciA9IG9wdGlvbnMucGFyc2VyO1xuXHR2YXIgZm9ybWF0ID0gcGFyc2VyIHx8IG9wdGlvbnMuZm9ybWF0O1xuXHR2YXIgdmFsdWUgPSBpbnB1dDtcblxuXHRpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcblx0fVxuXG5cdC8vIE9ubHkgcGFyc2UgaWYgaXRzIG5vdCBhIHRpbWVzdGFtcCBhbHJlYWR5XG5cdGlmICghaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSkge1xuXHRcdHZhbHVlID0gdHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZydcblx0XHRcdD8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgZm9ybWF0KVxuXHRcdFx0OiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcblx0fVxuXG5cdGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdHJldHVybiArdmFsdWU7XG5cdH1cblxuXHQvLyBMYWJlbHMgYXJlIGluIGFuIGluY29tcGF0aWJsZSBmb3JtYXQgYW5kIG5vIGBwYXJzZXJgIGhhcyBiZWVuIHByb3ZpZGVkLlxuXHQvLyBUaGUgdXNlciBtaWdodCBzdGlsbCB1c2UgdGhlIGRlcHJlY2F0ZWQgYGZvcm1hdGAgb3B0aW9uIGZvciBwYXJzaW5nLlxuXHRpZiAoIXBhcnNlciAmJiB0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFsdWUgPSBmb3JtYXQoaW5wdXQpO1xuXG5cdFx0Ly8gYGZvcm1hdGAgY291bGQgcmV0dXJuIHNvbWV0aGluZyBlbHNlIHRoYW4gYSB0aW1lc3RhbXAsIGlmIHNvLCBwYXJzZSBpdFxuXHRcdGlmICghaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xuXHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnMudGltZTtcblx0dmFyIHZhbHVlID0gdG9UaW1lc3RhbXAoc2NhbGUsIHNjYWxlLmdldFJpZ2h0VmFsdWUoaW5wdXQpKTtcblx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMucm91bmQpIHtcblx0XHR2YWx1ZSA9ICtzY2FsZS5fYWRhcHRlci5zdGFydE9mKHZhbHVlLCBvcHRpb25zLnJvdW5kKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdW5pdCB0byBza2lwIHRvIGJlIGFibGUgdG8gZGlzcGxheSB1cCB0byBgY2FwYWNpdHlgIG51bWJlciBvZiB0aWNrc1xuICogaW4gYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYG1pbmAgLyBgbWF4YCByYW5nZSBhbmQgcmVzcGVjdGluZyB0aGUgaW50ZXJ2YWwgc3RlcHMgY29uc3RyYWludHMuXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVN0ZXBTaXplKG1pbiwgbWF4LCB1bml0LCBjYXBhY2l0eSkge1xuXHR2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG5cdHZhciBpbnRlcnZhbCA9IElOVEVSVkFMU1t1bml0XTtcblx0dmFyIG1pbGxpc2Vjb25kcyA9IGludGVydmFsLnNpemU7XG5cdHZhciBzdGVwcyA9IGludGVydmFsLnN0ZXBzO1xuXHR2YXIgaSwgaWxlbiwgZmFjdG9yO1xuXG5cdGlmICghc3RlcHMpIHtcblx0XHRyZXR1cm4gTWF0aC5jZWlsKHJhbmdlIC8gKGNhcGFjaXR5ICogbWlsbGlzZWNvbmRzKSk7XG5cdH1cblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gc3RlcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0ZmFjdG9yID0gc3RlcHNbaV07XG5cdFx0aWYgKE1hdGguY2VpbChyYW5nZSAvIChtaWxsaXNlY29uZHMgKiBmYWN0b3IpKSA8PSBjYXBhY2l0eSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhY3Rvcjtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgcmVzdWx0cyBpbiBhbiBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXV0by1nZW5lcmF0ZWQgdGlja3NcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcblx0dmFyIGlsZW4gPSBVTklUUy5sZW5ndGg7XG5cdHZhciBpLCBpbnRlcnZhbCwgZmFjdG9yO1xuXG5cdGZvciAoaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG5cdFx0aW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuXHRcdGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHNbaW50ZXJ2YWwuc3RlcHMubGVuZ3RoIC0gMV0gOiBNQVhfSU5URUdFUjtcblxuXHRcdGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuXHRcdFx0cmV0dXJuIFVOSVRTW2ldO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBVTklUU1tpbGVuIC0gMV07XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHRvIGZvcm1hdCBhIHNldCBvZiB0aWNrcyB3aXRoXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCB0aWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcblx0dmFyIGlsZW4gPSBVTklUUy5sZW5ndGg7XG5cdHZhciBpLCB1bml0O1xuXG5cdGZvciAoaSA9IGlsZW4gLSAxOyBpID49IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGktLSkge1xuXHRcdHVuaXQgPSBVTklUU1tpXTtcblx0XHRpZiAoSU5URVJWQUxTW3VuaXRdLmNvbW1vbiAmJiBzY2FsZS5fYWRhcHRlci5kaWZmKG1heCwgbWluLCB1bml0KSA+PSB0aWNrcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB1bml0O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBVTklUU1ttaW5Vbml0ID8gVU5JVFMuaW5kZXhPZihtaW5Vbml0KSA6IDBdO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuXHRmb3IgKHZhciBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcblx0XHRcdHJldHVybiBVTklUU1tpXTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtYXhpbXVtIG9mIGBjYXBhY2l0eWAgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCByb3VuZGVkIHRvIHRoZVxuICogYG1pbm9yYCB1bml0LCBhbGlnbmVkIG9uIHRoZSBgbWFqb3JgIHVuaXQgYW5kIHVzaW5nIHRoZSBnaXZlbiBzY2FsZSB0aW1lIGBvcHRpb25zYC5cbiAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcbiAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGUoc2NhbGUsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuXHR2YXIgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuXHR2YXIgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG5cdHZhciB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcblx0dmFyIG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSk7XG5cdHZhciBtYWpvciA9IGRldGVybWluZU1ham9yVW5pdChtaW5vcik7XG5cdHZhciBzdGVwU2l6ZSA9IHZhbHVlT3JEZWZhdWx0JGModGltZU9wdHMuc3RlcFNpemUsIHRpbWVPcHRzLnVuaXRTdGVwU2l6ZSk7XG5cdHZhciB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcblx0dmFyIG1ham9yVGlja3NFbmFibGVkID0gb3B0aW9ucy50aWNrcy5tYWpvci5lbmFibGVkO1xuXHR2YXIgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbbWlub3JdO1xuXHR2YXIgZmlyc3QgPSBtaW47XG5cdHZhciBsYXN0ID0gbWF4O1xuXHR2YXIgdGlja3MgPSBbXTtcblx0dmFyIHRpbWU7XG5cblx0aWYgKCFzdGVwU2l6ZSkge1xuXHRcdHN0ZXBTaXplID0gZGV0ZXJtaW5lU3RlcFNpemUobWluLCBtYXgsIG1pbm9yLCBjYXBhY2l0eSk7XG5cdH1cblxuXHQvLyBGb3IgJ3dlZWsnIHVuaXQsIGhhbmRsZSB0aGUgZmlyc3QgZGF5IG9mIHdlZWsgb3B0aW9uXG5cdGlmICh3ZWVrZGF5KSB7XG5cdFx0Zmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuXHRcdGxhc3QgPSArYWRhcHRlci5zdGFydE9mKGxhc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG5cdH1cblxuXHQvLyBBbGlnbiBmaXJzdC9sYXN0IHRpY2tzIG9uIHVuaXRcblx0Zmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCB3ZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG5cdGxhc3QgPSArYWRhcHRlci5zdGFydE9mKGxhc3QsIHdlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcblxuXHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgbGFzdCB0aWNrIGluY2x1ZGUgbWF4XG5cdGlmIChsYXN0IDwgbWF4KSB7XG5cdFx0bGFzdCA9ICthZGFwdGVyLmFkZChsYXN0LCAxLCBtaW5vcik7XG5cdH1cblxuXHR0aW1lID0gZmlyc3Q7XG5cblx0aWYgKG1ham9yVGlja3NFbmFibGVkICYmIG1ham9yICYmICF3ZWVrZGF5ICYmICF0aW1lT3B0cy5yb3VuZCkge1xuXHRcdC8vIEFsaWduIHRoZSBmaXJzdCB0aWNrIG9uIHRoZSBwcmV2aW91cyBgbWlub3JgIHVuaXQgYWxpZ25lZCBvbiB0aGUgYG1ham9yYCB1bml0OlxuXHRcdC8vIHdlIGZpcnN0IGFsaWduZWQgdGltZSBvbiB0aGUgcHJldmlvdXMgYG1ham9yYCB1bml0IHRoZW4gYWRkIHRoZSBudW1iZXIgb2YgZnVsbFxuXHRcdC8vIHN0ZXBTaXplIHRoZXJlIGlzIGJldHdlZW4gZmlyc3QgYW5kIHRoZSBwcmV2aW91cyBtYWpvciB0aW1lLlxuXHRcdHRpbWUgPSArYWRhcHRlci5zdGFydE9mKHRpbWUsIG1ham9yKTtcblx0XHR0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIH5+KChmaXJzdCAtIHRpbWUpIC8gKGludGVydmFsLnNpemUgKiBzdGVwU2l6ZSkpICogc3RlcFNpemUsIG1pbm9yKTtcblx0fVxuXG5cdGZvciAoOyB0aW1lIDwgbGFzdDsgdGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCBzdGVwU2l6ZSwgbWlub3IpKSB7XG5cdFx0dGlja3MucHVzaCgrdGltZSk7XG5cdH1cblxuXHR0aWNrcy5wdXNoKCt0aW1lKTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBvZmZzZXRzIGZyb20gZWRnZXMgaW4gdGhlIGZvcm0gb2Yge3N0YXJ0LCBlbmR9XG4gKiB3aGVyZSBlYWNoIHZhbHVlIGlzIGEgcmVsYXRpdmUgd2lkdGggdG8gdGhlIHNjYWxlIGFuZCByYW5nZXMgYmV0d2VlbiAwIGFuZCAxLlxuICogVGhleSBhZGQgZXh0cmEgbWFyZ2lucyBvbiB0aGUgYm90aCBzaWRlcyBieSBzY2FsaW5nIGRvd24gdGhlIG9yaWdpbmFsIHNjYWxlLlxuICogT2Zmc2V0cyBhcmUgYWRkZWQgd2hlbiB0aGUgYG9mZnNldGAgb3B0aW9uIGlzIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRzKHRhYmxlLCB0aWNrcywgbWluLCBtYXgsIG9wdGlvbnMpIHtcblx0dmFyIHN0YXJ0ID0gMDtcblx0dmFyIGVuZCA9IDA7XG5cdHZhciBmaXJzdCwgbGFzdDtcblxuXHRpZiAob3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG5cdFx0aWYgKCFvcHRpb25zLnRpbWUubWluKSB7XG5cdFx0XHRmaXJzdCA9IGludGVycG9sYXRlJDEodGFibGUsICd0aW1lJywgdGlja3NbMF0sICdwb3MnKTtcblx0XHRcdGlmICh0aWNrcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0c3RhcnQgPSAxIC0gZmlyc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdGFydCA9IChpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzWzFdLCAncG9zJykgLSBmaXJzdCkgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIW9wdGlvbnMudGltZS5tYXgpIHtcblx0XHRcdGxhc3QgPSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLCAncG9zJyk7XG5cdFx0XHRpZiAodGlja3MubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGVuZCA9IGxhc3Q7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbmQgPSAobGFzdCAtIGludGVycG9sYXRlJDEodGFibGUsICd0aW1lJywgdGlja3NbdGlja3MubGVuZ3RoIC0gMl0sICdwb3MnKSkgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7c3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH07XG59XG5cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG5cdHZhciB0aWNrcyA9IFtdO1xuXHR2YXIgaSwgaWxlbiwgdmFsdWUsIG1ham9yO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0dmFsdWUgPSB2YWx1ZXNbaV07XG5cdFx0bWFqb3IgPSBtYWpvclVuaXQgPyB2YWx1ZSA9PT0gK3NjYWxlLl9hZGFwdGVyLnN0YXJ0T2YodmFsdWUsIG1ham9yVW5pdCkgOiBmYWxzZTtcblxuXHRcdHRpY2tzLnB1c2goe1xuXHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0bWFqb3I6IG1ham9yXG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbnZhciBkZWZhdWx0Q29uZmlnJDQgPSB7XG5cdHBvc2l0aW9uOiAnYm90dG9tJyxcblxuXHQvKipcblx0ICogRGF0YSBkaXN0cmlidXRpb24gYWxvbmcgdGhlIHNjYWxlOlxuXHQgKiAtICdsaW5lYXInOiBkYXRhIGFyZSBzcHJlYWQgYWNjb3JkaW5nIHRvIHRoZWlyIHRpbWUgKGRpc3RhbmNlcyBjYW4gdmFyeSksXG5cdCAqIC0gJ3Nlcmllcyc6IGRhdGEgYXJlIHNwcmVhZCBhdCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuXG5cdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTA3XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0ZGlzdHJpYnV0aW9uOiAnbGluZWFyJyxcblxuXHQvKipcblx0ICogU2NhbGUgYm91bmRhcnkgc3RyYXRlZ3kgKGJ5cGFzc2VkIGJ5IG1pbi9tYXggdGltZSBvcHRpb25zKVxuXHQgKiAtIGBkYXRhYDogbWFrZSBzdXJlIGRhdGEgYXJlIGZ1bGx5IHZpc2libGUsIHRpY2tzIG91dHNpZGUgYXJlIHJlbW92ZWRcblx0ICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG5cdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTU2XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0Ym91bmRzOiAnZGF0YScsXG5cblx0YWRhcHRlcnM6IHt9LFxuXHR0aW1lOiB7XG5cdFx0cGFyc2VyOiBmYWxzZSwgLy8gZmFsc2UgPT0gYSBwYXR0ZXJuIHN0cmluZyBmcm9tIGh0dHBzOi8vbW9tZW50anMuY29tL2RvY3MvIy9wYXJzaW5nL3N0cmluZy1mb3JtYXQvIG9yIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgY29udmVydHMgaXRzIGFyZ3VtZW50IHRvIGEgbW9tZW50XG5cdFx0Zm9ybWF0OiBmYWxzZSwgLy8gREVQUkVDQVRFRCBmYWxzZSA9PSBkYXRlIG9iamVjdHMsIG1vbWVudCBvYmplY3QsIGNhbGxiYWNrIG9yIGEgcGF0dGVybiBzdHJpbmcgZnJvbSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0L1xuXHRcdHVuaXQ6IGZhbHNlLCAvLyBmYWxzZSA9PSBhdXRvbWF0aWMgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuXHRcdHJvdW5kOiBmYWxzZSwgLy8gbm9uZSwgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuXHRcdGRpc3BsYXlGb3JtYXQ6IGZhbHNlLCAvLyBERVBSRUNBVEVEXG5cdFx0aXNvV2Vla2RheTogZmFsc2UsIC8vIG92ZXJyaWRlIHdlZWsgc3RhcnQgZGF5IC0gc2VlIGh0dHBzOi8vbW9tZW50anMuY29tL2RvY3MvIy9nZXQtc2V0L2lzby13ZWVrZGF5L1xuXHRcdG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG5cdFx0ZGlzcGxheUZvcm1hdHM6IHt9XG5cdH0sXG5cdHRpY2tzOiB7XG5cdFx0YXV0b1NraXA6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0ICogVGlja3MgZ2VuZXJhdGlvbiBpbnB1dCB2YWx1ZXM6XG5cdFx0ICogLSAnYXV0byc6IGdlbmVyYXRlcyBcIm9wdGltYWxcIiB0aWNrcyBiYXNlZCBvbiBzY2FsZSBzaXplIGFuZCB0aW1lIG9wdGlvbnMuXG5cdFx0ICogLSAnZGF0YSc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIGRhdGEgKGluY2x1ZGluZyBsYWJlbHMgZnJvbSBkYXRhIHt0fHh8eX0gb2JqZWN0cykuXG5cdFx0ICogLSAnbGFiZWxzJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gdXNlciBnaXZlbiBgZGF0YS5sYWJlbHNgIHZhbHVlcyBPTkxZLlxuXHRcdCAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTA3XG5cdFx0ICogQHNpbmNlIDIuNy4wXG5cdFx0ICovXG5cdFx0c291cmNlOiAnYXV0bycsXG5cblx0XHRtYWpvcjoge1xuXHRcdFx0ZW5hYmxlZDogZmFsc2Vcblx0XHR9XG5cdH1cbn07XG5cbnZhciBzY2FsZV90aW1lID0gY29yZV9zY2FsZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLm1lcmdlVGlja3NPcHRpb25zKCk7XG5cdFx0Y29yZV9zY2FsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHRpbWUgPSBvcHRpb25zLnRpbWUgfHwgKG9wdGlvbnMudGltZSA9IHt9KTtcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyID0gbmV3IGNvcmVfYWRhcHRlcnMuX2RhdGUob3B0aW9ucy5hZGFwdGVycy5kYXRlKTtcblxuXHRcdC8vIERFUFJFQ0FUSU9OUzogb3V0cHV0IGEgbWVzc2FnZSBvbmx5IG9uZSB0aW1lIHBlciB1cGRhdGVcblx0XHRpZiAodGltZS5mb3JtYXQpIHtcblx0XHRcdGNvbnNvbGUud2Fybignb3B0aW9ucy50aW1lLmZvcm1hdCBpcyBkZXByZWNhdGVkIGFuZCByZXBsYWNlZCBieSBvcHRpb25zLnRpbWUucGFyc2VyLicpO1xuXHRcdH1cblxuXHRcdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGJlZm9yZSBpbnRyb2R1Y2luZyBhZGFwdGVyLCBgZGlzcGxheUZvcm1hdHNgIHdhc1xuXHRcdC8vIHN1cHBvc2VkIHRvIGNvbnRhaW4gKmFsbCogdW5pdC9zdHJpbmcgcGFpcnMgYnV0IHRoaXMgY2FuJ3QgYmUgcmVzb2x2ZWRcblx0XHQvLyB3aGVuIGxvYWRpbmcgdGhlIHNjYWxlIChhZGFwdGVycyBhcmUgbG9hZGVkIGFmdGVyd2FyZCksIHNvIGxldCdzIHBvcHVsYXRlXG5cdFx0Ly8gbWlzc2luZyBmb3JtYXRzIG9uIHVwZGF0ZVxuXHRcdGhlbHBlcnMkMS5tZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcblxuXHRcdHJldHVybiBjb3JlX3NjYWxlLnByb3RvdHlwZS51cGRhdGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFsbG93cyBkYXRhIHRvIGJlIHJlZmVyZW5jZWQgdmlhICd0JyBhdHRyaWJ1dGVcblx0ICovXG5cdGdldFJpZ2h0VmFsdWU6IGZ1bmN0aW9uKHJhd1ZhbHVlKSB7XG5cdFx0aWYgKHJhd1ZhbHVlICYmIHJhd1ZhbHVlLnQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmF3VmFsdWUgPSByYXdWYWx1ZS50O1xuXHRcdH1cblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUuZ2V0UmlnaHRWYWx1ZS5jYWxsKHRoaXMsIHJhd1ZhbHVlKTtcblx0fSxcblxuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBhZGFwdGVyID0gbWUuX2FkYXB0ZXI7XG5cdFx0dmFyIHRpbWVPcHRzID0gbWUub3B0aW9ucy50aW1lO1xuXHRcdHZhciB1bml0ID0gdGltZU9wdHMudW5pdCB8fCAnZGF5Jztcblx0XHR2YXIgbWluID0gTUFYX0lOVEVHRVI7XG5cdFx0dmFyIG1heCA9IE1JTl9JTlRFR0VSO1xuXHRcdHZhciB0aW1lc3RhbXBzID0gW107XG5cdFx0dmFyIGRhdGFzZXRzID0gW107XG5cdFx0dmFyIGxhYmVscyA9IFtdO1xuXHRcdHZhciBpLCBqLCBpbGVuLCBqbGVuLCBkYXRhLCB0aW1lc3RhbXA7XG5cdFx0dmFyIGRhdGFMYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcblxuXHRcdC8vIENvbnZlcnQgbGFiZWxzIHRvIHRpbWVzdGFtcHNcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YUxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGxhYmVscy5wdXNoKHBhcnNlKG1lLCBkYXRhTGFiZWxzW2ldKSk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIHRvIHRpbWVzdGFtcHNcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0ZGF0YSA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0uZGF0YTtcblxuXHRcdFx0XHQvLyBMZXQncyBjb25zaWRlciB0aGF0IGFsbCBkYXRhIGhhdmUgdGhlIHNhbWUgZm9ybWF0LlxuXHRcdFx0XHRpZiAoaGVscGVycyQxLmlzT2JqZWN0KGRhdGFbMF0pKSB7XG5cdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuXHRcdFx0XHRcdFx0dGltZXN0YW1wID0gcGFyc2UobWUsIGRhdGFbal0pO1xuXHRcdFx0XHRcdFx0dGltZXN0YW1wcy5wdXNoKHRpbWVzdGFtcCk7XG5cdFx0XHRcdFx0XHRkYXRhc2V0c1tpXVtqXSA9IHRpbWVzdGFtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yIChqID0gMCwgamxlbiA9IGxhYmVscy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcHMucHVzaChsYWJlbHNbal0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhc2V0c1tpXSA9IGxhYmVscy5zbGljZSgwKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YXNldHNbaV0gPSBbXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobGFiZWxzLmxlbmd0aCkge1xuXHRcdFx0Ly8gU29ydCBsYWJlbHMgKiphZnRlcioqIGRhdGEgaGF2ZSBiZWVuIGNvbnZlcnRlZFxuXHRcdFx0bGFiZWxzID0gYXJyYXlVbmlxdWUobGFiZWxzKS5zb3J0KHNvcnRlcik7XG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIGxhYmVsc1swXSk7XG5cdFx0XHRtYXggPSBNYXRoLm1heChtYXgsIGxhYmVsc1tsYWJlbHMubGVuZ3RoIC0gMV0pO1xuXHRcdH1cblxuXHRcdGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdFx0dGltZXN0YW1wcyA9IGFycmF5VW5pcXVlKHRpbWVzdGFtcHMpLnNvcnQoc29ydGVyKTtcblx0XHRcdG1pbiA9IE1hdGgubWluKG1pbiwgdGltZXN0YW1wc1swXSk7XG5cdFx0XHRtYXggPSBNYXRoLm1heChtYXgsIHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XG5cdFx0fVxuXG5cdFx0bWluID0gcGFyc2UobWUsIHRpbWVPcHRzLm1pbikgfHwgbWluO1xuXHRcdG1heCA9IHBhcnNlKG1lLCB0aW1lT3B0cy5tYXgpIHx8IG1heDtcblxuXHRcdC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gdmFsaWQgbWluL21heCwgc2V0IGxpbWl0cyBiYXNlZCBvbiB1bml0IHRpbWUgb3B0aW9uXG5cdFx0bWluID0gbWluID09PSBNQVhfSU5URUdFUiA/ICthZGFwdGVyLnN0YXJ0T2YoRGF0ZS5ub3coKSwgdW5pdCkgOiBtaW47XG5cdFx0bWF4ID0gbWF4ID09PSBNSU5fSU5URUdFUiA/ICthZGFwdGVyLmVuZE9mKERhdGUubm93KCksIHVuaXQpICsgMSA6IG1heDtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG1heCBpcyBzdHJpY3RseSBoaWdoZXIgdGhhbiBtaW4gKHJlcXVpcmVkIGJ5IHRoZSBsb29rdXAgdGFibGUpXG5cdFx0bWUubWluID0gTWF0aC5taW4obWluLCBtYXgpO1xuXHRcdG1lLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG5cblx0XHQvLyBQUklWQVRFXG5cdFx0bWUuX2hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRtZS5fdGFibGUgPSBbXTtcblx0XHRtZS5fdGltZXN0YW1wcyA9IHtcblx0XHRcdGRhdGE6IHRpbWVzdGFtcHMsXG5cdFx0XHRkYXRhc2V0czogZGF0YXNldHMsXG5cdFx0XHRsYWJlbHM6IGxhYmVsc1xuXHRcdH07XG5cdH0sXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWluID0gbWUubWluO1xuXHRcdHZhciBtYXggPSBtZS5tYXg7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcblx0XHR2YXIgdGltZXN0YW1wcyA9IFtdO1xuXHRcdHZhciB0aWNrcyA9IFtdO1xuXHRcdHZhciBpLCBpbGVuLCB0aW1lc3RhbXA7XG5cblx0XHRzd2l0Y2ggKG9wdGlvbnMudGlja3Muc291cmNlKSB7XG5cdFx0Y2FzZSAnZGF0YSc6XG5cdFx0XHR0aW1lc3RhbXBzID0gbWUuX3RpbWVzdGFtcHMuZGF0YTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2xhYmVscyc6XG5cdFx0XHR0aW1lc3RhbXBzID0gbWUuX3RpbWVzdGFtcHMubGFiZWxzO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnYXV0byc6XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRpbWVzdGFtcHMgPSBnZW5lcmF0ZShtZSwgbWluLCBtYXgsIG1lLmdldExhYmVsQ2FwYWNpdHkobWluKSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG5cdFx0XHRtaW4gPSB0aW1lc3RhbXBzWzBdO1xuXHRcdFx0bWF4ID0gdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuXHRcdH1cblxuXHRcdC8vIEVuZm9yY2UgbGltaXRzIHdpdGggdXNlciBtaW4vbWF4IG9wdGlvbnNcblx0XHRtaW4gPSBwYXJzZShtZSwgdGltZU9wdHMubWluKSB8fCBtaW47XG5cdFx0bWF4ID0gcGFyc2UobWUsIHRpbWVPcHRzLm1heCkgfHwgbWF4O1xuXG5cdFx0Ly8gUmVtb3ZlIHRpY2tzIG91dHNpZGUgdGhlIG1pbi9tYXggcmFuZ2Vcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGltZXN0YW1wcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbaV07XG5cdFx0XHRpZiAodGltZXN0YW1wID49IG1pbiAmJiB0aW1lc3RhbXAgPD0gbWF4KSB7XG5cdFx0XHRcdHRpY2tzLnB1c2godGltZXN0YW1wKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS5taW4gPSBtaW47XG5cdFx0bWUubWF4ID0gbWF4O1xuXG5cdFx0Ly8gUFJJVkFURVxuXHRcdG1lLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhtZSwgdGlja3MsIHRpbWVPcHRzLm1pblVuaXQsIG1lLm1pbiwgbWUubWF4KTtcblx0XHRtZS5fbWFqb3JVbml0ID0gZGV0ZXJtaW5lTWFqb3JVbml0KG1lLl91bml0KTtcblx0XHRtZS5fdGFibGUgPSBidWlsZExvb2t1cFRhYmxlKG1lLl90aW1lc3RhbXBzLmRhdGEsIG1pbiwgbWF4LCBvcHRpb25zLmRpc3RyaWJ1dGlvbik7XG5cdFx0bWUuX29mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyhtZS5fdGFibGUsIHRpY2tzLCBtaW4sIG1heCwgb3B0aW9ucyk7XG5cblx0XHRpZiAob3B0aW9ucy50aWNrcy5yZXZlcnNlKSB7XG5cdFx0XHR0aWNrcy5yZXZlcnNlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHMobWUsIHRpY2tzLCBtZS5fbWFqb3JVbml0KTtcblx0fSxcblxuXHRnZXRMYWJlbEZvckluZGV4OiBmdW5jdGlvbihpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuXHRcdHZhciBkYXRhID0gbWUuY2hhcnQuZGF0YTtcblx0XHR2YXIgdGltZU9wdHMgPSBtZS5vcHRpb25zLnRpbWU7XG5cdFx0dmFyIGxhYmVsID0gZGF0YS5sYWJlbHMgJiYgaW5kZXggPCBkYXRhLmxhYmVscy5sZW5ndGggPyBkYXRhLmxhYmVsc1tpbmRleF0gOiAnJztcblx0XHR2YXIgdmFsdWUgPSBkYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF07XG5cblx0XHRpZiAoaGVscGVycyQxLmlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdFx0bGFiZWwgPSBtZS5nZXRSaWdodFZhbHVlKHZhbHVlKTtcblx0XHR9XG5cdFx0aWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcblx0XHRcdHJldHVybiBhZGFwdGVyLmZvcm1hdCh0b1RpbWVzdGFtcChtZSwgbGFiZWwpLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBsYWJlbDtcblx0XHR9XG5cdFx0cmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHRvVGltZXN0YW1wKG1lLCBsYWJlbCksIHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzLmRhdGV0aW1lKTtcblx0fSxcblxuXHQvKipcblx0ICogRnVuY3Rpb24gdG8gZm9ybWF0IGFuIGluZGl2aWR1YWwgdGljayBtYXJrXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR0aWNrRm9ybWF0RnVuY3Rpb246IGZ1bmN0aW9uKHRpbWUsIGluZGV4LCB0aWNrcywgZm9ybWF0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcblx0XHR2YXIgbWlub3JGb3JtYXQgPSBmb3JtYXRzW21lLl91bml0XTtcblx0XHR2YXIgbWFqb3JVbml0ID0gbWUuX21ham9yVW5pdDtcblx0XHR2YXIgbWFqb3JGb3JtYXQgPSBmb3JtYXRzW21ham9yVW5pdF07XG5cdFx0dmFyIG1ham9yVGltZSA9ICthZGFwdGVyLnN0YXJ0T2YodGltZSwgbWFqb3JVbml0KTtcblx0XHR2YXIgbWFqb3JUaWNrT3B0cyA9IG9wdGlvbnMudGlja3MubWFqb3I7XG5cdFx0dmFyIG1ham9yID0gbWFqb3JUaWNrT3B0cy5lbmFibGVkICYmIG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aW1lID09PSBtYWpvclRpbWU7XG5cdFx0dmFyIGxhYmVsID0gYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0ID8gZm9ybWF0IDogbWFqb3IgPyBtYWpvckZvcm1hdCA6IG1pbm9yRm9ybWF0KTtcblx0XHR2YXIgdGlja09wdHMgPSBtYWpvciA/IG1ham9yVGlja09wdHMgOiBvcHRpb25zLnRpY2tzLm1pbm9yO1xuXHRcdHZhciBmb3JtYXR0ZXIgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpY2tPcHRzLmNhbGxiYWNrLCB0aWNrT3B0cy51c2VyQ2FsbGJhY2spO1xuXG5cdFx0cmV0dXJuIGZvcm1hdHRlciA/IGZvcm1hdHRlcihsYWJlbCwgaW5kZXgsIHRpY2tzKSA6IGxhYmVsO1xuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbih0aWNrcykge1xuXHRcdHZhciBsYWJlbHMgPSBbXTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGxhYmVscy5wdXNoKHRoaXMudGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2tzW2ldLnZhbHVlLCBpLCB0aWNrcykpO1xuXHRcdH1cblxuXHRcdHJldHVybiBsYWJlbHM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRQaXhlbEZvck9mZnNldDogZnVuY3Rpb24odGltZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGlzUmV2ZXJzZSA9IG1lLm9wdGlvbnMudGlja3MucmV2ZXJzZTtcblx0XHR2YXIgc2l6ZSA9IG1lLl9ob3Jpem9udGFsID8gbWUud2lkdGggOiBtZS5oZWlnaHQ7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuX2hvcml6b250YWwgPyBpc1JldmVyc2UgPyBtZS5yaWdodCA6IG1lLmxlZnQgOiBpc1JldmVyc2UgPyBtZS5ib3R0b20gOiBtZS50b3A7XG5cdFx0dmFyIHBvcyA9IGludGVycG9sYXRlJDEobWUuX3RhYmxlLCAndGltZScsIHRpbWUsICdwb3MnKTtcblx0XHR2YXIgb2Zmc2V0ID0gc2l6ZSAqIChtZS5fb2Zmc2V0cy5zdGFydCArIHBvcykgLyAobWUuX29mZnNldHMuc3RhcnQgKyAxICsgbWUuX29mZnNldHMuZW5kKTtcblxuXHRcdHJldHVybiBpc1JldmVyc2UgPyBzdGFydCAtIG9mZnNldCA6IHN0YXJ0ICsgb2Zmc2V0O1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGltZSA9IG51bGw7XG5cblx0XHRpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0SW5kZXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGltZSA9IG1lLl90aW1lc3RhbXBzLmRhdGFzZXRzW2RhdGFzZXRJbmRleF1baW5kZXhdO1xuXHRcdH1cblxuXHRcdGlmICh0aW1lID09PSBudWxsKSB7XG5cdFx0XHR0aW1lID0gcGFyc2UobWUsIHZhbHVlKTtcblx0XHR9XG5cblx0XHRpZiAodGltZSAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG1lLmdldFBpeGVsRm9yT2Zmc2V0KHRpbWUpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIHRpY2tzID0gdGhpcy5nZXRUaWNrcygpO1xuXHRcdHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoID9cblx0XHRcdHRoaXMuZ2V0UGl4ZWxGb3JPZmZzZXQodGlja3NbaW5kZXhdLnZhbHVlKSA6XG5cdFx0XHRudWxsO1xuXHR9LFxuXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc2l6ZSA9IG1lLl9ob3Jpem9udGFsID8gbWUud2lkdGggOiBtZS5oZWlnaHQ7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuX2hvcml6b250YWwgPyBtZS5sZWZ0IDogbWUudG9wO1xuXHRcdHZhciBwb3MgPSAoc2l6ZSA/IChwaXhlbCAtIHN0YXJ0KSAvIHNpemUgOiAwKSAqIChtZS5fb2Zmc2V0cy5zdGFydCArIDEgKyBtZS5fb2Zmc2V0cy5zdGFydCkgLSBtZS5fb2Zmc2V0cy5lbmQ7XG5cdFx0dmFyIHRpbWUgPSBpbnRlcnBvbGF0ZSQxKG1lLl90YWJsZSwgJ3BvcycsIHBvcywgJ3RpbWUnKTtcblxuXHRcdC8vIERFUFJFQ0FUSU9OLCB3ZSBzaG91bGQgcmV0dXJuIHRpbWUgZGlyZWN0bHlcblx0XHRyZXR1cm4gbWUuX2FkYXB0ZXIuX2NyZWF0ZSh0aW1lKTtcblx0fSxcblxuXHQvKipcblx0ICogQ3J1ZGUgYXBwcm94aW1hdGlvbiBvZiB3aGF0IHRoZSBsYWJlbCB3aWR0aCBtaWdodCBiZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0TGFiZWxXaWR0aDogZnVuY3Rpb24obGFiZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrc09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciB0aWNrTGFiZWxXaWR0aCA9IG1lLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG5cdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvUmFkaWFucyh0aWNrc09wdHMubWF4Um90YXRpb24pO1xuXHRcdHZhciBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHR2YXIgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XG5cdFx0dmFyIHRpY2tGb250U2l6ZSA9IHZhbHVlT3JEZWZhdWx0JGModGlja3NPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpO1xuXG5cdFx0cmV0dXJuICh0aWNrTGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBzaW5Sb3RhdGlvbik7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRMYWJlbENhcGFjaXR5OiBmdW5jdGlvbihleGFtcGxlVGltZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHQvLyBwaWNrIHRoZSBsb25nZXN0IGZvcm1hdCAobWlsbGlzZWNvbmRzKSBmb3IgZ3Vlc3RpbWF0aW9uXG5cdFx0dmFyIGZvcm1hdCA9IG1lLm9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcblx0XHR2YXIgZXhhbXBsZUxhYmVsID0gbWUudGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCBbXSwgZm9ybWF0KTtcblx0XHR2YXIgdGlja0xhYmVsV2lkdGggPSBtZS5nZXRMYWJlbFdpZHRoKGV4YW1wbGVMYWJlbCk7XG5cdFx0dmFyIGlubmVyV2lkdGggPSBtZS5pc0hvcml6b250YWwoKSA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBjYXBhY2l0eSA9IE1hdGguZmxvb3IoaW5uZXJXaWR0aCAvIHRpY2tMYWJlbFdpZHRoKTtcblxuXHRcdHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMkNCA9IGRlZmF1bHRDb25maWckNDtcbnNjYWxlX3RpbWUuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDQ7XG5cbnZhciBzY2FsZXMgPSB7XG5cdGNhdGVnb3J5OiBzY2FsZV9jYXRlZ29yeSxcblx0bGluZWFyOiBzY2FsZV9saW5lYXIsXG5cdGxvZ2FyaXRobWljOiBzY2FsZV9sb2dhcml0aG1pYyxcblx0cmFkaWFsTGluZWFyOiBzY2FsZV9yYWRpYWxMaW5lYXIsXG5cdHRpbWU6IHNjYWxlX3RpbWVcbn07XG5cbnZhciBGT1JNQVRTID0ge1xuXHRkYXRldGltZTogJ01NTSBELCBZWVlZLCBoOm1tOnNzIGEnLFxuXHRtaWxsaXNlY29uZDogJ2g6bW06c3MuU1NTIGEnLFxuXHRzZWNvbmQ6ICdoOm1tOnNzIGEnLFxuXHRtaW51dGU6ICdoOm1tIGEnLFxuXHRob3VyOiAnaEEnLFxuXHRkYXk6ICdNTU0gRCcsXG5cdHdlZWs6ICdsbCcsXG5cdG1vbnRoOiAnTU1NIFlZWVknLFxuXHRxdWFydGVyOiAnW1FdUSAtIFlZWVknLFxuXHR5ZWFyOiAnWVlZWSdcbn07XG5cbmNvcmVfYWRhcHRlcnMuX2RhdGUub3ZlcnJpZGUodHlwZW9mIG1vbWVudCA9PT0gJ2Z1bmN0aW9uJyA/IHtcblx0X2lkOiAnbW9tZW50JywgLy8gREVCVUcgT05MWVxuXG5cdGZvcm1hdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBGT1JNQVRTO1xuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbih2YWx1ZSwgZm9ybWF0KSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhbHVlID0gbW9tZW50KHZhbHVlLCBmb3JtYXQpO1xuXHRcdH0gZWxzZSBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIG1vbWVudCkpIHtcblx0XHRcdHZhbHVlID0gbW9tZW50KHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlLmlzVmFsaWQoKSA/IHZhbHVlLnZhbHVlT2YoKSA6IG51bGw7XG5cdH0sXG5cblx0Zm9ybWF0OiBmdW5jdGlvbih0aW1lLCBmb3JtYXQpIHtcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpLmZvcm1hdChmb3JtYXQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24odGltZSwgYW1vdW50LCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5hZGQoYW1vdW50LCB1bml0KS52YWx1ZU9mKCk7XG5cdH0sXG5cblx0ZGlmZjogZnVuY3Rpb24obWF4LCBtaW4sIHVuaXQpIHtcblx0XHRyZXR1cm4gbW9tZW50LmR1cmF0aW9uKG1vbWVudChtYXgpLmRpZmYobW9tZW50KG1pbikpKS5hcyh1bml0KTtcblx0fSxcblxuXHRzdGFydE9mOiBmdW5jdGlvbih0aW1lLCB1bml0LCB3ZWVrZGF5KSB7XG5cdFx0dGltZSA9IG1vbWVudCh0aW1lKTtcblx0XHRpZiAodW5pdCA9PT0gJ2lzb1dlZWsnKSB7XG5cdFx0XHRyZXR1cm4gdGltZS5pc29XZWVrZGF5KHdlZWtkYXkpLnZhbHVlT2YoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRpbWUuc3RhcnRPZih1bml0KS52YWx1ZU9mKCk7XG5cdH0sXG5cblx0ZW5kT2Y6IGZ1bmN0aW9uKHRpbWUsIHVuaXQpIHtcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpLmVuZE9mKHVuaXQpLnZhbHVlT2YoKTtcblx0fSxcblxuXHQvLyBERVBSRUNBVElPTlNcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBzY2FsZS5nZXRWYWx1ZUZvclBpeGVsKCkuXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyZWF0ZTogZnVuY3Rpb24odGltZSkge1xuXHRcdHJldHVybiBtb21lbnQodGltZSk7XG5cdH0sXG59IDoge30pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0cGx1Z2luczoge1xuXHRcdGZpbGxlcjoge1xuXHRcdFx0cHJvcGFnYXRlOiB0cnVlXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIG1hcHBlcnMgPSB7XG5cdGRhdGFzZXQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdHZhciBpbmRleCA9IHNvdXJjZS5maWxsO1xuXHRcdHZhciBjaGFydCA9IHNvdXJjZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcblx0XHR2YXIgdmlzaWJsZSA9IG1ldGEgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpbmRleCk7XG5cdFx0dmFyIHBvaW50cyA9ICh2aXNpYmxlICYmIG1ldGEuZGF0YXNldC5fY2hpbGRyZW4pIHx8IFtdO1xuXHRcdHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIHx8IDA7XG5cblx0XHRyZXR1cm4gIWxlbmd0aCA/IG51bGwgOiBmdW5jdGlvbihwb2ludCwgaSkge1xuXHRcdFx0cmV0dXJuIChpIDwgbGVuZ3RoICYmIHBvaW50c1tpXS5fdmlldykgfHwgbnVsbDtcblx0XHR9O1xuXHR9LFxuXG5cdGJvdW5kYXJ5OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR2YXIgYm91bmRhcnkgPSBzb3VyY2UuYm91bmRhcnk7XG5cdFx0dmFyIHggPSBib3VuZGFyeSA/IGJvdW5kYXJ5LnggOiBudWxsO1xuXHRcdHZhciB5ID0gYm91bmRhcnkgPyBib3VuZGFyeS55IDogbnVsbDtcblxuXHRcdHJldHVybiBmdW5jdGlvbihwb2ludCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogeCA9PT0gbnVsbCA/IHBvaW50LnggOiB4LFxuXHRcdFx0XHR5OiB5ID09PSBudWxsID8gcG9pbnQueSA6IHksXG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cbn07XG5cbi8vIEB0b2RvIGlmIChmaWxsWzBdID09PSAnIycpXG5mdW5jdGlvbiBkZWNvZGVGaWxsKGVsLCBpbmRleCwgY291bnQpIHtcblx0dmFyIG1vZGVsID0gZWwuX21vZGVsIHx8IHt9O1xuXHR2YXIgZmlsbCA9IG1vZGVsLmZpbGw7XG5cdHZhciB0YXJnZXQ7XG5cblx0aWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuXHRcdGZpbGwgPSAhIW1vZGVsLmJhY2tncm91bmRDb2xvcjtcblx0fVxuXG5cdGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKGZpbGwgPT09IHRydWUpIHtcblx0XHRyZXR1cm4gJ29yaWdpbic7XG5cdH1cblxuXHR0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwsIDEwKTtcblx0aWYgKGlzRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcblx0XHRpZiAoZmlsbFswXSA9PT0gJy0nIHx8IGZpbGxbMF0gPT09ICcrJykge1xuXHRcdFx0dGFyZ2V0ID0gaW5kZXggKyB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0aWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblx0c3dpdGNoIChmaWxsKSB7XG5cdC8vIGNvbXBhdGliaWxpdHlcblx0Y2FzZSAnYm90dG9tJzpcblx0XHRyZXR1cm4gJ3N0YXJ0Jztcblx0Y2FzZSAndG9wJzpcblx0XHRyZXR1cm4gJ2VuZCc7XG5cdGNhc2UgJ3plcm8nOlxuXHRcdHJldHVybiAnb3JpZ2luJztcblx0Ly8gc3VwcG9ydGVkIGJvdW5kYXJpZXNcblx0Y2FzZSAnb3JpZ2luJzpcblx0Y2FzZSAnc3RhcnQnOlxuXHRjYXNlICdlbmQnOlxuXHRcdHJldHVybiBmaWxsO1xuXHQvLyBpbnZhbGlkIGZpbGwgdmFsdWVzXG5cdGRlZmF1bHQ6XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcblx0dmFyIG1vZGVsID0gc291cmNlLmVsLl9tb2RlbCB8fCB7fTtcblx0dmFyIHNjYWxlID0gc291cmNlLmVsLl9zY2FsZSB8fCB7fTtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHRhcmdldCA9IG51bGw7XG5cdHZhciBob3Jpem9udGFsO1xuXG5cdGlmIChpc0Zpbml0ZShmaWxsKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gQmFja3dhcmQgY29tcGF0aWJpbGl0eTogdW50aWwgdjMsIHdlIHN0aWxsIG5lZWQgdG8gc3VwcG9ydCBib3VuZGFyeSB2YWx1ZXMgc2V0IG9uXG5cdC8vIHRoZSBtb2RlbCAoc2NhbGVUb3AsIHNjYWxlQm90dG9tIGFuZCBzY2FsZVplcm8pIGJlY2F1c2Ugc29tZSBleHRlcm5hbCBwbHVnaW5zIGFuZFxuXHQvLyBjb250cm9sbGVycyBtaWdodCBzdGlsbCB1c2UgaXQgKGUuZy4gdGhlIFNtaXRoIGNoYXJ0KS5cblxuXHRpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuXHRcdHRhcmdldCA9IG1vZGVsLnNjYWxlQm90dG9tID09PSB1bmRlZmluZWQgPyBzY2FsZS5ib3R0b20gOiBtb2RlbC5zY2FsZUJvdHRvbTtcblx0fSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuXHRcdHRhcmdldCA9IG1vZGVsLnNjYWxlVG9wID09PSB1bmRlZmluZWQgPyBzY2FsZS50b3AgOiBtb2RlbC5zY2FsZVRvcDtcblx0fSBlbHNlIGlmIChtb2RlbC5zY2FsZVplcm8gIT09IHVuZGVmaW5lZCkge1xuXHRcdHRhcmdldCA9IG1vZGVsLnNjYWxlWmVybztcblx0fSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUG9zaXRpb24pIHtcblx0XHR0YXJnZXQgPSBzY2FsZS5nZXRCYXNlUG9zaXRpb24oKTtcblx0fSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcblx0XHR0YXJnZXQgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcblx0fVxuXG5cdGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQgIT09IG51bGwpIHtcblx0XHRpZiAodGFyZ2V0LnggIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQueSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGlmIChoZWxwZXJzJDEuaXNGaW5pdGUodGFyZ2V0KSkge1xuXHRcdFx0aG9yaXpvbnRhbCA9IHNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogaG9yaXpvbnRhbCA/IHRhcmdldCA6IG51bGwsXG5cdFx0XHRcdHk6IGhvcml6b250YWwgPyBudWxsIDogdGFyZ2V0XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGluZGV4LCBwcm9wYWdhdGUpIHtcblx0dmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuXHR2YXIgZmlsbCA9IHNvdXJjZS5maWxsO1xuXHR2YXIgdmlzaXRlZCA9IFtpbmRleF07XG5cdHZhciB0YXJnZXQ7XG5cblx0aWYgKCFwcm9wYWdhdGUpIHtcblx0XHRyZXR1cm4gZmlsbDtcblx0fVxuXG5cdHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG5cdFx0aWYgKCFpc0Zpbml0ZShmaWxsKSkge1xuXHRcdFx0cmV0dXJuIGZpbGw7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcblx0XHRpZiAoIXRhcmdldCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmICh0YXJnZXQudmlzaWJsZSkge1xuXHRcdFx0cmV0dXJuIGZpbGw7XG5cdFx0fVxuXG5cdFx0dmlzaXRlZC5wdXNoKGZpbGwpO1xuXHRcdGZpbGwgPSB0YXJnZXQuZmlsbDtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWFwcGVyKHNvdXJjZSkge1xuXHR2YXIgZmlsbCA9IHNvdXJjZS5maWxsO1xuXHR2YXIgdHlwZSA9ICdkYXRhc2V0JztcblxuXHRpZiAoZmlsbCA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmICghaXNGaW5pdGUoZmlsbCkpIHtcblx0XHR0eXBlID0gJ2JvdW5kYXJ5Jztcblx0fVxuXG5cdHJldHVybiBtYXBwZXJzW3R5cGVdKHNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIGlzRHJhd2FibGUocG9pbnQpIHtcblx0cmV0dXJuIHBvaW50ICYmICFwb2ludC5za2lwO1xufVxuXG5mdW5jdGlvbiBkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKSB7XG5cdHZhciBpO1xuXG5cdGlmICghbGVuMCB8fCAhbGVuMSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGJ1aWxkaW5nIGZpcnN0IGFyZWEgY3VydmUgKG5vcm1hbClcblx0Y3R4Lm1vdmVUbyhjdXJ2ZTBbMF0ueCwgY3VydmUwWzBdLnkpO1xuXHRmb3IgKGkgPSAxOyBpIDwgbGVuMDsgKytpKSB7XG5cdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBjdXJ2ZTBbaSAtIDFdLCBjdXJ2ZTBbaV0pO1xuXHR9XG5cblx0Ly8gam9pbmluZyB0aGUgdHdvIGFyZWEgY3VydmVzXG5cdGN0eC5saW5lVG8oY3VydmUxW2xlbjEgLSAxXS54LCBjdXJ2ZTFbbGVuMSAtIDFdLnkpO1xuXG5cdC8vIGJ1aWxkaW5nIG9wcG9zaXRlIGFyZWEgY3VydmUgKHJldmVyc2UpXG5cdGZvciAoaSA9IGxlbjEgLSAxOyBpID4gMDsgLS1pKSB7XG5cdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBjdXJ2ZTFbaV0sIGN1cnZlMVtpIC0gMV0sIHRydWUpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvRmlsbChjdHgsIHBvaW50cywgbWFwcGVyLCB2aWV3LCBjb2xvciwgbG9vcCkge1xuXHR2YXIgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuXHR2YXIgc3BhbiA9IHZpZXcuc3BhbkdhcHM7XG5cdHZhciBjdXJ2ZTAgPSBbXTtcblx0dmFyIGN1cnZlMSA9IFtdO1xuXHR2YXIgbGVuMCA9IDA7XG5cdHZhciBsZW4xID0gMDtcblx0dmFyIGksIGlsZW4sIGluZGV4LCBwMCwgcDEsIGQwLCBkMTtcblxuXHRjdHguYmVnaW5QYXRoKCk7XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IChjb3VudCArICEhbG9vcCk7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpbmRleCA9IGkgJSBjb3VudDtcblx0XHRwMCA9IHBvaW50c1tpbmRleF0uX3ZpZXc7XG5cdFx0cDEgPSBtYXBwZXIocDAsIGluZGV4LCB2aWV3KTtcblx0XHRkMCA9IGlzRHJhd2FibGUocDApO1xuXHRcdGQxID0gaXNEcmF3YWJsZShwMSk7XG5cblx0XHRpZiAoZDAgJiYgZDEpIHtcblx0XHRcdGxlbjAgPSBjdXJ2ZTAucHVzaChwMCk7XG5cdFx0XHRsZW4xID0gY3VydmUxLnB1c2gocDEpO1xuXHRcdH0gZWxzZSBpZiAobGVuMCAmJiBsZW4xKSB7XG5cdFx0XHRpZiAoIXNwYW4pIHtcblx0XHRcdFx0ZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSk7XG5cdFx0XHRcdGxlbjAgPSBsZW4xID0gMDtcblx0XHRcdFx0Y3VydmUwID0gW107XG5cdFx0XHRcdGN1cnZlMSA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGQwKSB7XG5cdFx0XHRcdFx0Y3VydmUwLnB1c2gocDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChkMSkge1xuXHRcdFx0XHRcdGN1cnZlMS5wdXNoKHAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xuXG5cdGN0eC5jbG9zZVBhdGgoKTtcblx0Y3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuXHRjdHguZmlsbCgpO1xufVxuXG52YXIgcGx1Z2luX2ZpbGxlciA9IHtcblx0aWQ6ICdmaWxsZXInLFxuXG5cdGFmdGVyRGF0YXNldHNVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBvcHRpb25zKSB7XG5cdFx0dmFyIGNvdW50ID0gKGNoYXJ0LmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDtcblx0XHR2YXIgcHJvcGFnYXRlID0gb3B0aW9ucy5wcm9wYWdhdGU7XG5cdFx0dmFyIHNvdXJjZXMgPSBbXTtcblx0XHR2YXIgbWV0YSwgaSwgZWwsIHNvdXJjZTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRlbCA9IG1ldGEuZGF0YXNldDtcblx0XHRcdHNvdXJjZSA9IG51bGw7XG5cblx0XHRcdGlmIChlbCAmJiBlbC5fbW9kZWwgJiYgZWwgaW5zdGFuY2VvZiBlbGVtZW50cy5MaW5lKSB7XG5cdFx0XHRcdHNvdXJjZSA9IHtcblx0XHRcdFx0XHR2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuXHRcdFx0XHRcdGZpbGw6IGRlY29kZUZpbGwoZWwsIGksIGNvdW50KSxcblx0XHRcdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRcdFx0ZWw6IGVsXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcblx0XHRcdHNvdXJjZXMucHVzaChzb3VyY2UpO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHRzb3VyY2UgPSBzb3VyY2VzW2ldO1xuXHRcdFx0aWYgKCFzb3VyY2UpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNvdXJjZS5maWxsID0gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBwcm9wYWdhdGUpO1xuXHRcdFx0c291cmNlLmJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG5cdFx0XHRzb3VyY2UubWFwcGVyID0gY3JlYXRlTWFwcGVyKHNvdXJjZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGJlZm9yZURhdGFzZXREcmF3OiBmdW5jdGlvbihjaGFydCwgYXJncykge1xuXHRcdHZhciBtZXRhID0gYXJncy5tZXRhLiRmaWxsZXI7XG5cdFx0aWYgKCFtZXRhKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGN0eCA9IGNoYXJ0LmN0eDtcblx0XHR2YXIgZWwgPSBtZXRhLmVsO1xuXHRcdHZhciB2aWV3ID0gZWwuX3ZpZXc7XG5cdFx0dmFyIHBvaW50cyA9IGVsLl9jaGlsZHJlbiB8fCBbXTtcblx0XHR2YXIgbWFwcGVyID0gbWV0YS5tYXBwZXI7XG5cdFx0dmFyIGNvbG9yID0gdmlldy5iYWNrZ3JvdW5kQ29sb3IgfHwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5cdFx0aWYgKG1hcHBlciAmJiBjb2xvciAmJiBwb2ludHMubGVuZ3RoKSB7XG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGN0eCwgY2hhcnQuY2hhcnRBcmVhKTtcblx0XHRcdGRvRmlsbChjdHgsIHBvaW50cywgbWFwcGVyLCB2aWV3LCBjb2xvciwgZWwuX2xvb3ApO1xuXHRcdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGN0eCk7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgbm9vcCQxID0gaGVscGVycyQxLm5vb3A7XG52YXIgdmFsdWVPckRlZmF1bHQkZCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdGxlZ2VuZDoge1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0cG9zaXRpb246ICd0b3AnLFxuXHRcdGZ1bGxXaWR0aDogdHJ1ZSxcblx0XHRyZXZlcnNlOiBmYWxzZSxcblx0XHR3ZWlnaHQ6IDEwMDAsXG5cblx0XHQvLyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBoYW5kbGVcblx0XHRvbkNsaWNrOiBmdW5jdGlvbihlLCBsZWdlbmRJdGVtKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcblx0XHRcdHZhciBjaSA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgbWV0YSA9IGNpLmdldERhdGFzZXRNZXRhKGluZGV4KTtcblxuXHRcdFx0Ly8gU2VlIGNvbnRyb2xsZXIuaXNEYXRhc2V0VmlzaWJsZSBjb21tZW50XG5cdFx0XHRtZXRhLmhpZGRlbiA9IG1ldGEuaGlkZGVuID09PSBudWxsID8gIWNpLmRhdGEuZGF0YXNldHNbaW5kZXhdLmhpZGRlbiA6IG51bGw7XG5cblx0XHRcdC8vIFdlIGhpZCBhIGRhdGFzZXQgLi4uIHJlcmVuZGVyIHRoZSBjaGFydFxuXHRcdFx0Y2kudXBkYXRlKCk7XG5cdFx0fSxcblxuXHRcdG9uSG92ZXI6IG51bGwsXG5cdFx0b25MZWF2ZTogbnVsbCxcblxuXHRcdGxhYmVsczoge1xuXHRcdFx0Ym94V2lkdGg6IDQwLFxuXHRcdFx0cGFkZGluZzogMTAsXG5cdFx0XHQvLyBHZW5lcmF0ZXMgbGFiZWxzIHNob3duIGluIHRoZSBsZWdlbmRcblx0XHRcdC8vIFZhbGlkIHByb3BlcnRpZXMgdG8gcmV0dXJuOlxuXHRcdFx0Ly8gdGV4dCA6IHRleHQgdG8gZGlzcGxheVxuXHRcdFx0Ly8gZmlsbFN0eWxlIDogZmlsbCBvZiBjb2xvdXJlZCBib3hcblx0XHRcdC8vIHN0cm9rZVN0eWxlOiBzdHJva2Ugb2YgY29sb3VyZWQgYm94XG5cdFx0XHQvLyBoaWRkZW4gOiBpZiB0aGlzIGxlZ2VuZCBpdGVtIHJlZmVycyB0byBhIGhpZGRlbiBpdGVtXG5cdFx0XHQvLyBsaW5lQ2FwIDogY2FwIHN0eWxlIGZvciBsaW5lXG5cdFx0XHQvLyBsaW5lRGFzaFxuXHRcdFx0Ly8gbGluZURhc2hPZmZzZXQgOlxuXHRcdFx0Ly8gbGluZUpvaW4gOlxuXHRcdFx0Ly8gbGluZVdpZHRoIDpcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHRcdHJldHVybiBoZWxwZXJzJDEuaXNBcnJheShkYXRhLmRhdGFzZXRzKSA/IGRhdGEuZGF0YXNldHMubWFwKGZ1bmN0aW9uKGRhdGFzZXQsIGkpIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dGV4dDogZGF0YXNldC5sYWJlbCxcblx0XHRcdFx0XHRcdGZpbGxTdHlsZTogKCFoZWxwZXJzJDEuaXNBcnJheShkYXRhc2V0LmJhY2tncm91bmRDb2xvcikgPyBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA6IGRhdGFzZXQuYmFja2dyb3VuZENvbG9yWzBdKSxcblx0XHRcdFx0XHRcdGhpZGRlbjogIWNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG5cdFx0XHRcdFx0XHRsaW5lQ2FwOiBkYXRhc2V0LmJvcmRlckNhcFN0eWxlLFxuXHRcdFx0XHRcdFx0bGluZURhc2g6IGRhdGFzZXQuYm9yZGVyRGFzaCxcblx0XHRcdFx0XHRcdGxpbmVEYXNoT2Zmc2V0OiBkYXRhc2V0LmJvcmRlckRhc2hPZmZzZXQsXG5cdFx0XHRcdFx0XHRsaW5lSm9pbjogZGF0YXNldC5ib3JkZXJKb2luU3R5bGUsXG5cdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGRhdGFzZXQuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogZGF0YXNldC5ib3JkZXJDb2xvcixcblx0XHRcdFx0XHRcdHBvaW50U3R5bGU6IGRhdGFzZXQucG9pbnRTdHlsZSxcblxuXHRcdFx0XHRcdFx0Ly8gQmVsb3cgaXMgZXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgZGF0YXNldHNcblx0XHRcdFx0XHRcdGRhdGFzZXRJbmRleDogaVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0sIHRoaXMpIDogW107XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0ZXh0ID0gW107XG5cdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGV4dC5wdXNoKCc8bGk+PHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOicgKyBjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmJhY2tncm91bmRDb2xvciArICdcIj48L3NwYW4+Jyk7XG5cdFx0XHRpZiAoY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5sYWJlbCkge1xuXHRcdFx0XHR0ZXh0LnB1c2goY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5sYWJlbCk7XG5cdFx0XHR9XG5cdFx0XHR0ZXh0LnB1c2goJzwvbGk+Jyk7XG5cdFx0fVxuXHRcdHRleHQucHVzaCgnPC91bD4nKTtcblx0XHRyZXR1cm4gdGV4dC5qb2luKCcnKTtcblx0fVxufSk7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm94IHdpZHRoIGJhc2VkIG9uIHRoZSB1c2VQb2ludFN0eWxlIG9wdGlvblxuICogQHBhcmFtIHtvYmplY3R9IGxhYmVsb3B0cyAtIHRoZSBsYWJlbCBvcHRpb25zIG9uIHRoZSBsZWdlbmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb250U2l6ZSAtIHRoZSBsYWJlbCBmb250IHNpemVcbiAqIEByZXR1cm4ge251bWJlcn0gd2lkdGggb2YgdGhlIGNvbG9yIGJveCBhcmVhXG4gKi9cbmZ1bmN0aW9uIGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpIHtcblx0cmV0dXJuIGxhYmVsT3B0cy51c2VQb2ludFN0eWxlICYmIGxhYmVsT3B0cy5ib3hXaWR0aCA+IGZvbnRTaXplID9cblx0XHRmb250U2l6ZSA6XG5cdFx0bGFiZWxPcHRzLmJveFdpZHRoO1xufVxuXG4vKipcbiAqIElNUE9SVEFOVDogdGhpcyBjbGFzcyBpcyBleHBvc2VkIHB1YmxpY2x5IGFzIENoYXJ0LkxlZ2VuZCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eSByZXF1aXJlZCFcbiAqL1xudmFyIExlZ2VuZCA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdGhlbHBlcnMkMS5leHRlbmQodGhpcywgY29uZmlnKTtcblxuXHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuXHRcdHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuXHRcdC8qKlxuIFx0XHQgKiBAcHJpdmF0ZVxuIFx0XHQgKi9cblx0XHR0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG5cblx0XHQvLyBBcmUgd2UgaW4gZG91Z2hudXQgbW9kZSB3aGljaCBoYXMgYSBkaWZmZXJlbnQgZGF0YSB0eXBlXG5cdFx0dGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcblx0fSxcblxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuXHQvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgbGVnZW5kIHR5cGVzLlxuXHQvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBsZWdlbmQgdHlwZVxuXG5cdGJlZm9yZVVwZGF0ZTogbm9vcCQxLFxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcblxuXHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0bWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXHRcdG1lLm1hcmdpbnMgPSBtYXJnaW5zO1xuXG5cdFx0Ly8gRGltZW5zaW9uc1xuXHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cdFx0Ly8gTGFiZWxzXG5cdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcblx0XHRtZS5idWlsZExhYmVscygpO1xuXHRcdG1lLmFmdGVyQnVpbGRMYWJlbHMoKTtcblxuXHRcdC8vIEZpdFxuXHRcdG1lLmJlZm9yZUZpdCgpO1xuXHRcdG1lLmZpdCgpO1xuXHRcdG1lLmFmdGVyRml0KCk7XG5cdFx0Ly9cblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xuXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBub29wJDEsXG5cblx0Ly9cblxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBub29wJDEsXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXG5cdFx0Ly8gUmVzZXQgbWluU2l6ZVxuXHRcdG1lLm1pblNpemUgPSB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMFxuXHRcdH07XG5cdH0sXG5cdGFmdGVyU2V0RGltZW5zaW9uczogbm9vcCQxLFxuXG5cdC8vXG5cblx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AkMSxcblx0YnVpbGRMYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGxhYmVsT3B0cyA9IG1lLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuXHRcdHZhciBsZWdlbmRJdGVtcyA9IGhlbHBlcnMkMS5jYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFttZS5jaGFydF0sIG1lKSB8fCBbXTtcblxuXHRcdGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG5cdFx0XHRsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIG1lLmNoYXJ0LmRhdGEpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1lLm9wdGlvbnMucmV2ZXJzZSkge1xuXHRcdFx0bGVnZW5kSXRlbXMucmV2ZXJzZSgpO1xuXHRcdH1cblxuXHRcdG1lLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG5cdH0sXG5cdGFmdGVyQnVpbGRMYWJlbHM6IG5vb3AkMSxcblxuXHQvL1xuXG5cdGJlZm9yZUZpdDogbm9vcCQxLFxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBsYWJlbE9wdHMgPSBvcHRzLmxhYmVscztcblx0XHR2YXIgZGlzcGxheSA9IG9wdHMuZGlzcGxheTtcblxuXHRcdHZhciBjdHggPSBtZS5jdHg7XG5cblx0XHR2YXIgbGFiZWxGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChsYWJlbE9wdHMpO1xuXHRcdHZhciBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuXG5cdFx0Ly8gUmVzZXQgaGl0IGJveGVzXG5cdFx0dmFyIGhpdGJveGVzID0gbWUubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZTtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gbWUubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBkaXNwbGF5ID8gMTAgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gZGlzcGxheSA/IDEwIDogMDtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0fVxuXG5cdFx0Ly8gSW5jcmVhc2Ugc2l6ZXMgaGVyZVxuXHRcdGlmIChkaXNwbGF5KSB7XG5cdFx0XHRjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0Ly8gTGFiZWxzXG5cblx0XHRcdFx0Ly8gV2lkdGggb2YgZWFjaCBsaW5lIG9mIGxlZ2VuZCBib3hlcy4gTGFiZWxzIHdyYXAgb250byBtdWx0aXBsZSBsaW5lcyB3aGVuIHRoZXJlIGFyZSB0b28gbWFueSB0byBmaXQgb24gb25lXG5cdFx0XHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocyA9IFswXTtcblx0XHRcdFx0dmFyIHRvdGFsSGVpZ2h0ID0gMDtcblxuXHRcdFx0XHRjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuXHRcdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cblx0XHRcdFx0aGVscGVycyQxLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcblx0XHRcdFx0XHR2YXIgYm94V2lkdGggPSBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKTtcblx0XHRcdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cblx0XHRcdFx0XHRpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nID4gbWluU2l6ZS53aWR0aCkge1xuXHRcdFx0XHRcdFx0dG90YWxIZWlnaHQgKz0gZm9udFNpemUgKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHRcdGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2Bcblx0XHRcdFx0XHRoaXRib3hlc1tpXSA9IHtcblx0XHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHR3aWR0aDogd2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGZvbnRTaXplXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRtaW5TaXplLmhlaWdodCArPSB0b3RhbEhlaWdodDtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHZQYWRkaW5nID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdHZhciBjb2x1bW5XaWR0aHMgPSBtZS5jb2x1bW5XaWR0aHMgPSBbXTtcblx0XHRcdFx0dmFyIHRvdGFsV2lkdGggPSBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0dmFyIGN1cnJlbnRDb2xXaWR0aCA9IDA7XG5cdFx0XHRcdHZhciBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcblx0XHRcdFx0dmFyIGl0ZW1IZWlnaHQgPSBmb250U2l6ZSArIHZQYWRkaW5nO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLmxlZ2VuZEl0ZW1zLCBmdW5jdGlvbihsZWdlbmRJdGVtLCBpKSB7XG5cdFx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0dmFyIGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblxuXHRcdFx0XHRcdC8vIElmIHRvbyB0YWxsLCBnbyB0byBuZXcgY29sdW1uXG5cdFx0XHRcdFx0aWYgKGkgPiAwICYmIGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ID4gbWluU2l6ZS5oZWlnaHQgLSB2UGFkZGluZykge1xuXHRcdFx0XHRcdFx0dG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHRcdGNvbHVtbldpZHRocy5wdXNoKGN1cnJlbnRDb2xXaWR0aCk7IC8vIHByZXZpb3VzIGNvbHVtbiB3aWR0aFxuXG5cdFx0XHRcdFx0XHRjdXJyZW50Q29sV2lkdGggPSAwO1xuXHRcdFx0XHRcdFx0Y3VycmVudENvbEhlaWdodCA9IDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gR2V0IG1heCB3aWR0aFxuXHRcdFx0XHRcdGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcblx0XHRcdFx0XHRjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQ7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxuXHRcdFx0XHRcdGhpdGJveGVzW2ldID0ge1xuXHRcdFx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0XHRcdHdpZHRoOiBpdGVtV2lkdGgsXG5cdFx0XHRcdFx0XHRoZWlnaHQ6IGZvbnRTaXplXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGg7XG5cdFx0XHRcdGNvbHVtbldpZHRocy5wdXNoKGN1cnJlbnRDb2xXaWR0aCk7XG5cdFx0XHRcdG1pblNpemUud2lkdGggKz0gdG90YWxXaWR0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGg7XG5cdFx0bWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG5cdH0sXG5cdGFmdGVyRml0OiBub29wJDEsXG5cblx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuXHR9LFxuXG5cdC8vIEFjdHVhbGx5IGRyYXcgdGhlIGxlZ2VuZCBvbiB0aGUgY2FudmFzXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciBsYWJlbE9wdHMgPSBvcHRzLmxhYmVscztcblx0XHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblx0XHR2YXIgZGVmYXVsdENvbG9yID0gZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdENvbG9yO1xuXHRcdHZhciBsaW5lRGVmYXVsdCA9IGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLmxpbmU7XG5cdFx0dmFyIGxlZ2VuZFdpZHRoID0gbWUud2lkdGg7XG5cdFx0dmFyIGxpbmVXaWR0aHMgPSBtZS5saW5lV2lkdGhzO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSkge1xuXHRcdFx0dmFyIGN0eCA9IG1lLmN0eDtcblx0XHRcdHZhciBmb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRkKGxhYmVsT3B0cy5mb250Q29sb3IsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0dmFyIGxhYmVsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobGFiZWxPcHRzKTtcblx0XHRcdHZhciBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuXHRcdFx0dmFyIGN1cnNvcjtcblxuXHRcdFx0Ly8gQ2FudmFzIHNldHVwXG5cdFx0XHRjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDAuNTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGZvbnRDb2xvcjsgLy8gZm9yIHN0cmlrZXRocm91Z2ggZWZmZWN0XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gZm9udENvbG9yOyAvLyByZW5kZXIgaW4gY29ycmVjdCBjb2xvdXJcblx0XHRcdGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuXHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHR2YXIgaGl0Ym94ZXMgPSBtZS5sZWdlbmRIaXRCb3hlcztcblxuXHRcdFx0Ly8gY3VycmVudCBwb3NpdGlvblxuXHRcdFx0dmFyIGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG5cdFx0XHRcdGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCB0aGUgY3R4IGZvciB0aGUgYm94XG5cdFx0XHRcdGN0eC5zYXZlKCk7XG5cblx0XHRcdFx0dmFyIGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lV2lkdGgsIGxpbmVEZWZhdWx0LmJvcmRlcldpZHRoKTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG5cdFx0XHRcdGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmxpbmVDYXAsIGxpbmVEZWZhdWx0LmJvcmRlckNhcFN0eWxlKTtcblx0XHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCBsaW5lRGVmYXVsdC5ib3JkZXJEYXNoT2Zmc2V0KTtcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmxpbmVKb2luLCBsaW5lRGVmYXVsdC5ib3JkZXJKb2luU3R5bGUpO1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG5cblx0XHRcdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRcdC8vIElFIDkgYW5kIDEwIGRvIG5vdCBzdXBwb3J0IGxpbmUgZGFzaFxuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0ubGluZURhc2gsIGxpbmVEZWZhdWx0LmJvcmRlckRhc2gpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcHRzLmxhYmVscyAmJiBvcHRzLmxhYmVscy51c2VQb2ludFN0eWxlKSB7XG5cdFx0XHRcdFx0Ly8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG5cdFx0XHRcdFx0Ly8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuXHRcdFx0XHRcdHZhciByYWRpdXMgPSBib3hXaWR0aCAqIE1hdGguU1FSVDIgLyAyO1xuXHRcdFx0XHRcdHZhciBjZW50ZXJYID0geCArIGJveFdpZHRoIC8gMjtcblx0XHRcdFx0XHR2YXIgY2VudGVyWSA9IHkgKyBmb250U2l6ZSAvIDI7XG5cblx0XHRcdFx0XHQvLyBEcmF3IHBvaW50U3R5bGUgYXMgbGVnZW5kIHN5bWJvbFxuXHRcdFx0XHRcdGhlbHBlcnMkMS5jYW52YXMuZHJhd1BvaW50KGN0eCwgbGVnZW5kSXRlbS5wb2ludFN0eWxlLCByYWRpdXMsIGNlbnRlclgsIGNlbnRlclkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIERyYXcgYm94IGFzIGxlZ2VuZCBzeW1ib2xcblx0XHRcdFx0XHRpZiAobGluZVdpZHRoICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlUmVjdCh4LCB5LCBib3hXaWR0aCwgZm9udFNpemUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoeCwgeSwgYm94V2lkdGgsIGZvbnRTaXplKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSwgdGV4dFdpZHRoKSB7XG5cdFx0XHRcdHZhciBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG5cdFx0XHRcdHZhciB4TGVmdCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgeDtcblx0XHRcdFx0dmFyIHlNaWRkbGUgPSB5ICsgaGFsZkZvbnRTaXplO1xuXG5cdFx0XHRcdGN0eC5maWxsVGV4dChsZWdlbmRJdGVtLnRleHQsIHhMZWZ0LCB5TWlkZGxlKTtcblxuXHRcdFx0XHRpZiAobGVnZW5kSXRlbS5oaWRkZW4pIHtcblx0XHRcdFx0XHQvLyBTdHJpa2V0aHJvdWdoIHRoZSB0ZXh0IGlmIGhpZGRlblxuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gMjtcblx0XHRcdFx0XHRjdHgubW92ZVRvKHhMZWZ0LCB5TWlkZGxlKTtcblx0XHRcdFx0XHRjdHgubGluZVRvKHhMZWZ0ICsgdGV4dFdpZHRoLCB5TWlkZGxlKTtcblx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIEhvcml6b250YWxcblx0XHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0Y3Vyc29yID0ge1xuXHRcdFx0XHRcdHg6IG1lLmxlZnQgKyAoKGxlZ2VuZFdpZHRoIC0gbGluZVdpZHRoc1swXSkgLyAyKSArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdHk6IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdGxpbmU6IDBcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnNvciA9IHtcblx0XHRcdFx0XHR4OiBtZS5sZWZ0ICsgbGFiZWxPcHRzLnBhZGRpbmcsXG5cdFx0XHRcdFx0eTogbWUudG9wICsgbGFiZWxPcHRzLnBhZGRpbmcsXG5cdFx0XHRcdFx0bGluZTogMFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaXRlbUhlaWdodCA9IGZvbnRTaXplICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHR2YXIgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cdFx0XHRcdHZhciB3aWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyB0ZXh0V2lkdGg7XG5cdFx0XHRcdHZhciB4ID0gY3Vyc29yLng7XG5cdFx0XHRcdHZhciB5ID0gY3Vyc29yLnk7XG5cblx0XHRcdFx0Ly8gVXNlIChtZS5sZWZ0ICsgbWUubWluU2l6ZS53aWR0aCkgYW5kIChtZS50b3AgKyBtZS5taW5TaXplLmhlaWdodClcblx0XHRcdFx0Ly8gaW5zdGVhZCBvZiBtZS5yaWdodCBhbmQgbWUuYm90dG9tIGJlY2F1c2UgbWUud2lkdGggYW5kIG1lLmhlaWdodFxuXHRcdFx0XHQvLyBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQgc2luY2UgbWUubWluU2l6ZSB3YXMgY2FsY3VsYXRlZFxuXHRcdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0aWYgKGkgPiAwICYmIHggKyB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nID4gbWUubGVmdCArIG1lLm1pblNpemUud2lkdGgpIHtcblx0XHRcdFx0XHRcdHkgPSBjdXJzb3IueSArPSBpdGVtSGVpZ2h0O1xuXHRcdFx0XHRcdFx0Y3Vyc29yLmxpbmUrKztcblx0XHRcdFx0XHRcdHggPSBjdXJzb3IueCA9IG1lLmxlZnQgKyAoKGxlZ2VuZFdpZHRoIC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pIC8gMikgKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoaSA+IDAgJiYgeSArIGl0ZW1IZWlnaHQgPiBtZS50b3AgKyBtZS5taW5TaXplLmhlaWdodCkge1xuXHRcdFx0XHRcdHggPSBjdXJzb3IueCA9IHggKyBtZS5jb2x1bW5XaWR0aHNbY3Vyc29yLmxpbmVdICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0eSA9IGN1cnNvci55ID0gbWUudG9wICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0Y3Vyc29yLmxpbmUrKztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRyYXdMZWdlbmRCb3goeCwgeSwgbGVnZW5kSXRlbSk7XG5cblx0XHRcdFx0aGl0Ym94ZXNbaV0ubGVmdCA9IHg7XG5cdFx0XHRcdGhpdGJveGVzW2ldLnRvcCA9IHk7XG5cblx0XHRcdFx0Ly8gRmlsbCB0aGUgYWN0dWFsIGxhYmVsXG5cdFx0XHRcdGZpbGxUZXh0KHgsIHksIGxlZ2VuZEl0ZW0sIHRleHRXaWR0aCk7XG5cblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdGN1cnNvci54ICs9IHdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3Vyc29yLnkgKz0gaXRlbUhlaWdodDtcblx0XHRcdFx0fVxuXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0TGVnZW5kSXRlbUF0OiBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaSwgaGl0Qm94LCBsaDtcblxuXHRcdGlmICh4ID49IG1lLmxlZnQgJiYgeCA8PSBtZS5yaWdodCAmJiB5ID49IG1lLnRvcCAmJiB5IDw9IG1lLmJvdHRvbSkge1xuXHRcdFx0Ly8gU2VlIGlmIHdlIGFyZSB0b3VjaGluZyBvbmUgb2YgdGhlIGRhdGFzZXQgYm94ZXNcblx0XHRcdGxoID0gbWUubGVnZW5kSGl0Qm94ZXM7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0aGl0Qm94ID0gbGhbaV07XG5cblx0XHRcdFx0aWYgKHggPj0gaGl0Qm94LmxlZnQgJiYgeCA8PSBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aCAmJiB5ID49IGhpdEJveC50b3AgJiYgeSA8PSBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkge1xuXHRcdFx0XHRcdC8vIFRvdWNoaW5nIGFuIGVsZW1lbnRcblx0XHRcdFx0XHRyZXR1cm4gbWUubGVnZW5kSXRlbXNbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICovXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHR5cGUgPSBlLnR5cGUgPT09ICdtb3VzZXVwJyA/ICdjbGljaycgOiBlLnR5cGU7XG5cdFx0dmFyIGhvdmVyZWRJdGVtO1xuXG5cdFx0aWYgKHR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG5cdFx0XHRpZiAoIW9wdHMub25Ib3ZlciAmJiAhb3B0cy5vbkxlYXZlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdGlmICghb3B0cy5vbkNsaWNrKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENoYXJ0IGV2ZW50IGFscmVhZHkgaGFzIHJlbGF0aXZlIHBvc2l0aW9uIGluIGl0XG5cdFx0aG92ZXJlZEl0ZW0gPSBtZS5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcblxuXHRcdGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAoaG92ZXJlZEl0ZW0gJiYgb3B0cy5vbkNsaWNrKSB7XG5cdFx0XHRcdC8vIHVzZSBlLm5hdGl2ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0b3B0cy5vbkNsaWNrLmNhbGwobWUsIGUubmF0aXZlLCBob3ZlcmVkSXRlbSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChvcHRzLm9uTGVhdmUgJiYgaG92ZXJlZEl0ZW0gIT09IG1lLl9ob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHRpZiAobWUuX2hvdmVyZWRJdGVtKSB7XG5cdFx0XHRcdFx0b3B0cy5vbkxlYXZlLmNhbGwobWUsIGUubmF0aXZlLCBtZS5faG92ZXJlZEl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1lLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0cy5vbkhvdmVyICYmIGhvdmVyZWRJdGVtKSB7XG5cdFx0XHRcdC8vIHVzZSBlLm5hdGl2ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0b3B0cy5vbkhvdmVyLmNhbGwobWUsIGUubmF0aXZlLCBob3ZlcmVkSXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoKGNoYXJ0LCBsZWdlbmRPcHRzKSB7XG5cdHZhciBsZWdlbmQgPSBuZXcgTGVnZW5kKHtcblx0XHRjdHg6IGNoYXJ0LmN0eCxcblx0XHRvcHRpb25zOiBsZWdlbmRPcHRzLFxuXHRcdGNoYXJ0OiBjaGFydFxuXHR9KTtcblxuXHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIGxlZ2VuZE9wdHMpO1xuXHRjb3JlX2xheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuXHRjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG59XG5cbnZhciBwbHVnaW5fbGVnZW5kID0ge1xuXHRpZDogJ2xlZ2VuZCcsXG5cblx0LyoqXG5cdCAqIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHNpbmNlIDIuMS41LCB0aGUgbGVnZW5kIGlzIHJlZ2lzdGVyZWQgYXMgYSBwbHVnaW4sIG1ha2luZ1xuXHQgKiBDaGFydC5MZWdlbmQgb2Jzb2xldGUuIFRvIGF2b2lkIGEgYnJlYWtpbmcgY2hhbmdlLCB3ZSBleHBvcnQgdGhlIExlZ2VuZCBhcyBwYXJ0IG9mXG5cdCAqIHRoZSBwbHVnaW4sIHdoaWNoIG9uZSB3aWxsIGJlIHJlLWV4cG9zZWQgaW4gdGhlIGNoYXJ0LmpzIGZpbGUuXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvMjY0MFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2VsZW1lbnQ6IExlZ2VuZCxcblxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciBsZWdlbmRPcHRzID0gY2hhcnQub3B0aW9ucy5sZWdlbmQ7XG5cblx0XHRpZiAobGVnZW5kT3B0cykge1xuXHRcdFx0Y3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoKGNoYXJ0LCBsZWdlbmRPcHRzKTtcblx0XHR9XG5cdH0sXG5cblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciBsZWdlbmRPcHRzID0gY2hhcnQub3B0aW9ucy5sZWdlbmQ7XG5cdFx0dmFyIGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcblxuXHRcdGlmIChsZWdlbmRPcHRzKSB7XG5cdFx0XHRoZWxwZXJzJDEubWVyZ2VJZihsZWdlbmRPcHRzLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5sZWdlbmQpO1xuXG5cdFx0XHRpZiAobGVnZW5kKSB7XG5cdFx0XHRcdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgbGVnZW5kT3B0cyk7XG5cdFx0XHRcdGxlZ2VuZC5vcHRpb25zID0gbGVnZW5kT3B0cztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChsZWdlbmQpIHtcblx0XHRcdGNvcmVfbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGxlZ2VuZCk7XG5cdFx0XHRkZWxldGUgY2hhcnQubGVnZW5kO1xuXHRcdH1cblx0fSxcblxuXHRhZnRlckV2ZW50OiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdHZhciBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG5cdFx0aWYgKGxlZ2VuZCkge1xuXHRcdFx0bGVnZW5kLmhhbmRsZUV2ZW50KGUpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIG5vb3AkMiA9IGhlbHBlcnMkMS5ub29wO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0dGl0bGU6IHtcblx0XHRkaXNwbGF5OiBmYWxzZSxcblx0XHRmb250U3R5bGU6ICdib2xkJyxcblx0XHRmdWxsV2lkdGg6IHRydWUsXG5cdFx0cGFkZGluZzogMTAsXG5cdFx0cG9zaXRpb246ICd0b3AnLFxuXHRcdHRleHQ6ICcnLFxuXHRcdHdlaWdodDogMjAwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgdG8gYmUgYWJvdmVcblx0fVxufSk7XG5cbi8qKlxuICogSU1QT1JUQU5UOiB0aGlzIGNsYXNzIGlzIGV4cG9zZWQgcHVibGljbHkgYXMgQ2hhcnQuTGVnZW5kLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHJlcXVpcmVkIVxuICovXG52YXIgVGl0bGUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRoZWxwZXJzJDEuZXh0ZW5kKG1lLCBjb25maWcpO1xuXG5cdFx0Ly8gQ29udGFpbnMgaGl0IGJveGVzIGZvciBlYWNoIGRhdGFzZXQgKGluIGRhdGFzZXQgb3JkZXIpXG5cdFx0bWUubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblx0fSxcblxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuXG5cdGJlZm9yZVVwZGF0ZTogbm9vcCQyLFxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gVXBkYXRlIExpZmVjeWNsZSAtIFByb2JhYmx5IGRvbid0IHdhbnQgdG8gZXZlciBleHRlbmQgb3Igb3ZlcndyaXRlIHRoaXMgZnVuY3Rpb24gOylcblx0XHRtZS5iZWZvcmVVcGRhdGUoKTtcblxuXHRcdC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuXHRcdG1lLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0bWUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXHRcdG1lLm1hcmdpbnMgPSBtYXJnaW5zO1xuXG5cdFx0Ly8gRGltZW5zaW9uc1xuXHRcdG1lLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5zZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG5cdFx0Ly8gTGFiZWxzXG5cdFx0bWUuYmVmb3JlQnVpbGRMYWJlbHMoKTtcblx0XHRtZS5idWlsZExhYmVscygpO1xuXHRcdG1lLmFmdGVyQnVpbGRMYWJlbHMoKTtcblxuXHRcdC8vIEZpdFxuXHRcdG1lLmJlZm9yZUZpdCgpO1xuXHRcdG1lLmZpdCgpO1xuXHRcdG1lLmFmdGVyRml0KCk7XG5cdFx0Ly9cblx0XHRtZS5hZnRlclVwZGF0ZSgpO1xuXG5cdFx0cmV0dXJuIG1lLm1pblNpemU7XG5cblx0fSxcblx0YWZ0ZXJVcGRhdGU6IG5vb3AkMixcblxuXHQvL1xuXG5cdGJlZm9yZVNldERpbWVuc2lvbnM6IG5vb3AkMixcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS53aWR0aCA9IG1lLm1heFdpZHRoO1xuXHRcdFx0bWUubGVmdCA9IDA7XG5cdFx0XHRtZS5yaWdodCA9IG1lLndpZHRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUudG9wID0gMDtcblx0XHRcdG1lLmJvdHRvbSA9IG1lLmhlaWdodDtcblx0XHR9XG5cblx0XHQvLyBSZXNldCBwYWRkaW5nXG5cdFx0bWUucGFkZGluZ0xlZnQgPSAwO1xuXHRcdG1lLnBhZGRpbmdUb3AgPSAwO1xuXHRcdG1lLnBhZGRpbmdSaWdodCA9IDA7XG5cdFx0bWUucGFkZGluZ0JvdHRvbSA9IDA7XG5cblx0XHQvLyBSZXNldCBtaW5TaXplXG5cdFx0bWUubWluU2l6ZSA9IHtcblx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fTtcblx0fSxcblx0YWZ0ZXJTZXREaW1lbnNpb25zOiBub29wJDIsXG5cblx0Ly9cblxuXHRiZWZvcmVCdWlsZExhYmVsczogbm9vcCQyLFxuXHRidWlsZExhYmVsczogbm9vcCQyLFxuXHRhZnRlckJ1aWxkTGFiZWxzOiBub29wJDIsXG5cblx0Ly9cblxuXHRiZWZvcmVGaXQ6IG5vb3AkMixcblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgZGlzcGxheSA9IG9wdHMuZGlzcGxheTtcblx0XHR2YXIgbWluU2l6ZSA9IG1lLm1pblNpemU7XG5cdFx0dmFyIGxpbmVDb3VudCA9IGhlbHBlcnMkMS5pc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcblx0XHR2YXIgZm9udE9wdHMgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG9wdHMpO1xuXHRcdHZhciB0ZXh0U2l6ZSA9IGRpc3BsYXkgPyAobGluZUNvdW50ICogZm9udE9wdHMubGluZUhlaWdodCkgKyAob3B0cy5wYWRkaW5nICogMikgOiAwO1xuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gbWUubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSB0ZXh0U2l6ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IHRleHRTaXplO1xuXHRcdFx0bWluU2l6ZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcblx0XHR9XG5cblx0XHRtZS53aWR0aCA9IG1pblNpemUud2lkdGg7XG5cdFx0bWUuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG5cblx0fSxcblx0YWZ0ZXJGaXQ6IG5vb3AkMixcblxuXHQvLyBTaGFyZWQgTWV0aG9kc1xuXHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG5cdFx0cmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcblx0fSxcblxuXHQvLyBBY3R1YWxseSBkcmF3IHRoZSB0aXRsZSBibG9jayBvbiB0aGUgY2FudmFzXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGN0eCA9IG1lLmN0eDtcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cblx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHR2YXIgZm9udE9wdHMgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KG9wdHMpO1xuXHRcdFx0dmFyIGxpbmVIZWlnaHQgPSBmb250T3B0cy5saW5lSGVpZ2h0O1xuXHRcdFx0dmFyIG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgb3B0cy5wYWRkaW5nO1xuXHRcdFx0dmFyIHJvdGF0aW9uID0gMDtcblx0XHRcdHZhciB0b3AgPSBtZS50b3A7XG5cdFx0XHR2YXIgbGVmdCA9IG1lLmxlZnQ7XG5cdFx0XHR2YXIgYm90dG9tID0gbWUuYm90dG9tO1xuXHRcdFx0dmFyIHJpZ2h0ID0gbWUucmlnaHQ7XG5cdFx0XHR2YXIgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0KG9wdHMuZm9udENvbG9yLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRjdHguZm9udCA9IGZvbnRPcHRzLnN0cmluZztcblxuXHRcdFx0Ly8gSG9yaXpvbnRhbFxuXHRcdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdHRpdGxlWCA9IGxlZnQgKyAoKHJpZ2h0IC0gbGVmdCkgLyAyKTsgLy8gbWlkcG9pbnQgb2YgdGhlIHdpZHRoXG5cdFx0XHRcdHRpdGxlWSA9IHRvcCArIG9mZnNldDtcblx0XHRcdFx0bWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aXRsZVggPSBvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyBsZWZ0ICsgb2Zmc2V0IDogcmlnaHQgLSBvZmZzZXQ7XG5cdFx0XHRcdHRpdGxlWSA9IHRvcCArICgoYm90dG9tIC0gdG9wKSAvIDIpO1xuXHRcdFx0XHRtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcblx0XHRcdFx0cm90YXRpb24gPSBNYXRoLlBJICogKG9wdHMucG9zaXRpb24gPT09ICdsZWZ0JyA/IC0wLjUgOiAwLjUpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSh0aXRsZVgsIHRpdGxlWSk7XG5cdFx0XHRjdHgucm90YXRlKHJvdGF0aW9uKTtcblx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXHRcdFx0dmFyIHRleHQgPSBvcHRzLnRleHQ7XG5cdFx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGV4dCkpIHtcblx0XHRcdFx0dmFyIHkgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRjdHguZmlsbFRleHQodGV4dFtpXSwgMCwgeSwgbWF4V2lkdGgpO1xuXHRcdFx0XHRcdHkgKz0gbGluZUhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHQsIDAsIDAsIG1heFdpZHRoKTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpIHtcblx0dmFyIHRpdGxlID0gbmV3IFRpdGxlKHtcblx0XHRjdHg6IGNoYXJ0LmN0eCxcblx0XHRvcHRpb25zOiB0aXRsZU9wdHMsXG5cdFx0Y2hhcnQ6IGNoYXJ0XG5cdH0pO1xuXG5cdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuXHRjb3JlX2xheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG5cdGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cblxudmFyIHBsdWdpbl90aXRsZSA9IHtcblx0aWQ6ICd0aXRsZScsXG5cblx0LyoqXG5cdCAqIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHNpbmNlIDIuMS41LCB0aGUgdGl0bGUgaXMgcmVnaXN0ZXJlZCBhcyBhIHBsdWdpbiwgbWFraW5nXG5cdCAqIENoYXJ0LlRpdGxlIG9ic29sZXRlLiBUbyBhdm9pZCBhIGJyZWFraW5nIGNoYW5nZSwgd2UgZXhwb3J0IHRoZSBUaXRsZSBhcyBwYXJ0IG9mXG5cdCAqIHRoZSBwbHVnaW4sIHdoaWNoIG9uZSB3aWxsIGJlIHJlLWV4cG9zZWQgaW4gdGhlIGNoYXJ0LmpzIGZpbGUuXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvMjY0MFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2VsZW1lbnQ6IFRpdGxlLFxuXG5cdGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHRpdGxlT3B0cyA9IGNoYXJ0Lm9wdGlvbnMudGl0bGU7XG5cblx0XHRpZiAodGl0bGVPcHRzKSB7XG5cdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xuXHRcdH1cblx0fSxcblxuXHRiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIHRpdGxlT3B0cyA9IGNoYXJ0Lm9wdGlvbnMudGl0bGU7XG5cdFx0dmFyIHRpdGxlQmxvY2sgPSBjaGFydC50aXRsZUJsb2NrO1xuXG5cdFx0aWYgKHRpdGxlT3B0cykge1xuXHRcdFx0aGVscGVycyQxLm1lcmdlSWYodGl0bGVPcHRzLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC50aXRsZSk7XG5cblx0XHRcdGlmICh0aXRsZUJsb2NrKSB7XG5cdFx0XHRcdGNvcmVfbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlQmxvY2ssIHRpdGxlT3B0cyk7XG5cdFx0XHRcdHRpdGxlQmxvY2sub3B0aW9ucyA9IHRpdGxlT3B0cztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZU5ld1RpdGxlQmxvY2tBbmRBdHRhY2goY2hhcnQsIHRpdGxlT3B0cyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aXRsZUJsb2NrKSB7XG5cdFx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcblx0XHRcdGRlbGV0ZSBjaGFydC50aXRsZUJsb2NrO1xuXHRcdH1cblx0fVxufTtcblxudmFyIHBsdWdpbnMgPSB7fTtcbnZhciBmaWxsZXIgPSBwbHVnaW5fZmlsbGVyO1xudmFyIGxlZ2VuZCA9IHBsdWdpbl9sZWdlbmQ7XG52YXIgdGl0bGUgPSBwbHVnaW5fdGl0bGU7XG5wbHVnaW5zLmZpbGxlciA9IGZpbGxlcjtcbnBsdWdpbnMubGVnZW5kID0gbGVnZW5kO1xucGx1Z2lucy50aXRsZSA9IHRpdGxlO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnRcbiAqL1xuXG5cbmNvcmVfY29udHJvbGxlci5oZWxwZXJzID0gaGVscGVycyQxO1xuXG4vLyBAdG9kbyBkaXNwYXRjaCB0aGVzZSBoZWxwZXJzIGludG8gYXBwcm9wcmlhdGVkIGhlbHBlcnMvaGVscGVycy4qIGZpbGUgYW5kIHdyaXRlIHVuaXQgdGVzdHMhXG5jb3JlX2hlbHBlcnMoY29yZV9jb250cm9sbGVyKTtcblxuY29yZV9jb250cm9sbGVyLl9hZGFwdGVycyA9IGNvcmVfYWRhcHRlcnM7XG5jb3JlX2NvbnRyb2xsZXIuQW5pbWF0aW9uID0gY29yZV9hbmltYXRpb247XG5jb3JlX2NvbnRyb2xsZXIuYW5pbWF0aW9uU2VydmljZSA9IGNvcmVfYW5pbWF0aW9ucztcbmNvcmVfY29udHJvbGxlci5jb250cm9sbGVycyA9IGNvbnRyb2xsZXJzO1xuY29yZV9jb250cm9sbGVyLkRhdGFzZXRDb250cm9sbGVyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlcjtcbmNvcmVfY29udHJvbGxlci5kZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHM7XG5jb3JlX2NvbnRyb2xsZXIuRWxlbWVudCA9IGNvcmVfZWxlbWVudDtcbmNvcmVfY29udHJvbGxlci5lbGVtZW50cyA9IGVsZW1lbnRzO1xuY29yZV9jb250cm9sbGVyLkludGVyYWN0aW9uID0gY29yZV9pbnRlcmFjdGlvbjtcbmNvcmVfY29udHJvbGxlci5sYXlvdXRzID0gY29yZV9sYXlvdXRzO1xuY29yZV9jb250cm9sbGVyLnBsYXRmb3JtID0gcGxhdGZvcm07XG5jb3JlX2NvbnRyb2xsZXIucGx1Z2lucyA9IGNvcmVfcGx1Z2lucztcbmNvcmVfY29udHJvbGxlci5TY2FsZSA9IGNvcmVfc2NhbGU7XG5jb3JlX2NvbnRyb2xsZXIuc2NhbGVTZXJ2aWNlID0gY29yZV9zY2FsZVNlcnZpY2U7XG5jb3JlX2NvbnRyb2xsZXIuVGlja3MgPSBjb3JlX3RpY2tzO1xuY29yZV9jb250cm9sbGVyLlRvb2x0aXAgPSBjb3JlX3Rvb2x0aXA7XG5cbi8vIFJlZ2lzdGVyIGJ1aWx0LWluIHNjYWxlc1xuXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycy5lYWNoKHNjYWxlcywgZnVuY3Rpb24oc2NhbGUsIHR5cGUpIHtcblx0Y29yZV9jb250cm9sbGVyLnNjYWxlU2VydmljZS5yZWdpc3RlclNjYWxlVHlwZSh0eXBlLCBzY2FsZSwgc2NhbGUuX2RlZmF1bHRzKTtcbn0pO1xuXG4vLyBMb2FkIHRvIHJlZ2lzdGVyIGJ1aWx0LWluIGFkYXB0ZXJzIChhcyBzaWRlIGVmZmVjdHMpXG5cblxuLy8gTG9hZGluZyBidWlsdC1pbiBwbHVnaW5zXG5cbmZvciAodmFyIGsgaW4gcGx1Z2lucykge1xuXHRpZiAocGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuXHRcdGNvcmVfY29udHJvbGxlci5wbHVnaW5zLnJlZ2lzdGVyKHBsdWdpbnNba10pO1xuXHR9XG59XG5cbmNvcmVfY29udHJvbGxlci5wbGF0Zm9ybS5pbml0aWFsaXplKCk7XG5cbnZhciBzcmMgPSBjb3JlX2NvbnRyb2xsZXI7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0d2luZG93LkNoYXJ0ID0gY29yZV9jb250cm9sbGVyO1xufVxuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkNoYXJ0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuQ2hhcnQgPSBjb3JlX2NvbnRyb2xsZXI7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5MZWdlbmRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjVcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5MZWdlbmQgPSBwbHVnaW5zLmxlZ2VuZC5fZWxlbWVudDtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpdGxlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuVGl0bGUgPSBwbHVnaW5zLnRpdGxlLl9lbGVtZW50O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQucGx1Z2lucyBpbnN0ZWFkXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsdWdpblNlcnZpY2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi4xLjVcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5wbHVnaW5TZXJ2aWNlID0gY29yZV9jb250cm9sbGVyLnBsdWdpbnM7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGluaGVyaXRpbmcgZnJvbSBDaGFydC5QbHVnaW5nQmFzZSBoYXMgbm9cbiAqIGVmZmVjdCwgaW5zdGVhZCBzaW1wbHkgY3JlYXRlL3JlZ2lzdGVyIHBsdWdpbnMgdmlhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqIEBpbnRlcmZhY2UgQ2hhcnQuUGx1Z2luQmFzZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLlBsdWdpbkJhc2UgPSBjb3JlX2NvbnRyb2xsZXIuRWxlbWVudC5leHRlbmQoe30pO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuY2FudmFzSGVscGVyc1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLmNhbnZhc0hlbHBlcnMgPSBjb3JlX2NvbnRyb2xsZXIuaGVscGVycy5jYW52YXM7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5sYXlvdXRzIGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmxheW91dFNlcnZpY2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjNcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5sYXlvdXRTZXJ2aWNlID0gY29yZV9jb250cm9sbGVyLmxheW91dHM7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZS5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuTGluZWFyU2NhbGVCYXNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLkxpbmVhclNjYWxlQmFzZSA9IHNjYWxlX2xpbmVhcmJhc2U7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIGluc3RlYWQgd2Ugc2hvdWxkIGNyZWF0ZSBhIG5ldyBDaGFydFxuICogYnkgc2V0dGluZyB0aGUgdHlwZSBpbiB0aGUgY29uZmlnIChgbmV3IENoYXJ0KGlkLCB7dHlwZTogJ3tjaGFydC10eXBlfSd9YCkuXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKi9cbmNvcmVfY29udHJvbGxlci5oZWxwZXJzLmVhY2goXG5cdFtcblx0XHQnQmFyJyxcblx0XHQnQnViYmxlJyxcblx0XHQnRG91Z2hudXQnLFxuXHRcdCdMaW5lJyxcblx0XHQnUG9sYXJBcmVhJyxcblx0XHQnUmFkYXInLFxuXHRcdCdTY2F0dGVyJ1xuXHRdLFxuXHRmdW5jdGlvbihrbGFzcykge1xuXHRcdGNvcmVfY29udHJvbGxlcltrbGFzc10gPSBmdW5jdGlvbihjdHgsIGNmZykge1xuXHRcdFx0cmV0dXJuIG5ldyBjb3JlX2NvbnRyb2xsZXIoY3R4LCBjb3JlX2NvbnRyb2xsZXIuaGVscGVycy5tZXJnZShjZmcgfHwge30sIHtcblx0XHRcdFx0dHlwZToga2xhc3MuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBrbGFzcy5zbGljZSgxKVxuXHRcdFx0fSkpO1xuXHRcdH07XG5cdH1cbik7XG5cbnJldHVybiBzcmM7XG5cbn0pKSk7XG4iLCJpbXBvcnQgQ2hhcnQgZnJvbSAnY2hhcnQuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2hhcnQoY2hhcnRJZCwgY2hhcnRUeXBlKSB7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoY3JlYXRlRWxlbWVudCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgc3R5bGU6IHRoaXMuc3R5bGVzLFxuICAgICAgICBjbGFzczogdGhpcy5jc3NDbGFzc2VzXG4gICAgICB9LCBbY3JlYXRlRWxlbWVudCgnY2FudmFzJywge1xuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIGlkOiB0aGlzLmNoYXJ0SWQsXG4gICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICB9LFxuICAgICAgICByZWY6ICdjYW52YXMnXG4gICAgICB9KV0pO1xuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGNoYXJ0SWQ6IHtcbiAgICAgICAgZGVmYXVsdDogY2hhcnRJZCxcbiAgICAgICAgdHlwZTogU3RyaW5nXG4gICAgICB9LFxuICAgICAgd2lkdGg6IHtcbiAgICAgICAgZGVmYXVsdDogNDAwLFxuICAgICAgICB0eXBlOiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgZGVmYXVsdDogNDAwLFxuICAgICAgICB0eXBlOiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICBjc3NDbGFzc2VzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJydcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0XG4gICAgICB9LFxuICAgICAgcGx1Z2luczoge1xuICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX2NoYXJ0OiBudWxsLFxuICAgICAgICBfcGx1Z2luczogdGhpcy5wbHVnaW5zXG4gICAgICB9O1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgYWRkUGx1Z2luOiBmdW5jdGlvbiBhZGRQbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIHRoaXMuJGRhdGEuX3BsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlTGVnZW5kOiBmdW5jdGlvbiBnZW5lcmF0ZUxlZ2VuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJGRhdGEuX2NoYXJ0LmdlbmVyYXRlTGVnZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW5kZXJDaGFydDogZnVuY3Rpb24gcmVuZGVyQ2hhcnQoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy4kZGF0YS5fY2hhcnQpIHRoaXMuJGRhdGEuX2NoYXJ0LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZGF0YS5fY2hhcnQgPSBuZXcgQ2hhcnQodGhpcy4kcmVmcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSwge1xuICAgICAgICAgIHR5cGU6IGNoYXJ0VHlwZSxcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgcGx1Z2luczogdGhpcy4kZGF0YS5fcGx1Z2luc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy4kZGF0YS5fY2hhcnQpIHtcbiAgICAgICAgdGhpcy4kZGF0YS5fY2hhcnQuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCB2YXIgQmFyID0gZ2VuZXJhdGVDaGFydCgnYmFyLWNoYXJ0JywgJ2JhcicpO1xuZXhwb3J0IHZhciBIb3Jpem9udGFsQmFyID0gZ2VuZXJhdGVDaGFydCgnaG9yaXpvbnRhbGJhci1jaGFydCcsICdob3Jpem9udGFsQmFyJyk7XG5leHBvcnQgdmFyIERvdWdobnV0ID0gZ2VuZXJhdGVDaGFydCgnZG91Z2hudXQtY2hhcnQnLCAnZG91Z2hudXQnKTtcbmV4cG9ydCB2YXIgTGluZSA9IGdlbmVyYXRlQ2hhcnQoJ2xpbmUtY2hhcnQnLCAnbGluZScpO1xuZXhwb3J0IHZhciBQaWUgPSBnZW5lcmF0ZUNoYXJ0KCdwaWUtY2hhcnQnLCAncGllJyk7XG5leHBvcnQgdmFyIFBvbGFyQXJlYSA9IGdlbmVyYXRlQ2hhcnQoJ3BvbGFyLWNoYXJ0JywgJ3BvbGFyQXJlYScpO1xuZXhwb3J0IHZhciBSYWRhciA9IGdlbmVyYXRlQ2hhcnQoJ3JhZGFyLWNoYXJ0JywgJ3JhZGFyJyk7XG5leHBvcnQgdmFyIEJ1YmJsZSA9IGdlbmVyYXRlQ2hhcnQoJ2J1YmJsZS1jaGFydCcsICdidWJibGUnKTtcbmV4cG9ydCB2YXIgU2NhdHRlciA9IGdlbmVyYXRlQ2hhcnQoJ3NjYXR0ZXItY2hhcnQnLCAnc2NhdHRlcicpO1xuZXhwb3J0IGRlZmF1bHQge1xuICBCYXI6IEJhcixcbiAgSG9yaXpvbnRhbEJhcjogSG9yaXpvbnRhbEJhcixcbiAgRG91Z2hudXQ6IERvdWdobnV0LFxuICBMaW5lOiBMaW5lLFxuICBQaWU6IFBpZSxcbiAgUG9sYXJBcmVhOiBQb2xhckFyZWEsXG4gIFJhZGFyOiBSYWRhcixcbiAgQnViYmxlOiBCdWJibGUsXG4gIFNjYXR0ZXI6IFNjYXR0ZXJcbn07IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgQmFyLCBtaXhpbnMgfSBmcm9tICd2dWUtY2hhcnRqcyc7XG4gIGNvbnN0IHsgcmVhY3RpdmVQcm9wIH0gPSBtaXhpbnM7XG5cbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLnBhZGRpbmcgPSAyMDtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmZvbnRTaXplID0gMTY7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5saW5lSGVpZ2h0ID0gMS42O1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBleHRlbmRzOiBCYXIsXG4gICAgbWl4aW5zOiBbcmVhY3RpdmVQcm9wXSxcbiAgICBwcm9wczoge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lVGVuc2lvbjogMSxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMuY2hhcnREYXRhLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0sXG4gIH07XG48L3NjcmlwdD4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNoYXJ0TGFiZWxzID0gWycxOTgwJywgJzE5OTAnLCAnMjAwMCcsICcyMDEwJywgJzIwMjAnXTtcblxuY29uc3QgY2hhcnREYXRhTGlzdCA9IFs2NTQyNTY0LCA3MzIyNTY0LCA4MDA4Mjc4LCA4MTc1MTMzLCA1NDc1MTMzXTtcblxuY29uc3QgQ2hhcnREYXRhID0ge1xuICBkYXRhOiB7XG4gICAgbGFiZWxzOiBjaGFydExhYmVscyxcbiAgICBkYXRhc2V0czogW1xuICAgICAge1xuICAgICAgICBkYXRhOiBjaGFydERhdGFMaXN0LFxuICAgICAgICBmaWxsOiBmYWxzZSwgLy8gdXNlZCBieSBsaW5lIGNoYXJ0XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogW1xuICAgICAgICAgICcjMkYzMzRGJyxcbiAgICAgICAgICAnIzMxNTVBNicsXG4gICAgICAgICAgJyNGMjY5NUQnLFxuICAgICAgICAgICcjRUJCQ0Q4JyxcbiAgICAgICAgICAnI0Y5QTEzNycsXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlckNvbG9yOiBbXG4gICAgICAgICAgJyNBQ0FFQjknXG4gICAgICAgIF0sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9LFxuICAgIF1cbiAgfSxcbiAgYmFyOiB7XG4gICAgb3B0aW9uczoge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgdGV4dDogJ1BvcHVsYXRpb24gQ2hhcnQnLFxuICAgICAgfSxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBsaW5lVGVuc2lvbjogMSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4QXhlczogW3tcbiAgICAgICAgICBzY2FsZUxhYmVsOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgbGFiZWxTdHJpbmc6ICdZZWFycycsXG4gICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgeUF4ZXM6IFt7XG4gICAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnUG9wdWxhdGlvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgcGFkZGluZzogMjUsXG4gICAgICAgICAgfVxuICAgICAgICB9XVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaG9yaXpvbnRhbEJhcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgIHRleHQ6ICdQb3B1bGF0aW9uIENoYXJ0JyxcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeEF4ZXM6IFt7XG4gICAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnUG9wdWxhdGlvbicsXG4gICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgeUF4ZXM6IFt7XG4gICAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnWWVhcnMnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDI1LFxuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBpZToge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgIHRleHQ6ICdQb3B1bGF0aW9uIENoYXJ0JyxcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBsaW5lVGVuc2lvbjogMSxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnREYXRhOyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLWJhci52dWUnOyAvLyBPdXIgY29tcG9uZW50XG5pbXBvcnQgQ2hhcnREYXRhIGZyb20gJy4vY2hhcnQuZGF0YSc7IC8vIE91ciBzYW1wbGUgZGF0YVxuXG5jb25zdCBjaGFydFR5cGUgPSAnYmFyJztcblxuY2xhc3MgQ2hhcnRCYXIge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoYG55Y28tY2hhcnQtJHtjaGFydFR5cGV9YCwgQ2hhcnRDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogYFtkYXRhLWpzPVwiY2hhcnQtJHtjaGFydFR5cGV9XCJdYCxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBDaGFydERhdGEuZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBDaGFydERhdGEuYmFyLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydEJhcjsiLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBIb3Jpem9udGFsQmFyLCBtaXhpbnMgfSBmcm9tICd2dWUtY2hhcnRqcyc7XG4gIGNvbnN0IHsgcmVhY3RpdmVQcm9wIH0gPSBtaXhpbnM7XG5cbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLnBhZGRpbmcgPSAyMDtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmZvbnRTaXplID0gMTY7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5saW5lSGVpZ2h0ID0gMS42O1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBleHRlbmRzOiBIb3Jpem9udGFsQmFyLFxuICAgIG1peGluczogW3JlYWN0aXZlUHJvcF0sXG4gICAgcHJvcHM6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICB9O1xuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7XG5pbXBvcnQgQ2hhcnRDb21wb25lbnQgZnJvbSAnLi9jaGFydC0taG9yaXpvbnRhbC1iYXIudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IENoYXJ0RGF0YSBmcm9tICcuL2NoYXJ0LmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY29uc3QgY2hhcnRUeXBlID0gJ2hvcml6b250YWwtYmFyJztcblxuY2xhc3MgQ2hhcnRIb3Jpem9udGFsQmFyIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KGBueWNvLWNoYXJ0LSR7Y2hhcnRUeXBlfWAsIENoYXJ0Q29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6IGBbZGF0YS1qcz1cImNoYXJ0LSR7Y2hhcnRUeXBlfVwiXWAsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogQ2hhcnREYXRhLmRhdGEsXG4gICAgICAgICAgb3B0aW9uczogQ2hhcnREYXRhLmhvcml6b250YWxCYXIub3B0aW9uc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0SG9yaXpvbnRhbEJhcjsiLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBMaW5lLCBtaXhpbnMgfSBmcm9tICd2dWUtY2hhcnRqcyc7XG4gIGNvbnN0IHsgcmVhY3RpdmVQcm9wIH0gPSBtaXhpbnM7XG5cbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLnBhZGRpbmcgPSAyMDtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmZvbnRTaXplID0gMTY7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5saW5lSGVpZ2h0ID0gMS42O1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBleHRlbmRzOiBMaW5lLFxuICAgIG1peGluczogW3JlYWN0aXZlUHJvcF0sXG4gICAgcHJvcHM6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICB9O1xuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7XG5pbXBvcnQgQ2hhcnRDb21wb25lbnQgZnJvbSAnLi9jaGFydC0tbGluZS52dWUnOyAvLyBPdXIgY29tcG9uZW50XG5pbXBvcnQgQ2hhcnREYXRhIGZyb20gJy4vY2hhcnQuZGF0YSc7IC8vIE91ciBzYW1wbGUgZGF0YVxuXG5jb25zdCBjaGFydFR5cGUgPSAnbGluZSc7XG5cbmNsYXNzIENoYXJ0TGluZSB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudChgbnljby1jaGFydC0ke2NoYXJ0VHlwZX1gLCBDaGFydENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiBgW2RhdGEtanM9XCJjaGFydC0ke2NoYXJ0VHlwZX1cIl1gLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IENoYXJ0RGF0YS5kYXRhLFxuICAgICAgICAgIG9wdGlvbnM6IENoYXJ0RGF0YS5iYXIub3B0aW9uc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0TGluZTsiLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBQaWUsIG1peGlucyB9IGZyb20gJ3Z1ZS1jaGFydGpzJztcbiAgY29uc3QgeyByZWFjdGl2ZVByb3AgfSA9IG1peGlucztcblxuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUucGFkZGluZyA9IDIwO1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUuZm9udFNpemUgPSAxNjtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmxpbmVIZWlnaHQgPSAxLjY7XG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIGV4dGVuZHM6IFBpZSxcbiAgICBtaXhpbnM6IFtyZWFjdGl2ZVByb3BdLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICB9O1xuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7XG5pbXBvcnQgQ2hhcnRDb21wb25lbnQgZnJvbSAnLi9jaGFydC0tcGllLnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBDaGFydERhdGEgZnJvbSAnLi9jaGFydC5kYXRhJzsgLy8gT3VyIHNhbXBsZSBkYXRhXG5cbmNvbnN0IGNoYXJ0VHlwZSA9ICdwaWUnO1xuXG5jbGFzcyBDaGFydFBpZSB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudChgbnljby1jaGFydC0ke2NoYXJ0VHlwZX1gLCBDaGFydENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiBgW2RhdGEtanM9XCJjaGFydC0ke2NoYXJ0VHlwZX1cIl1gLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IENoYXJ0RGF0YS5kYXRhLFxuICAgICAgICAgIG9wdGlvbnM6IENoYXJ0RGF0YS5waWUub3B0aW9uc1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0UGllOyIsIjx0ZW1wbGF0ZT48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IHtcbiAgICAgICdsYXllcnMnOiB7XG4gICAgICAgIHR5cGU6IEFycmF5XG4gICAgICB9LFxuICAgICAgJ2NvbmZpZyc6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWFwOiBudWxsLFxuICAgICAgICBtYXBQb3B1cDogbnVsbCxcbiAgICAgICAgbWFwRmlsdGVyOiBudWxsLFxuICAgICAgICBhY3RpdmVMYXllcjogbnVsbCxcbiAgICAgICAgbWFwTG9hZGVkOiBmYWxzZSxcbiAgICAgICAgbWVudUl0ZW1zOiBbXSxcbiAgICAgICAgc2VsZWN0ZWRJdGVtczogW10sXG4gICAgICB9O1xuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZU1hcCgpO1xuICAgIH0sXG4gICAgZGVzdHJveWVkKCkge1xuICAgICAgdGhpcy5tYXAucmVtb3ZlKCk7XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgJ2xheWVycyc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcFR5cGUgPT09ICdtdWx0aScpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICAgICAgICB0aGlzLnRyYWNrTGF5ZXIobGF5ZXIubmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChsYXllci5kZWZhdWx0IHx8IHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgdGhpcy5hY3RpdmVMYXllciA9IGxheWVyLm5hbWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1hcExvYWRlZClcbiAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbmZpZy5tYXBUeXBlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNbMF07XG5cbiAgICAgICAgICB0aGlzLmFjdGl2ZUxheWVyID0gbGF5ZXIubmFtZTtcbiAgICAgICAgICB0aGlzLmdlbmVyYXRlTGVnZW5kKGxheWVyLmRhdGEpO1xuXG4gICAgICAgICAgaWYgKHRoaXMubWFwTG9hZGVkKVxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplTGF5ZXIobGF5ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVHlwZSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdtYXBMb2FkZWQnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcExvYWRlZCAmJiB0aGlzLmxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBsYXllcnMgPSB0aGlzLmxheWVycztcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVMYXllcihsYXllcnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdtZW51SXRlbXMnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1lbnVJdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVRvZ2dsZSh0aGlzLm1lbnVJdGVtcyk7XG4gICAgICB9LFxuICAgICAgJ3NlbGVjdGVkSXRlbXMnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNbMF07XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IFsnaW4nLCBsYXllci5sZWdlbmRDb2x1bW5dO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZmlsdGVyLnB1c2godGhpcy5zZWxlY3RlZEl0ZW1zW2ldKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IHJlbGF0ZWRGZWF0dXJlcyA9IHRoaXMubWFwLnF1ZXJ5U291cmNlRmVhdHVyZXMobGF5ZXIubmFtZSwge1xuICAgICAgICAgICAgc291cmNlTGF5ZXI6IGxheWVyLm5hbWUsXG4gICAgICAgICAgICBmaWx0ZXI6IGZpbHRlclxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gc2V0IGZpbHRlciB3aGVuIGxlZ2VuZCBpdGVtIHNlbGVjdGVkXG4gICAgICAgICAgdGhpcy5tYXAuc2V0RmlsdGVyKGAke2xheWVyLm5hbWV9LWhpZ2hsaWdodGVkYCwgZmlsdGVyKTtcbiAgICAgICAgICB0aGlzLm1hcC5zZXRMYXlvdXRQcm9wZXJ0eShgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGAsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCAmJiAhdGhpcy5tYXBQb3B1cCkge1xuICAgICAgICAgIHRoaXMubWFwLnNldEZpbHRlcihgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGAsIG51bGwpO1xuICAgICAgICAgIHRoaXMubWFwLnNldExheW91dFByb3BlcnR5KGAke2xheWVyLm5hbWV9LWhpZ2hsaWdodGVkYCwgJ3Zpc2liaWxpdHknLCAnbm9uZScpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgaW5pdGlhbGl6ZU1hcCgpIHtcbiAgICAgICAgY29uc3QgbWFwQ29uZmlnID0gdGhpcy5jb25maWc7XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgY29udGFpbmVyOiBtYXBDb25maWcuY29udGFpbmVySWQsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcENvbmZpZy5jZW50ZXIpXG4gICAgICAgICAgb3B0aW9ucy5jZW50ZXIgPSBtYXBDb25maWcuY2VudGVyO1xuXG4gICAgICAgIGlmIChtYXBDb25maWcuc3R5bGUpXG4gICAgICAgICAgb3B0aW9ucy5zdHlsZSA9IG1hcENvbmZpZy5zdHlsZTtcblxuICAgICAgICBpZiAobWFwQ29uZmlnLnpvb20pXG4gICAgICAgICAgb3B0aW9ucy56b29tID0gbWFwQ29uZmlnLnpvb207XG5cbiAgICAgICAgbWFwYm94Z2wuYWNjZXNzVG9rZW4gPSBtYXBDb25maWcuQVBJS2V5O1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBtYXBib3hnbC5NYXAob3B0aW9ucyk7XG4gICAgICAgIHRoaXMubWFwLmFkZENvbnRyb2wobmV3IG1hcGJveGdsLk5hdmlnYXRpb25Db250cm9sKCkpO1xuXG4gICAgICAgIC8vIGRpc2FibGUgbWFwIHpvb20gd2hlbiB1c2luZyBzY3JvbGxcbiAgICAgICAgaWYgKG1hcENvbmZpZy5kaXNhYmxlU2Nyb2xsKVxuICAgICAgICAgIHRoaXMubWFwLnNjcm9sbFpvb20uZGlzYWJsZSgpO1xuXG4gICAgICAgIHRoaXMubWFwLm9uKCdsb2FkJywgKCkgPT4gdGhpcy5tYXBMb2FkZWQgPSB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwLmdldExheWVyKGxheWVyLm5hbWUpID09PSB1bmRlZmluZWQgJiYgT2JqZWN0LmVudHJpZXMobGF5ZXIuZGF0YSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgdmlzaWJpbGl0eSA9IGxheWVyLm5hbWUgPT09IHRoaXMuYWN0aXZlTGF5ZXIgPyAndmlzaWJsZScgOiAnbm9uZSc7XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0gbGF5ZXIuZmlsdGVyQnkgPyBbJ2luJywgbGF5ZXIuZmlsdGVyQnksICcnXSA6IFtdO1xuICAgICAgICAgIGNvbnN0IGZpbGwgPSB0aGlzLmNvbmZpZy5jb2xvcnMgPyB0aGlzLmdlbmVyYXRlRmlsbENvbG9yKHRoaXMuY29uZmlnLmNvbG9ycykgOiBsYXllci5maWxsO1xuXG4gICAgICAgICAgdGhpcy5tYXAuYWRkU291cmNlKGxheWVyLm5hbWUsIHtcbiAgICAgICAgICAgICd0eXBlJzogJ2dlb2pzb24nLFxuICAgICAgICAgICAgJ2RhdGEnOiBsYXllci5kYXRhXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLm1hcC5hZGRMYXllcih7XG4gICAgICAgICAgICAnaWQnOiBsYXllci5uYW1lLFxuICAgICAgICAgICAgJ3R5cGUnOiAnZmlsbCcsXG4gICAgICAgICAgICAnc291cmNlJzogbGF5ZXIubmFtZSxcbiAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgJ2ZpbGwtb3V0bGluZS1jb2xvcic6IGZpbGxbMF0sXG4gICAgICAgICAgICAgICdmaWxsLWNvbG9yJzogZmlsbFsxXSxcbiAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAuN1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdsYXlvdXQnOiB7XG4gICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogdmlzaWJpbGl0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIoe1xuICAgICAgICAgICAgJ2lkJzogYCR7bGF5ZXIubmFtZX0taGlnaGxpZ2h0ZWRgLFxuICAgICAgICAgICAgJ3R5cGUnOiAnZmlsbCcsXG4gICAgICAgICAgICAnc291cmNlJzogbGF5ZXIubmFtZSxcbiAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgJ2ZpbGwtb3V0bGluZS1jb2xvcic6IGZpbGxbMF0sXG4gICAgICAgICAgICAgICdmaWxsLWNvbG9yJzogZmlsbFsxXSxcbiAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZmlsdGVyJzogZmlsdGVyLFxuICAgICAgICAgICAgJ2xheW91dCc6IHtcbiAgICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiB2aXNpYmlsaXR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVGaWx0ZXIobGF5ZXIpO1xuICAgICAgICAgIHRoaXMudXBkYXRlQ3Vyc29yT25Ib3ZlcihsYXllci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluaXRpYWxpemVQb3B1cChldmVudCwgbGF5ZXIpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWFwVHlwZSA9PT0gJ211bHRpJyA/IHRoaXMucG9wdXBNdWx0aUxheWVyKGV2ZW50LCBsYXllcikgOiB0aGlzLnBvcHVwU2luZ2xlTGF5ZXIoZXZlbnQsIGxheWVyKTtcbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplVG9nZ2xlKHRvZ2dsZUxpc3QpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWFwVHlwZSA9PT0gJ211bHRpJyA/IHRoaXMudG9nZ2xlTXVsdGlMYXllcih0b2dnbGVMaXN0KSA6IHRoaXMudG9nZ2xlU2luZ2xlTGF5ZXIodG9nZ2xlTGlzdCk7XG4gICAgICB9LFxuICAgICAgaW5pdGlhbGl6ZUZpbHRlcihsYXllcikge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXBUeXBlID09PSAnbXVsdGknID8gdGhpcy5maWx0ZXJNdWx0aUxheWVyKGxheWVyKSA6IHRoaXMuZmlsdGVyU2luZ2xlTGF5ZXIobGF5ZXIpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZUN1cnNvck9uSG92ZXIobGF5ZXJJZCkge1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLm1hcDtcblxuICAgICAgICAvLyBjaGFuZ2UgdGhlIGN1cnNvciB0byBhIHBvaW50ZXIgd2hlbiB0aGUgbW91c2UgaXMgb3ZlciB0aGUgbGF5ZXIuXG4gICAgICAgIG1hcC5vbignbW91c2VlbnRlcicsIGxheWVySWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXAuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjaGFuZ2UgdGhlIGN1cnNvciBiYWNrIHRvIHRoZSBkZWZhdWx0IHdoZW4gaXQgbGVhdmVzIHRoZSBsYXllci5cbiAgICAgICAgbWFwLm9uKCdtb3VzZWxlYXZlJywgbGF5ZXJJZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG1hcC5nZXRDYW52YXMoKS5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVGaWxsQ29sb3IoY29sb3JzKSB7XG4gICAgICAgIHJldHVybiBjb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY29sb3JzLmxlbmd0aCldO1xuICAgICAgfSxcbiAgICAgIC8vIG11bHRpIGxheWVyXG4gICAgICB0cmFja0xheWVyKHJlZmVyZW5jZSkge1xuICAgICAgICBpZiAoIXRoaXMubWVudUl0ZW1zLmluY2x1ZGVzKHJlZmVyZW5jZSkpXG4gICAgICAgICAgdGhpcy5tZW51SXRlbXMucHVzaChyZWZlcmVuY2UpO1xuICAgICAgfSxcbiAgICAgIHBvcHVwTXVsdGlMYXllcihldmVudCwgbGF5ZXIpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBtYXAgPSAkdGhpcy5tYXA7XG4gICAgICAgIGNvbnN0IGxheWVyTmFtZSA9IGAke2xheWVyLm5hbWV9LWhpZ2hsaWdodGVkYDtcbiAgICAgICAgY29uc3QgcG9wdXAgPSBuZXcgbWFwYm94Z2wuUG9wdXAoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldExuZ0xhdChldmVudC5sbmdMYXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0SFRNTChldmVudC5mZWF0dXJlc1swXS5wcm9wZXJ0aWVzW2xheWVyLmZpbHRlckJ5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRUbyhtYXApO1xuXG4gICAgICAgIGlmIChwb3B1cC5pc09wZW4oKSkge1xuICAgICAgICAgICR0aGlzLm1hcFBvcHVwID0gcG9wdXA7XG4gICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGxheWVyTmFtZSwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICAgIG1hcC5zZXRGaWx0ZXIobGF5ZXJOYW1lLCAkdGhpcy5tYXBGaWx0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9wdXAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIHJlc2V0IGFzc29jaWF0ZWQgc3RhdGVzIHdoZW4gcG9wdXAgZGlzbWlzc2VkIHdoaWxlIGFjdGl2ZVxuICAgICAgICAgIGlmICgkdGhpcy5tYXBQb3B1cCA9PT0gcG9wdXApIHtcbiAgICAgICAgICAgICR0aGlzLm1hcFBvcHVwID0gbnVsbDtcbiAgICAgICAgICAgICR0aGlzLm1hcEZpbHRlciA9IG51bGw7XG4gICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJOYW1lLCAndmlzaWJpbGl0eScsICdub25lJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmaWx0ZXJNdWx0aUxheWVyKGxheWVyKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuXG4gICAgICAgIG1hcC5vbignY2xpY2snLCBsYXllci5uYW1lLCAoZSkgPT4ge1xuICAgICAgICAgIC8vIHNldCBiYm94IGFzIHJlYWN0YW5nbGUgYXJlYSBhcm91bmQgY2xpY2tlZCBwb2ludFxuICAgICAgICAgIGxldCBiYm94ID0gW1tlLnBvaW50LngsIGUucG9pbnQueV0sIFtlLnBvaW50LngsIGUucG9pbnQueV1dO1xuICAgICAgICAgIGxldCBmZWF0dXJlcyA9IG1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoYmJveCwgeyBsYXllcnM6IFtsYXllci5uYW1lXSB9KTtcblxuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGZlYXR1cmVzLnJlZHVjZShmdW5jdGlvbihtZW1vLCBmZWF0dXJlKSB7XG4gICAgICAgICAgICBtZW1vLnB1c2goZmVhdHVyZS5wcm9wZXJ0aWVzW2xheWVyLmZpbHRlckJ5XSk7XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICB9LCBbJ2luJywgYCR7bGF5ZXIuZmlsdGVyQnl9YF0pO1xuXG4gICAgICAgICAgJHRoaXMubWFwRmlsdGVyID0gZmlsdGVyO1xuICAgICAgICAgICR0aGlzLmluaXRpYWxpemVQb3B1cChlLCBsYXllcik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZU11bHRpTGF5ZXIobGF5ZXJzVG9Ub2dnbGUpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBtYXAgPSAkdGhpcy5tYXA7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUxheWVyID0gJHRoaXMuYWN0aXZlTGF5ZXI7XG4gICAgICAgIGNvbnN0IGxpbmtDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmNvbmZpZy5sZWdlbmRJZCk7XG5cbiAgICAgICAgLy8gY2xlYXIgYWxsIGxpbmtzIGJlZm9yZSBhcHBlbmRpbmcgbmV3IG9uZXMgdG8gcHJldmVudCBkdXBsaWNhdGVzXG4gICAgICAgIHdoaWxlIChsaW5rQ29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBsaW5rQ29udGFpbmVyLnJlbW92ZUNoaWxkKGxpbmtDb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheWVyc1RvVG9nZ2xlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGF5ZXJSZWYgPSBsYXllcnNUb1RvZ2dsZVtpXTtcbiAgICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXG4gICAgICAgICAgbGluay5ocmVmID0gJyMnO1xuICAgICAgICAgIGxpbmsudGV4dENvbnRlbnQgPSBsYXllclJlZjtcblxuICAgICAgICAgIGlmIChsYXllclJlZiA9PT0gYWN0aXZlTGF5ZXIpXG4gICAgICAgICAgICBsaW5rLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuXG4gICAgICAgICAgLy8gb24gY2xpY2sgdXBkYXRlIGxpbmsgc3RhdGUsIGFjdGl2ZSBsYXllciByZWZlcmVuY2UsIGFuZCBsYXllciB2aXNpYmlsaXR5XG4gICAgICAgICAgbGluay5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTGF5ZXIgPSB0aGlzLnRleHRDb250ZW50O1xuICAgICAgICAgICAgY29uc3QgbGlua3MgPSBsaW5rQ29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJyk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhY3RpdmUgcG9wdXBcbiAgICAgICAgICAgIGlmICgkdGhpcy5tYXBQb3B1cClcbiAgICAgICAgICAgICAgJHRoaXMubWFwUG9wdXAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudExpbmsgPSBsaW5rc1tpXTtcbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudExheWVyID0gY3VycmVudExpbmsudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMYXllckhpZ2hsaWdodCA9IGAke2N1cnJlbnRMYXllcn0taGlnaGxpZ2h0ZWRgO1xuICAgICAgICAgICAgICBjb25zdCBsYXllclZpc2liaWxpdHkgPSBtYXAuZ2V0TGF5b3V0UHJvcGVydHkoY3VycmVudExheWVyLCAndmlzaWJpbGl0eScpO1xuXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50TGF5ZXIgPT09IHNlbGVjdGVkTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gaWYgbGF5ZXIgaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIGlmIChsYXllclZpc2liaWxpdHkgPT09ICd2aXNpYmxlJyAmJiBjdXJyZW50TGluay5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IG91ciBjdXJyZW50IGxheWVyIGFzIHRoZSBnbG9iYWwgYWN0aXZlIGxheWVyLFxuICAgICAgICAgICAgICAgIC8vIGFkZCBhY3RpdmUgY2xhc3MgdG8gbGluaywgc2V0IGxheWVyIGFzIHZpc2libGVcbiAgICAgICAgICAgICAgICAkdGhpcy5hY3RpdmVMYXllciA9IGN1cnJlbnRMYXllcjtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluay5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoY3VycmVudExheWVyLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGxpbmtzIGFjdGl2ZSBjbGFzcywgc2V0IGxheWVyIHZpc2liaWxpdHkgdG8gbm9uZSBhbmQgcmVtb3ZlIGZpbHRlcnNcbiAgICAgICAgICAgICAgICBjdXJyZW50TGluay5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkoY3VycmVudExheWVyLCAndmlzaWJpbGl0eScsICdub25lJyk7XG4gICAgICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGN1cnJlbnRMYXllckhpZ2hsaWdodCwgJ3Zpc2liaWxpdHknLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgIG1hcC5zZXRGaWx0ZXIoY3VycmVudExheWVySGlnaGxpZ2h0LCBudWxsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBsaW5rQ29udGFpbmVyLmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gc2luZ2xlIGxheWVyXG4gICAgICBnZW5lcmF0ZUxlZ2VuZChsYXllckRhdGEpIHtcbiAgICAgICAgbGF5ZXJEYXRhLmZlYXR1cmVzLmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gZmVhdHVyZS5wcm9wZXJ0aWVzW3RoaXMubGF5ZXJzWzBdLmxlZ2VuZENvbHVtbl07XG5cbiAgICAgICAgICBpZiAoIXRoaXMubWVudUl0ZW1zLmluY2x1ZGVzKGl0ZW0pICYmIGl0ZW0pXG4gICAgICAgICAgICB0aGlzLm1lbnVJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBwb3B1cFNpbmdsZUxheWVyKGV2ZW50LCBsYXllcikge1xuICAgICAgICBjb25zdCAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1hcCA9ICR0aGlzLm1hcDtcbiAgICAgICAgY29uc3QgbGF5ZXJOYW1lID0gYCR7bGF5ZXIubmFtZX0taGlnaGxpZ2h0ZWRgO1xuXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgc2hhcGUgZmFsbHMgdW5kZXIgY3VycmVudCBsZWdlbmQgc2VsZWN0aW9uXG4gICAgICAgIGxldCBpbkN1cnJlbnRTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBsZXQgY29sdW1uRmlsdGVyID0gZXZlbnQuZmVhdHVyZXNbMF0ucHJvcGVydGllc1tsYXllci5sZWdlbmRDb2x1bW5dO1xuXG4gICAgICAgIGlmICghJHRoaXMuc2VsZWN0ZWRJdGVtcy5pbmNsdWRlcyhjb2x1bW5GaWx0ZXIpKVxuICAgICAgICAgIGluQ3VycmVudFNlbGVjdGlvbiA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHBvcHVwID0gbmV3IG1hcGJveGdsLlBvcHVwKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRMbmdMYXQoZXZlbnQubG5nTGF0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEhUTUwoZXZlbnQuZmVhdHVyZXNbMF0ucHJvcGVydGllc1tsYXllci5maWx0ZXJCeV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkVG8obWFwKTtcblxuICAgICAgICBpZiAocG9wdXAuaXNPcGVuKCkpIHtcbiAgICAgICAgICAkdGhpcy5tYXBQb3B1cCA9IHBvcHVwO1xuXG4gICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGxlZ2VuZCBpdGVtcyBzZWxlY3RlZCwgaGlnaGxpZ2h0IHNlbGVjdGVkIG1hcCBzaGFwZVxuICAgICAgICAgIGlmICghJHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShsYXllck5hbWUsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIG1hcC5zZXRGaWx0ZXIobGF5ZXJOYW1lLCAkdGhpcy5tYXBGaWx0ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBsZWdlbmQgaXRlbXMgc2VsZWN0ZWQgYW5kIHNlbGVjdGVkIG1hcCBzaGFwZSBpc24ndFxuICAgICAgICAgIC8vIHdpdGhpbiBhbnkgb2YgdGhlIHNlbGVjdGVkIGxlZ2VuZCBpdGVtcywgaGlnaGxpZ2h0IHNlbGVjdGVkXG4gICAgICAgICAgLy8gbWFwIHNoYXBlIGFuZCBjbGVhciBsZWdlbmRcbiAgICAgICAgICBpZiAoJHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggPiAwICYmICFpbkN1cnJlbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShsYXllck5hbWUsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIG1hcC5zZXRGaWx0ZXIobGF5ZXJOYW1lLCAkdGhpcy5tYXBGaWx0ZXIpO1xuXG4gICAgICAgICAgICAvLyByZXNldCBhbGwgY2hlY2tlZCBsZWdlbmQgaXRlbXNcbiAgICAgICAgICAgICR0aGlzLnNlbGVjdGVkSXRlbXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckdyb3VwSW5wdXRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5jb25maWcubGVnZW5kSWQpLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0OmNoZWNrZWQnKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJHcm91cElucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBmaWx0ZXJHcm91cElucHV0c1tpXS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9wdXAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIHJlc2V0IGFzc29jaWF0ZWQgc3RhdGVzIHdoZW4gcG9wdXAgZGlzbWlzc2VkIHdoaWxlIGFjdGl2ZVxuICAgICAgICAgIGlmICgkdGhpcy5tYXBQb3B1cCA9PT0gcG9wdXApIHtcbiAgICAgICAgICAgICR0aGlzLm1hcFBvcHVwID0gbnVsbDtcbiAgICAgICAgICAgICR0aGlzLm1hcEZpbHRlciA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBsZWdlbmQgaXRlbXMgc2VsZWN0ZWQsIHJlc2V0IGFsbCBmaWx0ZXJzXG4gICAgICAgICAgICBpZiAoISR0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hcC5zZXRGaWx0ZXIobGF5ZXJOYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGxheWVyTmFtZSwgJ3Zpc2liaWxpdHknLCAnbm9uZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZmlsdGVyU2luZ2xlTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBtYXAgPSAkdGhpcy5tYXA7XG5cbiAgICAgICAgbWFwLm9uKCdjbGljaycsIGxheWVyLm5hbWUsIChlKSA9PiB7XG4gICAgICAgICAgLy8gc2V0IGJib3ggYXMgcmVhY3RhbmdsZSBhcmVhIGFyb3VuZCBjbGlja2VkIHBvaW50XG4gICAgICAgICAgbGV0IGJib3ggPSBbW2UucG9pbnQueCwgZS5wb2ludC55XSwgW2UucG9pbnQueCwgZS5wb2ludC55XV07XG4gICAgICAgICAgbGV0IGZlYXR1cmVzID0gbWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhiYm94LCB7IGxheWVyczogW2xheWVyLm5hbWVdIH0pO1xuICAgICAgICAgIGxldCBsZWdlbmRDb2x1bW5WYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBmZWF0dXJlcy5yZWR1Y2UoZnVuY3Rpb24obWVtbywgZmVhdHVyZSkge1xuICAgICAgICAgICAgbGVnZW5kQ29sdW1uVmFsdWUgPSBmZWF0dXJlLnByb3BlcnRpZXNbbGF5ZXIubGVnZW5kQ29sdW1uXTtcbiAgICAgICAgICAgIG1lbW8ucHVzaChmZWF0dXJlLnByb3BlcnRpZXNbbGF5ZXIuZmlsdGVyQnldKTtcbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICAgIH0sIFsnaW4nLCBgJHtsYXllci5maWx0ZXJCeX1gXSk7XG5cbiAgICAgICAgICAkdGhpcy5tYXBGaWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgICAgJHRoaXMuaW5pdGlhbGl6ZVBvcHVwKGUsIGxheWVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlU2luZ2xlTGF5ZXIoZmlsdGVyc1RvVG9nZ2xlKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuICAgICAgICBjb25zdCBmaWx0ZXJHcm91cCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29uZmlnLmxlZ2VuZElkKTtcblxuICAgICAgICBjb25zdCBsYXllciA9ICR0aGlzLmxheWVyc1swXTtcbiAgICAgICAgY29uc3QgbGVnZW5kQ29sdW1uID0gbGF5ZXIubGVnZW5kQ29sdW1uO1xuXG4gICAgICAgIC8vIGNsZWFyIGFsbCBsaW5rcyBiZWZvcmUgYXBwZW5kaW5nIG5ldyBvbmVzIHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICB3aGlsZSAoZmlsdGVyR3JvdXAuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGZpbHRlckdyb3VwLnJlbW92ZUNoaWxkKGZpbHRlckdyb3VwLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5pdGlsaXplIGFuIGlucHV0IGVsZW1lbnQgZm9yIGVhY2ggZmlsdGVyIHR5cGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJzVG9Ub2dnbGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsYXllclJlZiA9IGZpbHRlcnNUb1RvZ2dsZVtpXTtcblxuICAgICAgICAgIC8vIGNoZWNrYm94XG4gICAgICAgICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgIGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICAgIGlucHV0LmlkID0gbGF5ZXJSZWY7XG4gICAgICAgICAgaW5wdXQudmFsdWUgPSBsYXllclJlZjtcbiAgICAgICAgICBmaWx0ZXJHcm91cC5hcHBlbmRDaGlsZChpbnB1dCk7XG5cbiAgICAgICAgICAvLyBjaGVja2JveCBsYWJlbFxuICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIGxheWVyUmVmKTtcbiAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgbGF5ZXJSZWYpO1xuICAgICAgICAgIGxhYmVsLnRleHRDb250ZW50ID0gbGF5ZXJSZWY7XG4gICAgICAgICAgZmlsdGVyR3JvdXAuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXG4gICAgICAgICAgLy8gd2hlbiB0aGUgY2hlY2tib3ggY2hhbmdlcyBzdGF0ZSwgdXBkYXRlIHRoZSBzZWxlY3RlZCBpdGVtcyBhcnJheS5cbiAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZS50YXJnZXQudmFsdWU7XG5cbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBjaGVja2JveGVzIGNoZWNrZWQgc3RhdGVcbiAgICAgICAgICAgIGUudGFyZ2V0LmNoZWNrZWQgPyAndmlzaWJsZScgOiAnbm9uZSc7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBwb3B1cCBpZiBvbmUgZXhpc3RzXG4gICAgICAgICAgICBpZiAoJHRoaXMubWFwUG9wdXApXG4gICAgICAgICAgICAgICR0aGlzLm1hcFBvcHVwLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuY2hlY2tlZCAmJiAhJHRoaXMuc2VsZWN0ZWRJdGVtcy5pbmNsdWRlcyhpdGVtKSlcbiAgICAgICAgICAgICAgJHRoaXMuc2VsZWN0ZWRJdGVtcy5wdXNoKGl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoIWUudGFyZ2V0LmNoZWNrZWQgJiYgJHRoaXMuc2VsZWN0ZWRJdGVtcy5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAkdGhpcy5zZWxlY3RlZEl0ZW1zID0gJHRoaXMuc2VsZWN0ZWRJdGVtcy5maWx0ZXIoKHZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwgIT09IGl0ZW07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuPC9zY3JpcHQ+IiwiLyoqXG4gKiBDb25maWdcbiAqL1xuXG5jb25zdCBueWNvQ29sb3JzID0ge1xuICBjb2xvcnM6IHtcbiAgICAncHJpbWFyeS1uYXZ5JzogJyMyRjMzNEYnLFxuICAgICdwcmltYXJ5LW5hdnktNzB0JzogJyM2RTcwODUnLFxuICAgICdwcmltYXJ5LW5hdnktNTB0JzogJyM5Njk4QTcnLFxuICAgICdwcmltYXJ5LW5hdnktMzB0JzogJyNDMEMyQ0EnLFxuICAgICdwcmltYXJ5LWJsdWUnOiAnIzMxNTVBNicsXG4gICAgJ3ByaW1hcnktYmx1ZS03MHQnOiAnIzZDODhDMScsXG4gICAgJ3ByaW1hcnktYmx1ZS01MHQnOiAnIzk2QUJEMicsXG4gICAgJ3ByaW1hcnktYmx1ZS0zMHQnOiAnI0MwQ0NFMycsXG4gICAgJ3ByaW1hcnktcmVkJzogJyNGMjY5NUQnLFxuICAgICdwcmltYXJ5LXJlZC03MHQnOiAnI0Y2OTU4RCcsXG4gICAgJ3ByaW1hcnktcmVkLTUwdCc6ICcjRjhCMkFEJyxcbiAgICAncHJpbWFyeS1yZWQtMzB0JzogJyNGQkQxQ0UnLFxuICAgICdzZWNvbmRhcnktZ3JleSc6ICcjQUNBRUI5JyxcbiAgICAnc2Vjb25kYXJ5LWdyZXktNzB0JzogJyNDNEM2Q0QnLFxuICAgICdzZWNvbmRhcnktZ3JleS01MHQnOiAnI0Q1RDZEQycsXG4gICAgJ3NlY29uZGFyeS1ncmV5LTMwdCc6ICcjRThFN0U5JyxcbiAgICAnc2Vjb25kYXJ5LXdoaXRlJzogJyNGM0YzRjMnLFxuICAgICdzZWNvbmRhcnktd2hpdGUtNzB0JzogJyNGNkY2RjYnLFxuICAgICdzZWNvbmRhcnktd2hpdGUtNTB0JzogJyNGOUY5RkEnLFxuICAgICdzZWNvbmRhcnktd2hpdGUtMzB0JzogJyNGQkZDRkMnLFxuICAgICdzZWNvbmRhcnktb3JhbmdlJzogJyNGOUExMzcnLFxuICAgICdzZWNvbmRhcnktb3JhbmdlLTcwdCc6ICcjRkZBMTMzJyxcbiAgICAnc2Vjb25kYXJ5LW9yYW5nZS01MHQnOiAnI0ZFRDA5QScsXG4gICAgJ3NlY29uZGFyeS1vcmFuZ2UtMzB0JzogJyNGRkUzQzInLFxuICAgICdzZWNvbmRhcnktcGluayc6ICcjRUJCQ0Q4JyxcbiAgICAnc2Vjb25kYXJ5LXBpbmstNzB0JzogJyNGMkQwRTMnLFxuICAgICdzZWNvbmRhcnktcGluay01MHQnOiAnI0Y3RERFQicsXG4gICAgJ3NlY29uZGFyeS1waW5rLTMwdCc6ICcjRkRFQkYzJyxcbiAgICAnYmFzZS1ibGFjayc6ICcjMDAwMDAwJyxcbiAgICAnYmFzZS13aGl0ZSc6ICcjRkZGRkZGJ1xuICB9LFxuICBjb2xvckNvbWJpbmF0aW9uczoge1xuICAgICdsaWdodC1iYWNrZ3JvdW5kJzoge1xuICAgICAgJ2NvbG9yJzogJ2Jhc2UtYmxhY2snLFxuICAgICAgJ2hlYWRpbmdzJzogJ3ByaW1hcnktbmF2eScsXG4gICAgICAnaHlwZXJsaW5rcyc6ICdwcmltYXJ5LWJsdWUnLFxuICAgICAgJ3Zpc2l0ZWQnOiAncHJpbWFyeS1ibHVlJyxcbiAgICAgICdob3Zlcic6ICdwcmltYXJ5LW5hdnknLFxuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnYmFzZS13aGl0ZScsXG4gICAgICAnYm9yZGVyJzogJ3NlY29uZGFyeS1ncmV5JyxcbiAgICAgICdwbGFjZWhvbGRlcic6ICdzZWNvbmRhcnktZ3JleScsXG4gICAgICAnY2hlY2tib3gtYmFja2dyb3VuZCc6ICdwcmltYXJ5LW5hdnknLFxuICAgICAgJ2Vycm9yJzogJ3ByaW1hcnktcmVkJyxcbiAgICB9LFxuICAgICdtaWQtYmFja2dyb3VuZCc6IHtcbiAgICAgICdjb2xvcic6ICdiYXNlLWJsYWNrJyxcbiAgICAgICdoZWFkaW5ncyc6ICdwcmltYXJ5LW5hdnknLFxuICAgICAgJ2h5cGVybGlua3MnOiAncHJpbWFyeS1ibHVlJyxcbiAgICAgICd2aXNpdGVkJzogJ3ByaW1hcnktYmx1ZScsXG4gICAgICAnaG92ZXInOiAncHJpbWFyeS1uYXZ5JyxcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJ3NlY29uZGFyeS13aGl0ZSdcbiAgICB9LFxuICAgICdkYXJrLWJhY2tncm91bmQnOiB7XG4gICAgICAnY29sb3InOiAnYmFzZS13aGl0ZScsXG4gICAgICAnZm9udC1zbW9vdGgnOiB0cnVlLFxuICAgICAgJ2hlYWRpbmdzJzogJ2Jhc2Utd2hpdGUnLFxuICAgICAgJ2h5cGVybGlua3MnOiAnYmFzZS13aGl0ZScsXG4gICAgICAndmlzaXRlZCc6ICdiYXNlLXdoaXRlJyxcbiAgICAgICdob3Zlcic6ICdiYXNlLXdoaXRlJyxcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJ3ByaW1hcnktbmF2eSdcbiAgICB9LFxuICAgICdwcmltYXJ5LWJ1dHRvbic6IHtcbiAgICAgICdmb250LXdlaWdodCc6ICdib2xkJyxcbiAgICAgICdjb2xvcic6ICdiYXNlLXdoaXRlJyxcbiAgICAgICdmb250LXNtb290aCc6IHRydWUsXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICdwcmltYXJ5LWJsdWUnXG4gICAgfSxcbiAgICAnc2Vjb25kYXJ5LWJ1dHRvbic6IHtcbiAgICAgICdmb250LXdlaWdodCc6ICdib2xkJyxcbiAgICAgICdjb2xvcic6ICdiYXNlLXdoaXRlJyxcbiAgICAgICdmb250LXNtb290aCc6IHRydWUsXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICdwcmltYXJ5LXJlZCdcbiAgICB9XG4gIH0sXG59O1xuXG5jb25zdCBjb2xvciA9IG55Y29Db2xvcnMuY29sb3JzO1xuY29uc3QgbWFwQ29sb3JDb21iaW5hdGlvbnMgPSBbXG4gIFtjb2xvclsncHJpbWFyeS1uYXZ5J10sIGNvbG9yWydwcmltYXJ5LW5hdnktNzB0J11dLFxuICBbY29sb3JbJ2Jhc2UtYmxhY2snXSwgY29sb3JbJ3NlY29uZGFyeS1vcmFuZ2UnXV0sXG4gIFtjb2xvclsncHJpbWFyeS1uYXZ5J10sIGNvbG9yWydzZWNvbmRhcnktZ3JleSddXSxcbiAgW2NvbG9yWydwcmltYXJ5LWJsdWUnXSwgY29sb3JbJ3NlY29uZGFyeS1vcmFuZ2UnXV0sXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbnljb0NvbG9ycyxcbiAgbWFwQ29sb3JDb21iaW5hdGlvbnNcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBtYXBDb2xvckNvbWJpbmF0aW9ucyB9IGZyb20gJy4uLy4uL2NvbmZpZy9jb2xvcnMnO1xuXG5jb25zdCBNYXBEYXRhID0ge1xuICBzaW5nbGU6IHtcbiAgICBsYXllcnM6IFtdLFxuICAgIGNvbmZpZzoge1xuICAgICAgQVBJS2V5OiAncGsuZXlKMUlqb2libmxqYnkxd2NtOWtkV04wY3lJc0ltRWlPaUpqYW5aalozWTRiMkl4TlhZd00zbDBaRE42YldONGFqQTVJbjAuWFN0LWhvejVwM2oyc2l5bGkwZzBvZycsXG4gICAgICBjb250YWluZXJJZDogJ255Y28tbWFwLXNsJyxcbiAgICAgIGxlZ2VuZElkOiAnbnljby1tYXAtbGVnZW5kJyxcbiAgICAgIGNlbnRlcjogWy03My45ODY3MTAsIDQwLjY5MzM5MV0sXG4gICAgICB6b29tOiA5LFxuICAgICAgZGlzYWJsZVNjcm9sbDogdHJ1ZSxcbiAgICAgIHN0eWxlOiAnbWFwYm94Oi8vc3R5bGVzL255Y28tcHJvZHVjdHMvY2p2NndqcTg4MTJ5czFncDM5bW52dWsydycsXG4gICAgICBtYXBUeXBlOiAnc2luZ2xlJ1xuICAgIH1cbiAgfSxcbiAgbXVsdGk6IHtcbiAgICBsYXllcnM6IFtdLFxuICAgIGNvbmZpZzoge1xuICAgICAgQVBJS2V5OiAncGsuZXlKMUlqb2libmxqYnkxd2NtOWtkV04wY3lJc0ltRWlPaUpqYW5aalozWTRiMkl4TlhZd00zbDBaRE42YldONGFqQTVJbjAuWFN0LWhvejVwM2oyc2l5bGkwZzBvZycsXG4gICAgICBjb250YWluZXJJZDogJ255Y28tbWFwLW1sJyxcbiAgICAgIGxlZ2VuZElkOiAnbnljby1tYXAtbWVudScsXG4gICAgICBjZW50ZXI6IFstNzMuOTg2NzEwLCA0MC42OTMzOTFdLFxuICAgICAgem9vbTogOSxcbiAgICAgIGRpc2FibGVTY3JvbGw6IHRydWUsXG4gICAgICBzdHlsZTogJ21hcGJveDovL3N0eWxlcy9ueWNvLXByb2R1Y3RzL2NqdjZ3anE4ODEyeXMxZ3AzOW1udnVrMncnLFxuICAgICAgbWFwVHlwZTogJ211bHRpJyxcbiAgICAgIGNvbG9yczogbWFwQ29sb3JDb21iaW5hdGlvbnNcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWFwRGF0YTsiLCIoZnVuY3Rpb24oR2VvSlNPTikge1xuICBHZW9KU09OLnZlcnNpb24gPSAnMC41LjAnO1xuXG4gIC8vIEFsbG93IHVzZXIgdG8gc3BlY2lmeSBkZWZhdWx0IHBhcmFtZXRlcnNcbiAgR2VvSlNPTi5kZWZhdWx0cyA9IHtcbiAgICBkb1Rocm93czoge1xuICAgICAgaW52YWxpZEdlb21ldHJ5OiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBJbnZhbGlkR2VvbWV0cnlFcnJvcigpIHtcbiAgICB2YXIgYXJncyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgIHZhciBpdGVtID0gYXJncy5zaGlmdCgpO1xuICAgIHZhciBwYXJhbXMgPSBhcmdzLnNoaWZ0KCk7XG5cbiAgICBFcnJvci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2UgfHwgXCJJbnZhbGlkIEdlb21ldHJ5OiBcIiArICdpdGVtOiAnICsgSlNPTi5zdHJpbmdpZnkoaXRlbSkgKyAnLCBwYXJhbXM6ICcgKyBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuICB9XG5cbiAgSW52YWxpZEdlb21ldHJ5RXJyb3IucHJvdG90eXBlID0gRXJyb3I7XG5cblxuICBHZW9KU09OLmVycm9ycyA9IHtcbiAgICBJbnZhbGlkR2VvbWV0cnlFcnJvcjogSW52YWxpZEdlb21ldHJ5RXJyb3JcbiAgfTtcblxuICAvL2V4cG9zaW5nIHNvIHRoaXMgY2FuIGJlIG92ZXJyaWRlbiBtYXliZSBieSBnZW9qc29uLXZhbGlkYXRpb24gb3IgdGhlIGxpa2VcbiAgR2VvSlNPTi5pc0dlb21ldHJ5VmFsaWQgPSBmdW5jdGlvbihnZW9tZXRyeSl7XG4gICAgaWYoIWdlb21ldHJ5IHx8ICFPYmplY3Qua2V5cyhnZW9tZXRyeSkubGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuICEhZ2VvbWV0cnkudHlwZSAmJiAhIWdlb21ldHJ5LmNvb3JkaW5hdGVzICYmIEFycmF5LmlzQXJyYXkoZ2VvbWV0cnkuY29vcmRpbmF0ZXMpICYmICEhZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFRoZSBvbmUgYW5kIG9ubHkgcHVibGljIGZ1bmN0aW9uLlxuICAvLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBHZW9KU09OIGZlYXR1cmUgY29sbGVjdGlvblxuICBHZW9KU09OLnBhcnNlID0gZnVuY3Rpb24ob2JqZWN0cywgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgIHZhciBnZW9qc29uLFxuICAgICAgICBzZXR0aW5ncyA9IGFwcGx5RGVmYXVsdHMocGFyYW1zLCB0aGlzLmRlZmF1bHRzKSxcbiAgICAgICAgcHJvcEZ1bmM7XG5cbiAgICBnZW9tQXR0cnMubGVuZ3RoID0gMDsgLy8gUmVzZXQgdGhlIGxpc3Qgb2YgZ2VvbWV0cnkgZmllbGRzXG4gICAgc2V0R2VvbShzZXR0aW5ncyk7XG4gICAgcHJvcEZ1bmMgPSBnZXRQcm9wRnVuY3Rpb24oc2V0dGluZ3MpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0cykpIHtcbiAgICAgIGdlb2pzb24gPSB7XCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIiwgXCJmZWF0dXJlc1wiOiBbXX07XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XG4gICAgICAgIGdlb2pzb24uZmVhdHVyZXMucHVzaChnZXRGZWF0dXJlKHtpdGVtOml0ZW0sIHBhcmFtczogc2V0dGluZ3MsIHByb3BGdW5jOnByb3BGdW5jfSkpO1xuICAgICAgfSk7XG4gICAgICBhZGRPcHRpb25hbHMoZ2VvanNvbiwgc2V0dGluZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW9qc29uID0gZ2V0RmVhdHVyZSh7aXRlbTpvYmplY3RzLCBwYXJhbXM6IHNldHRpbmdzLCBwcm9wRnVuYzpwcm9wRnVuY30pO1xuICAgICAgYWRkT3B0aW9uYWxzKGdlb2pzb24sIHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayhnZW9qc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdlb2pzb247XG4gICAgfVxuICB9O1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbnNcbiAgdmFyIGdlb21zID0gWydQb2ludCcsICdNdWx0aVBvaW50JywgJ0xpbmVTdHJpbmcnLCAnTXVsdGlMaW5lU3RyaW5nJywgJ1BvbHlnb24nLCAnTXVsdGlQb2x5Z29uJywgJ0dlb0pTT04nXSxcbiAgICAgIGdlb21BdHRycyA9IFtdO1xuXG4gIC8vIEFkZHMgZGVmYXVsdCBzZXR0aW5ncyB0byB1c2VyLXNwZWNpZmllZCBwYXJhbXNcbiAgLy8gRG9lcyBub3Qgb3ZlcndyaXRlIGFueSBzZXR0aW5ncy0tb25seSBhZGRzIGRlZmF1bHRzXG4gIC8vIHRoZSB0aGUgdXNlciBkaWQgbm90IHNwZWNpZnlcbiAgZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhwYXJhbXMsIGRlZmF1bHRzKSB7XG4gICAgdmFyIHNldHRpbmdzID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgZm9yKHZhciBzZXR0aW5nIGluIGRlZmF1bHRzKSB7XG4gICAgICBpZihkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShzZXR0aW5nKSAmJiAhc2V0dGluZ3Nbc2V0dGluZ10pIHtcbiAgICAgICAgc2V0dGluZ3Nbc2V0dGluZ10gPSBkZWZhdWx0c1tzZXR0aW5nXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG4gIH1cblxuICAvLyBBZGRzIHRoZSBvcHRpb25hbCBHZW9KU09OIHByb3BlcnRpZXMgY3JzIGFuZCBiYm94XG4gIC8vIGlmIHRoZXkgaGF2ZSBiZWVuIHNwZWNpZmllZFxuICBmdW5jdGlvbiBhZGRPcHRpb25hbHMoZ2VvanNvbiwgc2V0dGluZ3Mpe1xuICAgIGlmKHNldHRpbmdzLmNycyAmJiBjaGVja0NSUyhzZXR0aW5ncy5jcnMpKSB7XG4gICAgICBpZihzZXR0aW5ncy5pc1Bvc3RncmVzKVxuICAgICAgICBnZW9qc29uLmdlb21ldHJ5LmNycyA9IHNldHRpbmdzLmNycztcbiAgICAgIGVsc2VcbiAgICAgICAgZ2VvanNvbi5jcnMgPSBzZXR0aW5ncy5jcnM7XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5iYm94KSB7XG4gICAgICBnZW9qc29uLmJib3ggPSBzZXR0aW5ncy5iYm94O1xuICAgIH1cbiAgICBpZiAoc2V0dGluZ3MuZXh0cmFHbG9iYWwpIHtcbiAgICAgIGdlb2pzb24ucHJvcGVydGllcyA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHNldHRpbmdzLmV4dHJhR2xvYmFsKSB7XG4gICAgICAgIGdlb2pzb24ucHJvcGVydGllc1trZXldID0gc2V0dGluZ3MuZXh0cmFHbG9iYWxba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB0aGUgc3RydWN0dXJlIG9mIENSUyBvYmplY3QgaXMgdmFsaWRcbiAgZnVuY3Rpb24gY2hlY2tDUlMoY3JzKSB7XG4gICAgaWYgKGNycy50eXBlID09PSAnbmFtZScpIHtcbiAgICAgICAgaWYgKGNycy5wcm9wZXJ0aWVzICYmIGNycy5wcm9wZXJ0aWVzLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENSUy4gUHJvcGVydGllcyBtdXN0IGNvbnRhaW4gXCJuYW1lXCIga2V5Jyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNycy50eXBlID09PSAnbGluaycpIHtcbiAgICAgICAgaWYgKGNycy5wcm9wZXJ0aWVzICYmIGNycy5wcm9wZXJ0aWVzLmhyZWYgJiYgY3JzLnByb3BlcnRpZXMudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ1JTLiBQcm9wZXJ0aWVzIG11c3QgY29udGFpbiBcImhyZWZcIiBhbmQgXCJ0eXBlXCIga2V5Jyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsZCBDUlMuIFR5cGUgYXR0cmlidXRlIG11c3QgYmUgXCJuYW1lXCIgb3IgXCJsaW5rXCInKTtcbiAgICB9XG4gIH1cblxuICAvLyBNb3ZlcyB0aGUgdXNlci1zcGVjaWZpZWQgZ2VvbWV0cnkgcGFyYW1ldGVyc1xuICAvLyB1bmRlciB0aGUgYGdlb21gIGtleSBpbiBwYXJhbSBmb3IgZWFzaWVyIGFjY2Vzc1xuICBmdW5jdGlvbiBzZXRHZW9tKHBhcmFtcykge1xuICAgIHBhcmFtcy5nZW9tID0ge307XG5cbiAgICBmb3IodmFyIHBhcmFtIGluIHBhcmFtcykge1xuICAgICAgaWYocGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtKSAmJiBnZW9tcy5pbmRleE9mKHBhcmFtKSAhPT0gLTEpe1xuICAgICAgICBwYXJhbXMuZ2VvbVtwYXJhbV0gPSBwYXJhbXNbcGFyYW1dO1xuICAgICAgICBkZWxldGUgcGFyYW1zW3BhcmFtXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRHZW9tQXR0ckxpc3QocGFyYW1zLmdlb20pO1xuICB9XG5cbiAgLy8gQWRkcyBmaWVsZHMgd2hpY2ggY29udGFpbiBnZW9tZXRyeSBkYXRhXG4gIC8vIHRvIGdlb21BdHRycy4gVGhpcyBsaXN0IGlzIHVzZWQgd2hlbiBhZGRpbmdcbiAgLy8gcHJvcGVydGllcyB0byB0aGUgZmVhdHVyZXMgc28gdGhhdCBubyBnZW9tZXRyeVxuICAvLyBmaWVsZHMgYXJlIGFkZGVkIHRoZSBwcm9wZXJ0aWVzIGtleVxuICBmdW5jdGlvbiBzZXRHZW9tQXR0ckxpc3QocGFyYW1zKSB7XG4gICAgZm9yKHZhciBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICAgIGlmKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbSkpIHtcbiAgICAgICAgaWYodHlwZW9mIHBhcmFtc1twYXJhbV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZ2VvbUF0dHJzLnB1c2gocGFyYW1zW3BhcmFtXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtc1twYXJhbV0gPT09ICdvYmplY3QnKSB7IC8vIEFycmF5IG9mIGNvb3JkaW5hdGVzIGZvciBQb2ludFxuICAgICAgICAgIGdlb21BdHRycy5wdXNoKHBhcmFtc1twYXJhbV1bMF0pO1xuICAgICAgICAgIGdlb21BdHRycy5wdXNoKHBhcmFtc1twYXJhbV1bMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoZ2VvbUF0dHJzLmxlbmd0aCA9PT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vIGdlb21ldHJ5IGF0dHJpYnV0ZXMgc3BlY2lmaWVkJyk7IH1cbiAgfVxuXG4gIC8vIENyZWF0ZXMgYSBmZWF0dXJlIG9iamVjdCB0byBiZSBhZGRlZFxuICAvLyB0byB0aGUgR2VvSlNPTiBmZWF0dXJlcyBhcnJheVxuICBmdW5jdGlvbiBnZXRGZWF0dXJlKGFyZ3MpIHtcbiAgICB2YXIgaXRlbSA9IGFyZ3MuaXRlbSxcbiAgICAgIHBhcmFtcyA9IGFyZ3MucGFyYW1zLFxuICAgICAgcHJvcEZ1bmMgPSBhcmdzLnByb3BGdW5jO1xuXG4gICAgdmFyIGZlYXR1cmUgPSB7IFwidHlwZVwiOiBcIkZlYXR1cmVcIiB9O1xuXG4gICAgZmVhdHVyZS5nZW9tZXRyeSA9IGJ1aWxkR2VvbShpdGVtLCBwYXJhbXMpO1xuICAgIGZlYXR1cmUucHJvcGVydGllcyA9IHByb3BGdW5jLmNhbGwoaXRlbSk7XG5cbiAgICByZXR1cm4gZmVhdHVyZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTmVzdGVkKHZhbCl7XG4gICAgcmV0dXJuICgvXi4rXFwuLiskLy50ZXN0KHZhbCkpO1xuICB9XG5cbiAgLy8gQXNzZW1ibGVzIHRoZSBgZ2VvbWV0cnlgIHByb3BlcnR5XG4gIC8vIGZvciB0aGUgZmVhdHVyZSBvdXRwdXRcbiAgZnVuY3Rpb24gYnVpbGRHZW9tKGl0ZW0sIHBhcmFtcykge1xuICAgIHZhciBnZW9tID0ge30sXG4gICAgICAgIGF0dHI7XG5cbiAgICBmb3IodmFyIGd0eXBlIGluIHBhcmFtcy5nZW9tKSB7XG4gICAgICB2YXIgdmFsID0gcGFyYW1zLmdlb21bZ3R5cGVdO1xuXG4gICAgICAvLyBHZW9tZXRyeSBwYXJhbWV0ZXIgc3BlY2lmaWVkIGFzOiB7UG9pbnQ6ICdjb29yZHMnfVxuICAgICAgaWYodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgaXRlbS5oYXNPd25Qcm9wZXJ0eSh2YWwpKSB7XG4gICAgICAgIGlmKGd0eXBlID09PSAnR2VvSlNPTicpIHtcbiAgICAgICAgICBnZW9tID0gaXRlbVt2YWxdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlb20udHlwZSA9IGd0eXBlO1xuICAgICAgICAgIGdlb20uY29vcmRpbmF0ZXMgPSBpdGVtW3ZhbF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogSGFuZGxlIHRoaW5ncyBsaWtlOlxuICAgICAgUG9seWdvbjoge1xuICAgICAgICBub3J0aGVhc3Q6IFsnbGF0JywgJ2xuZyddLFxuICAgICAgICBzb3V0aHdlc3Q6IFsnbGF0JywgJ2xuZyddXG4gICAgICB9XG4gICAgICAqL1xuICAgICAgZWxzZSBpZih0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIC8qanNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgICAgIHZhciBwb2ludHMgPSBPYmplY3Qua2V5cyh2YWwpLm1hcChmdW5jdGlvbihrZXkpe1xuICAgICAgICAgIHZhciBvcmRlciA9IHZhbFtrZXldO1xuICAgICAgICAgIHZhciBuZXdJdGVtID0gaXRlbVtrZXldO1xuICAgICAgICAgIHJldHVybiBidWlsZEdlb20obmV3SXRlbSwge2dlb206eyBQb2ludDogb3JkZXJ9fSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnZW9tLnR5cGUgPSBndHlwZTtcbiAgICAgICAgLypqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cbiAgICAgICAgZ2VvbS5jb29yZGluYXRlcyA9IFtdLmNvbmNhdChwb2ludHMubWFwKGZ1bmN0aW9uKHApe1xuICAgICAgICAgIHJldHVybiBwLmNvb3JkaW5hdGVzO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdlb21ldHJ5IHBhcmFtZXRlciBzcGVjaWZpZWQgYXM6IHtQb2ludDogWydsYXQnLCAnbG5nJ119XG4gICAgICBlbHNlIGlmKEFycmF5LmlzQXJyYXkodmFsKSAmJiBpdGVtLmhhc093blByb3BlcnR5KHZhbFswXSkgJiYgaXRlbS5oYXNPd25Qcm9wZXJ0eSh2YWxbMV0pKXtcbiAgICAgICAgZ2VvbS50eXBlID0gZ3R5cGU7XG4gICAgICAgIGdlb20uY29vcmRpbmF0ZXMgPSBbTnVtYmVyKGl0ZW1bdmFsWzFdXSksIE51bWJlcihpdGVtW3ZhbFswXV0pXTtcbiAgICAgIH1cblxuICAgICAgLy8gR2VvbWV0cnkgcGFyYW1ldGVyIHNwZWNpZmllZCBhczoge1BvaW50OiBbJ2NvbnRhaW5lci5sYXQnLCAnY29udGFpbmVyLmxuZyddfVxuICAgICAgZWxzZSBpZihBcnJheS5pc0FycmF5KHZhbCkgJiYgaXNOZXN0ZWQodmFsWzBdKSAmJiBpc05lc3RlZCh2YWxbMV0pKXtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XHQvLyBpLmUuIDAgYW5kIDFcbiAgICAgICAgICB2YXIgcGF0aHMgPSB2YWxbaV0uc3BsaXQoJy4nKTtcbiAgICAgICAgICB2YXIgaXRlbUNsb25lID0gaXRlbTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhdGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoIWl0ZW1DbG9uZS5oYXNPd25Qcm9wZXJ0eShwYXRoc1tqXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbUNsb25lID0gaXRlbUNsb25lW3BhdGhzW2pdXTtcdC8vIEl0ZXJhdGUgZGVlcGVyIGludG8gdGhlIG9iamVjdFxuICAgICAgICAgIH1cbiAgICAgICAgICBjb29yZGluYXRlc1tpXSA9IGl0ZW1DbG9uZTtcbiAgICAgICAgfVxuICAgICAgICBnZW9tLnR5cGUgPSBndHlwZTtcbiAgICAgICAgZ2VvbS5jb29yZGluYXRlcyA9IFtOdW1iZXIoY29vcmRpbmF0ZXNbMV0pLCBOdW1iZXIoY29vcmRpbmF0ZXNbMF0pXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihwYXJhbXMuZG9UaHJvd3MgJiYgcGFyYW1zLmRvVGhyb3dzLmludmFsaWRHZW9tZXRyeSAmJiAhR2VvSlNPTi5pc0dlb21ldHJ5VmFsaWQoZ2VvbSkpe1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRHZW9tZXRyeUVycm9yKGl0ZW0sIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlb207XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmdW5jdGlvbiB0byBiZSB1c2VkIHRvXG4gIC8vIGJ1aWxkIHRoZSBwcm9wZXJ0aWVzIG9iamVjdCBmb3IgZWFjaCBmZWF0dXJlXG4gIGZ1bmN0aW9uIGdldFByb3BGdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgZnVuYztcblxuICAgIGlmKCFwYXJhbXMuZXhjbHVkZSAmJiAhcGFyYW1zLmluY2x1ZGUpIHtcbiAgICAgIGZ1bmMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvcih2YXIgYXR0ciBpbiB0aGlzKSB7XG4gICAgICAgICAgaWYodGhpcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiAoZ2VvbUF0dHJzLmluZGV4T2YoYXR0cikgPT09IC0xKSkge1xuICAgICAgICAgICAgcHJvcGVydGllc1thdHRyXSA9IHRoaXNbYXR0cl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihwYXJhbXMuaW5jbHVkZSkge1xuICAgICAgZnVuYyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgcGFyYW1zLmluY2x1ZGUuZm9yRWFjaChmdW5jdGlvbihhdHRyKXtcbiAgICAgICAgICBwcm9wZXJ0aWVzW2F0dHJdID0gdGhpc1thdHRyXTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZihwYXJhbXMuZXhjbHVkZSkge1xuICAgICAgZnVuYyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yKHZhciBhdHRyIGluIHRoaXMpIHtcbiAgICAgICAgICBpZih0aGlzLmhhc093blByb3BlcnR5KGF0dHIpICYmIChnZW9tQXR0cnMuaW5kZXhPZihhdHRyKSA9PT0gLTEpICYmIChwYXJhbXMuZXhjbHVkZS5pbmRleE9mKGF0dHIpID09PSAtMSkpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNbYXR0cl0gPSB0aGlzW2F0dHJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuXG4gICAgICBmdW5jLmNhbGwodGhpcywgcHJvcGVydGllcyk7XG5cbiAgICAgIGlmKHBhcmFtcy5leHRyYSkgeyBhZGRFeHRyYShwcm9wZXJ0aWVzLCBwYXJhbXMuZXh0cmEpOyB9XG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9O1xuICB9XG5cbiAgLy8gQWRkcyBkYXRhIGNvbnRhaW5lZCBpbiB0aGUgYGV4dHJhYFxuICAvLyBwYXJhbWV0ZXIgaWYgaXQgaGFzIGJlZW4gc3BlY2lmaWVkXG4gIGZ1bmN0aW9uIGFkZEV4dHJhKHByb3BlcnRpZXMsIGV4dHJhKSB7XG4gICAgZm9yKHZhciBrZXkgaW4gZXh0cmEpe1xuICAgICAgaWYoZXh0cmEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBwcm9wZXJ0aWVzW2tleV0gPSBleHRyYVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9XG5cbn0odHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyA/IG1vZHVsZS5leHBvcnRzIDogd2luZG93Lkdlb0pTT04gPSB7fSkpO1xuIiwibW9kdWxlLmV4cG9ydHMuUkFESVVTID0gNjM3ODEzNztcbm1vZHVsZS5leHBvcnRzLkZMQVRURU5JTkcgPSAxLzI5OC4yNTcyMjM1NjM7XG5tb2R1bGUuZXhwb3J0cy5QT0xBUl9SQURJVVMgPSA2MzU2NzUyLjMxNDI7XG4iLCJ2YXIgd2dzODQgPSByZXF1aXJlKCd3Z3M4NCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xubW9kdWxlLmV4cG9ydHMucmluZyA9IHJpbmdBcmVhO1xuXG5mdW5jdGlvbiBnZW9tZXRyeShfKSB7XG4gICAgdmFyIGFyZWEgPSAwLCBpO1xuICAgIHN3aXRjaCAoXy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25BcmVhKF8uY29vcmRpbmF0ZXMpO1xuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF8uY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmVhICs9IHBvbHlnb25BcmVhKF8uY29vcmRpbmF0ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZWE7XG4gICAgICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgXy5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJlYSArPSBnZW9tZXRyeShfLmdlb21ldHJpZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwb2x5Z29uQXJlYShjb29yZHMpIHtcbiAgICB2YXIgYXJlYSA9IDA7XG4gICAgaWYgKGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhcmVhICs9IE1hdGguYWJzKHJpbmdBcmVhKGNvb3Jkc1swXSkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJlYSAtPSBNYXRoLmFicyhyaW5nQXJlYShjb29yZHNbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJlYTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGFwcHJveGltYXRlIGFyZWEgb2YgdGhlIHBvbHlnb24gd2VyZSBpdCBwcm9qZWN0ZWQgb250b1xuICogICAgIHRoZSBlYXJ0aC4gIE5vdGUgdGhhdCB0aGlzIGFyZWEgd2lsbCBiZSBwb3NpdGl2ZSBpZiByaW5nIGlzIG9yaWVudGVkXG4gKiAgICAgY2xvY2t3aXNlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBuZWdhdGl2ZS5cbiAqXG4gKiBSZWZlcmVuY2U6XG4gKiBSb2JlcnQuIEcuIENoYW1iZXJsYWluIGFuZCBXaWxsaWFtIEguIER1cXVldHRlLCBcIlNvbWUgQWxnb3JpdGhtcyBmb3JcbiAqICAgICBQb2x5Z29ucyBvbiBhIFNwaGVyZVwiLCBKUEwgUHVibGljYXRpb24gMDctMDMsIEpldCBQcm9wdWxzaW9uXG4gKiAgICAgTGFib3JhdG9yeSwgUGFzYWRlbmEsIENBLCBKdW5lIDIwMDcgaHR0cDovL3Rycy1uZXcuanBsLm5hc2EuZ292L2RzcGFjZS9oYW5kbGUvMjAxNC80MDQwOVxuICpcbiAqIFJldHVybnM6XG4gKiB7ZmxvYXR9IFRoZSBhcHByb3hpbWF0ZSBzaWduZWQgZ2VvZGVzaWMgYXJlYSBvZiB0aGUgcG9seWdvbiBpbiBzcXVhcmVcbiAqICAgICBtZXRlcnMuXG4gKi9cblxuZnVuY3Rpb24gcmluZ0FyZWEoY29vcmRzKSB7XG4gICAgdmFyIHAxLCBwMiwgcDMsIGxvd2VySW5kZXgsIG1pZGRsZUluZGV4LCB1cHBlckluZGV4LCBpLFxuICAgIGFyZWEgPSAwLFxuICAgIGNvb3Jkc0xlbmd0aCA9IGNvb3Jkcy5sZW5ndGg7XG5cbiAgICBpZiAoY29vcmRzTGVuZ3RoID4gMikge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID09PSBjb29yZHNMZW5ndGggLSAyKSB7Ly8gaSA9IE4tMlxuICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBjb29yZHNMZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIG1pZGRsZUluZGV4ID0gY29vcmRzTGVuZ3RoIC0xO1xuICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSBjb29yZHNMZW5ndGggLSAxKSB7Ly8gaSA9IE4tMVxuICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBjb29yZHNMZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIG1pZGRsZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGkgPSAwIHRvIE4tM1xuICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIG1pZGRsZUluZGV4ID0gaSsxO1xuICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSBpKzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwMSA9IGNvb3Jkc1tsb3dlckluZGV4XTtcbiAgICAgICAgICAgIHAyID0gY29vcmRzW21pZGRsZUluZGV4XTtcbiAgICAgICAgICAgIHAzID0gY29vcmRzW3VwcGVySW5kZXhdO1xuICAgICAgICAgICAgYXJlYSArPSAoIHJhZChwM1swXSkgLSByYWQocDFbMF0pICkgKiBNYXRoLnNpbiggcmFkKHAyWzFdKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmVhID0gYXJlYSAqIHdnczg0LlJBRElVUyAqIHdnczg0LlJBRElVUyAvIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZWE7XG59XG5cbmZ1bmN0aW9uIHJhZChfKSB7XG4gICAgcmV0dXJuIF8gKiBNYXRoLlBJIC8gMTgwO1xufSIsInZhciBnZW9qc29uQXJlYSA9IHJlcXVpcmUoJ0BtYXBib3gvZ2VvanNvbi1hcmVhJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmV3aW5kO1xuXG5mdW5jdGlvbiByZXdpbmQoZ2osIG91dGVyKSB7XG4gICAgc3dpdGNoICgoZ2ogJiYgZ2oudHlwZSkgfHwgbnVsbCkge1xuICAgICAgICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgICAgICAgICBnai5mZWF0dXJlcyA9IGdqLmZlYXR1cmVzLm1hcChjdXJyeU91dGVyKHJld2luZCwgb3V0ZXIpKTtcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICAgICAgY2FzZSAnRmVhdHVyZSc6XG4gICAgICAgICAgICBnai5nZW9tZXRyeSA9IHJld2luZChnai5nZW9tZXRyeSwgb3V0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgICAgIHJldHVybiBjb3JyZWN0KGdqLCBvdXRlcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZ2o7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjdXJyeU91dGVyKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oXykgeyByZXR1cm4gYShfLCBiKTsgfTtcbn1cblxuZnVuY3Rpb24gY29ycmVjdChfLCBvdXRlcikge1xuICAgIGlmIChfLnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICBfLmNvb3JkaW5hdGVzID0gY29ycmVjdFJpbmdzKF8uY29vcmRpbmF0ZXMsIG91dGVyKTtcbiAgICB9IGVsc2UgaWYgKF8udHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgXy5jb29yZGluYXRlcyA9IF8uY29vcmRpbmF0ZXMubWFwKGN1cnJ5T3V0ZXIoY29ycmVjdFJpbmdzLCBvdXRlcikpO1xuICAgIH1cbiAgICByZXR1cm4gXztcbn1cblxuZnVuY3Rpb24gY29ycmVjdFJpbmdzKF8sIG91dGVyKSB7XG4gICAgb3V0ZXIgPSAhIW91dGVyO1xuICAgIF9bMF0gPSB3aW5kKF9bMF0sIG91dGVyKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IF8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX1tpXSA9IHdpbmQoX1tpXSwgIW91dGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIF87XG59XG5cbmZ1bmN0aW9uIHdpbmQoXywgZGlyKSB7XG4gICAgcmV0dXJuIGN3KF8pID09PSBkaXIgPyBfIDogXy5yZXZlcnNlKCk7XG59XG5cbmZ1bmN0aW9uIGN3KF8pIHtcbiAgICByZXR1cm4gZ2VvanNvbkFyZWEucmluZyhfKSA+PSAwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7XG5pbXBvcnQgTWFwQ29tcG9uZW50IGZyb20gJy4uL29iamVjdHMvbWFwL21hcC52dWUnOyAvLyBPdXIgY29tcG9uZW50XG5pbXBvcnQgTWFwRGF0YSBmcm9tICcuL21hcC5kYXRhJzsgLy8gT3VyIHNhbXBsZSBkYXRhXG5pbXBvcnQgR2VvSlNPTiBmcm9tICdnZW9qc29uJztcbmltcG9ydCByZXdpbmQgZnJvbSAnZ2VvanNvbi1yZXdpbmQnO1xuaW1wb3J0IHsgbWFwQ29sb3JDb21iaW5hdGlvbnMgfSBmcm9tICcuLi8uLi9jb25maWcvY29sb3JzJ1xuXG5jbGFzcyBNYXBNdWx0aUxheWVyIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KCdueWNvLW1hcC1tbCcsIE1hcENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiAnW2RhdGEtanM9XCJueWNvLW1hcC1tbFwiXScsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGF5ZXJzOiBNYXBEYXRhLm11bHRpLmxheWVycyxcbiAgICAgICAgICBjb25maWc6IE1hcERhdGEubXVsdGkuY29uZmlnLFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy5nZXRaaXBjb2RlRGF0YSgpO1xuICAgICAgICB0aGlzLmdldEJvcm91Z2hEYXRhKCk7XG4gICAgICAgIHRoaXMuZ2V0TmVpZ2hib3Job29kRGF0YSgpO1xuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2V0WmlwY29kZURhdGEoKSB7XG4gICAgICAgICAgZmV0Y2goJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9raW1wZW5ndWluL2dlb0pTT05AbWFzdGVyL3RpZ2VyLXpjdGEuZ2VvanNvbicpXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKGVycm9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBNYXBEYXRhLm11bHRpLmxheWVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnemlwY29kZXMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IEpTT04ucGFyc2UoZGF0YSksXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmaWx0ZXJCeTogJ0dFT0lEMTAnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEJvcm91Z2hEYXRhKCkge1xuICAgICAgICAgIGZldGNoKCdodHRwczovL2RhdGEuY2l0eW9mbmV3eW9yay51cy9yZXNvdXJjZS83dDNiLXl3dncuanNvbicpXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKGVycm9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgICAgICAgICAgICBNYXBEYXRhLm11bHRpLmxheWVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnYm9yb3VnaHMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuY29udmVydFRvR2VvSlNPTihkYXRhKSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmaWx0ZXJCeTogJ2Jvcm9fbmFtZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TmVpZ2hib3Job29kRGF0YSgpIHtcbiAgICAgICAgICBmZXRjaCgnaHR0cHM6Ly9kYXRhLmNpdHlvZm5ld3lvcmsudXMvcmVzb3VyY2UvcTJ6NS1haTM4Lmpzb24nKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihlcnJvcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICAgICAgICAgICAgTWFwRGF0YS5tdWx0aS5sYXllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ25laWdoYm9yaG9vZHMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuY29udmVydFRvR2VvSlNPTihkYXRhKSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmaWx0ZXJCeTogJ250YW5hbWUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnZlcnRUb0dlb0pTT04oanNvbkRhdGEpIHtcbiAgICAgICAgICAvLyBlbnN1cmUgZ2VvanNvbiBzYXRpc2ZpZXMgcmlnaHQtaGFuZCBydWxlXG4gICAgICAgICAgY29uc3QgZGF0YSA9IHJld2luZChHZW9KU09OLnBhcnNlKGpzb25EYXRhLCB7R2VvSlNPTjogJ3RoZV9nZW9tJ30pKTtcblxuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5jbGFzcyBNYXBTaW5nbGVMYXllciB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudCgnbnljby1tYXAtc2wnLCBNYXBDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogJ1tkYXRhLWpzPVwibnljby1tYXAtc2xcIl0nLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxheWVyczogTWFwRGF0YS5zaW5nbGUubGF5ZXJzLFxuICAgICAgICAgIGNvbmZpZzogTWFwRGF0YS5zaW5nbGUuY29uZmlnLFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy5nZXREYXRhKCk7XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBnZXREYXRhKCkge1xuICAgICAgICAgIGZldGNoKCdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gva2ltcGVuZ3Vpbi9nZW9KU09OQG1hc3Rlci9ueWNvLW55Y196aXBjb2Rlcy5nZW9qc29uJylcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIE1hcERhdGEuc2luZ2xlLmxheWVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbnljby1ueWNfemlwY29kZXMnLFxuICAgICAgICAgICAgICAgIGRhdGE6IEpTT04ucGFyc2UoZGF0YSksXG4gICAgICAgICAgICAgICAgZmlsdGVyQnk6ICdaQ1RBNUNFMTAnLFxuICAgICAgICAgICAgICAgIGxlZ2VuZENvbHVtbjogJ0JPUk8nLFxuICAgICAgICAgICAgICAgIGZpbGw6IG1hcENvbG9yQ29tYmluYXRpb25zWzNdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIE1hcE11bHRpTGF5ZXIsXG4gIE1hcFNpbmdsZUxheWVyXG59IiwiLyoqXG4gKiBKYXJvV2lua2xlciBmdW5jdGlvbi5cbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0phcm8lRTIlODAlOTNXaW5rbGVyX2Rpc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gczEgc3RyaW5nIG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzMiBzZWNvbmQgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfSBhbW91bnQgb2YgbWF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gamFybyhzMSwgczIpIHtcbiAgbGV0IHNob3J0ZXI7XG4gIGxldCBsb25nZXI7XG5cbiAgW2xvbmdlciwgc2hvcnRlcl0gPSBzMS5sZW5ndGggPiBzMi5sZW5ndGggPyBbczEsIHMyXSA6IFtzMiwgczFdO1xuXG4gIGNvbnN0IG1hdGNoaW5nV2luZG93ID0gTWF0aC5mbG9vcihsb25nZXIubGVuZ3RoIC8gMikgLSAxO1xuICBjb25zdCBzaG9ydGVyTWF0Y2hlcyA9IFtdO1xuICBjb25zdCBsb25nZXJNYXRjaGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaG9ydGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoID0gc2hvcnRlcltpXTtcbiAgICBjb25zdCB3aW5kb3dTdGFydCA9IE1hdGgubWF4KDAsIGkgLSBtYXRjaGluZ1dpbmRvdyk7XG4gICAgY29uc3Qgd2luZG93RW5kID0gTWF0aC5taW4oaSArIG1hdGNoaW5nV2luZG93ICsgMSwgbG9uZ2VyLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaiA9IHdpbmRvd1N0YXJ0OyBqIDwgd2luZG93RW5kOyBqKyspXG4gICAgICBpZiAobG9uZ2VyTWF0Y2hlc1tqXSA9PT0gdW5kZWZpbmVkICYmIGNoID09PSBsb25nZXJbal0pIHtcbiAgICAgICAgc2hvcnRlck1hdGNoZXNbaV0gPSBsb25nZXJNYXRjaGVzW2pdID0gY2g7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAgY29uc3Qgc2hvcnRlck1hdGNoZXNTdHJpbmcgPSBzaG9ydGVyTWF0Y2hlcy5qb2luKCcnKTtcbiAgY29uc3QgbG9uZ2VyTWF0Y2hlc1N0cmluZyA9IGxvbmdlck1hdGNoZXMuam9pbignJyk7XG4gIGNvbnN0IG51bU1hdGNoZXMgPSBzaG9ydGVyTWF0Y2hlc1N0cmluZy5sZW5ndGg7XG5cbiAgbGV0IHRyYW5zcG9zaXRpb25zID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaG9ydGVyTWF0Y2hlc1N0cmluZy5sZW5ndGg7IGkrKylcbiAgICBpZiAoc2hvcnRlck1hdGNoZXNTdHJpbmdbaV0gIT09IGxvbmdlck1hdGNoZXNTdHJpbmdbaV0pXG4gICAgICB0cmFuc3Bvc2l0aW9ucysrO1xuICByZXR1cm4gbnVtTWF0Y2hlcyA+IDBcbiAgICA/IChcbiAgICAgICAgbnVtTWF0Y2hlcyAvIHNob3J0ZXIubGVuZ3RoICtcbiAgICAgICAgbnVtTWF0Y2hlcyAvIGxvbmdlci5sZW5ndGggK1xuICAgICAgICAobnVtTWF0Y2hlcyAtIE1hdGguZmxvb3IodHJhbnNwb3NpdGlvbnMgLyAyKSkgLyBudW1NYXRjaGVzXG4gICAgICApIC8gMy4wXG4gICAgOiAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzMSBzdHJpbmcgb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHMyIHNlY29uZCBzdHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gcHJlZml4U2NhbGluZ0ZhY3RvclxuICogQHJldHVybiB7bnVtYmVyfSBqYXJvU2ltaWxhcml0eVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzMSwgczIsIHByZWZpeFNjYWxpbmdGYWN0b3IgPSAwLjIpIHtcbiAgY29uc3QgamFyb1NpbWlsYXJpdHkgPSBqYXJvKHMxLCBzMik7XG5cbiAgbGV0IGNvbW1vblByZWZpeExlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgczEubGVuZ3RoOyBpKyspXG4gICAgaWYgKHMxW2ldID09PSBzMltpXSlcbiAgICAgIGNvbW1vblByZWZpeExlbmd0aCsrO1xuICAgIGVsc2VcbiAgICAgIGJyZWFrO1xuXG4gIHJldHVybiBqYXJvU2ltaWxhcml0eSArXG4gICAgTWF0aC5taW4oY29tbW9uUHJlZml4TGVuZ3RoLCA0KSAqXG4gICAgcHJlZml4U2NhbGluZ0ZhY3RvciAqXG4gICAgKDEgLSBqYXJvU2ltaWxhcml0eSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCAoZm4pID0+IHtcbiAgY29uc3QgY2FjaGUgPSB7fTtcblxuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICByZXR1cm4gY2FjaGVba2V5XSB8fCAoXG4gICAgICBjYWNoZVtrZXldID0gZm4oLi4uYXJncylcbiAgICApO1xuICB9O1xufTtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgamFyb1dpbmtsZXIgZnJvbSAnLi9qYXJvV2lua2xlci5qcyc7XG5pbXBvcnQgbWVtb2l6ZSBmcm9tICcuL21lbW9pemUuanMnO1xuXG4vKipcbiAqIEF1dG9jb21wbGV0ZSBmb3IgYXV0b2NvbXBsZXRlLlxuICogRm9ya2VkIGFuZCBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS94YXZpL21pc3MtcGxldGVcbiAqL1xuY2xhc3MgQXV0b2NvbXBsZXRlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSAgIHtvYmplY3R9IHNldHRpbmdzICBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHJldHVybiAge3RoaXN9ICAgICAgICAgICAgIFRoZSBjbGFzc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30pIHtcbiAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgJ3NlbGVjdG9yJzogc2V0dGluZ3Muc2VsZWN0b3IsIC8vIHJlcXVpcmVkXG4gICAgICAnb3B0aW9ucyc6IHNldHRpbmdzLm9wdGlvbnMsIC8vIHJlcXVpcmVkXG4gICAgICAnY2xhc3NuYW1lJzogc2V0dGluZ3MuY2xhc3NuYW1lLCAvLyByZXF1aXJlZFxuICAgICAgJ3NlbGVjdGVkJzogKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdzZWxlY3RlZCcpKSA/XG4gICAgICAgIHNldHRpbmdzLnNlbGVjdGVkIDogZmFsc2UsXG4gICAgICAnc2NvcmUnOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3Njb3JlJykpID9cbiAgICAgICAgc2V0dGluZ3Muc2NvcmUgOiBtZW1vaXplKEF1dG9jb21wbGV0ZS5zY29yZSksXG4gICAgICAnbGlzdEl0ZW0nOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2xpc3RJdGVtJykpID9cbiAgICAgICAgc2V0dGluZ3MubGlzdEl0ZW0gOiBBdXRvY29tcGxldGUubGlzdEl0ZW0sXG4gICAgICAnZ2V0U2libGluZ0luZGV4JzogKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdnZXRTaWJsaW5nSW5kZXgnKSkgP1xuICAgICAgICBzZXR0aW5ncy5nZXRTaWJsaW5nSW5kZXggOiBBdXRvY29tcGxldGUuZ2V0U2libGluZ0luZGV4XG4gICAgfTtcblxuICAgIHRoaXMuc2NvcmVkT3B0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMudWwgPSBudWxsO1xuICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSAtMTtcblxuICAgIHRoaXMuU0VMRUNUT1JTID0gQXV0b2NvbXBsZXRlLnNlbGVjdG9ycztcbiAgICB0aGlzLlNUUklOR1MgPSBBdXRvY29tcGxldGUuc3RyaW5ncztcbiAgICB0aGlzLk1BWF9JVEVNUyA9IEF1dG9jb21wbGV0ZS5tYXhJdGVtcztcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgIHRoaXMua2V5ZG93bkV2ZW50KGUpO1xuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGUpID0+IHtcbiAgICAgIHRoaXMua2V5dXBFdmVudChlKTtcbiAgICB9KTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIChlKSA9PiB7XG4gICAgICB0aGlzLmlucHV0RXZlbnQoZSk7XG4gICAgfSk7XG5cbiAgICBsZXQgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcblxuICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCAoZSkgPT4ge1xuICAgICAgdGhpcy5mb2N1c0V2ZW50KGUpO1xuICAgIH0sIHRydWUpO1xuXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGUpID0+IHtcbiAgICAgIHRoaXMuYmx1ckV2ZW50KGUpO1xuICAgIH0sIHRydWUpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRVZFTlRTXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgZm9jdXMgZXZlbnRcbiAgICogQHBhcmFtICAge29iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0XG4gICAqL1xuICBmb2N1c0V2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLnNldHRpbmdzLnNlbGVjdG9yKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5pbnB1dCA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmICh0aGlzLmlucHV0LnZhbHVlID09PSAnJylcbiAgICAgIHRoaXMubWVzc2FnZSgnSU5JVCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBrZXlkb3duIGV2ZW50XG4gICAqIEBwYXJhbSAgIHtvYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdFxuICAgKi9cbiAga2V5ZG93bkV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLnNldHRpbmdzLnNlbGVjdG9yKSkgcmV0dXJuO1xuICAgIHRoaXMuaW5wdXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICBpZiAodGhpcy51bClcbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICBjYXNlIDEzOiB0aGlzLmtleUVudGVyKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNzogdGhpcy5rZXlFc2NhcGUoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOiB0aGlzLmtleURvd24oZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM4OiB0aGlzLmtleVVwKGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW5wdXQga2V5dXAgZXZlbnRcbiAgICogQHBhcmFtICAge29iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0XG4gICAqL1xuICBrZXl1cEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLnNldHRpbmdzLnNlbGVjdG9yKSlcbiAgICAgIHJldHVybjtcblxuICAgIHRoaXMuaW5wdXQgPSBldmVudC50YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlucHV0IGV2ZW50XG4gICAqIEBwYXJhbSAgIHtvYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdFxuICAgKi9cbiAgaW5wdXRFdmVudChldmVudCkge1xuICAgIGlmICghZXZlbnQudGFyZ2V0Lm1hdGNoZXModGhpcy5zZXR0aW5ncy5zZWxlY3RvcikpXG4gICAgICByZXR1cm47XG5cbiAgICB0aGlzLmlucHV0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgaWYgKHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoID4gMClcbiAgICAgIHRoaXMuc2NvcmVkT3B0aW9ucyA9IHRoaXMuc2V0dGluZ3Mub3B0aW9uc1xuICAgICAgICAubWFwKChvcHRpb24pID0+IHRoaXMuc2V0dGluZ3Muc2NvcmUodGhpcy5pbnB1dC52YWx1ZSwgb3B0aW9uKSlcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnNjb3JlZE9wdGlvbnMgPSBbXTtcblxuICAgIHRoaXMuZHJvcGRvd24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgYmx1ciBldmVudFxuICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3RcbiAgICovXG4gIGJsdXJFdmVudChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHdpbmRvdyB8fFxuICAgICAgICAgICFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLnNldHRpbmdzLnNlbGVjdG9yKSlcbiAgICAgIHJldHVybjtcblxuICAgIHRoaXMuaW5wdXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICBpZiAodGhpcy5pbnB1dC5kYXRhc2V0LnBlcnNpc3REcm9wZG93biA9PT0gJ3RydWUnKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICB0aGlzLmhpZ2hsaWdodGVkID0gLTE7XG4gIH1cblxuICAvKipcbiAgICogS0VZIElOUFVUIEVWRU5UU1xuICAgKi9cblxuICAvKipcbiAgICogV2hhdCBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgZG93biBhcnJvd1xuICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3RcbiAgICogQHJldHVybiAge29iamVjdH0gICAgICAgICBUaGUgQ2xhc3NcbiAgICovXG4gIGtleURvd24oZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdGhpcy5oaWdobGlnaHQoKHRoaXMuaGlnaGxpZ2h0ZWQgPCB0aGlzLnVsLmNoaWxkcmVuLmxlbmd0aCAtIDEpID9cbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZCArIDEgOiAtMVxuICAgICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoYXQgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlIHVwIGFycm93XG4gICAqIEBwYXJhbSAgIHtvYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuICB7b2JqZWN0fSAgICAgICAgIFRoZSBDbGFzc1xuICAgKi9cbiAga2V5VXAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdGhpcy5oaWdobGlnaHQoKHRoaXMuaGlnaGxpZ2h0ZWQgPiAtMSkgP1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkIC0gMSA6IHRoaXMudWwuY2hpbGRyZW4ubGVuZ3RoIC0gMVxuICAgICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoYXQgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlIGVudGVyIGtleVxuICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3RcbiAgICogQHJldHVybiAge29iamVjdH0gICAgICAgICBUaGUgQ2xhc3NcbiAgICovXG4gIGtleUVudGVyKGV2ZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoYXQgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlIGVzY2FwZSBrZXlcbiAgICogQHBhcmFtICAge29iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm4gIHtvYmplY3R9ICAgICAgICAgVGhlIENsYXNzXG4gICAqL1xuICBrZXlFc2NhcGUoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNUQVRJQ1xuICAgKi9cblxuICAvKipcbiAgICogSXQgbXVzdCByZXR1cm4gYW4gb2JqZWN0IHdpdGggYXQgbGVhc3QgdGhlIHByb3BlcnRpZXMgJ3Njb3JlJ1xuICAgKiBhbmQgJ2Rpc3BsYXlWYWx1ZS4nIERlZmF1bHQgaXMgYSBKYXJv4oCTV2lua2xlciBzaW1pbGFyaXR5IGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHthcnJheX0gIHZhbHVlXG4gICAqIEBwYXJhbSAge2FycmF5fSAgc3lub255bXNcbiAgICogQHJldHVybiB7aW50fSAgICBTY29yZSBvciBkaXNwbGF5VmFsdWVcbiAgICovXG4gIHN0YXRpYyBzY29yZSh2YWx1ZSwgc3lub255bXMpIHtcbiAgICBsZXQgY2xvc2VzdFN5bm9ueW0gPSBudWxsO1xuXG4gICAgc3lub255bXMuZm9yRWFjaCgoc3lub255bSkgPT4ge1xuICAgICAgbGV0IHNpbWlsYXJpdHkgPSBqYXJvV2lua2xlcihcbiAgICAgICAgICBzeW5vbnltLnRyaW0oKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHZhbHVlLnRyaW0oKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICk7XG5cbiAgICAgIGlmIChjbG9zZXN0U3lub255bSA9PT0gbnVsbCB8fCBzaW1pbGFyaXR5ID4gY2xvc2VzdFN5bm9ueW0uc2ltaWxhcml0eSkge1xuICAgICAgICBjbG9zZXN0U3lub255bSA9IHtzaW1pbGFyaXR5LCB2YWx1ZTogc3lub255bX07XG4gICAgICAgIGlmIChzaW1pbGFyaXR5ID09PSAxKSByZXR1cm47XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NvcmU6IGNsb3Nlc3RTeW5vbnltLnNpbWlsYXJpdHksXG4gICAgICBkaXNwbGF5VmFsdWU6IHN5bm9ueW1zWzBdXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IGl0ZW0gZm9yIGRyb3Bkb3duIGxpc3QuXG4gICAqIEBwYXJhbSAge051bWJlcn0gIHNjb3JlZE9wdGlvblxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBpbmRleFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9ICBUaGUgYSBsaXN0IGl0ZW0gPGxpPi5cbiAgICovXG4gIHN0YXRpYyBsaXN0SXRlbShzY29yZWRPcHRpb24sIGluZGV4LCBtYXhJdGVtcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbmRleCA9IGluZGV4ICsgMTsgLy8gc3RhcnQgYXQgMVxuXG4gICAgY29uc3QgbGkgPSAobm9ybWFsaXplZEluZGV4ID4gbWF4SXRlbXMpID9cbiAgICAgIG51bGwgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXG4gICAgaWYgKGxpKSB7XG4gICAgICBsaS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnb3B0aW9uJyk7XG4gICAgICBsaS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICBsaS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAnZmFsc2UnKTtcbiAgICB9XG5cbiAgICBsaSAmJiBsaS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzY29yZWRPcHRpb24uZGlzcGxheVZhbHVlKSk7XG5cbiAgICByZXR1cm4gbGk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIHByZXZpb3VzIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FycmF5fSAgIG5vZGVcbiAgICogQHJldHVybiB7bnVtYmVyfSAgaW5kZXggb2YgcHJldmlvdXMgZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyBnZXRTaWJsaW5nSW5kZXgobm9kZSkge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGxldCBuID0gbm9kZTtcblxuICAgIGRvIHtcbiAgICAgIGluZGV4Kys7IG4gPSBuLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHdoaWxlIChuKTtcblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQVUJMSUMgTUVUSE9EU1xuICAgKi9cblxuICAvKipcbiAgICogRGlzcGxheSBvcHRpb25zIGFzIGEgbGlzdC5cbiAgICogQHJldHVybiAge29iamVjdH0gVGhlIENsYXNzXG4gICAqL1xuICBkcm9wZG93bigpIHtcbiAgICBjb25zdCBkb2N1bWVudEZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgdGhpcy5zY29yZWRPcHRpb25zLmV2ZXJ5KChzY29yZWRPcHRpb24sIGkpID0+IHtcbiAgICAgIGxldCBsaXN0SXRlbSA9IHRoaXMuc2V0dGluZ3MubGlzdEl0ZW0oc2NvcmVkT3B0aW9uLCBpLCB0aGlzLk1BWF9JVEVNUyk7XG5cbiAgICAgIGxpc3RJdGVtICYmIGRvY3VtZW50RnJhZ21lbnQuYXBwZW5kQ2hpbGQobGlzdEl0ZW0pO1xuICAgICAgcmV0dXJuICEhbGlzdEl0ZW07XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSAtMTtcblxuICAgIGlmIChkb2N1bWVudEZyYWdtZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgY29uc3QgbmV3VWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpO1xuXG4gICAgICBuZXdVbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbGlzdGJveCcpO1xuICAgICAgbmV3VWwuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG4gICAgICBuZXdVbC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5TRUxFQ1RPUlMuT1BUSU9OUyk7XG5cbiAgICAgIG5ld1VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09ICdMSScpXG4gICAgICAgICAgdGhpcy5oaWdobGlnaHQodGhpcy5zZXR0aW5ncy5nZXRTaWJsaW5nSW5kZXgoZXZlbnQudGFyZ2V0KSk7XG4gICAgICB9KTtcblxuICAgICAgbmV3VWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGV2ZW50KSA9PlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpKTtcblxuICAgICAgbmV3VWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnTEknKVxuICAgICAgICAgIHRoaXMuc2VsZWN0ZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBuZXdVbC5hcHBlbmRDaGlsZChkb2N1bWVudEZyYWdtZW50KTtcblxuICAgICAgLy8gU2VlIENTUyB0byB1bmRlcnN0YW5kIHdoeSB0aGUgPHVsPiBoYXMgdG8gYmUgd3JhcHBlZCBpbiBhIDxkaXY+XG4gICAgICBjb25zdCBuZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgbmV3Q29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMuc2V0dGluZ3MuY2xhc3NuYW1lO1xuICAgICAgbmV3Q29udGFpbmVyLmFwcGVuZENoaWxkKG5ld1VsKTtcblxuICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuXG4gICAgICAvLyBJbnNlcnRzIHRoZSBkcm9wZG93biBqdXN0IGFmdGVyIHRoZSA8aW5wdXQ+IGVsZW1lbnRcbiAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Q29udGFpbmVyLCB0aGlzLmlucHV0Lm5leHRTaWJsaW5nKTtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gbmV3Q29udGFpbmVyO1xuICAgICAgdGhpcy51bCA9IG5ld1VsO1xuXG4gICAgICB0aGlzLm1lc3NhZ2UoJ1RZUElORycsIHRoaXMuc2V0dGluZ3Mub3B0aW9ucy5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZ2hsaWdodCBuZXcgb3B0aW9uIHNlbGVjdGVkLlxuICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgbmV3SW5kZXhcbiAgICogQHJldHVybiAge29iamVjdH0gIFRoZSBDbGFzc1xuICAgKi9cbiAgaGlnaGxpZ2h0KG5ld0luZGV4KSB7XG4gICAgaWYgKG5ld0luZGV4ID4gLTEgJiYgbmV3SW5kZXggPCB0aGlzLnVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gSWYgYW55IG9wdGlvbiBhbHJlYWR5IHNlbGVjdGVkLCB0aGVuIHVuc2VsZWN0IGl0XG4gICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy51bC5jaGlsZHJlblt0aGlzLmhpZ2hsaWdodGVkXS5jbGFzc0xpc3RcbiAgICAgICAgICAucmVtb3ZlKHRoaXMuU0VMRUNUT1JTLkhJR0hMSUdIVCk7XG4gICAgICAgIHRoaXMudWwuY2hpbGRyZW5bdGhpcy5oaWdobGlnaHRlZF0ucmVtb3ZlQXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJyk7XG4gICAgICAgIHRoaXMudWwuY2hpbGRyZW5bdGhpcy5oaWdobGlnaHRlZF0ucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuXG4gICAgICAgIHRoaXMuaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oaWdobGlnaHRlZCA9IG5ld0luZGV4O1xuXG4gICAgICBpZiAodGhpcy5oaWdobGlnaHRlZCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy51bC5jaGlsZHJlblt0aGlzLmhpZ2hsaWdodGVkXS5jbGFzc0xpc3RcbiAgICAgICAgICAuYWRkKHRoaXMuU0VMRUNUT1JTLkhJR0hMSUdIVCk7XG4gICAgICAgIHRoaXMudWwuY2hpbGRyZW5bdGhpcy5oaWdobGlnaHRlZF1cbiAgICAgICAgICAuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy51bC5jaGlsZHJlblt0aGlzLmhpZ2hsaWdodGVkXVxuICAgICAgICAgIC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5TRUxFQ1RPUlMuQUNUSVZFX0RFU0NFTkRBTlQpO1xuXG4gICAgICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLFxuICAgICAgICAgIHRoaXMuU0VMRUNUT1JTLkFDVElWRV9ERVNDRU5EQU5UKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIGFuIG9wdGlvbiBmcm9tIGEgbGlzdCBvZiBpdGVtcy5cbiAgICogQHJldHVybiAge29iamVjdH0gVGhlIENsYXNzXG4gICAqL1xuICBzZWxlY3RlZCgpIHtcbiAgICBpZiAodGhpcy5oaWdobGlnaHRlZCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuaW5wdXQudmFsdWUgPSB0aGlzLnNjb3JlZE9wdGlvbnNbdGhpcy5oaWdobGlnaHRlZF0uZGlzcGxheVZhbHVlO1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHRoaXMubWVzc2FnZSgnU0VMRUNURUQnLCB0aGlzLmlucHV0LnZhbHVlKTtcblxuICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIDw9IDc2OClcbiAgICAgICAgdGhpcy5pbnB1dC5zY3JvbGxJbnRvVmlldyh0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBVc2VyIHByb3ZpZGVkIGNhbGxiYWNrIG1ldGhvZCBmb3Igc2VsZWN0ZWQgb3B0aW9uLlxuICAgIGlmICh0aGlzLnNldHRpbmdzLnNlbGVjdGVkKVxuICAgICAgdGhpcy5zZXR0aW5ncy5zZWxlY3RlZCh0aGlzLmlucHV0LnZhbHVlLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBkcm9wZG93biBsaXN0IG9uY2UgYSBsaXN0IGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAqIEByZXR1cm4gIHtvYmplY3R9IFRoZSBDbGFzc1xuICAgKi9cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuY29udGFpbmVyICYmIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG5cbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy51bCA9IG51bGw7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXNzYWdpbmcgdGhhdCBpcyBwYXNzZWQgdG8gdGhlIHNjcmVlbiByZWFkZXJcbiAgICogQHBhcmFtICAge3N0cmluZ30gIGtleSAgICAgICBUaGUgS2V5IG9mIHRoZSBtZXNzYWdlIHRvIHdyaXRlXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9ICB2YXJpYWJsZSAgQSB2YXJpYWJsZSB0byBwcm92aWRlIHRvIHRoZSBzdHJpbmcuXG4gICAqIEByZXR1cm4gIHtvYmplY3R9ICAgICAgICAgICAgVGhlIENsYXNzXG4gICAqL1xuICBtZXNzYWdlKGtleSA9IGZhbHNlLCB2YXJpYWJsZSA9ICcnKSB7XG4gICAgaWYgKCFrZXkpIHJldHVybiB0aGlzO1xuXG4gICAgbGV0IG1lc3NhZ2VzID0ge1xuICAgICAgJ0lOSVQnOiAoKSA9PiB0aGlzLlNUUklOR1MuRElSRUNUSU9OU19UWVBFLFxuICAgICAgJ1RZUElORyc6ICgpID0+IChbXG4gICAgICAgICAgdGhpcy5TVFJJTkdTLk9QVElPTl9BVkFJTEFCTEUucmVwbGFjZSgne3sgTlVNQkVSIH19JywgdmFyaWFibGUpLFxuICAgICAgICAgIHRoaXMuU1RSSU5HUy5ESVJFQ1RJT05TX1JFVklFV1xuICAgICAgICBdLmpvaW4oJy4gJykpLFxuICAgICAgJ1NFTEVDVEVEJzogKCkgPT4gKFtcbiAgICAgICAgICB0aGlzLlNUUklOR1MuT1BUSU9OX1NFTEVDVEVELnJlcGxhY2UoJ3t7IFZBTFVFIH19JywgdmFyaWFibGUpLFxuICAgICAgICAgIHRoaXMuU1RSSU5HUy5ESVJFQ1RJT05TX1RZUEVcbiAgICAgICAgXS5qb2luKCcuICcpKVxuICAgIH07XG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAjJHt0aGlzLmlucHV0LmdldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpfWApXG4gICAgICAuaW5uZXJIVE1MID0gbWVzc2FnZXNba2V5XSgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLyoqIFNlbGVjdG9ycyBmb3IgdGhlIEF1dG9jb21wbGV0ZSBjbGFzcy4gKi9cbkF1dG9jb21wbGV0ZS5zZWxlY3RvcnMgPSB7XG4gICdISUdITElHSFQnOiAnaW5wdXQtYXV0b2NvbXBsZXRlX19oaWdobGlnaHQnLFxuICAnT1BUSU9OUyc6ICdpbnB1dC1hdXRvY29tcGxldGVfX29wdGlvbnMnLFxuICAnQUNUSVZFX0RFU0NFTkRBTlQnOiAnaW5wdXQtYXV0b2NvbXBsZXRlX19zZWxlY3RlZCcsXG4gICdTQ1JFRU5fUkVBREVSX09OTFknOiAnc3Itb25seSdcbn07XG5cbi8qKiAgKi9cbkF1dG9jb21wbGV0ZS5zdHJpbmdzID0ge1xuICAnRElSRUNUSU9OU19UWVBFJzpcbiAgICAnU3RhcnQgdHlwaW5nIHRvIGdlbmVyYXRlIGEgbGlzdCBvZiBwb3RlbnRpYWwgaW5wdXQgb3B0aW9ucycsXG4gICdESVJFQ1RJT05TX1JFVklFVyc6IFtcbiAgICAgICdLZXlib2FyZCB1c2VycyBjYW4gdXNlIHRoZSB1cCBhbmQgZG93biBhcnJvd3MgdG8gJyxcbiAgICAgICdyZXZpZXcgb3B0aW9ucyBhbmQgcHJlc3MgZW50ZXIgdG8gc2VsZWN0IGFuIG9wdGlvbidcbiAgICBdLmpvaW4oJycpLFxuICAnT1BUSU9OX0FWQUlMQUJMRSc6ICd7eyBOVU1CRVIgfX0gb3B0aW9ucyBhdmFpbGFibGUnLFxuICAnT1BUSU9OX1NFTEVDVEVEJzogJ3t7IFZBTFVFIH19IHNlbGVjdGVkJ1xufTtcblxuLyoqIE1heGltdW0gYW1vdW50IG9mIHJlc3VsdHMgdG8gYmUgcmV0dXJuZWQuICovXG5BdXRvY29tcGxldGUubWF4SXRlbXMgPSA1O1xuXG5leHBvcnQgZGVmYXVsdCBBdXRvY29tcGxldGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBdXRvY29tcGxldGUgZnJvbSAnLi4vLi4vanMvbW9kdWxlcy9hdXRvY29tcGxldGUnO1xuXG4vKipcbiAqIFRoZSBJbnB1dEF1dG9jb21wbGV0ZSBjbGFzcy5cbiAqL1xuY2xhc3MgSW5wdXRBdXRvY29tcGxldGUge1xuICAvKipcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzZXR0aW5ncyBUaGlzIGNvdWxkIGJlIHNvbWUgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgcGF0dGVybiBtb2R1bGUuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSkge1xuICAgIHRoaXMubGlicmFyeSA9IG5ldyBBdXRvY29tcGxldGUoe1xuICAgICAgb3B0aW9uczogKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdvcHRpb25zJykpXG4gICAgICAgID8gc2V0dGluZ3Mub3B0aW9ucyA6IElucHV0QXV0b2NvbXBsZXRlLm9wdGlvbnMsXG4gICAgICBzZWxlY3RlZDogKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdzZWxlY3RlZCcpKVxuICAgICAgICA/IHNldHRpbmdzLnNlbGVjdGVkIDogZmFsc2UsXG4gICAgICBzZWxlY3RvcjogKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdzZWxlY3RvcicpKVxuICAgICAgICA/IHNldHRpbmdzLnNlbGVjdG9yIDogSW5wdXRBdXRvY29tcGxldGUuc2VsZWN0b3IsXG4gICAgICBjbGFzc25hbWU6IChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnY2xhc3NuYW1lJykpXG4gICAgICAgID8gc2V0dGluZ3MuY2xhc3NuYW1lIDogSW5wdXRBdXRvY29tcGxldGUuY2xhc3NuYW1lLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgQXV0b2NvbXBsZXRlIG9wdGlvbnNcbiAgICogQHBhcmFtICB7b2JqZWN0fSByZXNldCBTZXQgb2YgYXJyYXkgb3B0aW9ucyBmb3IgdGhlIEF1dG9jb21wbGV0ZSBjbGFzc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9IElucHV0QXV0b2NvbXBsZXRlIG9iamVjdCB3aXRoIG5ldyBvcHRpb25zLlxuICAgKi9cbiAgb3B0aW9ucyhyZXNldCkge1xuICAgIHRoaXMubGlicmFyeS5zZXR0aW5ncy5vcHRpb25zID0gcmVzZXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgQXV0b2NvbXBsZXRlIHN0cmluZ3NcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgbG9jYWxpemVkU3RyaW5ncyAgT2JqZWN0IGNvbnRhaW5pbmcgc3RyaW5ncy5cbiAgICogQHJldHVybiB7b2JqZWN0fSBBdXRvY29tcGxldGUgc3RyaW5nc1xuICAgKi9cbiAgc3RyaW5ncyhsb2NhbGl6ZWRTdHJpbmdzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmxpYnJhcnkuU1RSSU5HUywgbG9jYWxpemVkU3RyaW5ncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLyoqIEB0eXBlIHthcnJheX0gRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYXV0b2NvbXBsZXRlIGNsYXNzICovXG5JbnB1dEF1dG9jb21wbGV0ZS5vcHRpb25zID0gW107XG5cbi8qKiBAdHlwZSB7c3RyaW5nfSBUaGUgc2VhcmNoIGJveCBkb20gc2VsZWN0b3IgKi9cbklucHV0QXV0b2NvbXBsZXRlLnNlbGVjdG9yID0gJ1tkYXRhLWpzPVwiaW5wdXQtYXV0b2NvbXBsZXRlX19pbnB1dFwiXSc7XG5cbi8qKiBAdHlwZSB7c3RyaW5nfSBUaGUgY2xhc3NuYW1lIGZvciB0aGUgZHJvcGRvd24gZWxlbWVudCAqL1xuSW5wdXRBdXRvY29tcGxldGUuY2xhc3NuYW1lID0gJ2lucHV0LWF1dG9jb21wbGV0ZV9fZHJvcGRvd24nO1xuXG5leHBvcnQgZGVmYXVsdCBJbnB1dEF1dG9jb21wbGV0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEljb25zIGZyb20gJy4uL2VsZW1lbnRzL2ljb25zL0ljb25zJztcbmltcG9ydCBGZWVkIGZyb20gJy4uL29iamVjdHMvZmVlZC9GZWVkJztcbmltcG9ydCBUb2dnbGUgZnJvbSAnLi4vdXRpbGl0aWVzL3RvZ2dsZS9Ub2dnbGUnO1xuaW1wb3J0IFRyYWNrIGZyb20gJy4uL3V0aWxpdGllcy90cmFjay9UcmFjayc7XG5pbXBvcnQgU2VsZWN0IGZyb20gJy4uL2VsZW1lbnRzL3NlbGVjdC9zZWxlY3QnO1xuaW1wb3J0IENoYXJ0QmFyIGZyb20gJy4uL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1iYXInO1xuaW1wb3J0IENoYXJ0SG9yaXpvbnRhbEJhciBmcm9tICcuLi9vYmplY3RzL2NoYXJ0cy9jaGFydC0taG9yaXpvbnRhbC1iYXInO1xuaW1wb3J0IENoYXJ0TGluZSBmcm9tICcuLi9vYmplY3RzL2NoYXJ0cy9jaGFydC0tbGluZSc7XG5pbXBvcnQgQ2hhcnRQaWUgZnJvbSAnLi4vb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZSc7XG5pbXBvcnQgeyBNYXBNdWx0aUxheWVyLCBNYXBTaW5nbGVMYXllciB9IGZyb20gJy4vTWFwJztcbmltcG9ydCBJbnB1dEF1dG9jb21wbGV0ZSBmcm9tICcuLi9lbGVtZW50cy9pbnB1dHMvaW5wdXQtYXV0b2NvbXBsZXRlJztcblxuLyoqIGltcG9ydCBtb2R1bGVzIGhlcmUgYXMgdGhleSBhcmUgd3JpdHRlbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIHRoZSBnbG9iYWwgTnljb1BhdHRlcm5zIGluc3RhbmNlXG4gKi9cbmNsYXNzIG55Y28ge1xuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgSWNvbnMgRWxlbWVudFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggIFRoZSBwYXRoIG9mIHRoZSBpY29uIGZpbGVcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBJY29ucyBpbnN0YW5jZVxuICAgKi9cbiAgaWNvbnMocGF0aCkge1xuICAgIHJldHVybiBuZXcgSWNvbnMocGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgRmVlZCBPYmplY3RcbiAgICogQHBhcmFtICAge09iamVjdH0gIHNldHRpbmdzICBTZXR0aW5nIGZvciB0aGUgZmVlZFxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSAgICAgICAgICAgIEZlZWQgaW5zdGFuY2VcbiAgICovXG4gIGZlZWQoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IEZlZWQoc2V0dGluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgdGhlIFRvZ2dsZSBVdGlsaXR5XG4gICAqIEByZXR1cm4gIHtPYmplY3R9IFRvZ2dsZSBpbnN0YW5jZVxuICAgKi9cbiAgdG9nZ2xlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBUb2dnbGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBUcmFjayBNb2R1bGVcbiAgICogQHJldHVybiAge09iamVjdH0gVHJhY2sgTW9kdWxlXG4gICAqL1xuICB0cmFjayhzZXR0aW5ncykge1xuICAgIHJldHVybiBuZXcgVHJhY2soKTtcbiAgfVxuXG4gIHNlbGVjdCgpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBDaGFydCBPYmplY3RzXG4gICAqIEByZXR1cm4gIHtPYmplY3R9IENoYXJ0IGluc3RhbmNlXG4gICAqL1xuICBjaGFydCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdiYXInKVxuICAgICAgcmV0dXJuIG5ldyBDaGFydEJhcigpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdob3Jpem9udGFsQmFyJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRIb3Jpem9udGFsQmFyKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2xpbmUnKVxuICAgICAgcmV0dXJuIG5ldyBDaGFydExpbmUoKTtcblxuICAgIGlmICh0eXBlID09PSAncGllJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRQaWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBNYXAgTW9kdWxlXG4gICAqIEByZXR1cm4gIHtPYmplY3R9IE1hcCBNb2R1bGVcbiAgICovXG4gIG1hcCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdtdWx0aScpXG4gICAgICByZXR1cm4gbmV3IE1hcE11bHRpTGF5ZXIoKTtcblxuICAgIGlmICh0eXBlID09PSAnc2luZ2xlJylcbiAgICAgIHJldHVybiBuZXcgTWFwU2luZ2xlTGF5ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBJbnB1dCBBdXRvY29tcGxldGUgRWxlbWVudFxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSBJbnB1dCBBdXRvY29tcGxldGUgaW5zdGFuY2VcbiAgICovXG4gIGlucHV0QXV0b2NvbXBsZXRlKHNldHRpbmdzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IElucHV0QXV0b2NvbXBsZXRlKHNldHRpbmdzKTtcbiAgfVxuXG4gIC8qKiBhZGQgQVBJcyBoZXJlIGFzIHRoZXkgYXJlIHdyaXR0ZW4gKi9cbn1cblxuZXhwb3J0IGRlZmF1bHQgbnljbztcbiJdLCJuYW1lcyI6WyJVdGlsaXR5IiwiZGVidWciLCJnZXRVcmxQYXJhbWV0ZXIiLCJQQVJBTVMiLCJERUJVRyIsIm5hbWUiLCJxdWVyeVN0cmluZyIsInF1ZXJ5Iiwid2luZG93IiwibG9jYXRpb24iLCJzZWFyY2giLCJjb25zdCIsInBhcmFtIiwicmVwbGFjZSIsInJlZ2V4IiwiUmVnRXhwIiwicmVzdWx0cyIsImV4ZWMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJsb2NhbGl6ZSIsInNsdWciLCJ0ZXh0IiwibGV0Iiwic3RyaW5ncyIsIkxPQ0FMSVpFRF9TVFJJTkdTIiwibWF0Y2giLCJmaWx0ZXIiLCJzIiwiaGFzT3duUHJvcGVydHkiLCJsYWJlbCIsIlNFTEVDVE9SUyIsInBhcnNlTWFya2Rvd24iLCJJY29ucyIsInBhdGgiLCJmZXRjaCIsInRoZW4iLCJyZXNwb25zZSIsIm9rIiwiY29uc29sZSIsImRpciIsImNhdGNoIiwiZXJyb3IiLCJkYXRhIiwic3ByaXRlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaW5uZXJIVE1MIiwic2V0QXR0cmlidXRlIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsIk9iamVjdCIsImZyZWVTZWxmIiwic2VsZiIsInJvb3QiLCJGdW5jdGlvbiIsIlN5bWJvbCIsIm9iamVjdFByb3RvIiwicHJvdG90eXBlIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJ0b1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJ1bmRlZmluZWQiLCJnZXRSYXdUYWciLCJ2YWx1ZSIsImlzT3duIiwiY2FsbCIsInRhZyIsInVubWFza2VkIiwiZSIsInJlc3VsdCIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsImJhc2VHZXRUYWciLCJpc09iamVjdCIsInR5cGUiLCJhc3luY1RhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRnVuY3Rpb24iLCJjb3JlSnNEYXRhIiwibWFza1NyY0tleSIsInVpZCIsImtleXMiLCJJRV9QUk9UTyIsImlzTWFza2VkIiwiZnVuYyIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInRvU291cmNlIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwicmVJc05hdGl2ZSIsImJhc2VJc05hdGl2ZSIsInBhdHRlcm4iLCJ0ZXN0IiwiZ2V0VmFsdWUiLCJvYmplY3QiLCJrZXkiLCJnZXROYXRpdmUiLCJkZWZpbmVQcm9wZXJ0eSIsImJhc2VBc3NpZ25WYWx1ZSIsImVxIiwib3RoZXIiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiY29weU9iamVjdCIsInNvdXJjZSIsInByb3BzIiwiY3VzdG9taXplciIsImlzTmV3IiwiaW5kZXgiLCJsZW5ndGgiLCJuZXdWYWx1ZSIsImlkZW50aXR5IiwiYXBwbHkiLCJ0aGlzQXJnIiwiYXJncyIsIm5hdGl2ZU1heCIsIk1hdGgiLCJtYXgiLCJvdmVyUmVzdCIsInN0YXJ0IiwidHJhbnNmb3JtIiwiYXJndW1lbnRzIiwiYXJyYXkiLCJBcnJheSIsIm90aGVyQXJncyIsImNvbnN0YW50IiwiYmFzZVNldFRvU3RyaW5nIiwic3RyaW5nIiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJuYXRpdmVOb3ciLCJEYXRlIiwibm93Iiwic2hvcnRPdXQiLCJjb3VudCIsImxhc3RDYWxsZWQiLCJzdGFtcCIsInJlbWFpbmluZyIsInNldFRvU3RyaW5nIiwiYmFzZVJlc3QiLCJNQVhfU0FGRV9JTlRFR0VSIiwiaXNMZW5ndGgiLCJpc0FycmF5TGlrZSIsInJlSXNVaW50IiwiaXNJbmRleCIsImlzSXRlcmF0ZWVDYWxsIiwiY3JlYXRlQXNzaWduZXIiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsImJhc2VUaW1lcyIsIm4iLCJpdGVyYXRlZSIsImlzT2JqZWN0TGlrZSIsImFyZ3NUYWciLCJiYXNlSXNBcmd1bWVudHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJndW1lbnRzIiwiaXNBcnJheSIsInN0dWJGYWxzZSIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwib2JqZWN0VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJ0eXBlZEFycmF5VGFncyIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkiLCJmcmVlUHJvY2VzcyIsInByb2Nlc3MiLCJub2RlVXRpbCIsInR5cGVzIiwicmVxdWlyZSIsImJpbmRpbmciLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5IiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJyIiwiaXNBcmciLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsIlN0cmluZyIsInB1c2giLCJpc1Byb3RvdHlwZSIsIkN0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvIiwibmF0aXZlS2V5c0luIiwiYmFzZUtleXNJbiIsImlzUHJvdG8iLCJrZXlzSW4iLCJhc3NpZ25JbldpdGgiLCJzcmNJbmRleCIsIm92ZXJBcmciLCJhcmciLCJnZXRQcm90b3R5cGUiLCJnZXRQcm90b3R5cGVPZiIsIm9iamVjdEN0b3JTdHJpbmciLCJpc1BsYWluT2JqZWN0IiwiZG9tRXhjVGFnIiwiaXNFcnJvciIsIm1lc3NhZ2UiLCJhdHRlbXB0IiwiRXJyb3IiLCJhcnJheU1hcCIsImJhc2VWYWx1ZXMiLCJjdXN0b21EZWZhdWx0c0Fzc2lnbkluIiwic3JjVmFsdWUiLCJzdHJpbmdFc2NhcGVzIiwiZXNjYXBlU3RyaW5nQ2hhciIsImNociIsIm5hdGl2ZUtleXMiLCJiYXNlS2V5cyIsInJlSW50ZXJwb2xhdGUiLCJiYXNlUHJvcGVydHlPZiIsImh0bWxFc2NhcGVzIiwiZXNjYXBlSHRtbENoYXIiLCJzeW1ib2xUYWciLCJpc1N5bWJvbCIsIklORklOSVRZIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsImJhc2VUb1N0cmluZyIsInJlVW5lc2NhcGVkSHRtbCIsInJlSGFzVW5lc2NhcGVkSHRtbCIsImVzY2FwZSIsInJlRXNjYXBlIiwicmVFdmFsdWF0ZSIsInRlbXBsYXRlU2V0dGluZ3MiLCJyZUVtcHR5U3RyaW5nTGVhZGluZyIsInJlRW1wdHlTdHJpbmdNaWRkbGUiLCJyZUVtcHR5U3RyaW5nVHJhaWxpbmciLCJyZUVzVGVtcGxhdGUiLCJyZU5vTWF0Y2giLCJyZVVuZXNjYXBlZFN0cmluZyIsInRlbXBsYXRlIiwib3B0aW9ucyIsInNldHRpbmdzIiwiaW1wb3J0cyIsIl8iLCJpbXBvcnRzS2V5cyIsImltcG9ydHNWYWx1ZXMiLCJpc0VzY2FwaW5nIiwiaXNFdmFsdWF0aW5nIiwiaW50ZXJwb2xhdGUiLCJyZURlbGltaXRlcnMiLCJldmFsdWF0ZSIsInNvdXJjZVVSTCIsImVzY2FwZVZhbHVlIiwiaW50ZXJwb2xhdGVWYWx1ZSIsImVzVGVtcGxhdGVWYWx1ZSIsImV2YWx1YXRlVmFsdWUiLCJvZmZzZXQiLCJzbGljZSIsInZhcmlhYmxlIiwiYXJyYXlFYWNoIiwiY3JlYXRlQmFzZUZvciIsImZyb21SaWdodCIsImtleXNGdW5jIiwiaXRlcmFibGUiLCJiYXNlRm9yIiwiYmFzZUZvck93biIsImNyZWF0ZUJhc2VFYWNoIiwiZWFjaEZ1bmMiLCJjb2xsZWN0aW9uIiwiYmFzZUVhY2giLCJjYXN0RnVuY3Rpb24iLCJmb3JFYWNoIiwibGlzdENhY2hlQ2xlYXIiLCJfX2RhdGFfXyIsInNpemUiLCJhc3NvY0luZGV4T2YiLCJhcnJheVByb3RvIiwic3BsaWNlIiwibGlzdENhY2hlRGVsZXRlIiwibGFzdEluZGV4IiwicG9wIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTGlzdENhY2hlIiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJzZXQiLCJnZXQiLCJoYXMiLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwiTWFwIiwibmF0aXZlQ3JlYXRlIiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsIkhBU0hfVU5ERUZJTkVEIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSGFzaCIsIm1hcENhY2hlQ2xlYXIiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwibWFwIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSIsIkxBUkdFX0FSUkFZX1NJWkUiLCJzdGFja1NldCIsInBhaXJzIiwiU3RhY2siLCJhc3NpZ25NZXJnZVZhbHVlIiwiYWxsb2NVbnNhZmUiLCJjbG9uZUJ1ZmZlciIsImJ1ZmZlciIsImlzRGVlcCIsImNvcHkiLCJVaW50OEFycmF5IiwiY2xvbmVBcnJheUJ1ZmZlciIsImFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsImNsb25lVHlwZWRBcnJheSIsInR5cGVkQXJyYXkiLCJieXRlT2Zmc2V0IiwiY29weUFycmF5Iiwib2JqZWN0Q3JlYXRlIiwiY3JlYXRlIiwiYmFzZUNyZWF0ZSIsImluaXRDbG9uZU9iamVjdCIsImlzQXJyYXlMaWtlT2JqZWN0Iiwic2FmZUdldCIsInRvUGxhaW5PYmplY3QiLCJiYXNlTWVyZ2VEZWVwIiwibWVyZ2VGdW5jIiwic3RhY2siLCJzdGFja2VkIiwiaXNDb21tb24iLCJpc1R5cGVkIiwiYmFzZU1lcmdlIiwibWVyZ2UiLCJ2YWx1ZXMiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU2V0Q2FjaGUiLCJhZGQiLCJhcnJheVNvbWUiLCJwcmVkaWNhdGUiLCJjYWNoZUhhcyIsImNhY2hlIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiZXF1YWxBcnJheXMiLCJiaXRtYXNrIiwiZXF1YWxGdW5jIiwiaXNQYXJ0aWFsIiwiYXJyTGVuZ3RoIiwib3RoTGVuZ3RoIiwic2VlbiIsImFyclZhbHVlIiwib3RoVmFsdWUiLCJjb21wYXJlZCIsIm90aEluZGV4IiwibWFwVG9BcnJheSIsInNldFRvQXJyYXkiLCJzeW1ib2xWYWx1ZU9mIiwidmFsdWVPZiIsImVxdWFsQnlUYWciLCJjb252ZXJ0IiwiYXJyYXlQdXNoIiwiYmFzZUdldEFsbEtleXMiLCJzeW1ib2xzRnVuYyIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJzdHViQXJyYXkiLCJuYXRpdmVHZXRTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0U3ltYm9scyIsInN5bWJvbCIsImdldEFsbEtleXMiLCJlcXVhbE9iamVjdHMiLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwic2tpcEN0b3IiLCJvYmpDdG9yIiwib3RoQ3RvciIsIkRhdGFWaWV3IiwiUHJvbWlzZSIsIlNldCIsIldlYWtNYXAiLCJwcm9taXNlVGFnIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiZ2V0VGFnIiwiQXJyYXlCdWZmZXIiLCJyZXNvbHZlIiwiY3RvclN0cmluZyIsImJhc2VJc0VxdWFsRGVlcCIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwib2JqVW53cmFwcGVkIiwib3RoVW53cmFwcGVkIiwiYmFzZUlzRXF1YWwiLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsImlzU3RyaWN0Q29tcGFyYWJsZSIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiYmFzZU1hdGNoZXMiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwiaXNLZXkiLCJGVU5DX0VSUk9SX1RFWFQiLCJtZW1vaXplIiwicmVzb2x2ZXIiLCJUeXBlRXJyb3IiLCJtZW1vaXplZCIsIkNhY2hlIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwic3RyaW5nVG9QYXRoIiwiY2hhckNvZGVBdCIsIm51bWJlciIsInF1b3RlIiwic3ViU3RyaW5nIiwiY2FzdFBhdGgiLCJ0b0tleSIsImJhc2VHZXQiLCJkZWZhdWx0VmFsdWUiLCJiYXNlSGFzSW4iLCJoYXNQYXRoIiwiaGFzRnVuYyIsImhhc0luIiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsImJhc2VQcm9wZXJ0eSIsImJhc2VQcm9wZXJ0eURlZXAiLCJwcm9wZXJ0eSIsImJhc2VJdGVyYXRlZSIsImJhc2VNYXAiLCJiYXNlU29ydEJ5IiwiY29tcGFyZXIiLCJzb3J0IiwiY29tcGFyZUFzY2VuZGluZyIsInZhbElzRGVmaW5lZCIsInZhbElzTnVsbCIsInZhbElzUmVmbGV4aXZlIiwidmFsSXNTeW1ib2wiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwiY29tcGFyZU11bHRpcGxlIiwib3JkZXJzIiwib2JqQ3JpdGVyaWEiLCJjcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwib3JkZXIiLCJiYXNlT3JkZXJCeSIsIml0ZXJhdGVlcyIsIm9yZGVyQnkiLCJub29wIiwiY3JlYXRlU2V0IiwiRmVlZCIsImNvbmZpZyIsImRlZmF1bHQiLCJfc2V0dGluZ3MiLCJfbWVyZ2UiLCJpbml0IiwiZmVlZCIsInJzc1RvSnNvbiIsInJzc1VybCIsIl9mb3JFYWNoIiwidXJsIiwidGhpcyIsIl9yZXF1ZXN0IiwiX3Byb2Nlc3MiLCJKU09OIiwicGFyc2UiLCJ0aGlzJDEiLCJjb21waWxlZCIsIl9yZW5kZXIiLCJlbCIsInF1ZXJ5U2VsZWN0b3IiLCJzZWxlY3RvciIsInJlamVjdCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwiZXZlbnQiLCJfeGhyIiwidGFyZ2V0IiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsIm9udGltZW91dCIsIm9wZW4iLCJzZW5kIiwibG9nIiwiX3ZhbHVlcyIsInRlbXBsYXRlcyIsImpvaW4iLCJfdGVtcGxhdGUiLCJtZWRpdW0iLCJvcGVuZXIiLCJoZWFkZXIiLCJwb3N0cyIsImNsb3NlciIsInBvc3RFeGNlcnB0TGVuZ3RoIiwiaXRlbXMiLCJwb3N0IiwiZXhjZXJwdCIsImRhdGUiLCJkZXNjcmlwdGlvbiIsInN1YnN0ciIsIm1pbiIsImxhc3RJbmRleE9mIiwicHViRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInBvc3REYXRlTG9jYWwiLCJwb3N0RGF0ZUZvcm1hdCIsIm1lcmdlZCIsImNvbmNhdCIsIl9vcmRlckJ5IiwidGl0bGUiLCJ0aXRsZVVybCIsInByb2ZpbGVJbWciLCJmb250U2l6ZSIsInJhdGlvUHJvZmlsZSIsInBvc3RCb3JkZXJDb2xvciIsInBvc3RJbWdIZWlnaHQiLCJwb3N0RXhjZXJwdFRyYWlsIiwicG9zdEN0YVRleHQiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJwb3N0RGF0ZVRpdGxlIiwiY2xhc3NlcyIsIndyYXBwZXIiLCJmZWVkSXRlbSIsImxpbmsiLCJ0aHVtYm5haWwiLCJpdGVtRm9vdGVyIiwiY3RhIiwidW5pcXVlIiwiVG9nZ2xlIiwibmFtZXNwYWNlIiwiaW5hY3RpdmVDbGFzcyIsImFjdGl2ZUNsYXNzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1hdGNoZXMiLCJwcmV2ZW50RGVmYXVsdCIsIl90b2dnbGUiLCJnZXRBdHRyaWJ1dGUiLCJlbGVtZW50VG9nZ2xlIiwiZGF0YXNldCIsInVuZG8iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwiaSIsImVsQXJpYVJvbGVzIiwidGFyZ2V0QXJpYVJvbGVzIiwiY29udGFpbnMiLCJoYXNoIiwiVHJhY2siLCJ0cmFja0tleSIsInRyYWNrRGF0YSIsImNsaWNrIiwiZCIsInBhdGhuYW1lIiwid3QiLCJ3ZWJ0cmVuZHMiLCJnYSIsImd0YWciLCJ2aWV3IiwiYXBwIiwiZ3RhZ1ZpZXciLCJhc3NpZ24iLCJ3dGQiLCJhcmdzYSIsImZsYXRNYXAiLCJrIiwiV2VidHJlbmRzIiwibXVsdGlUcmFjayIsInVyaSIsImZpbmQiLCJlbGVtZW50IiwiYXBwX25hbWUiLCJzY3JlZW5fbmFtZSIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwiaXNVbmRlZiIsInYiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsIm9iaiIsIl90b1N0cmluZyIsInRvUmF3VHlwZSIsImlzUmVnRXhwIiwiaXNWYWxpZEFycmF5SW5kZXgiLCJ2YWwiLCJwYXJzZUZsb2F0IiwiZmxvb3IiLCJpc0Zpbml0ZSIsImlzUHJvbWlzZSIsInN0cmluZ2lmeSIsInRvTnVtYmVyIiwiaXNOYU4iLCJtYWtlTWFwIiwic3RyIiwiZXhwZWN0c0xvd2VyQ2FzZSIsImxpc3QiLCJzcGxpdCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleE9mIiwiaGFzT3duIiwiY2FjaGVkIiwiZm4iLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsImMiLCJ0b1VwcGVyQ2FzZSIsImNhcGl0YWxpemUiLCJjaGFyQXQiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsInBvbHlmaWxsQmluZCIsImN0eCIsImJvdW5kRm4iLCJhIiwibCIsIl9sZW5ndGgiLCJuYXRpdmVCaW5kIiwiYmluZCIsInRvQXJyYXkiLCJyZXQiLCJleHRlbmQiLCJ0byIsIl9mcm9tIiwidG9PYmplY3QiLCJyZXMiLCJiIiwibm8iLCJnZW5TdGF0aWNLZXlzIiwibW9kdWxlcyIsInJlZHVjZSIsIm0iLCJzdGF0aWNLZXlzIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheUIiLCJldmVyeSIsImdldFRpbWUiLCJrZXlzQSIsImtleXNCIiwibG9vc2VJbmRleE9mIiwib25jZSIsImNhbGxlZCIsIlNTUl9BVFRSIiwiQVNTRVRfVFlQRVMiLCJMSUZFQ1lDTEVfSE9PS1MiLCJvcHRpb25NZXJnZVN0cmF0ZWdpZXMiLCJzaWxlbnQiLCJwcm9kdWN0aW9uVGlwIiwiZGV2dG9vbHMiLCJwZXJmb3JtYW5jZSIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsImFzeW5jIiwiX2xpZmVjeWNsZUhvb2tzIiwidW5pY29kZUxldHRlcnMiLCJpc1Jlc2VydmVkIiwiZGVmIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiYmFpbFJFIiwicGFyc2VQYXRoIiwic2VnbWVudHMiLCJoYXNQcm90byIsImluQnJvd3NlciIsImluV2VleCIsIldYRW52aXJvbm1lbnQiLCJwbGF0Zm9ybSIsIndlZXhQbGF0Zm9ybSIsIlVBIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsImlzUGhhbnRvbUpTIiwiaXNGRiIsIm5hdGl2ZVdhdGNoIiwid2F0Y2giLCJzdXBwb3J0c1Bhc3NpdmUiLCJvcHRzIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJlbnYiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiaGFzU3ltYm9sIiwiUmVmbGVjdCIsIm93bktleXMiLCJfU2V0Iiwid2FybiIsInRpcCIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJmb3JtYXRDb21wb25lbnROYW1lIiwiaGFzQ29uc29sZSIsImNsYXNzaWZ5UkUiLCJjbGFzc2lmeSIsIm1zZyIsInZtIiwidHJhY2UiLCJpbmNsdWRlRmlsZSIsIiRyb290IiwiY2lkIiwiX2lzVnVlIiwiJG9wdGlvbnMiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsIkRlcCIsImlkIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsIm5vdGlmeSIsInVwZGF0ZSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsInBvcFRhcmdldCIsIlZOb2RlIiwiY2hpbGRyZW4iLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsImFzeW5jRmFjdG9yeSIsIm5zIiwiZm5Db250ZXh0IiwiZm5PcHRpb25zIiwiZm5TY29wZUlkIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwYXJlbnQiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiY2hpbGQiLCJjcmVhdGVFbXB0eVZOb2RlIiwibm9kZSIsImNyZWF0ZVRleHRWTm9kZSIsImNsb25lVk5vZGUiLCJ2bm9kZSIsImNsb25lZCIsImFycmF5TWV0aG9kcyIsIm1ldGhvZHNUb1BhdGNoIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJzaG91bGRPYnNlcnZlIiwidG9nZ2xlT2JzZXJ2aW5nIiwiT2JzZXJ2ZXIiLCJ2bUNvdW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJvYnNlcnZlIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjaGlsZE9iIiwicmVhY3RpdmVHZXR0ZXIiLCJkZXBlbmRBcnJheSIsInJlYWN0aXZlU2V0dGVyIiwibmV3VmFsIiwiZGVsIiwic3RyYXRzIiwicHJvcHNEYXRhIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJkZWR1cGVIb29rcyIsImhvb2tzIiwiaG9vayIsIm1lcmdlQXNzZXRzIiwiYXNzZXJ0T2JqZWN0VHlwZSIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwidmFsaWRhdGVDb21wb25lbnROYW1lIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwiZGVmJCQxIiwibWVyZ2VPcHRpb25zIiwiX2Jhc2UiLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImJvb2xlYW5JbmRleCIsImdldFR5cGVJbmRleCIsIkJvb2xlYW4iLCJzdHJpbmdJbmRleCIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkT2JzZXJ2ZSIsImFzc2VydFByb3AiLCJfcHJvcHMiLCJnZXRUeXBlIiwicmVxdWlyZWQiLCJ2YWxpZCIsImV4cGVjdGVkVHlwZXMiLCJhc3NlcnRlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZXhwZWN0ZWRUeXBlIiwiZ2V0SW52YWxpZFR5cGVNZXNzYWdlIiwidmFsaWRhdG9yIiwic2ltcGxlQ2hlY2tSRSIsInQiLCJpc1NhbWVUeXBlIiwibGVuIiwicmVjZWl2ZWRUeXBlIiwiZXhwZWN0ZWRWYWx1ZSIsInN0eWxlVmFsdWUiLCJyZWNlaXZlZFZhbHVlIiwiaXNFeHBsaWNhYmxlIiwiaXNCb29sZWFuIiwiTnVtYmVyIiwiZXhwbGljaXRUeXBlcyIsInNvbWUiLCJlbGVtIiwiaGFuZGxlRXJyb3IiLCJlcnIiLCJpbmZvIiwiY3VyIiwiZXJyb3JDYXB0dXJlZCIsImNhcHR1cmUiLCJnbG9iYWxIYW5kbGVFcnJvciIsImludm9rZVdpdGhFcnJvckhhbmRsaW5nIiwiaGFuZGxlciIsImxvZ0Vycm9yIiwiaXNVc2luZ01pY3JvVGFzayIsImNhbGxiYWNrcyIsInBlbmRpbmciLCJmbHVzaENhbGxiYWNrcyIsImNvcGllcyIsInRpbWVyRnVuYyIsInAiLCJzZXRUaW1lb3V0IiwiTXV0YXRpb25PYnNlcnZlciIsImNvdW50ZXIiLCJvYnNlcnZlciIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJjaGFyYWN0ZXJEYXRhIiwic2V0SW1tZWRpYXRlIiwibmV4dFRpY2siLCJjYiIsIl9yZXNvbHZlIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJ3YXJuUmVzZXJ2ZWRQcmVmaXgiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiJGRhdGEiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5Iiwic2Vlbk9iamVjdHMiLCJ0cmF2ZXJzZSIsIl90cmF2ZXJzZSIsImlzQSIsImlzRnJvemVuIiwiZGVwSWQiLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY3JlYXRlRm5JbnZva2VyIiwiZm5zIiwiaW52b2tlciIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9sZCIsInBhcmFtcyIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJhdHRycyIsImFsdEtleSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsInNoaWZ0IiwiX2lzVkxpc3QiLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsInByb3ZpZGVLZXkiLCJwcm92aWRlRGVmYXVsdCIsInJlc29sdmVTbG90cyIsInNsb3RzIiwic2xvdCIsImlzV2hpdGVzcGFjZSIsIm5vcm1hbGl6ZVNjb3BlZFNsb3RzIiwibm9ybWFsU2xvdHMiLCJwcmV2U2xvdHMiLCJfbm9ybWFsaXplZCIsIiRzdGFibGUiLCJub3JtYWxpemVTY29wZWRTbG90IiwicHJveHlOb3JtYWxTbG90IiwicHJveHkiLCJyZW5kZXJMaXN0IiwiaXRlcmF0b3IiLCJuZXh0IiwiZG9uZSIsInJlbmRlclNsb3QiLCJmYWxsYmFjayIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCIkc2NvcGVkU2xvdHMiLCJub2RlcyIsIiRzbG90cyIsIiRjcmVhdGVFbGVtZW50IiwicmVzb2x2ZUZpbHRlciIsImlzS2V5Tm90TWF0Y2giLCJleHBlY3QiLCJhY3R1YWwiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbktleUNvZGUiLCJldmVudEtleU5hbWUiLCJidWlsdEluS2V5TmFtZSIsIm1hcHBlZEtleUNvZGUiLCJiaW5kT2JqZWN0UHJvcHMiLCJhc1Byb3AiLCJpc1N5bmMiLCJkb21Qcm9wcyIsImNhbWVsaXplZEtleSIsIiRldmVudCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJfc3RhdGljVHJlZXMiLCJzdGF0aWNSZW5kZXJGbnMiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJleGlzdGluZyIsIm91cnMiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJoYXNEeW5hbWljS2V5cyIsImJpbmREeW5hbWljS2V5cyIsImJhc2VPYmoiLCJwcmVwZW5kTW9kaWZpZXIiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIl9kIiwiX3AiLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsImNvbnRleHRWbSIsIl9vcmlnaW5hbCIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsImxpc3RlbmVycyIsImluamVjdGlvbnMiLCJzY29wZWRTbG90cyIsIl9zY29wZUlkIiwiX2MiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibWVyZ2VQcm9wcyIsInJlbmRlckNvbnRleHQiLCJjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0Iiwidm5vZGVzIiwiY2xvbmUiLCJkZXZ0b29sc01ldGEiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwiaHlkcmF0aW5nIiwiX2lzRGVzdHJveWVkIiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCJhY3RpdmVJbnN0YW5jZSIsIiRtb3VudCIsIm9sZFZub2RlIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJpbnNlcnQiLCJfaXNNb3VudGVkIiwiY2FsbEhvb2siLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkZXN0cm95IiwiJGRlc3Ryb3kiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsImFic3RyYWN0IiwiaW5zdGFsbENvbXBvbmVudEhvb2tzIiwiX2lzQ29tcG9uZW50IiwiX3BhcmVudFZub2RlIiwiaW5saW5lVGVtcGxhdGUiLCJ0b01lcmdlIiwiX21lcmdlZCIsIm1lcmdlSG9vayQxIiwiZjEiLCJmMiIsImNhbGxiYWNrIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiaXMiLCIkdm5vZGUiLCJwcmUiLCJhcHBseU5TIiwicmVnaXN0ZXJEZWVwQmluZGluZ3MiLCJmb3JjZSIsInN0eWxlIiwiY2xhc3MiLCJpbml0UmVuZGVyIiwiX3Zub2RlIiwicGFyZW50Vm5vZGUiLCJfcmVuZGVyQ2hpbGRyZW4iLCJwYXJlbnREYXRhIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiX3BhcmVudExpc3RlbmVycyIsImN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSIsInJlbmRlck1peGluIiwiVnVlIiwiJG5leHRUaWNrIiwicmVuZGVyRXJyb3IiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwiZmFjdG9yeSIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwib3duZXIiLCJvd25lcnMiLCJzeW5jIiwiZm9yY2VSZW5kZXIiLCJyZW5kZXJDb21wbGV0ZWQiLCIkZm9yY2VVcGRhdGUiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsInRpbWVvdXQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uIiwicmVtb3ZlJDEiLCIkb2ZmIiwiX3RhcmdldCIsIm9uY2VIYW5kbGVyIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJob29rUkUiLCIkb25jZSIsImNicyIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJzZXRBY3RpdmVJbnN0YW5jZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsImluaXRMaWZlY3ljbGUiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2luYWN0aXZlIiwiX2RpcmVjdEluYWN0aXZlIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJyZXN0b3JlQWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfX3Z1ZV9fIiwidGVhcmRvd24iLCJfd2F0Y2hlcnMiLCJfZGF0YSIsIm1vdW50Q29tcG9uZW50IiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiV2F0Y2hlciIsImJlZm9yZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzRHluYW1pY1Njb3BlZFNsb3QiLCJuZWVkc0ZvcmNlVXBkYXRlIiwiJGF0dHJzIiwiJGxpc3RlbmVycyIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiaXNJbkluYWN0aXZlVHJlZSIsImRpcmVjdCIsImoiLCJNQVhfVVBEQVRFX0NPVU5UIiwicXVldWUiLCJhY3RpdmF0ZWRDaGlsZHJlbiIsImNpcmN1bGFyIiwid2FpdGluZyIsImZsdXNoaW5nIiwicmVzZXRTY2hlZHVsZXJTdGF0ZSIsImN1cnJlbnRGbHVzaFRpbWVzdGFtcCIsImdldE5vdyIsImNyZWF0ZUV2ZW50IiwidGltZVN0YW1wIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJydW4iLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsImVtaXQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJpc1JlbmRlcldhdGNoZXIiLCJkZWVwIiwibGF6eSIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJjbGVhbnVwRGVwcyIsInRtcCIsIm9sZFZhbHVlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJoeXBoZW5hdGVkS2V5IiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwiaXNTU1IiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCJzaG91bGRDYWNoZSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlR2V0dGVySW52b2tlciIsImNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsInVpZCQzIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJpbml0VXNlIiwidXNlIiwicGx1Z2luIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl9pbnN0YWxsZWRQbHVnaW5zIiwidW5zaGlmdCIsImluc3RhbGwiLCJpbml0TWl4aW4kMSIsIm1peGluIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnROYW1lIiwicHJ1bmVDYWNoZSIsImtlZXBBbGl2ZUluc3RhbmNlIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsImN1cnJlbnQiLCJjYWNoZWQkJDEiLCJwYXR0ZXJuVHlwZXMiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNyZWF0ZWQiLCJkZXN0cm95ZWQiLCJtb3VudGVkIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJvYnNlcnZhYmxlIiwic3NyQ29udGV4dCIsInZlcnNpb24iLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlIiwiY29udmVydEVudW1lcmF0ZWRWYWx1ZSIsImlzRmFsc3lBdHRyVmFsdWUiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwic2VsZWN0ZWQiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsInNldFN0eWxlU2NvcGUiLCJzY29wZUlkIiwibm9kZU9wcyIsInJlZiIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpc1Vua25vd25FbGVtZW50JCQxIiwiaW5WUHJlIiwiaWdub3JlIiwiY3JlYXRpbmdFbG1JblZQcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJuZXN0ZWQiLCJvd25lckFycmF5Iiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJlbmQiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsIl9sZWF2ZUNiIiwicGF0Y2hhYmxlIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImNhbGxIb29rJDEiLCJvbGRBcmciLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwiaW5oZXJpdEF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJiYXNlU2V0QXR0ciIsInNldEF0dHJpYnV0ZU5TIiwiX19pZXBoIiwiYmxvY2tlciIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwicHJldiIsImZpbHRlcnMiLCJ0cmltIiwicHVzaEZpbHRlciIsIndyYXBGaWx0ZXIiLCJiYXNlV2FybiIsInJhbmdlIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJkeW5hbWljIiwicmFuZ2VTZXRJdGVtIiwicGxhaW4iLCJhZGRBdHRyIiwiZHluYW1pY0F0dHJzIiwiYWRkUmF3QXR0ciIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiYWRkRGlyZWN0aXZlIiwiaXNEeW5hbWljQXJnIiwicHJlcGVuZE1vZGlmaWVyTWFya2VyIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJyaWdodCIsIm1pZGRsZSIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRSYXdCaW5kaW5nQXR0ciIsInJhd0F0dHJzTWFwIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJyZW1vdmVGcm9tTWFwIiwiZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgiLCJnZW5Db21wb25lbnRNb2RlbCIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJwYXJzZU1vZGVsIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwiZW9mIiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0IiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJnZW5TZWxlY3QiLCJnZW5DaGVja2JveE1vZGVsIiwiZ2VuUmFkaW9Nb2RlbCIsImdlbkRlZmF1bHRNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsInNlbGVjdGVkVmFsIiwiY29kZSIsInR5cGVCaW5kaW5nIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyJDEiLCJyZW1vdmUkMiIsInVzZU1pY3JvdGFza0ZpeCIsImFkZCQxIiwiYXR0YWNoZWRUaW1lc3RhbXAiLCJfd3JhcHBlciIsImN1cnJlbnRUYXJnZXQiLCJvd25lckRvY3VtZW50IiwidXBkYXRlRE9NTGlzdGVuZXJzIiwic3ZnQ29udGFpbmVyIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc05vdEluRm9jdXNBbmREaXJ0eSIsImlzRGlydHlXaXRoTW9kaWZpZXJzIiwibm90SW5Gb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsIm5vcm1hbGl6ZVN0eWxlQmluZGluZyIsInN0YXRpY1N0eWxlIiwiYmluZGluZ1N0eWxlIiwiZ2V0U3R5bGUiLCJjaGVja0NoaWxkIiwic3R5bGVEYXRhIiwiY3NzVmFyUkUiLCJpbXBvcnRhbnRSRSIsInNldFByb3AiLCJzZXRQcm9wZXJ0eSIsIm5vcm1hbGl6ZWROYW1lIiwibm9ybWFsaXplIiwidmVuZG9yTmFtZXMiLCJlbXB0eVN0eWxlIiwiY2FwTmFtZSIsInVwZGF0ZVN0eWxlIiwib2xkU3RhdGljU3R5bGUiLCJvbGRTdHlsZUJpbmRpbmciLCJub3JtYWxpemVkU3R5bGUiLCJvbGRTdHlsZSIsIm5ld1N0eWxlIiwid2hpdGVzcGFjZVJFIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsInRhciIsInJlc29sdmVUcmFuc2l0aW9uIiwiY3NzIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJlbnRlckNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImxlYXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwiaGFzVHJhbnNpdGlvbiIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvblByb3AiLCJhbmltYXRpb25FbmRFdmVudCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ud2Via2l0dHJhbnNpdGlvbmVuZCIsIm9uYW5pbWF0aW9uZW5kIiwib253ZWJraXRhbmltYXRpb25lbmQiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJ0cmFuc2l0aW9uQ2xhc3NlcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwiZW5kZWQiLCJvbkVuZCIsInByb3BDb3VudCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJhcHBlYXIiLCJzdGFydENsYXNzIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiYmVmb3JlQXBwZWFyIiwiYmVmb3JlRW50ZXIiLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImFmdGVyQXBwZWFyIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkSG9vayIsImFwcGVhckNhbmNlbGxlZCIsImVudGVyQ2FuY2VsbGVkIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiZHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsImxlYXZlQ2FuY2VsbGVkIiwiYWZ0ZXJMZWF2ZSIsImRlbGF5TGVhdmUiLCJwZXJmb3JtTGVhdmUiLCJiZWZvcmVMZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJ0cmlnZ2VyIiwiZGlyZWN0aXZlIiwiX3ZPcHRpb25zIiwic2V0U2VsZWN0ZWQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwicGxhY2Vob2xkZXIiLCJoIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsImlzTm90VGV4dE5vZGUiLCJpc1ZTaG93RGlyZWN0aXZlIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJiZWZvcmVNb3VudCIsImtlcHQiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwicmVtb3ZlZCIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJfcmVmbG93Iiwib2Zmc2V0SGVpZ2h0IiwibW92ZWQiLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsImRlZmF1bHRUYWdSRSIsInJlZ2V4RXNjYXBlUkUiLCJidWlsZFJlZ2V4IiwiZGVsaW1pdGVycyIsImNsb3NlIiwicGFyc2VUZXh0IiwidGFnUkUiLCJ0b2tlbnMiLCJyYXdUb2tlbnMiLCJ0b2tlblZhbHVlIiwidHJhbnNmb3JtTm9kZSIsImNsYXNzQmluZGluZyIsImdlbkRhdGEiLCJrbGFzcyQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQxIiwic3R5bGUkMSIsImRlY29kZXIiLCJoZSIsImRlY29kZSIsImh0bWwiLCJpc1VuYXJ5VGFnIiwiY2FuQmVMZWZ0T3BlblRhZyIsImlzTm9uUGhyYXNpbmdUYWciLCJhdHRyaWJ1dGUiLCJkeW5hbWljQXJnQXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImlzSWdub3JlTmV3bGluZVRhZyIsInNob3VsZElnbm9yZUZpcnN0TmV3bGluZSIsImRlY29kZUF0dHIiLCJzaG91bGREZWNvZGVOZXdsaW5lcyIsInJlIiwicGFyc2VIVE1MIiwiZXhwZWN0SFRNTCIsImlzVW5hcnlUYWckJDEiLCJjYW5CZUxlZnRPcGVuVGFnJCQxIiwibGFzdFRhZyIsInRleHRFbmQiLCJjb21tZW50RW5kIiwic2hvdWxkS2VlcENvbW1lbnQiLCJzdWJzdHJpbmciLCJhZHZhbmNlIiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCIsImNoYXJzIiwiZW5kVGFnTGVuZ3RoIiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsInNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiIsIm91dHB1dFNvdXJjZVJhbmdlIiwibG93ZXJDYXNlZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJzdHJpcFBhcmVuc1JFIiwiZHluYW1pY0FyZ1JFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwic2xvdFJFIiwibGluZUJyZWFrUkUiLCJ3aGl0ZXNwYWNlUkUkMSIsImludmFsaWRBdHRyaWJ1dGVSRSIsImRlY29kZUhUTUxDYWNoZWQiLCJlbXB0eVNsb3RTY29wZVRva2VuIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJtYXliZUNvbXBvbmVudCIsImNyZWF0ZUFTVEVsZW1lbnQiLCJtYWtlQXR0cnNNYXAiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJ3aGl0ZXNwYWNlT3B0aW9uIiwid2hpdGVzcGFjZSIsImN1cnJlbnRQYXJlbnQiLCJpblByZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiY2xvc2VFbGVtZW50IiwidHJpbUVuZGluZ1doaXRlc3BhY2UiLCJwcm9jZXNzZWQiLCJwcm9jZXNzRWxlbWVudCIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImNoZWNrUm9vdENvbnN0cmFpbnRzIiwiYWRkSWZDb25kaXRpb24iLCJibG9jayIsImZvcmJpZGRlbiIsInByb2Nlc3NJZkNvbmRpdGlvbnMiLCJzbG90U2NvcGUiLCJzbG90VGFyZ2V0IiwibGFzdE5vZGUiLCJjb21tZW50cyIsImd1YXJkSUVTVkdCdWciLCJjdW11bGF0ZWQiLCJpc0ZvcmJpZGRlblRhZyIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJpc1RleHRUYWciLCJwcm9jZXNzS2V5IiwicHJvY2Vzc1JlZiIsInByb2Nlc3NTbG90Q29udGVudCIsInByb2Nlc3NTbG90T3V0bGV0IiwicHJvY2Vzc0NvbXBvbmVudCIsInByb2Nlc3NBdHRycyIsImZvciIsIml0ZXJhdG9yMiIsIml0ZXJhdG9yMSIsImNoZWNrSW5Gb3IiLCJwYXJzZUZvciIsImluTWF0Y2giLCJhbGlhcyIsIml0ZXJhdG9yTWF0Y2giLCJmaW5kUHJldkVsZW1lbnQiLCJjb25kaXRpb24iLCJpZkNvbmRpdGlvbnMiLCJzbG90VGFyZ2V0RHluYW1pYyIsInNsb3RCaW5kaW5nIiwiZ2V0U2xvdE5hbWUiLCJzbG90Q29udGFpbmVyIiwic2xvdE5hbWUiLCJzeW5jR2VuIiwiaXNEeW5hbWljIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsInByZVRyYW5zZm9ybU5vZGUiLCJpZkNvbmRpdGlvbiIsImlmQ29uZGl0aW9uRXh0cmEiLCJoYXNFbHNlIiwiZWxzZUlmQ29uZGl0aW9uIiwiYnJhbmNoMCIsImNsb25lQVNURWxlbWVudCIsImJyYW5jaDEiLCJicmFuY2gyIiwibW9kZWwkMSIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsImJhc2VPcHRpb25zIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJmbkludm9rZVJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsImRvd24iLCJrZXlOYW1lcyIsImdlbkd1YXJkIiwibW9kaWZpZXJDb2RlIiwic3RvcCIsImN0cmwiLCJhbHQiLCJtZXRhIiwiZ2VuSGFuZGxlcnMiLCJwcmVmaXgiLCJzdGF0aWNIYW5kbGVycyIsImR5bmFtaWNIYW5kbGVycyIsImhhbmRsZXJDb2RlIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiaXNGdW5jdGlvbkludm9jYXRpb24iLCJnZW5Nb2RpZmllckNvZGUiLCJrZXlNb2RpZmllciIsImdlbktleUZpbHRlciIsImdlbkZpbHRlckNvZGUiLCJrZXlWYWwiLCJrZXlDb2RlIiwia2V5TmFtZSIsIndyYXBMaXN0ZW5lcnMiLCJiaW5kJDEiLCJ3cmFwRGF0YSIsImJhc2VEaXJlY3RpdmVzIiwiY2xvYWsiLCJDb2RlZ2VuU3RhdGUiLCJkYXRhR2VuRm5zIiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJzdGF0ZSIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJvcmlnaW5hbFByZVN0YXRlIiwiYWx0R2VuIiwiYWx0RW1wdHkiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsImFsdEhlbHBlciIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJjb250YWluc1Nsb3RDaGlsZCIsImdlblNjb3BlZFNsb3QiLCJpc0xlZ2FjeVN5bnRheCIsInJldmVyc2VQcm94eSIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZ2V0Tm9ybWFsaXphdGlvblR5cGUiLCJnZW5Ob2RlIiwibmVlZHNOb3JtYWxpemF0aW9uIiwiZ2VuQ29tbWVudCIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsInN0YXRpY1Byb3BzIiwiZHluYW1pY1Byb3BzIiwicHJvaGliaXRlZEtleXdvcmRSRSIsInVuYXJ5T3BlcmF0b3JzUkUiLCJzdHJpcFN0cmluZ1JFIiwiZGV0ZWN0RXJyb3JzIiwiY2hlY2tOb2RlIiwiY2hlY2tGb3IiLCJjaGVja0V2ZW50IiwiY2hlY2tFeHByZXNzaW9uIiwic3RpcHBlZCIsImtleXdvcmRNYXRjaCIsImNoZWNrSWRlbnRpZmllciIsImlkZW50IiwiZ2VuZXJhdGVDb2RlRnJhbWUiLCJsaW5lcyIsImxpbmVMZW5ndGgiLCJwYWQiLCJjcmVhdGVGdW5jdGlvbiIsImVycm9ycyIsImNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4iLCJjb21waWxlIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwid2FybiQkMSIsInRpcHMiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJsZWFkaW5nU3BhY2VMZW5ndGgiLCJkaXYiLCJnZXRTaG91bGREZWNvZGUiLCJocmVmIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiLCJTZWxlY3REYXRhIiwiU2VsZWN0IiwiU2VsZWN0Q29tcG9uZW50IiwiX2NvbnN0YW50cyIsImRhdGFIYW5kbGVyIiwibmV3RGF0YSIsImNoYXJ0IiwiX2NoYXJ0IiwibmV3RGF0YXNldExhYmVscyIsImRhdGFzZXRzIiwib2xkRGF0YXNldExhYmVscyIsIm9sZExhYmVscyIsIm5ld0xhYmVscyIsIm9sZERhdGFzZXRLZXlzIiwibmV3RGF0YXNldEtleXMiLCJkZWxldGlvbktleXMiLCJkZWxldGlvbktleSIsImxhYmVscyIsInhMYWJlbHMiLCJ5TGFiZWxzIiwicmVuZGVyQ2hhcnQiLCJjaGFydERhdGEiLCJyZWFjdGl2ZURhdGEiLCJyZWFjdGl2ZVByb3AiLCJob29rQ2FsbGJhY2siLCJzZXRIb29rQ2FsbGJhY2siLCJpbnB1dCIsImlzT2JqZWN0RW1wdHkiLCJpc1VuZGVmaW5lZCIsImlzTnVtYmVyIiwiaXNEYXRlIiwiaGFzT3duUHJvcCIsImNyZWF0ZVVUQyIsImZvcm1hdCIsImxvY2FsZSIsInN0cmljdCIsImNyZWF0ZUxvY2FsT3JVVEMiLCJ1dGMiLCJkZWZhdWx0UGFyc2luZ0ZsYWdzIiwiZW1wdHkiLCJ1bnVzZWRUb2tlbnMiLCJ1bnVzZWRJbnB1dCIsIm92ZXJmbG93IiwiY2hhcnNMZWZ0T3ZlciIsIm51bGxJbnB1dCIsImludmFsaWRNb250aCIsImludmFsaWRGb3JtYXQiLCJ1c2VySW52YWxpZGF0ZWQiLCJpc28iLCJwYXJzZWREYXRlUGFydHMiLCJtZXJpZGllbSIsInJmYzI4MjIiLCJ3ZWVrZGF5TWlzbWF0Y2giLCJnZXRQYXJzaW5nRmxhZ3MiLCJfcGYiLCJmdW4iLCJpc1ZhbGlkIiwiX2lzVmFsaWQiLCJmbGFncyIsInBhcnNlZFBhcnRzIiwiaXNOb3dWYWxpZCIsImludmFsaWRXZWVrZGF5IiwiX3N0cmljdCIsImJpZ0hvdXIiLCJjcmVhdGVJbnZhbGlkIiwiTmFOIiwibW9tZW50UHJvcGVydGllcyIsImNvcHlDb25maWciLCJfaXNBTW9tZW50T2JqZWN0IiwiX3R6bSIsIl9pc1VUQyIsIl9vZmZzZXQiLCJfbG9jYWxlIiwidXBkYXRlSW5Qcm9ncmVzcyIsIk1vbWVudCIsInVwZGF0ZU9mZnNldCIsImlzTW9tZW50IiwiYWJzRmxvb3IiLCJjZWlsIiwidG9JbnQiLCJhcmd1bWVudEZvckNvZXJjaW9uIiwiY29lcmNlZE51bWJlciIsImNvbXBhcmVBcnJheXMiLCJhcnJheTEiLCJhcnJheTIiLCJkb250Q29udmVydCIsImxlbmd0aERpZmYiLCJhYnMiLCJkaWZmcyIsInN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyIsImRlcHJlY2F0ZSIsImZpcnN0VGltZSIsImRlcHJlY2F0aW9uSGFuZGxlciIsImRlcHJlY2F0aW9ucyIsImRlcHJlY2F0ZVNpbXBsZSIsIl9jb25maWciLCJfZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQiLCJfZGF5T2ZNb250aE9yZGluYWxQYXJzZSIsIl9vcmRpbmFsUGFyc2UiLCJtZXJnZUNvbmZpZ3MiLCJwYXJlbnRDb25maWciLCJjaGlsZENvbmZpZyIsIkxvY2FsZSIsImRlZmF1bHRDYWxlbmRhciIsInNhbWVEYXkiLCJuZXh0RGF5IiwibmV4dFdlZWsiLCJsYXN0RGF5IiwibGFzdFdlZWsiLCJzYW1lRWxzZSIsImNhbGVuZGFyIiwibW9tIiwib3V0cHV0IiwiX2NhbGVuZGFyIiwiZGVmYXVsdExvbmdEYXRlRm9ybWF0IiwiTFRTIiwiTFQiLCJMIiwiTEwiLCJMTEwiLCJMTExMIiwibG9uZ0RhdGVGb3JtYXQiLCJfbG9uZ0RhdGVGb3JtYXQiLCJmb3JtYXRVcHBlciIsImRlZmF1bHRJbnZhbGlkRGF0ZSIsImludmFsaWREYXRlIiwiX2ludmFsaWREYXRlIiwiZGVmYXVsdE9yZGluYWwiLCJkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSIsIm9yZGluYWwiLCJfb3JkaW5hbCIsImRlZmF1bHRSZWxhdGl2ZVRpbWUiLCJmdXR1cmUiLCJwYXN0Iiwic3MiLCJtbSIsImhoIiwiZGQiLCJNIiwiTU0iLCJ5IiwieXkiLCJyZWxhdGl2ZVRpbWUiLCJ3aXRob3V0U3VmZml4IiwiaXNGdXR1cmUiLCJfcmVsYXRpdmVUaW1lIiwicGFzdEZ1dHVyZSIsImRpZmYiLCJhbGlhc2VzIiwiYWRkVW5pdEFsaWFzIiwidW5pdCIsInNob3J0aGFuZCIsImxvd2VyQ2FzZSIsIm5vcm1hbGl6ZVVuaXRzIiwidW5pdHMiLCJub3JtYWxpemVPYmplY3RVbml0cyIsImlucHV0T2JqZWN0Iiwibm9ybWFsaXplZElucHV0Iiwibm9ybWFsaXplZFByb3AiLCJwcmlvcml0aWVzIiwiYWRkVW5pdFByaW9yaXR5IiwicHJpb3JpdHkiLCJnZXRQcmlvcml0aXplZFVuaXRzIiwidW5pdHNPYmoiLCJ1IiwiemVyb0ZpbGwiLCJ0YXJnZXRMZW5ndGgiLCJmb3JjZVNpZ24iLCJhYnNOdW1iZXIiLCJ6ZXJvc1RvRmlsbCIsInNpZ24iLCJwb3ciLCJmb3JtYXR0aW5nVG9rZW5zIiwibG9jYWxGb3JtYXR0aW5nVG9rZW5zIiwiZm9ybWF0RnVuY3Rpb25zIiwiZm9ybWF0VG9rZW5GdW5jdGlvbnMiLCJhZGRGb3JtYXRUb2tlbiIsInRva2VuIiwicGFkZGVkIiwibG9jYWxlRGF0YSIsInJlbW92ZUZvcm1hdHRpbmdUb2tlbnMiLCJtYWtlRm9ybWF0RnVuY3Rpb24iLCJmb3JtYXRNb21lbnQiLCJleHBhbmRGb3JtYXQiLCJyZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMiLCJtYXRjaDEiLCJtYXRjaDIiLCJtYXRjaDMiLCJtYXRjaDQiLCJtYXRjaDYiLCJtYXRjaDF0bzIiLCJtYXRjaDN0bzQiLCJtYXRjaDV0bzYiLCJtYXRjaDF0bzMiLCJtYXRjaDF0bzQiLCJtYXRjaDF0bzYiLCJtYXRjaFVuc2lnbmVkIiwibWF0Y2hTaWduZWQiLCJtYXRjaE9mZnNldCIsIm1hdGNoU2hvcnRPZmZzZXQiLCJtYXRjaFRpbWVzdGFtcCIsIm1hdGNoV29yZCIsInJlZ2V4ZXMiLCJhZGRSZWdleFRva2VuIiwic3RyaWN0UmVnZXgiLCJpc1N0cmljdCIsImdldFBhcnNlUmVnZXhGb3JUb2tlbiIsInVuZXNjYXBlRm9ybWF0IiwicmVnZXhFc2NhcGUiLCJtYXRjaGVkIiwicDEiLCJwMiIsInAzIiwicDQiLCJhZGRQYXJzZVRva2VuIiwiYWRkV2Vla1BhcnNlVG9rZW4iLCJfdyIsImFkZFRpbWVUb0FycmF5RnJvbVRva2VuIiwiX2EiLCJZRUFSIiwiTU9OVEgiLCJEQVRFIiwiSE9VUiIsIk1JTlVURSIsIlNFQ09ORCIsIk1JTExJU0VDT05EIiwiV0VFSyIsIldFRUtEQVkiLCJwYXJzZVR3b0RpZ2l0WWVhciIsImRheXNJblllYXIiLCJpc0xlYXBZZWFyIiwiZ2V0U2V0WWVhciIsIm1ha2VHZXRTZXQiLCJnZXRJc0xlYXBZZWFyIiwia2VlcFRpbWUiLCJzZXQkMSIsImRheXNJbk1vbnRoIiwic3RyaW5nR2V0Iiwic3RyaW5nU2V0IiwicHJpb3JpdGl6ZWQiLCJtb2QiLCJ4IiwibW9kTW9udGgiLCJtb250aHNTaG9ydCIsIm1vbnRocyIsIm1vbnRoc1Nob3J0UmVnZXgiLCJtb250aHNSZWdleCIsIm1vbnRoc1BhcnNlIiwiTU9OVEhTX0lOX0ZPUk1BVCIsImRlZmF1bHRMb2NhbGVNb250aHMiLCJsb2NhbGVNb250aHMiLCJfbW9udGhzIiwiaXNGb3JtYXQiLCJkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQiLCJsb2NhbGVNb250aHNTaG9ydCIsIl9tb250aHNTaG9ydCIsImhhbmRsZVN0cmljdFBhcnNlIiwibW9udGhOYW1lIiwiaWkiLCJsbGMiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsIl9tb250aHNQYXJzZSIsIl9sb25nTW9udGhzUGFyc2UiLCJfc2hvcnRNb250aHNQYXJzZSIsImxvY2FsZU1vbnRoc1BhcnNlIiwiX21vbnRoc1BhcnNlRXhhY3QiLCJzZXRNb250aCIsImRheU9mTW9udGgiLCJnZXRTZXRNb250aCIsImdldERheXNJbk1vbnRoIiwiZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXgiLCJjb21wdXRlTW9udGhzUGFyc2UiLCJfbW9udGhzU2hvcnRTdHJpY3RSZWdleCIsIl9tb250aHNTaG9ydFJlZ2V4IiwiZGVmYXVsdE1vbnRoc1JlZ2V4IiwiX21vbnRoc1N0cmljdFJlZ2V4IiwiX21vbnRoc1JlZ2V4IiwiY21wTGVuUmV2Iiwic2hvcnRQaWVjZXMiLCJsb25nUGllY2VzIiwibWl4ZWRQaWVjZXMiLCJjcmVhdGVEYXRlIiwibXMiLCJnZXRGdWxsWWVhciIsInNldEZ1bGxZZWFyIiwiY3JlYXRlVVRDRGF0ZSIsIlVUQyIsImdldFVUQ0Z1bGxZZWFyIiwic2V0VVRDRnVsbFllYXIiLCJmaXJzdFdlZWtPZmZzZXQiLCJkb3ciLCJkb3kiLCJmd2QiLCJmd2RsdyIsImdldFVUQ0RheSIsImRheU9mWWVhckZyb21XZWVrcyIsIndlZWsiLCJ3ZWVrZGF5IiwibG9jYWxXZWVrZGF5Iiwid2Vla09mZnNldCIsImRheU9mWWVhciIsInJlc1llYXIiLCJyZXNEYXlPZlllYXIiLCJ3ZWVrT2ZZZWFyIiwicmVzV2VlayIsIndlZWtzSW5ZZWFyIiwid2Vla09mZnNldE5leHQiLCJsb2NhbGVXZWVrIiwiX3dlZWsiLCJkZWZhdWx0TG9jYWxlV2VlayIsImxvY2FsZUZpcnN0RGF5T2ZXZWVrIiwibG9jYWxlRmlyc3REYXlPZlllYXIiLCJnZXRTZXRXZWVrIiwiZ2V0U2V0SVNPV2VlayIsIndlZWtkYXlzTWluIiwid2Vla2RheXNTaG9ydCIsIndlZWtkYXlzIiwid2Vla2RheXNNaW5SZWdleCIsIndlZWtkYXlzU2hvcnRSZWdleCIsIndlZWtkYXlzUmVnZXgiLCJ3ZWVrZGF5c1BhcnNlIiwicGFyc2VXZWVrZGF5IiwicGFyc2VJc29XZWVrZGF5Iiwic2hpZnRXZWVrZGF5cyIsIndzIiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzIiwibG9jYWxlV2Vla2RheXMiLCJfd2Vla2RheXMiLCJkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCIsImxvY2FsZVdlZWtkYXlzU2hvcnQiLCJfd2Vla2RheXNTaG9ydCIsImRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiIsImxvY2FsZVdlZWtkYXlzTWluIiwiX3dlZWtkYXlzTWluIiwiaGFuZGxlU3RyaWN0UGFyc2UkMSIsIndlZWtkYXlOYW1lIiwiX3dlZWtkYXlzUGFyc2UiLCJfc2hvcnRXZWVrZGF5c1BhcnNlIiwiX21pbldlZWtkYXlzUGFyc2UiLCJsb2NhbGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzUGFyc2VFeGFjdCIsIl9mdWxsV2Vla2RheXNQYXJzZSIsImdldFNldERheU9mV2VlayIsImdldERheSIsImdldFNldExvY2FsZURheU9mV2VlayIsImdldFNldElTT0RheU9mV2VlayIsImRlZmF1bHRXZWVrZGF5c1JlZ2V4IiwiY29tcHV0ZVdlZWtkYXlzUGFyc2UiLCJfd2Vla2RheXNTdHJpY3RSZWdleCIsIl93ZWVrZGF5c1JlZ2V4IiwiZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCIsIl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXgiLCJfd2Vla2RheXNTaG9ydFJlZ2V4IiwiZGVmYXVsdFdlZWtkYXlzTWluUmVnZXgiLCJfd2Vla2RheXNNaW5TdHJpY3RSZWdleCIsIl93ZWVrZGF5c01pblJlZ2V4IiwibWluUGllY2VzIiwibWlucCIsInNob3J0cCIsImxvbmdwIiwiaEZvcm1hdCIsImhvdXJzIiwia0Zvcm1hdCIsIm1pbnV0ZXMiLCJzZWNvbmRzIiwibG93ZXJjYXNlIiwibWF0Y2hNZXJpZGllbSIsIl9tZXJpZGllbVBhcnNlIiwia0lucHV0IiwiX2lzUG0iLCJpc1BNIiwiX21lcmlkaWVtIiwicG9zMSIsInBvczIiLCJsb2NhbGVJc1BNIiwiZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UiLCJsb2NhbGVNZXJpZGllbSIsImlzTG93ZXIiLCJnZXRTZXRIb3VyIiwiYmFzZUNvbmZpZyIsImRheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJtZXJpZGllbVBhcnNlIiwibG9jYWxlcyIsImxvY2FsZUZhbWlsaWVzIiwiZ2xvYmFsTG9jYWxlIiwibm9ybWFsaXplTG9jYWxlIiwiY2hvb3NlTG9jYWxlIiwibmFtZXMiLCJsb2FkTG9jYWxlIiwib2xkTG9jYWxlIiwiX2FiYnIiLCJhbGlhc2VkUmVxdWlyZSIsImdldFNldEdsb2JhbExvY2FsZSIsImdldExvY2FsZSIsImRlZmluZUxvY2FsZSIsImFiYnIiLCJwYXJlbnRMb2NhbGUiLCJ1cGRhdGVMb2NhbGUiLCJ0bXBMb2NhbGUiLCJsaXN0TG9jYWxlcyIsImNoZWNrT3ZlcmZsb3ciLCJfb3ZlcmZsb3dEYXlPZlllYXIiLCJfb3ZlcmZsb3dXZWVrcyIsIl9vdmVyZmxvd1dlZWtkYXkiLCJkZWZhdWx0cyIsImN1cnJlbnREYXRlQXJyYXkiLCJub3dWYWx1ZSIsIl91c2VVVEMiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRNb250aCIsImdldERhdGUiLCJjb25maWdGcm9tQXJyYXkiLCJjdXJyZW50RGF0ZSIsImV4cGVjdGVkV2Vla2RheSIsInllYXJUb1VzZSIsImRheU9mWWVhckZyb21XZWVrSW5mbyIsIl9kYXlPZlllYXIiLCJfbmV4dERheSIsInNldFVUQ01pbnV0ZXMiLCJnZXRVVENNaW51dGVzIiwidyIsIndlZWtZZWFyIiwidGVtcCIsIndlZWtkYXlPdmVyZmxvdyIsIkdHIiwiVyIsIkUiLCJjcmVhdGVMb2NhbCIsImN1cldlZWsiLCJnZyIsImV4dGVuZGVkSXNvUmVnZXgiLCJiYXNpY0lzb1JlZ2V4IiwidHpSZWdleCIsImlzb0RhdGVzIiwiaXNvVGltZXMiLCJhc3BOZXRKc29uUmVnZXgiLCJjb25maWdGcm9tSVNPIiwiYWxsb3dUaW1lIiwiZGF0ZUZvcm1hdCIsInRpbWVGb3JtYXQiLCJ0ekZvcm1hdCIsImNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQiLCJleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzIiwieWVhclN0ciIsIm1vbnRoU3RyIiwiZGF5U3RyIiwiaG91clN0ciIsIm1pbnV0ZVN0ciIsInNlY29uZFN0ciIsInVudHJ1bmNhdGVZZWFyIiwicHJlcHJvY2Vzc1JGQzI4MjIiLCJjaGVja1dlZWtkYXkiLCJ3ZWVrZGF5U3RyIiwicGFyc2VkSW5wdXQiLCJ3ZWVrZGF5UHJvdmlkZWQiLCJ3ZWVrZGF5QWN0dWFsIiwib2JzT2Zmc2V0cyIsIlVUIiwiR01UIiwiRURUIiwiRVNUIiwiQ0RUIiwiQ1NUIiwiTURUIiwiTVNUIiwiUERUIiwiUFNUIiwiY2FsY3VsYXRlT2Zmc2V0Iiwib2JzT2Zmc2V0IiwibWlsaXRhcnlPZmZzZXQiLCJudW1PZmZzZXQiLCJobSIsImNvbmZpZ0Zyb21SRkMyODIyIiwicGFyc2VkQXJyYXkiLCJjb25maWdGcm9tU3RyaW5nIiwiY3JlYXRlRnJvbUlucHV0RmFsbGJhY2siLCJJU09fODYwMSIsIlJGQ18yODIyIiwic2tpcHBlZCIsInN0cmluZ0xlbmd0aCIsInRvdGFsUGFyc2VkSW5wdXRMZW5ndGgiLCJtZXJpZGllbUZpeFdyYXAiLCJob3VyIiwiaXNQbSIsIm1lcmlkaWVtSG91ciIsImNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheSIsInRlbXBDb25maWciLCJiZXN0TW9tZW50Iiwic2NvcmVUb0JlYXQiLCJjdXJyZW50U2NvcmUiLCJzY29yZSIsImNvbmZpZ0Zyb21PYmplY3QiLCJtaW51dGUiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsImNyZWF0ZUZyb21Db25maWciLCJwcmVwYXJlQ29uZmlnIiwicHJlcGFyc2UiLCJjb25maWdGcm9tSW5wdXQiLCJpc1VUQyIsInByb3RvdHlwZU1pbiIsInByb3RvdHlwZU1heCIsInBpY2tCeSIsIm1vbWVudHMiLCJvcmRlcmluZyIsImlzRHVyYXRpb25WYWxpZCIsInVuaXRIYXNEZWNpbWFsIiwiaXNWYWxpZCQxIiwiY3JlYXRlSW52YWxpZCQxIiwiY3JlYXRlRHVyYXRpb24iLCJEdXJhdGlvbiIsInllYXJzIiwicXVhcnRlcnMiLCJxdWFydGVyIiwid2Vla3MiLCJpc29XZWVrIiwiZGF5cyIsIm1pbGxpc2Vjb25kcyIsIl9taWxsaXNlY29uZHMiLCJfZGF5cyIsIl9idWJibGUiLCJpc0R1cmF0aW9uIiwiYWJzUm91bmQiLCJyb3VuZCIsInNlcGFyYXRvciIsInV0Y09mZnNldCIsIm9mZnNldEZyb21TdHJpbmciLCJjaHVua09mZnNldCIsIm1hdGNoZXIiLCJjaHVuayIsInBhcnRzIiwiY2xvbmVXaXRoT2Zmc2V0Iiwic2V0VGltZSIsImxvY2FsIiwiZ2V0RGF0ZU9mZnNldCIsImdldFRpbWV6b25lT2Zmc2V0IiwiZ2V0U2V0T2Zmc2V0Iiwia2VlcExvY2FsVGltZSIsImtlZXBNaW51dGVzIiwibG9jYWxBZGp1c3QiLCJfY2hhbmdlSW5Qcm9ncmVzcyIsImFkZFN1YnRyYWN0IiwiZ2V0U2V0Wm9uZSIsInNldE9mZnNldFRvVVRDIiwic2V0T2Zmc2V0VG9Mb2NhbCIsInN1YnRyYWN0Iiwic2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQiLCJ0Wm9uZSIsImhhc0FsaWduZWRIb3VyT2Zmc2V0IiwiaXNEYXlsaWdodFNhdmluZ1RpbWUiLCJpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQiLCJfaXNEU1RTaGlmdGVkIiwiaXNMb2NhbCIsImlzVXRjT2Zmc2V0IiwiaXNVdGMiLCJhc3BOZXRSZWdleCIsImlzb1JlZ2V4IiwiZGlmZlJlcyIsInBhcnNlSXNvIiwibW9tZW50c0RpZmZlcmVuY2UiLCJpbnZhbGlkIiwiaW5wIiwicG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZSIsImlzQWZ0ZXIiLCJpc0JlZm9yZSIsImNyZWF0ZUFkZGVyIiwiZGlyZWN0aW9uIiwicGVyaW9kIiwiZHVyIiwiaXNBZGRpbmciLCJnZXRDYWxlbmRhckZvcm1hdCIsIm15TW9tZW50IiwiY2FsZW5kYXIkMSIsInRpbWUiLCJmb3JtYXRzIiwic29kIiwic3RhcnRPZiIsImNhbGVuZGFyRm9ybWF0IiwibG9jYWxJbnB1dCIsImVuZE9mIiwiaXNCZXR3ZWVuIiwiaW5jbHVzaXZpdHkiLCJsb2NhbEZyb20iLCJsb2NhbFRvIiwiaXNTYW1lIiwiaW5wdXRNcyIsImlzU2FtZU9yQWZ0ZXIiLCJpc1NhbWVPckJlZm9yZSIsImFzRmxvYXQiLCJ0aGF0Iiwiem9uZURlbHRhIiwibW9udGhEaWZmIiwid2hvbGVNb250aERpZmYiLCJhbmNob3IiLCJhbmNob3IyIiwiYWRqdXN0IiwiZGVmYXVsdEZvcm1hdCIsImRlZmF1bHRGb3JtYXRVdGMiLCJ0b0lTT1N0cmluZyIsImtlZXBPZmZzZXQiLCJ0b0RhdGUiLCJpbnNwZWN0Iiwiem9uZSIsImRhdGV0aW1lIiwic3VmZml4IiwiaW5wdXRTdHJpbmciLCJwb3N0Zm9ybWF0IiwiaHVtYW5pemUiLCJmcm9tTm93IiwidG9Ob3ciLCJuZXdMb2NhbGVEYXRhIiwibGFuZyIsIk1TX1BFUl9TRUNPTkQiLCJNU19QRVJfTUlOVVRFIiwiTVNfUEVSX0hPVVIiLCJNU19QRVJfNDAwX1lFQVJTIiwibW9kJDEiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJsb2NhbFN0YXJ0T2ZEYXRlIiwidXRjU3RhcnRPZkRhdGUiLCJzdGFydE9mRGF0ZSIsImlzb1dlZWtkYXkiLCJ1bml4IiwidG9KU09OIiwiaXNWYWxpZCQyIiwicGFyc2luZ0ZsYWdzIiwiaW52YWxpZEF0IiwiY3JlYXRpb25EYXRhIiwiaXNvV2Vla1llYXIiLCJhZGRXZWVrWWVhckZvcm1hdFRva2VuIiwiZ2V0U2V0V2Vla1llYXIiLCJnZXRTZXRXZWVrWWVhckhlbHBlciIsImdldFNldElTT1dlZWtZZWFyIiwiZ2V0SVNPV2Vla3NJblllYXIiLCJnZXRXZWVrc0luWWVhciIsIndlZWtJbmZvIiwid2Vla3NUYXJnZXQiLCJzZXRXZWVrQWxsIiwiZGF5T2ZZZWFyRGF0YSIsImdldFNldFF1YXJ0ZXIiLCJnZXRTZXREYXlPZk1vbnRoIiwiZ2V0U2V0RGF5T2ZZZWFyIiwiZ2V0U2V0TWludXRlIiwiZ2V0U2V0U2Vjb25kIiwicGFyc2VNcyIsImdldFNldE1pbGxpc2Vjb25kIiwiZ2V0Wm9uZUFiYnIiLCJnZXRab25lTmFtZSIsImlzb1dlZWtzIiwiaXNvV2Vla3NJblllYXIiLCJwYXJzZVpvbmUiLCJpc0RTVCIsInpvbmVBYmJyIiwiem9uZU5hbWUiLCJkYXRlcyIsImlzRFNUU2hpZnRlZCIsImNyZWF0ZVVuaXgiLCJjcmVhdGVJblpvbmUiLCJwcmVQYXJzZVBvc3RGb3JtYXQiLCJwcm90byQxIiwiZmlyc3REYXlPZlllYXIiLCJmaXJzdERheU9mV2VlayIsImdldCQxIiwiZmllbGQiLCJsaXN0TW9udGhzSW1wbCIsIm91dCIsImxpc3RXZWVrZGF5c0ltcGwiLCJsb2NhbGVTb3J0ZWQiLCJsaXN0TW9udGhzIiwibGlzdE1vbnRoc1Nob3J0IiwibGlzdFdlZWtkYXlzIiwibGlzdFdlZWtkYXlzU2hvcnQiLCJsaXN0V2Vla2RheXNNaW4iLCJsYW5nRGF0YSIsIm1hdGhBYnMiLCJhZGRTdWJ0cmFjdCQxIiwic3VidHJhY3QkMSIsImFic0NlaWwiLCJidWJibGUiLCJtb250aHNGcm9tRGF5cyIsIm1vbnRoc1RvRGF5cyIsImRheXNUb01vbnRocyIsImFzIiwidmFsdWVPZiQxIiwibWFrZUFzIiwiYXNNaWxsaXNlY29uZHMiLCJhc1NlY29uZHMiLCJhc01pbnV0ZXMiLCJhc0hvdXJzIiwiYXNEYXlzIiwiYXNXZWVrcyIsImFzTW9udGhzIiwiYXNRdWFydGVycyIsImFzWWVhcnMiLCJjbG9uZSQxIiwiZ2V0JDIiLCJtYWtlR2V0dGVyIiwidGhyZXNob2xkcyIsInN1YnN0aXR1dGVUaW1lQWdvIiwicmVsYXRpdmVUaW1lJDEiLCJwb3NOZWdEdXJhdGlvbiIsImdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIiwicm91bmRpbmdGdW5jdGlvbiIsImdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCIsInRocmVzaG9sZCIsImxpbWl0Iiwid2l0aFN1ZmZpeCIsImFicyQxIiwidG9JU09TdHJpbmckMSIsIlkiLCJEIiwidG9GaXhlZCIsInRvdGFsIiwidG90YWxTaWduIiwieW1TaWduIiwiZGF5c1NpZ24iLCJobXNTaWduIiwicHJvdG8kMiIsInRvSXNvU3RyaW5nIiwicmVsYXRpdmVUaW1lUm91bmRpbmciLCJyZWxhdGl2ZVRpbWVUaHJlc2hvbGQiLCJIVE1MNV9GTVQiLCJEQVRFVElNRV9MT0NBTCIsIkRBVEVUSU1FX0xPQ0FMX1NFQ09ORFMiLCJEQVRFVElNRV9MT0NBTF9NUyIsIlRJTUUiLCJUSU1FX1NFQ09ORFMiLCJUSU1FX01TIiwicmVxdWlyZSQkMCIsIm1vbWVudCIsImNvbnZlcnNpb25zIiwicmdiMmhzbCIsInJnYjJoc3YiLCJyZ2IyaHdiIiwicmdiMmNteWsiLCJyZ2Iya2V5d29yZCIsInJnYjJ4eXoiLCJyZ2IybGFiIiwicmdiMmxjaCIsImhzbDJyZ2IiLCJoc2wyaHN2IiwiaHNsMmh3YiIsImhzbDJjbXlrIiwiaHNsMmtleXdvcmQiLCJoc3YycmdiIiwiaHN2MmhzbCIsImhzdjJod2IiLCJoc3YyY215ayIsImhzdjJrZXl3b3JkIiwiaHdiMnJnYiIsImh3YjJoc2wiLCJod2IyaHN2IiwiaHdiMmNteWsiLCJod2Iya2V5d29yZCIsImNteWsycmdiIiwiY215azJoc2wiLCJjbXlrMmhzdiIsImNteWsyaHdiIiwiY215azJrZXl3b3JkIiwia2V5d29yZDJyZ2IiLCJrZXl3b3JkMmhzbCIsImtleXdvcmQyaHN2Iiwia2V5d29yZDJod2IiLCJrZXl3b3JkMmNteWsiLCJrZXl3b3JkMmxhYiIsImtleXdvcmQyeHl6IiwieHl6MnJnYiIsInh5ejJsYWIiLCJ4eXoybGNoIiwibGFiMnh5eiIsImxhYjJyZ2IiLCJsYWIybGNoIiwibGNoMmxhYiIsImxjaDJ4eXoiLCJsY2gycmdiIiwicmdiIiwiciIsImciLCJkZWx0YSIsInJldmVyc2VLZXl3b3JkcyIsInoiLCJ4eXoiLCJoc2wiLCJ0MSIsInQyIiwidDMiLCJzdiIsImhzdiIsImhpIiwiZiIsInEiLCJzbCIsImh3YiIsIndoIiwiYmwiLCJyYXRpbyIsImNteWsiLCJsYWIiLCJ5MiIsImhyIiwiYXRhbjIiLCJQSSIsInNxcnQiLCJsY2giLCJjb3MiLCJzaW4iLCJrZXl3b3JkIiwiY3NzS2V5d29yZHMiLCJhbGljZWJsdWUiLCJhbnRpcXVld2hpdGUiLCJhcXVhIiwiYXF1YW1hcmluZSIsImF6dXJlIiwiYmVpZ2UiLCJiaXNxdWUiLCJibGFjayIsImJsYW5jaGVkYWxtb25kIiwiYmx1ZSIsImJsdWV2aW9sZXQiLCJicm93biIsImJ1cmx5d29vZCIsImNhZGV0Ymx1ZSIsImNoYXJ0cmV1c2UiLCJjaG9jb2xhdGUiLCJjb3JhbCIsImNvcm5mbG93ZXJibHVlIiwiY29ybnNpbGsiLCJjcmltc29uIiwiY3lhbiIsImRhcmtibHVlIiwiZGFya2N5YW4iLCJkYXJrZ29sZGVucm9kIiwiZGFya2dyYXkiLCJkYXJrZ3JlZW4iLCJkYXJrZ3JleSIsImRhcmtraGFraSIsImRhcmttYWdlbnRhIiwiZGFya29saXZlZ3JlZW4iLCJkYXJrb3JhbmdlIiwiZGFya29yY2hpZCIsImRhcmtyZWQiLCJkYXJrc2FsbW9uIiwiZGFya3NlYWdyZWVuIiwiZGFya3NsYXRlYmx1ZSIsImRhcmtzbGF0ZWdyYXkiLCJkYXJrc2xhdGVncmV5IiwiZGFya3R1cnF1b2lzZSIsImRhcmt2aW9sZXQiLCJkZWVwcGluayIsImRlZXBza3libHVlIiwiZGltZ3JheSIsImRpbWdyZXkiLCJkb2RnZXJibHVlIiwiZmlyZWJyaWNrIiwiZmxvcmFsd2hpdGUiLCJmb3Jlc3RncmVlbiIsImZ1Y2hzaWEiLCJnYWluc2Jvcm8iLCJnaG9zdHdoaXRlIiwiZ29sZCIsImdvbGRlbnJvZCIsImdyYXkiLCJncmVlbiIsImdyZWVueWVsbG93IiwiZ3JleSIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZWVuIiwibGlnaHRncmV5IiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlYmVjY2FwdXJwbGUiLCJyZWQiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRhbiIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsIkNvbnZlcnRlciIsInBhaXIiLCJjb252cyIsInJvdXRlU3BhY2UiLCJnZXRWYWx1ZXMiLCJzZXRWYWx1ZXMiLCJ2YWxzIiwiZnNwYWNlIiwiY29sb3JDb252ZXJ0IiwiY29sb3JOYW1lIiwiY29sb3JTdHJpbmciLCJnZXRSZ2JhIiwiZ2V0SHNsYSIsImdldFJnYiIsImdldEhzbCIsImdldEh3YiIsImdldEFscGhhIiwiaGV4U3RyaW5nIiwicmdiU3RyaW5nIiwicmdiYVN0cmluZyIsInBlcmNlbnRTdHJpbmciLCJwZXJjZW50YVN0cmluZyIsImhzbFN0cmluZyIsImhzbGFTdHJpbmciLCJod2JTdHJpbmciLCJoZXgiLCJyZ2JhIiwicGVyIiwiaGV4QWxwaGEiLCJzY2FsZSIsImFscGhhIiwiaHNsYSIsImhleERvdWJsZSIsInJldmVyc2VOYW1lcyIsIm51bSIsIkNvbG9yIiwibGlnaHRuZXNzIiwid2hpdGVuZXNzIiwic2V0U3BhY2UiLCJyZ2JBcnJheSIsImhzbEFycmF5IiwiaHN2QXJyYXkiLCJod2JBcnJheSIsImNteWtBcnJheSIsInJnYmFBcnJheSIsImhzbGFBcnJheSIsInNldENoYW5uZWwiLCJodWUiLCJzYXR1cmF0aW9uIiwic2F0dXJhdGlvbnYiLCJibGFja25lc3MiLCJyZ2JOdW1iZXIiLCJsdW1pbm9zaXR5IiwibHVtIiwiY2hhbiIsImNvbnRyYXN0IiwiY29sb3IyIiwibHVtMSIsImx1bTIiLCJsZXZlbCIsImNvbnRyYXN0UmF0aW8iLCJkYXJrIiwieWlxIiwibGlnaHQiLCJuZWdhdGUiLCJsaWdodGVuIiwiZGFya2VuIiwic2F0dXJhdGUiLCJkZXNhdHVyYXRlIiwid2hpdGVuIiwiYmxhY2tlbiIsImdyZXlzY2FsZSIsImNsZWFyZXIiLCJvcGFxdWVyIiwicm90YXRlIiwiZGVncmVlcyIsIm1peCIsIm1peGluQ29sb3IiLCJ3ZWlnaHQiLCJjb2xvcjEiLCJ3MSIsIncyIiwic3BhY2VzIiwibWF4ZXMiLCJjaGFucyIsImNhcHBlZCIsInNuYW1lIiwic3ZhbHVlcyIsImNoYXJ0anNDb2xvciIsImhlbHBlcnMiLCJpc051bGxPclVuZGVmIiwidmFsdWVPckRlZmF1bHQiLCJ2YWx1ZUF0SW5kZXhPckRlZmF1bHQiLCJlYWNoIiwibG9vcGFibGUiLCJyZXZlcnNlIiwiYXJyYXlFcXVhbHMiLCJhMCIsImExIiwiaWxlbiIsInYwIiwidjEiLCJrbGVuIiwiX21lcmdlciIsInR2YWwiLCJzdmFsIiwiX21lcmdlcklmIiwibWVyZ2VJZiIsIm1lcmdlciIsInNldEZuIiwiaW5oZXJpdHMiLCJleHRlbnNpb25zIiwibWUiLCJDaGFydEVsZW1lbnQiLCJTdXJyb2dhdGUiLCJfX3N1cGVyX18iLCJoZWxwZXJzX2NvcmUiLCJjYWxsQ2FsbGJhY2siLCJmcm9tSW5kZXgiLCJnZXRWYWx1ZU9yRGVmYXVsdCIsImdldFZhbHVlQXRJbmRleE9yRGVmYXVsdCIsImVmZmVjdHMiLCJsaW5lYXIiLCJlYXNlSW5RdWFkIiwiZWFzZU91dFF1YWQiLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluQ3ViaWMiLCJlYXNlT3V0Q3ViaWMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJblF1YXJ0IiwiZWFzZU91dFF1YXJ0IiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VPdXRRdWludCIsImVhc2VJbk91dFF1aW50IiwiZWFzZUluU2luZSIsImVhc2VPdXRTaW5lIiwiZWFzZUluT3V0U2luZSIsImVhc2VJbkV4cG8iLCJlYXNlT3V0RXhwbyIsImVhc2VJbk91dEV4cG8iLCJlYXNlSW5DaXJjIiwiZWFzZU91dENpcmMiLCJlYXNlSW5PdXRDaXJjIiwiZWFzZUluRWxhc3RpYyIsImFzaW4iLCJlYXNlT3V0RWxhc3RpYyIsImVhc2VJbk91dEVsYXN0aWMiLCJlYXNlSW5CYWNrIiwiZWFzZU91dEJhY2siLCJlYXNlSW5PdXRCYWNrIiwiZWFzZUluQm91bmNlIiwiZWFzZU91dEJvdW5jZSIsImVhc2VJbk91dEJvdW5jZSIsImhlbHBlcnNfZWFzaW5nIiwiZWFzaW5nRWZmZWN0cyIsIlJBRF9QRVJfREVHIiwiRE9VQkxFX1BJIiwiSEFMRl9QSSIsIlFVQVJURVJfUEkiLCJUV09fVEhJUkRTX1BJIiwiZXhwb3J0cyQxIiwiY2xlYXJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJyb3VuZGVkUmVjdCIsInJhZGl1cyIsImJvdHRvbSIsIm1vdmVUbyIsImFyYyIsImNsb3NlUGF0aCIsInJlY3QiLCJkcmF3UG9pbnQiLCJyb3RhdGlvbiIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiY29ybmVyUmFkaXVzIiwicmFkIiwiZHJhd0ltYWdlIiwiYmVnaW5QYXRoIiwibGluZVRvIiwiU1FSVDFfMiIsImZpbGwiLCJzdHJva2UiLCJfaXNQb2ludEluQXJlYSIsInBvaW50IiwiYXJlYSIsImVwc2lsb24iLCJjbGlwQXJlYSIsInNhdmUiLCJjbGlwIiwidW5jbGlwQXJlYSIsInJlc3RvcmUiLCJwcmV2aW91cyIsImZsaXAiLCJzdGVwcGVkIiwic3RlcHBlZExpbmUiLCJtaWRwb2ludCIsInRlbnNpb24iLCJiZXppZXJDdXJ2ZVRvIiwiY29udHJvbFBvaW50UHJldmlvdXNYIiwiY29udHJvbFBvaW50TmV4dFgiLCJjb250cm9sUG9pbnRQcmV2aW91c1kiLCJjb250cm9sUG9pbnROZXh0WSIsImhlbHBlcnNfY2FudmFzIiwiZHJhd1JvdW5kZWRSZWN0YW5nbGUiLCJfc2V0Iiwic2NvcGUiLCJkZWZhdWx0Q29sb3IiLCJkZWZhdWx0Rm9udENvbG9yIiwiZGVmYXVsdEZvbnRGYW1pbHkiLCJkZWZhdWx0Rm9udFNpemUiLCJkZWZhdWx0Rm9udFN0eWxlIiwiZGVmYXVsdExpbmVIZWlnaHQiLCJzaG93TGluZXMiLCJjb3JlX2RlZmF1bHRzIiwidG9Gb250U3RyaW5nIiwiZm9udCIsImZhbWlseSIsImhlbHBlcnNfb3B0aW9ucyIsInRvTGluZUhlaWdodCIsInRvUGFkZGluZyIsIl9wYXJzZUZvbnQiLCJnbG9iYWxEZWZhdWx0cyIsImZvbnRGYW1pbHkiLCJsaW5lSGVpZ2h0IiwiZm9udFN0eWxlIiwiaW5wdXRzIiwiaGVscGVycyQxIiwiZWFzaW5nIiwiY2FudmFzIiwiZWFzZSIsIm9yaWdpbiIsImMwIiwiYzEiLCJFbGVtZW50IiwiY29uZmlndXJhdGlvbiIsImluaXRpYWxpemUiLCJoaWRkZW4iLCJwaXZvdCIsIl92aWV3IiwiX21vZGVsIiwiX3N0YXJ0IiwidG9vbHRpcFBvc2l0aW9uIiwiaGFzVmFsdWUiLCJjb3JlX2VsZW1lbnQiLCJleHBvcnRzJDIiLCJjdXJyZW50U3RlcCIsIm51bVN0ZXBzIiwib25BbmltYXRpb25Qcm9ncmVzcyIsIm9uQW5pbWF0aW9uQ29tcGxldGUiLCJjb3JlX2FuaW1hdGlvbiIsImFuaW1hdGlvbiIsIm9uUHJvZ3Jlc3MiLCJvbkNvbXBsZXRlIiwiY29yZV9hbmltYXRpb25zIiwiYW5pbWF0aW9ucyIsInJlcXVlc3QiLCJhZGRBbmltYXRpb24iLCJzdGFydFRpbWUiLCJhbmltYXRpbmciLCJjYW5jZWxBbmltYXRpb24iLCJmaW5kSW5kZXgiLCJyZXF1ZXN0QW5pbUZyYW1lIiwic3RhcnREaWdlc3QiLCJuZXh0U3RlcCIsImFycmF5RXZlbnRzIiwibGlzdGVuQXJyYXlFdmVudHMiLCJsaXN0ZW5lciIsIl9jaGFydGpzIiwidW5saXN0ZW5BcnJheUV2ZW50cyIsInN0dWIiLCJEYXRhc2V0Q29udHJvbGxlciIsImRhdGFzZXRJbmRleCIsImRhdGFzZXRFbGVtZW50VHlwZSIsImRhdGFFbGVtZW50VHlwZSIsImxpbmtTY2FsZXMiLCJhZGRFbGVtZW50cyIsInVwZGF0ZUluZGV4IiwiZ2V0TWV0YSIsImdldERhdGFzZXQiLCJ4QXhpc0lEIiwic2NhbGVzIiwieEF4ZXMiLCJ5QXhpc0lEIiwieUF4ZXMiLCJnZXREYXRhc2V0TWV0YSIsImdldFNjYWxlRm9ySWQiLCJzY2FsZUlEIiwiX2dldFZhbHVlU2NhbGVJZCIsIl9nZXRJbmRleFNjYWxlSWQiLCJfZ2V0VmFsdWVTY2FsZSIsIl9nZXRJbmRleFNjYWxlIiwicmVzZXQiLCJjcmVhdGVNZXRhRGF0YXNldCIsIl9kYXRhc2V0SW5kZXgiLCJjcmVhdGVNZXRhRGF0YSIsIl9pbmRleCIsIm1ldGFEYXRhIiwiYWRkRWxlbWVudEFuZFJlc2V0IiwidXBkYXRlRWxlbWVudCIsImJ1aWxkT3JVcGRhdGVFbGVtZW50cyIsInJlc3luY0VsZW1lbnRzIiwiZWFzaW5nVmFsdWUiLCJlbGVtZW50cyIsImRyYXciLCJyZW1vdmVIb3ZlclN0eWxlIiwiJHByZXZpb3VzU3R5bGUiLCJzZXRIb3ZlclN0eWxlIiwiY3VzdG9tIiwiZ2V0SG92ZXJDb2xvciIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwiYm9yZGVyV2lkdGgiLCJob3ZlckJhY2tncm91bmRDb2xvciIsImhvdmVyQm9yZGVyQ29sb3IiLCJob3ZlckJvcmRlcldpZHRoIiwibnVtTWV0YSIsIm51bURhdGEiLCJpbnNlcnRFbGVtZW50cyIsIm9uRGF0YVB1c2giLCJvbkRhdGFQb3AiLCJvbkRhdGFTaGlmdCIsIm9uRGF0YVNwbGljZSIsIm9uRGF0YVVuc2hpZnQiLCJjb3JlX2RhdGFzZXRDb250cm9sbGVyIiwiYm9yZGVyQWxpZ24iLCJlbGVtZW50X2FyYyIsImluTGFiZWxSYW5nZSIsIm1vdXNlWCIsImhvdmVyUmFkaXVzIiwiaW5SYW5nZSIsImNoYXJ0WCIsImNoYXJ0WSIsInBvaW50UmVsYXRpdmVQb3NpdGlvbiIsImdldEFuZ2xlRnJvbVBvaW50IiwiYW5nbGUiLCJkaXN0YW5jZSIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImJldHdlZW5BbmdsZXMiLCJ3aXRoaW5SYWRpdXMiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiZ2V0Q2VudGVyUG9pbnQiLCJoYWxmQW5nbGUiLCJoYWxmUmFkaXVzIiwiZ2V0QXJlYSIsImNlbnRyZUFuZ2xlIiwicmFuZ2VGcm9tQ2VudHJlIiwic0EiLCJlQSIsInBpeGVsTWFyZ2luIiwiYW5nbGVNYXJnaW4iLCJmaWxsU3R5bGUiLCJsaW5lV2lkdGgiLCJsaW5lSm9pbiIsInN0cm9rZVN0eWxlIiwidmFsdWVPckRlZmF1bHQkMSIsImxpbmUiLCJib3JkZXJDYXBTdHlsZSIsImJvcmRlckRhc2giLCJib3JkZXJEYXNoT2Zmc2V0IiwiYm9yZGVySm9pblN0eWxlIiwiY2FwQmV6aWVyUG9pbnRzIiwiZWxlbWVudF9saW5lIiwic3BhbkdhcHMiLCJwb2ludHMiLCJfY2hpbGRyZW4iLCJnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMiLCJsYXN0RHJhd25JbmRleCIsImN1cnJlbnRWTSIsIl9sb29wIiwibGluZUNhcCIsInNldExpbmVEYXNoIiwibGluZURhc2hPZmZzZXQiLCJwcmV2aW91c0l0ZW0iLCJza2lwIiwidmFsdWVPckRlZmF1bHQkMiIsImRlZmF1bHRDb2xvciQxIiwicG9pbnRTdHlsZSIsImhpdFJhZGl1cyIsInhSYW5nZSIsInlSYW5nZSIsIm1vdXNlWSIsImVsZW1lbnRfcG9pbnQiLCJpblhSYW5nZSIsImluWVJhbmdlIiwicGFkZGluZyIsImNoYXJ0QXJlYSIsImRlZmF1bHRDb2xvciQyIiwicmVjdGFuZ2xlIiwiYm9yZGVyU2tpcHBlZCIsImlzVmVydGljYWwiLCJnZXRCYXJCb3VuZHMiLCJ4MSIsIngyIiwieTEiLCJoYWxmIiwic3dhcCIsIm9yaWciLCJ2MiIsInBhcnNlQm9yZGVyU2tpcHBlZCIsImVkZ2UiLCJob3Jpem9udGFsIiwicGFyc2VCb3JkZXJXaWR0aCIsIm1heFciLCJtYXhIIiwiYm91bmRpbmdSZWN0cyIsImJvdW5kcyIsImJvcmRlciIsIm91dGVyIiwiaW5uZXIiLCJza2lwWCIsInNraXBZIiwiZWxlbWVudF9yZWN0YW5nbGUiLCJyZWN0cyIsImZpbGxSZWN0IiwiQXJjIiwiTGluZSIsIlBvaW50IiwiUmVjdGFuZ2xlIiwicmVzb2x2ZSQxIiwiaG92ZXIiLCJjYXRlZ29yeVBlcmNlbnRhZ2UiLCJiYXJQZXJjZW50YWdlIiwiZ3JpZExpbmVzIiwib2Zmc2V0R3JpZExpbmVzIiwiY29tcHV0ZU1pblNhbXBsZVNpemUiLCJwaXhlbHMiLCJpc0hvcml6b250YWwiLCJ0aWNrcyIsImdldFRpY2tzIiwiY3VyciIsImdldFBpeGVsRm9yVGljayIsImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsInJ1bGVyIiwidGhpY2tuZXNzIiwiYmFyVGhpY2tuZXNzIiwic3RhY2tDb3VudCIsImNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMiLCJwZXJjZW50IiwiY29udHJvbGxlcl9iYXIiLCJiYXIiLCJfcnVsZXIiLCJnZXRSdWxlciIsIl9yZXNvbHZlRWxlbWVudE9wdGlvbnMiLCJfeFNjYWxlIiwiX3lTY2FsZSIsImRhdGFzZXRMYWJlbCIsIl91cGRhdGVFbGVtZW50R2VvbWV0cnkiLCJ2c2NhbGUiLCJnZXRCYXNlUGl4ZWwiLCJ2cGl4ZWxzIiwiY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMiLCJpcGl4ZWxzIiwiY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMiLCJoZWFkIiwiY2VudGVyIiwiX2dldFN0YWNrcyIsInN0YWNrcyIsImlzRGF0YXNldFZpc2libGUiLCJnZXRTdGFja0NvdW50IiwiZ2V0U3RhY2tJbmRleCIsImdldFBpeGVsRm9yVmFsdWUiLCJnZXRSaWdodFZhbHVlIiwibWluQmFyTGVuZ3RoIiwiaW1ldGEiLCJpdmFsdWUiLCJjb250cm9sbGVyIiwic3RhY2tJbmRleCIsIm1heEJhclRoaWNrbmVzcyIsIkluZmluaXR5IiwiZGF0YUluZGV4IiwidmFsdWVPckRlZmF1bHQkMyIsInJlc29sdmUkMiIsInBvc2l0aW9uIiwidG9vbHRpcHMiLCJkYXRhUG9pbnQiLCJ4TGFiZWwiLCJ5TGFiZWwiLCJjb250cm9sbGVyX2J1YmJsZSIsInhTY2FsZSIsInlTY2FsZSIsImRzSW5kZXgiLCJnZXRQaXhlbEZvckRlY2ltYWwiLCJfb3B0aW9ucyIsInJlc29sdmUkMyIsInZhbHVlT3JEZWZhdWx0JDQiLCJhbmltYXRlUm90YXRlIiwiYW5pbWF0ZVNjYWxlIiwibGVnZW5kQ2FsbGJhY2siLCJsZWdlbmQiLCJnZW5lcmF0ZUxhYmVscyIsImRzIiwiYXJjT3B0cyIsImJ3Iiwib25DbGljayIsImxlZ2VuZEl0ZW0iLCJjdXRvdXRQZXJjZW50YWdlIiwiY2lyY3VtZmVyZW5jZSIsInRvb2x0aXBJdGVtIiwiZGF0YUxhYmVsIiwiY29udHJvbGxlcl9kb3VnaG51dCIsImdldFJpbmdJbmRleCIsInJpbmdJbmRleCIsImF2YWlsYWJsZVdpZHRoIiwiYXZhaWxhYmxlSGVpZ2h0IiwibWluU2l6ZSIsImFyY3MiLCJjaGFydFdlaWdodCIsIl9nZXRSaW5nV2VpZ2h0IiwiY29udGFpbnMwIiwiY29udGFpbnM5MCIsImNvbnRhaW5zMTgwIiwiY29udGFpbnMyNzAiLCJjdXRvdXQiLCJnZXRNYXhCb3JkZXJXaWR0aCIsInJhZGl1c0xlbmd0aCIsIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJjYWxjdWxhdGVUb3RhbCIsIl9nZXRSaW5nV2VpZ2h0T2Zmc2V0IiwiYW5pbWF0aW9uT3B0cyIsImNlbnRlclgiLCJjZW50ZXJZIiwiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsImhvdmVyV2lkdGgiLCJyaW5nV2VpZ2h0T2Zmc2V0IiwiZGF0YVNldEluZGV4IiwiYXhpcyIsImNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhciIsInZhbHVlT3JEZWZhdWx0JDUiLCJyZXNvbHZlJDQiLCJpc1BvaW50SW5BcmVhIiwibGluZUVuYWJsZWQiLCJzaG93TGluZSIsImNvbnRyb2xsZXJfbGluZSIsImxpbmVUZW5zaW9uIiwiX3NjYWxlIiwiX3Jlc29sdmVMaW5lT3B0aW9ucyIsInVwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCJsaW5lTW9kZWwiLCJfcmVzb2x2ZVBvaW50T3B0aW9ucyIsImNhbGN1bGF0ZVBvaW50WSIsIkVMRU1FTlRfT1BUSU9OUyIsImVsZW1lbnRPcHRpb25zIiwic3VtUG9zIiwic3VtTmVnIiwiZHNNZXRhIiwic3RhY2tlZFJpZ2h0VmFsdWUiLCJyaWdodFZhbHVlIiwiY29udHJvbFBvaW50cyIsInB0IiwiY2FwQ29udHJvbFBvaW50IiwiY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSIsInNwbGluZUN1cnZlTW9ub3RvbmUiLCJzcGxpbmVDdXJ2ZSIsIm5leHRJdGVtIiwiaGFsZkJvcmRlcldpZHRoIiwicmVzb2x2ZSQ1IiwiYW5nbGVMaW5lcyIsInBvaW50TGFiZWxzIiwiYmVnaW5BdFplcm8iLCJjb250cm9sbGVyX3BvbGFyQXJlYSIsInN0YXJ0cyIsIl9zdGFydHMiLCJhbmdsZXMiLCJfYW5nbGVzIiwiX3VwZGF0ZVJhZGl1cyIsImNvdW50VmlzaWJsZUVsZW1lbnRzIiwiX2NvbXB1dGVBbmdsZSIsImdldFZpc2libGVEYXRhc2V0Q291bnQiLCJ4Q2VudGVyIiwieUNlbnRlciIsImRhdGFzZXRTdGFydEFuZ2xlIiwiZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUiLCJyZXNldFJhZGl1cyIsImRvdWdobnV0IiwiY29udHJvbGxlcl9waWUiLCJ2YWx1ZU9yRGVmYXVsdCQ2IiwicmVzb2x2ZSQ2IiwiY29udHJvbGxlcl9yYWRhciIsInBvaW50UG9zaXRpb24iLCJnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUiLCJjb250cm9sbGVyX3NjYXR0ZXIiLCJjb250cm9sbGVycyIsImhvcml6b250YWxCYXIiLCJwb2xhckFyZWEiLCJwaWUiLCJyYWRhciIsInNjYXR0ZXIiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwicGFyc2VWaXNpYmxlSXRlbXMiLCJqbGVuIiwiZ2V0SW50ZXJzZWN0SXRlbXMiLCJnZXROZWFyZXN0SXRlbXMiLCJpbnRlcnNlY3QiLCJkaXN0YW5jZU1ldHJpYyIsIm1pbkRpc3RhbmNlIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJuZWFyZXN0SXRlbXMiLCJnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMiLCJ1c2VYIiwidXNlWSIsInB0MSIsInB0MiIsImRlbHRhWCIsImRlbHRhWSIsImluZGV4TW9kZSIsImNvcmVfaW50ZXJhY3Rpb24iLCJtb2RlcyIsInNpbmdsZSIsIm5lYXJlc3QiLCJpbnRlcnNlY3RzSXRlbSIsImZpbHRlckJ5UG9zaXRpb24iLCJ3aGVyZSIsInNvcnRCeVdlaWdodCIsIl90bXBJbmRleF8iLCJmaW5kTWF4UGFkZGluZyIsImJveGVzIiwiYm94IiwiZ2V0UGFkZGluZyIsImJveFBhZGRpbmciLCJhZGRTaXplQnlQb3NpdGlvbiIsImxheW91dCIsImNvcmVfbGF5b3V0cyIsImFkZEJveCIsImZ1bGxXaWR0aCIsInJlbW92ZUJveCIsImxheW91dEl0ZW0iLCJjb25maWd1cmUiLCJsYXlvdXRPcHRpb25zIiwibGVmdFBhZGRpbmciLCJyaWdodFBhZGRpbmciLCJ0b3BQYWRkaW5nIiwiYm90dG9tUGFkZGluZyIsImxlZnRCb3hlcyIsInJpZ2h0Qm94ZXMiLCJ0b3BCb3hlcyIsImJvdHRvbUJveGVzIiwiY2hhcnRBcmVhQm94ZXMiLCJ2ZXJ0aWNhbEJveGVzIiwiaG9yaXpvbnRhbEJveGVzIiwib3V0ZXJCb3hlcyIsImNoYXJ0V2lkdGgiLCJjaGFydEhlaWdodCIsImNoYXJ0QXJlYVdpZHRoIiwidmVydGljYWxCb3hXaWR0aCIsIm1heENoYXJ0QXJlYVdpZHRoIiwibWF4Q2hhcnRBcmVhSGVpZ2h0Iiwib3V0ZXJCb3hTaXplcyIsIm1pbkJveFNpemVzIiwibWF4UGFkZGluZyIsImdldE1pbmltdW1Cb3hTaXplIiwiZml0Qm94IiwibWluQm94U2l6ZSIsImZpbmROZXh0V2hlcmUiLCJtaW5Cb3giLCJzY2FsZU1hcmdpbiIsImZpbmFsRml0VmVydGljYWxCb3giLCJsZWZ0UGFkZGluZ0FkZGl0aW9uIiwidG9wUGFkZGluZ0FkZGl0aW9uIiwibmV3TWF4Q2hhcnRBcmVhSGVpZ2h0IiwibmV3TWF4Q2hhcnRBcmVhV2lkdGgiLCJwbGFjZUJveCIsInBsYXRmb3JtX2Jhc2ljIiwiYWNxdWlyZUNvbnRleHQiLCJnZXRDb250ZXh0IiwicGxhdGZvcm1fZG9tIiwicGxhdGZvcm1fZG9tJDEiLCJnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlIiwic3R5bGVzaGVldCIsIkVYUEFORE9fS0VZIiwiQ1NTX1BSRUZJWCIsIkNTU19TSVpFX01PTklUT1IiLCJDU1NfUkVOREVSX01PTklUT1IiLCJDU1NfUkVOREVSX0FOSU1BVElPTiIsIkFOSU1BVElPTl9TVEFSVF9FVkVOVFMiLCJFVkVOVF9UWVBFUyIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJkb3duIiwicG9pbnRlcm1vdmUiLCJwb2ludGVydXAiLCJwb2ludGVybGVhdmUiLCJwb2ludGVyb3V0IiwicmVhZFVzZWRTaXplIiwiaW5pdENhbnZhcyIsInJlbmRlckhlaWdodCIsInJlbmRlcldpZHRoIiwiZGlzcGxheVdpZHRoIiwiYXNwZWN0UmF0aW8iLCJkaXNwbGF5SGVpZ2h0Iiwic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsInN1cHBvcnRzIiwiZXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwibmF0aXZlRXZlbnQiLCJmcm9tTmF0aXZlRXZlbnQiLCJ0aHJvdHRsZWQiLCJ0aWNraW5nIiwiY3JlYXRlRGl2IiwiY2xhc3NOYW1lIiwiY3JlYXRlUmVzaXplciIsIm1heFNpemUiLCJyZXNpemVyIiwiZXhwYW5kIiwic2hyaW5rIiwiX3Jlc2V0Iiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIm9uU2Nyb2xsIiwid2F0Y2hGb3JSZW5kZXIiLCJleHBhbmRvIiwicmVuZGVyUHJveHkiLCJhbmltYXRpb25OYW1lIiwicmVmbG93Iiwib2Zmc2V0UGFyZW50IiwidW53YXRjaEZvclJlbmRlciIsImFkZFJlc2l6ZUxpc3RlbmVyIiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsImNsaWVudFdpZHRoIiwicmVtb3ZlUmVzaXplTGlzdGVuZXIiLCJpbmplY3RDU1MiLCJfc3R5bGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInBsYXRmb3JtX2RvbSQyIiwiZGlzYWJsZUNTU0luamVjdGlvbiIsIl9lbmFibGVkIiwiX2Vuc3VyZUxvYWRlZCIsIl9sb2FkZWQiLCJnZXRFbGVtZW50QnlJZCIsInJlbGVhc2VDb250ZXh0IiwicHJveGllcyIsImFkZEV2ZW50IiwicmVtb3ZlRXZlbnQiLCJpbXBsZW1lbnRhdGlvbiIsInBsdWdpbnMiLCJjb3JlX3BsdWdpbnMiLCJfcGx1Z2lucyIsIl9jYWNoZUlkIiwicmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwiaWR4IiwiZ2V0QWxsIiwiZGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9yIiwiJHBsdWdpbnMiLCJfaW52YWxpZGF0ZSIsImNvcmVfc2NhbGVTZXJ2aWNlIiwiY29uc3RydWN0b3JzIiwicmVnaXN0ZXJTY2FsZVR5cGUiLCJzY2FsZUNvbnN0cnVjdG9yIiwic2NhbGVEZWZhdWx0cyIsImdldFNjYWxlQ29uc3RydWN0b3IiLCJnZXRTY2FsZURlZmF1bHRzIiwidXBkYXRlU2NhbGVEZWZhdWx0cyIsImFkZGl0aW9ucyIsImFkZFNjYWxlc1RvTGF5b3V0IiwidmFsdWVPckRlZmF1bHQkNyIsImVuYWJsZWQiLCJ0aXRsZUZvbnRTdHlsZSIsInRpdGxlU3BhY2luZyIsInRpdGxlTWFyZ2luQm90dG9tIiwidGl0bGVGb250Q29sb3IiLCJ0aXRsZUFsaWduIiwiYm9keVNwYWNpbmciLCJib2R5Rm9udENvbG9yIiwiYm9keUFsaWduIiwiZm9vdGVyRm9udFN0eWxlIiwiZm9vdGVyU3BhY2luZyIsImZvb3Rlck1hcmdpblRvcCIsImZvb3RlckZvbnRDb2xvciIsImZvb3RlckFsaWduIiwieVBhZGRpbmciLCJ4UGFkZGluZyIsImNhcmV0UGFkZGluZyIsImNhcmV0U2l6ZSIsIm11bHRpS2V5QmFja2dyb3VuZCIsImRpc3BsYXlDb2xvcnMiLCJiZWZvcmVUaXRsZSIsInRvb2x0aXBJdGVtcyIsImxhYmVsQ291bnQiLCJhZnRlclRpdGxlIiwiYmVmb3JlQm9keSIsImJlZm9yZUxhYmVsIiwibGFiZWxDb2xvciIsImxhYmVsVGV4dENvbG9yIiwiYWZ0ZXJMYWJlbCIsImFmdGVyQm9keSIsImJlZm9yZUZvb3RlciIsImZvb3RlciIsImFmdGVyRm9vdGVyIiwicG9zaXRpb25lcnMiLCJhdmVyYWdlIiwiZXZlbnRQb3NpdGlvbiIsIm5lYXJlc3RFbGVtZW50IiwiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwidHAiLCJwdXNoT3JDb25jYXQiLCJ0b1B1c2giLCJzcGxpdE5ld2xpbmVzIiwiY3JlYXRlVG9vbHRpcEl0ZW0iLCJpbmRleFNjYWxlIiwidmFsdWVTY2FsZSIsImdldExhYmVsRm9ySW5kZXgiLCJnZXRCYXNlTW9kZWwiLCJ0b29sdGlwT3B0cyIsInhBbGlnbiIsInlBbGlnbiIsIl9ib2R5Rm9udEZhbWlseSIsImJvZHlGb250RmFtaWx5IiwiX2JvZHlGb250U3R5bGUiLCJib2R5Rm9udFN0eWxlIiwiX2JvZHlBbGlnbiIsImJvZHlGb250U2l6ZSIsIl90aXRsZUZvbnRGYW1pbHkiLCJ0aXRsZUZvbnRGYW1pbHkiLCJfdGl0bGVGb250U3R5bGUiLCJ0aXRsZUZvbnRTaXplIiwiX3RpdGxlQWxpZ24iLCJfZm9vdGVyRm9udEZhbWlseSIsImZvb3RlckZvbnRGYW1pbHkiLCJfZm9vdGVyRm9udFN0eWxlIiwiZm9vdGVyRm9udFNpemUiLCJfZm9vdGVyQWxpZ24iLCJvcGFjaXR5IiwibGVnZW5kQ29sb3JCYWNrZ3JvdW5kIiwiZ2V0VG9vbHRpcFNpemUiLCJ0b29sdGlwIiwiY29tYmluZWRCb2R5TGVuZ3RoIiwiYm9keUl0ZW0iLCJhZnRlciIsInRpdGxlTGluZUNvdW50IiwiZm9vdGVyTGluZUNvdW50Iiwid2lkdGhQYWRkaW5nIiwibWF4TGluZVdpZHRoIiwibWVhc3VyZVRleHQiLCJmb250U3RyaW5nIiwiZGV0ZXJtaW5lQWxpZ25tZW50IiwibGYiLCJyZiIsIm9sZiIsIm9yZiIsInlmIiwibWlkWCIsIm1pZFkiLCJnZXRCYWNrZ3JvdW5kUG9pbnQiLCJhbGlnbm1lbnQiLCJwYWRkaW5nQW5kU2l6ZSIsInJhZGl1c0FuZFBhZGRpbmciLCJnZXRBbGlnbmVkWCIsImFsaWduIiwiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCJleHBvcnRzJDMiLCJfbGFzdEFjdGl2ZSIsImdldFRpdGxlIiwiZ2V0QmVmb3JlQm9keSIsImdldEJvZHkiLCJib2R5SXRlbXMiLCJnZXRBZnRlckJvZHkiLCJnZXRGb290ZXIiLCJjaGFuZ2VkIiwiZXhpc3RpbmdNb2RlbCIsIl9hY3RpdmUiLCJiYWNrZ3JvdW5kUG9pbnQiLCJ0b29sdGlwU2l6ZSIsImNhcmV0WCIsImNhcmV0WSIsImxhYmVsQ29sb3JzIiwibGFiZWxUZXh0Q29sb3JzIiwiX2V2ZW50UG9zaXRpb24iLCJpdGVtU29ydCIsImRhdGFQb2ludHMiLCJkcmF3Q2FyZXQiLCJ0b29sdGlwUG9pbnQiLCJjYXJldFBvc2l0aW9uIiwiZ2V0Q2FyZXRQb3NpdGlvbiIsIngzIiwieTMiLCJwdFgiLCJwdFkiLCJkcmF3VGl0bGUiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsVGV4dCIsImRyYXdCb2R5IiwiZHJhd0NvbG9yQm94ZXMiLCJ4TGluZVBhZGRpbmciLCJjb2xvclgiLCJ0ZXh0Q29sb3IiLCJmaWxsTGluZU9mVGV4dCIsInN0cm9rZVJlY3QiLCJkcmF3Rm9vdGVyIiwiZHJhd0JhY2tncm91bmQiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiaGFzVG9vbHRpcENvbnRlbnQiLCJnbG9iYWxBbHBoYSIsImhhbmRsZUV2ZW50IiwiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsInBvc2l0aW9uZXJzXzEiLCJjb3JlX3Rvb2x0aXAiLCJ2YWx1ZU9yRGVmYXVsdCQ4Iiwib25Ib3ZlciIsImFuaW1hdGlvbkR1cmF0aW9uIiwicmVzcG9uc2l2ZSIsInJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvbiIsIm1lcmdlU2NhbGVDb25maWciLCJzbGVuIiwibWVyZ2VDb25maWciLCJpbml0Q29uZmlnIiwidXBkYXRlQ29uZmlnIiwibmV3T3B0aW9ucyIsImVuc3VyZVNjYWxlc0hhdmVJRHMiLCJidWlsZE9yVXBkYXRlU2NhbGVzIiwicG9zaXRpb25Jc0hvcml6b250YWwiLCJDaGFydCIsImNvbnN0cnVjdCIsIl9idWZmZXJlZFJlbmRlciIsImluc3RhbmNlcyIsInJldGluYVNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImJpbmRFdmVudHMiLCJyZXNpemUiLCJpbml0VG9vbFRpcCIsIm5ld1dpZHRoIiwiZ2V0TWF4aW11bVdpZHRoIiwibmV3SGVpZ2h0IiwiZ2V0TWF4aW11bUhlaWdodCIsIm5ld1NpemUiLCJvblJlc2l6ZSIsInNjYWxlc09wdGlvbnMiLCJzY2FsZU9wdGlvbnMiLCJ4QXhpc09wdGlvbnMiLCJ5QXhpc09wdGlvbnMiLCJkdHlwZSIsImRwb3NpdGlvbiIsImlzRGVmYXVsdCIsInNjYWxlVHlwZSIsInNjYWxlQ2xhc3MiLCJtZXJnZVRpY2tzT3B0aW9ucyIsImhhc1VwZGF0ZWQiLCJidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMiLCJuZXdDb250cm9sbGVycyIsImRlc3Ryb3lEYXRhc2V0TWV0YSIsIkNvbnRyb2xsZXJDbGFzcyIsInJlc2V0RWxlbWVudHMiLCJ1cGRhdGVMYXlvdXQiLCJ1cGRhdGVEYXRhc2V0cyIsImxhc3RBY3RpdmUiLCJfYnVmZmVyZWRSZXF1ZXN0IiwidXBkYXRlRGF0YXNldCIsImFuaW1hdGlvbk9wdGlvbnMiLCJhbmltYXRpb25PYmplY3QiLCJlYXNpbmdGdW5jdGlvbiIsInN0ZXBEZWNpbWFsIiwiZHJhd0RhdGFzZXRzIiwiX2RyYXdUb29sdGlwIiwiZHJhd0RhdGFzZXQiLCJnZXRFbGVtZW50QXRFdmVudCIsImdldEVsZW1lbnRzQXRFdmVudCIsImdldEVsZW1lbnRzQXRYQXhpcyIsImdldERhdGFzZXRBdEV2ZW50IiwiX21ldGEiLCJnZW5lcmF0ZUxlZ2VuZCIsInVuYmluZEV2ZW50cyIsInRvQmFzZTY0SW1hZ2UiLCJ0b0RhdGFVUkwiLCJfY2hhcnRJbnN0YW5jZSIsIl9saXN0ZW5lcnMiLCJldmVudEhhbmRsZXIiLCJ1cGRhdGVIb3ZlclN0eWxlIiwiYnVmZmVyZWRSZXF1ZXN0IiwiaG92ZXJPcHRpb25zIiwiY29yZV9jb250cm9sbGVyIiwiQ29udHJvbGxlciIsImNvbmZpZ01lcmdlIiwic2NhbGVNZXJnZSIsImNvcmVfaGVscGVycyIsImZpbHRlckNhbGxiYWNrIiwiZmlsdGVyZWQiLCJhcnJheVRvU2VhcmNoIiwic3RhcnRJbmRleCIsImN1cnJlbnRJdGVtIiwiZmluZFByZXZpb3VzV2hlcmUiLCJhbG1vc3RFcXVhbHMiLCJhbG1vc3RXaG9sZSIsInJvdW5kZWQiLCJORUdBVElWRV9JTkZJTklUWSIsImxvZzEwIiwiZXhwb25lbnQiLCJMT0cxMEUiLCJwb3dlck9mMTAiLCJpc1Bvd2VyT2YxMCIsInRvUmFkaWFucyIsInRvRGVncmVlcyIsInJhZGlhbnMiLCJfZGVjaW1hbFBsYWNlcyIsImNlbnRyZVBvaW50IiwiYW5nbGVQb2ludCIsImRpc3RhbmNlRnJvbVhDZW50ZXIiLCJkaXN0YW5jZUZyb21ZQ2VudGVyIiwicmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyIiwiYWxpYXNQaXhlbCIsInBpeGVsV2lkdGgiLCJfYWxpZ25QaXhlbCIsInBpeGVsIiwiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCJoYWxmV2lkdGgiLCJmaXJzdFBvaW50IiwibWlkZGxlUG9pbnQiLCJhZnRlclBvaW50IiwiZDAxIiwiZDEyIiwiczAxIiwiczEyIiwiZmEiLCJmYiIsIkVQU0lMT04iLCJwb2ludHNXaXRoVGFuZ2VudHMiLCJkZWx0YUsiLCJtSyIsInBvaW50c0xlbiIsInBvaW50QmVmb3JlIiwicG9pbnRDdXJyZW50IiwicG9pbnRBZnRlciIsInNsb3BlRGVsdGFYIiwiYWxwaGFLIiwiYmV0YUsiLCJ0YXVLIiwic3F1YXJlZE1hZ25pdHVkZSIsImxvb3AiLCJuaWNlTnVtIiwiZnJhY3Rpb24iLCJuaWNlRnJhY3Rpb24iLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJldnQiLCJvcmlnaW5hbEV2ZW50Iiwic3JjRWxlbWVudCIsImJvdW5kaW5nUmVjdCIsInRvdWNoZXMiLCJjbGllbnRYIiwiY2xpZW50WSIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdCb3R0b20iLCJwYXJzZU1heFN0eWxlIiwicGFyZW50UHJvcGVydHkiLCJ2YWx1ZUluUGl4ZWxzIiwiaXNDb25zdHJhaW5lZFZhbHVlIiwiZ2V0Q29uc3RyYWludERpbWVuc2lvbiIsImRvbU5vZGUiLCJtYXhTdHlsZSIsInBlcmNlbnRhZ2VQcm9wZXJ0eSIsImRlZmF1bHRWaWV3IiwiX2dldFBhcmVudE5vZGUiLCJjb25zdHJhaW5lZE5vZGUiLCJjb25zdHJhaW5lZENvbnRhaW5lciIsImhhc0NOb2RlIiwiaGFzQ0NvbnRhaW5lciIsImluZmluaXR5IiwiZ2V0Q29uc3RyYWludFdpZHRoIiwiZ2V0Q29uc3RyYWludEhlaWdodCIsIl9jYWxjdWxhdGVQYWRkaW5nIiwicGFyZW50RGltZW5zaW9uIiwiaG9zdCIsImN3IiwiY2xpZW50SGVpZ2h0IiwiY3VycmVudFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImZvcmNlUmF0aW8iLCJwaXhlbFJhdGlvIiwicGl4ZWxTaXplIiwibG9uZ2VzdFRleHQiLCJhcnJheU9mVGhpbmdzIiwiZ2MiLCJnYXJiYWdlQ29sbGVjdCIsImxvbmdlc3QiLCJ0aGluZyIsIm5lc3RlZFRoaW5nIiwiZ2NMZW4iLCJ0ZXh0V2lkdGgiLCJudW1iZXJPZkxhYmVsTGluZXMiLCJudW1iZXJPZkxpbmVzIiwiY29sb3IiLCJDYW52YXNHcmFkaWVudCIsImNvbG9yVmFsdWUiLCJDYW52YXNQYXR0ZXJuIiwiRGF0ZUFkYXB0ZXIiLCJfY3JlYXRlIiwib3ZlcnJpZGUiLCJtZW1iZXJzIiwiX2RhdGUiLCJjb3JlX2FkYXB0ZXJzIiwiY29yZV90aWNrcyIsImZvcm1hdHRlcnMiLCJ0aWNrVmFsdWUiLCJsb2dEZWx0YSIsInRpY2tTdHJpbmciLCJtYXhUaWNrIiwibG9nVGljayIsInRvRXhwb25lbnRpYWwiLCJudW1EZWNpbWFsIiwibG9nYXJpdGhtaWMiLCJyZW1haW4iLCJ2YWx1ZU9yRGVmYXVsdCQ5IiwiZHJhd0JvcmRlciIsImRyYXdPbkNoYXJ0QXJlYSIsImRyYXdUaWNrcyIsInRpY2tNYXJrTGVuZ3RoIiwiemVyb0xpbmVXaWR0aCIsInplcm9MaW5lQ29sb3IiLCJ6ZXJvTGluZUJvcmRlckRhc2giLCJ6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQiLCJzY2FsZUxhYmVsIiwibGFiZWxTdHJpbmciLCJtaW5Sb3RhdGlvbiIsIm1heFJvdGF0aW9uIiwibWlycm9yIiwiYXV0b1NraXAiLCJhdXRvU2tpcFBhZGRpbmciLCJsYWJlbE9mZnNldCIsIm1pbm9yIiwibWFqb3IiLCJsYWJlbHNGcm9tVGlja3MiLCJnZXRQaXhlbEZvckdyaWRMaW5lIiwibGluZVZhbHVlIiwiY29tcHV0ZVRleHRTaXplIiwidGljayIsImNvcmVfc2NhbGUiLCJfdGlja3MiLCJiZWZvcmVVcGRhdGUiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm1hcmdpbnMiLCJfbWF4TGFiZWxMaW5lcyIsImxvbmdlc3RMYWJlbFdpZHRoIiwibG9uZ2VzdFRleHRDYWNoZSIsImJlZm9yZVNldERpbWVuc2lvbnMiLCJzZXREaW1lbnNpb25zIiwiYWZ0ZXJTZXREaW1lbnNpb25zIiwiYmVmb3JlRGF0YUxpbWl0cyIsImRldGVybWluZURhdGFMaW1pdHMiLCJhZnRlckRhdGFMaW1pdHMiLCJiZWZvcmVCdWlsZFRpY2tzIiwiYnVpbGRUaWNrcyIsImFmdGVyQnVpbGRUaWNrcyIsImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImNvbnZlcnRUaWNrc1RvTGFiZWxzIiwiYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJiZWZvcmVDYWxjdWxhdGVUaWNrUm90YXRpb24iLCJjYWxjdWxhdGVUaWNrUm90YXRpb24iLCJhZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImJlZm9yZUZpdCIsImZpdCIsImFmdGVyRml0IiwiYWZ0ZXJVcGRhdGUiLCJ0aWNrT3B0cyIsInVzZXJDYWxsYmFjayIsInRpY2tGb250IiwibGFiZWxSb3RhdGlvbiIsIm9yaWdpbmFsTGFiZWxXaWR0aCIsImxhYmVsV2lkdGgiLCJjb3NSb3RhdGlvbiIsInNpblJvdGF0aW9uIiwidGlja1dpZHRoIiwiYW5nbGVSYWRpYW5zIiwic2NhbGVMYWJlbE9wdHMiLCJncmlkTGluZU9wdHMiLCJfaXNWaXNpYmxlIiwicGFyc2VGb250IiwiaXNGdWxsV2lkdGgiLCJzY2FsZUxhYmVsRm9udCIsInNjYWxlTGFiZWxQYWRkaW5nIiwiZGVsdGFIZWlnaHQiLCJsYXJnZXN0VGV4dFdpZHRoIiwidGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcyIsImxpbmVTcGFjZSIsInRpY2tQYWRkaW5nIiwibGFiZWxIZWlnaHQiLCJmaXJzdExhYmVsV2lkdGgiLCJsYXN0TGFiZWxXaWR0aCIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsImhhbmRsZU1hcmdpbnMiLCJyYXdWYWx1ZSIsImdldFZhbHVlRm9yUGl4ZWwiLCJpbm5lcldpZHRoIiwiZmluYWxWYWwiLCJpbm5lckhlaWdodCIsImRlY2ltYWwiLCJ2YWx1ZU9mZnNldCIsImdldEJhc2VWYWx1ZSIsIl9hdXRvU2tpcCIsIm9wdGlvblRpY2tzIiwidGlja0NvdW50Iiwic2tpcFJhdGlvIiwibWF4VGlja3MiLCJtYXhUaWNrc0xpbWl0IiwidGlja3NMZW5ndGgiLCJfdGlja1NpemUiLCJheGlzTGVuZ3RoIiwiUGFkZGluZ0JvdHRvbSIsInJvdCIsIm9wdGlvbk1ham9yVGlja3MiLCJpc1JvdGF0ZWQiLCJpc01pcnJvcmVkIiwidGlja0ZvbnRDb2xvciIsImZvbnRDb2xvciIsIm1ham9yVGlja0ZvbnRDb2xvciIsIm1ham9yVGlja0ZvbnQiLCJ0bCIsInNjYWxlTGFiZWxGb250Q29sb3IiLCJsYWJlbFJvdGF0aW9uUmFkaWFucyIsIml0ZW1zVG9EcmF3IiwiYXhpc1dpZHRoIiwiYWxpZ25QaXhlbCIsImJvcmRlclZhbHVlIiwidGlja1N0YXJ0IiwidGlja0VuZCIsImxpbmVDb2xvciIsInplcm9MaW5lSW5kZXgiLCJ0eDEiLCJ0eTEiLCJ0eDIiLCJ0eTIiLCJsYWJlbFgiLCJsYWJlbFkiLCJ0ZXh0T2Zmc2V0IiwibGFiZWxZT2Zmc2V0IiwibGFiZWxYT2Zmc2V0IiwiZ2xXaWR0aCIsImdsQ29sb3IiLCJnbEJvcmRlckRhc2giLCJnbEJvcmRlckRhc2hPZmZzZXQiLCJpdGVtVG9EcmF3IiwidHJhbnNsYXRlIiwic2NhbGVMYWJlbFgiLCJzY2FsZUxhYmVsWSIsImhhbGZMaW5lSGVpZ2h0IiwiaXNMZWZ0IiwiZmlyc3RMaW5lV2lkdGgiLCJsYXN0TGluZVdpZHRoIiwiZGVmYXVsdENvbmZpZyIsInNjYWxlX2NhdGVnb3J5IiwiZ2V0TGFiZWxzIiwibWluSW5kZXgiLCJtYXhJbmRleCIsIm9mZnNldEFtdCIsInZhbHVlQ2F0ZWdvcnkiLCJ2YWx1ZVdpZHRoIiwid2lkdGhPZmZzZXQiLCJ2YWx1ZUhlaWdodCIsImhlaWdodE9mZnNldCIsImhvcnoiLCJ2YWx1ZURpbWVuc2lvbiIsIl9kZWZhdWx0cyIsImdlbmVyYXRlVGlja3MiLCJnZW5lcmF0aW9uT3B0aW9ucyIsImRhdGFSYW5nZSIsIk1JTl9TUEFDSU5HIiwic3RlcFNpemUiLCJtYXhOdW1TcGFjZXMiLCJwcmVjaXNpb24iLCJybWluIiwicm1heCIsInNwYWNpbmciLCJmYWN0b3IiLCJuaWNlTWluIiwibmljZU1heCIsIm51bVNwYWNlcyIsInNjYWxlX2xpbmVhcmJhc2UiLCJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zIiwibWluU2lnbiIsIm1heFNpZ24iLCJzZXRNaW4iLCJzdWdnZXN0ZWRNaW4iLCJzZXRNYXgiLCJzdWdnZXN0ZWRNYXgiLCJnZXRUaWNrTGltaXQiLCJfY29tcHV0ZVRpY2tMaW1pdCIsImhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlcyIsIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwiZml4ZWRTdGVwU2l6ZSIsInRpY2tzQXNOdW1iZXJzIiwiZGVmYXVsdENvbmZpZyQxIiwic2NhbGVfbGluZWFyIiwiREVGQVVMVF9NSU4iLCJERUZBVUxUX01BWCIsIklETWF0Y2hlcyIsImhhc1N0YWNrcyIsInZhbHVlc1BlclN0YWNrIiwicG9zaXRpdmVWYWx1ZXMiLCJuZWdhdGl2ZVZhbHVlcyIsInJlbGF0aXZlUG9pbnRzIiwidmFsdWVzRm9yVHlwZSIsIm1pblZhbCIsIm1heFZhbCIsImlubmVyRGltZW5zaW9uIiwiX2RlZmF1bHRzJDEiLCJ2YWx1ZU9yRGVmYXVsdCRhIiwiZ2VuZXJhdGVUaWNrcyQxIiwidGlja1ZhbCIsImVuZEV4cCIsImVuZFNpZ25pZmljYW5kIiwic2lnbmlmaWNhbmQiLCJtaW5Ob3RaZXJvIiwibGFzdFRpY2siLCJkZWZhdWx0Q29uZmlnJDIiLCJub25OZWdhdGl2ZU9yRGVmYXVsdCIsInNjYWxlX2xvZ2FyaXRobWljIiwidGlja1ZhbHVlcyIsIl9nZXRGaXJzdFRpY2tWYWx1ZSIsImZpcnN0VGlja1ZhbHVlIiwiX2RlZmF1bHRzJDIiLCJ2YWx1ZU9yRGVmYXVsdCRiIiwidmFsdWVBdEluZGV4T3JEZWZhdWx0JDEiLCJyZXNvbHZlJDciLCJkZWZhdWx0Q29uZmlnJDMiLCJhbmltYXRlIiwic2hvd0xhYmVsQmFja2Ryb3AiLCJiYWNrZHJvcENvbG9yIiwiYmFja2Ryb3BQYWRkaW5nWSIsImJhY2tkcm9wUGFkZGluZ1giLCJnZXRWYWx1ZUNvdW50IiwiZ2V0VGlja0JhY2tkcm9wSGVpZ2h0IiwibWVhc3VyZUxhYmVsU2l6ZSIsImRldGVybWluZUxpbWl0cyIsImZpdFdpdGhQb2ludExhYmVscyIsInBsRm9udCIsImZ1cnRoZXN0TGltaXRzIiwiZnVydGhlc3RBbmdsZXMiLCJ0ZXh0U2l6ZSIsIl9wb2ludExhYmVsU2l6ZXMiLCJ2YWx1ZUNvdW50IiwiZ2V0UG9pbnRQb3NpdGlvbiIsImRyYXdpbmdBcmVhIiwiZ2V0SW5kZXhBbmdsZSIsImhMaW1pdHMiLCJ2TGltaXRzIiwic2V0UmVkdWN0aW9ucyIsImdldFRleHRBbGlnbkZvckFuZ2xlIiwiYWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0IiwiZHJhd1BvaW50TGFiZWxzIiwiYW5nbGVMaW5lT3B0cyIsInBvaW50TGFiZWxPcHRzIiwidGlja0JhY2tkcm9wSGVpZ2h0Iiwib3V0ZXJEaXN0YW5jZSIsIm91dGVyUG9zaXRpb24iLCJleHRyYSIsInBvaW50TGFiZWxQb3NpdGlvbiIsInBvaW50TGFiZWxGb250Q29sb3IiLCJkcmF3UmFkaXVzTGluZSIsIm51bWJlck9yWmVybyIsInNjYWxlX3JhZGlhbExpbmVhciIsInNldENlbnRlclBvaW50IiwibGFyZ2VzdFBvc3NpYmxlUmFkaXVzIiwicmFkaXVzUmVkdWN0aW9uTGVmdCIsInJhZGl1c1JlZHVjdGlvblJpZ2h0IiwicmFkaXVzUmVkdWN0aW9uVG9wIiwicmFkaXVzUmVkdWN0aW9uQm90dG9tIiwibGVmdE1vdmVtZW50IiwicmlnaHRNb3ZlbWVudCIsInRvcE1vdmVtZW50IiwiYm90dG9tTW92ZW1lbnQiLCJtYXhSaWdodCIsIm1heExlZnQiLCJtYXhUb3AiLCJtYXhCb3R0b20iLCJhbmdsZU11bHRpcGxpZXIiLCJzdGFydEFuZ2xlUmFkaWFucyIsInNjYWxpbmdGYWN0b3IiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJ0aGlzQW5nbGUiLCJnZXRCYXNlUG9zaXRpb24iLCJ5Q2VudGVyT2Zmc2V0IiwiX2RlZmF1bHRzJDMiLCJ2YWx1ZU9yRGVmYXVsdCRjIiwiTUlOX0lOVEVHRVIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiTUFYX0lOVEVHRVIiLCJJTlRFUlZBTFMiLCJjb21tb24iLCJzdGVwcyIsIlVOSVRTIiwic29ydGVyIiwiYXJyYXlVbmlxdWUiLCJidWlsZExvb2t1cFRhYmxlIiwidGltZXN0YW1wcyIsImRpc3RyaWJ1dGlvbiIsInRhYmxlIiwibG9va3VwIiwibG8iLCJtaWQiLCJpMCIsImkxIiwiaW50ZXJwb2xhdGUkMSIsInNrZXkiLCJ0a2V5Iiwic3BhbiIsInRvVGltZXN0YW1wIiwiYWRhcHRlciIsIl9hZGFwdGVyIiwicGFyc2VyIiwiZGV0ZXJtaW5lU3RlcFNpemUiLCJjYXBhY2l0eSIsImludGVydmFsIiwiZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyIsIm1pblVuaXQiLCJkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyIsImRldGVybWluZU1ham9yVW5pdCIsInRpbWVPcHRzIiwidW5pdFN0ZXBTaXplIiwibWFqb3JUaWNrc0VuYWJsZWQiLCJmaXJzdCIsImNvbXB1dGVPZmZzZXRzIiwidGlja3NGcm9tVGltZXN0YW1wcyIsIm1ham9yVW5pdCIsImRlZmF1bHRDb25maWckNCIsImFkYXB0ZXJzIiwiZGlzcGxheUZvcm1hdCIsImRpc3BsYXlGb3JtYXRzIiwic2NhbGVfdGltZSIsInRpbWVzdGFtcCIsImRhdGFMYWJlbHMiLCJfaG9yaXpvbnRhbCIsIl90YWJsZSIsIl90aW1lc3RhbXBzIiwiZ2V0TGFiZWxDYXBhY2l0eSIsIl91bml0IiwiX21ham9yVW5pdCIsIl9vZmZzZXRzIiwidG9vbHRpcEZvcm1hdCIsInRpY2tGb3JtYXRGdW5jdGlvbiIsIm1pbm9yRm9ybWF0IiwibWFqb3JGb3JtYXQiLCJtYWpvclRpbWUiLCJtYWpvclRpY2tPcHRzIiwiZm9ybWF0dGVyIiwiZ2V0UGl4ZWxGb3JPZmZzZXQiLCJpc1JldmVyc2UiLCJnZXRMYWJlbFdpZHRoIiwidGlja3NPcHRzIiwidGlja0xhYmVsV2lkdGgiLCJ0aWNrRm9udFNpemUiLCJleGFtcGxlVGltZSIsImV4YW1wbGVMYWJlbCIsIl9kZWZhdWx0cyQ0IiwiY2F0ZWdvcnkiLCJyYWRpYWxMaW5lYXIiLCJGT1JNQVRTIiwiX2lkIiwiYW1vdW50IiwiZmlsbGVyIiwicHJvcGFnYXRlIiwibWFwcGVycyIsInZpc2libGUiLCJib3VuZGFyeSIsImRlY29kZUZpbGwiLCJjb21wdXRlQm91bmRhcnkiLCJzY2FsZUJvdHRvbSIsInNjYWxlVG9wIiwic2NhbGVaZXJvIiwicmVzb2x2ZVRhcmdldCIsInZpc2l0ZWQiLCJjcmVhdGVNYXBwZXIiLCJpc0RyYXdhYmxlIiwiZHJhd0FyZWEiLCJjdXJ2ZTAiLCJjdXJ2ZTEiLCJsZW4wIiwibGVuMSIsImRvRmlsbCIsIm1hcHBlciIsInAwIiwiZDAiLCJkMSIsInBsdWdpbl9maWxsZXIiLCJhZnRlckRhdGFzZXRzVXBkYXRlIiwiJGZpbGxlciIsImJlZm9yZURhdGFzZXREcmF3Iiwibm9vcCQxIiwidmFsdWVPckRlZmF1bHQkZCIsImNpIiwib25MZWF2ZSIsImJveFdpZHRoIiwibGluZURhc2giLCJnZXRCb3hXaWR0aCIsImxhYmVsT3B0cyIsInVzZVBvaW50U3R5bGUiLCJMZWdlbmQiLCJsZWdlbmRIaXRCb3hlcyIsIl9ob3ZlcmVkSXRlbSIsImRvdWdobnV0TW9kZSIsImJlZm9yZUJ1aWxkTGFiZWxzIiwiYnVpbGRMYWJlbHMiLCJhZnRlckJ1aWxkTGFiZWxzIiwibGVnZW5kSXRlbXMiLCJsYWJlbEZvbnQiLCJoaXRib3hlcyIsImxpbmVXaWR0aHMiLCJ0b3RhbEhlaWdodCIsInZQYWRkaW5nIiwiY29sdW1uV2lkdGhzIiwidG90YWxXaWR0aCIsImN1cnJlbnRDb2xXaWR0aCIsImN1cnJlbnRDb2xIZWlnaHQiLCJpdGVtSGVpZ2h0IiwiaXRlbVdpZHRoIiwibGluZURlZmF1bHQiLCJsZWdlbmRXaWR0aCIsImN1cnNvciIsImRyYXdMZWdlbmRCb3giLCJTUVJUMiIsImhhbGZGb250U2l6ZSIsInhMZWZ0IiwieU1pZGRsZSIsIl9nZXRMZWdlbmRJdGVtQXQiLCJoaXRCb3giLCJsaCIsImhvdmVyZWRJdGVtIiwiY3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoIiwibGVnZW5kT3B0cyIsInBsdWdpbl9sZWdlbmQiLCJfZWxlbWVudCIsImJlZm9yZUluaXQiLCJhZnRlckV2ZW50Iiwibm9vcCQyIiwiVGl0bGUiLCJsaW5lQ291bnQiLCJmb250T3B0cyIsInRpdGxlWCIsInRpdGxlWSIsImNyZWF0ZU5ld1RpdGxlQmxvY2tBbmRBdHRhY2giLCJ0aXRsZU9wdHMiLCJ0aXRsZUJsb2NrIiwicGx1Z2luX3RpdGxlIiwiX2FkYXB0ZXJzIiwiQW5pbWF0aW9uIiwiYW5pbWF0aW9uU2VydmljZSIsIkludGVyYWN0aW9uIiwibGF5b3V0cyIsIlNjYWxlIiwic2NhbGVTZXJ2aWNlIiwiVGlja3MiLCJUb29sdGlwIiwicGx1Z2luU2VydmljZSIsIlBsdWdpbkJhc2UiLCJjYW52YXNIZWxwZXJzIiwibGF5b3V0U2VydmljZSIsIkxpbmVhclNjYWxlQmFzZSIsImNmZyIsImdlbmVyYXRlQ2hhcnQiLCJjaGFydElkIiwiY2hhcnRUeXBlIiwiY3NzQ2xhc3NlcyIsIl9kZWZhdWx0IiwiYWRkUGx1Z2luIiwiYmVmb3JlRGVzdHJveSIsIkJhciIsIkhvcml6b250YWxCYXIiLCJQaWUiLCJjaGFydExhYmVscyIsImNoYXJ0RGF0YUxpc3QiLCJDaGFydERhdGEiLCJDaGFydEJhciIsIkNoYXJ0Q29tcG9uZW50IiwiQ2hhcnRIb3Jpem9udGFsQmFyIiwiQ2hhcnRMaW5lIiwiQ2hhcnRQaWUiLCJueWNvQ29sb3JzIiwiY29sb3JzIiwiY29sb3JDb21iaW5hdGlvbnMiLCJtYXBDb2xvckNvbWJpbmF0aW9ucyIsIk1hcERhdGEiLCJsYXllcnMiLCJBUElLZXkiLCJjb250YWluZXJJZCIsImxlZ2VuZElkIiwiem9vbSIsImRpc2FibGVTY3JvbGwiLCJtYXBUeXBlIiwibXVsdGkiLCJHZW9KU09OIiwiZG9UaHJvd3MiLCJpbnZhbGlkR2VvbWV0cnkiLCJJbnZhbGlkR2VvbWV0cnlFcnJvciIsImlzR2VvbWV0cnlWYWxpZCIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJvYmplY3RzIiwiZ2VvanNvbiIsImFwcGx5RGVmYXVsdHMiLCJwcm9wRnVuYyIsImdlb21BdHRycyIsInNldEdlb20iLCJnZXRQcm9wRnVuY3Rpb24iLCJmZWF0dXJlcyIsImdldEZlYXR1cmUiLCJhZGRPcHRpb25hbHMiLCJnZW9tcyIsInNldHRpbmciLCJjcnMiLCJjaGVja0NSUyIsImlzUG9zdGdyZXMiLCJiYm94IiwiZXh0cmFHbG9iYWwiLCJwcm9wZXJ0aWVzIiwiZ2VvbSIsInNldEdlb21BdHRyTGlzdCIsImZlYXR1cmUiLCJidWlsZEdlb20iLCJpc05lc3RlZCIsImd0eXBlIiwibmV3SXRlbSIsInBhdGhzIiwiaXRlbUNsb25lIiwiYWRkRXh0cmEiLCJyaW5nQXJlYSIsInBvbHlnb25BcmVhIiwiZ2VvbWV0cmllcyIsImNvb3JkcyIsImxvd2VySW5kZXgiLCJtaWRkbGVJbmRleCIsInVwcGVySW5kZXgiLCJjb29yZHNMZW5ndGgiLCJ3Z3M4NCIsIlJBRElVUyIsInJld2luZCIsImdqIiwiY3VycnlPdXRlciIsImNvcnJlY3QiLCJjb3JyZWN0UmluZ3MiLCJ3aW5kIiwiZ2VvanNvbkFyZWEiLCJyaW5nIiwiTWFwTXVsdGlMYXllciIsIk1hcENvbXBvbmVudCIsImdldFppcGNvZGVEYXRhIiwiZ2V0Qm9yb3VnaERhdGEiLCJnZXROZWlnaGJvcmhvb2REYXRhIiwiZmlsdGVyQnkiLCJjb252ZXJ0VG9HZW9KU09OIiwianNvbkRhdGEiLCJNYXBTaW5nbGVMYXllciIsImxlZ2VuZENvbHVtbiIsImphcm8iLCJzMSIsInMyIiwic2hvcnRlciIsImxvbmdlciIsIm1hdGNoaW5nV2luZG93Iiwic2hvcnRlck1hdGNoZXMiLCJsb25nZXJNYXRjaGVzIiwid2luZG93U3RhcnQiLCJ3aW5kb3dFbmQiLCJzaG9ydGVyTWF0Y2hlc1N0cmluZyIsImxvbmdlck1hdGNoZXNTdHJpbmciLCJudW1NYXRjaGVzIiwidHJhbnNwb3NpdGlvbnMiLCJwcmVmaXhTY2FsaW5nRmFjdG9yIiwiamFyb1NpbWlsYXJpdHkiLCJjb21tb25QcmVmaXhMZW5ndGgiLCJBdXRvY29tcGxldGUiLCJjbGFzc25hbWUiLCJsaXN0SXRlbSIsImdldFNpYmxpbmdJbmRleCIsInNjb3JlZE9wdGlvbnMiLCJ1bCIsImhpZ2hsaWdodGVkIiwic2VsZWN0b3JzIiwiU1RSSU5HUyIsIk1BWF9JVEVNUyIsIm1heEl0ZW1zIiwia2V5ZG93bkV2ZW50Iiwia2V5dXBFdmVudCIsImlucHV0RXZlbnQiLCJmb2N1c0V2ZW50IiwiYmx1ckV2ZW50Iiwia2V5RW50ZXIiLCJrZXlFc2NhcGUiLCJrZXlEb3duIiwia2V5VXAiLCJkcm9wZG93biIsInBlcnNpc3REcm9wZG93biIsImhpZ2hsaWdodCIsInN5bm9ueW1zIiwiY2xvc2VzdFN5bm9ueW0iLCJzeW5vbnltIiwic2ltaWxhcml0eSIsImphcm9XaW5rbGVyIiwiZGlzcGxheVZhbHVlIiwic2NvcmVkT3B0aW9uIiwibm9ybWFsaXplZEluZGV4IiwibGkiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiZG9jdW1lbnRGcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJuZXdVbCIsIk9QVElPTlMiLCJuZXdDb250YWluZXIiLCJuZXdJbmRleCIsIkhJR0hMSUdIVCIsIkFDVElWRV9ERVNDRU5EQU5UIiwic2Nyb2xsSW50b1ZpZXciLCJtZXNzYWdlcyIsIkRJUkVDVElPTlNfVFlQRSIsIk9QVElPTl9BVkFJTEFCTEUiLCJESVJFQ1RJT05TX1JFVklFVyIsIk9QVElPTl9TRUxFQ1RFRCIsIklucHV0QXV0b2NvbXBsZXRlIiwibGlicmFyeSIsImxvY2FsaXplZFN0cmluZ3MiLCJueWNvIiwiaWNvbnMiLCJ0cmFjayIsInNlbGVjdCIsImlucHV0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
