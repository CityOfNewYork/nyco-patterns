'use strict';

/**
 * The Utility class
 * @class
 */

var Utility$1 = function Utility() {
  return this;
};
/**
 * Boolean for debug mode
 * @return {boolean} wether or not the front-end is in debug mode.
 */


Utility$1.debug = function () {
  return Utility$1.getUrlParameter(Utility$1.PARAMS.DEBUG) === '1';
};
/**
 * Returns the value of a given key in a URL query string. If no URL query
 * string is provided, the current URL location is used.
 * @param  {string}  name        - Key name.
 * @param  {?string} queryString - Optional query string to check.
 * @return {?string} Query parameter value.
 */


Utility$1.getUrlParameter = function (name, queryString) {
  var query = queryString || window.location.search;
  var param = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
  var regex = new RegExp('[\\?&]' + param + '=([^&#]*)');
  var results = regex.exec(query);
  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};
/**
 * For translating strings, there is a global LOCALIZED_STRINGS array that
 * is defined on the HTML template level so that those strings are exposed to
 * WPML translation. The LOCALIZED_STRINGS array is composed of objects with a
 * `slug` key whose value is some constant, and a `label` value which is the
 * translated equivalent. This function takes a slug name and returns the
 * label.
 * @param  {string} slug
 * @return {string} localized value
 */


Utility$1.localize = function (slug) {
  var text = slug || '';
  var strings = window.LOCALIZED_STRINGS || [];
  var match = strings.filter(function (s) {
    return s.hasOwnProperty('slug') && s['slug'] === slug ? s : false;
  });
  return match[0] && match[0].hasOwnProperty('label') ? match[0].label : text;
};
/**
 * Application parameters
 * @type {Object}
 */


Utility$1.PARAMS = {
  DEBUG: 'debug'
};
/**
 * Selectors for the Utility module
 * @type {Object}
 */

Utility$1.SELECTORS = {
  parseMarkdown: '[data-js="markdown"]'
};

/**
 * The Icon module
 * @class
 */

var Icons = function Icons(path) {
  path = path ? path : Icons.path;
  fetch(path).then(function (response) {
    if (response.ok) {
      return response.text();
    } else // eslint-disable-next-line no-console
      if (Utility$1.debug()) {
        console.dir(response);
      }
  })["catch"](function (error) {
    // eslint-disable-next-line no-console
    if (Utility$1.debug()) {
      console.dir(error);
    }
  }).then(function (data) {
    var sprite = document.createElement('div');
    sprite.innerHTML = data;
    sprite.setAttribute('aria-hidden', true);
    sprite.setAttribute('style', 'display: none;');
    document.body.appendChild(sprite);
  });
  return this;
};
/** @type {String} The path of the icon file */


Icons.path = 'icons.svg';

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */

var Symbol$1 = root.Symbol;

/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString$1 = objectProto$1.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */

var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto$1 = Function.prototype,
    objectProto$2 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/** Used for built-in method references. */

var objectProto$3 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$2.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString = shortOut(baseSetToString);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */

function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */

function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */

function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */

var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */

var objectProto$4 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty$3.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */

var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */

var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports$1 && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */

var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */

var objectProto$5 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$6;
  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */

var objectProto$7 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */

var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */

var getPrototype = overArg(Object.getPrototypeOf, Object);

/** `Object#toString` result references. */

var objectTag$1 = '[object Object]';
/** Used for built-in method references. */

var funcProto$2 = Function.prototype,
    objectProto$8 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$2 = funcProto$2.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString$2.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
    return false;
  }

  var proto = getPrototype(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty$6.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
}

/** `Object#toString` result references. */

var domExcTag = '[object DOMException]',
    errorTag$1 = '[object Error]';
/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */

function isError(value) {
  if (!isObjectLike(value)) {
    return false;
  }

  var tag = baseGetTag(value);
  return tag == errorTag$1 || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
}

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */

var attempt = baseRest(function (func, args) {
  try {
    return apply(func, undefined, args);
  } catch (e) {
    return isError(e) ? e : new Error(e);
  }
});

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */

function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

/** Used for built-in method references. */

var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */

function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined || eq(objValue, objectProto$9[key]) && !hasOwnProperty$7.call(object, key)) {
    return srcValue;
  }

  return objValue;
}

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};
/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */

var objectProto$a = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function (key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map characters to HTML entities. */

var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

var escapeHtmlChar = basePropertyOf(htmlEscapes);

/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */

function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to match HTML entities and HTML characters. */

var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */

function escape(string) {
  string = toString(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
}

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */

var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': reEscape,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': reEvaluate,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': reInterpolate,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': {
      'escape': escape
    }
  }
};

/** Used to match empty string literals in compiled template source. */

var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */

var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
/** Used to ensure capturing order of template delimiters. */

var reNoMatch = /($^)/;
/** Used to match unescaped characters in compiled string literals. */

var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
/** Used for built-in method references. */

var objectProto$b = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */

function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = templateSettings.imports._.templateSettings || templateSettings;

  if (guard && isIterateeCall(string, options, guard)) {
    options = undefined;
  }

  string = toString(string);
  options = assignInWith({}, options, settings, customDefaultsAssignIn);
  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
      importsKeys = keys(imports),
      importsValues = baseValues(imports, importsKeys);
  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '"; // Compile the regexp to match each delimiter.

  var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
  // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.

  var sourceURL = hasOwnProperty$9.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/[\r\n]/g, ' ') + '\n' : '';
  string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets.

    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }

    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }

    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }

    index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.

    return match;
  });
  source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  // Like with sourceURL, we take care to not check the option's prototype,
  // as this configuration is a code injection vector.

  var variable = hasOwnProperty$9.call(options, 'variable') && options.variable;

  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  } // Cleanup code by stripping empty strings.


  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

  source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
  var result = attempt(function () {
    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
  }); // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.

  result.source = source;

  if (isError(result)) {
    throw result;
  }

  return result;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */

var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */

function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */

var baseEach = createBaseEach(baseForOwn);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */

function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */

function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* Built-in method references that are verified to be native. */

var Map = getNative(root, 'Map');

/* Built-in method references that are verified to be native. */

var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto$c = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$a = objectProto$c.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty$a.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */

var objectProto$d = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$b = objectProto$d.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$b.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/** Detect free variable `exports`. */

var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
/** Built-in value references. */

var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

/** Built-in value references. */

var Uint8Array = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */

function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */

function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;

      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */

var merge = createAssigner(function (object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */

function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);

  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */

function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;
/** `Object#toString` result references. */

var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$2 = '[object Error]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag$1 = '[object Symbol]';
var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag$2:
      return object.name == other.name && object.message == other.message;

    case regexpTag$1:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag$1:
      var convert = mapToArray;

    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */

var objectProto$e = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable$1 = objectProto$e.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$2 = 1;
/** Used for built-in method references. */

var objectProto$f = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$c = objectProto$f.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty$c.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* Built-in method references that are verified to be native. */

var DataView = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */

var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */

var Set$1 = getNative(root, 'Set');

/* Built-in method references that are verified to be native. */

var WeakMap = getNative(root, 'WeakMap');

/** `Object#toString` result references. */

var mapTag$2 = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$2 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';
var dataViewTag$2 = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map && getTag(new Map()) != mapTag$2 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$2 || WeakMap && getTag(new WeakMap()) != weakMapTag$1) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;

        case mapCtorString:
          return mapTag$2;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag$2;

        case weakMapCtorString:
          return weakMapTag$1;
      }
    }

    return result;
  };
}

var getTag$1 = getTag;

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$3 = 1;
/** `Object#toString` result references. */

var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    objectTag$3 = '[object Object]';
/** Used for built-in method references. */

var objectProto$g = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$d = objectProto$g.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag$1 : getTag$1(object),
      othTag = othIsArr ? arrayTag$1 : getTag$1(other);
  objTag = objTag == argsTag$2 ? objectTag$3 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$3 : othTag;
  var objIsObj = objTag == objectTag$3,
      othIsObj = othTag == objectTag$3,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$d.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$d.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */

function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */

function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/** Used to match property names within property paths. */

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */

var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */

function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

/** Used as references for various `Number` constants. */

var INFINITY$1 = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */

function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */

function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */

function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */

function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */

function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */

function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (typeof value == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);

  while (length--) {
    array[length] = array[length].value;
  }

  return array;
}

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */

function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);
    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }

    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }

  return 0;
}

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */

function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);

    if (result) {
      if (index >= ordersLength) {
        return result;
      }

      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  } // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.


  return object.index - other.index;
}

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */

function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
  var result = baseMap(collection, function (value, key, collection) {
    var criteria = arrayMap(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return {
      'criteria': criteria,
      'index': ++index,
      'value': value
    };
  });
  return baseSortBy(result, function (object, other) {
    return compareMultiple(object, other, orders);
  });
}

/**
 * This method is like `_.sortBy` except that it allows specifying the sort
 * orders of the iteratees to sort by. If `orders` is unspecified, all values
 * are sorted in ascending order. Otherwise, specify an order of "desc" for
 * descending or "asc" for ascending sort order of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @param {string[]} [orders] The sort orders of `iteratees`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 34 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 36 }
 * ];
 *
 * // Sort by `user` in ascending order and by `age` in descending order.
 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 */

function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }

  if (!isArray(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }

  orders = guard ? undefined : orders;

  if (!isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }

  return baseOrderBy(collection, iteratees, orders);
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

/** Used as references for various `Number` constants. */

var INFINITY$2 = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY$2) ? noop : function (values) {
  return new Set$1(values);
};

/**
 *
 */

var Feed = function Feed(config) {
  this["default"] = Feed["default"];
  this._settings = merge({}, Feed["default"], config);
  this.init();
};
/**
 * Initializes the module
 */


Feed.prototype.init = function init() {
  var this$1 = this;
  var data = [];
  var feed = this._settings.feed;
  var config = {
    rssToJson: Feed.rssToJson,
    rssUrl: Array.isArray(feed) ? feed : [feed]
  }; // Go through each feed

  forEach(config.rssUrl, function (url, index) {
    // Make the request
    this$1._request(config, url).then(function (response) {
      // Process the data
      data.push(this$1._process(JSON.parse(response), this$1._settings)); // When all feeds have been requested, merge the data and compile

      if (data.length === config.rssUrl.length) {
        this$1._merge(data, this$1._settings);

        var compiled = this$1._render(this$1._merge(data, this$1._settings), this$1._settings);

        var el = document.querySelector(this$1._settings.selector);

        if (el) {
          el.innerHTML = compiled;
        }
      }
    });
  });

  return this;
};
/**
 * Create an XHR request for the feed data
 * @param{object} config The request data
 * @param{string} url  The request url
 * @return {Promise}     Resolves when the response is ready, rejects when
 *                       the operation times out or there is an error.
 */


Feed.prototype._request = function _request(config, url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();

    xhr.onreadystatechange = function (event) {
      var _xhr = event.target;

      if (_xhr.readyState === 4) {
        if (_xhr.status >= 200 && _xhr.status < 400) {
          resolve(_xhr.response);
        } else {
          reject(new Error(_xhr.status));
        }
      }
    };

    xhr.ontimeout = function () {
      reject(new Error('The Feed request timed out'));
    };

    xhr.open('GET', config.rssToJson + "?rss_url=" + url, true);
    xhr.send();
    xhr = null;
  });
};
/**
 * Pass data to the appropriate processing function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The processed data
 */


Feed.prototype._process = function _process(data, settings) {
  return Feed.process[settings.type](data, settings);
};
/**
 * Pass data to the appropriate merge function based on type
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {object}        The merged feed data
 */


Feed.prototype._merge = function _merge(data, settings) {
  return Feed.merge[settings.type](data);
};
/**
 * Combine template components, pass data, and return compiled temlate
 * @param{object} data   The requested feed data to pass
 * @param{object} settings The application settings
 * @return {string}        The complied html string
 */


Feed.prototype._render = function _render(data, settings) {
  data.settings = settings;

  if (settings.log) {
    console.dir(data);
  }

  var template$1 = values(settings.templates).join('');

  var compiled = template(template$1, {
    'imports': {
      '_each': forEach
    }
  });

  return compiled(data);
};
/**
 * An open RSS to JSON api, see https://rss2json.com
 * @type {String}
 */


Feed.rssToJson = 'https://api.rss2json.com/v1/api.json';
/**
 * The template for the widget.
 * @type {String}
 */

Feed.templates = {
  medium: {
    opener: ['<section class="o-feed <%- settings.classes.wrapper %>" style="', '<% if (settings.fontSize) { %>font-size: <%- settings.fontSize %>;<% } %>', '<% if (settings.postBorderColor) { %>border-color: <%- settings.postBorderColor %>;<% } %>', '">'],
    header: ['<header class="o-feed__header <%- settings.classes.header %>">', '<div class="o-feed__avatar <%- settings.classes.avatar %>">', '<img src="', '<% if (settings.profileImg !== "") { %>', '<%- settings.profileImg %>', '<% } else { %>', '<%- feed.profileImg %>', '<% } %>" ', 'width="<%- settings.ratioProfile[0] %>" ', 'height="<%- settings.ratioProfile[1] %>">', '</div>', '<a class="o-feed__url <%- settings.classes.avatar %>" ', 'href="<% if (settings.titleUrl !== "") { %>', '<%- settings.titleUrl %>', '<% } else { %>', '<%- feed.url %>', '<% } %>" ', 'target="_blank" rel="noopener noreferrer nofollow">', '<% if (settings.title !== "") { %>', '<%- settings.title %>', '<% } else { %>', '<%- feed.title %>', '<% } %>', '</a>', '</header>'],
    posts: ['<div class="o-feed__items" style="', 'border-color: <%- settings.postBorderColor %>;', '">', '<% _each(items, function(post) { %>', '<div class="c-feed-item <%- settings.classes.feedItem %>">', '<h4 class="c-feed-item__title <%- settings.classes.title %>">', '<a class="c-feed-item__link <%- settings.classes.link %>"', 'href="<%- post.guid %>"', 'target="_blank"', 'rel="noopener noreferrer nofollow">', '<%- post.title %>', '</a>', '</h4>', '<span class="c-feed-item__date <%- settings.classes.date %>" ', 'title="<%- settings.postDateTitle %>">', '<%- post.date %>', '</span>', '<div class="c-feed-item__thumbnail <%- settings.classes.thumbnail %>"', 'style="', 'background-image: url(<%- post.thumbnail %>);', 'height: <%- settings.postImgHeight %>;"', 'aria-hidden="true">', '<img style="display: none;" src="<%- post.thumbnail %>" alt="<%- post.title %>">', '</div>', '<p class="c-feed-item__excerpt <%- settings.classes.excerpt %>">', '<%- post.excerpt %><%- settings.postExcerptTrail %>', '</p>', '<div class="c-feed-item__footer <%- settings.classes.itemFooter %>">', '<a class="c-feed-item__cta <%- settings.classes.cta %>" ', 'href="<%- post.guid %>" ', 'target="_blank" ', 'rel="noopener noreferrer nofollow">', '<%- settings.postCtaText %>', '</a>', '</div>', '</div>', '<% }); %>', '</div>'],
    closer: ['</section>']
  }
};
/**
 * Functions for processing the data based on the feed type.
 * @type {Object}
 */

Feed.process = {
  medium: function medium(data, settings) {
    var length = settings.postExcerptLength;

    forEach(data.items, function (post, index) {
      var excerpt = '';
      var date = ''; // Remove figures first

      excerpt = post.description.replace(/<figure.*>.*?<\/figure>/g, ''); // Remove all tags

      excerpt = excerpt.replace(/<(.|\n)*?>/g, ''); // Trim the excerpt

      excerpt = excerpt.substr(0, length);
      excerpt = excerpt.substr(0, Math.min(excerpt.length, excerpt.lastIndexOf(' ')));
      post.excerpt = excerpt; // Format the date

      date = new Date(Date.parse(post.pubDate.replace(' ', 'T'))).toLocaleDateString(settings.postDateLocal, settings.postDateFormat);
      post.date = date;
      return post;
    });

    return data;
  }
  /**
   * Functions for merging the data feeds together, based on the feed type.
   * @type {Object}
   */

};
Feed.merge = {
  medium: function medium(data) {
    var merged = {};
    var items = []; // Combine the post items

    data.forEach(function (feed) {
      items = items.concat(feed.items);
    }); // Merge the data, this will override values, it probably won't be
    // particularly useful for feeds that are the same, but potentially
    // different feed types could use this and combine unique data

    data.forEach(function (feed) {
      merged = merge(merged, feed);
    }); // Get unique posts
    // items = _uniqBy(items, (item) => item.guid);

    merged.items = orderBy(items, 'pubDate', 'desc');
    return merged;
  }
  /**
   * See https://rss2json.com/docs for details on default parameters
   * @type {Object}
   */

};
Feed["default"] = {
  feed: '',
  selector: '#js-feed',
  type: 'medium',
  title: '',
  titleUrl: '',
  profileImg: '',
  fontSize: '',
  ratioProfile: ['50', '50'],
  postBorderColor: 'lightsteelblue',
  postImgHeight: '200px',
  postExcerptLength: 120,
  postExcerptTrail: '…',
  postCtaText: 'Read the full post',
  postDateLocal: 'en-US',
  postDateFormat: {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  },
  postDateTitle: 'Published Date',
  classes: {
    wrapper: '',
    header: '',
    url: '',
    feedItem: '',
    title: '',
    link: '',
    thumbnail: '',
    excerpt: '',
    itemFooter: '',
    cta: '',
    date: ''
  },
  templates: {
    opener: Feed.templates.medium.opener.join(''),
    header: Feed.templates.medium.header.join(''),
    posts: Feed.templates.medium.posts.join(''),
    closer: Feed.templates.medium.closer.join('')
  },
  log: false,
  unique: false
};

/**
 * The Simple Toggle class. This will toggle the class 'active' and 'hidden'
 * on target elements, determined by a click event on a selected link or
 * element. This will also toggle the aria-hidden attribute for targeted
 * elements to support screen readers. Target settings and other functionality
 * can be controlled through data attributes.
 *
 * This uses the .matches() method which will require a polyfill for IE
 * https://polyfill.io/v2/docs/features/#Element_prototype_matches
 *
 * Basic Usage;
 *
 * javascript:
 *   new Toggle().init();
 *
 * Toggling Anchor links:
 *   <a data-js='toggle' href='#main-menu'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Toggling aria-control elements:
 *
 *   <button data-js='toggle' aria-controls='#main-menu' aria-pressed='false'>
 *      Menu
 *   </button>
 *   <div id='main-menu' aria-hidden='true'> ... </div>
 *
 * Create "Undo" Event (to close a dialogue);
 *   <a href='#main-menu' data-js='toggle' data-toggle-undo='#close'>Menu</a>
 *   <div id='main-menu' aria-hidden='true'>
 *     <a id="close">Close</a>
 *   </div>
 * @class
 */

var Toggle = function Toggle(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Toggle.selector,
    namespace: s.namespace ? s.namespace : Toggle.namespace,
    inactiveClass: s.inactiveClass ? s.inactiveClass : Toggle.inactiveClass,
    activeClass: s.activeClass ? s.activeClass : Toggle.activeClass
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    event.preventDefault();

    this$1._toggle(event);
  });
  return this;
};
/**
 * Logs constants to the debugger
 * @param{object} eventThe main click event
 * @return {object}      The class
 */


Toggle.prototype._toggle = function _toggle(event) {
  var this$1 = this;
  var el = event.target;
  var target = false;
  /** Anchor Links */

  target = el.getAttribute('href') ? document.querySelector(el.getAttribute('href')) : target;
  /** Toggle Controls */
  // console.dir(el.getAttribute('aria-controls'));

  target = el.getAttribute('aria-controls') ? document.querySelector("#" + el.getAttribute('aria-controls')) : target;
  /** Main Functionality */

  if (!target) {
    return this;
  }

  this.elementToggle(el, target);
  /** Undo */

  if (el.dataset[this._settings.namespace + "Undo"]) {
    var undo = document.querySelector(el.dataset[this._settings.namespace + "Undo"]);
    undo.addEventListener('click', function (event) {
      event.preventDefault();
      this$1.elementToggle(el, target);
      undo.removeEventListener('click');
    });
  }

  return this;
};
/**
 * The main toggling method
 * @param{object} el   The current element to toggle active
 * @param{object} target The target element to toggle active/hidden
 * @return {object}      The class
 */


Toggle.prototype.elementToggle = function elementToggle(el, target) {
  if (this._settings.activeClass !== '') {
    el.classList.toggle(this._settings.activeClass);
    target.classList.toggle(this._settings.activeClass);
  }

  if (this._settings.inactiveClass !== '') {
    target.classList.toggle(this._settings.inactiveClass);
  } // Check the element for defined aria roles and toggle them if they exist


  for (var i = 0; i < Toggle.elAriaRoles.length; i++) {
    if (el.getAttribute(Toggle.elAriaRoles[i])) {
      el.setAttribute(Toggle.elAriaRoles[i], !(el.getAttribute(Toggle.elAriaRoles[i]) === 'true'));
    }
  } // Check the target for defined aria roles and toggle them if they exist


  for (var i$1 = 0; i$1 < Toggle.targetAriaRoles.length; i$1++) {
    if (target.getAttribute(Toggle.targetAriaRoles[i$1])) {
      target.setAttribute(Toggle.targetAriaRoles[i$1], !(target.getAttribute(Toggle.targetAriaRoles[i$1]) === 'true'));
    }
  }

  if (el.getAttribute('href') && target.classList.contains(this._settings.activeClass)) {
    window.location.hash = '';
    window.location.hash = el.getAttribute('href');
  }

  return this;
};
/** @type {String} The main selector to add the toggling function to */


Toggle.selector = '[data-js*="toggle"]';
/** @type {String} The namespace for our data attribute settings */

Toggle.namespace = 'toggle';
/** @type {String} The hide class */

Toggle.inactiveClass = 'hidden';
/** @type {String} The active class */

Toggle.activeClass = 'active';
/** @type {Array} Aria roles to toggle true/false on the toggling element */

Toggle.elAriaRoles = ['aria-pressed', 'aria-expanded'];
/** @type {Array} Aria roles to toggle true/false on the target element */

Toggle.targetAriaRoles = ['aria-hidden'];

/**
 * Tracking bus for Google analytics and Webtrends.
 */

var Track = function Track(s) {
  var this$1 = this;
  var body = document.querySelector('body');
  s = !s ? {} : s;
  this._settings = {
    selector: s.selector ? s.selector : Track.selector
  };
  body.addEventListener('click', function (event) {
    if (!event.target.matches(this$1._settings.selector)) {
      return;
    }

    var key = event.target.dataset.trackKey;
    var data = JSON.parse(event.target.dataset.trackData);
    this$1.click(key, data);
  });
  return this;
};
/**
 * Tracking function wrapper
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 * @return {object}        The final data object
 */


Track.prototype.click = function click(key, data) {
  // Set the path name based on the location
  var d = data.map(function (el) {
    if (el.hasOwnProperty(Track.key)) {
      el[Track.key] = window.location.pathname + "/" + el[Track.key];
    }

    return el;
  });
  var wt = this.webtrends(key, d);
  var ga = this.gtag(key, d);
  /* eslint-disable no-console */

  if (Utility$1.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */


  return d;
};
/**
 * Data bus for tracking views in Webtrends and Google Analytics
 * @param{string}   appThe name of the Single Page Application to track
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.view = function view(app, key, data) {
  var wt = this.webtrends(key, data);
  var ga = this.gtagView(app, key);
  /* eslint-disable no-console */

  if (Utility$1.debug()) {
    console.dir({
      'Track': [wt, ga]
    });
  }
  /* eslint-enable no-console */

};
/**
 * Push Events to Webtrends
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.webtrends = function webtrends(key, data) {
  var event = [{
    'WT.ti': key
  }];

  if (data[0] && data[0].hasOwnProperty(Track.key)) {
    event.push({
      'DCS.dcsuri': data[0][Track.key]
    });
  } else {
    Object.assign(event, data);
  } // Format data for Webtrends


  var wtd = {
    argsa: event.flatMap(function (e) {
      return Object.keys(e).flatMap(function (k) {
        return [k, e[k]];
      });
    })
  };
  /* eslint-disable no-undef */

  if (typeof Webtrends !== 'undefined') {
    Webtrends.multiTrack(wtd);
  }
  /* eslint-disable no-undef */


  return ['Webtrends', wtd];
};
/**
 * Push Click Events to Google Analytics
 * @param{string}   keyThe key or event of the data
 * @param{collection} data The data to track
 */

Track.prototype.gtag = function gtag$1(key, data) {
  var uri = data.find(function (element) {
    return element.hasOwnProperty(Track.key);
  });
  var event = {
    'event_category': key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag(Track.key, uri[Track.key], event);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, uri[Track.key], event];
};
/**
 * Push Screen View Events to Google Analytics
 * @param{string}   appThe name of the application
 * @param{string}   keyThe key or event of the data
 */

Track.prototype.gtagView = function gtagView(app, key) {
  var view = {
    app_name: app,
    screen_name: key
  };
  /* eslint-disable no-undef */

  if (typeof gtag !== 'undefined') {
    gtag('event', 'screen_view', view);
  }
  /* eslint-enable no-undef */


  return ['gtag', Track.key, 'screen_view', view];
};
/** @type {String} The main selector to add the tracking function to */


Track.selector = '[data-js*="track"]';
/** @type {String} The main event tracking key to map to Webtrends DCS.uri */

Track.key = 'event';

/*!
 * Vue.js v2.6.6
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */

/*  */
var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.

function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive.
 */


function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
  typeof value === 'symbol' || typeof value === 'boolean';
}
/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */


function isObject$1(obj) {
  return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */


var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */


function isPlainObject$1(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */


function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

function isPromise(val) {
  return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
}
/**
 * Convert a value to a string that is actually rendered.
 */


function toString$1(val) {
  return val == null ? '' : Array.isArray(val) || isPlainObject$1(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */


function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */


function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');

  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }

  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}
/**
 * Check if a tag is a built-in tag.
 */


var isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */

var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */

function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);

    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}
/**
 * Check whether an object has the property.
 */


var hasOwnProperty$e = Object.prototype.hasOwnProperty;

function hasOwn(obj, key) {
  return hasOwnProperty$e.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */


function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
/**
 * Camelize a hyphen-delimited string.
 */


var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});
/**
 * Capitalize a string.
 */

var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */

var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

function polyfillBind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }

  boundFn._length = fn.length;
  return boundFn;
}

function nativeBind(fn, ctx) {
  return fn.bind(ctx);
}

var bind = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */

function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);

  while (i--) {
    ret[i] = list[i + start];
  }

  return ret;
}
/**
 * Mix properties into target object.
 */


function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }

  return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */


function toObject(arr) {
  var res = {};

  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */


function noop$1(a, b, c) {}
/**
 * Always return false.
 */


var no = function (a, b, c) {
  return false;
};
/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */


var identity$1 = function (_) {
  return _;
};
/**
 * Generate a string containing static keys from compiler modules.
 */


function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */


function looseEqual(a, b) {
  if (a === b) {
    return true;
  }

  var isObjectA = isObject$1(a);
  var isObjectB = isObject$1(b);

  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);

      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */


function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }

  return -1;
}
/**
 * Ensure a function is called only once.
 */


function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';
var ASSET_TYPES = ['component', 'directive', 'filter'];
var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop$1,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity$1,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};
/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */

var unicodeLetters = 'a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD';
/**
 * Check if a string starts with $ or _
 */

function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}
/**
 * Define a property.
 */


function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}
/**
 * Parse simple path.
 */


var bailRE = new RegExp("[^" + unicodeLetters + ".$_\\d]");

function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }

  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }

      obj = obj[segments[i]];
    }

    return obj;
  };
}
/*  */
// can we use __proto__?


var hasProto = '__proto__' in {}; // Browser environment sniffing

var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...

var nativeWatch = {}.watch;
var supportsPassive = false;

if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285

    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
} // this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV


var _isServer;

var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }

  return _isServer;
}; // detect devtools


var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */

function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */
// $flow-disable-line


if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set =
  /*@__PURE__*/
  function () {
    function Set() {
      this.set = Object.create(null);
    }

    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };

    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };

    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}
/*  */


var warn = noop$1;
var tip = noop$1;
var generateComponentTrace = noop$1; // work around flow check

var formatComponentName = noop$1;
{
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;

  var classify = function (str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }

    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;

    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat$1 = function (str, n) {
    var res = '';

    while (n) {
      if (n % 2 === 1) {
        res += str;
      }

      if (n > 1) {
        str += str;
      }

      n >>= 1;
    }

    return res;
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;

      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];

          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }

        tree.push(vm);
        vm = vm.$parent;
      }

      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat$1(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}
/*  */

var uid = 0;
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */

var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();

  if (!config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) {
      return a.id - b.id;
    });
  }

  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
}; // The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.


Dep.target = null;
var targetStack = [];

function pushTarget(target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
/*  */


var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = {
  child: {
    configurable: true
  }
}; // DEPRECATED: alias for componentInstance for backwards compat.

/* istanbul ignore next */

prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function (text) {
  if (text === void 0) text = '';
  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
} // optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.


function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, // #7975
  // clone children array to avoid mutating original in case of cloning
  // a child.
  vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */


var arrayProto$1 = Array.prototype;
var arrayMethods = Object.create(arrayProto$1);
var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
/**
 * Intercept mutating methods and emit events
 */

methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto$1[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;

    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;

      case 'splice':
        inserted = args.slice(2);
        break;
    }

    if (inserted) {
      ob.observeArray(inserted);
    } // notify change


    ob.dep.notify();
    return result;
  });
});
/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

var shouldObserve = true;

function toggleObserving(value) {
  shouldObserve = value;
}
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */


var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);

  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }

    this.observeArray(value);
  } else {
    this.walk(value);
  }
};
/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */


Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);

  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};
/**
 * Observe a list of Array items.
 */


Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}; // helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */


function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/* istanbul ignore next */


function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */


function observe(value, asRootData) {
  if (!isObject$1(value) || value instanceof VNode) {
    return;
  }

  var ob;

  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject$1(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }

  if (asRootData && ob) {
    ob.vmCount++;
  }

  return ob;
}
/**
 * Define a reactive property on an Object.
 */


function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();
  var property = Object.getOwnPropertyDescriptor(obj, key);

  if (property && property.configurable === false) {
    return;
  } // cater for pre-defined getter/setters


  var getter = property && property.get;
  var setter = property && property.set;

  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;

      if (Dep.target) {
        dep.depend();

        if (childOb) {
          childOb.dep.depend();

          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }

      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */

      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */


      if (customSetter) {
        customSetter();
      } // #7981: for accessor properties without setter


      if (getter && !setter) {
        return;
      }

      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }

      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}
/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */


function set(target, key, val) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }

  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }

  if (!ob) {
    target[key] = val;
    return val;
  }

  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}
/**
 * Delete a property and trigger change if necessary.
 */


function del(target, key) {
  if (isUndef(target) || isPrimitive(target)) {
    warn("Cannot delete reactive property on undefined, null, or primitive value: " + target);
  }

  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }

  var ob = target.__ob__;

  if (target._isVue || ob && ob.vmCount) {
    warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }

  if (!hasOwn(target, key)) {
    return;
  }

  delete target[key];

  if (!ob) {
    return;
  }

  ob.dep.notify();
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */


function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();

    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}
/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */


var strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */

{
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }

    return defaultStrat(parent, child);
  };
}
/**
 * Helper that recursively merges two data objects together.
 */

function mergeData(to, from) {
  if (!from) {
    return to;
  }

  var key, toVal, fromVal;
  var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i]; // in case the object is already observed...

    if (key === '__ob__') {
      continue;
    }

    toVal = to[key];
    fromVal = from[key];

    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (toVal !== fromVal && isPlainObject$1(toVal) && isPlainObject$1(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }

  return to;
}
/**
 * Data
 */


function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }

    if (!parentVal) {
      return childVal;
    } // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.


    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;

      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }

    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */


function mergeHook(parentVal, childVal) {
  var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}

function dedupeHooks(hooks) {
  var res = [];

  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }

  return res;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);

  if (childVal) {
    assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }

  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */


  if (!childVal) {
    return Object.create(parentVal || null);
  }

  {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = {};
  extend(ret, parentVal);

  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];

    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }

    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }

  return ret;
};
/**
 * Other object hashes.
 */


strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }

  if (!parentVal) {
    return childVal;
  }

  var ret = Object.create(null);
  extend(ret, parentVal);

  if (childVal) {
    extend(ret, childVal);
  }

  return ret;
};

strats.provide = mergeDataOrFn;
/**
 * Default strategy.
 */

var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */


function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeLetters + "]*$").test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
  }

  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */


function normalizeProps(options, vm) {
  var props = options.props;

  if (!props) {
    return;
  }

  var res = {};
  var i, val, name;

  if (Array.isArray(props)) {
    i = props.length;

    while (i--) {
      val = props[i];

      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = {
          type: null
        };
      } else {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject$1(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject$1(val) ? val : {
        type: val
      };
    }
  } else {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }

  options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */


function normalizeInject(options, vm) {
  var inject = options.inject;

  if (!inject) {
    return;
  }

  var normalized = options.inject = {};

  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = {
        from: inject[i]
      };
    }
  } else if (isPlainObject$1(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject$1(val) ? extend({
        from: key
      }, val) : {
        from: val
      };
    }
  } else {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}
/**
 * Normalize raw function directives into object format.
 */


function normalizeDirectives(options) {
  var dirs = options.directives;

  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];

      if (typeof def$$1 === 'function') {
        dirs[key] = {
          bind: def$$1,
          update: def$$1
        };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject$1(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */


function mergeOptions(parent, child, vm) {
  {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child); // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.

  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }

    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;

  for (key in parent) {
    mergeField(key);
  }

  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }

  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }

  return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */


function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }

  var assets = options[type]; // check local registration variations first

  if (hasOwn(assets, id)) {
    return assets[id];
  }

  var camelizedId = camelize(id);

  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }

  var PascalCaseId = capitalize(camelizedId);

  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  } // fallback to prototype chain


  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];

  if (warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }

  return res;
}
/*  */


function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key]; // boolean casting

  var booleanIndex = getTypeIndex(Boolean, prop.type);

  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);

      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  } // check default value


  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
    // make sure to observe it.

    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }

  {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}
/**
 * Get the default value of a prop.
 */


function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }

  var def = prop.default; // warn against non-factory defaults for Object & Array

  if (isObject$1(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  } // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger


  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  } // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context


  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}
/**
 * Assert whether a prop is valid.
 */


function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }

  if (value == null && !prop.required) {
    return;
  }

  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];

  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }

    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
    return;
  }

  var validator = prop.validator;

  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);

  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase(); // for primitive wrapper objects

    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject$1(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }

  return {
    valid: valid,
    expectedType: expectedType
  };
}
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */


function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isSameType(a, b) {
  return getType(a) === getType(b);
}

function getTypeIndex(type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }

  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i;
    }
  }

  return -1;
}

function getInvalidTypeMessage(name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value

  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }

  message += ", got " + receivedType + " "; // check if we need to specify received value

  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }

  return message;
}

function styleValue(value, type) {
  if (type === 'String') {
    return "\"" + value + "\"";
  } else if (type === 'Number') {
    return "" + Number(value);
  } else {
    return "" + value;
  }
}

function isExplicable(value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) {
    return value.toLowerCase() === elem;
  });
}

function isBoolean() {
  var args = [],
      len = arguments.length;

  while (len--) args[len] = arguments[len];

  return args.some(function (elem) {
    return elem.toLowerCase() === 'boolean';
  });
}
/*  */


function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;

    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;

      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;

            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }

  globalHandleError(err, vm, info);
}

function invokeWithErrorHandling(handler, context, args, vm, info) {
  var res;

  try {
    res = args ? handler.apply(context, args) : handler.call(context);

    if (res && !res._isVue && isPromise(res)) {
      res.catch(function (e) {
        return handleError(e, vm, info + " (Promise/async)");
      });
    }
  } catch (e) {
    handleError(e, vm, info);
  }

  return res;
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }

  logError(err, vm, info);
}

function logError(err, vm, info) {
  {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */

  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}
/*  */


var isUsingMicroTask = false;
var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;

  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
} // Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).


var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();

  timerFunc = function () {
    p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.

    if (isIOS) {
      setTimeout(noop$1);
    }
  };

  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === '[object MutationObserverConstructor]')) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });

  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };

  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick(cb, ctx) {
  var _resolve;

  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });

  if (!pending) {
    pending = true;
    timerFunc();
  } // $flow-disable-line


  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}
/*  */


var mark;
var measure;
{
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */

  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function (tag) {
      return perf.mark(tag);
    };

    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag); // perf.clearMeasures(name)
    };
  }
}
/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;
{
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var warnReservedPrefix = function (target, key) {
    warn("Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " + 'properties starting with "$" or "_" are not proxied in the Vue instance to ' + 'prevent conflicts with Vue internals' + 'See: https://vuejs.org/v2/api/#data', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data);

      if (!has && !isAllowed) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return has || !isAllowed;
    }
  };
  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) {
          warnReservedPrefix(target, key);
        } else {
          warnNonPresent(target, key);
        }
      }

      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
/*  */

var seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

function traverse(val) {
  _traverse(val, seenObjects);

  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);

  if (!isA && !isObject$1(val) || Object.isFrozen(val) || val instanceof VNode) {
    return;
  }

  if (val.__ob__) {
    var depId = val.__ob__.dep.id;

    if (seen.has(depId)) {
      return;
    }

    seen.add(depId);
  }

  if (isA) {
    i = val.length;

    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;

    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}
/*  */


var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first

  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns, vm) {
  function invoker() {
    var arguments$1 = arguments;
    var fns = invoker.fns;

    if (Array.isArray(fns)) {
      var cloned = fns.slice();

      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
    }
  }

  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
  var name, def$$1, cur, old, event;

  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);

    if (isUndef(cur)) {
      warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }

      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }

      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }

  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}
/*  */


function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }

  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
    // and prevent memory leak

    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}
/*  */


function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;

  if (isUndef(propOptions)) {
    return;
  }

  var res = {};
  var attrs = data.attrs;
  var props = data.props;

  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      {
        var keyInLowerCase = key.toLowerCase();

        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }

  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];

      if (!preserve) {
        delete hash[key];
      }

      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];

      if (!preserve) {
        delete hash[altKey];
      }

      return true;
    }
  }

  return false;
}
/*  */
// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.


function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }

  return children;
} // 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.


function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;

  for (i = 0; i < children.length; i++) {
    c = children[i];

    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }

    lastIndex = res.length - 1;
    last = res[lastIndex]; //  nested

    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes

        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }

        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }

        res.push(c);
      }
    }
  }

  return res;
}
/*  */


function initProvide(vm) {
  var provide = vm.$options.provide;

  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);

  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      }
    });
    toggleObserving(true);
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i]; // #6574 in case the inject object is observed...

      if (key === '__ob__') {
        continue;
      }

      var provideKey = inject[key].from;
      var source = vm;

      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break;
        }

        source = source.$parent;
      }

      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }

    return result;
  }
}
/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */


function resolveSlots(children, context) {
  if (!children || !children.length) {
    return {};
  }

  var slots = {};

  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node

    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    } // named slots should only be respected if the vnode was rendered in the
    // same context.


    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);

      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  } // ignore slots that contains only whitespace


  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }

  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}
/*  */


function normalizeScopedSlots(slots, normalSlots, prevSlots) {
  var res;

  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized;
  } else if (slots.$stable && prevSlots && prevSlots !== emptyObject && Object.keys(normalSlots).length === 0) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots;
  } else {
    res = {};

    for (var key in slots) {
      if (slots[key] && key[0] !== '$') {
        res[key] = normalizeScopedSlot(normalSlots, key, slots[key]);
      }
    }
  } // expose normal slots on scopedSlots


  for (var key$1 in normalSlots) {
    if (!(key$1 in res)) {
      res[key$1] = proxyNormalSlot(normalSlots, key$1);
    }
  } // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error


  if (slots && Object.isExtensible(slots)) {
    slots._normalized = res;
  }

  def(res, '$stable', slots ? !!slots.$stable : true);
  return res;
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
    : normalizeChildren(res);
    return res && res.length === 0 ? undefined : res;
  }; // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.


  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }

  return normalized;
}

function proxyNormalSlot(slots, key) {
  return function () {
    return slots[key];
  };
}
/*  */

/**
 * Runtime helper for rendering v-for lists.
 */


function renderList(val, render) {
  var ret, i, l, keys, key;

  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);

    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);

    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject$1(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();

      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);

      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }

  if (!isDef(ret)) {
    ret = [];
  }

  ret._isVList = true;
  return ret;
}
/*  */

/**
 * Runtime helper for rendering <slot>
 */


function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;

  if (scopedSlotFn) {
    // scoped slot
    props = props || {};

    if (bindObject) {
      if (!isObject$1(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }

      props = extend(extend({}, bindObject), props);
    }

    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;

  if (target) {
    return this.$createElement('template', {
      slot: target
    }, nodes);
  } else {
    return nodes;
  }
}
/*  */

/**
 * Runtime helper for resolving filters
 */


function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity$1;
}
/*  */


function isKeyNotMatch(expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1;
  } else {
    return expect !== actual;
  }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */


function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;

  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName);
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode);
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}
/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */


function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject$1(value)) {
      warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }

      var hash;

      var loop = function (key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }

        var camelizedKey = camelize(key);

        if (!(key in hash) && !(camelizedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});

            on["update:" + camelizedKey] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop(key);
    }
  }

  return data;
}
/*  */

/**
 * Runtime helper for rendering static trees.
 */


function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.

  if (tree && !isInFor) {
    return tree;
  } // otherwise, render a fresh tree.


  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */


function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}
/*  */


function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject$1(value)) {
      warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};

      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }

  return data;
}
/*  */


function resolveScopedSlots(fns, // see flow/vnode
hasDynamicKeys, res) {
  res = res || {
    $stable: !hasDynamicKeys
  };

  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];

    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, hasDynamicKeys, res);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }

      res[slot.key] = slot.fn;
    }
  }

  return res;
}
/*  */


function bindDynamicKeys(baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];

    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (key !== '' && key !== null) {
      // null is a speical value for explicitly removing a binding
      warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
    }
  }

  return baseObj;
} // helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.


function prependModifier(value, symbol) {
  return typeof value === 'string' ? symbol + value : value;
}
/*  */


function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString$1;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}
/*  */


function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var this$1 = this;
  var options = Ctor.options; // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check

  var contextVm;

  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent); // $flow-disable-line

    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent; // $flow-disable-line

    parent = parent._original;
  }

  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);

  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
    }

    return this$1.$slots;
  };

  Object.defineProperty(this, 'scopedSlots', {
    enumerable: true,
    get: function get() {
      return normalizeScopedSlots(data.scopedSlots, this.slots());
    }
  }); // support for compiled functional template

  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options; // pre-resolve slots for renderSlot()

    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);

      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }

      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;

  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }

    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);

    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }

    return res;
  }
}

function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }

  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }

  return clone;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}
/*  */

/*  */

/*  */

/*  */
// inline hooks to be invoked on component VNodes during patch


var componentVNodeHooks = {
  init: function init(vnode, hydrating) {
    if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow

      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },
  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }

    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  },
  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;

    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true
        /* direct */
        );
      }
    }
  }
};
var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base; // plain options object: turn it into a constructor

  if (isObject$1(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  } // if at this stage it's not a constructor or an async component factory,
  // reject.


  if (typeof Ctor !== 'function') {
    {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  } // async component


  var asyncFactory;

  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);

    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {}; // resolve constructor options in case global mixins are applied after
  // component constructor creation

  resolveConstructorOptions(Ctor); // transform component v-model data into props & events

  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  } // extract props


  var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component

  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  } // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners


  var listeners = data.on; // replace with listeners with .native modifier
  // so it gets processed during parent component patch.

  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot
    // work around flow
    var slot = data.slot;
    data = {};

    if (slot) {
      data.slot = slot;
    }
  } // install component management hooks onto the placeholder node


  installComponentHooks(data); // return a placeholder vnode

  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
    Ctor: Ctor,
    propsData: propsData,
    listeners: listeners,
    tag: tag,
    children: children
  }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  }; // check inline-template render functions

  var inlineTemplate = vnode.data.inlineTemplate;

  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }

  return new vnode.componentOptions.Ctor(options);
}

function installComponentHooks(data) {
  var hooks = data.hook || (data.hook = {});

  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];

    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1(f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };

  merged._merged = true;
  return merged;
} // transform component v-model info (value and callback) into
// prop and event handler respectively.


function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';
  (data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;

  if (isDef(existing)) {
    if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}
/*  */


var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
// without getting yelled at by flow

function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }

  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }

  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  } // object syntax in v-bind


  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }

  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  } // warn against non-primitive key


  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  } // support single function children as default scoped slot


  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = {
      default: children[0]
    };
    children.length = 0;
  }

  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }

  var vnode, ns;

  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);

    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }

  if (Array.isArray(vnode)) {
    return vnode;
  } else if (isDef(vnode)) {
    if (isDef(ns)) {
      applyNS(vnode, ns);
    }

    if (isDef(data)) {
      registerDeepBindings(data);
    }

    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;

  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }

  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];

      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
        applyNS(child, ns, force);
      }
    }
  }
} // ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes


function registerDeepBindings(data) {
  if (isObject$1(data.style)) {
    traverse(data.style);
  }

  if (isObject$1(data.class)) {
    traverse(data.class);
  }
}
/*  */


function initRender(vm) {
  vm._vnode = null; // the root of the child tree

  vm._staticTrees = null; // v-once cached trees

  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree

  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates

  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  }; // normalization is always applied for the public version, used in
  // user-written render functions.


  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  }; // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated


  var parentData = parentVnode && parentVnode.data;
  /* istanbul ignore else */

  {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  }
}

var currentRenderingInstance = null;

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
    } // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.


    vm.$vnode = _parentVnode; // render self

    var vnode;

    try {
      // There's no need to maintain a stack becaues all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render"); // return error render result,
      // or previous vnode to prevent render error causing blank component

      /* istanbul ignore else */

      if (vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    } // if the returned array contains only a single node, allow it


    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    } // return empty vnode in case the render function errored out


    if (!(vnode instanceof VNode)) {
      if (Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }

      vnode = createEmptyVNode();
    } // set parent


    vnode.parent = _parentVnode;
    return vnode;
  };
}
/*  */


function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }

  return isObject$1(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = {
    data: data,
    context: context,
    children: children,
    tag: tag
  };
  return node;
}

function resolveAsyncComponent(factory, baseCtor) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  var owner = currentRenderingInstance;

  if (isDef(factory.owners)) {
    // already pending
    factory.owners.push(owner);
  } else {
    var owners = factory.owners = [owner];
    var sync = true;

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)

      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });
    var reject = once(function (reason) {
      warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));

      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });
    var res = factory(resolve, reject);

    if (isObject$1(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);

          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject("timeout (" + res.timeout + "ms)");
            }
          }, res.timeout);
        }
      }
    }

    sync = false; // return in case resolved synchronously

    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}
/*  */


function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}
/*  */


function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];

      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}
/*  */

/*  */


function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false; // init parent attached events

  var listeners = vm.$options._parentListeners;

  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn) {
  target.$on(event, fn);
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function createOnceHandler(event, fn) {
  var _target = target;
  return function onceHandler() {
    var res = fn.apply(null, arguments);

    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  };
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;

  Vue.prototype.$on = function (event, fn) {
    var vm = this;

    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup

      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }

    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;

    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }

    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this; // all

    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    } // array of events


    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }

      return vm;
    } // specific event


    var cbs = vm._events[event];

    if (!cbs) {
      return vm;
    }

    if (!fn) {
      vm._events[event] = null;
      return vm;
    } // specific handler


    var cb;
    var i = cbs.length;

    while (i--) {
      cb = cbs[i];

      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }

    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    {
      var lowerCaseEvent = event.toLowerCase();

      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];

    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";

      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }

    return vm;
  };
}
/*  */


var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  };
}

function initLifecycle(vm) {
  var options = vm.$options; // locate first non-abstract parent

  var parent = options.parent;

  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }

    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;
  vm.$children = [];
  vm.$refs = {};
  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.

    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false
      /* removeOnly */
      );
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }

    restoreActiveInstance(); // update __vue__ reference

    if (prevEl) {
      prevEl.__vue__ = null;
    }

    if (vm.$el) {
      vm.$el.__vue__ = vm;
    } // if parent is an HOC, update its $el as well


    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    } // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.

  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;

    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;

    if (vm._isBeingDestroyed) {
      return;
    }

    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true; // remove self from parent

    var parent = vm.$parent;

    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    } // teardown watchers


    if (vm._watcher) {
      vm._watcher.teardown();
    }

    var i = vm._watchers.length;

    while (i--) {
      vm._watchers[i].teardown();
    } // remove reference from data ob
    // frozen object may not have observer.


    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    } // call the last hook...


    vm._isDestroyed = true; // invoke destroy hooks on current rendered tree

    vm.__patch__(vm._vnode, null); // fire destroyed hook


    callHook(vm, 'destroyed'); // turn off all instance listeners.

    vm.$off(); // remove __vue__ reference

    if (vm.$el) {
      vm.$el.__vue__ = null;
    } // release circular reference (#6759)


    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;

  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }

  callHook(vm, 'beforeMount');
  var updateComponent;
  /* istanbul ignore if */

  if (config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;
      mark(startTag);

      var vnode = vm._render();

      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);
      mark(startTag);

      vm._update(vnode, hydrating);

      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  } // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined


  new Watcher(vm, updateComponent, noop$1, {
    before: function before() {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true
  /* isRenderWatcher */
  );
  hydrating = false; // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook

  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }

  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  {
    isUpdatingChildComponent = true;
  } // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.
  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.

  var hasDynamicScopedSlot = !!(parentVnode.data.scopedSlots && !parentVnode.data.scopedSlots.$stable || vm.$scopedSlots !== emptyObject && !vm.$scopedSlots.$stable); // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.

  var needsForceUpdate = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  hasDynamicScopedSlot);
  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }

  vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render

  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject; // update props

  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];

    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?

      props[key] = validateProp(key, propOptions, propsData, vm);
    }

    toggleObserving(true); // keep a copy of raw propsData

    vm.$options.propsData = propsData;
  } // update listeners


  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children

  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }

  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;

    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }

  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;

    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;

    if (isInInactiveTree(vm)) {
      return;
    }
  }

  if (!vm._inactive) {
    vm._inactive = true;

    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }

    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";

  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }

  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }

  popTarget();
}
/*  */


var MAX_UPDATE_COUNT = 100;
var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;
/**
 * Reset the scheduler's state.
 */

function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  {
    circular = {};
  }
  waiting = flushing = false;
} // Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.


var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.

var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.

if (inBrowser && getNow() > document.createEvent('Event').timeStamp) {
  // if the low-res timestamp which is bigger than the event timestamp
  // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
  // and we need to use the hi-res version for event listeners as well.
  getNow = function () {
    return performance.now();
  };
}
/**
 * Flush both queues and run the watchers.
 */


function flushSchedulerQueue() {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id; // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.

  queue.sort(function (a, b) {
    return a.id - b.id;
  }); // do not cache length because more watchers might be pushed
  // as we run existing watchers

  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];

    if (watcher.before) {
      watcher.before();
    }

    id = watcher.id;
    has[id] = null;
    watcher.run(); // in dev build, check and stop circular updates.

    if (has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;

      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  } // keep copies of post queues before resetting state


  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();
  resetSchedulerState(); // call component updated and activated hooks

  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue); // devtool hook

  /* istanbul ignore if */

  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;

  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;

    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */


function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true
    /* true */
    );
  }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */


function queueWatcher(watcher) {
  var id = watcher.id;

  if (has[id] == null) {
    has[id] = true;

    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;

      while (i > index && queue[i].id > watcher.id) {
        i--;
      }

      queue.splice(i + 1, 0, watcher);
    } // queue the flush


    if (!waiting) {
      waiting = true;

      if (!config.async) {
        flushSchedulerQueue();
        return;
      }

      nextTick(flushSchedulerQueue);
    }
  }
}
/*  */


var uid$2 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;

  if (isRenderWatcher) {
    vm._watcher = this;
  }

  vm._watchers.push(this); // options


  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }

  this.cb = cb;
  this.id = ++uid$2; // uid for batching

  this.active = true;
  this.dirty = this.lazy; // for lazy watchers

  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = expOrFn.toString(); // parse expression for getter

  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);

    if (!this.getter) {
      this.getter = noop$1;
      warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }

  this.value = this.lazy ? undefined : this.get();
};
/**
 * Evaluate the getter, and re-collect dependencies.
 */


Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;

  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }

    popTarget();
    this.cleanupDeps();
  }

  return value;
};
/**
 * Add a dependency to this directive.
 */


Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;

  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);

    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};
/**
 * Clean up for dependency collection.
 */


Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var i = this.deps.length;

  while (i--) {
    var dep = this.deps[i];

    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }

  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};
/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */


Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};
/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */


Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();

    if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject$1(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;

      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};
/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */


Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};
/**
 * Depend on all deps collected by this watcher.
 */


Watcher.prototype.depend = function depend() {
  var i = this.deps.length;

  while (i--) {
    this.deps[i].depend();
  }
};
/**
 * Remove self from all dependencies' subscriber list.
 */


Watcher.prototype.teardown = function teardown() {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }

    var i = this.deps.length;

    while (i--) {
      this.deps[i].removeSub(this);
    }

    this.active = false;
  }
};
/*  */


var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop$1,
  set: noop$1
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };

  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;

  if (opts.props) {
    initProps(vm, opts.props);
  }

  if (opts.methods) {
    initMethods(vm, opts.methods);
  }

  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true
    /* asRootData */
    );
  }

  if (opts.computed) {
    initComputed(vm, opts.computed);
  }

  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.

  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent; // root instance props should be converted

  if (!isRoot) {
    toggleObserving(false);
  }

  var loop = function (key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */

    {
      var hyphenatedKey = hyphenate(key);

      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }

      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.

    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop(key);

  toggleObserving(true);
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};

  if (!isPlainObject$1(data)) {
    data = {};
    warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  } // proxy data on instance


  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;

  while (i--) {
    var key = keys[i];
    {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }

    if (props && hasOwn(props, key)) {
      warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  } // observe data


  observe(data, true
  /* asRootData */
  );
}

function getData(data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();

  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = {
  lazy: true
};

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR

  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;

    if (getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop$1, noop$1, computedWatcherOptions);
    } // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.


    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();

  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop$1;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop$1;
    sharedPropertyDefinition.set = userDef.set || noop$1;
  }

  if (sharedPropertyDefinition.set === noop$1) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }

  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];

    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }

      if (Dep.target) {
        watcher.depend();
      }

      return watcher.value;
    }
  };
}

function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this);
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;

  for (var key in methods) {
    {
      if (typeof methods[key] !== 'function') {
        warn("Method \"" + key + "\" has type \"" + typeof methods[key] + "\" in the component definition. " + "Did you reference the function correctly?", vm);
      }

      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }

      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop$1 : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];

    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, expOrFn, handler, options) {
  if (isPlainObject$1(handler)) {
    options = handler;
    handler = handler.handler;
  }

  if (typeof handler === 'string') {
    handler = vm[handler];
  }

  return vm.$watch(expOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};

  dataDef.get = function () {
    return this._data;
  };

  var propsDef = {};

  propsDef.get = function () {
    return this._props;
  };

  {
    dataDef.set = function () {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };

    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);
  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;

    if (isPlainObject$1(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }

    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);

    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, "callback for immediate watcher \"" + watcher.expression + "\"");
      }
    }

    return function unwatchFn() {
      watcher.teardown();
    };
  };
}
/*  */


var uid$3 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this; // a uid

    vm._uid = uid$3++;
    var startTag, endTag;
    /* istanbul ignore if */

    if (config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    } // a flag to avoid this being observed


    vm._isVue = true; // merge options

    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */


    {
      initProxy(vm);
    } // expose real self

    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props

    initState(vm);
    initProvide(vm); // resolve provide after data/props

    callHook(vm, 'created');
    /* istanbul ignore if */

    if (config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.

  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;

  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;

    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)

      var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options

      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }

      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);

      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }

  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;

  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }

      modified[key] = latest[key];
    }
  }

  return modified;
}

function Vue(options) {
  if (!(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }

  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);

    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    } // additional parameters


    var args = toArray(arguments, 1);
    args.unshift(this);

    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }

    installedPlugins.push(plugin);
    return this;
  };
}
/*  */


function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}
/*  */


function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;
  /**
   * Class inheritance
   */

  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;

    if (name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };

    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super; // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.

    if (Sub.options.props) {
      initProps$1(Sub);
    }

    if (Sub.options.computed) {
      initComputed$1(Sub);
    } // allow further extension/mixin/plugin usage


    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use; // create asset registers, so extended classes
    // can have their private assets too.

    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    }); // enable recursive self-lookup

    if (name) {
      Sub.options.components[name] = Sub;
    } // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.


    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options); // cache constructor

    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;

  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;

  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}
/*  */


function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (type === 'component') {
          validateComponentName(id);
        }

        if (type === 'component' && isPlainObject$1(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }

        if (type === 'directive' && typeof definition === 'function') {
          definition = {
            bind: definition,
            update: definition
          };
        }

        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}
/*  */


function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */


  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;

  for (var key in cache) {
    var cachedNode = cache[key];

    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);

      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];

  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }

  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];
var KeepAlive = {
  name: 'keep-alive',
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },
  destroyed: function destroyed() {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },
  mounted: function mounted() {
    var this$1 = this;
    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) {
        return matches(val, name);
      });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) {
        return !matches(val, name);
      });
    });
  },
  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;

    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;

      if ( // not included
      include && (!name || !matches(include, name)) || // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;

      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance; // make current key freshest

        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key); // prune oldest entry

        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }

    return vnode || slot && slot[0];
  }
};
var builtInComponents = {
  KeepAlive: KeepAlive
};
/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};

  configDef.get = function () {
    return config;
  };

  {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef); // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.

  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };
  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick; // 2.6 explicit observable API

  Vue.observable = function (obj) {
    observe(obj);
    return obj;
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  }); // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.

  Vue.options._base = Vue;
  extend(Vue.options.components, builtInComponents);
  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
}); // expose FunctionalRenderContext for ssr runtime helper installation

Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});
Vue.version = '2.6.6';
/*  */
// these are reserved for web because they are directly compiled away
// during template compilation

var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding

var acceptValue = makeMap('input,textarea,option,select,progress');

var mustUseProp = function (tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
  : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
};

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false;
};
/*  */


function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;

  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;

    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }

  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }

  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */


  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }

  if (isObject$1(value)) {
    return stringifyObject(value);
  }

  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */


  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;

  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }

      res += stringified;
    }
  }

  return res;
}

function stringifyObject(value) {
  var res = '';

  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }

      res += key;
    }
  }

  return res;
}
/*  */


var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};
var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
// contain child elements.

var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function (tag) {
  return tag === 'pre';
};

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  } // basic support for MathML
  // note it doesn't support other MathML elements being component roots


  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);

function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }

  if (isReservedTag(tag)) {
    return false;
  }

  tag = tag.toLowerCase();
  /* istanbul ignore if */

  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }

  var el = document.createElement(tag);

  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');
/*  */

/**
 * Query an element selector if it's not an element already.
 */

function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);

    if (!selected) {
      warn('Cannot find element: ' + el);
      return document.createElement('div');
    }

    return selected;
  } else {
    return el;
  }
}
/*  */


function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);

  if (tagName !== 'select') {
    return elm;
  } // false or null will remove the attribute but undefined will not


  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }

  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setStyleScope(node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps =
/*#__PURE__*/
Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});
/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;

  if (!isDef(key)) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;

  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}
/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */


var emptyNode = new VNode('', {}, []);
var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }

  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};

  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;

    if (isDef(key)) {
      map[key] = i;
    }
  }

  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};
  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];

    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }

    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text

    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;

  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check

    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;

    if (isDef(tag)) {
      {
        if (data && data.pre) {
          creatingElmInVPre++;
        }

        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);
      /* istanbul ignore if */

      {
        createChildren(vnode, children, insertedVnodeQueue);

        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }

        insert(parentElm, vnode.elm, refElm);
      }

      if (data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;

    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;

      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false
        /* hydrating */
        );
      } // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.


      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);

        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }

        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }

    vnode.elm = vnode.componentInstance.$el;

    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode); // make sure to invoke the insert hook

      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i; // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.

    var innerNode = vnode;

    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;

      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }

        insertedVnodeQueue.push(innerNode);
        break;
      }
    } // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself


    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      {
        checkDuplicateKeys(children);
      }

      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }

    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }

    i = vnode.data.hook; // Reuse variable

    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }

      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  } // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.


  function setScope(vnode) {
    var i;

    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;

      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }

        ancestor = ancestor.parent;
      }
    } // for slot content they should also get the scopeId from the host instance.


    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }

      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }

    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];

      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;

      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      } // recursively invoke hooks on child component root node


      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }

      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }

      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions

    var canMove = !removeOnly;
    {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }

        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);

        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];

          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }

        newStartVnode = newCh[++newStartIdx];
      }
    }

    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};

    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;

      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];

      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }

      return;
    } // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.


    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;

    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;

    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }

      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }

    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        {
          checkDuplicateKeys(ch);
        }

        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }

        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).

  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.

  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    } // assert node match


    {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }

    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true
        /* hydrating */
        );
      }

      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }

    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }

              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;

            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }

              childNode = childNode.nextSibling;
            } // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.


            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }

              return false;
            }
          }
        }
      }

      if (isDef(data)) {
        var fullInvoke = false;

        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }

        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }

    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }

      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);

      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }

          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          } // either not server-rendered, or hydration failed.
          // create an empty node and replace it


          oldVnode = emptyNodeAt(oldVnode);
        } // replacing existing element


        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm); // create new node

        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively

        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);

          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }

            ancestor.elm = vnode.elm;

            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              } // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.


              var insert = ancestor.data.hook.insert;

              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }

            ancestor = ancestor.parent;
          }
        } // destroy old node


        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}
/*  */


var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
  var dirsWithInsert = [];
  var dirsWithPostpatch = [];
  var key, oldDir, dir;

  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];

    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);

      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);

      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };

    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);

  if (!dirs) {
    // $flow-disable-line
    return res;
  }

  var i, dir;

  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];

    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }

    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  } // $flow-disable-line


  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];

  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];
/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;

  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }

  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }

  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];

    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  } // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max

  /* istanbul ignore if */


  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }

  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr(el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.

    /* istanbul ignore if */
    if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && value !== '' && !el.__ieph) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };

      el.addEventListener('input', blocker); // $flow-disable-line

      el.__ieph = true;
      /* IE placeholder patched */
    }

    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode); // handle transition classes

  var transitionClass = el._transitionClasses;

  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  } // set the class


  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};
/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);

    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;
          break;
        // "

        case 0x27:
          inSingle = true;
          break;
        // '

        case 0x60:
          inTemplateString = true;
          break;
        // `

        case 0x28:
          paren++;
          break;
        // (

        case 0x29:
          paren--;
          break;
        // )

        case 0x5B:
          square++;
          break;
        // [

        case 0x5D:
          square--;
          break;
        // ]

        case 0x7B:
          curly++;
          break;
        // {

        case 0x7D:
          curly--;
          break;
        // }
      }

      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0; // find first non-whitespace prev char

        for (; j >= 0; j--) {
          p = exp.charAt(j);

          if (p !== ' ') {
            break;
          }
        }

        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');

  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
  }
}
/*  */

/* eslint-disable no-unused-vars */


function baseWarn(msg, range) {
  console.error("[Vue compiler]: " + msg);
}
/* eslint-enable no-unused-vars */


function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
}

function addAttr(el, name, value, range, dynamic) {
  var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
  attrs.push(rangeSetItem({
    name: name,
    value: value,
    dynamic: dynamic
  }, range));
  el.plain = false;
} // add a raw attr (use this in preTransforms)


function addRawAttr(el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({
    name: name,
    value: value
  }, range));
}

function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker(symbol, name, dynamic) {
  return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
}

function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
  modifiers = modifiers || emptyObject; // warn prevent and passive modifier

  /* istanbul ignore if */

  if (warn && modifiers.prevent && modifiers.passive) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
  } // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.


  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  } // check capture modifier


  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }

  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */


  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;

  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({
    value: value.trim(),
    dynamic: dynamic
  }, range);

  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */

  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr(el, name) {
  return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);

  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);

    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
} // note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.


function getAndRemoveAttr(el, name, removeFromMap) {
  var val;

  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;

    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }

  if (removeFromMap) {
    delete el.attrsMap[name];
  }

  return val;
}

function getAndRemoveAttrByRegex(el, name) {
  var list = el.attrsList;

  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];

    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr;
    }
  }
}

function rangeSetItem(item, range) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }

    if (range.end != null) {
      item.end = range.end;
    }
  }

  return item;
}
/*  */

/**
 * Cross-platform code generation for component v-model
 */


function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;
  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;

  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var assignment = genAssignmentCode(value, valueExpression);
  el.model = {
    value: "(" + value + ")",
    expression: JSON.stringify(value),
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}
/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */


function genAssignmentCode(value, assignment) {
  var res = parseModel(value);

  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}
/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */


var len, str, chr, index$1, expressionPos, expressionEndPos;

function parseModel(val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');

    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */

    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;

  while (!eof()) {
    chr = next();

    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }

    if (chr === 0x5B) {
      inBracket++;
    }

    if (chr === 0x5D) {
      inBracket--;
    }

    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;

  while (!eof()) {
    chr = next();

    if (chr === stringQuote) {
      break;
    }
  }
}
/*  */


var warn$1; // in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.

var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;
  {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime

    return false;
  } else {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
  } // ensure runtime directive metadata


  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type

  {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];

    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
    }
  }
  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
  var valueExpression = '$event.target.value';

  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }

  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);

  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);

  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}
/*  */
// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.


function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  } // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4

  /* istanbul ignore if */


  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1(event, handler, capture) {
  var _target = target$1; // save current target element in closure

  return function onceHandler() {
    var res = handler.apply(null, arguments);

    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
} // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.


var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1(name, handler, capture, passive) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;

    handler = original._wrapper = function (e) {
      if ( // no bubbling, should always fire.
      // this is just a safety net in case event.timeStamp is unreliable in
      // certain weird environments...
      e.target === e.currentTarget || // event is fired after handler attachment
      e.timeStamp >= attachedTimestamp || // #9462 bail for iOS 9 bug: event.timeStamp is 0 after history.pushState
      e.timeStamp === 0 || // #9448 bail if event is fired in another document in a multi-page
      // electron/nw.js app, since event.timeStamp will be using a different
      // starting reference
      e.target.ownerDocument !== document) {
        return original.apply(this, arguments);
      }
    };
  }

  target$1.addEventListener(name, handler, supportsPassive ? {
    capture: capture,
    passive: passive
  } : capture);
}

function remove$2(name, handler, capture, _target) {
  (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }

  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};
/*  */

var svgContainer;

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }

  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it

  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key]; // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)

    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }

      if (cur === oldProps[key]) {
        continue;
      } // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property


      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    } // skip the update if old and new VDOM state is the same.
    // the only exception is `value` where the DOM value may be temporarily
    // out of sync with VDOM state due to focus, composition and modifiers.
    // This also covers #4521 by skipping the unnecesarry `checked` update.


    if (key !== 'value' && cur === oldProps[key]) {
      continue;
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur; // avoid resetting cursor position when value is the same

      var strCur = isUndef(cur) ? '' : String(cur);

      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;

      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }

      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else {
      elm[key] = cur;
    }
  }
} // check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true; // #6157
  // work around IE bug when accessing document.activeElement in an iframe

  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}

  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime

  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }

    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }

  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};
/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
}); // merge static and dynamic style data on the same vnode

function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it

  return data.staticStyle ? extend(data.staticStyle, style) : style;
} // normalize possible array / string values into Object


function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }

  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }

  return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */


function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;

    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;

      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;

  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }

  return res;
}
/*  */


var cssVarRE = /^--/;
var importantRE = /\s*!important$/;

var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);

    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];
var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);

  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }

  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);

  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;

    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData

  var oldStyle = oldStaticStyle || oldStyleBinding;
  var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.

  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }

  for (name in newStyle) {
    cur = newStyle[name];

    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};
/*  */

var whitespaceRE = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";

    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */


function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }
  /* istanbul ignore else */


  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }

    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';

    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }

    cur = cur.trim();

    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}
/*  */


function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */


  if (typeof def$$1 === 'object') {
    var res = {};

    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }

    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});
var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation'; // Transition property/event sniffing

var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';

if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }

  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
} // binding to window is necessary to make hot reload work in IE in strict mode


var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :
/* istanbul ignore next */
function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);

  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }

  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;

  if (!type) {
    return cb();
  }

  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;

  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };

  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };

  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties

  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);
  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */

  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }

  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
} // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors


function toMs(s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
/*  */


function enter(vnode, toggleDisplay) {
  var el = vnode.elm; // call leave callback now

  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;

    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data)) {
    return;
  }
  /* istanbul ignore if */


  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration; // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.

  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;

  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;
  var explicitEnterDuration = toNumber(isObject$1(duration) ? duration.enter : duration);

  if (explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);
  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }

      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }

    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];

      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }

      enterHook && enterHook(el, cb);
    });
  } // start enter transition


  beforeEnterHook && beforeEnterHook(el);

  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);

      if (!cb.cancelled) {
        addTransitionClass(el, toClass);

        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm; // call enter callback now

  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;

    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);

  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }
  /* istanbul ignore if */


  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;
  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);
  var explicitLeaveDuration = toNumber(isObject$1(duration) ? duration.leave : duration);

  if (isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }

    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }

    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }

      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }

    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    } // record leaving element


    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }

    beforeLeave && beforeLeave(el);

    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);

        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);

          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    leave && leave(el, cb);

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
} // only used in dev mode


function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */


function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }

  var invokerFns = fn.fns;

  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};
var platformModules = [attrs, klass, events, domProps, style, transition];
/*  */
// the directive module should be applied last, after all
// built-in modules have been applied.

var modules = platformModules.concat(baseModules);
var patch = createPatchFunction({
  nodeOps: nodeOps,
  modules: modules
});
/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */

if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;

    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }

      el._vOptions = [].map.call(el.options, getValue$1);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;

      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.

        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */

        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.

      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue$1);

      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);

        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */

  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;

  if (isMultiple && !Array.isArray(value)) {
    warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }

  var selected, option;

  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];

    if (isMultiple) {
      selected = looseIndexOf(value, getValue$1(option)) > -1;

      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue$1(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }

        return;
      }
    }
  }

  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue$1(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }

  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}
/*  */
// recursively search for possible transition defined inside the component root


function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;

    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },
  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;
    /* istanbul ignore if */

    if (!value === !oldValue) {
      return;
    }

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;

    if (transition$$1) {
      vnode.data.show = true;

      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },
  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};
var platformDirectives = {
  model: directive,
  show: show
};
/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
}; // in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered

function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;

  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options; // props

  for (var key in options.propsData) {
    data[key] = comp[key];
  } // events.
  // extract listeners and pass them directly to the transition methods


  var listeners = options._parentListeners;

  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }

  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var isNotTextNode = function (c) {
  return c.tag || isAsyncPlaceholder(c);
};

var isVShowDirective = function (d) {
  return d.name === 'show';
};

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,
  render: function render(h) {
    var this$1 = this;
    var children = this.$slots.default;

    if (!children) {
      return;
    } // filter out text nodes (possible whitespaces)


    children = children.filter(isNotTextNode);
    /* istanbul ignore if */

    if (!children.length) {
      return;
    } // warn multiple elements


    if (children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode; // warn invalid mode

    if (mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0]; // if this is a component root node and the component's
    // parent container node also has transition, skip.

    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    } // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive


    var child = getRealChild(rawChild);
    /* istanbul ignore if */

    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    } // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.


    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;
    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild); // mark v-show
    // so that the transition module can hand over the control to the directive

    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data); // handle transition mode

      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }

        var delayedLeave;

        var performLeave = function () {
          delayedLeave();
        };

        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};
/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props: props,
  beforeMount: function beforeMount() {
    var this$1 = this;
    var update = this._update;

    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1); // force removing pass

      this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );

      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },
  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];

      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;
          (c.data || (c.data = {})).transition = transitionData;
        } else {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];

      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();

        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }

      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },
  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';

    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    } // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.


    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation); // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line

    this._reflow = document.body.offsetHeight;
    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (e && e.target !== el) {
            return;
          }

          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },
  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */


      if (this._hasMove) {
        return this._hasMove;
      } // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.


      var clone = el.cloneNode();

      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }

      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */


  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;

  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};
/*  */
// install platform specific utils

Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components

extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents); // install platform patch function

Vue.prototype.__patch__ = inBrowser ? patch : noop$1; // public mount method

Vue.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
}; // devtools global hook

/* istanbul ignore next */


if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else {
        console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }

    if (config.productionTip !== false && typeof console !== 'undefined') {
      console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
    }
  }, 0);
}
/*  */


var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;

  if (!tagRE.test(text)) {
    return;
  }

  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;

  while (match = tagRE.exec(text)) {
    index = match.index; // push text token

    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    } // tag token


    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    rawTokens.push({
      '@binding': exp
    });
    lastIndex = index + match[0].length;
  }

  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }

  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  };
}
/*  */


function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');

  if (staticClass) {
    var res = parseText(staticClass, options.delimiters);

    if (res) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
    }
  }

  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }

  var classBinding = getBindingAttr(el, 'class', false
  /* getStatic */
  );

  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';

  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }

  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }

  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};
/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');

  if (staticStyle) {
    /* istanbul ignore if */
    {
      var res = parseText(staticStyle, options.delimiters);

      if (res) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false
  /* getStatic */
  );

  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';

  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }

  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }

  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};
/*  */

var decoder;
var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};
/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open
// (and which close themselves)

var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content

var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
/**
 * Not type-checking this file because it's mostly vendor code.
 */
// Regular Expressions for parsing tags and attributes

var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeLetters + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page

var comment = /^<!\--/;
var conditionalComment = /^<!\[/; // Special Elements (can contain anything)

var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};
var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992

var isIgnoreNewlineTag = makeMap('pre,textarea', true);

var shouldIgnoreFirstNewline = function (tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;

  while (html) {
    last = html; // Make sure we're not in a plaintext content element like script/style

    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');

      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }

            advance(commentEnd + 3);
            continue;
          }
        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment


        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        } // Doctype:


        var doctypeMatch = html.match(doctype);

        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        } // End tag:


        var endTagMatch = html.match(endTag);

        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        } // Start tag:


        var startTagMatch = parseStartTag();

        if (startTagMatch) {
          handleStartTag(startTagMatch);

          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }

          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;

      if (textEnd >= 0) {
        rest = html.slice(textEnd);

        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);

          if (next < 0) {
            break;
          }

          textEnd += next;
          rest = html.slice(textEnd);
        }

        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;

        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
          .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }

        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }

        if (options.chars) {
          options.chars(text);
        }

        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);

      if (!stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"", {
          start: index + html.length
        });
      }

      break;
    }
  } // Clean up any remaining tags


  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);

    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;

      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }

      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }

      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;
    var l = match.attrs.length;
    var attrs = new Array(l);

    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };

      if (options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({
        tag: tagName,
        lowerCasedTag: tagName.toLowerCase(),
        attrs: attrs,
        start: match.start,
        end: match.end
      });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;

    if (start == null) {
      start = index;
    }

    if (end == null) {
      end = index;
    } // Find the closest opened tag of the same type


    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();

      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (i > pos || !tagName && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.", {
            start: stack[i].start
          });
        }

        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      } // Remove the open elements from the stack


      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }

      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}
/*  */


var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;
var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.]+/g;
var slotRE = /^v-slot(:|$)|^#/;
var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /\s+/g;
var invalidAttributeRE = /[\s"'<>\/=]/;
var decodeHTMLCached = cached(he.decode);
var emptySlotScopeToken = "_empty_"; // configurable state

var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  };
}
/**
 * Convert HTML string to AST.
 */


function parse(template, options) {
  warn$2 = options.warn || baseWarn;
  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;

  maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
  delimiters = options.delimiters;
  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement(element) {
    trimEndingWhitespace(element);

    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    } // tree management


    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else {
        warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", {
          start: element.start
        });
      }
    }

    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"';
          (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }

        currentParent.children.push(element);
        element.parent = currentParent;
      }
    } // final children cleanup
    // filter out scoped slots


    element.children = element.children.filter(function (c) {
      return !c.slotScope;
    }); // remove trailing whitespace node again

    trimEndingWhitespace(element); // check pre state

    if (element.pre) {
      inVPre = false;
    }

    if (platformIsPreTag(element.tag)) {
      inPre = false;
    } // apply post-transforms


    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace(el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;

      while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints(el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', {
        start: el.start
      });
    }

    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start(tag, attrs, unary, start$1) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug

      /* istanbul ignore if */

      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);

      if (ns) {
        element.ns = ns;
      }

      {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated;
          }, {});
        }

        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
              start: attr.start + attr.name.indexOf("["),
              end: attr.start + attr.name.length
            });
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', {
          start: element.start
        });
      } // apply pre-transforms


      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);

        if (element.pre) {
          inVPre = true;
        }
      }

      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }

      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },
    end: function end(tag, start, end$1) {
      var element = stack[stack.length - 1]; // pop stack

      stack.length -= 1;
      currentParent = stack[stack.length - 1];

      if (options.outputSourceRange) {
        element.end = end$1;
      }

      closeElement(element);
    },
    chars: function chars(text, start, end) {
      if (!currentParent) {
        {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.', {
              start: start
            });
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.", {
              start: start
            });
          }
        }
        return;
      } // IE textarea placeholder bug

      /* istanbul ignore if */


      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }

      var children = currentParent.children;

      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }

      if (text) {
        if (whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }

        var res;
        var child;

        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }

        if (child) {
          if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }

          children.push(child);
        }
      }
    },
    comment: function comment(text, start, end) {
      // adding anyting as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };

        if (options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }

        currentParent.children.push(child);
      }
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var list = el.attrsList;
  var len = list.length;

  if (len) {
    var attrs = el.attrs = new Array(len);

    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };

      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element); // determine whether this is a plain element after
  // removing structural attributes

  element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);

  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }

  processAttrs(element);
  return element;
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');

  if (exp) {
    {
      if (el.tag === 'template') {
        warn$2("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
      }

      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;

        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true
          /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');

  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;

  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var res = parseFor(exp);

    if (res) {
      extend(el, res);
    } else {
      warn$2("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
    }
  }
}

function parseFor(exp) {
  var inMatch = exp.match(forAliasRE);

  if (!inMatch) {
    return;
  }

  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);

  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();

    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }

  return res;
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');

  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }

    var elseif = getAndRemoveAttr(el, 'v-else-if');

    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);

  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
  }
}

function findPrevElement(children) {
  var i = children.length;

  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if (children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
      }

      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }

  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');

  if (once$$1 != null) {
    el.once = true;
  }
} // handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">


function processSlotContent(el) {
  var slotScope;

  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */

    if (slotScope) {
      warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
    }

    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
    /* istanbul ignore if */
    if (el.attrsMap['v-for']) {
      warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
    }

    el.slotScope = slotScope;
  } // slot="xxx"


  var slotTarget = getBindingAttr(el, 'slot');

  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.

    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  } // 2.6 v-slot syntax


  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding) {
        {
          if (el.slotTarget || el.slotScope) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.parent && !maybeComponent(el.parent)) {
            warn$2("<template v-slot> can only appear at the root level inside " + "the receiving the component", el);
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);

      if (slotBinding$1) {
        {
          if (!maybeComponent(el)) {
            warn$2("v-slot can only be used on components or <template>.", slotBinding$1);
          }

          if (el.slotScope || el.slotTarget) {
            warn$2("Unexpected mixed usage of different slot syntaxes.", el);
          }

          if (el.scopedSlots) {
            warn$2("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
          }
        } // add the component's children to its default slot

        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true;
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now

        el.children = []; // mark el non-plain so data gets generated

        el.plain = false;
      }
    }
  }
}

function getSlotName(binding) {
  var name = binding.name.replace(slotRE, '');

  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else {
      warn$2("v-slot shorthand syntax requires a slot name.", binding);
    }
  }

  return dynamicArgRE.test(name) // dynamic [name]
  ? {
    name: name.slice(1, -1),
    dynamic: true // static name

  } : {
    name: "\"" + name + "\"",
    dynamic: false
  };
} // handle <slot/> outlets


function processSlotOutlet(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');

    if (el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
    }
  }
}

function processComponent(el) {
  var binding;

  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }

  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;

  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;

    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true; // modifiers

      modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier

      if (modifiers) {
        name = name.replace(modifierRE, '');
      }

      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        if (value.trim().length === 0) {
          warn$2("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
        }

        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);

            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }

          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }

          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");

            if (!isDynamic) {
              addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$2, list[i]);

              if (hyphenate(name) !== camelize(name)) {
                addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$2, list[i]);
              }
            } else {
              // handler w/ dynamic event name
              addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$2, list[i], true // dynamic
              );
            }
          }
        }

        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);

        if (isDynamic) {
          name = name.slice(1, -1);
        }

        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else {
        // normal directives
        name = name.replace(dirRE, ''); // parse arg

        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;

        if (arg) {
          name = name.slice(0, -(arg.length + 1));

          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }

        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);

        if (name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      {
        var res = parseText(value, delimiters);

        if (res) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation

      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;

  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }

    parent = parent.parent;
  }

  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);

  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};

  for (var i = 0, l = attrs.length; i < l; i++) {
    if (map[attrs[i].name] && !isIE && !isEdge) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }

    map[attrs[i].name] = attrs[i].value;
  }

  return map;
} // for script (e.g. type="x/template") or style, do not decode content


function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;
/* istanbul ignore next */

function guardIESVGBug(attrs) {
  var res = [];

  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];

    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }

  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;

  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
    }

    _el = _el.parent;
  }
}
/*  */


function preTransformNode(el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;

    if (!map['v-model']) {
      return;
    }

    var typeBinding;

    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }

    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + map['v-bind'] + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox

      var branch0 = cloneASTElement(el); // process for on the main node

      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed

      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      }); // 2. add radio else-if condition

      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      }); // 3. other

      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0;
    }
  }
}

function cloneASTElement(el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}

var model$1 = {
  preTransformNode: preTransformNode
};
var modules$1 = [klass$1, style$1, model$1];
/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
  }
}
/*  */


function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};
/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};
/*  */

var isStaticKey;
var isPlatformReservedTag;
var genStaticKeysCached = cached(genStaticKeys$1);
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */

function optimize(root, options) {
  if (!root) {
    return;
  }

  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.

  markStatic$1(root); // second pass: mark static roots.

  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);

  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }

    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);

      if (!child.static) {
        node.static = false;
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);

        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    } // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.


    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }

    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }

    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }

  if (node.type === 3) {
    // text
    return true;
  }

  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;

    if (node.tag !== 'template') {
      return false;
    }

    if (node.for) {
      return true;
    }
  }

  return false;
}
/*  */


var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases

var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
}; // KeyboardEvent.key aliases

var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
}; // #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once

var genGuard = function (condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";

  for (var name in events) {
    var handlerCode = genHandler(events[name]);

    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }

  staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";

  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
  } else {
    return prefix + staticHandlers;
  }
}

function genHandler(handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value;
    }

    return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];

    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key]; // left/right

        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }

    if (keys.length) {
      code += genKeyFilter(keys);
    } // Make sure modifiers like prevent and stop get executed after key filtering


    if (genModifierCode) {
      code += genModifierCode;
    }

    var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return (// make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;"
  );
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);

  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }

  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
}
/*  */


function on(el, dir) {
  if (dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }

  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}
/*  */


function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}
/*  */


var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop$1
};
/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;

  this.maybeComponent = function (el) {
    return !!el.component || !isReservedTag(el.tag);
  };

  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;

    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;

      if (!el.plain || el.pre && state.maybeComponent(el)) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    } // module transforms


    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }

    return code;
  }
} // hoist static sub-trees out


function genStatic(el, state) {
  el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.

  var originalPreState = state.pre;

  if (el.pre) {
    state.pre = el.pre;
  }

  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  state.pre = originalPreState;
  return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
} // v-once


function genOnce(el, state) {
  el.onceProcessed = true;

  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;

    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }

      parent = parent.parent;
    }

    if (!key) {
      state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
      return genElement(el, state);
    }

    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion

  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();

  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  } // v-if with v-once should generate code like (a)?_m(0):_m(1)


  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true
    /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion

  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{'; // directives first.
  // directives may mutate the el's other properties before they are generated.

  var dirs = genDirectives(el, state);

  if (dirs) {
    data += dirs + ',';
  } // key


  if (el.key) {
    data += "key:" + el.key + ",";
  } // ref


  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }

  if (el.refInFor) {
    data += "refInFor:true,";
  } // pre


  if (el.pre) {
    data += "pre:true,";
  } // record original tag name for components using "is" attribute


  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  } // module data generation functions


  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  } // attributes


  if (el.attrs) {
    data += "attrs:" + genProps(el.attrs) + ",";
  } // DOM props


  if (el.props) {
    data += "domProps:" + genProps(el.props) + ",";
  } // event handlers


  if (el.events) {
    data += genHandlers(el.events, false) + ",";
  }

  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true) + ",";
  } // slot target
  // only for non-scoped slots


  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  } // scoped slots


  if (el.scopedSlots) {
    data += genScopedSlots(el, el.scopedSlots, state) + ",";
  } // component v-model


  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  } // inline-template


  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);

    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }

  data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.

  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
  } // v-bind data wrap


  if (el.wrapData) {
    data = el.wrapData(data);
  } // v-on data wrap


  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }

  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;

  if (!dirs) {
    return;
  }

  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;

  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];

    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }

    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }

  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];

  if (el.children.length !== 1 || ast.type !== 1) {
    state.warn('Inline-template components must have exactly one child element.', {
      start: el.start
    });
  }

  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(el, slots, state) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    ;
  }); // OR when it is inside another scoped slot (the reactivity is disconnected)
  // #9438

  if (!needsForceUpdate) {
    var parent = el.parent;

    while (parent) {
      if (parent.slotScope && parent.slotScope !== emptySlotScopeToken) {
        needsForceUpdate = true;
        break;
      }

      parent = parent.parent;
    }
  }

  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(slots[key], state);
  }).join(',') + "]" + (needsForceUpdate ? ",true" : "") + ")";
}

function containsSlotChild(el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true;
    }

    return el.children.some(containsSlotChild);
  }

  return false;
}

function genScopedSlot(el, state) {
  var isLegacySyntax = el.attrsMap['slot-scope'];

  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null");
  }

  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot);
  }

  var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
  var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}"; // reverse proxy v-slot without scope on this.$slots

  var reverseProxy = slotScope ? "" : ",proxy:true";
  return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;

  if (children.length) {
    var el$1 = children[0]; // optimize single v-for

    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
      return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
    }

    var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
  }
} // determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed


function getNormalizationType(children, maybeComponent) {
  var res = 0;

  for (var i = 0; i < children.length; i++) {
    var el = children[i];

    if (el.type !== 1) {
      continue;
    }

    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }

    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }

  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  } else if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
    return {
      // slot props are camelized
      name: camelize(attr.name),
      value: attr.value,
      dynamic: attr.dynamic
    };
  })) : null;
  var bind$$1 = el.attrsMap['v-bind'];

  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }

  if (attrs) {
    res += "," + attrs;
  }

  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }

  return res + ')';
} // componentName is el.component, take it as argument to shun flow's pessimistic refinement


function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var staticProps = "";
  var dynamicProps = "";

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);

    if (prop.dynamic) {
      dynamicProps += prop.name + "," + value + ",";
    } else {
      staticProps += "\"" + prop.name + "\":" + value + ",";
    }
  }

  staticProps = "{" + staticProps.slice(0, -1) + "}";

  if (dynamicProps) {
    return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
  } else {
    return staticProps;
  }
} // #3895, #4268


function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}
/*  */
// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed


var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b'); // these unary operators should not be used as property/method names

var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)'); // strip strings in expressions

var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template

function detectErrors(ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode(node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];

        if (value) {
          var range = node.rawAttrsMap[name];

          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", warn, range);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", warn, range);
          }
        }
      }
    }

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent(exp, text, warn, range) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);

  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
  }

  checkExpression(exp, text, warn, range);
}

function checkFor(node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier(ident, type, text, warn, range) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
    }
  }
}

function checkExpression(exp, text, warn, range) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);

    if (keywordMatch) {
      warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
    } else {
      warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
    }
  }
}
/*  */


var range = 2;

function generateCodeFrame(source, start, end) {
  if (start === void 0) start = 0;
  if (end === void 0) end = source.length;
  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];

  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;

    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) {
          continue;
        }

        res.push("" + (j + 1) + repeat(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
        var lineLength = lines[j].length;

        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat(" ", pad) + repeat("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat("^", length$1));
          }

          count += lineLength + 1;
        }
      }

      break;
    }
  }

  return res.join('\n');
}

function repeat(str, n) {
  var result = '';

  while (true) {
    // eslint-disable-line
    if (n & 1) {
      result += str;
    }

    n >>>= 1;

    if (n <= 0) {
      break;
    }

    str += str;
  }

  return result;
}
/*  */


function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({
      err: err,
      code: code
    });
    return noop$1;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);
  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;
    /* istanbul ignore if */

    {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    } // check cache

    var key = options.delimiters ? String(options.delimiters) + template : template;

    if (cache[key]) {
      return cache[key];
    } // compile


    var compiled = compile(template, options); // check compilation errors/tips

    {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
          });
        } else {
          warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
            return "- " + e;
          }).join('\n') + '\n', vm);
        }
      }

      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) {
            return tip(e.msg, vm);
          });
        } else {
          compiled.tips.forEach(function (msg) {
            return tip(msg, vm);
          });
        }
      }
    } // turn code into functions

    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    }); // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use

    /* istanbul ignore if */

    {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;
          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }
    return cache[key] = res;
  };
}
/*  */


function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if (options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = {
              msg: msg
            };

            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }

              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }

            (tip ? tips : errors).push(data);
          };
        } // merge custom modules


        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        } // merge custom directives


        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
        } // copy other options


        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;
      var compiled = baseCompile(template.trim(), finalOptions);
      {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}
/*  */
// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.


var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);

  if (options.optimize !== false) {
    optimize(ast, options);
  }

  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});
/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;
/*  */
// check whether current browser encodes a char inside attribute values

var div;

function getShouldDecode(href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0;
} // #3663: IE encodes newlines inside attribute values while other browsers don't


var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]

var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;
/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});
var mount = Vue.prototype.$mount;

Vue.prototype.$mount = function (el, hydrating) {
  el = el && query(el);
  /* istanbul ignore if */

  if (el === document.body || el === document.documentElement) {
    warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options; // resolve template/el and convert to render function

  if (!options.render) {
    var template = options.template;

    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */

          if (!template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }

    if (template) {
      /* istanbul ignore if */
      if (config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;
      /* istanbul ignore if */

      if (config.performance && mark) {
        mark('compile end');
        measure("vue " + this._name + " compile", 'compile', 'compile end');
      }
    }
  }

  return mount.call(this, el, hydrating);
};
/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */


function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue.compile = compileToFunctions;

//
//
//
//
//
//
//
//
//
//
//
//
var script = {
  props: ['options', 'value'],
  data: function data() {
    return {
      selected: null
    };
  },
  mounted: function mounted() {
    this.selected = this.value;
  },
  watch: {
    value: function value(newValue) {
      this.selected = newValue;
    }
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
/* server only */
, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
  if (typeof shadowMode !== 'boolean') {
    createInjectorSSR = createInjector;
    createInjector = shadowMode;
    shadowMode = false;
  } // Vue.extend constructor export interop.


  var options = typeof script === 'function' ? script.options : script; // render functions

  if (template && template.render) {
    options.render = template.render;
    options.staticRenderFns = template.staticRenderFns;
    options._compiled = true; // functional template

    if (isFunctionalTemplate) {
      options.functional = true;
    }
  } // scopedId


  if (scopeId) {
    options._scopeId = scopeId;
  }

  var hook;

  if (moduleIdentifier) {
    // server build
    hook = function hook(context) {
      // 2.3 injection
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
      // 2.2 with runInNewContext: true

      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__;
      } // inject component styles


      if (style) {
        style.call(this, createInjectorSSR(context));
      } // register component module identifier for async chunk inference


      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    }; // used by ssr in case component is cached and beforeCreate
    // never gets called


    options._ssrRegister = hook;
  } else if (style) {
    hook = shadowMode ? function () {
      style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
    } : function (context) {
      style.call(this, createInjector(context));
    };
  }

  if (hook) {
    if (options.functional) {
      // register for functional component in vue file
      var originalRender = options.render;

      options.render = function renderWithStyleInjection(h, context) {
        hook.call(context);
        return originalRender(h, context);
      };
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }

  return script;
}

var normalizeComponent_1 = normalizeComponent;

var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());

function createInjector(context) {
  return function (id, style) {
    return addStyle(id, style);
  };
}

var HEAD = document.head || document.getElementsByTagName('head')[0];
var styles = {};

function addStyle(id, css) {
  var group = isOldIE ? css.media || 'default' : id;
  var style = styles[group] || (styles[group] = {
    ids: new Set(),
    styles: []
  });

  if (!style.ids.has(id)) {
    style.ids.add(id);
    var code = css.source;

    if (css.map) {
      // https://developer.chrome.com/devtools/docs/javascript-debugging
      // this makes source maps inside style tags work properly in Chrome
      code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

      code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
    }

    if (!style.element) {
      style.element = document.createElement('style');
      style.element.type = 'text/css';

      if (css.media) {
        style.element.setAttribute('media', css.media);
      }

      HEAD.appendChild(style.element);
    }

    if ('styleSheet' in style.element) {
      style.styles.push(code);
      style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
    } else {
      var index = style.ids.size - 1;
      var textNode = document.createTextNode(code);
      var nodes = style.element.childNodes;

      if (nodes[index]) {
        style.element.removeChild(nodes[index]);
      }

      if (nodes.length) {
        style.element.insertBefore(textNode, nodes[index]);
      } else {
        style.element.appendChild(textNode);
      }
    }
  }
}

var browser = createInjector;

/* script */
var __vue_script__ = script;

/* template */
var __vue_render__ = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", [
    _c(
      "select",
      {
        directives: [
          {
            name: "model",
            rawName: "v-model",
            value: _vm.selected,
            expression: "selected"
          }
        ],
        staticClass: "select",
        on: {
          input: function(event) {
            _vm.$emit("input", event.target.value);
          },
          change: function($event) {
            var $$selectedVal = Array.prototype.filter
              .call($event.target.options, function(o) {
                return o.selected
              })
              .map(function(o) {
                var val = "_value" in o ? o._value : o.value;
                return val
              });
            _vm.selected = $event.target.multiple
              ? $$selectedVal
              : $$selectedVal[0];
          }
        }
      },
      _vm._l(_vm.options, function(option) {
        return _c(
          "option",
          { key: option.value, domProps: { value: option.value } },
          [_vm._v("\n      " + _vm._s(option.text) + "\n    ")]
        )
      }),
      0
    )
  ])
};
var __vue_staticRenderFns__ = [];
__vue_render__._withStripped = true;

  /* style */
  var __vue_inject_styles__ = function (inject) {
    if (!inject) { return }
    inject("data-v-2608958d_0", { source: "\n\n\n\n\n\n\n\n\n\n", map: {"version":3,"sources":[],"names":[],"mappings":"","file":"select.vue"}, media: undefined });

  };
  /* scoped */
  var __vue_scope_id__ = undefined;
  /* module identifier */
  var __vue_module_identifier__ = undefined;
  /* functional template */
  var __vue_is_functional_template__ = false;
  /* style inject SSR */
  

  
  var SelectComponent = normalizeComponent_1(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    browser,
    undefined
  );

var SelectData = [{
  text: 'All Boroughs',
  value: 'all'
}, {
  text: 'Brooklyn',
  value: 'brooklyn'
}, {
  text: 'Queens',
  value: 'queens'
}, {
  text: 'Manhattan',
  value: 'manhattan'
}, {
  text: 'Staten Island',
  value: 'staten island'
}, {
  text: 'The Bronx',
  value: 'bronx'
}];

var Select = function Select(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


Select.prototype.init = function init() {
  Vue.component('nyco-select', SelectComponent);
  new Vue({
    el: '[data-js="app"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        options: Select.data,
        selected: 'all'
      };
    },
    methods: {}
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


Select.prototype._constants = function _constants(param) {
  console.dir(param);
};

Select.data = SelectData;

function dataHandler(newData, oldData) {
  if (oldData) {
    var chart = this.$data._chart;
    var newDatasetLabels = newData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldDatasetLabels = oldData.datasets.map(function (dataset) {
      return dataset.label;
    });
    var oldLabels = JSON.stringify(oldDatasetLabels);
    var newLabels = JSON.stringify(newDatasetLabels);

    if (newLabels === oldLabels && oldData.datasets.length === newData.datasets.length) {
      newData.datasets.forEach(function (dataset, i) {
        var oldDatasetKeys = Object.keys(oldData.datasets[i]);
        var newDatasetKeys = Object.keys(dataset);
        var deletionKeys = oldDatasetKeys.filter(function (key) {
          return key !== '_meta' && newDatasetKeys.indexOf(key) === -1;
        });
        deletionKeys.forEach(function (deletionKey) {
          delete chart.data.datasets[i][deletionKey];
        });

        for (var attribute in dataset) {
          if (dataset.hasOwnProperty(attribute)) {
            chart.data.datasets[i][attribute] = dataset[attribute];
          }
        }
      });

      if (newData.hasOwnProperty('labels')) {
        chart.data.labels = newData.labels;
        this.$emit('labels:update');
      }

      if (newData.hasOwnProperty('xLabels')) {
        chart.data.xLabels = newData.xLabels;
        this.$emit('xlabels:update');
      }

      if (newData.hasOwnProperty('yLabels')) {
        chart.data.yLabels = newData.yLabels;
        this.$emit('ylabels:update');
      }

      chart.update();
      this.$emit('chart:update');
    } else {
      if (chart) {
        chart.destroy();
        this.$emit('chart:destroy');
      }

      this.renderChart(this.chartData, this.options);
      this.$emit('chart:render');
    }
  } else {
    if (this.$data._chart) {
      this.$data._chart.destroy();

      this.$emit('chart:destroy');
    }

    this.renderChart(this.chartData, this.options);
    this.$emit('chart:render');
  }
}

var reactiveData = {
  data: function data() {
    return {
      chartData: null
    };
  },
  watch: {
    'chartData': dataHandler
  }
};
var reactiveProp = {
  props: {
    chartData: {
      required: true
    }
  },
  watch: {
    'chartData': dataHandler
  }
};
var mixins = {
  reactiveData: reactiveData,
  reactiveProp: reactiveProp
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var moment = createCommonjsModule(function (module, exports) {

  (function (global, factory) {
    module.exports = factory();
  })(commonjsGlobal, function () {

    var hookCallback;

    function hooks() {
      return hookCallback.apply(null, arguments);
    } // This is done to register the method called with moment()
    // without creating circular dependencies.


    function setHookCallback(callback) {
      hookCallback = callback;
    }

    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
      // IE8 will treat undefined and null as object if it wasn't for
      // input != null
      return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;

        for (k in obj) {
          if (obj.hasOwnProperty(k)) {
            return false;
          }
        }

        return true;
      }
    }

    function isUndefined(input) {
      return input === void 0;
    }

    function isNumber(input) {
      return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
      var res = [],
          i;

      for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
      }

      return res;
    }

    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }

      if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
      }

      if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
      }

      return a;
    }

    function createUTC(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
      // We need to deep clone this object.
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }

    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }

      return m._pf;
    }

    var some;

    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }

        return false;
      };
    }

    function isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
          return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }

      return m._isValid;
    }

    function createInvalid(flags) {
      var m = createUTC(NaN);

      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }

      return m;
    } // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.


    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
      var i, prop, val;

      if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
      }

      if (!isUndefined(from._i)) {
        to._i = from._i;
      }

      if (!isUndefined(from._f)) {
        to._f = from._f;
      }

      if (!isUndefined(from._l)) {
        to._l = from._l;
      }

      if (!isUndefined(from._strict)) {
        to._strict = from._strict;
      }

      if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
      }

      if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
      }

      if (!isUndefined(from._offset)) {
        to._offset = from._offset;
      }

      if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
      }

      if (!isUndefined(from._locale)) {
        to._locale = from._locale;
      }

      if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
          prop = momentProperties[i];
          val = from[prop];

          if (!isUndefined(val)) {
            to[prop] = val;
          }
        }
      }

      return to;
    }

    var updateInProgress = false; // Moment prototype object

    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);

      if (!this.isValid()) {
        this._d = new Date(NaN);
      } // Prevent infinite loop in case updateOffset creates new moment
      // objects.


      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }

    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }

    function absFloor(number) {
      if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }

    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;

      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }

      return value;
    } // compare two arrays, return the number of differences


    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;

      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }

      return diffs + lengthDiff;
    }

    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
        console.warn('Deprecation warning: ' + msg);
      }
    }

    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function () {
        var arguments$1 = arguments;

        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }

        if (firstTime) {
          var args = [];
          var arg;

          for (var i = 0; i < arguments.length; i++) {
            arg = '';

            if (typeof arguments$1[i] === 'object') {
              arg += '\n[' + i + '] ';

              for (var key in arguments[0]) {
                arg += key + ': ' + arguments$1[0][key] + ', ';
              }

              arg = arg.slice(0, -2); // Remove trailing comma and space
            } else {
              arg = arguments$1[i];
            }

            args.push(arg);
          }

          warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
          firstTime = false;
        }

        return fn.apply(this, arguments);
      }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }

      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set(config) {
      var prop, i;

      for (i in config) {
        prop = config[i];

        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }

      this._config = config; // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
      // TODO: Remove "ordinalParse" fallback in next major release.

      this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
    }

    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig),
          prop;

      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }

      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          // make sure changes to properties don't modify parent config
          res[prop] = extend({}, res[prop]);
        }
      }

      return res;
    }

    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }

    var keys;

    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function (obj) {
        var i,
            res = [];

        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }

        return res;
      };
    }

    var defaultCalendar = {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    };

    function calendar(key, mom, now) {
      var output = this._calendar[key] || this._calendar['sameElse'];
      return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
      LTS: 'h:mm:ss A',
      LT: 'h:mm A',
      L: 'MM/DD/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];

      if (format || !formatUpper) {
        return format;
      }

      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
      });
      return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
      return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
      return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;

      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);

          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }

      return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
      var units = [];

      for (var u in unitsObj) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }

      units.sort(function (a, b) {
        return a.priority - b.priority;
      });
      return units;
    }

    function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
    var formatFunctions = {};
    var formatTokenFunctions = {}; // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }

    function addFormatToken(token, padded, ordinal, callback) {
      var func = callback;

      if (typeof callback === 'string') {
        func = function () {
          return this[callback]();
        };
      }

      if (token) {
        formatTokenFunctions[token] = func;
      }

      if (padded) {
        formatTokenFunctions[padded[0]] = function () {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }

      if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
          return this.localeData().ordinal(func.apply(this, arguments), token);
        };
      }
    }

    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
      }

      return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
      var array = format.match(formattingTokens),
          i,
          length;

      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }

      return function (mom) {
        var output = '',
            i;

        for (i = 0; i < length; i++) {
          output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }

        return output;
      };
    } // format date using native date object


    function formatMoment(m, format) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }

      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
      return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
      var i = 5;

      function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
      }

      localFormattingTokens.lastIndex = 0;

      while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }

      return format;
    }

    var match1 = /\d/; //       0 - 9

    var match2 = /\d\d/; //      00 - 99

    var match3 = /\d{3}/; //     000 - 999

    var match4 = /\d{4}/; //    0000 - 9999

    var match6 = /[+-]?\d{6}/; // -999999 - 999999

    var match1to2 = /\d\d?/; //       0 - 99

    var match3to4 = /\d\d\d\d?/; //     999 - 9999

    var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

    var match1to3 = /\d{1,3}/; //       0 - 999

    var match1to4 = /\d{1,4}/; //       0 - 9999

    var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

    var matchUnsigned = /\d+/; //       0 - inf

    var matchSigned = /[+-]?\d+/; //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months

    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }

    function getParseRegexForToken(token, config) {
      if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
      }

      return regexes[token](config._strict, config._locale);
    } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


    function unescapeFormat(s) {
      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }));
    }

    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
      var i,
          func = callback;

      if (typeof token === 'string') {
        token = [token];
      }

      if (isNumber(callback)) {
        func = function (input, array) {
          array[callback] = toInt(input);
        };
      }

      for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
      }
    }

    function addWeekParseToken(token, callback) {
      addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
      });
    }

    function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
      }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8; // FORMATTING

    addFormatToken('Y', 0, 0, function () {
      var y = this.year();
      return y <= 9999 ? '' + y : '+' + y;
    });
    addFormatToken(0, ['YY', 2], 0, function () {
      return this.year() % 100;
    });
    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

    addUnitAlias('year', 'y'); // PRIORITIES

    addUnitPriority('year', 1); // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);
    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
      array[YEAR] = parseInt(input, 10);
    }); // HELPERS

    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    } // HOOKS


    hooks.parseTwoDigitYear = function (input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    }; // MOMENTS


    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
      return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
      return function (value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }

    function get(mom, unit) {
      return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        } else {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
      }
    } // MOMENTS


    function stringGet(units) {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units]();
      }

      return this;
    }

    function stringSet(units, value) {
      if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);

        for (var i = 0; i < prioritized.length; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);

        if (isFunction(this[units])) {
          return this[units](value);
        }
      }

      return this;
    }

    function mod(n, x) {
      return (n % x + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function (o) {
        // I know
        var i;

        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }

        return -1;
      };
    }

    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }

      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    } // FORMATTING


    addFormatToken('M', ['MM', 2], 'Mo', function () {
      return this.month() + 1;
    });
    addFormatToken('MMM', 0, 0, function (format) {
      return this.localeData().monthsShort(this, format);
    });
    addFormatToken('MMMM', 0, 0, function (format) {
      return this.localeData().months(this, format);
    }); // ALIASES

    addUnitAlias('month', 'M'); // PRIORITY

    addUnitPriority('month', 8); // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
      return locale.monthsRegex(isStrict);
    });
    addParseToken(['M', 'MM'], function (input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    }); // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

    function localeMonths(m, format) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months['standalone'];
      }

      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

    function localeMonthsShort(m, format) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
      }

      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
      var i,
          ii,
          mom,
          llc = monthName.toLocaleLowerCase();

      if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];

        for (i = 0; i < 12; ++i) {
          mom = createUTC([2000, i]);
          this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'MMM') {
          ii = indexOf.call(this._shortMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeMonthsParse(monthName, format, strict) {
      var i, mom, regex;

      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
      }

      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      } // TODO: add sorting
      // Sorting makes sure if one month (or abbr) is a prefix of another
      // see sorting in computeMonthsParse


      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);

        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
          this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }

        if (!strict && !this._monthsParse[i]) {
          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    } // MOMENTS


    function setMonth(mom, value) {
      var dayOfMonth;

      if (!mom.isValid()) {
        // No op
        return mom;
      }

      if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

          if (!isNumber(value)) {
            return mom;
          }
        }
      }

      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

      return mom;
    }

    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, 'Month');
      }
    }

    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;

    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }

        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }

    var defaultMonthsRegex = matchWord;

    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
          computeMonthsParse.call(this);
        }

        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
          this._monthsRegex = defaultMonthsRegex;
        }

        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }

    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom;

      for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
      } // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.


      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
      }

      for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate(y, m, d, h, M, s, ms) {
      // can't just apply() to create a date:
      // https://stackoverflow.com/q/181348
      var date; // the date constructor remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        date = new Date(y + 400, m, d, h, M, s, ms);

        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h, M, s, ms);
      }

      return date;
    }

    function createUTCDate(y) {
      var date; // the Date.UTC function remaps years 0-99 to 1900-1999

      if (y < 100 && y >= 0) {
        var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));

        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }

      return date;
    } // start-of-first-week - start-of-year


    function firstWeekOffset(year, dow, doy) {
      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
      fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear,
          resDayOfYear;

      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }

      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }

    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek,
          resYear;

      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }

      return {
        week: resWeek,
        year: resYear
      };
    }

    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    } // FORMATTING


    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W'); // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5); // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);
    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
    }); // HELPERS
    // LOCALES

    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    };

    function localeFirstDayOfWeek() {
      return this._week.dow;
    }

    function localeFirstDayOfYear() {
      return this._week.doy;
    } // MOMENTS


    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
    } // FORMATTING


    addFormatToken('d', 0, 'do', 'day');
    addFormatToken('dd', 0, 0, function (format) {
      return this.localeData().weekdaysMin(this, format);
    });
    addFormatToken('ddd', 0, 0, function (format) {
      return this.localeData().weekdaysShort(this, format);
    });
    addFormatToken('dddd', 0, 0, function (format) {
      return this.localeData().weekdays(this, format);
    });
    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E'); // PRIORITY

    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11); // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
      return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
      return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
      return locale.weekdaysRegex(isStrict);
    });
    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
      week[token] = toInt(input);
    }); // HELPERS

    function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
        return input;
      }

      if (!isNaN(input)) {
        return parseInt(input, 10);
      }

      input = locale.weekdaysParse(input);

      if (typeof input === 'number') {
        return input;
      }

      return null;
    }

    function parseIsoWeekday(input, locale) {
      if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
      }

      return isNaN(input) ? null : input;
    } // LOCALES


    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

    function localeWeekdays(m, format) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
      var i,
          ii,
          mom,
          llc = weekdayName.toLocaleLowerCase();

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
          mom = createUTC([2000, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
      }

      if (strict) {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format === 'dddd') {
          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
          ii = indexOf.call(this._shortWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._weekdaysParse, llc);

          if (ii !== -1) {
            return ii;
          }

          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
      var i, mom, regex;

      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
      }

      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);

        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
          this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
          this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
        }

        if (!this._weekdaysParse[i]) {
          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        } // test the regex


        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    } // MOMENTS


    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
      } else {
        return day;
      }
    }

    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      } // behaves the same as moment#day except
      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
      // as a setter, sunday should belong to the previous week.


      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }

    var defaultWeekdaysRegex = matchWord;

    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }

        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }

    var defaultWeekdaysShortRegex = matchWord;

    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }

        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }

    var defaultWeekdaysMinRegex = matchWord;

    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
          computeWeekdaysParse.call(this);
        }

        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }

        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }

    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }

      var minPieces = [],
          shortPieces = [],
          longPieces = [],
          mixedPieces = [],
          i,
          mom,
          minp,
          shortp,
          longp;

      for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.


      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);

      for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    } // FORMATTING


    function hFormat() {
      return this.hours() % 12 || 12;
    }

    function kFormat() {
      return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);
    addFormatToken('hmm', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken('hmmss', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken('Hmm', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken('Hmmss', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
      addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
    }

    meridiem('a', true);
    meridiem('A', false); // ALIASES

    addUnitAlias('hour', 'h'); // PRIORITY

    addUnitPriority('hour', 13); // PARSING

    function matchMeridiem(isStrict, locale) {
      return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);
    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);
    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    }); // LOCALES

    function localeIsPM(input) {
      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
      // Using charAt should be more compatible.
      return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

    function localeMeridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'pm' : 'PM';
      } else {
        return isLower ? 'am' : 'AM';
      }
    } // MOMENTS
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.


    var getSetHour = makeGetSet('Hours', true);
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    }; // internal storage for locale config files

    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
    } // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


    function chooseLocale(names) {
      var i = 0,
          j,
          next,
          locale,
          split;

      while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;

        while (j > 0) {
          locale = loadLocale(split.slice(0, j).join('-'));

          if (locale) {
            return locale;
          }

          if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
            //the next array item is better than a shallower substring of this one
            break;
          }

          j--;
        }

        i++;
      }

      return globalLocale;
    }

    function loadLocale(name) {
      var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

      if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
        try {
          oldLocale = globalLocale._abbr;
          var aliasedRequire = commonjsRequire;
          aliasedRequire('./locale/' + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {}
      }

      return locales[name];
    } // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.


    function getSetGlobalLocale(key, values) {
      var data;

      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }

        if (data) {
          // moment.duration._locale = moment._locale = data;
          globalLocale = data;
        } else {
          if (typeof console !== 'undefined' && console.warn) {
            //warn user if arguments are passed but the locale could not be set
            console.warn('Locale ' + key + ' not found. Did you forget to load it?');
          }
        }
      }

      return globalLocale._abbr;
    }

    function defineLocale(name, config) {
      if (config !== null) {
        var locale,
            parentConfig = baseConfig;
        config.abbr = name;

        if (locales[name] != null) {
          deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale = loadLocale(config.parentLocale);

            if (locale != null) {
              parentConfig = locale._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }

              localeFamilies[config.parentLocale].push({
                name: name,
                config: config
              });
              return null;
            }
          }
        }

        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function (x) {
            defineLocale(x.name, x.config);
          });
        } // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.


        getSetGlobalLocale(name);
        return locales[name];
      } else {
        // useful for testing
        delete locales[name];
        return null;
      }
    }

    function updateLocale(name, config) {
      if (config != null) {
        var locale,
            tmpLocale,
            parentConfig = baseConfig; // MERGE

        tmpLocale = loadLocale(name);

        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }

        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale; // backwards compat for now: also set the locale

        getSetGlobalLocale(name);
      } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }

      return locales[name];
    } // returns locale data


    function getLocale(key) {
      var locale;

      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }

      if (!key) {
        return globalLocale;
      }

      if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);

        if (locale) {
          return locale;
        }

        key = [key];
      }

      return chooseLocale(key);
    }

    function listLocales() {
      return keys(locales);
    }

    function checkOverflow(m) {
      var overflow;
      var a = m._a;

      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }

        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }

        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
      }

      return m;
    } // Pick the first defined of two or three arguments.


    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }

      if (b != null) {
        return b;
      }

      return c;
    }

    function currentDateArray(config) {
      // hooks is actually the exported moment object
      var nowValue = new Date(hooks.now());

      if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
      }

      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    } // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]


    function configFromArray(config) {
      var i,
          date,
          input = [],
          currentDate,
          expectedWeekday,
          yearToUse;

      if (config._d) {
        return;
      }

      currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      } //if the day of the year is set, figure out what it is


      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      } // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything


      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      } // Zero out whatever was not defaulted, including time


      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      } // Check for 24:00:00.000


      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }

      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
      // with parseZone.

      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }

      if (config._nextDay) {
        config._a[HOUR] = 24;
      } // check for mismatching day of week


      if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }

    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
      w = config._w;

      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).

        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);

        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        var curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
          // weekday -- low day numbers are considered next week
          weekday = w.d;

          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          // local weekday -- counting starts from beginning of week
          weekday = w.e + dow;

          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          // default to beginning of week
          weekday = dow;
        }
      }

      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    } // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

    function configFromISO(config) {
      var i,
          l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime,
          dateFormat,
          timeFormat,
          tzFormat;

      if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }

        if (dateFormat == null) {
          config._isValid = false;
          return;
        }

        if (match[3]) {
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              // match[2] should be 'T' or space
              timeFormat = (match[2] || ' ') + isoTimes[i][0];
              break;
            }
          }

          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }

        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }

        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = 'Z';
          } else {
            config._isValid = false;
            return;
          }
        }

        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }

      return result;
    }

    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);

      if (year <= 49) {
        return 2000 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }

      return year;
    }

    function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }

      return true;
    }

    var obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
      } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100,
            h = (hm - m) / 100;
        return h * 60 + m;
      }
    } // date and time from ref 2822 format


    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i));

      if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);

        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    } // date from iso format or fallback


    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);

      if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
      }

      configFromISO(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }

      configFromRFC2822(config);

      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      } // Final attempt, use Input Fallback


      hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
      config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }); // constant that refers to the ISO standard

    hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


    hooks.RFC_2822 = function () {}; // date from string and format string


    function configFromStringAndFormat(config) {
      // TODO: Move this to another part of the creation flow to prevent circular deps
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }

      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }

      config._a = [];
      getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

      var string = '' + config._i,
          i,
          parsedInput,
          tokens,
          token,
          skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;
      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));

        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));

          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }

          string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
          totalParsedInputLength += parsedInput.length;
        } // don't parse if it's not a known token


        if (formatTokenFunctions[token]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token);
          }

          addTimeToArrayFromToken(token, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token);
        }
      } // add remaining unparsed input length to the string


      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      } // clear _12h flag if hour is <= 12


      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
      }

      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
      configFromArray(config);
      checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
      var isPm;

      if (meridiem == null) {
        // nothing to do
        return hour;
      }

      if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);

        if (isPm && hour < 12) {
          hour += 12;
        }

        if (!isPm && hour === 12) {
          hour = 0;
        }

        return hour;
      } else {
        // this is not supposed to happen
        return hour;
      }
    } // date from string and array of format strings


    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore;

      if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
      }

      for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);

        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }

        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
          continue;
        } // if there is any input that was not parsed add a penalty for that format


        currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }

      extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
      if (config._d) {
        return;
      }

      var i = normalizeObjectUnits(config._i);
      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
      });
      configFromArray(config);
    }

    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));

      if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
      }

      return res;
    }

    function prepareConfig(config) {
      var input = config._i,
          format = config._f;
      config._locale = config._locale || getLocale(config._l);

      if (input === null || format === undefined && input === '') {
        return createInvalid({
          nullInput: true
        });
      }

      if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
      }

      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format)) {
        configFromStringAndArray(config);
      } else if (format) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }

      if (!isValid(config)) {
        config._d = null;
      }

      return config;
    }

    function configFromInput(config) {
      var input = config._i;

      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === 'string') {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
      var c = {};

      if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
      }

      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = undefined;
      } // object construction must be done this way.
      // https://github.com/moment/moment/issues/1423


      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;
      return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
      } else {
        return createInvalid();
      }
    });
    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
      var other = createLocal.apply(null, arguments);

      if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
      } else {
        return createInvalid();
      }
    }); // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.

    function pickBy(fn, moments) {
      var res, i;

      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }

      if (!moments.length) {
        return createLocal();
      }

      res = moments[0];

      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }

      return res;
    } // TODO: Use [].sort instead?


    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isBefore', args);
    }

    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy('isAfter', args);
    }

    var now = function () {
      return Date.now ? Date.now() : +new Date();
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
      for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }

      var unitHasDecimal = false;

      for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false; // only allow non-integers for smallest unit
          }

          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }

      return true;
    }

    function isValid$1() {
      return this._isValid;
    }

    function createInvalid$1() {
      return createDuration(NaN);
    }

    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

      this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
      minutes * 6e4 + // 1000 * 60
      hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately

      this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.

      this._months = +months + quarters * 3 + years * 12;
      this._data = {};
      this._locale = getLocale();

      this._bubble();
    }

    function isDuration(obj) {
      return obj instanceof Duration;
    }

    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    } // FORMATTING


    function offset(token, separator) {
      addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';

        if (offset < 0) {
          offset = -offset;
          sign = '-';
        }

        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
      });
    }

    offset('Z', ':');
    offset('ZZ', ''); // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    }); // HELPERS
    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']

    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher);

      if (matches === null) {
        return null;
      }

      var chunk = matches[matches.length - 1] || [];
      var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);
      return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    } // Return a moment from input, that is local/utc/zone equivalent to model.


    function cloneWithOffset(input, model) {
      var res, diff;

      if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

        res._d.setTime(res._d.valueOf() + diff);

        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }

    function getDateOffset(m) {
      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
      // https://github.com/moment/moment/pull/1871
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    } // HOOKS
    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.


    hooks.updateOffset = function () {}; // MOMENTS
    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.


    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset = this._offset || 0,
          localAdjust;

      if (!this.isValid()) {
        return input != null ? this : NaN;
      }

      if (input != null) {
        if (typeof input === 'string') {
          input = offsetFromString(matchShortOffset, input);

          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }

        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }

        this._offset = input;
        this._isUTC = true;

        if (localAdjust != null) {
          this.add(localAdjust, 'm');
        }

        if (offset !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(this, createDuration(input - offset, 'm'), 1, false);
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }

        return this;
      } else {
        return this._isUTC ? offset : getDateOffset(this);
      }
    }

    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== 'string') {
          input = -input;
        }

        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }

    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
          this.subtract(getDateOffset(this), 'm');
        }
      }

      return this;
    }

    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);

        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }

      return this;
    }

    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }

      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }

    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }

      var c = {};
      copyConfig(c, this);
      c = prepareConfig(c);

      if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }

      return this._isDSTShifted;
    }

    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    } // ASP.NET json date format regex


    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day

    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
      var duration = input,
          // matching against regexp is expensive, do it on demand
      match = null,
          sign,
          ret,
          diffRes;

      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input)) {
        duration = {};

        if (key) {
          duration[key] = input;
        } else {
          duration.milliseconds = input;
        }
      } else if (!!(match = aspNetRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign,
          h: toInt(match[HOUR]) * sign,
          m: toInt(match[MINUTE]) * sign,
          s: toInt(match[SECOND]) * sign,
          ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

        };
      } else if (!!(match = isoRegex.exec(input))) {
        sign = match[1] === '-' ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign),
          M: parseIso(match[3], sign),
          w: parseIso(match[4], sign),
          d: parseIso(match[5], sign),
          h: parseIso(match[6], sign),
          m: parseIso(match[7], sign),
          s: parseIso(match[8], sign)
        };
      } else if (duration == null) {
        // checks for null or undefined
        duration = {};
      } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }

      ret = new Duration(duration);

      if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
      }

      return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
      // We'd normally use ~~inp for this, but unfortunately it also
      // converts floats to ints.
      // inp may be undefined, so careful calling replace on it.
      var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

      return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

      if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
      }

      res.milliseconds = +other - +base.clone().add(res.months, 'M');
      return res;
    }

    function momentsDifference(base, other) {
      var res;

      if (!(base.isValid() && other.isValid())) {
        return {
          milliseconds: 0,
          months: 0
        };
      }

      other = cloneWithOffset(other, base);

      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }

      return res;
    } // TODO: remove 'name' arg after deprecation is removed


    function createAdder(direction, name) {
      return function (val, period) {
        var dur, tmp; //invert the arguments, but complain about it

        if (period !== null && !isNaN(+period)) {
          deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
          tmp = val;
          val = period;
          period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);

      if (!mom.isValid()) {
        // No op
        return;
      }

      updateOffset = updateOffset == null ? true : updateOffset;

      if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
      }

      if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
      }

      if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }

      if (updateOffset) {
        hooks.updateOffset(mom, days || months);
      }
    }

    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
      var diff = myMoment.diff(now, 'days', true);
      return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1(time, formats) {
      // We want to compare the start of today, vs this.
      // Getting start-of-today depends on whether we're local/utc/offset or not.
      var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse';
      var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
      return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone() {
      return new Moment(this);
    }

    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }

    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }

    function isBetween(from, to, units, inclusivity) {
      var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);

      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }

      inclusivity = inclusivity || '()';
      return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;

      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }

      units = normalizeUnits(units) || 'millisecond';

      if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }

    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
      var that, zoneDelta, output;

      if (!this.isValid()) {
        return NaN;
      }

      that = cloneWithOffset(input, this);

      if (!that.isValid()) {
        return NaN;
      }

      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);

      switch (units) {
        case 'year':
          output = monthDiff(this, that) / 12;
          break;

        case 'month':
          output = monthDiff(this, that);
          break;

        case 'quarter':
          output = monthDiff(this, that) / 3;
          break;

        case 'second':
          output = (this - that) / 1e3;
          break;
        // 1000

        case 'minute':
          output = (this - that) / 6e4;
          break;
        // 1000 * 60

        case 'hour':
          output = (this - that) / 36e5;
          break;
        // 1000 * 60 * 60

        case 'day':
          output = (this - that - zoneDelta) / 864e5;
          break;
        // 1000 * 60 * 60 * 24, negate dst

        case 'week':
          output = (this - that - zoneDelta) / 6048e5;
          break;
        // 1000 * 60 * 60 * 24 * 7, negate dst

        default:
          output = this - that;
      }

      return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
      // difference in months
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
      anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2,
          adjust;

      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

        adjust = (b - anchor) / (anchor2 - anchor);
      } //check for negative zero, return zero if negative zero


      return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }

      var utc = keepOffset !== true;
      var m = utc ? this.clone().utc() : this;

      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }

      if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
      }

      return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */


    function inspect() {
      if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
      }

      var func = 'moment';
      var zone = '';

      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
      }

      var prefix = '[' + func + '("]';
      var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
      var datetime = '-MM-DD[T]HH:mm:ss.SSS';
      var suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }

      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          to: this,
          from: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({
          from: this,
          to: time
        }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }

    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    } // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.


    function locale(key) {
      var newLocaleData;

      if (key === undefined) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);

        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }

        return this;
      }
    }

    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
      if (key === undefined) {
        return this.localeData();
      } else {
        return this.locale(key);
      }
    });

    function localeData() {
      return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }

    function utcStartOfDate(y, m, d) {
      // Date.UTC remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
        // preserve leap years using a full 400 year cycle, then reset
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }

    function startOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year(), 0, 1);
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
          break;

        case 'month':
          time = startOfDate(this.year(), this.month(), 1);
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date());
          break;

        case 'hour':
          time = this._d.valueOf();
          time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
          break;

        case 'minute':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;

        case 'second':
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function endOf(units) {
      var time;
      units = normalizeUnits(units);

      if (units === undefined || units === 'millisecond' || !this.isValid()) {
        return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
        case 'year':
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;

        case 'quarter':
          time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;

        case 'month':
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;

        case 'week':
          time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;

        case 'isoWeek':
          time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;

        case 'day':
        case 'date':
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;

        case 'hour':
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
          break;

        case 'minute':
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;

        case 'second':
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }

      this._d.setTime(time);

      hooks.updateOffset(this, true);
      return this;
    }

    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
      return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
      return new Date(this.valueOf());
    }

    function toArray() {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }

    function toJSON() {
      // new Date(NaN).toJSON() === null
      return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
      return isValid(this);
    }

    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
      return getParsingFlags(this).overflow;
    }

    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    } // FORMATTING


    addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ['GG', 2], 0, function () {
      return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1); // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);
    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
    });
    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
      week[token] = hooks.parseTwoDigitYear(input);
    }); // MOMENTS

    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;

      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;

      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);

        if (week > weeksTarget) {
          week = weeksTarget;
        }

        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    } // FORMATTING


    addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

    addUnitAlias('quarter', 'Q'); // PRIORITY

    addUnitPriority('quarter', 7); // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    }); // MOMENTS

    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    } // FORMATTING


    addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

    addUnitAlias('date', 'D'); // PRIORITY

    addUnitPriority('date', 9); // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
      // TODO: Remove "ordinalParse" fallback in next major release.
      return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    }); // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

    addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

    addUnitPriority('dayOfYear', 4); // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
      config._dayOfYear = toInt(input);
    }); // HELPERS
    // MOMENTS

    function getSetDayOfYear(input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    } // FORMATTING


    addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

    addUnitAlias('minute', 'm'); // PRIORITY

    addUnitPriority('minute', 14); // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE); // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

    addUnitAlias('second', 's'); // PRIORITY

    addUnitPriority('second', 15); // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND); // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

    addFormatToken('S', 0, 0, function () {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ['SS', 2], 0, function () {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
      return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
      return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
      return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
      return this.millisecond() * 1000000;
    }); // ALIASES

    addUnitAlias('millisecond', 'ms'); // PRIORITY

    addUnitPriority('millisecond', 16); // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);
    var token;

    for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
    } // MOMENTS


    var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

    function getZoneAbbr() {
      return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
      return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix(input) {
      return createLocal(input * 1000);
    }

    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
      return string;
    }

    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
      var locale = getLocale();
      var utc = createUTC().set(setter, index);
      return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';

      if (index != null) {
        return get$1(format, index, field, 'month');
      }

      var i;
      var out = [];

      for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
      }

      return out;
    } // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)


    function listWeekdaysImpl(localeSorted, format, index, field) {
      if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
          index = format;
          format = undefined;
        }

        format = format || '';
      }

      var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0;

      if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
      }

      var i;
      var out = [];

      for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
      }

      return out;
    }

    function listMonths(format, index) {
      return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
      return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function (number) {
        var b = number % 10,
            output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        return number + output;
      }
    }); // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
    var mathAbs = Math.abs;

    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }

    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    } // supports only 2.0-style add(1, 's') or add(duration)


    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    } // supports only 2.0-style subtract(1, 's') or subtract(duration)


    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }

    function bubble() {
      var milliseconds = this._milliseconds;
      var days = this._days;
      var months = this._months;
      var data = this._data;
      var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
      // check: https://github.com/moment/moment/issues/2166

      if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
      } // The following code bubbles up values, see the tests for
      // examples of what that means.


      data.milliseconds = milliseconds % 1000;
      seconds = absFloor(milliseconds / 1000);
      data.seconds = seconds % 60;
      minutes = absFloor(seconds / 60);
      data.minutes = minutes % 60;
      hours = absFloor(minutes / 60);
      data.hours = hours % 24;
      days += absFloor(hours / 24); // convert days to months

      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12;
      data.days = days;
      data.months = months;
      data.years = years;
      return this;
    }

    function daysToMonths(days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      return days * 4800 / 146097;
    }

    function monthsToDays(months) {
      // the reverse of daysToMonths
      return months * 146097 / 4800;
    }

    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }

      var days;
      var months;
      var milliseconds = this._milliseconds;
      units = normalizeUnits(units);

      if (units === 'month' || units === 'quarter' || units === 'year') {
        days = this._days + milliseconds / 864e5;
        months = this._months + daysToMonths(days);

        switch (units) {
          case 'month':
            return months;

          case 'quarter':
            return months / 3;

          case 'year':
            return months / 12;
        }
      } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));

        switch (units) {
          case 'week':
            return days / 7 + milliseconds / 6048e5;

          case 'day':
            return days + milliseconds / 864e5;

          case 'hour':
            return days * 24 + milliseconds / 36e5;

          case 'minute':
            return days * 1440 + milliseconds / 6e4;

          case 'second':
            return days * 86400 + milliseconds / 1000;
          // Math.floor prevents floating point math errors here

          case 'millisecond':
            return Math.floor(days * 864e5) + milliseconds;

          default:
            throw new Error('Unknown unit ' + units);
        }
      }
    } // TODO: Use this.as('ms')?


    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }

      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }

    function makeAs(alias) {
      return function () {
        return this.as(alias);
      };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asQuarters = makeAs('Q');
    var asYears = makeAs('y');

    function clone$1() {
      return createDuration(this);
    }

    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
      return function () {
        return this.isValid() ? this._data[name] : NaN;
      };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
      return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month
      M: 11 // months to year

    }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
      var duration = createDuration(posNegDuration).abs();
      var seconds = round(duration.as('s'));
      var minutes = round(duration.as('m'));
      var hours = round(duration.as('h'));
      var days = round(duration.as('d'));
      var months = round(duration.as('M'));
      var years = round(duration.as('y'));
      var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
    } // This function allows you to set the rounding function for relative time strings


    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === undefined) {
        return round;
      }

      if (typeof roundingFunction === 'function') {
        round = roundingFunction;
        return true;
      }

      return false;
    } // This function allows you to set a threshold for relative time strings


    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === undefined) {
        return false;
      }

      if (limit === undefined) {
        return thresholds[threshold];
      }

      thresholds[threshold] = limit;

      if (threshold === 's') {
        thresholds.ss = limit - 1;
      }

      return true;
    }

    function humanize(withSuffix) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var locale = this.localeData();
      var output = relativeTime$1(this, !withSuffix, locale);

      if (withSuffix) {
        output = locale.pastFuture(+this, output);
      }

      return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
      // for ISO strings we do not use the normal bubbling rules:
      //  * milliseconds bubble up until they become hours
      //  * days do not bubble at all
      //  * months bubble up until they become years
      // This is because there is no context-free conversion between hours and days
      // (think of clock changes)
      // and also not between days and months (28-31 days per month)
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }

      var seconds = abs$1(this._milliseconds) / 1000;
      var days = abs$1(this._days);
      var months = abs$1(this._months);
      var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

      minutes = absFloor(seconds / 60);
      hours = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60; // 12 months -> 1 year

      years = absFloor(months / 12);
      months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
      var total = this.asSeconds();

      if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
      }

      var totalSign = total < 0 ? '-' : '';
      var ymSign = sign(this._months) !== sign(total) ? '-' : '';
      var daysSign = sign(this._days) !== sign(total) ? '-' : '';
      var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
      return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang; // Side effect imports
    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf'); // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
      config._d = new Date(toInt(input));
    }); // Side effect imports

    hooks.version = '2.24.0';
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

    hooks.HTML5_FMT = {
      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
      // <input type="datetime-local" step="0.001" />
      DATE: 'YYYY-MM-DD',
      // <input type="date" />
      TIME: 'HH:mm',
      // <input type="time" />
      TIME_SECONDS: 'HH:mm:ss',
      // <input type="time" step="1" />
      TIME_MS: 'HH:mm:ss.SSS',
      // <input type="time" step="0.001" />
      WEEK: 'GGGG-[W]WW',
      // <input type="week" />
      MONTH: 'YYYY-MM' // <input type="month" />

    };
    return hooks;
  });
});

var Chart$1 = createCommonjsModule(function (module, exports) {
  /*!
   * Chart.js v2.8.0
   * https://www.chartjs.org
   * (c) 2019 Chart.js Contributors
   * Released under the MIT License
   */
  (function (global, factory) {
    module.exports = factory(function () {
      try {
        return moment;
      } catch (e) {}
    }());
  })(commonjsGlobal, function (moment) {

    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;
    /* MIT license */

    var conversions = {
      rgb2hsl: rgb2hsl,
      rgb2hsv: rgb2hsv,
      rgb2hwb: rgb2hwb,
      rgb2cmyk: rgb2cmyk,
      rgb2keyword: rgb2keyword,
      rgb2xyz: rgb2xyz,
      rgb2lab: rgb2lab,
      rgb2lch: rgb2lch,
      hsl2rgb: hsl2rgb,
      hsl2hsv: hsl2hsv,
      hsl2hwb: hsl2hwb,
      hsl2cmyk: hsl2cmyk,
      hsl2keyword: hsl2keyword,
      hsv2rgb: hsv2rgb,
      hsv2hsl: hsv2hsl,
      hsv2hwb: hsv2hwb,
      hsv2cmyk: hsv2cmyk,
      hsv2keyword: hsv2keyword,
      hwb2rgb: hwb2rgb,
      hwb2hsl: hwb2hsl,
      hwb2hsv: hwb2hsv,
      hwb2cmyk: hwb2cmyk,
      hwb2keyword: hwb2keyword,
      cmyk2rgb: cmyk2rgb,
      cmyk2hsl: cmyk2hsl,
      cmyk2hsv: cmyk2hsv,
      cmyk2hwb: cmyk2hwb,
      cmyk2keyword: cmyk2keyword,
      keyword2rgb: keyword2rgb,
      keyword2hsl: keyword2hsl,
      keyword2hsv: keyword2hsv,
      keyword2hwb: keyword2hwb,
      keyword2cmyk: keyword2cmyk,
      keyword2lab: keyword2lab,
      keyword2xyz: keyword2xyz,
      xyz2rgb: xyz2rgb,
      xyz2lab: xyz2lab,
      xyz2lch: xyz2lch,
      lab2xyz: lab2xyz,
      lab2rgb: lab2rgb,
      lab2lch: lab2lch,
      lch2lab: lch2lab,
      lch2xyz: lch2xyz,
      lch2rgb: lch2rgb
    };

    function rgb2hsl(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          l;

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max == min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    }

    function rgb2hsv(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          delta = max - min,
          h,
          s,
          v;

      if (max == 0) {
        s = 0;
      } else {
        s = delta / max * 1000 / 10;
      }

      if (max == min) {
        h = 0;
      } else if (r == max) {
        h = (g - b) / delta;
      } else if (g == max) {
        h = 2 + (b - r) / delta;
      } else if (b == max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      v = max / 255 * 1000 / 10;
      return [h, s, v];
    }

    function rgb2hwb(rgb) {
      var r = rgb[0],
          g = rgb[1],
          b = rgb[2],
          h = rgb2hsl(rgb)[0],
          w = 1 / 255 * Math.min(r, Math.min(g, b)),
          b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    }

    function rgb2cmyk(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255,
          c,
          m,
          y,
          k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    }

    function rgb2keyword(rgb) {
      return reverseKeywords[JSON.stringify(rgb)];
    }

    function rgb2xyz(rgb) {
      var r = rgb[0] / 255,
          g = rgb[1] / 255,
          b = rgb[2] / 255; // assume sRGB

      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    }

    function rgb2lab(rgb) {
      var xyz = rgb2xyz(rgb),
          x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function rgb2lch(args) {
      return lab2lch(rgb2lab(args));
    }

    function hsl2rgb(hsl) {
      var h = hsl[0] / 360,
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          t1,
          t2,
          t3,
          rgb,
          val;

      if (s == 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        t3 < 0 && t3++;
        t3 > 1 && t3--;

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    }

    function hsl2hsv(hsl) {
      var h = hsl[0],
          s = hsl[1] / 100,
          l = hsl[2] / 100,
          sv,
          v;

      if (l === 0) {
        // no need to do calc on black
        // also avoids divide by 0 error
        return [0, 0, 0];
      }

      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      v = (l + s) / 2;
      sv = 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    }

    function hsl2hwb(args) {
      return rgb2hwb(hsl2rgb(args));
    }

    function hsl2cmyk(args) {
      return rgb2cmyk(hsl2rgb(args));
    }

    function hsl2keyword(args) {
      return rgb2keyword(hsl2rgb(args));
    }

    function hsv2rgb(hsv) {
      var h = hsv[0] / 60,
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          hi = Math.floor(h) % 6;
      var f = h - Math.floor(h),
          p = 255 * v * (1 - s),
          q = 255 * v * (1 - s * f),
          t = 255 * v * (1 - s * (1 - f)),
          v = 255 * v;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    }

    function hsv2hsl(hsv) {
      var h = hsv[0],
          s = hsv[1] / 100,
          v = hsv[2] / 100,
          sl,
          l;
      l = (2 - s) * v;
      sl = s * v;
      sl /= l <= 1 ? l : 2 - l;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    }

    function hsv2hwb(args) {
      return rgb2hwb(hsv2rgb(args));
    }

    function hsv2cmyk(args) {
      return rgb2cmyk(hsv2rgb(args));
    }

    function hsv2keyword(args) {
      return rgb2keyword(hsv2rgb(args));
    } // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


    function hwb2rgb(hwb) {
      var h = hwb[0] / 360,
          wh = hwb[1] / 100,
          bl = hwb[2] / 100,
          ratio = wh + bl,
          i,
          v,
          f,
          n; // wh + bl cant be > 1

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) != 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh); // linear interpolation

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    }

    function hwb2hsl(args) {
      return rgb2hsl(hwb2rgb(args));
    }

    function hwb2hsv(args) {
      return rgb2hsv(hwb2rgb(args));
    }

    function hwb2cmyk(args) {
      return rgb2cmyk(hwb2rgb(args));
    }

    function hwb2keyword(args) {
      return rgb2keyword(hwb2rgb(args));
    }

    function cmyk2rgb(cmyk) {
      var c = cmyk[0] / 100,
          m = cmyk[1] / 100,
          y = cmyk[2] / 100,
          k = cmyk[3] / 100,
          r,
          g,
          b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    }

    function cmyk2hsl(args) {
      return rgb2hsl(cmyk2rgb(args));
    }

    function cmyk2hsv(args) {
      return rgb2hsv(cmyk2rgb(args));
    }

    function cmyk2hwb(args) {
      return rgb2hwb(cmyk2rgb(args));
    }

    function cmyk2keyword(args) {
      return rgb2keyword(cmyk2rgb(args));
    }

    function xyz2rgb(xyz) {
      var x = xyz[0] / 100,
          y = xyz[1] / 100,
          z = xyz[2] / 100,
          r,
          g,
          b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r = r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g = g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b = b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    }

    function xyz2lab(xyz) {
      var x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l,
          a,
          b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    }

    function xyz2lch(args) {
      return lab2lch(xyz2lab(args));
    }

    function lab2xyz(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          x,
          y,
          z,
          y2;

      if (l <= 8) {
        y = l * 100 / 903.3;
        y2 = 7.787 * (y / 100) + 16 / 116;
      } else {
        y = 100 * Math.pow((l + 16) / 116, 3);
        y2 = Math.pow(y / 100, 1 / 3);
      }

      x = x / 95.047 <= 0.008856 ? x = 95.047 * (a / 500 + y2 - 16 / 116) / 7.787 : 95.047 * Math.pow(a / 500 + y2, 3);
      z = z / 108.883 <= 0.008859 ? z = 108.883 * (y2 - b / 200 - 16 / 116) / 7.787 : 108.883 * Math.pow(y2 - b / 200, 3);
      return [x, y, z];
    }

    function lab2lch(lab) {
      var l = lab[0],
          a = lab[1],
          b = lab[2],
          hr,
          h,
          c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    }

    function lab2rgb(args) {
      return xyz2rgb(lab2xyz(args));
    }

    function lch2lab(lch) {
      var l = lch[0],
          c = lch[1],
          h = lch[2],
          a,
          b,
          hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    }

    function lch2xyz(args) {
      return lab2xyz(lch2lab(args));
    }

    function lch2rgb(args) {
      return lab2rgb(lch2lab(args));
    }

    function keyword2rgb(keyword) {
      return cssKeywords[keyword];
    }

    function keyword2hsl(args) {
      return rgb2hsl(keyword2rgb(args));
    }

    function keyword2hsv(args) {
      return rgb2hsv(keyword2rgb(args));
    }

    function keyword2hwb(args) {
      return rgb2hwb(keyword2rgb(args));
    }

    function keyword2cmyk(args) {
      return rgb2cmyk(keyword2rgb(args));
    }

    function keyword2lab(args) {
      return rgb2lab(keyword2rgb(args));
    }

    function keyword2xyz(args) {
      return rgb2xyz(keyword2rgb(args));
    }

    var cssKeywords = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    var reverseKeywords = {};

    for (var key in cssKeywords) {
      reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
    }

    var convert = function () {
      return new Converter();
    };

    for (var func in conversions) {
      // export Raw versions
      convert[func + "Raw"] = function (func) {
        // accept array or plain args
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          return conversions[func](arg);
        };
      }(func);

      var pair = /(\w+)2(\w+)/.exec(func),
          from = pair[1],
          to = pair[2]; // export rgb2hsl and ["rgb"]["hsl"]

      convert[from] = convert[from] || {};

      convert[from][to] = convert[func] = function (func) {
        return function (arg) {
          if (typeof arg == "number") {
            arg = Array.prototype.slice.call(arguments);
          }

          var val = conversions[func](arg);

          if (typeof val == "string" || val === undefined) {
            return val;
          } // keyword


          for (var i = 0; i < val.length; i++) {
            val[i] = Math.round(val[i]);
          }

          return val;
        };
      }(func);
    }
    /* Converter does lazy conversion and caching */


    var Converter = function () {
      this.convs = {};
    };
    /* Either get the values for a space or
      set the values for a space, depending on args */


    Converter.prototype.routeSpace = function (space, args) {
      var values = args[0];

      if (values === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof values == "number") {
        values = Array.prototype.slice.call(args);
      }

      return this.setValues(space, values);
    };
    /* Set the values for a space, invalidating cache */


    Converter.prototype.setValues = function (space, values) {
      this.space = space;
      this.convs = {};
      this.convs[space] = values;
      return this;
    };
    /* Get the values for a space. If there's already
      a conversion for the space, fetch it, otherwise
      compute it */


    Converter.prototype.getValues = function (space) {
      var vals = this.convs[space];

      if (!vals) {
        var fspace = this.space,
            from = this.convs[fspace];
        vals = convert[fspace][space](from);
        this.convs[space] = vals;
      }

      return vals;
    };

    ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function (space) {
      Converter.prototype[space] = function (vals) {
        return this.routeSpace(space, arguments);
      };
    });
    var colorConvert = convert;
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    /* MIT license */

    var colorString = {
      getRgba: getRgba,
      getHsla: getHsla,
      getRgb: getRgb,
      getHsl: getHsl,
      getHwb: getHwb,
      getAlpha: getAlpha,
      hexString: hexString,
      rgbString: rgbString,
      rgbaString: rgbaString,
      percentString: percentString,
      percentaString: percentaString,
      hslString: hslString,
      hslaString: hslaString,
      hwbString: hwbString,
      keyword: keyword
    };

    function getRgba(string) {
      if (!string) {
        return;
      }

      var abbr = /^#([a-fA-F0-9]{3,4})$/i,
          hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
          rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
          keyword = /(\w+)/;
      var rgb = [0, 0, 0],
          a = 1,
          match = string.match(abbr),
          hexAlpha = "";

      if (match) {
        match = match[1];
        hexAlpha = match[3];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];

        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
        }

        if (hexAlpha) {
          a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
        }
      } else if (match = string.match(rgba)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = parseInt(match[i + 1]);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(per)) {
        for (var i = 0; i < rgb.length; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }

        a = parseFloat(match[4]);
      } else if (match = string.match(keyword)) {
        if (match[1] == "transparent") {
          return [0, 0, 0, 0];
        }

        rgb = colorName[match[1]];

        if (!rgb) {
          return;
        }
      }

      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = scale(rgb[i], 0, 255);
      }

      if (!a && a != 0) {
        a = 1;
      } else {
        a = scale(a, 0, 1);
      }

      rgb[3] = a;
      return rgb;
    }

    function getHsla(string) {
      if (!string) {
        return;
      }

      var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hsl);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            s = scale(parseFloat(match[2]), 0, 100),
            l = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
    }

    function getHwb(string) {
      if (!string) {
        return;
      }

      var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
      var match = string.match(hwb);

      if (match) {
        var alpha = parseFloat(match[4]);
        var h = scale(parseInt(match[1]), 0, 360),
            w = scale(parseFloat(match[2]), 0, 100),
            b = scale(parseFloat(match[3]), 0, 100),
            a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
    }

    function getRgb(string) {
      var rgba = getRgba(string);
      return rgba && rgba.slice(0, 3);
    }

    function getHsl(string) {
      var hsla = getHsla(string);
      return hsla && hsla.slice(0, 3);
    }

    function getAlpha(string) {
      var vals = getRgba(string);

      if (vals) {
        return vals[3];
      } else if (vals = getHsla(string)) {
        return vals[3];
      } else if (vals = getHwb(string)) {
        return vals[3];
      }
    } // generators


    function hexString(rgba, a) {
      var a = a !== undefined && rgba.length === 3 ? a : rgba[3];
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
    }

    function rgbString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return rgbaString(rgba, alpha);
      }

      return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
    }

    function rgbaString(rgba, alpha) {
      if (alpha === undefined) {
        alpha = rgba[3] !== undefined ? rgba[3] : 1;
      }

      return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
    }

    function percentString(rgba, alpha) {
      if (alpha < 1 || rgba[3] && rgba[3] < 1) {
        return percentaString(rgba, alpha);
      }

      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgb(" + r + "%, " + g + "%, " + b + "%)";
    }

    function percentaString(rgba, alpha) {
      var r = Math.round(rgba[0] / 255 * 100),
          g = Math.round(rgba[1] / 255 * 100),
          b = Math.round(rgba[2] / 255 * 100);
      return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
    }

    function hslString(hsla, alpha) {
      if (alpha < 1 || hsla[3] && hsla[3] < 1) {
        return hslaString(hsla, alpha);
      }

      return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
    }

    function hslaString(hsla, alpha) {
      if (alpha === undefined) {
        alpha = hsla[3] !== undefined ? hsla[3] : 1;
      }

      return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
    } // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
    // (hwb have alpha optional & 1 is default value)


    function hwbString(hwb, alpha) {
      if (alpha === undefined) {
        alpha = hwb[3] !== undefined ? hwb[3] : 1;
      }

      return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
    }

    function keyword(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    } // helpers


    function scale(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }

    function hexDouble(num) {
      var str = num.toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    } //create a list of reverse color names


    var reverseNames = {};

    for (var name in colorName) {
      reverseNames[colorName[name]] = name;
    }
    /* MIT license */


    var Color = function (obj) {
      if (obj instanceof Color) {
        return obj;
      }

      if (!(this instanceof Color)) {
        return new Color(obj);
      }

      this.valid = false;
      this.values = {
        rgb: [0, 0, 0],
        hsl: [0, 0, 0],
        hsv: [0, 0, 0],
        hwb: [0, 0, 0],
        cmyk: [0, 0, 0, 0],
        alpha: 1
      }; // parse Color() argument

      var vals;

      if (typeof obj === 'string') {
        vals = colorString.getRgba(obj);

        if (vals) {
          this.setValues('rgb', vals);
        } else if (vals = colorString.getHsla(obj)) {
          this.setValues('hsl', vals);
        } else if (vals = colorString.getHwb(obj)) {
          this.setValues('hwb', vals);
        }
      } else if (typeof obj === 'object') {
        vals = obj;

        if (vals.r !== undefined || vals.red !== undefined) {
          this.setValues('rgb', vals);
        } else if (vals.l !== undefined || vals.lightness !== undefined) {
          this.setValues('hsl', vals);
        } else if (vals.v !== undefined || vals.value !== undefined) {
          this.setValues('hsv', vals);
        } else if (vals.w !== undefined || vals.whiteness !== undefined) {
          this.setValues('hwb', vals);
        } else if (vals.c !== undefined || vals.cyan !== undefined) {
          this.setValues('cmyk', vals);
        }
      }
    };

    Color.prototype = {
      isValid: function () {
        return this.valid;
      },
      rgb: function () {
        return this.setSpace('rgb', arguments);
      },
      hsl: function () {
        return this.setSpace('hsl', arguments);
      },
      hsv: function () {
        return this.setSpace('hsv', arguments);
      },
      hwb: function () {
        return this.setSpace('hwb', arguments);
      },
      cmyk: function () {
        return this.setSpace('cmyk', arguments);
      },
      rgbArray: function () {
        return this.values.rgb;
      },
      hslArray: function () {
        return this.values.hsl;
      },
      hsvArray: function () {
        return this.values.hsv;
      },
      hwbArray: function () {
        var values = this.values;

        if (values.alpha !== 1) {
          return values.hwb.concat([values.alpha]);
        }

        return values.hwb;
      },
      cmykArray: function () {
        return this.values.cmyk;
      },
      rgbaArray: function () {
        var values = this.values;
        return values.rgb.concat([values.alpha]);
      },
      hslaArray: function () {
        var values = this.values;
        return values.hsl.concat([values.alpha]);
      },
      alpha: function (val) {
        if (val === undefined) {
          return this.values.alpha;
        }

        this.setValues('alpha', val);
        return this;
      },
      red: function (val) {
        return this.setChannel('rgb', 0, val);
      },
      green: function (val) {
        return this.setChannel('rgb', 1, val);
      },
      blue: function (val) {
        return this.setChannel('rgb', 2, val);
      },
      hue: function (val) {
        if (val) {
          val %= 360;
          val = val < 0 ? 360 + val : val;
        }

        return this.setChannel('hsl', 0, val);
      },
      saturation: function (val) {
        return this.setChannel('hsl', 1, val);
      },
      lightness: function (val) {
        return this.setChannel('hsl', 2, val);
      },
      saturationv: function (val) {
        return this.setChannel('hsv', 1, val);
      },
      whiteness: function (val) {
        return this.setChannel('hwb', 1, val);
      },
      blackness: function (val) {
        return this.setChannel('hwb', 2, val);
      },
      value: function (val) {
        return this.setChannel('hsv', 2, val);
      },
      cyan: function (val) {
        return this.setChannel('cmyk', 0, val);
      },
      magenta: function (val) {
        return this.setChannel('cmyk', 1, val);
      },
      yellow: function (val) {
        return this.setChannel('cmyk', 2, val);
      },
      black: function (val) {
        return this.setChannel('cmyk', 3, val);
      },
      hexString: function () {
        return colorString.hexString(this.values.rgb);
      },
      rgbString: function () {
        return colorString.rgbString(this.values.rgb, this.values.alpha);
      },
      rgbaString: function () {
        return colorString.rgbaString(this.values.rgb, this.values.alpha);
      },
      percentString: function () {
        return colorString.percentString(this.values.rgb, this.values.alpha);
      },
      hslString: function () {
        return colorString.hslString(this.values.hsl, this.values.alpha);
      },
      hslaString: function () {
        return colorString.hslaString(this.values.hsl, this.values.alpha);
      },
      hwbString: function () {
        return colorString.hwbString(this.values.hwb, this.values.alpha);
      },
      keyword: function () {
        return colorString.keyword(this.values.rgb, this.values.alpha);
      },
      rgbNumber: function () {
        var rgb = this.values.rgb;
        return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
      },
      luminosity: function () {
        // http://www.w3.org/TR/WCAG20/#relativeluminancedef
        var rgb = this.values.rgb;
        var lum = [];

        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }

        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function (color2) {
        // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();

        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }

        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function (color2) {
        var contrastRatio = this.contrast(color2);

        if (contrastRatio >= 7.1) {
          return 'AAA';
        }

        return contrastRatio >= 4.5 ? 'AA' : '';
      },
      dark: function () {
        // YIQ equation from http://24ways.org/2010/calculating-color-contrast
        var rgb = this.values.rgb;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
        return yiq < 128;
      },
      light: function () {
        return !this.dark();
      },
      negate: function () {
        var rgb = [];

        for (var i = 0; i < 3; i++) {
          rgb[i] = 255 - this.values.rgb[i];
        }

        this.setValues('rgb', rgb);
        return this;
      },
      lighten: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] += hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      darken: function (ratio) {
        var hsl = this.values.hsl;
        hsl[2] -= hsl[2] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      saturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] += hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      desaturate: function (ratio) {
        var hsl = this.values.hsl;
        hsl[1] -= hsl[1] * ratio;
        this.setValues('hsl', hsl);
        return this;
      },
      whiten: function (ratio) {
        var hwb = this.values.hwb;
        hwb[1] += hwb[1] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      blacken: function (ratio) {
        var hwb = this.values.hwb;
        hwb[2] += hwb[2] * ratio;
        this.setValues('hwb', hwb);
        return this;
      },
      greyscale: function () {
        var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale

        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        this.setValues('rgb', [val, val, val]);
        return this;
      },
      clearer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha - alpha * ratio);
        return this;
      },
      opaquer: function (ratio) {
        var alpha = this.values.alpha;
        this.setValues('alpha', alpha + alpha * ratio);
        return this;
      },
      rotate: function (degrees) {
        var hsl = this.values.hsl;
        var hue = (hsl[0] + degrees) % 360;
        hsl[0] = hue < 0 ? 360 + hue : hue;
        this.setValues('hsl', hsl);
        return this;
      },

      /**
       * Ported from sass implementation in C
       * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
       */
      mix: function (mixinColor, weight) {
        var color1 = this;
        var color2 = mixinColor;
        var p = weight === undefined ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;
        return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
      },
      toJSON: function () {
        return this.rgb();
      },
      clone: function () {
        // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
        // making the final build way to big to embed in Chart.js. So let's do it manually,
        // assuming that values to clone are 1 dimension arrays containing only numbers,
        // except 'alpha' which is a number.
        var result = new Color();
        var source = this.values;
        var target = result.values;
        var value, type;

        for (var prop in source) {
          if (source.hasOwnProperty(prop)) {
            value = source[prop];
            type = {}.toString.call(value);

            if (type === '[object Array]') {
              target[prop] = value.slice(0);
            } else if (type === '[object Number]') {
              target[prop] = value;
            } else {
              console.error('unexpected color value:', value);
            }
          }
        }

        return result;
      }
    };
    Color.prototype.spaces = {
      rgb: ['red', 'green', 'blue'],
      hsl: ['hue', 'saturation', 'lightness'],
      hsv: ['hue', 'saturation', 'value'],
      hwb: ['hue', 'whiteness', 'blackness'],
      cmyk: ['cyan', 'magenta', 'yellow', 'black']
    };
    Color.prototype.maxes = {
      rgb: [255, 255, 255],
      hsl: [360, 100, 100],
      hsv: [360, 100, 100],
      hwb: [360, 100, 100],
      cmyk: [100, 100, 100, 100]
    };

    Color.prototype.getValues = function (space) {
      var values = this.values;
      var vals = {};

      for (var i = 0; i < space.length; i++) {
        vals[space.charAt(i)] = values[space][i];
      }

      if (values.alpha !== 1) {
        vals.a = values.alpha;
      } // {r: 255, g: 255, b: 255, a: 0.4}


      return vals;
    };

    Color.prototype.setValues = function (space, vals) {
      var values = this.values;
      var spaces = this.spaces;
      var maxes = this.maxes;
      var alpha = 1;
      var i;
      this.valid = true;

      if (space === 'alpha') {
        alpha = vals;
      } else if (vals.length) {
        // [10, 10, 10]
        values[space] = vals.slice(0, space.length);
        alpha = vals[space.length];
      } else if (vals[space.charAt(0)] !== undefined) {
        // {r: 10, g: 10, b: 10}
        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[space.charAt(i)];
        }

        alpha = vals.a;
      } else if (vals[spaces[space][0]] !== undefined) {
        // {red: 10, green: 10, blue: 10}
        var chans = spaces[space];

        for (i = 0; i < space.length; i++) {
          values[space][i] = vals[chans[i]];
        }

        alpha = vals.alpha;
      }

      values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

      if (space === 'alpha') {
        return false;
      }

      var capped; // cap values of the space prior converting all values

      for (i = 0; i < space.length; i++) {
        capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
        values[space][i] = Math.round(capped);
      } // convert to all the other color spaces


      for (var sname in spaces) {
        if (sname !== space) {
          values[sname] = colorConvert[space][sname](values[space]);
        }
      }

      return true;
    };

    Color.prototype.setSpace = function (space, args) {
      var vals = args[0];

      if (vals === undefined) {
        // color.rgb()
        return this.getValues(space);
      } // color.rgb(10, 10, 10)


      if (typeof vals === 'number') {
        vals = Array.prototype.slice.call(args);
      }

      this.setValues(space, vals);
      return this;
    };

    Color.prototype.setChannel = function (space, index, val) {
      var svalues = this.values[space];

      if (val === undefined) {
        // color.red()
        return svalues[index];
      } else if (val === svalues[index]) {
        // color.red(color.red())
        return this;
      } // color.red(100)


      svalues[index] = val;
      this.setValues(space, svalues);
      return this;
    };

    if (typeof window !== 'undefined') {
      window.Color = Color;
    }

    var chartjsColor = Color;
    /**
     * @namespace Chart.helpers
     */

    var helpers = {
      /**
       * An empty function that can be used, for example, for optional callback.
       */
      noop: function () {},

      /**
       * Returns a unique id, sequentially generated from a global variable.
       * @returns {number}
       * @function
       */
      uid: function () {
        var id = 0;
        return function () {
          return id++;
        };
      }(),

      /**
       * Returns true if `value` is neither null nor undefined, else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isNullOrUndef: function (value) {
        return value === null || typeof value === 'undefined';
      },

      /**
       * Returns true if `value` is an array (including typed arrays), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @function
       */
      isArray: function (value) {
        if (Array.isArray && Array.isArray(value)) {
          return true;
        }

        var type = Object.prototype.toString.call(value);

        if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
          return true;
        }

        return false;
      },

      /**
       * Returns true if `value` is an object (excluding null), else returns false.
       * @param {*} value - The value to test.
       * @returns {boolean}
       * @since 2.7.0
       */
      isObject: function (value) {
        return value !== null && Object.prototype.toString.call(value) === '[object Object]';
      },

      /**
       * Returns true if `value` is a finite number, else returns false
       * @param {*} value  - The value to test.
       * @returns {boolean}
       */
      isFinite: function (value) {
        return (typeof value === 'number' || value instanceof Number) && isFinite(value);
      },

      /**
       * Returns `value` if defined, else returns `defaultValue`.
       * @param {*} value - The value to return if defined.
       * @param {*} defaultValue - The value to return if `value` is undefined.
       * @returns {*}
       */
      valueOrDefault: function (value, defaultValue) {
        return typeof value === 'undefined' ? defaultValue : value;
      },

      /**
       * Returns value at the given `index` in array if defined, else returns `defaultValue`.
       * @param {Array} value - The array to lookup for value at `index`.
       * @param {number} index - The index in `value` to lookup for value.
       * @param {*} defaultValue - The value to return if `value[index]` is undefined.
       * @returns {*}
       */
      valueAtIndexOrDefault: function (value, index, defaultValue) {
        return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
      },

      /**
       * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
       * value returned by `fn`. If `fn` is not a function, this method returns undefined.
       * @param {function} fn - The function to call.
       * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @returns {*}
       */
      callback: function (fn, args, thisArg) {
        if (fn && typeof fn.call === 'function') {
          return fn.apply(thisArg, args);
        }
      },

      /**
       * Note(SB) for performance sake, this method should only be used when loopable type
       * is unknown or in none intensive code (not called often and small loopable). Else
       * it's preferable to use a regular for() loop and save extra function calls.
       * @param {object|Array} loopable - The object or array to be iterated.
       * @param {function} fn - The function to call for each item.
       * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
       * @param {boolean} [reverse] - If true, iterates backward on the loopable.
       */
      each: function (loopable, fn, thisArg, reverse) {
        var i, len, keys;

        if (helpers.isArray(loopable)) {
          len = loopable.length;

          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (helpers.isObject(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;

          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      },

      /**
       * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
       * @see https://stackoverflow.com/a/14853974
       * @param {Array} a0 - The array to compare
       * @param {Array} a1 - The array to compare
       * @returns {boolean}
       */
      arrayEquals: function (a0, a1) {
        var i, ilen, v0, v1;

        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }

        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];

          if (v0 instanceof Array && v1 instanceof Array) {
            if (!helpers.arrayEquals(v0, v1)) {
              return false;
            }
          } else if (v0 !== v1) {
            // NOTE: two different object instances will never be equal: {x:20} != {x:20}
            return false;
          }
        }

        return true;
      },

      /**
       * Returns a deep copy of `source` without keeping references on objects and arrays.
       * @param {*} source - The value to clone.
       * @returns {*}
       */
      clone: function (source) {
        if (helpers.isArray(source)) {
          return source.map(helpers.clone);
        }

        if (helpers.isObject(source)) {
          var target = {};
          var keys = Object.keys(source);
          var klen = keys.length;
          var k = 0;

          for (; k < klen; ++k) {
            target[keys[k]] = helpers.clone(source[keys[k]]);
          }

          return target;
        }

        return source;
      },

      /**
       * The default merger when Chart.helpers.merge is called without merger option.
       * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
       * @private
       */
      _merger: function (key, target, source, options) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.merge(tval, sval, options);
        } else {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Merges source[key] in target[key] only if target[key] is undefined.
       * @private
       */
      _mergerIf: function (key, target, source) {
        var tval = target[key];
        var sval = source[key];

        if (helpers.isObject(tval) && helpers.isObject(sval)) {
          helpers.mergeIf(tval, sval);
        } else if (!target.hasOwnProperty(key)) {
          target[key] = helpers.clone(sval);
        }
      },

      /**
       * Recursively deep copies `source` properties into `target` with the given `options`.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @param {object} [options] - Merging options:
       * @param {function} [options.merger] - The merge method (key, target, source, options)
       * @returns {object} The `target` object.
       */
      merge: function (target, source, options) {
        var sources = helpers.isArray(source) ? source : [source];
        var ilen = sources.length;
        var merge, i, keys, klen, k;

        if (!helpers.isObject(target)) {
          return target;
        }

        options = options || {};
        merge = options.merger || helpers._merger;

        for (i = 0; i < ilen; ++i) {
          source = sources[i];

          if (!helpers.isObject(source)) {
            continue;
          }

          keys = Object.keys(source);

          for (k = 0, klen = keys.length; k < klen; ++k) {
            merge(keys[k], target, source, options);
          }
        }

        return target;
      },

      /**
       * Recursively deep copies `source` properties into `target` *only* if not defined in target.
       * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
       * @param {object} target - The target object in which all sources are merged into.
       * @param {object|object[]} source - Object(s) to merge into `target`.
       * @returns {object} The `target` object.
       */
      mergeIf: function (target, source) {
        return helpers.merge(target, source, {
          merger: helpers._mergerIf
        });
      },

      /**
       * Applies the contents of two or more objects together into the first object.
       * @param {object} target - The target object in which all objects are merged into.
       * @param {object} arg1 - Object containing additional properties to merge in target.
       * @param {object} argN - Additional objects containing properties to merge in target.
       * @returns {object} The `target` object.
       */
      extend: function (target) {
        var arguments$1 = arguments;

        var setFn = function (value, key) {
          target[key] = value;
        };

        for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
          helpers.each(arguments$1[i], setFn);
        }

        return target;
      },

      /**
       * Basic javascript inheritance based on the model created in Backbone.js
       */
      inherits: function (extensions) {
        var me = this;
        var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
          return me.apply(this, arguments);
        };

        var Surrogate = function () {
          this.constructor = ChartElement;
        };

        Surrogate.prototype = me.prototype;
        ChartElement.prototype = new Surrogate();
        ChartElement.extend = helpers.inherits;

        if (extensions) {
          helpers.extend(ChartElement.prototype, extensions);
        }

        ChartElement.__super__ = me.prototype;
        return ChartElement;
      }
    };
    var helpers_core = helpers; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.callback instead.
     * @function Chart.helpers.callCallback
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    helpers.callCallback = helpers.callback;
    /**
     * Provided for backward compatibility, use Array.prototype.indexOf instead.
     * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
     * @function Chart.helpers.indexOf
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.indexOf = function (array, item, fromIndex) {
      return Array.prototype.indexOf.call(array, item, fromIndex);
    };
    /**
     * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
     * @function Chart.helpers.getValueOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */


    helpers.getValueOrDefault = helpers.valueOrDefault;
    /**
     * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
     * @function Chart.helpers.getValueAtIndexOrDefault
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
    /**
     * Easing functions adapted from Robert Penner's easing equations.
     * @namespace Chart.helpers.easingEffects
     * @see http://www.robertpenner.com/easing/
     */

    var effects = {
      linear: function (t) {
        return t;
      },
      easeInQuad: function (t) {
        return t * t;
      },
      easeOutQuad: function (t) {
        return -t * (t - 2);
      },
      easeInOutQuad: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t;
        }

        return -0.5 * (--t * (t - 2) - 1);
      },
      easeInCubic: function (t) {
        return t * t * t;
      },
      easeOutCubic: function (t) {
        return (t = t - 1) * t * t + 1;
      },
      easeInOutCubic: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t + 2);
      },
      easeInQuart: function (t) {
        return t * t * t * t;
      },
      easeOutQuart: function (t) {
        return -((t = t - 1) * t * t * t - 1);
      },
      easeInOutQuart: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t;
        }

        return -0.5 * ((t -= 2) * t * t * t - 2);
      },
      easeInQuint: function (t) {
        return t * t * t * t * t;
      },
      easeOutQuint: function (t) {
        return (t = t - 1) * t * t * t * t + 1;
      },
      easeInOutQuint: function (t) {
        if ((t /= 0.5) < 1) {
          return 0.5 * t * t * t * t * t;
        }

        return 0.5 * ((t -= 2) * t * t * t * t + 2);
      },
      easeInSine: function (t) {
        return -Math.cos(t * (Math.PI / 2)) + 1;
      },
      easeOutSine: function (t) {
        return Math.sin(t * (Math.PI / 2));
      },
      easeInOutSine: function (t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
      },
      easeInExpo: function (t) {
        return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
      },
      easeOutExpo: function (t) {
        return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
      },
      easeInOutExpo: function (t) {
        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if ((t /= 0.5) < 1) {
          return 0.5 * Math.pow(2, 10 * (t - 1));
        }

        return 0.5 * (-Math.pow(2, -10 * --t) + 2);
      },
      easeInCirc: function (t) {
        if (t >= 1) {
          return t;
        }

        return -(Math.sqrt(1 - t * t) - 1);
      },
      easeOutCirc: function (t) {
        return Math.sqrt(1 - (t = t - 1) * t);
      },
      easeInOutCirc: function (t) {
        if ((t /= 0.5) < 1) {
          return -0.5 * (Math.sqrt(1 - t * t) - 1);
        }

        return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
      },
      easeInElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
      },
      easeOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if (t === 1) {
          return 1;
        }

        if (!p) {
          p = 0.3;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
      },
      easeInOutElastic: function (t) {
        var s = 1.70158;
        var p = 0;
        var a = 1;

        if (t === 0) {
          return 0;
        }

        if ((t /= 0.5) === 2) {
          return 1;
        }

        if (!p) {
          p = 0.45;
        }

        if (a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p / (2 * Math.PI) * Math.asin(1 / a);
        }

        if (t < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
        }

        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      easeInBack: function (t) {
        var s = 1.70158;
        return t * t * ((s + 1) * t - s);
      },
      easeOutBack: function (t) {
        var s = 1.70158;
        return (t = t - 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack: function (t) {
        var s = 1.70158;

        if ((t /= 0.5) < 1) {
          return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
        }

        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      easeInBounce: function (t) {
        return 1 - effects.easeOutBounce(1 - t);
      },
      easeOutBounce: function (t) {
        if (t < 1 / 2.75) {
          return 7.5625 * t * t;
        }

        if (t < 2 / 2.75) {
          return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        }

        if (t < 2.5 / 2.75) {
          return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        }

        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
      },
      easeInOutBounce: function (t) {
        if (t < 0.5) {
          return effects.easeInBounce(t * 2) * 0.5;
        }

        return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
      }
    };
    var helpers_easing = {
      effects: effects
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
     * @function Chart.helpers.easingEffects
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.easingEffects = effects;
    var PI = Math.PI;
    var RAD_PER_DEG = PI / 180;
    var DOUBLE_PI = PI * 2;
    var HALF_PI = PI / 2;
    var QUARTER_PI = PI / 4;
    var TWO_THIRDS_PI = PI * 2 / 3;
    /**
     * @namespace Chart.helpers.canvas
     */

    var exports$1 = {
      /**
       * Clears the entire canvas associated to the given `chart`.
       * @param {Chart} chart - The chart for which to clear the canvas.
       */
      clear: function (chart) {
        chart.ctx.clearRect(0, 0, chart.width, chart.height);
      },

      /**
       * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
       * given size (width, height) and the same `radius` for all corners.
       * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
       * @param {number} x - The x axis of the coordinate for the rectangle starting point.
       * @param {number} y - The y axis of the coordinate for the rectangle starting point.
       * @param {number} width - The rectangle's width.
       * @param {number} height - The rectangle's height.
       * @param {number} radius - The rounded amount (in pixels) for the four corners.
       * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
       */
      roundedRect: function (ctx, x, y, width, height, radius) {
        if (radius) {
          var r = Math.min(radius, height / 2, width / 2);
          var left = x + r;
          var top = y + r;
          var right = x + width - r;
          var bottom = y + height - r;
          ctx.moveTo(x, top);

          if (left < right && top < bottom) {
            ctx.arc(left, top, r, -PI, -HALF_PI);
            ctx.arc(right, top, r, -HALF_PI, 0);
            ctx.arc(right, bottom, r, 0, HALF_PI);
            ctx.arc(left, bottom, r, HALF_PI, PI);
          } else if (left < right) {
            ctx.moveTo(left, y);
            ctx.arc(right, top, r, -HALF_PI, HALF_PI);
            ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
          } else if (top < bottom) {
            ctx.arc(left, top, r, -PI, 0);
            ctx.arc(left, bottom, r, 0, PI);
          } else {
            ctx.arc(left, top, r, -PI, PI);
          }

          ctx.closePath();
          ctx.moveTo(x, y);
        } else {
          ctx.rect(x, y, width, height);
        }
      },
      drawPoint: function (ctx, style, radius, x, y, rotation) {
        var type, xOffset, yOffset, size, cornerRadius;
        var rad = (rotation || 0) * RAD_PER_DEG;

        if (style && typeof style === 'object') {
          type = style.toString();

          if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
            ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
            return;
          }
        }

        if (isNaN(radius) || radius <= 0) {
          return;
        }

        ctx.beginPath();

        switch (style) {
          // Default includes circle
          default:
            ctx.arc(x, y, radius, 0, DOUBLE_PI);
            ctx.closePath();
            break;

          case 'triangle':
            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;

          case 'rectRounded':
            // NOTE: the rounded rect implementation changed to use `arc` instead of
            // `quadraticCurveTo` since it generates better results when rect is
            // almost a circle. 0.516 (instead of 0.5) produces results with visually
            // closer proportion to the previous impl and it is inscribed in the
            // circle with `radius`. For more details, see the following PRs:
            // https://github.com/chartjs/Chart.js/issues/5597
            // https://github.com/chartjs/Chart.js/issues/5858
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;

          case 'rect':
            if (!rotation) {
              size = Math.SQRT1_2 * radius;
              ctx.rect(x - size, y - size, 2 * size, 2 * size);
              break;
            }

            rad += QUARTER_PI;

          /* falls through */

          case 'rectRot':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + yOffset, y - xOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            ctx.closePath();
            break;

          case 'crossRot':
            rad += QUARTER_PI;

          /* falls through */

          case 'cross':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'star':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            rad += QUARTER_PI;
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;

          case 'line':
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;

          case 'dash':
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
            break;
        }

        ctx.fill();
        ctx.stroke();
      },

      /**
       * Returns true if the point is inside the rectangle
       * @param {object} point - The point to test
       * @param {object} area - The rectangle
       * @returns {boolean}
       * @private
       */
      _isPointInArea: function (point, area) {
        var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

        return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
      },
      clipArea: function (ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      },
      unclipArea: function (ctx) {
        ctx.restore();
      },
      lineTo: function (ctx, previous, target, flip) {
        var stepped = target.steppedLine;

        if (stepped) {
          if (stepped === 'middle') {
            var midpoint = (previous.x + target.x) / 2.0;
            ctx.lineTo(midpoint, flip ? target.y : previous.y);
            ctx.lineTo(midpoint, flip ? previous.y : target.y);
          } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }

          ctx.lineTo(target.x, target.y);
          return;
        }

        if (!target.tension) {
          ctx.lineTo(target.x, target.y);
          return;
        }

        ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
      }
    };
    var helpers_canvas = exports$1; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
     * @namespace Chart.helpers.clear
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.clear = exports$1.clear;
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
     * @namespace Chart.helpers.drawRoundedRectangle
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers_core.drawRoundedRectangle = function (ctx) {
      ctx.beginPath();
      exports$1.roundedRect.apply(exports$1, arguments);
    };

    var defaults = {
      /**
       * @private
       */
      _set: function (scope, values) {
        return helpers_core.merge(this[scope] || (this[scope] = {}), values);
      }
    };

    defaults._set('global', {
      defaultColor: 'rgba(0,0,0,0.1)',
      defaultFontColor: '#666',
      defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      defaultFontSize: 12,
      defaultFontStyle: 'normal',
      defaultLineHeight: 1.2,
      showLines: true
    });

    var core_defaults = defaults;
    var valueOrDefault = helpers_core.valueOrDefault;
    /**
     * Converts the given font object into a CSS font string.
     * @param {object} font - A font object.
     * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
     * @private
     */

    function toFontString(font) {
      if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
        return null;
      }

      return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
    }
    /**
     * @alias Chart.helpers.options
     * @namespace
     */


    var helpers_options = {
      /**
       * Converts the given line height `value` in pixels for a specific font `size`.
       * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
       * @param {number} size - The font size (in pixels) used to resolve relative `value`.
       * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
       * @since 2.7.0
       */
      toLineHeight: function (value, size) {
        var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);

        if (!matches || matches[1] === 'normal') {
          return size * 1.2;
        }

        value = +matches[2];

        switch (matches[3]) {
          case 'px':
            return value;

          case '%':
            value /= 100;
            break;

          default:
            break;
        }

        return size * value;
      },

      /**
       * Converts the given value into a padding object with pre-computed width/height.
       * @param {number|object} value - If a number, set the value to all TRBL component,
       *  else, if and object, use defined properties and sets undefined ones to 0.
       * @returns {object} The padding values (top, right, bottom, left, width, height)
       * @since 2.7.0
       */
      toPadding: function (value) {
        var t, r, b, l;

        if (helpers_core.isObject(value)) {
          t = +value.top || 0;
          r = +value.right || 0;
          b = +value.bottom || 0;
          l = +value.left || 0;
        } else {
          t = r = b = l = +value || 0;
        }

        return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          height: t + b,
          width: l + r
        };
      },

      /**
       * Parses font options and returns the font object.
       * @param {object} options - A object that contains font options to be parsed.
       * @return {object} The font object.
       * @todo Support font.* options and renamed to toFont().
       * @private
       */
      _parseFont: function (options) {
        var globalDefaults = core_defaults.global;
        var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
        var font = {
          family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
          lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
          size: size,
          style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
          weight: null,
          string: ''
        };
        font.string = toFontString(font);
        return font;
      },

      /**
       * Evaluates the given `inputs` sequentially and returns the first defined value.
       * @param {Array} inputs - An array of values, falling back to the last value.
       * @param {object} [context] - If defined and the current value is a function, the value
       * is called with `context` as first argument and the result becomes the new input.
       * @param {number} [index] - If defined and the current value is an array, the value
       * at `index` become the new input.
       * @since 2.7.0
       */
      resolve: function (inputs, context, index) {
        var i, ilen, value;

        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];

          if (value === undefined) {
            continue;
          }

          if (context !== undefined && typeof value === 'function') {
            value = value(context);
          }

          if (index !== undefined && helpers_core.isArray(value)) {
            value = value[index];
          }

          if (value !== undefined) {
            return value;
          }
        }
      }
    };
    var helpers$1 = helpers_core;
    var easing = helpers_easing;
    var canvas = helpers_canvas;
    var options = helpers_options;
    helpers$1.easing = easing;
    helpers$1.canvas = canvas;
    helpers$1.options = options;

    function interpolate(start, view, model, ease) {
      var keys = Object.keys(model);
      var i, ilen, key, actual, origin, target, type, c0, c1;

      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        target = model[key]; // if a value is added to the model after pivot() has been called, the view
        // doesn't contain it, so let's initialize the view to the target value.

        if (!view.hasOwnProperty(key)) {
          view[key] = target;
        }

        actual = view[key];

        if (actual === target || key[0] === '_') {
          continue;
        }

        if (!start.hasOwnProperty(key)) {
          start[key] = actual;
        }

        origin = start[key];
        type = typeof target;

        if (type === typeof origin) {
          if (type === 'string') {
            c0 = chartjsColor(origin);

            if (c0.valid) {
              c1 = chartjsColor(target);

              if (c1.valid) {
                view[key] = c1.mix(c0, ease).rgbString();
                continue;
              }
            }
          } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
            view[key] = origin + (target - origin) * ease;
            continue;
          }
        }

        view[key] = target;
      }
    }

    var Element = function (configuration) {
      helpers$1.extend(this, configuration);
      this.initialize.apply(this, arguments);
    };

    helpers$1.extend(Element.prototype, {
      initialize: function () {
        this.hidden = false;
      },
      pivot: function () {
        var me = this;

        if (!me._view) {
          me._view = helpers$1.clone(me._model);
        }

        me._start = {};
        return me;
      },
      transition: function (ease) {
        var me = this;
        var model = me._model;
        var start = me._start;
        var view = me._view; // No animation -> No Transition

        if (!model || ease === 1) {
          me._view = model;
          me._start = null;
          return me;
        }

        if (!view) {
          view = me._view = {};
        }

        if (!start) {
          start = me._start = {};
        }

        interpolate(start, view, model, ease);
        return me;
      },
      tooltipPosition: function () {
        return {
          x: this._model.x,
          y: this._model.y
        };
      },
      hasValue: function () {
        return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
      }
    });
    Element.extend = helpers$1.inherits;
    var core_element = Element;
    var exports$2 = core_element.extend({
      chart: null,
      // the animation associated chart instance
      currentStep: 0,
      // the current animation step
      numSteps: 60,
      // default number of steps
      easing: '',
      // the easing to use for this animation
      render: null,
      // render function used by the animation service
      onAnimationProgress: null,
      // user specified callback to fire on each step of the animation
      onAnimationComplete: null // user specified callback to fire when the animation finishes

    });
    var core_animation = exports$2; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart.Animation instead
     * @prop Chart.Animation#animationObject
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'animationObject', {
      get: function () {
        return this;
      }
    });
    /**
     * Provided for backward compatibility, use Chart.Animation#chart instead
     * @prop Chart.Animation#chartInstance
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     */

    Object.defineProperty(exports$2.prototype, 'chartInstance', {
      get: function () {
        return this.chart;
      },
      set: function (value) {
        this.chart = value;
      }
    });

    core_defaults._set('global', {
      animation: {
        duration: 1000,
        easing: 'easeOutQuart',
        onProgress: helpers$1.noop,
        onComplete: helpers$1.noop
      }
    });

    var core_animations = {
      animations: [],
      request: null,

      /**
       * @param {Chart} chart - The chart to animate.
       * @param {Chart.Animation} animation - The animation that we will animate.
       * @param {number} duration - The animation duration in ms.
       * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
       */
      addAnimation: function (chart, animation, duration, lazy) {
        var animations = this.animations;
        var i, ilen;
        animation.chart = chart;
        animation.startTime = Date.now();
        animation.duration = duration;

        if (!lazy) {
          chart.animating = true;
        }

        for (i = 0, ilen = animations.length; i < ilen; ++i) {
          if (animations[i].chart === chart) {
            animations[i] = animation;
            return;
          }
        }

        animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word

        if (animations.length === 1) {
          this.requestAnimationFrame();
        }
      },
      cancelAnimation: function (chart) {
        var index = helpers$1.findIndex(this.animations, function (animation) {
          return animation.chart === chart;
        });

        if (index !== -1) {
          this.animations.splice(index, 1);
          chart.animating = false;
        }
      },
      requestAnimationFrame: function () {
        var me = this;

        if (me.request === null) {
          // Skip animation frame requests until the active one is executed.
          // This can happen when processing mouse events, e.g. 'mousemove'
          // and 'mouseout' events will trigger multiple renders.
          me.request = helpers$1.requestAnimFrame.call(window, function () {
            me.request = null;
            me.startDigest();
          });
        }
      },

      /**
       * @private
       */
      startDigest: function () {
        var me = this;
        me.advance(); // Do we have more stuff to animate?

        if (me.animations.length > 0) {
          me.requestAnimationFrame();
        }
      },

      /**
       * @private
       */
      advance: function () {
        var animations = this.animations;
        var animation, chart, numSteps, nextStep;
        var i = 0; // 1 animation per chart, so we are looping charts here

        while (i < animations.length) {
          animation = animations[i];
          chart = animation.chart;
          numSteps = animation.numSteps; // Make sure that currentStep starts at 1
          // https://github.com/chartjs/Chart.js/issues/6104

          nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
          animation.currentStep = Math.min(nextStep, numSteps);
          helpers$1.callback(animation.render, [chart, animation], chart);
          helpers$1.callback(animation.onAnimationProgress, [animation], chart);

          if (animation.currentStep >= numSteps) {
            helpers$1.callback(animation.onAnimationComplete, [animation], chart);
            chart.animating = false;
            animations.splice(i, 1);
          } else {
            ++i;
          }
        }
      }
    };
    var resolve = helpers$1.options.resolve;
    var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
    /**
     * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
     * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
     * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
     */

    function listenArrayEvents(array, listener) {
      if (array._chartjs) {
        array._chartjs.listeners.push(listener);

        return;
      }

      Object.defineProperty(array, '_chartjs', {
        configurable: true,
        enumerable: false,
        value: {
          listeners: [listener]
        }
      });
      arrayEvents.forEach(function (key) {
        var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
        var base = array[key];
        Object.defineProperty(array, key, {
          configurable: true,
          enumerable: false,
          value: function () {
            var args = Array.prototype.slice.call(arguments);
            var res = base.apply(this, args);
            helpers$1.each(array._chartjs.listeners, function (object) {
              if (typeof object[method] === 'function') {
                object[method].apply(object, args);
              }
            });
            return res;
          }
        });
      });
    }
    /**
     * Removes the given array event listener and cleanup extra attached properties (such as
     * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
     */


    function unlistenArrayEvents(array, listener) {
      var stub = array._chartjs;

      if (!stub) {
        return;
      }

      var listeners = stub.listeners;
      var index = listeners.indexOf(listener);

      if (index !== -1) {
        listeners.splice(index, 1);
      }

      if (listeners.length > 0) {
        return;
      }

      arrayEvents.forEach(function (key) {
        delete array[key];
      });
      delete array._chartjs;
    } // Base class for all dataset controllers (line, bar, etc)


    var DatasetController = function (chart, datasetIndex) {
      this.initialize(chart, datasetIndex);
    };

    helpers$1.extend(DatasetController.prototype, {
      /**
       * Element type used to generate a meta dataset (e.g. Chart.element.Line).
       * @type {Chart.core.element}
       */
      datasetElementType: null,

      /**
       * Element type used to generate a meta data (e.g. Chart.element.Point).
       * @type {Chart.core.element}
       */
      dataElementType: null,
      initialize: function (chart, datasetIndex) {
        var me = this;
        me.chart = chart;
        me.index = datasetIndex;
        me.linkScales();
        me.addElements();
      },
      updateIndex: function (datasetIndex) {
        this.index = datasetIndex;
      },
      linkScales: function () {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        if (meta.xAxisID === null || !(meta.xAxisID in me.chart.scales)) {
          meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
        }

        if (meta.yAxisID === null || !(meta.yAxisID in me.chart.scales)) {
          meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
        }
      },
      getDataset: function () {
        return this.chart.data.datasets[this.index];
      },
      getMeta: function () {
        return this.chart.getDatasetMeta(this.index);
      },
      getScaleForId: function (scaleID) {
        return this.chart.scales[scaleID];
      },

      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().yAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getValueScale: function () {
        return this.getScaleForId(this._getValueScaleId());
      },

      /**
       * @private
       */
      _getIndexScale: function () {
        return this.getScaleForId(this._getIndexScaleId());
      },
      reset: function () {
        this.update(true);
      },

      /**
       * @private
       */
      destroy: function () {
        if (this._data) {
          unlistenArrayEvents(this._data, this);
        }
      },
      createMetaDataset: function () {
        var me = this;
        var type = me.datasetElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index
        });
      },
      createMetaData: function (index) {
        var me = this;
        var type = me.dataElementType;
        return type && new type({
          _chart: me.chart,
          _datasetIndex: me.index,
          _index: index
        });
      },
      addElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data || [];
        var metaData = meta.data;
        var i, ilen;

        for (i = 0, ilen = data.length; i < ilen; ++i) {
          metaData[i] = metaData[i] || me.createMetaData(i);
        }

        meta.dataset = meta.dataset || me.createMetaDataset();
      },
      addElementAndReset: function (index) {
        var element = this.createMetaData(index);
        this.getMeta().data.splice(index, 0, element);
        this.updateElement(element, index, true);
      },
      buildOrUpdateElements: function () {
        var me = this;
        var dataset = me.getDataset();
        var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate
        // real-time charts), we need to monitor these data modifications and synchronize
        // the internal meta data accordingly.

        if (me._data !== data) {
          if (me._data) {
            // This case happens when the user replaced the data array instance.
            unlistenArrayEvents(me._data, me);
          }

          if (data && Object.isExtensible(data)) {
            listenArrayEvents(data, me);
          }

          me._data = data;
        } // Re-sync meta data in case the user replaced the data array or if we missed
        // any updates and so make sure that we handle number of datapoints changing.


        me.resyncElements();
      },
      update: helpers$1.noop,
      transition: function (easingValue) {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        for (; i < ilen; ++i) {
          elements[i].transition(easingValue);
        }

        if (meta.dataset) {
          meta.dataset.transition(easingValue);
        }
      },
      draw: function () {
        var meta = this.getMeta();
        var elements = meta.data || [];
        var ilen = elements.length;
        var i = 0;

        if (meta.dataset) {
          meta.dataset.draw();
        }

        for (; i < ilen; ++i) {
          elements[i].draw();
        }
      },
      removeHoverStyle: function (element) {
        helpers$1.merge(element._model, element.$previousStyle || {});
        delete element.$previousStyle;
      },
      setHoverStyle: function (element) {
        var dataset = this.chart.data.datasets[element._datasetIndex];
        var index = element._index;
        var custom = element.custom || {};
        var model = element._model;
        var getHoverColor = helpers$1.getHoverColor;
        element.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
        model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
        model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
      },

      /**
       * @private
       */
      resyncElements: function () {
        var me = this;
        var meta = me.getMeta();
        var data = me.getDataset().data;
        var numMeta = meta.data.length;
        var numData = data.length;

        if (numData < numMeta) {
          meta.data.splice(numData, numMeta - numData);
        } else if (numData > numMeta) {
          me.insertElements(numMeta, numData - numMeta);
        }
      },

      /**
       * @private
       */
      insertElements: function (start, count) {
        for (var i = 0; i < count; ++i) {
          this.addElementAndReset(start + i);
        }
      },

      /**
       * @private
       */
      onDataPush: function () {
        var count = arguments.length;
        this.insertElements(this.getDataset().data.length - count, count);
      },

      /**
       * @private
       */
      onDataPop: function () {
        this.getMeta().data.pop();
      },

      /**
       * @private
       */
      onDataShift: function () {
        this.getMeta().data.shift();
      },

      /**
       * @private
       */
      onDataSplice: function (start, count) {
        this.getMeta().data.splice(start, count);
        this.insertElements(start, arguments.length - 2);
      },

      /**
       * @private
       */
      onDataUnshift: function () {
        this.insertElements(0, arguments.length);
      }
    });
    DatasetController.extend = helpers$1.inherits;
    var core_datasetController = DatasetController;

    core_defaults._set('global', {
      elements: {
        arc: {
          backgroundColor: core_defaults.global.defaultColor,
          borderColor: '#fff',
          borderWidth: 2,
          borderAlign: 'center'
        }
      }
    });

    var element_arc = core_element.extend({
      inLabelRange: function (mouseX) {
        var vm = this._view;

        if (vm) {
          return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
        }

        return false;
      },
      inRange: function (chartX, chartY) {
        var vm = this._view;

        if (vm) {
          var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {
            x: chartX,
            y: chartY
          });
          var angle = pointRelativePosition.angle;
          var distance = pointRelativePosition.distance; // Sanitise angle range

          var startAngle = vm.startAngle;
          var endAngle = vm.endAngle;

          while (endAngle < startAngle) {
            endAngle += 2.0 * Math.PI;
          }

          while (angle > endAngle) {
            angle -= 2.0 * Math.PI;
          }

          while (angle < startAngle) {
            angle += 2.0 * Math.PI;
          } // Check if within the range of the open/close angle


          var betweenAngles = angle >= startAngle && angle <= endAngle;
          var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
          return betweenAngles && withinRadius;
        }

        return false;
      },
      getCenterPoint: function () {
        var vm = this._view;
        var halfAngle = (vm.startAngle + vm.endAngle) / 2;
        var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
        return {
          x: vm.x + Math.cos(halfAngle) * halfRadius,
          y: vm.y + Math.sin(halfAngle) * halfRadius
        };
      },
      getArea: function () {
        var vm = this._view;
        return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
      },
      tooltipPosition: function () {
        var vm = this._view;
        var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
        var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
        return {
          x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
          y: vm.y + Math.sin(centreAngle) * rangeFromCentre
        };
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var sA = vm.startAngle;
        var eA = vm.endAngle;
        var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;
        var angleMargin;
        ctx.save();
        ctx.beginPath();
        ctx.arc(vm.x, vm.y, Math.max(vm.outerRadius - pixelMargin, 0), sA, eA);
        ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
        ctx.closePath();
        ctx.fillStyle = vm.backgroundColor;
        ctx.fill();

        if (vm.borderWidth) {
          if (vm.borderAlign === 'inner') {
            // Draw an inner border by cliping the arc and drawing a double-width border
            // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
            ctx.beginPath();
            angleMargin = pixelMargin / vm.outerRadius;
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA - angleMargin, eA + angleMargin);

            if (vm.innerRadius > pixelMargin) {
              angleMargin = pixelMargin / vm.innerRadius;
              ctx.arc(vm.x, vm.y, vm.innerRadius - pixelMargin, eA + angleMargin, sA - angleMargin, true);
            } else {
              ctx.arc(vm.x, vm.y, pixelMargin, eA + Math.PI / 2, sA - Math.PI / 2);
            }

            ctx.closePath();
            ctx.clip();
            ctx.beginPath();
            ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
            ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
            ctx.closePath();
            ctx.lineWidth = vm.borderWidth * 2;
            ctx.lineJoin = 'round';
          } else {
            ctx.lineWidth = vm.borderWidth;
            ctx.lineJoin = 'bevel';
          }

          ctx.strokeStyle = vm.borderColor;
          ctx.stroke();
        }

        ctx.restore();
      }
    });
    var valueOrDefault$1 = helpers$1.valueOrDefault;
    var defaultColor = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        line: {
          tension: 0.4,
          backgroundColor: defaultColor,
          borderWidth: 3,
          borderColor: defaultColor,
          borderCapStyle: 'butt',
          borderDash: [],
          borderDashOffset: 0.0,
          borderJoinStyle: 'miter',
          capBezierPoints: true,
          fill: true // do we fill in the area between the line and its base axis

        }
      }
    });

    var element_line = core_element.extend({
      draw: function () {
        var me = this;
        var vm = me._view;
        var ctx = me._chart.ctx;
        var spanGaps = vm.spanGaps;

        var points = me._children.slice(); // clone array


        var globalDefaults = core_defaults.global;
        var globalOptionLineElements = globalDefaults.elements.line;
        var lastDrawnIndex = -1;
        var index, current, previous, currentVM; // If we are looping, adding the first point again

        if (me._loop && points.length) {
          points.push(points[0]);
        }

        ctx.save(); // Stroke Line Options

        ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash

        if (ctx.setLineDash) {
          ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
        }

        ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
        ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
        ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
        ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line

        ctx.beginPath();
        lastDrawnIndex = -1;

        for (index = 0; index < points.length; ++index) {
          current = points[index];
          previous = helpers$1.previousItem(points, index);
          currentVM = current._view; // First point moves to it's starting position no matter what

          if (index === 0) {
            if (!currentVM.skip) {
              ctx.moveTo(currentVM.x, currentVM.y);
              lastDrawnIndex = index;
            }
          } else {
            previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];

            if (!currentVM.skip) {
              if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
                // There was a gap and this is the first point after the gap
                ctx.moveTo(currentVM.x, currentVM.y);
              } else {
                // Line to next point
                helpers$1.canvas.lineTo(ctx, previous._view, current._view);
              }

              lastDrawnIndex = index;
            }
          }
        }

        ctx.stroke();
        ctx.restore();
      }
    });
    var valueOrDefault$2 = helpers$1.valueOrDefault;
    var defaultColor$1 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        point: {
          radius: 3,
          pointStyle: 'circle',
          backgroundColor: defaultColor$1,
          borderColor: defaultColor$1,
          borderWidth: 1,
          // Hover
          hitRadius: 1,
          hoverRadius: 4,
          hoverBorderWidth: 1
        }
      }
    });

    function xRange(mouseX) {
      var vm = this._view;
      return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
    }

    function yRange(mouseY) {
      var vm = this._view;
      return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
    }

    var element_point = core_element.extend({
      inRange: function (mouseX, mouseY) {
        var vm = this._view;
        return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
      },
      inLabelRange: xRange,
      inXRange: xRange,
      inYRange: yRange,
      getCenterPoint: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      },
      getArea: function () {
        return Math.PI * Math.pow(this._view.radius, 2);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y,
          padding: vm.radius + vm.borderWidth
        };
      },
      draw: function (chartArea) {
        var vm = this._view;
        var ctx = this._chart.ctx;
        var pointStyle = vm.pointStyle;
        var rotation = vm.rotation;
        var radius = vm.radius;
        var x = vm.x;
        var y = vm.y;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow

        if (vm.skip) {
          return;
        } // Clipping for Points.


        if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
          ctx.strokeStyle = vm.borderColor || defaultColor;
          ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
          ctx.fillStyle = vm.backgroundColor || defaultColor;
          helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
        }
      }
    });
    var defaultColor$2 = core_defaults.global.defaultColor;

    core_defaults._set('global', {
      elements: {
        rectangle: {
          backgroundColor: defaultColor$2,
          borderColor: defaultColor$2,
          borderSkipped: 'bottom',
          borderWidth: 0
        }
      }
    });

    function isVertical(vm) {
      return vm && vm.width !== undefined;
    }
    /**
     * Helper function to get the bounds of the bar regardless of the orientation
     * @param bar {Chart.Element.Rectangle} the bar
     * @return {Bounds} bounds of the bar
     * @private
     */


    function getBarBounds(vm) {
      var x1, x2, y1, y2, half;

      if (isVertical(vm)) {
        half = vm.width / 2;
        x1 = vm.x - half;
        x2 = vm.x + half;
        y1 = Math.min(vm.y, vm.base);
        y2 = Math.max(vm.y, vm.base);
      } else {
        half = vm.height / 2;
        x1 = Math.min(vm.x, vm.base);
        x2 = Math.max(vm.x, vm.base);
        y1 = vm.y - half;
        y2 = vm.y + half;
      }

      return {
        left: x1,
        top: y1,
        right: x2,
        bottom: y2
      };
    }

    function swap(orig, v1, v2) {
      return orig === v1 ? v2 : orig === v2 ? v1 : orig;
    }

    function parseBorderSkipped(vm) {
      var edge = vm.borderSkipped;
      var res = {};

      if (!edge) {
        return res;
      }

      if (vm.horizontal) {
        if (vm.base > vm.x) {
          edge = swap(edge, 'left', 'right');
        }
      } else if (vm.base < vm.y) {
        edge = swap(edge, 'bottom', 'top');
      }

      res[edge] = true;
      return res;
    }

    function parseBorderWidth(vm, maxW, maxH) {
      var value = vm.borderWidth;
      var skip = parseBorderSkipped(vm);
      var t, r, b, l;

      if (helpers$1.isObject(value)) {
        t = +value.top || 0;
        r = +value.right || 0;
        b = +value.bottom || 0;
        l = +value.left || 0;
      } else {
        t = r = b = l = +value || 0;
      }

      return {
        t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,
        r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,
        b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
        l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l
      };
    }

    function boundingRects(vm) {
      var bounds = getBarBounds(vm);
      var width = bounds.right - bounds.left;
      var height = bounds.bottom - bounds.top;
      var border = parseBorderWidth(vm, width / 2, height / 2);
      return {
        outer: {
          x: bounds.left,
          y: bounds.top,
          w: width,
          h: height
        },
        inner: {
          x: bounds.left + border.l,
          y: bounds.top + border.t,
          w: width - border.l - border.r,
          h: height - border.t - border.b
        }
      };
    }

    function inRange(vm, x, y) {
      var skipX = x === null;
      var skipY = y === null;
      var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
      return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
    }

    var element_rectangle = core_element.extend({
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var rects = boundingRects(vm);
        var outer = rects.outer;
        var inner = rects.inner;
        ctx.fillStyle = vm.backgroundColor;
        ctx.fillRect(outer.x, outer.y, outer.w, outer.h);

        if (outer.w === inner.w && outer.h === inner.h) {
          return;
        }

        ctx.save();
        ctx.beginPath();
        ctx.rect(outer.x, outer.y, outer.w, outer.h);
        ctx.clip();
        ctx.fillStyle = vm.borderColor;
        ctx.rect(inner.x, inner.y, inner.w, inner.h);
        ctx.fill('evenodd');
        ctx.restore();
      },
      height: function () {
        var vm = this._view;
        return vm.base - vm.y;
      },
      inRange: function (mouseX, mouseY) {
        return inRange(this._view, mouseX, mouseY);
      },
      inLabelRange: function (mouseX, mouseY) {
        var vm = this._view;
        return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
      },
      inXRange: function (mouseX) {
        return inRange(this._view, mouseX, null);
      },
      inYRange: function (mouseY) {
        return inRange(this._view, null, mouseY);
      },
      getCenterPoint: function () {
        var vm = this._view;
        var x, y;

        if (isVertical(vm)) {
          x = vm.x;
          y = (vm.y + vm.base) / 2;
        } else {
          x = (vm.x + vm.base) / 2;
          y = vm.y;
        }

        return {
          x: x,
          y: y
        };
      },
      getArea: function () {
        var vm = this._view;
        return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
      },
      tooltipPosition: function () {
        var vm = this._view;
        return {
          x: vm.x,
          y: vm.y
        };
      }
    });
    var elements = {};
    var Arc = element_arc;
    var Line = element_line;
    var Point = element_point;
    var Rectangle = element_rectangle;
    elements.Arc = Arc;
    elements.Line = Line;
    elements.Point = Point;
    elements.Rectangle = Rectangle;
    var resolve$1 = helpers$1.options.resolve;

    core_defaults._set('bar', {
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }],
        yAxes: [{
          type: 'linear'
        }]
      }
    });
    /**
     * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
     * @private
     */


    function computeMinSampleSize(scale, pixels) {
      var min = scale.isHorizontal() ? scale.width : scale.height;
      var ticks = scale.getTicks();
      var prev, curr, i, ilen;

      for (i = 1, ilen = pixels.length; i < ilen; ++i) {
        min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
      }

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        curr = scale.getPixelForTick(i);
        min = i > 0 ? Math.min(min, curr - prev) : min;
        prev = curr;
      }

      return min;
    }
    /**
     * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
     * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
     * mode currently always generates bars equally sized (until we introduce scriptable options?).
     * @private
     */


    function computeFitCategoryTraits(index, ruler, options) {
      var thickness = options.barThickness;
      var count = ruler.stackCount;
      var curr = ruler.pixels[index];
      var size, ratio;

      if (helpers$1.isNullOrUndef(thickness)) {
        size = ruler.min * options.categoryPercentage;
        ratio = options.barPercentage;
      } else {
        // When bar thickness is enforced, category and bar percentages are ignored.
        // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
        // and deprecate barPercentage since this value is ignored when thickness is absolute.
        size = thickness * count;
        ratio = 1;
      }

      return {
        chunk: size / count,
        ratio: ratio,
        start: curr - size / 2
      };
    }
    /**
     * Computes an "optimal" category that globally arranges bars side by side (no gap when
     * percentage options are 1), based on the previous and following categories. This mode
     * generates bars with different widths when data are not evenly spaced.
     * @private
     */


    function computeFlexCategoryTraits(index, ruler, options) {
      var pixels = ruler.pixels;
      var curr = pixels[index];
      var prev = index > 0 ? pixels[index - 1] : null;
      var next = index < pixels.length - 1 ? pixels[index + 1] : null;
      var percent = options.categoryPercentage;
      var start, size;

      if (prev === null) {
        // first data: its size is double based on the next point or,
        // if it's also the last data, we use the scale size.
        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
      }

      if (next === null) {
        // last data: its size is also double based on the previous point.
        next = curr + curr - prev;
      }

      start = curr - (curr - Math.min(prev, next)) / 2 * percent;
      size = Math.abs(next - prev) / 2 * percent;
      return {
        chunk: size / ruler.stackCount,
        ratio: options.barPercentage,
        start: start
      };
    }

    var controller_bar = core_datasetController.extend({
      dataElementType: elements.Rectangle,
      initialize: function () {
        var me = this;
        var meta;
        core_datasetController.prototype.initialize.apply(me, arguments);
        meta = me.getMeta();
        meta.stack = me.getDataset().stack;
        meta.bar = true;
      },
      update: function (reset) {
        var me = this;
        var rects = me.getMeta().data;
        var i, ilen;
        me._ruler = me.getRuler();

        for (i = 0, ilen = rects.length; i < ilen; ++i) {
          me.updateElement(rects[i], i, reset);
        }
      },
      updateElement: function (rectangle, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var dataset = me.getDataset();

        var options = me._resolveElementOptions(rectangle, index);

        rectangle._xScale = me.getScaleForId(meta.xAxisID);
        rectangle._yScale = me.getScaleForId(meta.yAxisID);
        rectangle._datasetIndex = me.index;
        rectangle._index = index;
        rectangle._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderSkipped: options.borderSkipped,
          borderWidth: options.borderWidth,
          datasetLabel: dataset.label,
          label: me.chart.data.labels[index]
        };

        me._updateElementGeometry(rectangle, index, reset);

        rectangle.pivot();
      },

      /**
       * @private
       */
      _updateElementGeometry: function (rectangle, index, reset) {
        var me = this;
        var model = rectangle._model;

        var vscale = me._getValueScale();

        var base = vscale.getBasePixel();
        var horizontal = vscale.isHorizontal();
        var ruler = me._ruler || me.getRuler();
        var vpixels = me.calculateBarValuePixels(me.index, index);
        var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
        model.horizontal = horizontal;
        model.base = reset ? base : vpixels.base;
        model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
        model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
        model.height = horizontal ? ipixels.size : undefined;
        model.width = horizontal ? undefined : ipixels.size;
      },

      /**
       * Returns the stacks based on groups and bar visibility.
       * @param {number} [last] - The dataset index
       * @returns {string[]} The list of stack IDs
       * @private
       */
      _getStacks: function (last) {
        var me = this;
        var chart = me.chart;

        var scale = me._getIndexScale();

        var stacked = scale.options.stacked;
        var ilen = last === undefined ? chart.data.datasets.length : last + 1;
        var stacks = [];
        var i, meta;

        for (i = 0; i < ilen; ++i) {
          meta = chart.getDatasetMeta(i);

          if (meta.bar && chart.isDatasetVisible(i) && (stacked === false || stacked === true && stacks.indexOf(meta.stack) === -1 || stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1))) {
            stacks.push(meta.stack);
          }
        }

        return stacks;
      },

      /**
       * Returns the effective number of stacks based on groups and bar visibility.
       * @private
       */
      getStackCount: function () {
        return this._getStacks().length;
      },

      /**
       * Returns the stack index for the given dataset based on groups and bar visibility.
       * @param {number} [datasetIndex] - The dataset index
       * @param {string} [name] - The stack name to find
       * @returns {number} The stack index
       * @private
       */
      getStackIndex: function (datasetIndex, name) {
        var stacks = this._getStacks(datasetIndex);

        var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present

        return index === -1 ? stacks.length - 1 : index;
      },

      /**
       * @private
       */
      getRuler: function () {
        var me = this;

        var scale = me._getIndexScale();

        var stackCount = me.getStackCount();
        var datasetIndex = me.index;
        var isHorizontal = scale.isHorizontal();
        var start = isHorizontal ? scale.left : scale.top;
        var end = start + (isHorizontal ? scale.width : scale.height);
        var pixels = [];
        var i, ilen, min;

        for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
          pixels.push(scale.getPixelForValue(null, i, datasetIndex));
        }

        min = helpers$1.isNullOrUndef(scale.options.barThickness) ? computeMinSampleSize(scale, pixels) : -1;
        return {
          min: min,
          pixels: pixels,
          start: start,
          end: end,
          stackCount: stackCount,
          scale: scale
        };
      },

      /**
       * Note: pixel values are not clamped to the scale area.
       * @private
       */
      calculateBarValuePixels: function (datasetIndex, index) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();

        var scale = me._getValueScale();

        var isHorizontal = scale.isHorizontal();
        var datasets = chart.data.datasets;
        var value = +scale.getRightValue(datasets[datasetIndex].data[index]);
        var minBarLength = scale.options.minBarLength;
        var stacked = scale.options.stacked;
        var stack = meta.stack;
        var start = 0;
        var i, imeta, ivalue, base, head, size;

        if (stacked || stacked === undefined && stack !== undefined) {
          for (i = 0; i < datasetIndex; ++i) {
            imeta = chart.getDatasetMeta(i);

            if (imeta.bar && imeta.stack === stack && imeta.controller._getValueScaleId() === scale.id && chart.isDatasetVisible(i)) {
              ivalue = +scale.getRightValue(datasets[i].data[index]);

              if (value < 0 && ivalue < 0 || value >= 0 && ivalue > 0) {
                start += ivalue;
              }
            }
          }
        }

        base = scale.getPixelForValue(start);
        head = scale.getPixelForValue(start + value);
        size = head - base;

        if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
          size = minBarLength;

          if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {
            head = base - minBarLength;
          } else {
            head = base + minBarLength;
          }
        }

        return {
          size: size,
          base: base,
          head: head,
          center: head + size / 2
        };
      },

      /**
       * @private
       */
      calculateBarIndexPixels: function (datasetIndex, index, ruler) {
        var me = this;
        var options = ruler.scale.options;
        var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
        var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
        var center = range.start + range.chunk * stackIndex + range.chunk / 2;
        var size = Math.min(helpers$1.valueOrDefault(options.maxBarThickness, Infinity), range.chunk * range.ratio);
        return {
          base: center - size / 2,
          head: center + size / 2,
          center: center,
          size: size
        };
      },
      draw: function () {
        var me = this;
        var chart = me.chart;

        var scale = me._getValueScale();

        var rects = me.getMeta().data;
        var dataset = me.getDataset();
        var ilen = rects.length;
        var i = 0;
        helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);

        for (; i < ilen; ++i) {
          if (!isNaN(scale.getRightValue(dataset.data[i]))) {
            rects[i].draw();
          }
        }

        helpers$1.canvas.unclipArea(chart.ctx);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (rectangle, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = rectangle.custom || {};
        var options = chart.options.elements.rectangle;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$1([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      }
    });
    var valueOrDefault$3 = helpers$1.valueOrDefault;
    var resolve$2 = helpers$1.options.resolve;

    core_defaults._set('bubble', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          // bubble should probably use a linear scale by default
          position: 'bottom',
          id: 'x-axis-0' // need an ID so datasets can reference the scale

        }],
        yAxes: [{
          type: 'linear',
          position: 'left',
          id: 'y-axis-0'
        }]
      },
      tooltips: {
        callbacks: {
          title: function () {
            // Title doesn't make sense for scatter since we format the data as a point
            return '';
          },
          label: function (item, data) {
            var datasetLabel = data.datasets[item.datasetIndex].label || '';
            var dataPoint = data.datasets[item.datasetIndex].data[item.index];
            return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
          }
        }
      }
    });

    var controller_bubble = core_datasetController.extend({
      /**
       * @protected
       */
      dataElementType: elements.Point,

      /**
       * @protected
       */
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var points = meta.data; // Update Points

        helpers$1.each(points, function (point, index) {
          me.updateElement(point, index, reset);
        });
      },

      /**
       * @protected
       */
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var xScale = me.getScaleForId(meta.xAxisID);
        var yScale = me.getScaleForId(meta.yAxisID);

        var options = me._resolveElementOptions(point, index);

        var data = me.getDataset().data[index];
        var dsIndex = me.index;
        var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
        var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = dsIndex;
        point._index = index;
        point._model = {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          hitRadius: options.hitRadius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          radius: reset ? 0 : options.radius,
          skip: custom.skip || isNaN(x) || isNaN(y),
          x: x,
          y: y
        };
        point.pivot();
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$3(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$3(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$3(options.hoverBorderWidth, options.borderWidth);
        model.radius = options.radius + options.hoverRadius;
      },

      /**
       * @private
       */
      _resolveElementOptions: function (point, index) {
        var me = this;
        var chart = me.chart;
        var datasets = chart.data.datasets;
        var dataset = datasets[me.index];
        var custom = point.custom || {};
        var options = chart.options.elements.point;
        var data = dataset.data[index];
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$2([custom[key], dataset[key], options[key]], context, index);
        } // Custom radius resolution


        values.radius = resolve$2([custom.radius, data ? data.r : undefined, dataset.radius, options.radius], context, index);
        return values;
      }
    });
    var resolve$3 = helpers$1.options.resolve;
    var valueOrDefault$4 = helpers$1.valueOrDefault;

    core_defaults._set('doughnut', {
      animation: {
        // Boolean - Whether we animate the rotation of the Doughnut
        animateRotate: true,
        // Boolean - Whether we animate scaling the Doughnut from the centre
        animateScale: false
      },
      hover: {
        mode: 'single'
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc && arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$3([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$3([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$3([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i); // toggle visibility of index if exists

            if (meta.data[index]) {
              meta.data[index].hidden = !meta.data[index].hidden;
            }
          }

          chart.update();
        }
      },
      // The percentage of the chart that we cut out of the middle.
      cutoutPercentage: 50,
      // The rotation of the chart, where the first data arc begins.
      rotation: Math.PI * -0.5,
      // The total circumference of the chart.
      circumference: Math.PI * 2.0,
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (tooltipItem, data) {
            var dataLabel = data.labels[tooltipItem.index];
            var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

            if (helpers$1.isArray(dataLabel)) {
              // show value on first line of multiline label
              // need to clone because we are changing the value
              dataLabel = dataLabel.slice();
              dataLabel[0] += value;
            } else {
              dataLabel += value;
            }

            return dataLabel;
          }
        }
      }
    });

    var controller_doughnut = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
      getRingIndex: function (datasetIndex) {
        var ringIndex = 0;

        for (var j = 0; j < datasetIndex; ++j) {
          if (this.chart.isDatasetVisible(j)) {
            ++ringIndex;
          }
        }

        return ringIndex;
      },
      update: function (reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var availableWidth = chartArea.right - chartArea.left;
        var availableHeight = chartArea.bottom - chartArea.top;
        var minSize = Math.min(availableWidth, availableHeight);
        var offset = {
          x: 0,
          y: 0
        };
        var meta = me.getMeta();
        var arcs = meta.data;
        var cutoutPercentage = opts.cutoutPercentage;
        var circumference = opts.circumference;

        var chartWeight = me._getRingWeight(me.index);

        var i, ilen; // If the chart's circumference isn't a full circle, calculate minSize as a ratio of the width/height of the arc

        if (circumference < Math.PI * 2.0) {
          var startAngle = opts.rotation % (Math.PI * 2.0);
          startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
          var endAngle = startAngle + circumference;
          var start = {
            x: Math.cos(startAngle),
            y: Math.sin(startAngle)
          };
          var end = {
            x: Math.cos(endAngle),
            y: Math.sin(endAngle)
          };
          var contains0 = startAngle <= 0 && endAngle >= 0 || startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle;
          var contains90 = startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle;
          var contains180 = startAngle <= -Math.PI && -Math.PI <= endAngle || startAngle <= Math.PI && Math.PI <= endAngle;
          var contains270 = startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle || startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle;
          var cutout = cutoutPercentage / 100.0;
          var min = {
            x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)),
            y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))
          };
          var max = {
            x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)),
            y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))
          };
          var size = {
            width: (max.x - min.x) * 0.5,
            height: (max.y - min.y) * 0.5
          };
          minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
          offset = {
            x: (max.x + min.x) * -0.5,
            y: (max.y + min.y) * -0.5
          };
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
        }

        chart.borderWidth = me.getMaxBorderWidth();
        chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
        chart.innerRadius = Math.max(cutoutPercentage ? chart.outerRadius / 100 * cutoutPercentage : 0, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
        chart.offsetX = offset.x * chart.outerRadius;
        chart.offsetY = offset.y * chart.outerRadius;
        meta.total = me.calculateTotal();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
        me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          me.updateElement(arcs[i], i, reset);
        }
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var animationOpts = opts.animation;
        var centerX = (chartArea.left + chartArea.right) / 2;
        var centerY = (chartArea.top + chartArea.bottom) / 2;
        var startAngle = opts.rotation; // non reset case handled later

        var endAngle = opts.rotation; // non reset case handled later

        var dataset = me.getDataset();
        var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
        var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
        var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX + chart.offsetX,
            y: centerY + chart.offsetY,
            startAngle: startAngle,
            endAngle: endAngle,
            circumference: circumference,
            outerRadius: outerRadius,
            innerRadius: innerRadius,
            label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
          }
        });
        var model = arc._model; // Set correct angles if not resetting

        if (!reset || !animationOpts.animateRotate) {
          if (index === 0) {
            model.startAngle = opts.rotation;
          } else {
            model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
          }

          model.endAngle = model.startAngle + model.circumference;
        }

        arc.pivot();
      },
      calculateTotal: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var total = 0;
        var value;
        helpers$1.each(meta.data, function (element, index) {
          value = dataset.data[index];

          if (!isNaN(value) && !element.hidden) {
            total += Math.abs(value);
          }
        });
        /* if (total === 0) {
        	total = NaN;
        }*/

        return total;
      },
      calculateCircumference: function (value) {
        var total = this.getMeta().total;

        if (total > 0 && !isNaN(value)) {
          return Math.PI * 2.0 * (Math.abs(value) / total);
        }

        return 0;
      },
      // gets the max border or hover width to properly scale pie charts
      getMaxBorderWidth: function (arcs) {
        var me = this;
        var max = 0;
        var chart = me.chart;
        var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;

        if (!arcs) {
          // Find the outmost visible dataset
          for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
            if (chart.isDatasetVisible(i)) {
              meta = chart.getDatasetMeta(i);
              arcs = meta.data;

              if (i !== me.index) {
                controller = meta.controller;
              }

              break;
            }
          }
        }

        if (!arcs) {
          return 0;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arc = arcs[i];
          options = controller ? controller._resolveElementOptions(arc, i) : arc._options;

          if (options.borderAlign !== 'inner') {
            borderWidth = options.borderWidth;
            hoverWidth = options.hoverBorderWidth;
            max = borderWidth > max ? borderWidth : max;
            max = hoverWidth > max ? hoverWidth : max;
          }
        }

        return max;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$3([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
       * @private
       */
      _getRingWeightOffset: function (datasetIndex) {
        var ringWeightOffset = 0;

        for (var i = 0; i < datasetIndex; ++i) {
          if (this.chart.isDatasetVisible(i)) {
            ringWeightOffset += this._getRingWeight(i);
          }
        }

        return ringWeightOffset;
      },

      /**
       * @private
       */
      _getRingWeight: function (dataSetIndex) {
        return Math.max(valueOrDefault$4(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
      },

      /**
       * Returns the sum of all visibile data set weights.  This value can be 0.
       * @private
       */
      _getVisibleDatasetWeightTotal: function () {
        return this._getRingWeightOffset(this.chart.data.datasets.length);
      }
    });

    core_defaults._set('horizontalBar', {
      hover: {
        mode: 'index',
        axis: 'y'
      },
      scales: {
        xAxes: [{
          type: 'linear',
          position: 'bottom'
        }],
        yAxes: [{
          type: 'category',
          position: 'left',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          offset: true,
          gridLines: {
            offsetGridLines: true
          }
        }]
      },
      elements: {
        rectangle: {
          borderSkipped: 'left'
        }
      },
      tooltips: {
        mode: 'index',
        axis: 'y'
      }
    });

    var controller_horizontalBar = controller_bar.extend({
      /**
       * @private
       */
      _getValueScaleId: function () {
        return this.getMeta().xAxisID;
      },

      /**
       * @private
       */
      _getIndexScaleId: function () {
        return this.getMeta().yAxisID;
      }
    });
    var valueOrDefault$5 = helpers$1.valueOrDefault;
    var resolve$4 = helpers$1.options.resolve;
    var isPointInArea = helpers$1.canvas._isPointInArea;

    core_defaults._set('line', {
      showLines: true,
      spanGaps: false,
      hover: {
        mode: 'label'
      },
      scales: {
        xAxes: [{
          type: 'category',
          id: 'x-axis-0'
        }],
        yAxes: [{
          type: 'linear',
          id: 'y-axis-0'
        }]
      }
    });

    function lineEnabled(dataset, options) {
      return valueOrDefault$5(dataset.showLine, options.showLines);
    }

    var controller_line = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.getScaleForId(meta.yAxisID);
        var dataset = me.getDataset();
        var showLine = lineEnabled(dataset, me.chart.options);
        var i, ilen; // Update Line

        if (showLine) {
          // Compatibility: If the properties are defined with only the old name, use those values
          if (dataset.tension !== undefined && dataset.lineTension === undefined) {
            dataset.lineTension = dataset.tension;
          } // Utility


          line._scale = scale;
          line._datasetIndex = me.index; // Data

          line._children = points; // Model

          line._model = me._resolveLineOptions(line);
          line.pivot();
        } // Update Points


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        }

        if (showLine && line._model.tension !== 0) {
          me.updateBezierControlPoints();
        } // Now pivot the point for animation


        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var meta = me.getMeta();
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var datasetIndex = me.index;
        var value = dataset.data[index];
        var yScale = me.getScaleForId(meta.yAxisID);
        var xScale = me.getScaleForId(meta.xAxisID);
        var lineModel = meta.dataset._model;
        var x, y;

        var options = me._resolvePointOptions(point, index);

        x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
        y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility

        point._xScale = xScale;
        point._yScale = yScale;
        point._options = options;
        point._datasetIndex = datasetIndex;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$5(custom.tension, lineModel ? lineModel.tension : 0),
          steppedLine: lineModel ? lineModel.steppedLine : false,
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options;
        var elementOptions = options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill', 'cubicInterpolationMode'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$4([custom[key], dataset[key], elementOptions[key]]);
        } // The default behavior of lines is to break at null values, according
        // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
        // This option gives lines the ability to span gaps


        values.spanGaps = valueOrDefault$5(dataset.spanGaps, options.spanGaps);
        values.tension = valueOrDefault$5(dataset.lineTension, elementOptions.tension);
        values.steppedLine = resolve$4([custom.steppedLine, dataset.steppedLine, elementOptions.stepped]);
        return values;
      },
      calculatePointY: function (value, index, datasetIndex) {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var yScale = me.getScaleForId(meta.yAxisID);
        var sumPos = 0;
        var sumNeg = 0;
        var i, ds, dsMeta;

        if (yScale.options.stacked) {
          for (i = 0; i < datasetIndex; i++) {
            ds = chart.data.datasets[i];
            dsMeta = chart.getDatasetMeta(i);

            if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
              var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));

              if (stackedRightValue < 0) {
                sumNeg += stackedRightValue || 0;
              } else {
                sumPos += stackedRightValue || 0;
              }
            }
          }

          var rightValue = Number(yScale.getRightValue(value));

          if (rightValue < 0) {
            return yScale.getPixelForValue(sumNeg + rightValue);
          }

          return yScale.getPixelForValue(sumPos + rightValue);
        }

        return yScale.getPixelForValue(value);
      },
      updateBezierControlPoints: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var lineModel = meta.dataset._model;
        var area = chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

        if (lineModel.spanGaps) {
          points = points.filter(function (pt) {
            return !pt._model.skip;
          });
        }

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        if (lineModel.cubicInterpolationMode === 'monotone') {
          helpers$1.splineCurveMonotone(points);
        } else {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;
            controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
            model.controlPointPreviousX = controlPoints.previous.x;
            model.controlPointPreviousY = controlPoints.previous.y;
            model.controlPointNextX = controlPoints.next.x;
            model.controlPointNextY = controlPoints.next.y;
          }
        }

        if (chart.options.elements.line.capBezierPoints) {
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            model = points[i]._model;

            if (isPointInArea(model, area)) {
              if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
              }

              if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
              }
            }
          }
        }
      },
      draw: function () {
        var me = this;
        var chart = me.chart;
        var meta = me.getMeta();
        var points = meta.data || [];
        var area = chart.chartArea;
        var ilen = points.length;
        var halfBorderWidth;
        var i = 0;

        if (lineEnabled(me.getDataset(), chart.options)) {
          halfBorderWidth = (meta.dataset._model.borderWidth || 0) / 2;
          helpers$1.canvas.clipArea(chart.ctx, {
            left: area.left,
            right: area.right,
            top: area.top - halfBorderWidth,
            bottom: area.bottom + halfBorderWidth
          });
          meta.dataset.draw();
          helpers$1.canvas.unclipArea(chart.ctx);
        } // Draw the points


        for (; i < ilen; ++i) {
          points[i].draw(area);
        }
      },

      /**
       * @protected
       */
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$5(options.hoverRadius, options.radius);
      }
    });
    var resolve$5 = helpers$1.options.resolve;

    core_defaults._set('polarArea', {
      scale: {
        type: 'radialLinear',
        angleLines: {
          display: false
        },
        gridLines: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        ticks: {
          beginAtZero: true
        }
      },
      // Boolean - Whether to animate the rotation of the chart
      animation: {
        animateRotate: true,
        animateScale: true
      },
      startAngle: -0.5 * Math.PI,
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');
        var data = chart.data;
        var datasets = data.datasets;
        var labels = data.labels;

        if (datasets.length) {
          for (var i = 0; i < datasets[0].data.length; ++i) {
            text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');

            if (labels[i]) {
              text.push(labels[i]);
            }

            text.push('</li>');
          }
        }

        text.push('</ul>');
        return text.join('');
      },
      legend: {
        labels: {
          generateLabels: function (chart) {
            var data = chart.data;

            if (data.labels.length && data.datasets.length) {
              return data.labels.map(function (label, i) {
                var meta = chart.getDatasetMeta(0);
                var ds = data.datasets[0];
                var arc = meta.data[i];
                var custom = arc.custom || {};
                var arcOpts = chart.options.elements.arc;
                var fill = resolve$5([custom.backgroundColor, ds.backgroundColor, arcOpts.backgroundColor], undefined, i);
                var stroke = resolve$5([custom.borderColor, ds.borderColor, arcOpts.borderColor], undefined, i);
                var bw = resolve$5([custom.borderWidth, ds.borderWidth, arcOpts.borderWidth], undefined, i);
                return {
                  text: label,
                  fillStyle: fill,
                  strokeStyle: stroke,
                  lineWidth: bw,
                  hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                  // Extra data used for toggling the correct item
                  index: i
                };
              });
            }

            return [];
          }
        },
        onClick: function (e, legendItem) {
          var index = legendItem.index;
          var chart = this.chart;
          var i, ilen, meta;

          for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
            meta = chart.getDatasetMeta(i);
            meta.data[index].hidden = !meta.data[index].hidden;
          }

          chart.update();
        }
      },
      // Need to override these to give a nice default
      tooltips: {
        callbacks: {
          title: function () {
            return '';
          },
          label: function (item, data) {
            return data.labels[item.index] + ': ' + item.yLabel;
          }
        }
      }
    });

    var controller_polarArea = core_datasetController.extend({
      dataElementType: elements.Arc,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var dataset = me.getDataset();
        var meta = me.getMeta();
        var start = me.chart.options.startAngle || 0;
        var starts = me._starts = [];
        var angles = me._angles = [];
        var arcs = meta.data;
        var i, ilen, angle;

        me._updateRadius();

        meta.count = me.countVisibleElements();

        for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
          starts[i] = start;
          angle = me._computeAngle(i);
          angles[i] = angle;
          start += angle;
        }

        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
          arcs[i]._options = me._resolveElementOptions(arcs[i], i);
          me.updateElement(arcs[i], i, reset);
        }
      },

      /**
       * @private
       */
      _updateRadius: function () {
        var me = this;
        var chart = me.chart;
        var chartArea = chart.chartArea;
        var opts = chart.options;
        var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
        chart.outerRadius = Math.max(minSize / 2, 0);
        chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
        me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
        me.innerRadius = me.outerRadius - chart.radiusLength;
      },
      updateElement: function (arc, index, reset) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var opts = chart.options;
        var animationOpts = opts.animation;
        var scale = chart.scale;
        var labels = chart.data.labels;
        var centerX = scale.xCenter;
        var centerY = scale.yCenter; // var negHalfPI = -0.5 * Math.PI;

        var datasetStartAngle = opts.startAngle;
        var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var startAngle = me._starts[index];
        var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
        var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
        var options = arc._options || {};
        helpers$1.extend(arc, {
          // Utility
          _datasetIndex: me.index,
          _index: index,
          _scale: scale,
          // Desired view properties
          _model: {
            backgroundColor: options.backgroundColor,
            borderColor: options.borderColor,
            borderWidth: options.borderWidth,
            borderAlign: options.borderAlign,
            x: centerX,
            y: centerY,
            innerRadius: 0,
            outerRadius: reset ? resetRadius : distance,
            startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
            endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
            label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
          }
        });
        arc.pivot();
      },
      countVisibleElements: function () {
        var dataset = this.getDataset();
        var meta = this.getMeta();
        var count = 0;
        helpers$1.each(meta.data, function (element, index) {
          if (!isNaN(dataset.data[index]) && !element.hidden) {
            count++;
          }
        });
        return count;
      },

      /**
       * @protected
       */
      setHoverStyle: function (arc) {
        var model = arc._model;
        var options = arc._options;
        var getHoverColor = helpers$1.getHoverColor;
        var valueOrDefault = helpers$1.valueOrDefault;
        arc.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth
        };
        model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
      },

      /**
       * @private
       */
      _resolveElementOptions: function (arc, index) {
        var me = this;
        var chart = me.chart;
        var dataset = me.getDataset();
        var custom = arc.custom || {};
        var options = chart.options.elements.arc;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var keys = ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$5([custom[key], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _computeAngle: function (index) {
        var me = this;
        var count = this.getMeta().count;
        var dataset = me.getDataset();
        var meta = me.getMeta();

        if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
          return 0;
        } // Scriptable options


        var context = {
          chart: me.chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        return resolve$5([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);
      }
    });

    core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));

    core_defaults._set('pie', {
      cutoutPercentage: 0
    }); // Pie charts are Doughnut chart with different defaults


    var controller_pie = controller_doughnut;
    var valueOrDefault$6 = helpers$1.valueOrDefault;
    var resolve$6 = helpers$1.options.resolve;

    core_defaults._set('radar', {
      scale: {
        type: 'radialLinear'
      },
      elements: {
        line: {
          tension: 0 // no bezier in radar

        }
      }
    });

    var controller_radar = core_datasetController.extend({
      datasetElementType: elements.Line,
      dataElementType: elements.Point,
      linkScales: helpers$1.noop,
      update: function (reset) {
        var me = this;
        var meta = me.getMeta();
        var line = meta.dataset;
        var points = meta.data || [];
        var scale = me.chart.scale;
        var dataset = me.getDataset();
        var i, ilen; // Compatibility: If the properties are defined with only the old name, use those values

        if (dataset.tension !== undefined && dataset.lineTension === undefined) {
          dataset.lineTension = dataset.tension;
        } // Utility


        line._scale = scale;
        line._datasetIndex = me.index; // Data

        line._children = points;
        line._loop = true; // Model

        line._model = me._resolveLineOptions(line);
        line.pivot(); // Update Points

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          me.updateElement(points[i], i, reset);
        } // Update bezier control points


        me.updateBezierControlPoints(); // Now pivot the point for animation

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          points[i].pivot();
        }
      },
      updateElement: function (point, index, reset) {
        var me = this;
        var custom = point.custom || {};
        var dataset = me.getDataset();
        var scale = me.chart.scale;
        var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

        var options = me._resolvePointOptions(point, index);

        var lineModel = me.getMeta().dataset._model;

        var x = reset ? scale.xCenter : pointPosition.x;
        var y = reset ? scale.yCenter : pointPosition.y; // Utility

        point._scale = scale;
        point._options = options;
        point._datasetIndex = me.index;
        point._index = index; // Desired view properties

        point._model = {
          x: x,
          // value not used in dataset scale, but we want a consistent API between scales
          y: y,
          skip: custom.skip || isNaN(x) || isNaN(y),
          // Appearance
          radius: options.radius,
          pointStyle: options.pointStyle,
          rotation: options.rotation,
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
          // Tooltip
          hitRadius: options.hitRadius
        };
      },

      /**
       * @private
       */
      _resolvePointOptions: function (element, index) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.point;
        var values = {};
        var i, ilen, key; // Scriptable options

        var context = {
          chart: chart,
          dataIndex: index,
          dataset: dataset,
          datasetIndex: me.index
        };
        var ELEMENT_OPTIONS = {
          backgroundColor: 'pointBackgroundColor',
          borderColor: 'pointBorderColor',
          borderWidth: 'pointBorderWidth',
          hitRadius: 'pointHitRadius',
          hoverBackgroundColor: 'pointHoverBackgroundColor',
          hoverBorderColor: 'pointHoverBorderColor',
          hoverBorderWidth: 'pointHoverBorderWidth',
          hoverRadius: 'pointHoverRadius',
          pointStyle: 'pointStyle',
          radius: 'pointRadius',
          rotation: 'pointRotation'
        };
        var keys = Object.keys(ELEMENT_OPTIONS);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[ELEMENT_OPTIONS[key]], dataset[key], options[key]], context, index);
        }

        return values;
      },

      /**
       * @private
       */
      _resolveLineOptions: function (element) {
        var me = this;
        var chart = me.chart;
        var dataset = chart.data.datasets[me.index];
        var custom = element.custom || {};
        var options = chart.options.elements.line;
        var values = {};
        var i, ilen, key;
        var keys = ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill'];

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve$6([custom[key], dataset[key], options[key]]);
        }

        values.tension = valueOrDefault$6(dataset.lineTension, options.tension);
        return values;
      },
      updateBezierControlPoints: function () {
        var me = this;
        var meta = me.getMeta();
        var area = me.chart.chartArea;
        var points = meta.data || [];
        var i, ilen, model, controlPoints;

        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }

        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;
          controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph

          model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
          model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
          model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
          model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
        }
      },
      setHoverStyle: function (point) {
        var model = point._model;
        var options = point._options;
        var getHoverColor = helpers$1.getHoverColor;
        point.$previousStyle = {
          backgroundColor: model.backgroundColor,
          borderColor: model.borderColor,
          borderWidth: model.borderWidth,
          radius: model.radius
        };
        model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
        model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
        model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
        model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
      }
    });

    core_defaults._set('scatter', {
      hover: {
        mode: 'single'
      },
      scales: {
        xAxes: [{
          id: 'x-axis-1',
          // need an ID so datasets can reference the scale
          type: 'linear',
          // scatter should not use a category axis
          position: 'bottom'
        }],
        yAxes: [{
          id: 'y-axis-1',
          type: 'linear',
          position: 'left'
        }]
      },
      showLines: false,
      tooltips: {
        callbacks: {
          title: function () {
            return ''; // doesn't make sense for scatter since data are formatted as a point
          },
          label: function (item) {
            return '(' + item.xLabel + ', ' + item.yLabel + ')';
          }
        }
      }
    }); // Scatter charts use line controllers


    var controller_scatter = controller_line; // NOTE export a map in which the key represents the controller type, not
    // the class, and so must be CamelCase in order to be correctly retrieved
    // by the controller in core.controller.js (`controllers[meta.type]`).

    var controllers = {
      bar: controller_bar,
      bubble: controller_bubble,
      doughnut: controller_doughnut,
      horizontalBar: controller_horizontalBar,
      line: controller_line,
      polarArea: controller_polarArea,
      pie: controller_pie,
      radar: controller_radar,
      scatter: controller_scatter
    };
    /**
     * Helper function to get relative position for an event
     * @param {Event|IEvent} event - The event to get the position for
     * @param {Chart} chart - The chart
     * @returns {object} the event position
     */

    function getRelativePosition(e, chart) {
      if (e.native) {
        return {
          x: e.x,
          y: e.y
        };
      }

      return helpers$1.getRelativePosition(e, chart);
    }
    /**
     * Helper function to traverse all of the visible elements in the chart
     * @param {Chart} chart - the chart
     * @param {function} handler - the callback to execute for each visible item
     */


    function parseVisibleItems(chart, handler) {
      var datasets = chart.data.datasets;
      var meta, i, j, ilen, jlen;

      for (i = 0, ilen = datasets.length; i < ilen; ++i) {
        if (!chart.isDatasetVisible(i)) {
          continue;
        }

        meta = chart.getDatasetMeta(i);

        for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
          var element = meta.data[j];

          if (!element._view.skip) {
            handler(element);
          }
        }
      }
    }
    /**
     * Helper function to get the items that intersect the event position
     * @param {ChartElement[]} items - elements to filter
     * @param {object} position - the point to be nearest to
     * @return {ChartElement[]} the nearest items
     */


    function getIntersectItems(chart, position) {
      var elements = [];
      parseVisibleItems(chart, function (element) {
        if (element.inRange(position.x, position.y)) {
          elements.push(element);
        }
      });
      return elements;
    }
    /**
     * Helper function to get the items nearest to the event position considering all visible items in teh chart
     * @param {Chart} chart - the chart to look at elements from
     * @param {object} position - the point to be nearest to
     * @param {boolean} intersect - if true, only consider items that intersect the position
     * @param {function} distanceMetric - function to provide the distance between points
     * @return {ChartElement[]} the nearest items
     */


    function getNearestItems(chart, position, intersect, distanceMetric) {
      var minDistance = Number.POSITIVE_INFINITY;
      var nearestItems = [];
      parseVisibleItems(chart, function (element) {
        if (intersect && !element.inRange(position.x, position.y)) {
          return;
        }

        var center = element.getCenterPoint();
        var distance = distanceMetric(position, center);

        if (distance < minDistance) {
          nearestItems = [element];
          minDistance = distance;
        } else if (distance === minDistance) {
          // Can have multiple items at the same distance in which case we sort by size
          nearestItems.push(element);
        }
      });
      return nearestItems;
    }
    /**
     * Get a distance metric function for two points based on the
     * axis mode setting
     * @param {string} axis - the axis mode. x|y|xy
     */


    function getDistanceMetricForAxis(axis) {
      var useX = axis.indexOf('x') !== -1;
      var useY = axis.indexOf('y') !== -1;
      return function (pt1, pt2) {
        var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
        var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
    }

    function indexMode(chart, e, options) {
      var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour

      options.axis = options.axis || 'x';
      var distanceMetric = getDistanceMetricForAxis(options.axis);
      var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
      var elements = [];

      if (!items.length) {
        return [];
      }

      chart.data.datasets.forEach(function (dataset, datasetIndex) {
        if (chart.isDatasetVisible(datasetIndex)) {
          var meta = chart.getDatasetMeta(datasetIndex);
          var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)

          if (element && !element._view.skip) {
            elements.push(element);
          }
        }
      });
      return elements;
    }
    /**
     * @interface IInteractionOptions
     */

    /**
     * If true, only consider items that intersect the point
     * @name IInterfaceOptions#boolean
     * @type Boolean
     */

    /**
     * Contains interaction related functions
     * @namespace Chart.Interaction
     */


    var core_interaction = {
      // Helper function for different modes
      modes: {
        single: function (chart, e) {
          var position = getRelativePosition(e, chart);
          var elements = [];
          parseVisibleItems(chart, function (element) {
            if (element.inRange(position.x, position.y)) {
              elements.push(element);
              return elements;
            }
          });
          return elements.slice(0, 1);
        },

        /**
         * @function Chart.Interaction.modes.label
         * @deprecated since version 2.4.0
         * @todo remove at version 3
         * @private
         */
        label: indexMode,

        /**
         * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
         * @function Chart.Interaction.modes.index
         * @since v2.4.0
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        index: indexMode,

        /**
         * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
         * If the options.intersect is false, we find the nearest item and return the items in that dataset
         * @function Chart.Interaction.modes.dataset
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use during interaction
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        dataset: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

          if (items.length > 0) {
            items = chart.getDatasetMeta(items[0]._datasetIndex).data;
          }

          return items;
        },

        /**
         * @function Chart.Interaction.modes.x-axis
         * @deprecated since version 2.4.0. Use index mode and intersect == true
         * @todo remove at version 3
         * @private
         */
        'x-axis': function (chart, e) {
          return indexMode(chart, e, {
            intersect: false
          });
        },

        /**
         * Point mode returns all elements that hit test based on the event position
         * of the event
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        point: function (chart, e) {
          var position = getRelativePosition(e, chart);
          return getIntersectItems(chart, position);
        },

        /**
         * nearest mode returns the element closest to the point
         * @function Chart.Interaction.modes.intersect
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        nearest: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          options.axis = options.axis || 'xy';
          var distanceMetric = getDistanceMetricForAxis(options.axis);
          return getNearestItems(chart, position, options.intersect, distanceMetric);
        },

        /**
         * x mode returns the elements that hit-test at the current x coordinate
         * @function Chart.Interaction.modes.x
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        x: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inXRange(position.x)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        },

        /**
         * y mode returns the elements that hit-test at the current y coordinate
         * @function Chart.Interaction.modes.y
         * @param {Chart} chart - the chart we are returning items from
         * @param {Event} e - the event we are find things at
         * @param {IInteractionOptions} options - options to use
         * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
         */
        y: function (chart, e, options) {
          var position = getRelativePosition(e, chart);
          var items = [];
          var intersectsItem = false;
          parseVisibleItems(chart, function (element) {
            if (element.inYRange(position.y)) {
              items.push(element);
            }

            if (element.inRange(position.x, position.y)) {
              intersectsItem = true;
            }
          }); // If we want to trigger on an intersect and we don't have any items
          // that intersect the position, return nothing

          if (options.intersect && !intersectsItem) {
            items = [];
          }

          return items;
        }
      }
    };

    function filterByPosition(array, position) {
      return helpers$1.where(array, function (v) {
        return v.position === position;
      });
    }

    function sortByWeight(array, reverse) {
      array.forEach(function (v, i) {
        v._tmpIndex_ = i;
        return v;
      });
      array.sort(function (a, b) {
        var v0 = reverse ? b : a;
        var v1 = reverse ? a : b;
        return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;
      });
      array.forEach(function (v) {
        delete v._tmpIndex_;
      });
    }

    function findMaxPadding(boxes) {
      var top = 0;
      var left = 0;
      var bottom = 0;
      var right = 0;
      helpers$1.each(boxes, function (box) {
        if (box.getPadding) {
          var boxPadding = box.getPadding();
          top = Math.max(top, boxPadding.top);
          left = Math.max(left, boxPadding.left);
          bottom = Math.max(bottom, boxPadding.bottom);
          right = Math.max(right, boxPadding.right);
        }
      });
      return {
        top: top,
        left: left,
        bottom: bottom,
        right: right
      };
    }

    function addSizeByPosition(boxes, size) {
      helpers$1.each(boxes, function (box) {
        size[box.position] += box.isHorizontal() ? box.height : box.width;
      });
    }

    core_defaults._set('global', {
      layout: {
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      }
    });
    /**
     * @interface ILayoutItem
     * @prop {string} position - The position of the item in the chart layout. Possible values are
     * 'left', 'top', 'right', 'bottom', and 'chartArea'
     * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area
     * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
     * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
     * @prop {function} update - Takes two parameters: width and height. Returns size of item
     * @prop {function} getPadding -  Returns an object with padding on the edges
     * @prop {number} width - Width of item. Must be valid after update()
     * @prop {number} height - Height of item. Must be valid after update()
     * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update
     * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update
     * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update
     * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
     */
    // The layout service is very self explanatory.  It's responsible for the layout within a chart.
    // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
    // It is this service's responsibility of carrying out that layout.


    var core_layouts = {
      defaults: {},

      /**
       * Register a box to a chart.
       * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
       * @param {Chart} chart - the chart to use
       * @param {ILayoutItem} item - the item to add to be layed out
       */
      addBox: function (chart, item) {
        if (!chart.boxes) {
          chart.boxes = [];
        } // initialize item with default values


        item.fullWidth = item.fullWidth || false;
        item.position = item.position || 'top';
        item.weight = item.weight || 0;
        chart.boxes.push(item);
      },

      /**
       * Remove a layoutItem from a chart
       * @param {Chart} chart - the chart to remove the box from
       * @param {ILayoutItem} layoutItem - the item to remove from the layout
       */
      removeBox: function (chart, layoutItem) {
        var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;

        if (index !== -1) {
          chart.boxes.splice(index, 1);
        }
      },

      /**
       * Sets (or updates) options on the given `item`.
       * @param {Chart} chart - the chart in which the item lives (or will be added to)
       * @param {ILayoutItem} item - the item to configure with the given options
       * @param {object} options - the new item options.
       */
      configure: function (chart, item, options) {
        var props = ['fullWidth', 'position', 'weight'];
        var ilen = props.length;
        var i = 0;
        var prop;

        for (; i < ilen; ++i) {
          prop = props[i];

          if (options.hasOwnProperty(prop)) {
            item[prop] = options[prop];
          }
        }
      },

      /**
       * Fits boxes of the given chart into the given size by having each box measure itself
       * then running a fitting algorithm
       * @param {Chart} chart - the chart
       * @param {number} width - the width to fit into
       * @param {number} height - the height to fit into
       */
      update: function (chart, width, height) {
        if (!chart) {
          return;
        }

        var layoutOptions = chart.options.layout || {};
        var padding = helpers$1.options.toPadding(layoutOptions.padding);
        var leftPadding = padding.left;
        var rightPadding = padding.right;
        var topPadding = padding.top;
        var bottomPadding = padding.bottom;
        var leftBoxes = filterByPosition(chart.boxes, 'left');
        var rightBoxes = filterByPosition(chart.boxes, 'right');
        var topBoxes = filterByPosition(chart.boxes, 'top');
        var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
        var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea'); // Sort boxes by weight. A higher weight is further away from the chart area

        sortByWeight(leftBoxes, true);
        sortByWeight(rightBoxes, false);
        sortByWeight(topBoxes, true);
        sortByWeight(bottomBoxes, false);
        var verticalBoxes = leftBoxes.concat(rightBoxes);
        var horizontalBoxes = topBoxes.concat(bottomBoxes);
        var outerBoxes = verticalBoxes.concat(horizontalBoxes); // Essentially we now have any number of boxes on each of the 4 sides.
        // Our canvas looks like the following.
        // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
        // B1 is the bottom axis
        // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
        // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
        // an error will be thrown.
        //
        // |----------------------------------------------------|
        // |                  T1 (Full Width)                   |
        // |----------------------------------------------------|
        // |    |    |                 T2                  |    |
        // |    |----|-------------------------------------|----|
        // |    |    | C1 |                           | C2 |    |
        // |    |    |----|                           |----|    |
        // |    |    |                                     |    |
        // | L1 | L2 |           ChartArea (C0)            | R1 |
        // |    |    |                                     |    |
        // |    |    |----|                           |----|    |
        // |    |    | C3 |                           | C4 |    |
        // |    |----|-------------------------------------|----|
        // |    |    |                 B1                  |    |
        // |----------------------------------------------------|
        // |                  B2 (Full Width)                   |
        // |----------------------------------------------------|
        //
        // What we do to find the best sizing, we do the following
        // 1. Determine the minimum size of the chart area.
        // 2. Split the remaining width equally between each vertical axis
        // 3. Split the remaining height equally between each horizontal axis
        // 4. Give each layout the maximum size it can be. The layout will return it's minimum size
        // 5. Adjust the sizes of each axis based on it's minimum reported size.
        // 6. Refit each axis
        // 7. Position each axis in the final location
        // 8. Tell the chart the final location of the chart area
        // 9. Tell any axes that overlay the chart area the positions of the chart area
        // Step 1

        var chartWidth = width - leftPadding - rightPadding;
        var chartHeight = height - topPadding - bottomPadding;
        var chartAreaWidth = chartWidth / 2; // min 50%
        // Step 2

        var verticalBoxWidth = (width - chartAreaWidth) / verticalBoxes.length; // Step 3
        // TODO re-limit horizontal axis height (this limit has affected only padding calculation since PR 1837)
        // var horizontalBoxHeight = (height - chartAreaHeight) / horizontalBoxes.length;
        // Step 4

        var maxChartAreaWidth = chartWidth;
        var maxChartAreaHeight = chartHeight;
        var outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        var minBoxSizes = [];
        var maxPadding;

        function getMinimumBoxSize(box) {
          var minSize;
          var isHorizontal = box.isHorizontal();

          if (isHorizontal) {
            minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2);
            maxChartAreaHeight -= minSize.height;
          } else {
            minSize = box.update(verticalBoxWidth, maxChartAreaHeight);
            maxChartAreaWidth -= minSize.width;
          }

          minBoxSizes.push({
            horizontal: isHorizontal,
            width: minSize.width,
            box: box
          });
        }

        helpers$1.each(outerBoxes, getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)

        maxPadding = findMaxPadding(outerBoxes); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could
        // be if the axes are drawn at their minimum sizes.
        // Steps 5 & 6
        // Function to fit a box

        function fitBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minBox) {
            return minBox.box === box;
          });

          if (minBoxSize) {
            if (minBoxSize.horizontal) {
              var scaleMargin = {
                left: Math.max(outerBoxSizes.left, maxPadding.left),
                right: Math.max(outerBoxSizes.right, maxPadding.right),
                top: 0,
                bottom: 0
              }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends
              // on the margin. Sometimes they need to increase in size slightly

              box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
            } else {
              box.update(minBoxSize.width, maxChartAreaHeight);
            }
          }
        } // Update, and calculate the left and right margins for the horizontal boxes


        helpers$1.each(verticalBoxes, fitBox);
        addSizeByPosition(verticalBoxes, outerBoxSizes); // Set the Left and Right margins for the horizontal boxes

        helpers$1.each(horizontalBoxes, fitBox);
        addSizeByPosition(horizontalBoxes, outerBoxSizes);

        function finalFitVerticalBox(box) {
          var minBoxSize = helpers$1.findNextWhere(minBoxSizes, function (minSize) {
            return minSize.box === box;
          });
          var scaleMargin = {
            left: 0,
            right: 0,
            top: outerBoxSizes.top,
            bottom: outerBoxSizes.bottom
          };

          if (minBoxSize) {
            box.update(minBoxSize.width, maxChartAreaHeight, scaleMargin);
          }
        } // Let the left layout know the final margin


        helpers$1.each(verticalBoxes, finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)

        outerBoxSizes = {
          top: topPadding,
          left: leftPadding,
          bottom: bottomPadding,
          right: rightPadding
        };
        addSizeByPosition(outerBoxes, outerBoxSizes); // We may be adding some padding to account for rotated x axis labels

        var leftPaddingAddition = Math.max(maxPadding.left - outerBoxSizes.left, 0);
        outerBoxSizes.left += leftPaddingAddition;
        outerBoxSizes.right += Math.max(maxPadding.right - outerBoxSizes.right, 0);
        var topPaddingAddition = Math.max(maxPadding.top - outerBoxSizes.top, 0);
        outerBoxSizes.top += topPaddingAddition;
        outerBoxSizes.bottom += Math.max(maxPadding.bottom - outerBoxSizes.bottom, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation
        // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do
        // without calling `fit` again

        var newMaxChartAreaHeight = height - outerBoxSizes.top - outerBoxSizes.bottom;
        var newMaxChartAreaWidth = width - outerBoxSizes.left - outerBoxSizes.right;

        if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
          helpers$1.each(verticalBoxes, function (box) {
            box.height = newMaxChartAreaHeight;
          });
          helpers$1.each(horizontalBoxes, function (box) {
            if (!box.fullWidth) {
              box.width = newMaxChartAreaWidth;
            }
          });
          maxChartAreaHeight = newMaxChartAreaHeight;
          maxChartAreaWidth = newMaxChartAreaWidth;
        } // Step 7 - Position the boxes


        var left = leftPadding + leftPaddingAddition;
        var top = topPadding + topPaddingAddition;

        function placeBox(box) {
          if (box.isHorizontal()) {
            box.left = box.fullWidth ? leftPadding : outerBoxSizes.left;
            box.right = box.fullWidth ? width - rightPadding : outerBoxSizes.left + maxChartAreaWidth;
            box.top = top;
            box.bottom = top + box.height; // Move to next point

            top = box.bottom;
          } else {
            box.left = left;
            box.right = left + box.width;
            box.top = outerBoxSizes.top;
            box.bottom = outerBoxSizes.top + maxChartAreaHeight; // Move to next point

            left = box.right;
          }
        }

        helpers$1.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height

        left += maxChartAreaWidth;
        top += maxChartAreaHeight;
        helpers$1.each(rightBoxes, placeBox);
        helpers$1.each(bottomBoxes, placeBox); // Step 8

        chart.chartArea = {
          left: outerBoxSizes.left,
          top: outerBoxSizes.top,
          right: outerBoxSizes.left + maxChartAreaWidth,
          bottom: outerBoxSizes.top + maxChartAreaHeight
        }; // Step 9

        helpers$1.each(chartAreaBoxes, function (box) {
          box.left = chart.chartArea.left;
          box.top = chart.chartArea.top;
          box.right = chart.chartArea.right;
          box.bottom = chart.chartArea.bottom;
          box.update(maxChartAreaWidth, maxChartAreaHeight);
        });
      }
    };
    /**
     * Platform fallback implementation (minimal).
     * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
     */

    var platform_basic = {
      acquireContext: function (item) {
        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        }

        return item && item.getContext('2d') || null;
      }
    };
    var platform_dom = "/*\n * DOM element rendering detection\n * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index: -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth: 1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop: 0;\n}\n";
    var platform_dom$1 =
    /*#__PURE__*/
    Object.freeze({
      default: platform_dom
    });

    function getCjsExportFromNamespace(n) {
      return n && n.default || n;
    }

    var stylesheet = getCjsExportFromNamespace(platform_dom$1);
    var EXPANDO_KEY = '$chartjs';
    var CSS_PREFIX = 'chartjs-';
    var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';
    var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
    var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
    var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
    /**
     * DOM event types -> Chart.js event types.
     * Note: only events with different types are mapped.
     * @see https://developer.mozilla.org/en-US/docs/Web/Events
     */

    var EVENT_TYPES = {
      touchstart: 'mousedown',
      touchmove: 'mousemove',
      touchend: 'mouseup',
      pointerenter: 'mouseenter',
      pointerdown: 'mousedown',
      pointermove: 'mousemove',
      pointerup: 'mouseup',
      pointerleave: 'mouseout',
      pointerout: 'mouseout'
    };
    /**
     * The "used" size is the final value of a dimension property after all calculations have
     * been performed. This method uses the computed style of `element` but returns undefined
     * if the computed style is not expressed in pixels. That can happen in some cases where
     * `element` has a size relative to its parent and this last one is not yet displayed,
     * for example because of `display: none` on a parent node.
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
     * @returns {number} Size in pixels or undefined if unknown.
     */

    function readUsedSize(element, property) {
      var value = helpers$1.getStyle(element, property);
      var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? Number(matches[1]) : undefined;
    }
    /**
     * Initializes the canvas style and render size without modifying the canvas display size,
     * since responsiveness is handled by the controller.resize() method. The config is used
     * to determine the aspect ratio to apply in case no explicit height has been specified.
     */


    function initCanvas(canvas, config) {
      var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
      // returns null or '' if no explicit value has been set to the canvas attribute.

      var renderHeight = canvas.getAttribute('height');
      var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy

      canvas[EXPANDO_KEY] = {
        initial: {
          height: renderHeight,
          width: renderWidth,
          style: {
            display: style.display,
            height: style.height,
            width: style.width
          }
        }
      }; // Force canvas to display as block to avoid extra space caused by inline
      // elements, which would interfere with the responsive resize process.
      // https://github.com/chartjs/Chart.js/issues/2538

      style.display = style.display || 'block';

      if (renderWidth === null || renderWidth === '') {
        var displayWidth = readUsedSize(canvas, 'width');

        if (displayWidth !== undefined) {
          canvas.width = displayWidth;
        }
      }

      if (renderHeight === null || renderHeight === '') {
        if (canvas.style.height === '') {
          // If no explicit render height and style height, let's apply the aspect ratio,
          // which one can be specified by the user but also by charts as default option
          // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
          canvas.height = canvas.width / (config.options.aspectRatio || 2);
        } else {
          var displayHeight = readUsedSize(canvas, 'height');

          if (displayWidth !== undefined) {
            canvas.height = displayHeight;
          }
        }
      }

      return canvas;
    }
    /**
     * Detects support for options object argument in addEventListener.
     * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
     * @private
     */


    var supportsEventListenerOptions = function () {
      var supports = false;

      try {
        var options = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line getter-return
          get: function () {
            supports = true;
          }
        });
        window.addEventListener('e', null, options);
      } catch (e) {// continue regardless of error
      }

      return supports;
    }(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
    // https://github.com/chartjs/Chart.js/issues/4287


    var eventListenerOptions = supportsEventListenerOptions ? {
      passive: true
    } : false;

    function addListener(node, type, listener) {
      node.addEventListener(type, listener, eventListenerOptions);
    }

    function removeListener(node, type, listener) {
      node.removeEventListener(type, listener, eventListenerOptions);
    }

    function createEvent(type, chart, x, y, nativeEvent) {
      return {
        type: type,
        chart: chart,
        native: nativeEvent || null,
        x: x !== undefined ? x : null,
        y: y !== undefined ? y : null
      };
    }

    function fromNativeEvent(event, chart) {
      var type = EVENT_TYPES[event.type] || event.type;
      var pos = helpers$1.getRelativePosition(event, chart);
      return createEvent(type, chart, pos.x, pos.y, event);
    }

    function throttled(fn, thisArg) {
      var ticking = false;
      var args = [];
      return function () {
        args = Array.prototype.slice.call(arguments);
        thisArg = thisArg || this;

        if (!ticking) {
          ticking = true;
          helpers$1.requestAnimFrame.call(window, function () {
            ticking = false;
            fn.apply(thisArg, args);
          });
        }
      };
    }

    function createDiv(cls) {
      var el = document.createElement('div');
      el.className = cls || '';
      return el;
    } // Implementation based on https://github.com/marcj/css-element-queries


    function createResizer(handler) {
      var maxSize = 1000000; // NOTE(SB) Don't use innerHTML because it could be considered unsafe.
      // https://github.com/chartjs/Chart.js/issues/5902

      var resizer = createDiv(CSS_SIZE_MONITOR);
      var expand = createDiv(CSS_SIZE_MONITOR + '-expand');
      var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');
      expand.appendChild(createDiv());
      shrink.appendChild(createDiv());
      resizer.appendChild(expand);
      resizer.appendChild(shrink);

      resizer._reset = function () {
        expand.scrollLeft = maxSize;
        expand.scrollTop = maxSize;
        shrink.scrollLeft = maxSize;
        shrink.scrollTop = maxSize;
      };

      var onScroll = function () {
        resizer._reset();

        handler();
      };

      addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
      addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
      return resizer;
    } // https://davidwalsh.name/detect-node-insertion


    function watchForRender(node, handler) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

      var proxy = expando.renderProxy = function (e) {
        if (e.animationName === CSS_RENDER_ANIMATION) {
          handler();
        }
      };

      helpers$1.each(ANIMATION_START_EVENTS, function (type) {
        addListener(node, type, proxy);
      }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
      // is removed then added back immediately (same animation frame?). Accessing the
      // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
      // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
      // https://github.com/chartjs/Chart.js/issues/4737

      expando.reflow = !!node.offsetParent;
      node.classList.add(CSS_RENDER_MONITOR);
    }

    function unwatchForRender(node) {
      var expando = node[EXPANDO_KEY] || {};
      var proxy = expando.renderProxy;

      if (proxy) {
        helpers$1.each(ANIMATION_START_EVENTS, function (type) {
          removeListener(node, type, proxy);
        });
        delete expando.renderProxy;
      }

      node.classList.remove(CSS_RENDER_MONITOR);
    }

    function addResizeListener(node, listener, chart) {
      var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.

      var resizer = expando.resizer = createResizer(throttled(function () {
        if (expando.resizer) {
          var container = chart.options.maintainAspectRatio && node.parentNode;
          var w = container ? container.clientWidth : 0;
          listener(createEvent('resize', chart));

          if (container && container.clientWidth < w && chart.canvas) {
            // If the container size shrank during chart resize, let's assume
            // scrollbar appeared. So we resize again with the scrollbar visible -
            // effectively making chart smaller and the scrollbar hidden again.
            // Because we are inside `throttled`, and currently `ticking`, scroll
            // events are ignored during this whole 2 resize process.
            // If we assumed wrong and something else happened, we are resizing
            // twice in a frame (potential performance issue)
            listener(createEvent('resize', chart));
          }
        }
      })); // The resizer needs to be attached to the node parent, so we first need to be
      // sure that `node` is attached to the DOM before injecting the resizer element.

      watchForRender(node, function () {
        if (expando.resizer) {
          var container = node.parentNode;

          if (container && container !== resizer.parentNode) {
            container.insertBefore(resizer, container.firstChild);
          } // The container size might have changed, let's reset the resizer state.


          resizer._reset();
        }
      });
    }

    function removeResizeListener(node) {
      var expando = node[EXPANDO_KEY] || {};
      var resizer = expando.resizer;
      delete expando.resizer;
      unwatchForRender(node);

      if (resizer && resizer.parentNode) {
        resizer.parentNode.removeChild(resizer);
      }
    }

    function injectCSS(platform, css) {
      // https://stackoverflow.com/q/3922139
      var style = platform._style || document.createElement('style');

      if (!platform._style) {
        platform._style = style;
        css = '/* Chart.js */\n' + css;
        style.setAttribute('type', 'text/css');
        document.getElementsByTagName('head')[0].appendChild(style);
      }

      style.appendChild(document.createTextNode(css));
    }

    var platform_dom$2 = {
      /**
       * When `true`, prevents the automatic injection of the stylesheet required to
       * correctly detect when the chart is added to the DOM and then resized. This
       * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
       * to be manually imported to make this library compatible with any CSP.
       * See https://github.com/chartjs/Chart.js/issues/5208
       */
      disableCSSInjection: false,

      /**
       * This property holds whether this platform is enabled for the current environment.
       * Currently used by platform.js to select the proper implementation.
       * @private
       */
      _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

      /**
       * @private
       */
      _ensureLoaded: function () {
        if (this._loaded) {
          return;
        }

        this._loaded = true; // https://github.com/chartjs/Chart.js/issues/5208

        if (!this.disableCSSInjection) {
          injectCSS(this, stylesheet);
        }
      },
      acquireContext: function (item, config) {
        if (typeof item === 'string') {
          item = document.getElementById(item);
        } else if (item.length) {
          // Support for array based queries (such as jQuery)
          item = item[0];
        }

        if (item && item.canvas) {
          // Support for any object associated to a canvas (including a context2d)
          item = item.canvas;
        } // To prevent canvas fingerprinting, some add-ons undefine the getContext
        // method, for example: https://github.com/kkapsner/CanvasBlocker
        // https://github.com/chartjs/Chart.js/issues/2807


        var context = item && item.getContext && item.getContext('2d'); // Load platform resources on first chart creation, to make possible to change
        // platform options after importing the library (e.g. `disableCSSInjection`).

        this._ensureLoaded(); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
        // inside an iframe or when running in a protected environment. We could guess the
        // types from their toString() value but let's keep things flexible and assume it's
        // a sufficient condition if the item has a context2D which has item as `canvas`.
        // https://github.com/chartjs/Chart.js/issues/3887
        // https://github.com/chartjs/Chart.js/issues/4102
        // https://github.com/chartjs/Chart.js/issues/4152


        if (context && context.canvas === item) {
          initCanvas(item, config);
          return context;
        }

        return null;
      },
      releaseContext: function (context) {
        var canvas = context.canvas;

        if (!canvas[EXPANDO_KEY]) {
          return;
        }

        var initial = canvas[EXPANDO_KEY].initial;
        ['height', 'width'].forEach(function (prop) {
          var value = initial[prop];

          if (helpers$1.isNullOrUndef(value)) {
            canvas.removeAttribute(prop);
          } else {
            canvas.setAttribute(prop, value);
          }
        });
        helpers$1.each(initial.style || {}, function (value, key) {
          canvas.style[key] = value;
        }); // The canvas render size might have been changed (and thus the state stack discarded),
        // we can't use save() and restore() to restore the initial state. So make sure that at
        // least the canvas context is reset to the default state by setting the canvas width.
        // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
        // eslint-disable-next-line no-self-assign

        canvas.width = canvas.width;
        delete canvas[EXPANDO_KEY];
      },
      addEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          addResizeListener(canvas, listener, chart);
          return;
        }

        var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
        var proxies = expando.proxies || (expando.proxies = {});

        var proxy = proxies[chart.id + '_' + type] = function (event) {
          listener(fromNativeEvent(event, chart));
        };

        addListener(canvas, type, proxy);
      },
      removeEventListener: function (chart, type, listener) {
        var canvas = chart.canvas;

        if (type === 'resize') {
          // Note: the resize event is not supported on all browsers.
          removeResizeListener(canvas);
          return;
        }

        var expando = listener[EXPANDO_KEY] || {};
        var proxies = expando.proxies || {};
        var proxy = proxies[chart.id + '_' + type];

        if (!proxy) {
          return;
        }

        removeListener(canvas, type, proxy);
      }
    }; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use EventTarget.addEventListener instead.
     * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     * @function Chart.helpers.addEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.addEvent = addListener;
    /**
     * Provided for backward compatibility, use EventTarget.removeEventListener instead.
     * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
     * @function Chart.helpers.removeEvent
     * @deprecated since version 2.7.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.removeEvent = removeListener; // @TODO Make possible to select another platform at build time.

    var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
    /**
     * @namespace Chart.platform
     * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
     * @since 2.4.0
     */

    var platform = helpers$1.extend({
      /**
       * @since 2.7.0
       */
      initialize: function () {},

      /**
       * Called at chart construction time, returns a context2d instance implementing
       * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
       * @param {*} item - The native item from which to acquire context (platform specific)
       * @param {object} options - The chart options
       * @returns {CanvasRenderingContext2D} context2d instance
       */
      acquireContext: function () {},

      /**
       * Called at chart destruction time, releases any resources associated to the context
       * previously returned by the acquireContext() method.
       * @param {CanvasRenderingContext2D} context - The context2d instance
       * @returns {boolean} true if the method succeeded, else false
       */
      releaseContext: function () {},

      /**
       * Registers the specified listener on the given chart.
       * @param {Chart} chart - Chart from which to listen for event
       * @param {string} type - The ({@link IEvent}) type to listen for
       * @param {function} listener - Receives a notification (an object that implements
       * the {@link IEvent} interface) when an event of the specified type occurs.
       */
      addEventListener: function () {},

      /**
       * Removes the specified listener previously registered with addEventListener.
       * @param {Chart} chart - Chart from which to remove the listener
       * @param {string} type - The ({@link IEvent}) type to remove
       * @param {function} listener - The listener function to remove from the event target.
       */
      removeEventListener: function () {}
    }, implementation);

    core_defaults._set('global', {
      plugins: {}
    });
    /**
     * The plugin service singleton
     * @namespace Chart.plugins
     * @since 2.1.0
     */


    var core_plugins = {
      /**
       * Globally registered plugins.
       * @private
       */
      _plugins: [],

      /**
       * This identifier is used to invalidate the descriptors cache attached to each chart
       * when a global plugin is registered or unregistered. In this case, the cache ID is
       * incremented and descriptors are regenerated during following API calls.
       * @private
       */
      _cacheId: 0,

      /**
       * Registers the given plugin(s) if not already registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      register: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          if (p.indexOf(plugin) === -1) {
            p.push(plugin);
          }
        });
        this._cacheId++;
      },

      /**
       * Unregisters the given plugin(s) only if registered.
       * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
       */
      unregister: function (plugins) {
        var p = this._plugins;
        [].concat(plugins).forEach(function (plugin) {
          var idx = p.indexOf(plugin);

          if (idx !== -1) {
            p.splice(idx, 1);
          }
        });
        this._cacheId++;
      },

      /**
       * Remove all registered plugins.
       * @since 2.1.5
       */
      clear: function () {
        this._plugins = [];
        this._cacheId++;
      },

      /**
       * Returns the number of registered plugins?
       * @returns {number}
       * @since 2.1.5
       */
      count: function () {
        return this._plugins.length;
      },

      /**
       * Returns all registered plugin instances.
       * @returns {IPlugin[]} array of plugin objects.
       * @since 2.1.5
       */
      getAll: function () {
        return this._plugins;
      },

      /**
       * Calls enabled plugins for `chart` on the specified hook and with the given args.
       * This method immediately returns as soon as a plugin explicitly returns false. The
       * returned value can be used, for instance, to interrupt the current action.
       * @param {Chart} chart - The chart instance for which plugins should be called.
       * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
       * @param {Array} [args] - Extra arguments to apply to the hook call.
       * @returns {boolean} false if any of the plugins return false, else returns true.
       */
      notify: function (chart, hook, args) {
        var descriptors = this.descriptors(chart);
        var ilen = descriptors.length;
        var i, descriptor, plugin, params, method;

        for (i = 0; i < ilen; ++i) {
          descriptor = descriptors[i];
          plugin = descriptor.plugin;
          method = plugin[hook];

          if (typeof method === 'function') {
            params = [chart].concat(args || []);
            params.push(descriptor.options);

            if (method.apply(plugin, params) === false) {
              return false;
            }
          }
        }

        return true;
      },

      /**
       * Returns descriptors of enabled plugins for the given chart.
       * @returns {object[]} [{ plugin, options }]
       * @private
       */
      descriptors: function (chart) {
        var cache = chart.$plugins || (chart.$plugins = {});

        if (cache.id === this._cacheId) {
          return cache.descriptors;
        }

        var plugins = [];
        var descriptors = [];
        var config = chart && chart.config || {};
        var options = config.options && config.options.plugins || {};

        this._plugins.concat(config.plugins || []).forEach(function (plugin) {
          var idx = plugins.indexOf(plugin);

          if (idx !== -1) {
            return;
          }

          var id = plugin.id;
          var opts = options[id];

          if (opts === false) {
            return;
          }

          if (opts === true) {
            opts = helpers$1.clone(core_defaults.global.plugins[id]);
          }

          plugins.push(plugin);
          descriptors.push({
            plugin: plugin,
            options: opts || {}
          });
        });

        cache.descriptors = descriptors;
        cache.id = this._cacheId;
        return descriptors;
      },

      /**
       * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
       * but in some cases, this reference can be changed by the user when updating options.
       * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
       * @private
       */
      _invalidate: function (chart) {
        delete chart.$plugins;
      }
    };
    var core_scaleService = {
      // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
      // use the new chart options to grab the correct scale
      constructors: {},
      // Use a registration function so that we can move to an ES6 map when we no longer need to support
      // old browsers
      // Scale config defaults
      defaults: {},
      registerScaleType: function (type, scaleConstructor, scaleDefaults) {
        this.constructors[type] = scaleConstructor;
        this.defaults[type] = helpers$1.clone(scaleDefaults);
      },
      getScaleConstructor: function (type) {
        return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
      },
      getScaleDefaults: function (type) {
        // Return the scale defaults merged with the global settings so that we always use the latest ones
        return this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};
      },
      updateScaleDefaults: function (type, additions) {
        var me = this;

        if (me.defaults.hasOwnProperty(type)) {
          me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
        }
      },
      addScalesToLayout: function (chart) {
        // Adds each scale to the chart.boxes array to be sized accordingly
        helpers$1.each(chart.scales, function (scale) {
          // Set ILayoutItem parameters for backwards compatibility
          scale.fullWidth = scale.options.fullWidth;
          scale.position = scale.options.position;
          scale.weight = scale.options.weight;
          core_layouts.addBox(chart, scale);
        });
      }
    };
    var valueOrDefault$7 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      tooltips: {
        enabled: true,
        custom: null,
        mode: 'nearest',
        position: 'average',
        intersect: true,
        backgroundColor: 'rgba(0,0,0,0.8)',
        titleFontStyle: 'bold',
        titleSpacing: 2,
        titleMarginBottom: 6,
        titleFontColor: '#fff',
        titleAlign: 'left',
        bodySpacing: 2,
        bodyFontColor: '#fff',
        bodyAlign: 'left',
        footerFontStyle: 'bold',
        footerSpacing: 2,
        footerMarginTop: 6,
        footerFontColor: '#fff',
        footerAlign: 'left',
        yPadding: 6,
        xPadding: 6,
        caretPadding: 2,
        caretSize: 5,
        cornerRadius: 6,
        multiKeyBackground: '#fff',
        displayColors: true,
        borderColor: 'rgba(0,0,0,0)',
        borderWidth: 0,
        callbacks: {
          // Args are: (tooltipItems, data)
          beforeTitle: helpers$1.noop,
          title: function (tooltipItems, data) {
            var title = '';
            var labels = data.labels;
            var labelCount = labels ? labels.length : 0;

            if (tooltipItems.length > 0) {
              var item = tooltipItems[0];

              if (item.label) {
                title = item.label;
              } else if (item.xLabel) {
                title = item.xLabel;
              } else if (labelCount > 0 && item.index < labelCount) {
                title = labels[item.index];
              }
            }

            return title;
          },
          afterTitle: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeBody: helpers$1.noop,
          // Args are: (tooltipItem, data)
          beforeLabel: helpers$1.noop,
          label: function (tooltipItem, data) {
            var label = data.datasets[tooltipItem.datasetIndex].label || '';

            if (label) {
              label += ': ';
            }

            if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
              label += tooltipItem.value;
            } else {
              label += tooltipItem.yLabel;
            }

            return label;
          },
          labelColor: function (tooltipItem, chart) {
            var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
            var activeElement = meta.data[tooltipItem.index];
            var view = activeElement._view;
            return {
              borderColor: view.borderColor,
              backgroundColor: view.backgroundColor
            };
          },
          labelTextColor: function () {
            return this._options.bodyFontColor;
          },
          afterLabel: helpers$1.noop,
          // Args are: (tooltipItems, data)
          afterBody: helpers$1.noop,
          // Args are: (tooltipItems, data)
          beforeFooter: helpers$1.noop,
          footer: helpers$1.noop,
          afterFooter: helpers$1.noop
        }
      }
    });

    var positioners = {
      /**
       * Average mode places the tooltip at the average position of the elements shown
       * @function Chart.Tooltip.positioners.average
       * @param elements {ChartElement[]} the elements being displayed in the tooltip
       * @returns {object} tooltip position
       */
      average: function (elements) {
        if (!elements.length) {
          return false;
        }

        var i, len;
        var x = 0;
        var y = 0;
        var count = 0;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var pos = el.tooltipPosition();
            x += pos.x;
            y += pos.y;
            ++count;
          }
        }

        return {
          x: x / count,
          y: y / count
        };
      },

      /**
       * Gets the tooltip position nearest of the item nearest to the event position
       * @function Chart.Tooltip.positioners.nearest
       * @param elements {Chart.Element[]} the tooltip elements
       * @param eventPosition {object} the position of the event in canvas coordinates
       * @returns {object} the tooltip position
       */
      nearest: function (elements, eventPosition) {
        var x = eventPosition.x;
        var y = eventPosition.y;
        var minDistance = Number.POSITIVE_INFINITY;
        var i, len, nearestElement;

        for (i = 0, len = elements.length; i < len; ++i) {
          var el = elements[i];

          if (el && el.hasValue()) {
            var center = el.getCenterPoint();
            var d = helpers$1.distanceBetweenPoints(eventPosition, center);

            if (d < minDistance) {
              minDistance = d;
              nearestElement = el;
            }
          }
        }

        if (nearestElement) {
          var tp = nearestElement.tooltipPosition();
          x = tp.x;
          y = tp.y;
        }

        return {
          x: x,
          y: y
        };
      }
    }; // Helper to push or concat based on if the 2nd parameter is an array or not

    function pushOrConcat(base, toPush) {
      if (toPush) {
        if (helpers$1.isArray(toPush)) {
          // base = base.concat(toPush);
          Array.prototype.push.apply(base, toPush);
        } else {
          base.push(toPush);
        }
      }

      return base;
    }
    /**
     * Returns array of strings split by newline
     * @param {string} value - The value to split by newline.
     * @returns {string[]} value if newline present - Returned from String split() method
     * @function
     */


    function splitNewlines(str) {
      if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
        return str.split('\n');
      }

      return str;
    }
    /**
     * Private helper to create a tooltip item model
     * @param element - the chart element (point, arc, bar) to create the tooltip item for
     * @return new tooltip item
     */


    function createTooltipItem(element) {
      var xScale = element._xScale;
      var yScale = element._yScale || element._scale; // handle radar || polarArea charts

      var index = element._index;
      var datasetIndex = element._datasetIndex;

      var controller = element._chart.getDatasetMeta(datasetIndex).controller;

      var indexScale = controller._getIndexScale();

      var valueScale = controller._getValueScale();

      return {
        xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
        yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
        label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',
        value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',
        index: index,
        datasetIndex: datasetIndex,
        x: element._model.x,
        y: element._model.y
      };
    }
    /**
     * Helper to get the reset model for the tooltip
     * @param tooltipOpts {object} the tooltip options
     */


    function getBaseModel(tooltipOpts) {
      var globalDefaults = core_defaults.global;
      return {
        // Positioning
        xPadding: tooltipOpts.xPadding,
        yPadding: tooltipOpts.yPadding,
        xAlign: tooltipOpts.xAlign,
        yAlign: tooltipOpts.yAlign,
        // Body
        bodyFontColor: tooltipOpts.bodyFontColor,
        _bodyFontFamily: valueOrDefault$7(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
        _bodyFontStyle: valueOrDefault$7(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
        _bodyAlign: tooltipOpts.bodyAlign,
        bodyFontSize: valueOrDefault$7(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
        bodySpacing: tooltipOpts.bodySpacing,
        // Title
        titleFontColor: tooltipOpts.titleFontColor,
        _titleFontFamily: valueOrDefault$7(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
        _titleFontStyle: valueOrDefault$7(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
        titleFontSize: valueOrDefault$7(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
        _titleAlign: tooltipOpts.titleAlign,
        titleSpacing: tooltipOpts.titleSpacing,
        titleMarginBottom: tooltipOpts.titleMarginBottom,
        // Footer
        footerFontColor: tooltipOpts.footerFontColor,
        _footerFontFamily: valueOrDefault$7(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
        _footerFontStyle: valueOrDefault$7(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
        footerFontSize: valueOrDefault$7(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
        _footerAlign: tooltipOpts.footerAlign,
        footerSpacing: tooltipOpts.footerSpacing,
        footerMarginTop: tooltipOpts.footerMarginTop,
        // Appearance
        caretSize: tooltipOpts.caretSize,
        cornerRadius: tooltipOpts.cornerRadius,
        backgroundColor: tooltipOpts.backgroundColor,
        opacity: 0,
        legendColorBackground: tooltipOpts.multiKeyBackground,
        displayColors: tooltipOpts.displayColors,
        borderColor: tooltipOpts.borderColor,
        borderWidth: tooltipOpts.borderWidth
      };
    }
    /**
     * Get the size of the tooltip
     */


    function getTooltipSize(tooltip, model) {
      var ctx = tooltip._chart.ctx;
      var height = model.yPadding * 2; // Tooltip Padding

      var width = 0; // Count of all lines in the body

      var body = model.body;
      var combinedBodyLength = body.reduce(function (count, bodyItem) {
        return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
      }, 0);
      combinedBodyLength += model.beforeBody.length + model.afterBody.length;
      var titleLineCount = model.title.length;
      var footerLineCount = model.footer.length;
      var titleFontSize = model.titleFontSize;
      var bodyFontSize = model.bodyFontSize;
      var footerFontSize = model.footerFontSize;
      height += titleLineCount * titleFontSize; // Title Lines

      height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing

      height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin

      height += combinedBodyLength * bodyFontSize; // Body Lines

      height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing

      height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin

      height += footerLineCount * footerFontSize; // Footer Lines

      height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
      // Title width

      var widthPadding = 0;

      var maxLineWidth = function (line) {
        width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };

      ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
      helpers$1.each(model.title, maxLineWidth); // Body width

      ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
      helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box

      widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
      helpers$1.each(body, function (bodyItem) {
        helpers$1.each(bodyItem.before, maxLineWidth);
        helpers$1.each(bodyItem.lines, maxLineWidth);
        helpers$1.each(bodyItem.after, maxLineWidth);
      }); // Reset back to 0

      widthPadding = 0; // Footer width

      ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
      helpers$1.each(model.footer, maxLineWidth); // Add padding

      width += 2 * model.xPadding;
      return {
        width: width,
        height: height
      };
    }
    /**
     * Helper to get the alignment of a tooltip given the size
     */


    function determineAlignment(tooltip, size) {
      var model = tooltip._model;
      var chart = tooltip._chart;
      var chartArea = tooltip._chart.chartArea;
      var xAlign = 'center';
      var yAlign = 'center';

      if (model.y < size.height) {
        yAlign = 'top';
      } else if (model.y > chart.height - size.height) {
        yAlign = 'bottom';
      }

      var lf, rf; // functions to determine left, right alignment

      var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart

      var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges

      var midX = (chartArea.left + chartArea.right) / 2;
      var midY = (chartArea.top + chartArea.bottom) / 2;

      if (yAlign === 'center') {
        lf = function (x) {
          return x <= midX;
        };

        rf = function (x) {
          return x > midX;
        };
      } else {
        lf = function (x) {
          return x <= size.width / 2;
        };

        rf = function (x) {
          return x >= chart.width - size.width / 2;
        };
      }

      olf = function (x) {
        return x + size.width + model.caretSize + model.caretPadding > chart.width;
      };

      orf = function (x) {
        return x - size.width - model.caretSize - model.caretPadding < 0;
      };

      yf = function (y) {
        return y <= midY ? 'top' : 'bottom';
      };

      if (lf(model.x)) {
        xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?

        if (olf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      } else if (rf(model.x)) {
        xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?

        if (orf(model.x)) {
          xAlign = 'center';
          yAlign = yf(model.y);
        }
      }

      var opts = tooltip._options;
      return {
        xAlign: opts.xAlign ? opts.xAlign : xAlign,
        yAlign: opts.yAlign ? opts.yAlign : yAlign
      };
    }
    /**
     * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
     */


    function getBackgroundPoint(vm, size, alignment, chart) {
      // Background Position
      var x = vm.x;
      var y = vm.y;
      var caretSize = vm.caretSize;
      var caretPadding = vm.caretPadding;
      var cornerRadius = vm.cornerRadius;
      var xAlign = alignment.xAlign;
      var yAlign = alignment.yAlign;
      var paddingAndSize = caretSize + caretPadding;
      var radiusAndPadding = cornerRadius + caretPadding;

      if (xAlign === 'right') {
        x -= size.width;
      } else if (xAlign === 'center') {
        x -= size.width / 2;

        if (x + size.width > chart.width) {
          x = chart.width - size.width;
        }

        if (x < 0) {
          x = 0;
        }
      }

      if (yAlign === 'top') {
        y += paddingAndSize;
      } else if (yAlign === 'bottom') {
        y -= size.height + paddingAndSize;
      } else {
        y -= size.height / 2;
      }

      if (yAlign === 'center') {
        if (xAlign === 'left') {
          x += paddingAndSize;
        } else if (xAlign === 'right') {
          x -= paddingAndSize;
        }
      } else if (xAlign === 'left') {
        x -= radiusAndPadding;
      } else if (xAlign === 'right') {
        x += radiusAndPadding;
      }

      return {
        x: x,
        y: y
      };
    }

    function getAlignedX(vm, align) {
      return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
    }
    /**
     * Helper to build before and after body lines
     */


    function getBeforeAfterBodyLines(callback) {
      return pushOrConcat([], splitNewlines(callback));
    }

    var exports$3 = core_element.extend({
      initialize: function () {
        this._model = getBaseModel(this._options);
        this._lastActive = [];
      },
      // Get the title
      // Args are: (tooltipItem, data)
      getTitle: function () {
        var me = this;
        var opts = me._options;
        var callbacks = opts.callbacks;
        var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
        var title = callbacks.title.apply(me, arguments);
        var afterTitle = callbacks.afterTitle.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
        lines = pushOrConcat(lines, splitNewlines(title));
        lines = pushOrConcat(lines, splitNewlines(afterTitle));
        return lines;
      },
      // Args are: (tooltipItem, data)
      getBeforeBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
      },
      // Args are: (tooltipItem, data)
      getBody: function (tooltipItems, data) {
        var me = this;
        var callbacks = me._options.callbacks;
        var bodyItems = [];
        helpers$1.each(tooltipItems, function (tooltipItem) {
          var bodyItem = {
            before: [],
            lines: [],
            after: []
          };
          pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
          pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
          pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
          bodyItems.push(bodyItem);
        });
        return bodyItems;
      },
      // Args are: (tooltipItem, data)
      getAfterBody: function () {
        return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
      },
      // Get the footer and beforeFooter and afterFooter lines
      // Args are: (tooltipItem, data)
      getFooter: function () {
        var me = this;
        var callbacks = me._options.callbacks;
        var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
        var footer = callbacks.footer.apply(me, arguments);
        var afterFooter = callbacks.afterFooter.apply(me, arguments);
        var lines = [];
        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
        lines = pushOrConcat(lines, splitNewlines(footer));
        lines = pushOrConcat(lines, splitNewlines(afterFooter));
        return lines;
      },
      update: function (changed) {
        var me = this;
        var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
        // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
        // which breaks any animations.

        var existingModel = me._model;
        var model = me._model = getBaseModel(opts);
        var active = me._active;
        var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations

        var alignment = {
          xAlign: existingModel.xAlign,
          yAlign: existingModel.yAlign
        };
        var backgroundPoint = {
          x: existingModel.x,
          y: existingModel.y
        };
        var tooltipSize = {
          width: existingModel.width,
          height: existingModel.height
        };
        var tooltipPosition = {
          x: existingModel.caretX,
          y: existingModel.caretY
        };
        var i, len;

        if (active.length) {
          model.opacity = 1;
          var labelColors = [];
          var labelTextColors = [];
          tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
          var tooltipItems = [];

          for (i = 0, len = active.length; i < len; ++i) {
            tooltipItems.push(createTooltipItem(active[i]));
          } // If the user provided a filter function, use it to modify the tooltip items


          if (opts.filter) {
            tooltipItems = tooltipItems.filter(function (a) {
              return opts.filter(a, data);
            });
          } // If the user provided a sorting function, use it to modify the tooltip items


          if (opts.itemSort) {
            tooltipItems = tooltipItems.sort(function (a, b) {
              return opts.itemSort(a, b, data);
            });
          } // Determine colors for boxes


          helpers$1.each(tooltipItems, function (tooltipItem) {
            labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
            labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
          }); // Build the Text Lines

          model.title = me.getTitle(tooltipItems, data);
          model.beforeBody = me.getBeforeBody(tooltipItems, data);
          model.body = me.getBody(tooltipItems, data);
          model.afterBody = me.getAfterBody(tooltipItems, data);
          model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors

          model.x = tooltipPosition.x;
          model.y = tooltipPosition.y;
          model.caretPadding = opts.caretPadding;
          model.labelColors = labelColors;
          model.labelTextColors = labelTextColors; // data points

          model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip

          tooltipSize = getTooltipSize(this, model);
          alignment = determineAlignment(this, tooltipSize); // Final Size and Position

          backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
        } else {
          model.opacity = 0;
        }

        model.xAlign = alignment.xAlign;
        model.yAlign = alignment.yAlign;
        model.x = backgroundPoint.x;
        model.y = backgroundPoint.y;
        model.width = tooltipSize.width;
        model.height = tooltipSize.height; // Point where the caret on the tooltip points to

        model.caretX = tooltipPosition.x;
        model.caretY = tooltipPosition.y;
        me._model = model;

        if (changed && opts.custom) {
          opts.custom.call(me, model);
        }

        return me;
      },
      drawCaret: function (tooltipPoint, size) {
        var ctx = this._chart.ctx;
        var vm = this._view;
        var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
        ctx.lineTo(caretPosition.x1, caretPosition.y1);
        ctx.lineTo(caretPosition.x2, caretPosition.y2);
        ctx.lineTo(caretPosition.x3, caretPosition.y3);
      },
      getCaretPosition: function (tooltipPoint, size, vm) {
        var x1, x2, x3, y1, y2, y3;
        var caretSize = vm.caretSize;
        var cornerRadius = vm.cornerRadius;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var ptX = tooltipPoint.x;
        var ptY = tooltipPoint.y;
        var width = size.width;
        var height = size.height;

        if (yAlign === 'center') {
          y2 = ptY + height / 2;

          if (xAlign === 'left') {
            x1 = ptX;
            x2 = x1 - caretSize;
            x3 = x1;
            y1 = y2 + caretSize;
            y3 = y2 - caretSize;
          } else {
            x1 = ptX + width;
            x2 = x1 + caretSize;
            x3 = x1;
            y1 = y2 - caretSize;
            y3 = y2 + caretSize;
          }
        } else {
          if (xAlign === 'left') {
            x2 = ptX + cornerRadius + caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else if (xAlign === 'right') {
            x2 = ptX + width - cornerRadius - caretSize;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          } else {
            x2 = vm.caretX;
            x1 = x2 - caretSize;
            x3 = x2 + caretSize;
          }

          if (yAlign === 'top') {
            y1 = ptY;
            y2 = y1 - caretSize;
            y3 = y1;
          } else {
            y1 = ptY + height;
            y2 = y1 + caretSize;
            y3 = y1; // invert drawing order

            var tmp = x3;
            x3 = x1;
            x1 = tmp;
          }
        }

        return {
          x1: x1,
          x2: x2,
          x3: x3,
          y1: y1,
          y2: y2,
          y3: y3
        };
      },
      drawTitle: function (pt, vm, ctx) {
        var title = vm.title;

        if (title.length) {
          pt.x = getAlignedX(vm, vm._titleAlign);
          ctx.textAlign = vm._titleAlign;
          ctx.textBaseline = 'top';
          var titleFontSize = vm.titleFontSize;
          var titleSpacing = vm.titleSpacing;
          ctx.fillStyle = vm.titleFontColor;
          ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
          var i, len;

          for (i = 0, len = title.length; i < len; ++i) {
            ctx.fillText(title[i], pt.x, pt.y);
            pt.y += titleFontSize + titleSpacing; // Line Height and spacing

            if (i + 1 === title.length) {
              pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
            }
          }
        }
      },
      drawBody: function (pt, vm, ctx) {
        var bodyFontSize = vm.bodyFontSize;
        var bodySpacing = vm.bodySpacing;
        var bodyAlign = vm._bodyAlign;
        var body = vm.body;
        var drawColorBoxes = vm.displayColors;
        var labelColors = vm.labelColors;
        var xLinePadding = 0;
        var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;
        var textColor;
        ctx.textAlign = bodyAlign;
        ctx.textBaseline = 'top';
        ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
        pt.x = getAlignedX(vm, bodyAlign); // Before Body

        var fillLineOfText = function (line) {
          ctx.fillText(line, pt.x + xLinePadding, pt.y);
          pt.y += bodyFontSize + bodySpacing;
        }; // Before body lines


        ctx.fillStyle = vm.bodyFontColor;
        helpers$1.each(vm.beforeBody, fillLineOfText);
        xLinePadding = drawColorBoxes && bodyAlign !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0; // Draw body lines now

        helpers$1.each(body, function (bodyItem, i) {
          textColor = vm.labelTextColors[i];
          ctx.fillStyle = textColor;
          helpers$1.each(bodyItem.before, fillLineOfText);
          helpers$1.each(bodyItem.lines, function (line) {
            // Draw Legend-like boxes if needed
            if (drawColorBoxes) {
              // Fill a white rect so that colours merge nicely if the opacity is < 1
              ctx.fillStyle = vm.legendColorBackground;
              ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Border

              ctx.lineWidth = 1;
              ctx.strokeStyle = labelColors[i].borderColor;
              ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Inner square

              ctx.fillStyle = labelColors[i].backgroundColor;
              ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
              ctx.fillStyle = textColor;
            }

            fillLineOfText(line);
          });
          helpers$1.each(bodyItem.after, fillLineOfText);
        }); // Reset back to 0 for after body

        xLinePadding = 0; // After body lines

        helpers$1.each(vm.afterBody, fillLineOfText);
        pt.y -= bodySpacing; // Remove last body spacing
      },
      drawFooter: function (pt, vm, ctx) {
        var footer = vm.footer;

        if (footer.length) {
          pt.x = getAlignedX(vm, vm._footerAlign);
          pt.y += vm.footerMarginTop;
          ctx.textAlign = vm._footerAlign;
          ctx.textBaseline = 'top';
          ctx.fillStyle = vm.footerFontColor;
          ctx.font = helpers$1.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
          helpers$1.each(footer, function (line) {
            ctx.fillText(line, pt.x, pt.y);
            pt.y += vm.footerFontSize + vm.footerSpacing;
          });
        }
      },
      drawBackground: function (pt, vm, ctx, tooltipSize) {
        ctx.fillStyle = vm.backgroundColor;
        ctx.strokeStyle = vm.borderColor;
        ctx.lineWidth = vm.borderWidth;
        var xAlign = vm.xAlign;
        var yAlign = vm.yAlign;
        var x = pt.x;
        var y = pt.y;
        var width = tooltipSize.width;
        var height = tooltipSize.height;
        var radius = vm.cornerRadius;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);

        if (yAlign === 'top') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);

        if (yAlign === 'center' && xAlign === 'right') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);

        if (yAlign === 'bottom') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);

        if (yAlign === 'center' && xAlign === 'left') {
          this.drawCaret(pt, tooltipSize);
        }

        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();

        if (vm.borderWidth > 0) {
          ctx.stroke();
        }
      },
      draw: function () {
        var ctx = this._chart.ctx;
        var vm = this._view;

        if (vm.opacity === 0) {
          return;
        }

        var tooltipSize = {
          width: vm.width,
          height: vm.height
        };
        var pt = {
          x: vm.x,
          y: vm.y
        }; // IE11/Edge does not like very small opacities, so snap to 0

        var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip

        var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

        if (this._options.enabled && hasTooltipContent) {
          ctx.save();
          ctx.globalAlpha = opacity; // Draw Background

          this.drawBackground(pt, vm, ctx, tooltipSize); // Draw Title, Body, and Footer

          pt.y += vm.yPadding; // Titles

          this.drawTitle(pt, vm, ctx); // Body

          this.drawBody(pt, vm, ctx); // Footer

          this.drawFooter(pt, vm, ctx);
          ctx.restore();
        }
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       * @returns {boolean} true if the tooltip changed
       */
      handleEvent: function (e) {
        var me = this;
        var options = me._options;
        var changed = false;
        me._lastActive = me._lastActive || []; // Find Active Elements for tooltips

        if (e.type === 'mouseout') {
          me._active = [];
        } else {
          me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
        } // Remember Last Actives


        changed = !helpers$1.arrayEquals(me._active, me._lastActive); // Only handle target event on tooltip change

        if (changed) {
          me._lastActive = me._active;

          if (options.enabled || options.custom) {
            me._eventPosition = {
              x: e.x,
              y: e.y
            };
            me.update(true);
            me.pivot();
          }
        }

        return changed;
      }
    });
    /**
     * @namespace Chart.Tooltip.positioners
     */

    var positioners_1 = positioners;
    var core_tooltip = exports$3;
    core_tooltip.positioners = positioners_1;
    var valueOrDefault$8 = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      elements: {},
      events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
      hover: {
        onHover: null,
        mode: 'nearest',
        intersect: true,
        animationDuration: 400
      },
      onClick: null,
      maintainAspectRatio: true,
      responsive: true,
      responsiveAnimationDuration: 0
    });
    /**
     * Recursively merge the given config objects representing the `scales` option
     * by incorporating scale defaults in `xAxes` and `yAxes` array items, then
     * returns a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeScaleConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          if (key === 'xAxes' || key === 'yAxes') {
            var slen = source[key].length;
            var i, type, scale;

            if (!target[key]) {
              target[key] = [];
            }

            for (i = 0; i < slen; ++i) {
              scale = source[key][i];
              type = valueOrDefault$8(scale.type, key === 'xAxes' ? 'category' : 'linear');

              if (i >= target[key].length) {
                target[key].push({});
              }

              if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
                // new/untyped scale or type changed: let's apply the new defaults
                // then merge source scale to correctly overwrite the defaults.
                helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
              } else {
                // scales type are the same
                helpers$1.merge(target[key][i], scale);
              }
            }
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }
    /**
     * Recursively merge the given config objects as the root options by handling
     * default scale options for the `scales` and `scale` properties, then returns
     * a deep copy of the result, thus doesn't alter inputs.
     */


    function mergeConfig()
    /* config objects ... */
    {
      return helpers$1.merge({}, [].slice.call(arguments), {
        merger: function (key, target, source, options) {
          var tval = target[key] || {};
          var sval = source[key];

          if (key === 'scales') {
            // scale config merging is complex. Add our own function here for that
            target[key] = mergeScaleConfig(tval, sval);
          } else if (key === 'scale') {
            // used in polar area & radar charts since there is only one scale
            target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
          } else {
            helpers$1._merger(key, target, source, options);
          }
        }
      });
    }

    function initConfig(config) {
      config = config || {}; // Do NOT use mergeConfig for the data object because this method merges arrays
      // and so would change references to labels and datasets, preventing data updates.

      var data = config.data = config.data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
      return config;
    }

    function updateConfig(chart) {
      var newOptions = chart.options;
      helpers$1.each(chart.scales, function (scale) {
        core_layouts.removeBox(chart, scale);
      });
      newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
      chart.options = chart.config.options = newOptions;
      chart.ensureScalesHaveIDs();
      chart.buildOrUpdateScales(); // Tooltip

      chart.tooltip._options = newOptions.tooltips;
      chart.tooltip.initialize();
    }

    function positionIsHorizontal(position) {
      return position === 'top' || position === 'bottom';
    }

    var Chart = function (item, config) {
      this.construct(item, config);
      return this;
    };

    helpers$1.extend(Chart.prototype,
    /** @lends Chart */
    {
      /**
       * @private
       */
      construct: function (item, config) {
        var me = this;
        config = initConfig(config);
        var context = platform.acquireContext(item, config);
        var canvas = context && context.canvas;
        var height = canvas && canvas.height;
        var width = canvas && canvas.width;
        me.id = helpers$1.uid();
        me.ctx = context;
        me.canvas = canvas;
        me.config = config;
        me.width = width;
        me.height = height;
        me.aspectRatio = height ? width / height : null;
        me.options = config.options;
        me._bufferedRender = false;
        /**
         * Provided for backward compatibility, Chart and Chart.Controller have been merged,
         * the "instance" still need to be defined since it might be called from plugins.
         * @prop Chart#chart
         * @deprecated since version 2.6.0
         * @todo remove at version 3
         * @private
         */

        me.chart = me;
        me.controller = me; // chart.chart.controller #inception
        // Add the chart instance to the global namespace

        Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`

        Object.defineProperty(me, 'data', {
          get: function () {
            return me.config.data;
          },
          set: function (value) {
            me.config.data = value;
          }
        });

        if (!context || !canvas) {
          // The given item is not a compatible context2d element, let's return before finalizing
          // the chart initialization but after setting basic chart / controller properties that
          // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
          // https://github.com/chartjs/Chart.js/issues/2807
          console.error("Failed to create chart: can't acquire context from the given item");
          return;
        }

        me.initialize();
        me.update();
      },

      /**
       * @private
       */
      initialize: function () {
        var me = this; // Before init plugin notification

        core_plugins.notify(me, 'beforeInit');
        helpers$1.retinaScale(me, me.options.devicePixelRatio);
        me.bindEvents();

        if (me.options.responsive) {
          // Initial resize before chart draws (must be silent to preserve initial animations).
          me.resize(true);
        } // Make sure scales have IDs and are built before we build any controllers.


        me.ensureScalesHaveIDs();
        me.buildOrUpdateScales();
        me.initToolTip(); // After init plugin notification

        core_plugins.notify(me, 'afterInit');
        return me;
      },
      clear: function () {
        helpers$1.canvas.clear(this);
        return this;
      },
      stop: function () {
        // Stops any current animation loop occurring
        core_animations.cancelAnimation(this);
        return this;
      },
      resize: function (silent) {
        var me = this;
        var options = me.options;
        var canvas = me.canvas;
        var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that
        // the canvas display style uses the same integer values to avoid blurring effect.
        // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed

        var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
        var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));

        if (me.width === newWidth && me.height === newHeight) {
          return;
        }

        canvas.width = me.width = newWidth;
        canvas.height = me.height = newHeight;
        canvas.style.width = newWidth + 'px';
        canvas.style.height = newHeight + 'px';
        helpers$1.retinaScale(me, options.devicePixelRatio);

        if (!silent) {
          // Notify any plugins about the resize
          var newSize = {
            width: newWidth,
            height: newHeight
          };
          core_plugins.notify(me, 'resize', [newSize]); // Notify of resize

          if (options.onResize) {
            options.onResize(me, newSize);
          }

          me.stop();
          me.update({
            duration: options.responsiveAnimationDuration
          });
        }
      },
      ensureScalesHaveIDs: function () {
        var options = this.options;
        var scalesOptions = options.scales || {};
        var scaleOptions = options.scale;
        helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {
          xAxisOptions.id = xAxisOptions.id || 'x-axis-' + index;
        });
        helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {
          yAxisOptions.id = yAxisOptions.id || 'y-axis-' + index;
        });

        if (scaleOptions) {
          scaleOptions.id = scaleOptions.id || 'scale';
        }
      },

      /**
       * Builds a map of scale ID to scale object for future lookup.
       */
      buildOrUpdateScales: function () {
        var me = this;
        var options = me.options;
        var scales = me.scales || {};
        var items = [];
        var updated = Object.keys(scales).reduce(function (obj, id) {
          obj[id] = false;
          return obj;
        }, {});

        if (options.scales) {
          items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
            return {
              options: xAxisOptions,
              dtype: 'category',
              dposition: 'bottom'
            };
          }), (options.scales.yAxes || []).map(function (yAxisOptions) {
            return {
              options: yAxisOptions,
              dtype: 'linear',
              dposition: 'left'
            };
          }));
        }

        if (options.scale) {
          items.push({
            options: options.scale,
            dtype: 'radialLinear',
            isDefault: true,
            dposition: 'chartArea'
          });
        }

        helpers$1.each(items, function (item) {
          var scaleOptions = item.options;
          var id = scaleOptions.id;
          var scaleType = valueOrDefault$8(scaleOptions.type, item.dtype);

          if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
            scaleOptions.position = item.dposition;
          }

          updated[id] = true;
          var scale = null;

          if (id in scales && scales[id].type === scaleType) {
            scale = scales[id];
            scale.options = scaleOptions;
            scale.ctx = me.ctx;
            scale.chart = me;
          } else {
            var scaleClass = core_scaleService.getScaleConstructor(scaleType);

            if (!scaleClass) {
              return;
            }

            scale = new scaleClass({
              id: id,
              type: scaleType,
              options: scaleOptions,
              ctx: me.ctx,
              chart: me
            });
            scales[scale.id] = scale;
          }

          scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)
          // and consider it as a regular scale part of the "scales"" map only! This would
          // make the logic easier and remove some useless? custom code.

          if (item.isDefault) {
            me.scale = scale;
          }
        }); // clear up discarded scales

        helpers$1.each(updated, function (hasUpdated, id) {
          if (!hasUpdated) {
            delete scales[id];
          }
        });
        me.scales = scales;
        core_scaleService.addScalesToLayout(this);
      },
      buildOrUpdateControllers: function () {
        var me = this;
        var newControllers = [];
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          var meta = me.getDatasetMeta(datasetIndex);
          var type = dataset.type || me.config.type;

          if (meta.type && meta.type !== type) {
            me.destroyDatasetMeta(datasetIndex);
            meta = me.getDatasetMeta(datasetIndex);
          }

          meta.type = type;

          if (meta.controller) {
            meta.controller.updateIndex(datasetIndex);
            meta.controller.linkScales();
          } else {
            var ControllerClass = controllers[meta.type];

            if (ControllerClass === undefined) {
              throw new Error('"' + meta.type + '" is not a chart type.');
            }

            meta.controller = new ControllerClass(me, datasetIndex);
            newControllers.push(meta.controller);
          }
        }, me);
        return newControllers;
      },

      /**
       * Reset the elements of all datasets
       * @private
       */
      resetElements: function () {
        var me = this;
        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.reset();
        }, me);
      },

      /**
      * Resets the chart back to it's state before the initial animation
      */
      reset: function () {
        this.resetElements();
        this.tooltip.initialize();
      },
      update: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        updateConfig(me); // plugins options references might have change, let's invalidate the cache
        // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167

        core_plugins._invalidate(me);

        if (core_plugins.notify(me, 'beforeUpdate') === false) {
          return;
        } // In case the entire data object changed


        me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset

        var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts

        helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
          me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
        }, me);
        me.updateLayout(); // Can only reset the new controllers after the scales have been updated

        if (me.options.animation && me.options.animation.duration) {
          helpers$1.each(newControllers, function (controller) {
            controller.reset();
          });
        }

        me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed
        // after update.

        me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.
        // When we reset the tooltip, we need to clear it

        me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it

        core_plugins.notify(me, 'afterUpdate');

        if (me._bufferedRender) {
          me._bufferedRequest = {
            duration: config.duration,
            easing: config.easing,
            lazy: config.lazy
          };
        } else {
          me.render(config);
        }
      },

      /**
       * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
       * hook, in which case, plugins will not be called on `afterLayout`.
       * @private
       */
      updateLayout: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeLayout') === false) {
          return;
        }

        core_layouts.update(this, this.width, this.height);
        /**
         * Provided for backward compatibility, use `afterLayout` instead.
         * @method IPlugin#afterScaleUpdate
         * @deprecated since version 2.5.0
         * @todo remove at version 3
         * @private
         */

        core_plugins.notify(me, 'afterScaleUpdate');
        core_plugins.notify(me, 'afterLayout');
      },

      /**
       * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
       * @private
       */
      updateDatasets: function () {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {
          return;
        }

        for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.updateDataset(i);
        }

        core_plugins.notify(me, 'afterDatasetsUpdate');
      },

      /**
       * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
       * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
       * @private
       */
      updateDataset: function (index) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index
        };

        if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
          return;
        }

        meta.controller.update();
        core_plugins.notify(me, 'afterDatasetUpdate', [args]);
      },
      render: function (config) {
        var me = this;

        if (!config || typeof config !== 'object') {
          // backwards compatibility
          config = {
            duration: config,
            lazy: arguments[1]
          };
        }

        var animationOptions = me.options.animation;
        var duration = valueOrDefault$8(config.duration, animationOptions && animationOptions.duration);
        var lazy = config.lazy;

        if (core_plugins.notify(me, 'beforeRender') === false) {
          return;
        }

        var onComplete = function (animation) {
          core_plugins.notify(me, 'afterRender');
          helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
        };

        if (animationOptions && duration) {
          var animation = new core_animation({
            numSteps: duration / 16.66,
            // 60 fps
            easing: config.easing || animationOptions.easing,
            render: function (chart, animationObject) {
              var easingFunction = helpers$1.easing.effects[animationObject.easing];
              var currentStep = animationObject.currentStep;
              var stepDecimal = currentStep / animationObject.numSteps;
              chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
            },
            onAnimationProgress: animationOptions.onProgress,
            onAnimationComplete: onComplete
          });
          core_animations.addAnimation(me, animation, duration, lazy);
        } else {
          me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781

          onComplete(new core_animation({
            numSteps: 0,
            chart: me
          }));
        }

        return me;
      },
      draw: function (easingValue) {
        var me = this;
        me.clear();

        if (helpers$1.isNullOrUndef(easingValue)) {
          easingValue = 1;
        }

        me.transition(easingValue);

        if (me.width <= 0 || me.height <= 0) {
          return;
        }

        if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
          return;
        } // Draw all the scales


        helpers$1.each(me.boxes, function (box) {
          box.draw(me.chartArea);
        }, me);
        me.drawDatasets(easingValue);

        me._drawTooltip(easingValue);

        core_plugins.notify(me, 'afterDraw', [easingValue]);
      },

      /**
       * @private
       */
      transition: function (easingValue) {
        var me = this;

        for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
          if (me.isDatasetVisible(i)) {
            me.getDatasetMeta(i).controller.transition(easingValue);
          }
        }

        me.tooltip.transition(easingValue);
      },

      /**
       * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
       * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
       * @private
       */
      drawDatasets: function (easingValue) {
        var me = this;

        if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
          return;
        } // Draw datasets reversed to support proper line stacking


        for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
          if (me.isDatasetVisible(i)) {
            me.drawDataset(i, easingValue);
          }
        }

        core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
      },

      /**
       * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
       * hook, in which case, plugins will not be called on `afterDatasetDraw`.
       * @private
       */
      drawDataset: function (index, easingValue) {
        var me = this;
        var meta = me.getDatasetMeta(index);
        var args = {
          meta: meta,
          index: index,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
          return;
        }

        meta.controller.draw(easingValue);
        core_plugins.notify(me, 'afterDatasetDraw', [args]);
      },

      /**
       * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
       * hook, in which case, plugins will not be called on `afterTooltipDraw`.
       * @private
       */
      _drawTooltip: function (easingValue) {
        var me = this;
        var tooltip = me.tooltip;
        var args = {
          tooltip: tooltip,
          easingValue: easingValue
        };

        if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
          return;
        }

        tooltip.draw();
        core_plugins.notify(me, 'afterTooltipDraw', [args]);
      },

      /**
       * Get the single element that was clicked on
       * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
       */
      getElementAtEvent: function (e) {
        return core_interaction.modes.single(this, e);
      },
      getElementsAtEvent: function (e) {
        return core_interaction.modes.label(this, e, {
          intersect: true
        });
      },
      getElementsAtXAxis: function (e) {
        return core_interaction.modes['x-axis'](this, e, {
          intersect: true
        });
      },
      getElementsAtEventForMode: function (e, mode, options) {
        var method = core_interaction.modes[mode];

        if (typeof method === 'function') {
          return method(this, e, options);
        }

        return [];
      },
      getDatasetAtEvent: function (e) {
        return core_interaction.modes.dataset(this, e, {
          intersect: true
        });
      },
      getDatasetMeta: function (datasetIndex) {
        var me = this;
        var dataset = me.data.datasets[datasetIndex];

        if (!dataset._meta) {
          dataset._meta = {};
        }

        var meta = dataset._meta[me.id];

        if (!meta) {
          meta = dataset._meta[me.id] = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            // See isDatasetVisible() comment
            xAxisID: null,
            yAxisID: null
          };
        }

        return meta;
      },
      getVisibleDatasetCount: function () {
        var count = 0;

        for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
          if (this.isDatasetVisible(i)) {
            count++;
          }
        }

        return count;
      },
      isDatasetVisible: function (datasetIndex) {
        var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
        // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.

        return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
      },
      generateLegend: function () {
        return this.options.legendCallback(this);
      },

      /**
       * @private
       */
      destroyDatasetMeta: function (datasetIndex) {
        var id = this.id;
        var dataset = this.data.datasets[datasetIndex];
        var meta = dataset._meta && dataset._meta[id];

        if (meta) {
          meta.controller.destroy();
          delete dataset._meta[id];
        }
      },
      destroy: function () {
        var me = this;
        var canvas = me.canvas;
        var i, ilen;
        me.stop(); // dataset controllers need to cleanup associated data

        for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
          me.destroyDatasetMeta(i);
        }

        if (canvas) {
          me.unbindEvents();
          helpers$1.canvas.clear(me);
          platform.releaseContext(me.ctx);
          me.canvas = null;
          me.ctx = null;
        }

        core_plugins.notify(me, 'destroy');
        delete Chart.instances[me.id];
      },
      toBase64Image: function () {
        return this.canvas.toDataURL.apply(this.canvas, arguments);
      },
      initToolTip: function () {
        var me = this;
        me.tooltip = new core_tooltip({
          _chart: me,
          _chartInstance: me,
          // deprecated, backward compatibility
          _data: me.data,
          _options: me.options.tooltips
        }, me);
      },

      /**
       * @private
       */
      bindEvents: function () {
        var me = this;
        var listeners = me._listeners = {};

        var listener = function () {
          me.eventHandler.apply(me, arguments);
        };

        helpers$1.each(me.options.events, function (type) {
          platform.addEventListener(me, type, listener);
          listeners[type] = listener;
        }); // Elements used to detect size change should not be injected for non responsive charts.
        // See https://github.com/chartjs/Chart.js/issues/2210

        if (me.options.responsive) {
          listener = function () {
            me.resize();
          };

          platform.addEventListener(me, 'resize', listener);
          listeners.resize = listener;
        }
      },

      /**
       * @private
       */
      unbindEvents: function () {
        var me = this;
        var listeners = me._listeners;

        if (!listeners) {
          return;
        }

        delete me._listeners;
        helpers$1.each(listeners, function (listener, type) {
          platform.removeEventListener(me, type, listener);
        });
      },
      updateHoverStyle: function (elements, mode, enabled) {
        var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
        var element, i, ilen;

        for (i = 0, ilen = elements.length; i < ilen; ++i) {
          element = elements[i];

          if (element) {
            this.getDatasetMeta(element._datasetIndex).controller[method](element);
          }
        }
      },

      /**
       * @private
       */
      eventHandler: function (e) {
        var me = this;
        var tooltip = me.tooltip;

        if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {
          return;
        } // Buffer any update calls so that renders do not occur


        me._bufferedRender = true;
        me._bufferedRequest = null;
        var changed = me.handleEvent(e); // for smooth tooltip animations issue #4989
        // the tooltip should be the source of change
        // Animation check workaround:
        // tooltip._start will be null when tooltip isn't animating

        if (tooltip) {
          changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
        }

        core_plugins.notify(me, 'afterEvent', [e]);
        var bufferedRequest = me._bufferedRequest;

        if (bufferedRequest) {
          // If we have an update that was triggered, we need to do a normal render
          me.render(bufferedRequest);
        } else if (changed && !me.animating) {
          // If entering, leaving, or changing elements, animate the change via pivot
          me.stop(); // We only need to render at this point. Updating will cause scales to be
          // recomputed generating flicker & using more memory than necessary.

          me.render({
            duration: me.options.hover.animationDuration,
            lazy: true
          });
        }

        me._bufferedRender = false;
        me._bufferedRequest = null;
        return me;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event the event to handle
       * @return {boolean} true if the chart needs to re-render
       */
      handleEvent: function (e) {
        var me = this;
        var options = me.options || {};
        var hoverOptions = options.hover;
        var changed = false;
        me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips

        if (e.type === 'mouseout') {
          me.active = [];
        } else {
          me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
        } // Invoke onHover hook
        // Need to call with native event here to not break backwards compatibility


        helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

        if (e.type === 'mouseup' || e.type === 'click') {
          if (options.onClick) {
            // Use e.native here for backwards compatibility
            options.onClick.call(me, e.native, me.active);
          }
        } // Remove styling for last active (even if it may still be active)


        if (me.lastActive.length) {
          me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
        } // Built in hover styling


        if (me.active.length && hoverOptions.mode) {
          me.updateHoverStyle(me.active, hoverOptions.mode, true);
        }

        changed = !helpers$1.arrayEquals(me.active, me.lastActive); // Remember Last Actives

        me.lastActive = me.active;
        return changed;
      }
    });
    /**
     * NOTE(SB) We actually don't use this container anymore but we need to keep it
     * for backward compatibility. Though, it can still be useful for plugins that
     * would need to work on multiple charts?!
     */

    Chart.instances = {};
    var core_controller = Chart; // DEPRECATIONS

    /**
     * Provided for backward compatibility, use Chart instead.
     * @class Chart.Controller
     * @deprecated since version 2.6
     * @todo remove at version 3
     * @private
     */

    Chart.Controller = Chart;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    Chart.types = {};
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.configMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.configMerge = mergeConfig;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.helpers.scaleMerge
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */

    helpers$1.scaleMerge = mergeScaleConfig;

    var core_helpers = function () {
      // -- Basic js utility methods
      helpers$1.where = function (collection, filterCallback) {
        if (helpers$1.isArray(collection) && Array.prototype.filter) {
          return collection.filter(filterCallback);
        }

        var filtered = [];
        helpers$1.each(collection, function (item) {
          if (filterCallback(item)) {
            filtered.push(item);
          }
        });
        return filtered;
      };

      helpers$1.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
        return array.findIndex(callback, scope);
      } : function (array, callback, scope) {
        scope = scope === undefined ? array : scope;

        for (var i = 0, ilen = array.length; i < ilen; ++i) {
          if (callback.call(scope, array[i], i, array)) {
            return i;
          }
        }

        return -1;
      };

      helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to start of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = -1;
        }

        for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      };

      helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
        // Default to end of the array
        if (helpers$1.isNullOrUndef(startIndex)) {
          startIndex = arrayToSearch.length;
        }

        for (var i = startIndex - 1; i >= 0; i--) {
          var currentItem = arrayToSearch[i];

          if (filterCallback(currentItem)) {
            return currentItem;
          }
        }
      }; // -- Math methods


      helpers$1.isNumber = function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      };

      helpers$1.almostEquals = function (x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      };

      helpers$1.almostWhole = function (x, epsilon) {
        var rounded = Math.round(x);
        return rounded - epsilon < x && rounded + epsilon > x;
      };

      helpers$1.max = function (array) {
        return array.reduce(function (max, value) {
          if (!isNaN(value)) {
            return Math.max(max, value);
          }

          return max;
        }, Number.NEGATIVE_INFINITY);
      };

      helpers$1.min = function (array) {
        return array.reduce(function (min, value) {
          if (!isNaN(value)) {
            return Math.min(min, value);
          }

          return min;
        }, Number.POSITIVE_INFINITY);
      };

      helpers$1.sign = Math.sign ? function (x) {
        return Math.sign(x);
      } : function (x) {
        x = +x; // convert to a number

        if (x === 0 || isNaN(x)) {
          return x;
        }

        return x > 0 ? 1 : -1;
      };
      helpers$1.log10 = Math.log10 ? function (x) {
        return Math.log10(x);
      } : function (x) {
        var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
        // Check for whole powers of 10,
        // which due to floating point rounding error should be corrected.

        var powerOf10 = Math.round(exponent);
        var isPowerOf10 = x === Math.pow(10, powerOf10);
        return isPowerOf10 ? powerOf10 : exponent;
      };

      helpers$1.toRadians = function (degrees) {
        return degrees * (Math.PI / 180);
      };

      helpers$1.toDegrees = function (radians) {
        return radians * (180 / Math.PI);
      };
      /**
       * Returns the number of decimal places
       * i.e. the number of digits after the decimal point, of the value of this Number.
       * @param {number} x - A number.
       * @returns {number} The number of decimal places.
       * @private
       */


      helpers$1._decimalPlaces = function (x) {
        if (!helpers$1.isFinite(x)) {
          return;
        }

        var e = 1;
        var p = 0;

        while (Math.round(x * e) / e !== x) {
          e *= 10;
          p++;
        }

        return p;
      }; // Gets the angle from vertical upright to the point about a centre.


      helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {
        var distanceFromXCenter = anglePoint.x - centrePoint.x;
        var distanceFromYCenter = anglePoint.y - centrePoint.y;
        var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

        if (angle < -0.5 * Math.PI) {
          angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
        }

        return {
          angle: angle,
          distance: radialDistanceFromCenter
        };
      };

      helpers$1.distanceBetweenPoints = function (pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      };
      /**
       * Provided for backward compatibility, not available anymore
       * @function Chart.helpers.aliasPixel
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       */


      helpers$1.aliasPixel = function (pixelWidth) {
        return pixelWidth % 2 === 0 ? 0 : 0.5;
      };
      /**
       * Returns the aligned pixel value to avoid anti-aliasing blur
       * @param {Chart} chart - The chart instance.
       * @param {number} pixel - A pixel value.
       * @param {number} width - The width of the element.
       * @returns {number} The aligned pixel value.
       * @private
       */


      helpers$1._alignPixel = function (chart, pixel, width) {
        var devicePixelRatio = chart.currentDevicePixelRatio;
        var halfWidth = width / 2;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
      };

      helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
        // Props to Rob Spencer at scaled innovation for his post on splining between points
        // http://scaledinnovation.com/analytics/splines/aboutSplines.html
        // This function must also respect "skipped" points
        var previous = firstPoint.skip ? middlePoint : firstPoint;
        var current = middlePoint;
        var next = afterPoint.skip ? middlePoint : afterPoint;
        var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
        var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
        var s01 = d01 / (d01 + d12);
        var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf

        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        var fa = t * s01; // scaling factor for triangle Ta

        var fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      };

      helpers$1.EPSILON = Number.EPSILON || 1e-14;

      helpers$1.splineCurveMonotone = function (points) {
        // This function calculates Bézier control points in a similar way than |splineCurve|,
        // but preserves monotonicity of the provided data and ensures no local extremums are added
        // between the dataset discrete points due to the interpolation.
        // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
        var pointsWithTangents = (points || []).map(function (point) {
          return {
            model: point._model,
            deltaK: 0,
            mK: 0
          };
        }); // Calculate slopes (deltaK) and initialize tangents (mK)

        var pointsLen = pointsWithTangents.length;
        var i, pointBefore, pointCurrent, pointAfter;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointAfter && !pointAfter.model.skip) {
            var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0

            pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
          }

          if (!pointBefore || pointBefore.model.skip) {
            pointCurrent.mK = pointCurrent.deltaK;
          } else if (!pointAfter || pointAfter.model.skip) {
            pointCurrent.mK = pointBefore.deltaK;
          } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
            pointCurrent.mK = 0;
          } else {
            pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
          }
        } // Adjust tangents to ensure monotonic properties


        var alphaK, betaK, tauK, squaredMagnitude;

        for (i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointsWithTangents[i];
          pointAfter = pointsWithTangents[i + 1];

          if (pointCurrent.model.skip || pointAfter.model.skip) {
            continue;
          }

          if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
            pointCurrent.mK = pointAfter.mK = 0;
            continue;
          }

          alphaK = pointCurrent.mK / pointCurrent.deltaK;
          betaK = pointAfter.mK / pointCurrent.deltaK;
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

          if (squaredMagnitude <= 9) {
            continue;
          }

          tauK = 3 / Math.sqrt(squaredMagnitude);
          pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
          pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
        } // Compute control points


        var deltaX;

        for (i = 0; i < pointsLen; ++i) {
          pointCurrent = pointsWithTangents[i];

          if (pointCurrent.model.skip) {
            continue;
          }

          pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
          pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

          if (pointBefore && !pointBefore.model.skip) {
            deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
            pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
            pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
          }

          if (pointAfter && !pointAfter.model.skip) {
            deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
            pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
            pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
          }
        }
      };

      helpers$1.nextItem = function (collection, index, loop) {
        if (loop) {
          return index >= collection.length - 1 ? collection[0] : collection[index + 1];
        }

        return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
      };

      helpers$1.previousItem = function (collection, index, loop) {
        if (loop) {
          return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
        }

        return index <= 0 ? collection[0] : collection[index - 1];
      }; // Implementation of the nice number algorithm used in determining where axis labels will go


      helpers$1.niceNum = function (range, round) {
        var exponent = Math.floor(helpers$1.log10(range));
        var fraction = range / Math.pow(10, exponent);
        var niceFraction;

        if (round) {
          if (fraction < 1.5) {
            niceFraction = 1;
          } else if (fraction < 3) {
            niceFraction = 2;
          } else if (fraction < 7) {
            niceFraction = 5;
          } else {
            niceFraction = 10;
          }
        } else if (fraction <= 1.0) {
          niceFraction = 1;
        } else if (fraction <= 2) {
          niceFraction = 2;
        } else if (fraction <= 5) {
          niceFraction = 5;
        } else {
          niceFraction = 10;
        }

        return niceFraction * Math.pow(10, exponent);
      }; // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/


      helpers$1.requestAnimFrame = function () {
        if (typeof window === 'undefined') {
          return function (callback) {
            callback();
          };
        }

        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
          return window.setTimeout(callback, 1000 / 60);
        };
      }(); // -- DOM methods


      helpers$1.getRelativePosition = function (evt, chart) {
        var mouseX, mouseY;
        var e = evt.originalEvent || evt;
        var canvas = evt.target || evt.srcElement;
        var boundingRect = canvas.getBoundingClientRect();
        var touches = e.touches;

        if (touches && touches.length > 0) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        } // Scale mouse coordinates into canvas coordinates
        // by following the pattern laid out by 'jerryj' in the comments of
        // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/


        var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));
        var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));
        var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));
        var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));
        var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
        var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
        // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here

        mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
        mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
        return {
          x: mouseX,
          y: mouseY
        };
      }; // Private helper function to convert max-width/max-height values that may be percentages into a number


      function parseMaxStyle(styleValue, node, parentProperty) {
        var valueInPixels;

        if (typeof styleValue === 'string') {
          valueInPixels = parseInt(styleValue, 10);

          if (styleValue.indexOf('%') !== -1) {
            // percentage * size in dimension
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }

        return valueInPixels;
      }
      /**
       * Returns if the given value contains an effective constraint.
       * @private
       */


      function isConstrainedValue(value) {
        return value !== undefined && value !== null && value !== 'none';
      }
      /**
       * Returns the max width or height of the given DOM node in a cross-browser compatible fashion
       * @param {HTMLElement} domNode - the node to check the constraint on
       * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')
       * @param {string} percentageProperty - property of parent to use when calculating width as a percentage
       * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}
       */


      function getConstraintDimension(domNode, maxStyle, percentageProperty) {
        var view = document.defaultView;

        var parentNode = helpers$1._getParentNode(domNode);

        var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
        var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
        var hasCNode = isConstrainedValue(constrainedNode);
        var hasCContainer = isConstrainedValue(constrainedContainer);
        var infinity = Number.POSITIVE_INFINITY;

        if (hasCNode || hasCContainer) {
          return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
        }

        return 'none';
      } // returns Number or undefined if no constraint


      helpers$1.getConstraintWidth = function (domNode) {
        return getConstraintDimension(domNode, 'max-width', 'clientWidth');
      }; // returns Number or undefined if no constraint


      helpers$1.getConstraintHeight = function (domNode) {
        return getConstraintDimension(domNode, 'max-height', 'clientHeight');
      };
      /**
       * @private
      	 */


      helpers$1._calculatePadding = function (container, padding, parentDimension) {
        padding = helpers$1.getStyle(container, padding);
        return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
      };
      /**
       * @private
       */


      helpers$1._getParentNode = function (domNode) {
        var parent = domNode.parentNode;

        if (parent && parent.toString() === '[object ShadowRoot]') {
          parent = parent.host;
        }

        return parent;
      };

      helpers$1.getMaximumWidth = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientWidth;
        }

        var clientWidth = container.clientWidth;

        var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);

        var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);

        var w = clientWidth - paddingLeft - paddingRight;
        var cw = helpers$1.getConstraintWidth(domNode);
        return isNaN(cw) ? w : Math.min(w, cw);
      };

      helpers$1.getMaximumHeight = function (domNode) {
        var container = helpers$1._getParentNode(domNode);

        if (!container) {
          return domNode.clientHeight;
        }

        var clientHeight = container.clientHeight;

        var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);

        var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);

        var h = clientHeight - paddingTop - paddingBottom;
        var ch = helpers$1.getConstraintHeight(domNode);
        return isNaN(ch) ? h : Math.min(h, ch);
      };

      helpers$1.getStyle = function (el, property) {
        return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
      };

      helpers$1.retinaScale = function (chart, forceRatio) {
        var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;

        if (pixelRatio === 1) {
          return;
        }

        var canvas = chart.canvas;
        var height = chart.height;
        var width = chart.width;
        canvas.height = height * pixelRatio;
        canvas.width = width * pixelRatio;
        chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,
        // making the chart visually bigger, so let's enforce it to the "correct" values.
        // See https://github.com/chartjs/Chart.js/issues/3575

        if (!canvas.style.height && !canvas.style.width) {
          canvas.style.height = height + 'px';
          canvas.style.width = width + 'px';
        }
      }; // -- Canvas methods


      helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {
        return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
      };

      helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        var data = cache.data = cache.data || {};
        var gc = cache.garbageCollect = cache.garbageCollect || [];

        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }

        ctx.font = font;
        var longest = 0;
        helpers$1.each(arrayOfThings, function (thing) {
          // Undefined strings and arrays should not be measured
          if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
            longest = helpers$1.measureText(ctx, data, gc, longest, thing);
          } else if (helpers$1.isArray(thing)) {
            // if it is an array lets measure each element
            // to do maybe simplify this function a bit so we can do this more recursively?
            helpers$1.each(thing, function (nestedThing) {
              // Undefined strings and arrays should not be measured
              if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
              }
            });
          }
        });
        var gcLen = gc.length / 2;

        if (gcLen > arrayOfThings.length) {
          for (var i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }

          gc.splice(0, gcLen);
        }

        return longest;
      };

      helpers$1.measureText = function (ctx, data, gc, longest, string) {
        var textWidth = data[string];

        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
        }

        if (textWidth > longest) {
          longest = textWidth;
        }

        return longest;
      };

      helpers$1.numberOfLabelLines = function (arrayOfThings) {
        var numberOfLines = 1;
        helpers$1.each(arrayOfThings, function (thing) {
          if (helpers$1.isArray(thing)) {
            if (thing.length > numberOfLines) {
              numberOfLines = thing.length;
            }
          }
        });
        return numberOfLines;
      };

      helpers$1.color = !chartjsColor ? function (value) {
        console.error('Color.js not found!');
        return value;
      } : function (value) {
        /* global CanvasGradient */
        if (value instanceof CanvasGradient) {
          value = core_defaults.global.defaultColor;
        }

        return chartjsColor(value);
      };

      helpers$1.getHoverColor = function (colorValue) {
        /* global CanvasPattern */
        return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
      };
    };

    function abstract() {
      throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');
    }
    /**
     * Date adapter (current used by the time scale)
     * @namespace Chart._adapters._date
     * @memberof Chart._adapters
     * @private
     */

    /**
     * Currently supported unit string values.
     * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}
     * @memberof Chart._adapters._date
     * @name Unit
     */

    /**
     * @class
     */


    function DateAdapter(options) {
      this.options = options || {};
    }

    helpers$1.extend(DateAdapter.prototype,
    /** @lends DateAdapter */
    {
      /**
       * Returns a map of time formats for the supported formatting units defined
       * in Unit as well as 'datetime' representing a detailed date/time string.
       * @returns {{string: string}}
       */
      formats: abstract,

      /**
       * Parses the given `value` and return the associated timestamp.
       * @param {any} value - the value to parse (usually comes from the data)
       * @param {string} [format] - the expected data format
       * @returns {(number|null)}
       * @function
       */
      parse: abstract,

      /**
       * Returns the formatted date in the specified `format` for a given `timestamp`.
       * @param {number} timestamp - the timestamp to format
       * @param {string} format - the date/time token
       * @return {string}
       * @function
       */
      format: abstract,

      /**
       * Adds the specified `amount` of `unit` to the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {number} amount - the amount to add
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      add: abstract,

      /**
       * Returns the number of `unit` between the given timestamps.
       * @param {number} max - the input timestamp (reference)
       * @param {number} min - the timestamp to substract
       * @param {Unit} unit - the unit as string
       * @return {number}
       * @function
       */
      diff: abstract,

      /**
       * Returns start of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @param {number} [weekday] - the ISO day of the week with 1 being Monday
       * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
       * @function
       */
      startOf: abstract,

      /**
       * Returns end of `unit` for the given `timestamp`.
       * @param {number} timestamp - the input timestamp
       * @param {Unit} unit - the unit as string
       * @function
       */
      endOf: abstract,
      // DEPRECATIONS

      /**
       * Provided for backward compatibility for scale.getValueForPixel(),
       * this method should be overridden only by the moment adapter.
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (value) {
        return value;
      }
    });

    DateAdapter.override = function (members) {
      helpers$1.extend(DateAdapter.prototype, members);
    };

    var _date = DateAdapter;
    var core_adapters = {
      _date: _date
    };
    /**
     * Namespace to hold static tick generation functions
     * @namespace Chart.Ticks
     */

    var core_ticks = {
      /**
       * Namespace to hold formatters for different types of ticks
       * @namespace Chart.Ticks.formatters
       */
      formatters: {
        /**
         * Formatter for value labels
         * @method Chart.Ticks.formatters.values
         * @param value the value to display
         * @return {string|string[]} the label to display
         */
        values: function (value) {
          return helpers$1.isArray(value) ? value : '' + value;
        },

        /**
         * Formatter for linear numeric ticks
         * @method Chart.Ticks.formatters.linear
         * @param tickValue {number} the value to be formatted
         * @param index {number} the position of the tickValue parameter in the ticks array
         * @param ticks {number[]} the list of ticks being converted
         * @return {string} string representation of the tickValue parameter
         */
        linear: function (tickValue, index, ticks) {
          // If we have lots of ticks, don't use the ones
          var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need

          if (Math.abs(delta) > 1) {
            if (tickValue !== Math.floor(tickValue)) {
              // not an integer
              delta = tickValue - Math.floor(tickValue);
            }
          }

          var logDelta = helpers$1.log10(Math.abs(delta));
          var tickString = '';

          if (tickValue !== 0) {
            var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));

            if (maxTick < 1e-4) {
              // all ticks are small numbers; use scientific notation
              var logTick = helpers$1.log10(Math.abs(tickValue));
              tickString = tickValue.toExponential(Math.floor(logTick) - Math.floor(logDelta));
            } else {
              var numDecimal = -1 * Math.floor(logDelta);
              numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places

              tickString = tickValue.toFixed(numDecimal);
            }
          } else {
            tickString = '0'; // never show decimal places for 0
          }

          return tickString;
        },
        logarithmic: function (tickValue, index, ticks) {
          var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));

          if (tickValue === 0) {
            return '0';
          } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
            return tickValue.toExponential();
          }

          return '';
        }
      }
    };
    var valueOrDefault$9 = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;

    core_defaults._set('scale', {
      display: true,
      position: 'left',
      offset: false,
      // grid line settings
      gridLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        drawBorder: true,
        drawOnChartArea: true,
        drawTicks: true,
        tickMarkLength: 10,
        zeroLineWidth: 1,
        zeroLineColor: 'rgba(0,0,0,0.25)',
        zeroLineBorderDash: [],
        zeroLineBorderDashOffset: 0.0,
        offsetGridLines: false,
        borderDash: [],
        borderDashOffset: 0.0
      },
      // scale label
      scaleLabel: {
        // display property
        display: false,
        // actual label
        labelString: '',
        // top/bottom padding
        padding: {
          top: 4,
          bottom: 4
        }
      },
      // label settings
      ticks: {
        beginAtZero: false,
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        padding: 0,
        reverse: false,
        display: true,
        autoSkip: true,
        autoSkipPadding: 0,
        labelOffset: 0,
        // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
        callback: core_ticks.formatters.values,
        minor: {},
        major: {}
      }
    });

    function labelsFromTicks(ticks) {
      var labels = [];
      var i, ilen;

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        labels.push(ticks[i].label);
      }

      return labels;
    }

    function getPixelForGridLine(scale, index, offsetGridLines) {
      var lineValue = scale.getPixelForTick(index);

      if (offsetGridLines) {
        if (scale.getTicks().length === 1) {
          lineValue -= scale.isHorizontal() ? Math.max(lineValue - scale.left, scale.right - lineValue) : Math.max(lineValue - scale.top, scale.bottom - lineValue);
        } else if (index === 0) {
          lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
        } else {
          lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
        }
      }

      return lineValue;
    }

    function computeTextSize(context, tick, font) {
      return helpers$1.isArray(tick) ? helpers$1.longestText(context, font, tick) : context.measureText(tick).width;
    }

    var core_scale = core_element.extend({
      /**
       * Get the padding needed for the scale
       * @method getPadding
       * @private
       * @returns {Padding} the necessary padding
       */
      getPadding: function () {
        var me = this;
        return {
          left: me.paddingLeft || 0,
          top: me.paddingTop || 0,
          right: me.paddingRight || 0,
          bottom: me.paddingBottom || 0
        };
      },

      /**
       * Returns the scale tick objects ({label, major})
       * @since 2.7
       */
      getTicks: function () {
        return this._ticks;
      },
      // These methods are ordered by lifecyle. Utilities then follow.
      // Any function defined here is inherited by all scale types.
      // Any function can be extended by the scale type
      mergeTicksOptions: function () {
        var ticks = this.options.ticks;

        if (ticks.minor === false) {
          ticks.minor = {
            display: false
          };
        }

        if (ticks.major === false) {
          ticks.major = {
            display: false
          };
        }

        for (var key in ticks) {
          if (key !== 'major' && key !== 'minor') {
            if (typeof ticks.minor[key] === 'undefined') {
              ticks.minor[key] = ticks[key];
            }

            if (typeof ticks.major[key] === 'undefined') {
              ticks.major[key] = ticks[key];
            }
          }
        }
      },
      beforeUpdate: function () {
        helpers$1.callback(this.options.beforeUpdate, [this]);
      },
      update: function (maxWidth, maxHeight, margins) {
        var me = this;
        var i, ilen, labels, label, ticks, tick; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = helpers$1.extend({
          left: 0,
          right: 0,
          top: 0,
          bottom: 0
        }, margins);
        me._maxLabelLines = 0;
        me.longestLabelWidth = 0;
        me.longestTextCache = me.longestTextCache || {}; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Data min/max

        me.beforeDataLimits();
        me.determineDataLimits();
        me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!
        // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
        // and must not be accessed directly from outside this class. `this.ticks` being
        // around for long time and not marked as private, we can't change its structure
        // without unexpected breaking changes. If you need to access the scale ticks,
        // use scale.getTicks() instead.

        me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,
        // we still support no return (`this.ticks` internally set by calling this method).

        ticks = me.buildTicks() || []; // Allow modification of ticks in callback.

        ticks = me.afterBuildTicks(ticks) || ticks;
        me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD
        // COMPAT, we still support no return (`this.ticks` internally changed by calling
        // this method and supposed to contain only string values).

        labels = me.convertTicksToLabels(ticks) || me.ticks;
        me.afterTickToLabelConversion();
        me.ticks = labels; // BACKWARD COMPATIBILITY
        // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!
        // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)

        for (i = 0, ilen = labels.length; i < ilen; ++i) {
          label = labels[i];
          tick = ticks[i];

          if (!tick) {
            ticks.push(tick = {
              label: label,
              major: false
            });
          } else {
            tick.label = label;
          }
        }

        me._ticks = ticks; // Tick Rotation

        me.beforeCalculateTickRotation();
        me.calculateTickRotation();
        me.afterCalculateTickRotation(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: function () {
        helpers$1.callback(this.options.afterUpdate, [this]);
      },
      //
      beforeSetDimensions: function () {
        helpers$1.callback(this.options.beforeSetDimensions, [this]);
      },
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0;
      },
      afterSetDimensions: function () {
        helpers$1.callback(this.options.afterSetDimensions, [this]);
      },
      // Data limits
      beforeDataLimits: function () {
        helpers$1.callback(this.options.beforeDataLimits, [this]);
      },
      determineDataLimits: helpers$1.noop,
      afterDataLimits: function () {
        helpers$1.callback(this.options.afterDataLimits, [this]);
      },
      //
      beforeBuildTicks: function () {
        helpers$1.callback(this.options.beforeBuildTicks, [this]);
      },
      buildTicks: helpers$1.noop,
      afterBuildTicks: function (ticks) {
        var me = this; // ticks is empty for old axis implementations here

        if (helpers$1.isArray(ticks) && ticks.length) {
          return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
        } // Support old implementations (that modified `this.ticks` directly in buildTicks)


        me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
        return ticks;
      },
      beforeTickToLabelConversion: function () {
        helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
      },
      convertTicksToLabels: function () {
        var me = this; // Convert ticks to strings

        var tickOpts = me.options.ticks;
        me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
      },
      afterTickToLabelConversion: function () {
        helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
      },
      //
      beforeCalculateTickRotation: function () {
        helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
      },
      calculateTickRotation: function () {
        var me = this;
        var context = me.ctx;
        var tickOpts = me.options.ticks;
        var labels = labelsFromTicks(me._ticks); // Get the width of each grid by calculating the difference
        // between x offsets between 0 and 1.

        var tickFont = helpers$1.options._parseFont(tickOpts);

        context.font = tickFont.string;
        var labelRotation = tickOpts.minRotation || 0;

        if (labels.length && me.options.display && me.isHorizontal()) {
          var originalLabelWidth = helpers$1.longestText(context, tickFont.string, labels, me.longestTextCache);
          var labelWidth = originalLabelWidth;
          var cosRotation, sinRotation; // Allow 3 pixels x2 padding either side for label readability

          var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter

          while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
            var angleRadians = helpers$1.toRadians(labelRotation);
            cosRotation = Math.cos(angleRadians);
            sinRotation = Math.sin(angleRadians);

            if (sinRotation * originalLabelWidth > me.maxHeight) {
              // go back one step
              labelRotation--;
              break;
            }

            labelRotation++;
            labelWidth = cosRotation * originalLabelWidth;
          }
        }

        me.labelRotation = labelRotation;
      },
      afterCalculateTickRotation: function () {
        helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
      },
      //
      beforeFit: function () {
        helpers$1.callback(this.options.beforeFit, [this]);
      },
      fit: function () {
        var me = this; // Reset

        var minSize = me.minSize = {
          width: 0,
          height: 0
        };
        var labels = labelsFromTicks(me._ticks);
        var opts = me.options;
        var tickOpts = opts.ticks;
        var scaleLabelOpts = opts.scaleLabel;
        var gridLineOpts = opts.gridLines;

        var display = me._isVisible();

        var position = opts.position;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var tickFont = parseFont(tickOpts);
        var tickMarkLength = opts.gridLines.tickMarkLength; // Width

        if (isHorizontal) {
          // subtract the margins to line up with the chartArea if we are a full width scale
          minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
        } else {
          minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } // height


        if (isHorizontal) {
          minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
        } else {
          minSize.height = me.maxHeight; // fill all the height
        } // Are we showing a title for the scale?


        if (scaleLabelOpts.display && display) {
          var scaleLabelFont = parseFont(scaleLabelOpts);
          var scaleLabelPadding = helpers$1.options.toPadding(scaleLabelOpts.padding);
          var deltaHeight = scaleLabelFont.lineHeight + scaleLabelPadding.height;

          if (isHorizontal) {
            minSize.height += deltaHeight;
          } else {
            minSize.width += deltaHeight;
          }
        } // Don't bother fitting the ticks if we are not showing the labels


        if (tickOpts.display && display) {
          var largestTextWidth = helpers$1.longestText(me.ctx, tickFont.string, labels, me.longestTextCache);
          var tallestLabelHeightInLines = helpers$1.numberOfLabelLines(labels);
          var lineSpace = tickFont.size * 0.5;
          var tickPadding = me.options.ticks.padding; // Store max number of lines and widest label for _autoSkip

          me._maxLabelLines = tallestLabelHeightInLines;
          me.longestLabelWidth = largestTextWidth;

          if (isHorizontal) {
            var angleRadians = helpers$1.toRadians(me.labelRotation);
            var cosRotation = Math.cos(angleRadians);
            var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation

            var labelHeight = sinRotation * largestTextWidth + tickFont.lineHeight * tallestLabelHeightInLines + lineSpace; // padding

            minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
            me.ctx.font = tickFont.string;
            var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.string);
            var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.string);
            var offsetLeft = me.getPixelForTick(0) - me.left;
            var offsetRight = me.right - me.getPixelForTick(labels.length - 1);
            var paddingLeft, paddingRight; // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
            // which means that the right padding is dominated by the font height

            if (me.labelRotation !== 0) {
              paddingLeft = position === 'bottom' ? cosRotation * firstLabelWidth : cosRotation * lineSpace;
              paddingRight = position === 'bottom' ? cosRotation * lineSpace : cosRotation * lastLabelWidth;
            } else {
              paddingLeft = firstLabelWidth / 2;
              paddingRight = lastLabelWidth / 2;
            }

            me.paddingLeft = Math.max(paddingLeft - offsetLeft, 0) + 3; // add 3 px to move away from canvas edges

            me.paddingRight = Math.max(paddingRight - offsetRight, 0) + 3;
          } else {
            // A vertical axis is more constrained by the width. Labels are the
            // dominant factor here, so get that length first and account for padding
            if (tickOpts.mirror) {
              largestTextWidth = 0;
            } else {
              // use lineSpace for consistency with horizontal axis
              // tickPadding is not implemented for horizontal
              largestTextWidth += tickPadding + lineSpace;
            }

            minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
            me.paddingTop = tickFont.size / 2;
            me.paddingBottom = tickFont.size / 2;
          }
        }

        me.handleMargins();
        me.width = minSize.width;
        me.height = minSize.height;
      },

      /**
       * Handle margins and padding interactions
       * @private
       */
      handleMargins: function () {
        var me = this;

        if (me.margins) {
          me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
          me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
          me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
          me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
        }
      },
      afterFit: function () {
        helpers$1.callback(this.options.afterFit, [this]);
      },
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      isFullWidth: function () {
        return this.options.fullWidth;
      },
      // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
      getRightValue: function (rawValue) {
        // Null and undefined values first
        if (helpers$1.isNullOrUndef(rawValue)) {
          return NaN;
        } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values


        if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {
          return NaN;
        } // If it is in fact an object, dive in one more level


        if (rawValue) {
          if (this.isHorizontal()) {
            if (rawValue.x !== undefined) {
              return this.getRightValue(rawValue.x);
            }
          } else if (rawValue.y !== undefined) {
            return this.getRightValue(rawValue.y);
          }
        } // Value is good, return it


        return rawValue;
      },

      /**
       * Used to get the value to display in the tooltip for the data at the given index
       * @param index
       * @param datasetIndex
       */
      getLabelForIndex: helpers$1.noop,

      /**
       * Returns the location of the given data point. Value can either be an index or a numerical value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param value
       * @param index
       * @param datasetIndex
       */
      getPixelForValue: helpers$1.noop,

      /**
       * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       * @param pixel
       */
      getValueForPixel: helpers$1.noop,

      /**
       * Returns the location of the tick at the given index
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForTick: function (index) {
        var me = this;
        var offset = me.options.offset;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);
          var pixel = tickWidth * index + me.paddingLeft;

          if (offset) {
            pixel += tickWidth / 2;
          }

          var finalVal = me.left + pixel;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
        return me.top + index * (innerHeight / (me._ticks.length - 1));
      },

      /**
       * Utility for getting the pixel location of a percentage of scale
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getPixelForDecimal: function (decimal) {
        var me = this;

        if (me.isHorizontal()) {
          var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
          var valueOffset = innerWidth * decimal + me.paddingLeft;
          var finalVal = me.left + valueOffset;
          finalVal += me.isFullWidth() ? me.margins.left : 0;
          return finalVal;
        }

        return me.top + decimal * me.height;
      },

      /**
       * Returns the pixel for the minimum chart value
       * The coordinate (0, 0) is at the upper-left corner of the canvas
       */
      getBasePixel: function () {
        return this.getPixelForValue(this.getBaseValue());
      },
      getBaseValue: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
      },

      /**
       * Returns a subset of ticks to be plotted to avoid overlapping labels.
       * @private
       */
      _autoSkip: function (ticks) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor;
        var tickCount = ticks.length;
        var skipRatio = false;
        var maxTicks = optionTicks.maxTicksLimit; // Total space needed to display all ticks. First and last ticks are
        // drawn as their center at end of axis, so tickCount-1

        var ticksLength = me._tickSize() * (tickCount - 1); // Axis length

        var axisLength = isHorizontal ? me.width - (me.paddingLeft + me.paddingRight) : me.height - (me.paddingTop + me.PaddingBottom);
        var result = [];
        var i, tick;

        if (ticksLength > axisLength) {
          skipRatio = 1 + Math.floor(ticksLength / axisLength);
        } // if they defined a max number of optionTicks,
        // increase skipRatio until that number is met


        if (tickCount > maxTicks) {
          skipRatio = Math.max(skipRatio, 1 + Math.floor(tickCount / maxTicks));
        }

        for (i = 0; i < tickCount; i++) {
          tick = ticks[i];

          if (skipRatio > 1 && i % skipRatio > 0) {
            // leave tick in place but make sure it's not displayed (#4635)
            delete tick.label;
          }

          result.push(tick);
        }

        return result;
      },

      /**
       * @private
       */
      _tickSize: function () {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var optionTicks = me.options.ticks.minor; // Calculate space needed by label in axis direction.

        var rot = helpers$1.toRadians(me.labelRotation);
        var cos = Math.abs(Math.cos(rot));
        var sin = Math.abs(Math.sin(rot));
        var padding = optionTicks.autoSkipPadding || 0;
        var w = me.longestLabelWidth + padding || 0;

        var tickFont = helpers$1.options._parseFont(optionTicks);

        var h = me._maxLabelLines * tickFont.lineHeight + padding || 0; // Calculate space needed for 1 tick in axis direction.

        return isHorizontal ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
      },

      /**
       * @private
       */
      _isVisible: function () {
        var me = this;
        var chart = me.chart;
        var display = me.options.display;
        var i, ilen, meta;

        if (display !== 'auto') {
          return !!display;
        } // When 'auto', the scale is visible if at least one associated dataset is visible.


        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);

            if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
              return true;
            }
          }
        }

        return false;
      },

      /**
       * Actually draw the scale on the canvas
       * @param {object} chartArea - the area of the chart to draw full grid lines on
       */
      draw: function (chartArea) {
        var me = this;
        var options = me.options;

        if (!me._isVisible()) {
          return;
        }

        var chart = me.chart;
        var context = me.ctx;
        var globalDefaults = core_defaults.global;
        var defaultFontColor = globalDefaults.defaultFontColor;
        var optionTicks = options.ticks.minor;
        var optionMajorTicks = options.ticks.major || optionTicks;
        var gridLines = options.gridLines;
        var scaleLabel = options.scaleLabel;
        var position = options.position;
        var isRotated = me.labelRotation !== 0;
        var isMirrored = optionTicks.mirror;
        var isHorizontal = me.isHorizontal();
        var parseFont = helpers$1.options._parseFont;
        var ticks = optionTicks.display && optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
        var tickFontColor = valueOrDefault$9(optionTicks.fontColor, defaultFontColor);
        var tickFont = parseFont(optionTicks);
        var lineHeight = tickFont.lineHeight;
        var majorTickFontColor = valueOrDefault$9(optionMajorTicks.fontColor, defaultFontColor);
        var majorTickFont = parseFont(optionMajorTicks);
        var tickPadding = optionTicks.padding;
        var labelOffset = optionTicks.labelOffset;
        var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
        var scaleLabelFontColor = valueOrDefault$9(scaleLabel.fontColor, defaultFontColor);
        var scaleLabelFont = parseFont(scaleLabel);
        var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
        var labelRotationRadians = helpers$1.toRadians(me.labelRotation);
        var itemsToDraw = [];
        var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
        var alignPixel = helpers$1._alignPixel;
        var borderValue, tickStart, tickEnd;

        if (position === 'top') {
          borderValue = alignPixel(chart, me.bottom, axisWidth);
          tickStart = me.bottom - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else if (position === 'bottom') {
          borderValue = alignPixel(chart, me.top, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.top + tl;
        } else if (position === 'left') {
          borderValue = alignPixel(chart, me.right, axisWidth);
          tickStart = me.right - tl;
          tickEnd = borderValue - axisWidth / 2;
        } else {
          borderValue = alignPixel(chart, me.left, axisWidth);
          tickStart = borderValue + axisWidth / 2;
          tickEnd = me.left + tl;
        }

        var epsilon = 0.0000001; // 0.0000001 is margin in pixels for Accumulated error.

        helpers$1.each(ticks, function (tick, index) {
          // autoskipper skipped this tick (#4635)
          if (helpers$1.isNullOrUndef(tick.label)) {
            return;
          }

          var label = tick.label;
          var lineWidth, lineColor, borderDash, borderDashOffset;

          if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
            // Draw the first index specially
            lineWidth = gridLines.zeroLineWidth;
            lineColor = gridLines.zeroLineColor;
            borderDash = gridLines.zeroLineBorderDash || [];
            borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;
          } else {
            lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, index);
            lineColor = valueAtIndexOrDefault(gridLines.color, index);
            borderDash = gridLines.borderDash || [];
            borderDashOffset = gridLines.borderDashOffset || 0.0;
          } // Common properties


          var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY, textOffset, textAlign;
          var labelCount = helpers$1.isArray(label) ? label.length : 1;
          var lineValue = getPixelForGridLine(me, index, gridLines.offsetGridLines);

          if (isHorizontal) {
            var labelYOffset = tl + tickPadding;

            if (lineValue < me.left - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tx2 = x1 = x2 = alignPixel(chart, lineValue, lineWidth);
            ty1 = tickStart;
            ty2 = tickEnd;
            labelX = me.getPixelForTick(index) + labelOffset; // x values for optionTicks (need to consider offsetLabel option)

            if (position === 'top') {
              y1 = alignPixel(chart, chartArea.top, axisWidth) + axisWidth / 2;
              y2 = chartArea.bottom;
              textOffset = ((!isRotated ? 0.5 : 1) - labelCount) * lineHeight;
              textAlign = !isRotated ? 'center' : 'left';
              labelY = me.bottom - labelYOffset;
            } else {
              y1 = chartArea.top;
              y2 = alignPixel(chart, chartArea.bottom, axisWidth) - axisWidth / 2;
              textOffset = (!isRotated ? 0.5 : 0) * lineHeight;
              textAlign = !isRotated ? 'center' : 'right';
              labelY = me.top + labelYOffset;
            }
          } else {
            var labelXOffset = (isMirrored ? 0 : tl) + tickPadding;

            if (lineValue < me.top - epsilon) {
              lineColor = 'rgba(0,0,0,0)';
            }

            tx1 = tickStart;
            tx2 = tickEnd;
            ty1 = ty2 = y1 = y2 = alignPixel(chart, lineValue, lineWidth);
            labelY = me.getPixelForTick(index) + labelOffset;
            textOffset = (1 - labelCount) * lineHeight / 2;

            if (position === 'left') {
              x1 = alignPixel(chart, chartArea.left, axisWidth) + axisWidth / 2;
              x2 = chartArea.right;
              textAlign = isMirrored ? 'left' : 'right';
              labelX = me.right - labelXOffset;
            } else {
              x1 = chartArea.left;
              x2 = alignPixel(chart, chartArea.right, axisWidth) - axisWidth / 2;
              textAlign = isMirrored ? 'right' : 'left';
              labelX = me.left + labelXOffset;
            }
          }

          itemsToDraw.push({
            tx1: tx1,
            ty1: ty1,
            tx2: tx2,
            ty2: ty2,
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            labelX: labelX,
            labelY: labelY,
            glWidth: lineWidth,
            glColor: lineColor,
            glBorderDash: borderDash,
            glBorderDashOffset: borderDashOffset,
            rotation: -1 * labelRotationRadians,
            label: label,
            major: tick.major,
            textOffset: textOffset,
            textAlign: textAlign
          });
        }); // Draw all of the tick labels, tick marks, and grid lines at the correct places

        helpers$1.each(itemsToDraw, function (itemToDraw) {
          var glWidth = itemToDraw.glWidth;
          var glColor = itemToDraw.glColor;

          if (gridLines.display && glWidth && glColor) {
            context.save();
            context.lineWidth = glWidth;
            context.strokeStyle = glColor;

            if (context.setLineDash) {
              context.setLineDash(itemToDraw.glBorderDash);
              context.lineDashOffset = itemToDraw.glBorderDashOffset;
            }

            context.beginPath();

            if (gridLines.drawTicks) {
              context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
              context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
            }

            if (gridLines.drawOnChartArea) {
              context.moveTo(itemToDraw.x1, itemToDraw.y1);
              context.lineTo(itemToDraw.x2, itemToDraw.y2);
            }

            context.stroke();
            context.restore();
          }

          if (optionTicks.display) {
            // Make sure we draw text in the correct color and font
            context.save();
            context.translate(itemToDraw.labelX, itemToDraw.labelY);
            context.rotate(itemToDraw.rotation);
            context.font = itemToDraw.major ? majorTickFont.string : tickFont.string;
            context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
            context.textBaseline = 'middle';
            context.textAlign = itemToDraw.textAlign;
            var label = itemToDraw.label;
            var y = itemToDraw.textOffset;

            if (helpers$1.isArray(label)) {
              for (var i = 0; i < label.length; ++i) {
                // We just make sure the multiline element is a string here..
                context.fillText('' + label[i], 0, y);
                y += lineHeight;
              }
            } else {
              context.fillText(label, 0, y);
            }

            context.restore();
          }
        });

        if (scaleLabel.display) {
          // Draw the scale label
          var scaleLabelX;
          var scaleLabelY;
          var rotation = 0;
          var halfLineHeight = scaleLabelFont.lineHeight / 2;

          if (isHorizontal) {
            scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width

            scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
          } else {
            var isLeft = position === 'left';
            scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
            scaleLabelY = me.top + (me.bottom - me.top) / 2;
            rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
          }

          context.save();
          context.translate(scaleLabelX, scaleLabelY);
          context.rotate(rotation);
          context.textAlign = 'center';
          context.textBaseline = 'middle';
          context.fillStyle = scaleLabelFontColor; // render in correct colour

          context.font = scaleLabelFont.string;
          context.fillText(scaleLabel.labelString, 0, 0);
          context.restore();
        }

        if (axisWidth) {
          // Draw the line at the edge of the axis
          var firstLineWidth = axisWidth;
          var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, ticks.length - 1, 0);
          var x1, x2, y1, y2;

          if (isHorizontal) {
            x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
            x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
            y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }

          context.lineWidth = axisWidth;
          context.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
          context.beginPath();
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
          context.stroke();
        }
      }
    });
    var defaultConfig = {
      position: 'bottom'
    };
    var scale_category = core_scale.extend({
      /**
      * Internal function to get the correct labels. If data.xLabels or data.yLabels are defined, use those
      * else fall back to data.labels
      * @private
      */
      getLabels: function () {
        var data = this.chart.data;
        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
      },
      determineDataLimits: function () {
        var me = this;
        var labels = me.getLabels();
        me.minIndex = 0;
        me.maxIndex = labels.length - 1;
        var findIndex;

        if (me.options.ticks.min !== undefined) {
          // user specified min value
          findIndex = labels.indexOf(me.options.ticks.min);
          me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
        }

        if (me.options.ticks.max !== undefined) {
          // user specified max value
          findIndex = labels.indexOf(me.options.ticks.max);
          me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
        }

        me.min = labels[me.minIndex];
        me.max = labels[me.maxIndex];
      },
      buildTicks: function () {
        var me = this;
        var labels = me.getLabels(); // If we are viewing some subset of labels, slice the original array

        me.ticks = me.minIndex === 0 && me.maxIndex === labels.length - 1 ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var chart = me.chart;

        if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
          return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
        }

        return me.ticks[index - me.minIndex];
      },
      // Used to get data value locations.  Value can either be an index or a numerical value
      getPixelForValue: function (value, index) {
        var me = this;
        var offset = me.options.offset; // 1 is added because we need the length but we have the indexes

        var offsetAmt = Math.max(me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1), 1); // If value is a data object, then index is the index in the data array,
        // not the index of the scale. We need to change that.

        var valueCategory;

        if (value !== undefined && value !== null) {
          valueCategory = me.isHorizontal() ? value.x : value.y;
        }

        if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
          var labels = me.getLabels();
          value = valueCategory || value;
          var idx = labels.indexOf(value);
          index = idx !== -1 ? idx : index;
        }

        if (me.isHorizontal()) {
          var valueWidth = me.width / offsetAmt;
          var widthOffset = valueWidth * (index - me.minIndex);

          if (offset) {
            widthOffset += valueWidth / 2;
          }

          return me.left + widthOffset;
        }

        var valueHeight = me.height / offsetAmt;
        var heightOffset = valueHeight * (index - me.minIndex);

        if (offset) {
          heightOffset += valueHeight / 2;
        }

        return me.top + heightOffset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var offset = me.options.offset;
        var value;
        var offsetAmt = Math.max(me._ticks.length - (offset ? 0 : 1), 1);
        var horz = me.isHorizontal();
        var valueDimension = (horz ? me.width : me.height) / offsetAmt;
        pixel -= horz ? me.left : me.top;

        if (offset) {
          pixel -= valueDimension / 2;
        }

        if (pixel <= 0) {
          value = 0;
        } else {
          value = Math.round(pixel / valueDimension);
        }

        return value + me.minIndex;
      },
      getBasePixel: function () {
        return this.bottom;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults = defaultConfig;
    scale_category._defaults = _defaults;
    var noop = helpers$1.noop;
    var isNullOrUndef = helpers$1.isNullOrUndef;
    /**
     * Generate a set of linear ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks(generationOptions, dataRange) {
      var ticks = []; // To get a "nice" value for the tick spacing, we will use the appropriately named
      // "nice number" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
      // for details.

      var MIN_SPACING = 1e-14;
      var stepSize = generationOptions.stepSize;
      var unit = stepSize || 1;
      var maxNumSpaces = generationOptions.maxTicks - 1;
      var min = generationOptions.min;
      var max = generationOptions.max;
      var precision = generationOptions.precision;
      var rmin = dataRange.min;
      var rmax = dataRange.max;
      var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
      var factor, niceMin, niceMax, numSpaces; // Beyond MIN_SPACING floating point numbers being to lose precision
      // such that we can't do the math necessary to generate ticks

      if (spacing < MIN_SPACING && isNullOrUndef(min) && isNullOrUndef(max)) {
        return [rmin, rmax];
      }

      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);

      if (numSpaces > maxNumSpaces) {
        // If the calculated num of spaces exceeds maxNumSpaces, recalculate it
        spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
      }

      if (stepSize || isNullOrUndef(precision)) {
        // If a precision is not specified, calculate factor based on spacing
        factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
      } else {
        // If the user specified a precision, round to that number of decimal places
        factor = Math.pow(10, precision);
        spacing = Math.ceil(spacing * factor) / factor;
      }

      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.

      if (stepSize) {
        // If very close to our whole number, use it.
        if (!isNullOrUndef(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {
          niceMin = min;
        }

        if (!isNullOrUndef(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {
          niceMax = max;
        }
      }

      numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.

      if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }

      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      ticks.push(isNullOrUndef(min) ? niceMin : min);

      for (var j = 1; j < numSpaces; ++j) {
        ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
      }

      ticks.push(isNullOrUndef(max) ? niceMax : max);
      return ticks;
    }

    var scale_linearbase = core_scale.extend({
      getRightValue: function (value) {
        if (typeof value === 'string') {
          return +value;
        }

        return core_scale.prototype.getRightValue.call(this, value);
      },
      handleTickRangeOptions: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
        // do nothing since that would make the chart weird. If the user really wants a weird chart
        // axis, they can manually override it

        if (tickOpts.beginAtZero) {
          var minSign = helpers$1.sign(me.min);
          var maxSign = helpers$1.sign(me.max);

          if (minSign < 0 && maxSign < 0) {
            // move the top up to 0
            me.max = 0;
          } else if (minSign > 0 && maxSign > 0) {
            // move the bottom down to 0
            me.min = 0;
          }
        }

        var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
        var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

        if (tickOpts.min !== undefined) {
          me.min = tickOpts.min;
        } else if (tickOpts.suggestedMin !== undefined) {
          if (me.min === null) {
            me.min = tickOpts.suggestedMin;
          } else {
            me.min = Math.min(me.min, tickOpts.suggestedMin);
          }
        }

        if (tickOpts.max !== undefined) {
          me.max = tickOpts.max;
        } else if (tickOpts.suggestedMax !== undefined) {
          if (me.max === null) {
            me.max = tickOpts.suggestedMax;
          } else {
            me.max = Math.max(me.max, tickOpts.suggestedMax);
          }
        }

        if (setMin !== setMax) {
          // We set the min or the max but not both.
          // So ensure that our range is good
          // Inverted or 0 length range can happen when
          // ticks.min is set, and no datasets are visible
          if (me.min >= me.max) {
            if (setMin) {
              me.max = me.min + 1;
            } else {
              me.min = me.max - 1;
            }
          }
        }

        if (me.min === me.max) {
          me.max++;

          if (!tickOpts.beginAtZero) {
            me.min--;
          }
        }
      },
      getTickLimit: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var stepSize = tickOpts.stepSize;
        var maxTicksLimit = tickOpts.maxTicksLimit;
        var maxTicks;

        if (stepSize) {
          maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
        } else {
          maxTicks = me._computeTickLimit();
          maxTicksLimit = maxTicksLimit || 11;
        }

        if (maxTicksLimit) {
          maxTicks = Math.min(maxTicksLimit, maxTicks);
        }

        return maxTicks;
      },
      _computeTickLimit: function () {
        return Number.POSITIVE_INFINITY;
      },
      handleDirectionalChanges: noop,
      buildTicks: function () {
        var me = this;
        var opts = me.options;
        var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of
        // the axis area. For now, we say that the minimum tick spacing in pixels must be 40
        // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
        // the graph. Make sure we always have at least 2 ticks

        var maxTicks = me.getTickLimit();
        maxTicks = Math.max(2, maxTicks);
        var numericGeneratorOptions = {
          maxTicks: maxTicks,
          min: tickOpts.min,
          max: tickOpts.max,
          precision: tickOpts.precision,
          stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
        };
        var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
        me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          ticks.reverse();
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }
      },
      convertTicksToLabels: function () {
        var me = this;
        me.ticksAsNumbers = me.ticks.slice();
        me.zeroLineIndex = me.ticks.indexOf(0);
        core_scale.prototype.convertTicksToLabels.call(me);
      }
    });
    var defaultConfig$1 = {
      position: 'left',
      ticks: {
        callback: core_ticks.formatters.linear
      }
    };
    var scale_linear = scale_linearbase.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();
        var DEFAULT_MIN = 0;
        var DEFAULT_MAX = 1;

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // First Calculate the range


        me.min = null;
        me.max = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (valuesPerStack[key] === undefined) {
              valuesPerStack[key] = {
                positiveValues: [],
                negativeValues: []
              };
            } // Store these per type


            var positiveValues = valuesPerStack[key].positiveValues;
            var negativeValues = valuesPerStack[key].negativeValues;

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                positiveValues[index] = positiveValues[index] || 0;
                negativeValues[index] = negativeValues[index] || 0;

                if (opts.relativePoints) {
                  positiveValues[index] = 100;
                } else if (value < 0) {
                  negativeValues[index] += value;
                } else {
                  positiveValues[index] += value;
                }
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
            var minVal = helpers$1.min(values);
            var maxVal = helpers$1.max(values);
            me.min = me.min === null ? minVal : Math.min(me.min, minVal);
            me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue);

                if (isNaN(value) || meta.data[index].hidden) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }
              });
            }
          });
        }

        me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
        me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        this.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        var me = this;
        var tickFont;

        if (me.isHorizontal()) {
          return Math.ceil(me.width / 40);
        }

        tickFont = helpers$1.options._parseFont(me.options.ticks);
        return Math.ceil(me.height / tickFont.lineHeight);
      },
      // Called after the ticks are built. We need
      handleDirectionalChanges: function () {
        if (!this.isHorizontal()) {
          // We are in a vertical orientation. The top value is the highest. So reverse the array
          this.ticks.reverse();
        }
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      // Utils
      getPixelForValue: function (value) {
        // This must be called after fit has been run so that
        // this.left, this.top, this.right, and this.bottom have been defined
        var me = this;
        var start = me.start;
        var rightValue = +me.getRightValue(value);
        var pixel;
        var range = me.end - start;

        if (me.isHorizontal()) {
          pixel = me.left + me.width / range * (rightValue - start);
        } else {
          pixel = me.bottom - me.height / range * (rightValue - start);
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var isHorizontal = me.isHorizontal();
        var innerDimension = isHorizontal ? me.width : me.height;
        var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
        return me.start + (me.end - me.start) * offset;
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.ticksAsNumbers[index]);
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$1 = defaultConfig$1;
    scale_linear._defaults = _defaults$1;
    var valueOrDefault$a = helpers$1.valueOrDefault;
    /**
     * Generate a set of logarithmic ticks
     * @param generationOptions the options used to generate the ticks
     * @param dataRange the range of the data
     * @returns {number[]} array of tick values
     */

    function generateTicks$1(generationOptions, dataRange) {
      var ticks = [];
      var tickVal = valueOrDefault$a(generationOptions.min, Math.pow(10, Math.floor(helpers$1.log10(dataRange.min))));
      var endExp = Math.floor(helpers$1.log10(dataRange.max));
      var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
      var exp, significand;

      if (tickVal === 0) {
        exp = Math.floor(helpers$1.log10(dataRange.minNotZero));
        significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
        ticks.push(tickVal);
        tickVal = significand * Math.pow(10, exp);
      } else {
        exp = Math.floor(helpers$1.log10(tickVal));
        significand = Math.floor(tickVal / Math.pow(10, exp));
      }

      var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

      do {
        ticks.push(tickVal);
        ++significand;

        if (significand === 10) {
          significand = 1;
          ++exp;
          precision = exp >= 0 ? 1 : precision;
        }

        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
      } while (exp < endExp || exp === endExp && significand < endSignificand);

      var lastTick = valueOrDefault$a(generationOptions.max, tickVal);
      ticks.push(lastTick);
      return ticks;
    }

    var defaultConfig$2 = {
      position: 'left',
      // label settings
      ticks: {
        callback: core_ticks.formatters.logarithmic
      }
    }; // TODO(v3): change this to positiveOrDefault

    function nonNegativeOrDefault(value, defaultValue) {
      return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
    }

    var scale_logarithmic = core_scale.extend({
      determineDataLimits: function () {
        var me = this;
        var opts = me.options;
        var chart = me.chart;
        var data = chart.data;
        var datasets = data.datasets;
        var isHorizontal = me.isHorizontal();

        function IDMatches(meta) {
          return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
        } // Calculate Range


        me.min = null;
        me.max = null;
        me.minNotZero = null;
        var hasStacks = opts.stacked;

        if (hasStacks === undefined) {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            if (hasStacks) {
              return;
            }

            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
              hasStacks = true;
            }
          });
        }

        if (opts.stacked || hasStacks) {
          var valuesPerStack = {};
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);
            var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
            opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              if (valuesPerStack[key] === undefined) {
                valuesPerStack[key] = [];
              }

              helpers$1.each(dataset.data, function (rawValue, index) {
                var values = valuesPerStack[key];
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                values[index] = values[index] || 0;
                values[index] += value;
              });
            }
          });
          helpers$1.each(valuesPerStack, function (valuesForType) {
            if (valuesForType.length > 0) {
              var minVal = helpers$1.min(valuesForType);
              var maxVal = helpers$1.max(valuesForType);
              me.min = me.min === null ? minVal : Math.min(me.min, minVal);
              me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
            }
          });
        } else {
          helpers$1.each(datasets, function (dataset, datasetIndex) {
            var meta = chart.getDatasetMeta(datasetIndex);

            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
              helpers$1.each(dataset.data, function (rawValue, index) {
                var value = +me.getRightValue(rawValue); // invalid, hidden and negative values are ignored

                if (isNaN(value) || meta.data[index].hidden || value < 0) {
                  return;
                }

                if (me.min === null) {
                  me.min = value;
                } else if (value < me.min) {
                  me.min = value;
                }

                if (me.max === null) {
                  me.max = value;
                } else if (value > me.max) {
                  me.max = value;
                }

                if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
                  me.minNotZero = value;
                }
              });
            }
          });
        } // Common base implementation to handle ticks.min, ticks.max


        this.handleTickRangeOptions();
      },
      handleTickRangeOptions: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var DEFAULT_MIN = 1;
        var DEFAULT_MAX = 10;
        me.min = nonNegativeOrDefault(tickOpts.min, me.min);
        me.max = nonNegativeOrDefault(tickOpts.max, me.max);

        if (me.min === me.max) {
          if (me.min !== 0 && me.min !== null) {
            me.min = Math.pow(10, Math.floor(helpers$1.log10(me.min)) - 1);
            me.max = Math.pow(10, Math.floor(helpers$1.log10(me.max)) + 1);
          } else {
            me.min = DEFAULT_MIN;
            me.max = DEFAULT_MAX;
          }
        }

        if (me.min === null) {
          me.min = Math.pow(10, Math.floor(helpers$1.log10(me.max)) - 1);
        }

        if (me.max === null) {
          me.max = me.min !== 0 ? Math.pow(10, Math.floor(helpers$1.log10(me.min)) + 1) : DEFAULT_MAX;
        }

        if (me.minNotZero === null) {
          if (me.min > 0) {
            me.minNotZero = me.min;
          } else if (me.max < 1) {
            me.minNotZero = Math.pow(10, Math.floor(helpers$1.log10(me.max)));
          } else {
            me.minNotZero = DEFAULT_MIN;
          }
        }
      },
      buildTicks: function () {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = !me.isHorizontal();
        var generationOptions = {
          min: nonNegativeOrDefault(tickOpts.min),
          max: nonNegativeOrDefault(tickOpts.max)
        };
        var ticks = me.ticks = generateTicks$1(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the
        // range of the scale

        me.max = helpers$1.max(ticks);
        me.min = helpers$1.min(ticks);

        if (tickOpts.reverse) {
          reverse = !reverse;
          me.start = me.max;
          me.end = me.min;
        } else {
          me.start = me.min;
          me.end = me.max;
        }

        if (reverse) {
          ticks.reverse();
        }
      },
      convertTicksToLabels: function () {
        this.tickValues = this.ticks.slice();
        core_scale.prototype.convertTicksToLabels.call(this);
      },
      // Get the correct tooltip label
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      getPixelForTick: function (index) {
        return this.getPixelForValue(this.tickValues[index]);
      },

      /**
       * Returns the value of the first tick.
       * @param {number} value - The minimum not zero value.
       * @return {number} The first tick value.
       * @private
       */
      _getFirstTickValue: function (value) {
        var exp = Math.floor(helpers$1.log10(value));
        var significand = Math.floor(value / Math.pow(10, exp));
        return significand * Math.pow(10, exp);
      },
      getPixelForValue: function (value) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var offset = 0;
        var innerDimension, pixel, start, end, sign;
        value = +me.getRightValue(value);

        if (reverse) {
          start = me.end;
          end = me.start;
          sign = -1;
        } else {
          start = me.start;
          end = me.end;
          sign = 1;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          pixel = reverse ? me.right : me.left;
        } else {
          innerDimension = me.height;
          sign *= -1; // invert, since the upper-left corner of the canvas is at pixel (0, 0)

          pixel = reverse ? me.top : me.bottom;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            innerDimension -= offset;
            start = firstTickValue;
          }

          if (value !== 0) {
            offset += innerDimension / (log10(end) - log10(start)) * (log10(value) - log10(start));
          }

          pixel += sign * offset;
        }

        return pixel;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var tickOpts = me.options.ticks;
        var reverse = tickOpts.reverse;
        var log10 = helpers$1.log10;

        var firstTickValue = me._getFirstTickValue(me.minNotZero);

        var innerDimension, start, end, value;

        if (reverse) {
          start = me.end;
          end = me.start;
        } else {
          start = me.start;
          end = me.end;
        }

        if (me.isHorizontal()) {
          innerDimension = me.width;
          value = reverse ? me.right - pixel : pixel - me.left;
        } else {
          innerDimension = me.height;
          value = reverse ? pixel - me.top : me.bottom - pixel;
        }

        if (value !== start) {
          if (start === 0) {
            // include zero tick
            var offset = valueOrDefault$a(tickOpts.fontSize, core_defaults.global.defaultFontSize);
            value -= offset;
            innerDimension -= offset;
            start = firstTickValue;
          }

          value *= log10(end) - log10(start);
          value /= innerDimension;
          value = Math.pow(10, log10(start) + value);
        }

        return value;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$2 = defaultConfig$2;
    scale_logarithmic._defaults = _defaults$2;
    var valueOrDefault$b = helpers$1.valueOrDefault;
    var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
    var resolve$7 = helpers$1.options.resolve;
    var defaultConfig$3 = {
      display: true,
      // Boolean - Whether to animate scaling the chart from the centre
      animate: true,
      position: 'chartArea',
      angleLines: {
        display: true,
        color: 'rgba(0, 0, 0, 0.1)',
        lineWidth: 1,
        borderDash: [],
        borderDashOffset: 0.0
      },
      gridLines: {
        circular: false
      },
      // label settings
      ticks: {
        // Boolean - Show a backdrop to the scale label
        showLabelBackdrop: true,
        // String - The colour of the label backdrop
        backdropColor: 'rgba(255,255,255,0.75)',
        // Number - The backdrop padding above & below the label in pixels
        backdropPaddingY: 2,
        // Number - The backdrop padding to the side of the label in pixels
        backdropPaddingX: 2,
        callback: core_ticks.formatters.linear
      },
      pointLabels: {
        // Boolean - if true, show point labels
        display: true,
        // Number - Point label font size in pixels
        fontSize: 10,
        // Function - Used to convert point labels
        callback: function (label) {
          return label;
        }
      }
    };

    function getValueCount(scale) {
      var opts = scale.options;
      return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
    }

    function getTickBackdropHeight(opts) {
      var tickOpts = opts.ticks;

      if (tickOpts.display && opts.display) {
        return valueOrDefault$b(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
      }

      return 0;
    }

    function measureLabelSize(ctx, lineHeight, label) {
      if (helpers$1.isArray(label)) {
        return {
          w: helpers$1.longestText(ctx, ctx.font, label),
          h: label.length * lineHeight
        };
      }

      return {
        w: ctx.measureText(label).width,
        h: lineHeight
      };
    }

    function determineLimits(angle, pos, size, min, max) {
      if (angle === min || angle === max) {
        return {
          start: pos - size / 2,
          end: pos + size / 2
        };
      } else if (angle < min || angle > max) {
        return {
          start: pos - size,
          end: pos
        };
      }

      return {
        start: pos,
        end: pos + size
      };
    }
    /**
     * Helper function to fit a radial linear scale with point labels
     */


    function fitWithPointLabels(scale) {
      // Right, this is really confusing and there is a lot of maths going on here
      // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
      //
      // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
      //
      // Solution:
      //
      // We assume the radius of the polygon is half the size of the canvas at first
      // at each index we check if the text overlaps.
      //
      // Where it does, we store that angle and that index.
      //
      // After finding the largest index and angle we calculate how much we need to remove
      // from the shape radius to move the point inwards by that x.
      //
      // We average the left and right distances to get the maximum shape radius that can fit in the box
      // along with labels.
      //
      // Once we have that, we can find the centre point for the chart, by taking the x text protrusion
      // on each side, removing that from the size, halving it and adding the left x protrusion width.
      //
      // This will mean we have a shape fitted to the canvas, as large as it can be with the labels
      // and position it in the most space efficient manner
      //
      // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
      var plFont = helpers$1.options._parseFont(scale.options.pointLabels); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
      // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points


      var furthestLimits = {
        l: 0,
        r: scale.width,
        t: 0,
        b: scale.height - scale.paddingTop
      };
      var furthestAngles = {};
      var i, textSize, pointPosition;
      scale.ctx.font = plFont.string;
      scale._pointLabelSizes = [];
      var valueCount = getValueCount(scale);

      for (i = 0; i < valueCount; i++) {
        pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
        textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i] || '');
        scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle

        var angleRadians = scale.getIndexAngle(i);
        var angle = helpers$1.toDegrees(angleRadians) % 360;
        var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
        var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

        if (hLimits.start < furthestLimits.l) {
          furthestLimits.l = hLimits.start;
          furthestAngles.l = angleRadians;
        }

        if (hLimits.end > furthestLimits.r) {
          furthestLimits.r = hLimits.end;
          furthestAngles.r = angleRadians;
        }

        if (vLimits.start < furthestLimits.t) {
          furthestLimits.t = vLimits.start;
          furthestAngles.t = angleRadians;
        }

        if (vLimits.end > furthestLimits.b) {
          furthestLimits.b = vLimits.end;
          furthestAngles.b = angleRadians;
        }
      }

      scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
    }

    function getTextAlignForAngle(angle) {
      if (angle === 0 || angle === 180) {
        return 'center';
      } else if (angle < 180) {
        return 'left';
      }

      return 'right';
    }

    function fillText(ctx, text, position, lineHeight) {
      var y = position.y + lineHeight / 2;
      var i, ilen;

      if (helpers$1.isArray(text)) {
        for (i = 0, ilen = text.length; i < ilen; ++i) {
          ctx.fillText(text[i], position.x, y);
          y += lineHeight;
        }
      } else {
        ctx.fillText(text, position.x, y);
      }
    }

    function adjustPointPositionForLabelHeight(angle, textSize, position) {
      if (angle === 90 || angle === 270) {
        position.y -= textSize.h / 2;
      } else if (angle > 270 || angle < 90) {
        position.y -= textSize.h;
      }
    }

    function drawPointLabels(scale) {
      var ctx = scale.ctx;
      var opts = scale.options;
      var angleLineOpts = opts.angleLines;
      var gridLineOpts = opts.gridLines;
      var pointLabelOpts = opts.pointLabels;
      var lineWidth = valueOrDefault$b(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
      var lineColor = valueOrDefault$b(angleLineOpts.color, gridLineOpts.color);
      var tickBackdropHeight = getTickBackdropHeight(opts);
      ctx.save();
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = lineColor;

      if (ctx.setLineDash) {
        ctx.setLineDash(resolve$7([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
        ctx.lineDashOffset = resolve$7([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);
      }

      var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max); // Point Label Font

      var plFont = helpers$1.options._parseFont(pointLabelOpts);

      ctx.font = plFont.string;
      ctx.textBaseline = 'middle';

      for (var i = getValueCount(scale) - 1; i >= 0; i--) {
        if (angleLineOpts.display && lineWidth && lineColor) {
          var outerPosition = scale.getPointPosition(i, outerDistance);
          ctx.beginPath();
          ctx.moveTo(scale.xCenter, scale.yCenter);
          ctx.lineTo(outerPosition.x, outerPosition.y);
          ctx.stroke();
        }

        if (pointLabelOpts.display) {
          // Extra pixels out for some label spacing
          var extra = i === 0 ? tickBackdropHeight / 2 : 0;
          var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5); // Keep this in loop since we may support array properties here

          var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
          ctx.fillStyle = pointLabelFontColor;
          var angleRadians = scale.getIndexAngle(i);
          var angle = helpers$1.toDegrees(angleRadians);
          ctx.textAlign = getTextAlignForAngle(angle);
          adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
          fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.lineHeight);
        }
      }

      ctx.restore();
    }

    function drawRadiusLine(scale, gridLineOpts, radius, index) {
      var ctx = scale.ctx;
      var circular = gridLineOpts.circular;
      var valueCount = getValueCount(scale);
      var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
      var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
      var pointPosition;

      if (!circular && !valueCount || !lineColor || !lineWidth) {
        return;
      }

      ctx.save();
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = lineWidth;

      if (ctx.setLineDash) {
        ctx.setLineDash(gridLineOpts.borderDash || []);
        ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;
      }

      ctx.beginPath();

      if (circular) {
        // Draw circular arcs between the points
        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
      } else {
        // Draw straight lines connecting each index
        pointPosition = scale.getPointPosition(0, radius);
        ctx.moveTo(pointPosition.x, pointPosition.y);

        for (var i = 1; i < valueCount; i++) {
          pointPosition = scale.getPointPosition(i, radius);
          ctx.lineTo(pointPosition.x, pointPosition.y);
        }
      }

      ctx.closePath();
      ctx.stroke();
      ctx.restore();
    }

    function numberOrZero(param) {
      return helpers$1.isNumber(param) ? param : 0;
    }

    var scale_radialLinear = scale_linearbase.extend({
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        me.width = me.maxWidth;
        me.height = me.maxHeight;
        me.paddingTop = getTickBackdropHeight(me.options) / 2;
        me.xCenter = Math.floor(me.width / 2);
        me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
        me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var min = Number.POSITIVE_INFINITY;
        var max = Number.NEGATIVE_INFINITY;
        helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {
          if (chart.isDatasetVisible(datasetIndex)) {
            var meta = chart.getDatasetMeta(datasetIndex);
            helpers$1.each(dataset.data, function (rawValue, index) {
              var value = +me.getRightValue(rawValue);

              if (isNaN(value) || meta.data[index].hidden) {
                return;
              }

              min = Math.min(value, min);
              max = Math.max(value, max);
            });
          }
        });
        me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
        me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

        me.handleTickRangeOptions();
      },
      // Returns the maximum number of ticks based on the scale dimension
      _computeTickLimit: function () {
        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
      },
      convertTicksToLabels: function () {
        var me = this;
        scale_linearbase.prototype.convertTicksToLabels.call(me); // Point labels

        me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
      },
      getLabelForIndex: function (index, datasetIndex) {
        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
      },
      fit: function () {
        var me = this;
        var opts = me.options;

        if (opts.display && opts.pointLabels.display) {
          fitWithPointLabels(me);
        } else {
          me.setCenterPoint(0, 0, 0, 0);
        }
      },

      /**
       * Set radius reductions and determine new radius and center point
       * @private
       */
      setReductions: function (largestPossibleRadius, furthestLimits, furthestAngles) {
        var me = this;
        var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
        var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
        var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
        var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
        radiusReductionLeft = numberOrZero(radiusReductionLeft);
        radiusReductionRight = numberOrZero(radiusReductionRight);
        radiusReductionTop = numberOrZero(radiusReductionTop);
        radiusReductionBottom = numberOrZero(radiusReductionBottom);
        me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
        me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
      },
      setCenterPoint: function (leftMovement, rightMovement, topMovement, bottomMovement) {
        var me = this;
        var maxRight = me.width - rightMovement - me.drawingArea;
        var maxLeft = leftMovement + me.drawingArea;
        var maxTop = topMovement + me.drawingArea;
        var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
        me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
        me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
      },
      getIndexAngle: function (index) {
        var angleMultiplier = Math.PI * 2 / getValueCount(this);
        var startAngle = this.chart.options && this.chart.options.startAngle ? this.chart.options.startAngle : 0;
        var startAngleRadians = startAngle * Math.PI * 2 / 360; // Start from the top instead of right, so remove a quarter of the circle

        return index * angleMultiplier + startAngleRadians;
      },
      getDistanceFromCenterForValue: function (value) {
        var me = this;

        if (value === null) {
          return 0; // null always in center
        } // Take into account half font size + the yPadding of the top value


        var scalingFactor = me.drawingArea / (me.max - me.min);

        if (me.options.ticks.reverse) {
          return (me.max - value) * scalingFactor;
        }

        return (value - me.min) * scalingFactor;
      },
      getPointPosition: function (index, distanceFromCenter) {
        var me = this;
        var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
        return {
          x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
          y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
        };
      },
      getPointPositionForValue: function (index, value) {
        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
      },
      getBasePosition: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        return me.getPointPositionForValue(0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
      },
      draw: function () {
        var me = this;
        var opts = me.options;
        var gridLineOpts = opts.gridLines;
        var tickOpts = opts.ticks;

        if (opts.display) {
          var ctx = me.ctx;
          var startAngle = this.getIndexAngle(0);

          var tickFont = helpers$1.options._parseFont(tickOpts);

          if (opts.angleLines.display || opts.pointLabels.display) {
            drawPointLabels(me);
          }

          helpers$1.each(me.ticks, function (label, index) {
            // Don't draw a centre value (if it is minimum)
            if (index > 0 || tickOpts.reverse) {
              var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]); // Draw circular lines around the scale

              if (gridLineOpts.display && index !== 0) {
                drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
              }

              if (tickOpts.display) {
                var tickFontColor = valueOrDefault$b(tickOpts.fontColor, core_defaults.global.defaultFontColor);
                ctx.font = tickFont.string;
                ctx.save();
                ctx.translate(me.xCenter, me.yCenter);
                ctx.rotate(startAngle);

                if (tickOpts.showLabelBackdrop) {
                  var labelWidth = ctx.measureText(label).width;
                  ctx.fillStyle = tickOpts.backdropColor;
                  ctx.fillRect(-labelWidth / 2 - tickOpts.backdropPaddingX, -yCenterOffset - tickFont.size / 2 - tickOpts.backdropPaddingY, labelWidth + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
                }

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = tickFontColor;
                ctx.fillText(label, 0, -yCenterOffset);
                ctx.restore();
              }
            }
          });
        }
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$3 = defaultConfig$3;
    scale_radialLinear._defaults = _defaults$3;
    var valueOrDefault$c = helpers$1.valueOrDefault; // Integer constants are from the ES6 spec.

    var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var INTERVALS = {
      millisecond: {
        common: true,
        size: 1,
        steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
      },
      second: {
        common: true,
        size: 1000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      minute: {
        common: true,
        size: 60000,
        steps: [1, 2, 5, 10, 15, 30]
      },
      hour: {
        common: true,
        size: 3600000,
        steps: [1, 2, 3, 6, 12]
      },
      day: {
        common: true,
        size: 86400000,
        steps: [1, 2, 5]
      },
      week: {
        common: false,
        size: 604800000,
        steps: [1, 2, 3, 4]
      },
      month: {
        common: true,
        size: 2.628e9,
        steps: [1, 2, 3]
      },
      quarter: {
        common: false,
        size: 7.884e9,
        steps: [1, 2, 3, 4]
      },
      year: {
        common: true,
        size: 3.154e10
      }
    };
    var UNITS = Object.keys(INTERVALS);

    function sorter(a, b) {
      return a - b;
    }

    function arrayUnique(items) {
      var hash = {};
      var out = [];
      var i, ilen, item;

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];

        if (!hash[item]) {
          hash[item] = true;
          out.push(item);
        }
      }

      return out;
    }
    /**
     * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
     * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
     * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
     * extremity (left + width or top + height). Note that it would be more optimized to directly
     * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
     * to create the lookup table. The table ALWAYS contains at least two items: min and max.
     *
     * @param {number[]} timestamps - timestamps sorted from lowest to highest.
     * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min
     * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
     * If 'series', timestamps will be positioned at the same distance from each other. In this
     * case, only timestamps that break the time linearity are registered, meaning that in the
     * best case, all timestamps are linear, the table contains only min and max.
     */


    function buildLookupTable(timestamps, min, max, distribution) {
      if (distribution === 'linear' || !timestamps.length) {
        return [{
          time: min,
          pos: 0
        }, {
          time: max,
          pos: 1
        }];
      }

      var table = [];
      var items = [min];
      var i, ilen, prev, curr, next;

      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];

        if (curr > min && curr < max) {
          items.push(curr);
        }
      }

      items.push(max);

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i]; // only add points that breaks the scale linearity

        if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }

      return table;
    } // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/


    function lookup(table, key, value) {
      var lo = 0;
      var hi = table.length - 1;
      var mid, i0, i1;

      while (lo >= 0 && lo <= hi) {
        mid = lo + hi >> 1;
        i0 = table[mid - 1] || null;
        i1 = table[mid];

        if (!i0) {
          // given value is outside table (before first item)
          return {
            lo: null,
            hi: i1
          };
        } else if (i1[key] < value) {
          lo = mid + 1;
        } else if (i0[key] > value) {
          hi = mid - 1;
        } else {
          return {
            lo: i0,
            hi: i1
          };
        }
      } // given value is outside table (after last item)


      return {
        lo: i1,
        hi: null
      };
    }
    /**
     * Linearly interpolates the given source `value` using the table items `skey` values and
     * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
     * returns the position for a timestamp equal to 42. If value is out of bounds, values at
     * index [0, 1] or [n - 1, n] are used for the interpolation.
     */


    function interpolate$1(table, skey, sval, tkey) {
      var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)

      var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
      var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
      var span = next[skey] - prev[skey];
      var ratio = span ? (sval - prev[skey]) / span : 0;
      var offset = (next[tkey] - prev[tkey]) * ratio;
      return prev[tkey] + offset;
    }

    function toTimestamp(scale, input) {
      var adapter = scale._adapter;
      var options = scale.options.time;
      var parser = options.parser;
      var format = parser || options.format;
      var value = input;

      if (typeof parser === 'function') {
        value = parser(value);
      } // Only parse if its not a timestamp already


      if (!helpers$1.isFinite(value)) {
        value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);
      }

      if (value !== null) {
        return +value;
      } // Labels are in an incompatible format and no `parser` has been provided.
      // The user might still use the deprecated `format` option for parsing.


      if (!parser && typeof format === 'function') {
        value = format(input); // `format` could return something else than a timestamp, if so, parse it

        if (!helpers$1.isFinite(value)) {
          value = adapter.parse(value);
        }
      }

      return value;
    }

    function parse(scale, input) {
      if (helpers$1.isNullOrUndef(input)) {
        return null;
      }

      var options = scale.options.time;
      var value = toTimestamp(scale, scale.getRightValue(input));

      if (value === null) {
        return value;
      }

      if (options.round) {
        value = +scale._adapter.startOf(value, options.round);
      }

      return value;
    }
    /**
     * Returns the number of unit to skip to be able to display up to `capacity` number of ticks
     * in `unit` for the given `min` / `max` range and respecting the interval steps constraints.
     */


    function determineStepSize(min, max, unit, capacity) {
      var range = max - min;
      var interval = INTERVALS[unit];
      var milliseconds = interval.size;
      var steps = interval.steps;
      var i, ilen, factor;

      if (!steps) {
        return Math.ceil(range / (capacity * milliseconds));
      }

      for (i = 0, ilen = steps.length; i < ilen; ++i) {
        factor = steps[i];

        if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
          break;
        }
      }

      return factor;
    }
    /**
     * Figures out what unit results in an appropriate number of auto-generated ticks
     */


    function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      var ilen = UNITS.length;
      var i, interval, factor;

      for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
        interval = INTERVALS[UNITS[i]];
        factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;

        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
          return UNITS[i];
        }
      }

      return UNITS[ilen - 1];
    }
    /**
     * Figures out what unit to format a set of ticks with
     */


    function determineUnitForFormatting(scale, ticks, minUnit, min, max) {
      var ilen = UNITS.length;
      var i, unit;

      for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
        unit = UNITS[i];

        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= ticks.length) {
          return unit;
        }
      }

      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
    }

    function determineMajorUnit(unit) {
      for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
        if (INTERVALS[UNITS[i]].common) {
          return UNITS[i];
        }
      }
    }
    /**
     * Generates a maximum of `capacity` timestamps between min and max, rounded to the
     * `minor` unit, aligned on the `major` unit and using the given scale time `options`.
     * Important: this method can return ticks outside the min and max range, it's the
     * responsibility of the calling code to clamp values if needed.
     */


    function generate(scale, min, max, capacity) {
      var adapter = scale._adapter;
      var options = scale.options;
      var timeOpts = options.time;
      var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
      var major = determineMajorUnit(minor);
      var stepSize = valueOrDefault$c(timeOpts.stepSize, timeOpts.unitStepSize);
      var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
      var majorTicksEnabled = options.ticks.major.enabled;
      var interval = INTERVALS[minor];
      var first = min;
      var last = max;
      var ticks = [];
      var time;

      if (!stepSize) {
        stepSize = determineStepSize(min, max, minor, capacity);
      } // For 'week' unit, handle the first day of week option


      if (weekday) {
        first = +adapter.startOf(first, 'isoWeek', weekday);
        last = +adapter.startOf(last, 'isoWeek', weekday);
      } // Align first/last ticks on unit


      first = +adapter.startOf(first, weekday ? 'day' : minor);
      last = +adapter.startOf(last, weekday ? 'day' : minor); // Make sure that the last tick include max

      if (last < max) {
        last = +adapter.add(last, 1, minor);
      }

      time = first;

      if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
        // Align the first tick on the previous `minor` unit aligned on the `major` unit:
        // we first aligned time on the previous `major` unit then add the number of full
        // stepSize there is between first and the previous major time.
        time = +adapter.startOf(time, major);
        time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
      }

      for (; time < last; time = +adapter.add(time, stepSize, minor)) {
        ticks.push(+time);
      }

      ticks.push(+time);
      return ticks;
    }
    /**
     * Returns the start and end offsets from edges in the form of {start, end}
     * where each value is a relative width to the scale and ranges between 0 and 1.
     * They add extra margins on the both sides by scaling down the original scale.
     * Offsets are added when the `offset` option is true.
     */


    function computeOffsets(table, ticks, min, max, options) {
      var start = 0;
      var end = 0;
      var first, last;

      if (options.offset && ticks.length) {
        if (!options.time.min) {
          first = interpolate$1(table, 'time', ticks[0], 'pos');

          if (ticks.length === 1) {
            start = 1 - first;
          } else {
            start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;
          }
        }

        if (!options.time.max) {
          last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');

          if (ticks.length === 1) {
            end = last;
          } else {
            end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;
          }
        }
      }

      return {
        start: start,
        end: end
      };
    }

    function ticksFromTimestamps(scale, values, majorUnit) {
      var ticks = [];
      var i, ilen, value, major;

      for (i = 0, ilen = values.length; i < ilen; ++i) {
        value = values[i];
        major = majorUnit ? value === +scale._adapter.startOf(value, majorUnit) : false;
        ticks.push({
          value: value,
          major: major
        });
      }

      return ticks;
    }

    var defaultConfig$4 = {
      position: 'bottom',

      /**
       * Data distribution along the scale:
       * - 'linear': data are spread according to their time (distances can vary),
       * - 'series': data are spread at the same distance from each other.
       * @see https://github.com/chartjs/Chart.js/pull/4507
       * @since 2.7.0
       */
      distribution: 'linear',

      /**
       * Scale boundary strategy (bypassed by min/max time options)
       * - `data`: make sure data are fully visible, ticks outside are removed
       * - `ticks`: make sure ticks are fully visible, data outside are truncated
       * @see https://github.com/chartjs/Chart.js/pull/4556
       * @since 2.7.0
       */
      bounds: 'data',
      adapters: {},
      time: {
        parser: false,
        // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
        format: false,
        // DEPRECATED false == date objects, moment object, callback or a pattern string from https://momentjs.com/docs/#/parsing/string-format/
        unit: false,
        // false == automatic or override with week, month, year, etc.
        round: false,
        // none, or override with week, month, year, etc.
        displayFormat: false,
        // DEPRECATED
        isoWeekday: false,
        // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
        minUnit: 'millisecond',
        displayFormats: {}
      },
      ticks: {
        autoSkip: false,

        /**
         * Ticks generation input values:
         * - 'auto': generates "optimal" ticks based on scale size and time options.
         * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
         * - 'labels': generates ticks from user given `data.labels` values ONLY.
         * @see https://github.com/chartjs/Chart.js/pull/4507
         * @since 2.7.0
         */
        source: 'auto',
        major: {
          enabled: false
        }
      }
    };
    var scale_time = core_scale.extend({
      initialize: function () {
        this.mergeTicksOptions();
        core_scale.prototype.initialize.call(this);
      },
      update: function () {
        var me = this;
        var options = me.options;
        var time = options.time || (options.time = {});
        var adapter = me._adapter = new core_adapters._date(options.adapters.date); // DEPRECATIONS: output a message only one time per update

        if (time.format) {
          console.warn('options.time.format is deprecated and replaced by options.time.parser.');
        } // Backward compatibility: before introducing adapter, `displayFormats` was
        // supposed to contain *all* unit/string pairs but this can't be resolved
        // when loading the scale (adapters are loaded afterward), so let's populate
        // missing formats on update


        helpers$1.mergeIf(time.displayFormats, adapter.formats());
        return core_scale.prototype.update.apply(me, arguments);
      },

      /**
       * Allows data to be referenced via 't' attribute
       */
      getRightValue: function (rawValue) {
        if (rawValue && rawValue.t !== undefined) {
          rawValue = rawValue.t;
        }

        return core_scale.prototype.getRightValue.call(this, rawValue);
      },
      determineDataLimits: function () {
        var me = this;
        var chart = me.chart;
        var adapter = me._adapter;
        var timeOpts = me.options.time;
        var unit = timeOpts.unit || 'day';
        var min = MAX_INTEGER;
        var max = MIN_INTEGER;
        var timestamps = [];
        var datasets = [];
        var labels = [];
        var i, j, ilen, jlen, data, timestamp;
        var dataLabels = chart.data.labels || []; // Convert labels to timestamps

        for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
          labels.push(parse(me, dataLabels[i]));
        } // Convert data to timestamps


        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            data = chart.data.datasets[i].data; // Let's consider that all data have the same format.

            if (helpers$1.isObject(data[0])) {
              datasets[i] = [];

              for (j = 0, jlen = data.length; j < jlen; ++j) {
                timestamp = parse(me, data[j]);
                timestamps.push(timestamp);
                datasets[i][j] = timestamp;
              }
            } else {
              for (j = 0, jlen = labels.length; j < jlen; ++j) {
                timestamps.push(labels[j]);
              }

              datasets[i] = labels.slice(0);
            }
          } else {
            datasets[i] = [];
          }
        }

        if (labels.length) {
          // Sort labels **after** data have been converted
          labels = arrayUnique(labels).sort(sorter);
          min = Math.min(min, labels[0]);
          max = Math.max(max, labels[labels.length - 1]);
        }

        if (timestamps.length) {
          timestamps = arrayUnique(timestamps).sort(sorter);
          min = Math.min(min, timestamps[0]);
          max = Math.max(max, timestamps[timestamps.length - 1]);
        }

        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // In case there is no valid min/max, set limits based on unit time option

        min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
        max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)

        me.min = Math.min(min, max);
        me.max = Math.max(min + 1, max); // PRIVATE

        me._horizontal = me.isHorizontal();
        me._table = [];
        me._timestamps = {
          data: timestamps,
          datasets: datasets,
          labels: labels
        };
      },
      buildTicks: function () {
        var me = this;
        var min = me.min;
        var max = me.max;
        var options = me.options;
        var timeOpts = options.time;
        var timestamps = [];
        var ticks = [];
        var i, ilen, timestamp;

        switch (options.ticks.source) {
          case 'data':
            timestamps = me._timestamps.data;
            break;

          case 'labels':
            timestamps = me._timestamps.labels;
            break;

          case 'auto':
          default:
            timestamps = generate(me, min, max, me.getLabelCapacity(min), options);
        }

        if (options.bounds === 'ticks' && timestamps.length) {
          min = timestamps[0];
          max = timestamps[timestamps.length - 1];
        } // Enforce limits with user min/max options


        min = parse(me, timeOpts.min) || min;
        max = parse(me, timeOpts.max) || max; // Remove ticks outside the min/max range

        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
          timestamp = timestamps[i];

          if (timestamp >= min && timestamp <= max) {
            ticks.push(timestamp);
          }
        }

        me.min = min;
        me.max = max; // PRIVATE

        me._unit = timeOpts.unit || determineUnitForFormatting(me, ticks, timeOpts.minUnit, me.min, me.max);
        me._majorUnit = determineMajorUnit(me._unit);
        me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
        me._offsets = computeOffsets(me._table, ticks, min, max, options);

        if (options.ticks.reverse) {
          ticks.reverse();
        }

        return ticksFromTimestamps(me, ticks, me._majorUnit);
      },
      getLabelForIndex: function (index, datasetIndex) {
        var me = this;
        var adapter = me._adapter;
        var data = me.chart.data;
        var timeOpts = me.options.time;
        var label = data.labels && index < data.labels.length ? data.labels[index] : '';
        var value = data.datasets[datasetIndex].data[index];

        if (helpers$1.isObject(value)) {
          label = me.getRightValue(value);
        }

        if (timeOpts.tooltipFormat) {
          return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
        }

        if (typeof label === 'string') {
          return label;
        }

        return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
      },

      /**
       * Function to format an individual tick mark
       * @private
       */
      tickFormatFunction: function (time, index, ticks, format) {
        var me = this;
        var adapter = me._adapter;
        var options = me.options;
        var formats = options.time.displayFormats;
        var minorFormat = formats[me._unit];
        var majorUnit = me._majorUnit;
        var majorFormat = formats[majorUnit];
        var majorTime = +adapter.startOf(time, majorUnit);
        var majorTickOpts = options.ticks.major;
        var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
        var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
        var tickOpts = major ? majorTickOpts : options.ticks.minor;
        var formatter = valueOrDefault$c(tickOpts.callback, tickOpts.userCallback);
        return formatter ? formatter(label, index, ticks) : label;
      },
      convertTicksToLabels: function (ticks) {
        var labels = [];
        var i, ilen;

        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
          labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
        }

        return labels;
      },

      /**
       * @private
       */
      getPixelForOffset: function (time) {
        var me = this;
        var isReverse = me.options.ticks.reverse;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? isReverse ? me.right : me.left : isReverse ? me.bottom : me.top;
        var pos = interpolate$1(me._table, 'time', time, 'pos');
        var offset = size * (me._offsets.start + pos) / (me._offsets.start + 1 + me._offsets.end);
        return isReverse ? start - offset : start + offset;
      },
      getPixelForValue: function (value, index, datasetIndex) {
        var me = this;
        var time = null;

        if (index !== undefined && datasetIndex !== undefined) {
          time = me._timestamps.datasets[datasetIndex][index];
        }

        if (time === null) {
          time = parse(me, value);
        }

        if (time !== null) {
          return me.getPixelForOffset(time);
        }
      },
      getPixelForTick: function (index) {
        var ticks = this.getTicks();
        return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
      },
      getValueForPixel: function (pixel) {
        var me = this;
        var size = me._horizontal ? me.width : me.height;
        var start = me._horizontal ? me.left : me.top;
        var pos = (size ? (pixel - start) / size : 0) * (me._offsets.start + 1 + me._offsets.start) - me._offsets.end;
        var time = interpolate$1(me._table, 'pos', pos, 'time'); // DEPRECATION, we should return time directly

        return me._adapter._create(time);
      },

      /**
       * Crude approximation of what the label width might be
       * @private
       */
      getLabelWidth: function (label) {
        var me = this;
        var ticksOpts = me.options.ticks;
        var tickLabelWidth = me.ctx.measureText(label).width;
        var angle = helpers$1.toRadians(ticksOpts.maxRotation);
        var cosRotation = Math.cos(angle);
        var sinRotation = Math.sin(angle);
        var tickFontSize = valueOrDefault$c(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
        return tickLabelWidth * cosRotation + tickFontSize * sinRotation;
      },

      /**
       * @private
       */
      getLabelCapacity: function (exampleTime) {
        var me = this; // pick the longest format (milliseconds) for guestimation

        var format = me.options.time.displayFormats.millisecond;
        var exampleLabel = me.tickFormatFunction(exampleTime, 0, [], format);
        var tickLabelWidth = me.getLabelWidth(exampleLabel);
        var innerWidth = me.isHorizontal() ? me.width : me.height;
        var capacity = Math.floor(innerWidth / tickLabelWidth);
        return capacity > 0 ? capacity : 1;
      }
    }); // INTERNAL: static default options, registered in src/index.js

    var _defaults$4 = defaultConfig$4;
    scale_time._defaults = _defaults$4;
    var scales = {
      category: scale_category,
      linear: scale_linear,
      logarithmic: scale_logarithmic,
      radialLinear: scale_radialLinear,
      time: scale_time
    };
    var FORMATS = {
      datetime: 'MMM D, YYYY, h:mm:ss a',
      millisecond: 'h:mm:ss.SSS a',
      second: 'h:mm:ss a',
      minute: 'h:mm a',
      hour: 'hA',
      day: 'MMM D',
      week: 'll',
      month: 'MMM YYYY',
      quarter: '[Q]Q - YYYY',
      year: 'YYYY'
    };

    core_adapters._date.override(typeof moment === 'function' ? {
      _id: 'moment',
      // DEBUG ONLY
      formats: function () {
        return FORMATS;
      },
      parse: function (value, format) {
        if (typeof value === 'string' && typeof format === 'string') {
          value = moment(value, format);
        } else if (!(value instanceof moment)) {
          value = moment(value);
        }

        return value.isValid() ? value.valueOf() : null;
      },
      format: function (time, format) {
        return moment(time).format(format);
      },
      add: function (time, amount, unit) {
        return moment(time).add(amount, unit).valueOf();
      },
      diff: function (max, min, unit) {
        return moment.duration(moment(max).diff(moment(min))).as(unit);
      },
      startOf: function (time, unit, weekday) {
        time = moment(time);

        if (unit === 'isoWeek') {
          return time.isoWeekday(weekday).valueOf();
        }

        return time.startOf(unit).valueOf();
      },
      endOf: function (time, unit) {
        return moment(time).endOf(unit).valueOf();
      },
      // DEPRECATIONS

      /**
       * Provided for backward compatibility with scale.getValueForPixel().
       * @deprecated since version 2.8.0
       * @todo remove at version 3
       * @private
       */
      _create: function (time) {
        return moment(time);
      }
    } : {});

    core_defaults._set('global', {
      plugins: {
        filler: {
          propagate: true
        }
      }
    });

    var mappers = {
      dataset: function (source) {
        var index = source.fill;
        var chart = source.chart;
        var meta = chart.getDatasetMeta(index);
        var visible = meta && chart.isDatasetVisible(index);
        var points = visible && meta.dataset._children || [];
        var length = points.length || 0;
        return !length ? null : function (point, i) {
          return i < length && points[i]._view || null;
        };
      },
      boundary: function (source) {
        var boundary = source.boundary;
        var x = boundary ? boundary.x : null;
        var y = boundary ? boundary.y : null;
        return function (point) {
          return {
            x: x === null ? point.x : x,
            y: y === null ? point.y : y
          };
        };
      }
    }; // @todo if (fill[0] === '#')

    function decodeFill(el, index, count) {
      var model = el._model || {};
      var fill = model.fill;
      var target;

      if (fill === undefined) {
        fill = !!model.backgroundColor;
      }

      if (fill === false || fill === null) {
        return false;
      }

      if (fill === true) {
        return 'origin';
      }

      target = parseFloat(fill, 10);

      if (isFinite(target) && Math.floor(target) === target) {
        if (fill[0] === '-' || fill[0] === '+') {
          target = index + target;
        }

        if (target === index || target < 0 || target >= count) {
          return false;
        }

        return target;
      }

      switch (fill) {
        // compatibility
        case 'bottom':
          return 'start';

        case 'top':
          return 'end';

        case 'zero':
          return 'origin';
        // supported boundaries

        case 'origin':
        case 'start':
        case 'end':
          return fill;
        // invalid fill values

        default:
          return false;
      }
    }

    function computeBoundary(source) {
      var model = source.el._model || {};
      var scale = source.el._scale || {};
      var fill = source.fill;
      var target = null;
      var horizontal;

      if (isFinite(fill)) {
        return null;
      } // Backward compatibility: until v3, we still need to support boundary values set on
      // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
      // controllers might still use it (e.g. the Smith chart).


      if (fill === 'start') {
        target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
      } else if (fill === 'end') {
        target = model.scaleTop === undefined ? scale.top : model.scaleTop;
      } else if (model.scaleZero !== undefined) {
        target = model.scaleZero;
      } else if (scale.getBasePosition) {
        target = scale.getBasePosition();
      } else if (scale.getBasePixel) {
        target = scale.getBasePixel();
      }

      if (target !== undefined && target !== null) {
        if (target.x !== undefined && target.y !== undefined) {
          return target;
        }

        if (helpers$1.isFinite(target)) {
          horizontal = scale.isHorizontal();
          return {
            x: horizontal ? target : null,
            y: horizontal ? null : target
          };
        }
      }

      return null;
    }

    function resolveTarget(sources, index, propagate) {
      var source = sources[index];
      var fill = source.fill;
      var visited = [index];
      var target;

      if (!propagate) {
        return fill;
      }

      while (fill !== false && visited.indexOf(fill) === -1) {
        if (!isFinite(fill)) {
          return fill;
        }

        target = sources[fill];

        if (!target) {
          return false;
        }

        if (target.visible) {
          return fill;
        }

        visited.push(fill);
        fill = target.fill;
      }

      return false;
    }

    function createMapper(source) {
      var fill = source.fill;
      var type = 'dataset';

      if (fill === false) {
        return null;
      }

      if (!isFinite(fill)) {
        type = 'boundary';
      }

      return mappers[type](source);
    }

    function isDrawable(point) {
      return point && !point.skip;
    }

    function drawArea(ctx, curve0, curve1, len0, len1) {
      var i;

      if (!len0 || !len1) {
        return;
      } // building first area curve (normal)


      ctx.moveTo(curve0[0].x, curve0[0].y);

      for (i = 1; i < len0; ++i) {
        helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
      } // joining the two area curves


      ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)

      for (i = len1 - 1; i > 0; --i) {
        helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
      }
    }

    function doFill(ctx, points, mapper, view, color, loop) {
      var count = points.length;
      var span = view.spanGaps;
      var curve0 = [];
      var curve1 = [];
      var len0 = 0;
      var len1 = 0;
      var i, ilen, index, p0, p1, d0, d1;
      ctx.beginPath();

      for (i = 0, ilen = count + !!loop; i < ilen; ++i) {
        index = i % count;
        p0 = points[index]._view;
        p1 = mapper(p0, index, view);
        d0 = isDrawable(p0);
        d1 = isDrawable(p1);

        if (d0 && d1) {
          len0 = curve0.push(p0);
          len1 = curve1.push(p1);
        } else if (len0 && len1) {
          if (!span) {
            drawArea(ctx, curve0, curve1, len0, len1);
            len0 = len1 = 0;
            curve0 = [];
            curve1 = [];
          } else {
            if (d0) {
              curve0.push(p0);
            }

            if (d1) {
              curve1.push(p1);
            }
          }
        }
      }

      drawArea(ctx, curve0, curve1, len0, len1);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    var plugin_filler = {
      id: 'filler',
      afterDatasetsUpdate: function (chart, options) {
        var count = (chart.data.datasets || []).length;
        var propagate = options.propagate;
        var sources = [];
        var meta, i, el, source;

        for (i = 0; i < count; ++i) {
          meta = chart.getDatasetMeta(i);
          el = meta.dataset;
          source = null;

          if (el && el._model && el instanceof elements.Line) {
            source = {
              visible: chart.isDatasetVisible(i),
              fill: decodeFill(el, i, count),
              chart: chart,
              el: el
            };
          }

          meta.$filler = source;
          sources.push(source);
        }

        for (i = 0; i < count; ++i) {
          source = sources[i];

          if (!source) {
            continue;
          }

          source.fill = resolveTarget(sources, i, propagate);
          source.boundary = computeBoundary(source);
          source.mapper = createMapper(source);
        }
      },
      beforeDatasetDraw: function (chart, args) {
        var meta = args.meta.$filler;

        if (!meta) {
          return;
        }

        var ctx = chart.ctx;
        var el = meta.el;
        var view = el._view;
        var points = el._children || [];
        var mapper = meta.mapper;
        var color = view.backgroundColor || core_defaults.global.defaultColor;

        if (mapper && color && points.length) {
          helpers$1.canvas.clipArea(ctx, chart.chartArea);
          doFill(ctx, points, mapper, view, color, el._loop);
          helpers$1.canvas.unclipArea(ctx);
        }
      }
    };
    var noop$1 = helpers$1.noop;
    var valueOrDefault$d = helpers$1.valueOrDefault;

    core_defaults._set('global', {
      legend: {
        display: true,
        position: 'top',
        fullWidth: true,
        reverse: false,
        weight: 1000,
        // a callback that will handle
        onClick: function (e, legendItem) {
          var index = legendItem.datasetIndex;
          var ci = this.chart;
          var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment

          meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart

          ci.update();
        },
        onHover: null,
        onLeave: null,
        labels: {
          boxWidth: 40,
          padding: 10,
          // Generates labels shown in the legend
          // Valid properties to return:
          // text : text to display
          // fillStyle : fill of coloured box
          // strokeStyle: stroke of coloured box
          // hidden : if this legend item refers to a hidden item
          // lineCap : cap style for line
          // lineDash
          // lineDashOffset :
          // lineJoin :
          // lineWidth :
          generateLabels: function (chart) {
            var data = chart.data;
            return helpers$1.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {
              return {
                text: dataset.label,
                fillStyle: !helpers$1.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],
                hidden: !chart.isDatasetVisible(i),
                lineCap: dataset.borderCapStyle,
                lineDash: dataset.borderDash,
                lineDashOffset: dataset.borderDashOffset,
                lineJoin: dataset.borderJoinStyle,
                lineWidth: dataset.borderWidth,
                strokeStyle: dataset.borderColor,
                pointStyle: dataset.pointStyle,
                // Below is extra data used for toggling the datasets
                datasetIndex: i
              };
            }, this) : [];
          }
        }
      },
      legendCallback: function (chart) {
        var text = [];
        text.push('<ul class="' + chart.id + '-legend">');

        for (var i = 0; i < chart.data.datasets.length; i++) {
          text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');

          if (chart.data.datasets[i].label) {
            text.push(chart.data.datasets[i].label);
          }

          text.push('</li>');
        }

        text.push('</ul>');
        return text.join('');
      }
    });
    /**
     * Helper function to get the box width based on the usePointStyle option
     * @param {object} labelopts - the label options on the legend
     * @param {number} fontSize - the label font size
     * @return {number} width of the color box area
     */


    function getBoxWidth(labelOpts, fontSize) {
      return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
    }
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Legend = core_element.extend({
      initialize: function (config) {
        helpers$1.extend(this, config); // Contains hit boxes for each dataset (in dataset order)

        this.legendHitBoxes = [];
        /**
        	 * @private
        	 */

        this._hoveredItem = null; // Are we in doughnut mode which has a different data type

        this.doughnutMode = false;
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      // Any function defined here is inherited by all legend types.
      // Any function can be extended by the legend type
      beforeUpdate: noop$1,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$1,
      //
      beforeSetDimensions: noop$1,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$1,
      //
      beforeBuildLabels: noop$1,
      buildLabels: function () {
        var me = this;
        var labelOpts = me.options.labels || {};
        var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];

        if (labelOpts.filter) {
          legendItems = legendItems.filter(function (item) {
            return labelOpts.filter(item, me.chart.data);
          });
        }

        if (me.options.reverse) {
          legendItems.reverse();
        }

        me.legendItems = legendItems;
      },
      afterBuildLabels: noop$1,
      //
      beforeFit: noop$1,
      fit: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var display = opts.display;
        var ctx = me.ctx;

        var labelFont = helpers$1.options._parseFont(labelOpts);

        var fontSize = labelFont.size; // Reset hit boxes

        var hitboxes = me.legendHitBoxes = [];
        var minSize = me.minSize;
        var isHorizontal = me.isHorizontal();

        if (isHorizontal) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = display ? 10 : 0;
        } else {
          minSize.width = display ? 10 : 0;
          minSize.height = me.maxHeight; // fill all the height
        } // Increase sizes here


        if (display) {
          ctx.font = labelFont.string;

          if (isHorizontal) {
            // Labels
            // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
            var lineWidths = me.lineWidths = [0];
            var totalHeight = 0;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

              if (i === 0 || lineWidths[lineWidths.length - 1] + width + labelOpts.padding > minSize.width) {
                totalHeight += fontSize + labelOpts.padding;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = labelOpts.padding;
              } // Store the hitbox width and height here. Final position will be updated in `draw`


              hitboxes[i] = {
                left: 0,
                top: 0,
                width: width,
                height: fontSize
              };
              lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
            });
            minSize.height += totalHeight;
          } else {
            var vPadding = labelOpts.padding;
            var columnWidths = me.columnWidths = [];
            var totalWidth = labelOpts.padding;
            var currentColWidth = 0;
            var currentColHeight = 0;
            var itemHeight = fontSize + vPadding;
            helpers$1.each(me.legendItems, function (legendItem, i) {
              var boxWidth = getBoxWidth(labelOpts, fontSize);
              var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column

              if (i > 0 && currentColHeight + itemHeight > minSize.height - vPadding) {
                totalWidth += currentColWidth + labelOpts.padding;
                columnWidths.push(currentColWidth); // previous column width

                currentColWidth = 0;
                currentColHeight = 0;
              } // Get max width


              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`

              hitboxes[i] = {
                left: 0,
                top: 0,
                width: itemWidth,
                height: fontSize
              };
            });
            totalWidth += currentColWidth;
            columnWidths.push(currentColWidth);
            minSize.width += totalWidth;
          }
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$1,
      // Shared Methods
      isHorizontal: function () {
        return this.options.position === 'top' || this.options.position === 'bottom';
      },
      // Actually draw the legend on the canvas
      draw: function () {
        var me = this;
        var opts = me.options;
        var labelOpts = opts.labels;
        var globalDefaults = core_defaults.global;
        var defaultColor = globalDefaults.defaultColor;
        var lineDefault = globalDefaults.elements.line;
        var legendWidth = me.width;
        var lineWidths = me.lineWidths;

        if (opts.display) {
          var ctx = me.ctx;
          var fontColor = valueOrDefault$d(labelOpts.fontColor, globalDefaults.defaultFontColor);

          var labelFont = helpers$1.options._parseFont(labelOpts);

          var fontSize = labelFont.size;
          var cursor; // Canvas setup

          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.lineWidth = 0.5;
          ctx.strokeStyle = fontColor; // for strikethrough effect

          ctx.fillStyle = fontColor; // render in correct colour

          ctx.font = labelFont.string;
          var boxWidth = getBoxWidth(labelOpts, fontSize);
          var hitboxes = me.legendHitBoxes; // current position

          var drawLegendBox = function (x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0) {
              return;
            } // Set the ctx for the box


            ctx.save();
            var lineWidth = valueOrDefault$d(legendItem.lineWidth, lineDefault.borderWidth);
            ctx.fillStyle = valueOrDefault$d(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault$d(legendItem.lineCap, lineDefault.borderCapStyle);
            ctx.lineDashOffset = valueOrDefault$d(legendItem.lineDashOffset, lineDefault.borderDashOffset);
            ctx.lineJoin = valueOrDefault$d(legendItem.lineJoin, lineDefault.borderJoinStyle);
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault$d(legendItem.strokeStyle, defaultColor);

            if (ctx.setLineDash) {
              // IE 9 and 10 do not support line dash
              ctx.setLineDash(valueOrDefault$d(legendItem.lineDash, lineDefault.borderDash));
            }

            if (opts.labels && opts.labels.usePointStyle) {
              // Recalculate x and y for drawPoint() because its expecting
              // x and y to be center of figure (instead of top left)
              var radius = boxWidth * Math.SQRT2 / 2;
              var centerX = x + boxWidth / 2;
              var centerY = y + fontSize / 2; // Draw pointStyle as legend symbol

              helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
            } else {
              // Draw box as legend symbol
              if (lineWidth !== 0) {
                ctx.strokeRect(x, y, boxWidth, fontSize);
              }

              ctx.fillRect(x, y, boxWidth, fontSize);
            }

            ctx.restore();
          };

          var fillText = function (x, y, legendItem, textWidth) {
            var halfFontSize = fontSize / 2;
            var xLeft = boxWidth + halfFontSize + x;
            var yMiddle = y + halfFontSize;
            ctx.fillText(legendItem.text, xLeft, yMiddle);

            if (legendItem.hidden) {
              // Strikethrough the text if hidden
              ctx.beginPath();
              ctx.lineWidth = 2;
              ctx.moveTo(xLeft, yMiddle);
              ctx.lineTo(xLeft + textWidth, yMiddle);
              ctx.stroke();
            }
          }; // Horizontal


          var isHorizontal = me.isHorizontal();

          if (isHorizontal) {
            cursor = {
              x: me.left + (legendWidth - lineWidths[0]) / 2 + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          } else {
            cursor = {
              x: me.left + labelOpts.padding,
              y: me.top + labelOpts.padding,
              line: 0
            };
          }

          var itemHeight = fontSize + labelOpts.padding;
          helpers$1.each(me.legendItems, function (legendItem, i) {
            var textWidth = ctx.measureText(legendItem.text).width;
            var width = boxWidth + fontSize / 2 + textWidth;
            var x = cursor.x;
            var y = cursor.y; // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)
            // instead of me.right and me.bottom because me.width and me.height
            // may have been changed since me.minSize was calculated

            if (isHorizontal) {
              if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                y = cursor.y += itemHeight;
                cursor.line++;
                x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2 + labelOpts.padding;
              }
            } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
              x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
              y = cursor.y = me.top + labelOpts.padding;
              cursor.line++;
            }

            drawLegendBox(x, y, legendItem);
            hitboxes[i].left = x;
            hitboxes[i].top = y; // Fill the actual label

            fillText(x, y, legendItem, textWidth);

            if (isHorizontal) {
              cursor.x += width + labelOpts.padding;
            } else {
              cursor.y += itemHeight;
            }
          });
        }
      },

      /**
       * @private
       */
      _getLegendItemAt: function (x, y) {
        var me = this;
        var i, hitBox, lh;

        if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
          // See if we are touching one of the dataset boxes
          lh = me.legendHitBoxes;

          for (i = 0; i < lh.length; ++i) {
            hitBox = lh[i];

            if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
              // Touching an element
              return me.legendItems[i];
            }
          }
        }

        return null;
      },

      /**
       * Handle an event
       * @private
       * @param {IEvent} event - The event to handle
       */
      handleEvent: function (e) {
        var me = this;
        var opts = me.options;
        var type = e.type === 'mouseup' ? 'click' : e.type;
        var hoveredItem;

        if (type === 'mousemove') {
          if (!opts.onHover && !opts.onLeave) {
            return;
          }
        } else if (type === 'click') {
          if (!opts.onClick) {
            return;
          }
        } else {
          return;
        } // Chart event already has relative position in it


        hoveredItem = me._getLegendItemAt(e.x, e.y);

        if (type === 'click') {
          if (hoveredItem && opts.onClick) {
            // use e.native for backwards compatibility
            opts.onClick.call(me, e.native, hoveredItem);
          }
        } else {
          if (opts.onLeave && hoveredItem !== me._hoveredItem) {
            if (me._hoveredItem) {
              opts.onLeave.call(me, e.native, me._hoveredItem);
            }

            me._hoveredItem = hoveredItem;
          }

          if (opts.onHover && hoveredItem) {
            // use e.native for backwards compatibility
            opts.onHover.call(me, e.native, hoveredItem);
          }
        }
      }
    });

    function createNewLegendAndAttach(chart, legendOpts) {
      var legend = new Legend({
        ctx: chart.ctx,
        options: legendOpts,
        chart: chart
      });
      core_layouts.configure(chart, legend, legendOpts);
      core_layouts.addBox(chart, legend);
      chart.legend = legend;
    }

    var plugin_legend = {
      id: 'legend',

      /**
       * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
       * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Legend,
      beforeInit: function (chart) {
        var legendOpts = chart.options.legend;

        if (legendOpts) {
          createNewLegendAndAttach(chart, legendOpts);
        }
      },
      beforeUpdate: function (chart) {
        var legendOpts = chart.options.legend;
        var legend = chart.legend;

        if (legendOpts) {
          helpers$1.mergeIf(legendOpts, core_defaults.global.legend);

          if (legend) {
            core_layouts.configure(chart, legend, legendOpts);
            legend.options = legendOpts;
          } else {
            createNewLegendAndAttach(chart, legendOpts);
          }
        } else if (legend) {
          core_layouts.removeBox(chart, legend);
          delete chart.legend;
        }
      },
      afterEvent: function (chart, e) {
        var legend = chart.legend;

        if (legend) {
          legend.handleEvent(e);
        }
      }
    };
    var noop$2 = helpers$1.noop;

    core_defaults._set('global', {
      title: {
        display: false,
        fontStyle: 'bold',
        fullWidth: true,
        padding: 10,
        position: 'top',
        text: '',
        weight: 2000 // by default greater than legend (1000) to be above

      }
    });
    /**
     * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
     */


    var Title = core_element.extend({
      initialize: function (config) {
        var me = this;
        helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)

        me.legendHitBoxes = [];
      },
      // These methods are ordered by lifecycle. Utilities then follow.
      beforeUpdate: noop$2,
      update: function (maxWidth, maxHeight, margins) {
        var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

        me.beforeUpdate(); // Absorb the master measurements

        me.maxWidth = maxWidth;
        me.maxHeight = maxHeight;
        me.margins = margins; // Dimensions

        me.beforeSetDimensions();
        me.setDimensions();
        me.afterSetDimensions(); // Labels

        me.beforeBuildLabels();
        me.buildLabels();
        me.afterBuildLabels(); // Fit

        me.beforeFit();
        me.fit();
        me.afterFit(); //

        me.afterUpdate();
        return me.minSize;
      },
      afterUpdate: noop$2,
      //
      beforeSetDimensions: noop$2,
      setDimensions: function () {
        var me = this; // Set the unconstrained dimension before label rotation

        if (me.isHorizontal()) {
          // Reset position before calculating rotation
          me.width = me.maxWidth;
          me.left = 0;
          me.right = me.width;
        } else {
          me.height = me.maxHeight; // Reset position before calculating rotation

          me.top = 0;
          me.bottom = me.height;
        } // Reset padding


        me.paddingLeft = 0;
        me.paddingTop = 0;
        me.paddingRight = 0;
        me.paddingBottom = 0; // Reset minSize

        me.minSize = {
          width: 0,
          height: 0
        };
      },
      afterSetDimensions: noop$2,
      //
      beforeBuildLabels: noop$2,
      buildLabels: noop$2,
      afterBuildLabels: noop$2,
      //
      beforeFit: noop$2,
      fit: function () {
        var me = this;
        var opts = me.options;
        var display = opts.display;
        var minSize = me.minSize;
        var lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;

        var fontOpts = helpers$1.options._parseFont(opts);

        var textSize = display ? lineCount * fontOpts.lineHeight + opts.padding * 2 : 0;

        if (me.isHorizontal()) {
          minSize.width = me.maxWidth; // fill all the width

          minSize.height = textSize;
        } else {
          minSize.width = textSize;
          minSize.height = me.maxHeight; // fill all the height
        }

        me.width = minSize.width;
        me.height = minSize.height;
      },
      afterFit: noop$2,
      // Shared Methods
      isHorizontal: function () {
        var pos = this.options.position;
        return pos === 'top' || pos === 'bottom';
      },
      // Actually draw the title block on the canvas
      draw: function () {
        var me = this;
        var ctx = me.ctx;
        var opts = me.options;

        if (opts.display) {
          var fontOpts = helpers$1.options._parseFont(opts);

          var lineHeight = fontOpts.lineHeight;
          var offset = lineHeight / 2 + opts.padding;
          var rotation = 0;
          var top = me.top;
          var left = me.left;
          var bottom = me.bottom;
          var right = me.right;
          var maxWidth, titleX, titleY;
          ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour

          ctx.font = fontOpts.string; // Horizontal

          if (me.isHorizontal()) {
            titleX = left + (right - left) / 2; // midpoint of the width

            titleY = top + offset;
            maxWidth = right - left;
          } else {
            titleX = opts.position === 'left' ? left + offset : right - offset;
            titleY = top + (bottom - top) / 2;
            maxWidth = bottom - top;
            rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
          }

          ctx.save();
          ctx.translate(titleX, titleY);
          ctx.rotate(rotation);
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          var text = opts.text;

          if (helpers$1.isArray(text)) {
            var y = 0;

            for (var i = 0; i < text.length; ++i) {
              ctx.fillText(text[i], 0, y, maxWidth);
              y += lineHeight;
            }
          } else {
            ctx.fillText(text, 0, 0, maxWidth);
          }

          ctx.restore();
        }
      }
    });

    function createNewTitleBlockAndAttach(chart, titleOpts) {
      var title = new Title({
        ctx: chart.ctx,
        options: titleOpts,
        chart: chart
      });
      core_layouts.configure(chart, title, titleOpts);
      core_layouts.addBox(chart, title);
      chart.titleBlock = title;
    }

    var plugin_title = {
      id: 'title',

      /**
       * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
       * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
       * the plugin, which one will be re-exposed in the chart.js file.
       * https://github.com/chartjs/Chart.js/pull/2640
       * @private
       */
      _element: Title,
      beforeInit: function (chart) {
        var titleOpts = chart.options.title;

        if (titleOpts) {
          createNewTitleBlockAndAttach(chart, titleOpts);
        }
      },
      beforeUpdate: function (chart) {
        var titleOpts = chart.options.title;
        var titleBlock = chart.titleBlock;

        if (titleOpts) {
          helpers$1.mergeIf(titleOpts, core_defaults.global.title);

          if (titleBlock) {
            core_layouts.configure(chart, titleBlock, titleOpts);
            titleBlock.options = titleOpts;
          } else {
            createNewTitleBlockAndAttach(chart, titleOpts);
          }
        } else if (titleBlock) {
          core_layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        }
      }
    };
    var plugins = {};
    var filler = plugin_filler;
    var legend = plugin_legend;
    var title = plugin_title;
    plugins.filler = filler;
    plugins.legend = legend;
    plugins.title = title;
    /**
     * @namespace Chart
     */

    core_controller.helpers = helpers$1; // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!

    core_helpers(core_controller);
    core_controller._adapters = core_adapters;
    core_controller.Animation = core_animation;
    core_controller.animationService = core_animations;
    core_controller.controllers = controllers;
    core_controller.DatasetController = core_datasetController;
    core_controller.defaults = core_defaults;
    core_controller.Element = core_element;
    core_controller.elements = elements;
    core_controller.Interaction = core_interaction;
    core_controller.layouts = core_layouts;
    core_controller.platform = platform;
    core_controller.plugins = core_plugins;
    core_controller.Scale = core_scale;
    core_controller.scaleService = core_scaleService;
    core_controller.Ticks = core_ticks;
    core_controller.Tooltip = core_tooltip; // Register built-in scales

    core_controller.helpers.each(scales, function (scale, type) {
      core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
    }); // Load to register built-in adapters (as side effects)
    // Loading built-in plugins

    for (var k in plugins) {
      if (plugins.hasOwnProperty(k)) {
        core_controller.plugins.register(plugins[k]);
      }
    }

    core_controller.platform.initialize();
    var src = core_controller;

    if (typeof window !== 'undefined') {
      window.Chart = core_controller;
    } // DEPRECATIONS

    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Chart
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */


    core_controller.Chart = core_controller;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Legend
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Legend = plugins.legend._element;
    /**
     * Provided for backward compatibility, not available anymore
     * @namespace Chart.Title
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.Title = plugins.title._element;
    /**
     * Provided for backward compatibility, use Chart.plugins instead
     * @namespace Chart.pluginService
     * @deprecated since version 2.1.5
     * @todo remove at version 3
     * @private
     */

    core_controller.pluginService = core_controller.plugins;
    /**
     * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
     * effect, instead simply create/register plugins via plain JavaScript objects.
     * @interface Chart.PluginBase
     * @deprecated since version 2.5.0
     * @todo remove at version 3
     * @private
     */

    core_controller.PluginBase = core_controller.Element.extend({});
    /**
     * Provided for backward compatibility, use Chart.helpers.canvas instead.
     * @namespace Chart.canvasHelpers
     * @deprecated since version 2.6.0
     * @todo remove at version 3
     * @private
     */

    core_controller.canvasHelpers = core_controller.helpers.canvas;
    /**
     * Provided for backward compatibility, use Chart.layouts instead.
     * @namespace Chart.layoutService
     * @deprecated since version 2.7.3
     * @todo remove at version 3
     * @private
     */

    core_controller.layoutService = core_controller.layouts;
    /**
     * Provided for backward compatibility, not available anymore.
     * @namespace Chart.LinearScaleBase
     * @deprecated since version 2.8
     * @todo remove at version 3
     * @private
     */

    core_controller.LinearScaleBase = scale_linearbase;
    /**
     * Provided for backward compatibility, instead we should create a new Chart
     * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     */

    core_controller.helpers.each(['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'], function (klass) {
      core_controller[klass] = function (ctx, cfg) {
        return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
          type: klass.charAt(0).toLowerCase() + klass.slice(1)
        }));
      };
    });
    return src;
  });
});

function generateChart(chartId, chartType) {
  return {
    render: function render(createElement) {
      return createElement('div', {
        style: this.styles,
        class: this.cssClasses
      }, [createElement('canvas', {
        attrs: {
          id: this.chartId,
          width: this.width,
          height: this.height
        },
        ref: 'canvas'
      })]);
    },
    props: {
      chartId: {
        default: chartId,
        type: String
      },
      width: {
        default: 400,
        type: Number
      },
      height: {
        default: 400,
        type: Number
      },
      cssClasses: {
        type: String,
        default: ''
      },
      styles: {
        type: Object
      },
      plugins: {
        type: Array,
        default: function _default() {
          return [];
        }
      }
    },
    data: function data() {
      return {
        _chart: null,
        _plugins: this.plugins
      };
    },
    methods: {
      addPlugin: function addPlugin(plugin) {
        this.$data._plugins.push(plugin);
      },
      generateLegend: function generateLegend() {
        if (this.$data._chart) {
          return this.$data._chart.generateLegend();
        }
      },
      renderChart: function renderChart(data, options) {
        if (this.$data._chart) {
          this.$data._chart.destroy();
        }

        this.$data._chart = new Chart$1(this.$refs.canvas.getContext('2d'), {
          type: chartType,
          data: data,
          options: options,
          plugins: this.$data._plugins
        });
      }
    },
    beforeDestroy: function beforeDestroy() {
      if (this.$data._chart) {
        this.$data._chart.destroy();
      }
    }
  };
}
var Bar = generateChart('bar-chart', 'bar');
var HorizontalBar = generateChart('horizontalbar-chart', 'horizontalBar');
var Line = generateChart('line-chart', 'line');
var Pie = generateChart('pie-chart', 'pie');

var reactiveProp$1 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$1 = {
  "extends": Bar,
  mixins: [reactiveProp$1],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$1 = script$1;

/* template */

  /* style */
  var __vue_inject_styles__$1 = undefined;
  /* scoped */
  var __vue_scope_id__$1 = undefined;
  /* module identifier */
  var __vue_module_identifier__$1 = undefined;
  /* functional template */
  var __vue_is_functional_template__$1 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent = normalizeComponent_1(
    {},
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    undefined,
    undefined
  );

var chartLabels = ['1980', '1990', '2000', '2010', '2020'];
var chartDataList = [6542564, 7322564, 8008278, 8175133, 5475133];
var ChartData = {
  data: {
    labels: chartLabels,
    datasets: [{
      data: chartDataList,
      fill: false,
      // used by line chart
      backgroundColor: ['#2F334F', '#3155A6', '#F2695D', '#EBBCD8', '#F9A137'],
      borderColor: ['#ACAEB9'],
      borderWidth: 1
    }]
  },
  bar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  horizontalBar: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: false
      },
      lineTension: 1,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Population'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Years'
          },
          ticks: {
            padding: 25
          }
        }]
      }
    }
  },
  pie: {
    options: {
      title: {
        display: true,
        text: 'Population Chart'
      },
      legend: {
        display: true
      },
      lineTension: 1
    }
  }
};

var chartType = 'bar';

var ChartBar = function ChartBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType, ChartComponent);
  new Vue({
    el: "[data-js=\"chart-" + chartType + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$2 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$2 = {
  "extends": HorizontalBar,
  mixins: [reactiveProp$2],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$2 = script$2;

/* template */

  /* style */
  var __vue_inject_styles__$2 = undefined;
  /* scoped */
  var __vue_scope_id__$2 = undefined;
  /* module identifier */
  var __vue_module_identifier__$2 = undefined;
  /* functional template */
  var __vue_is_functional_template__$2 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$1 = normalizeComponent_1(
    {},
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    undefined,
    undefined
  );

var chartType$1 = 'horizontal-bar';

var ChartHorizontalBar = function ChartHorizontalBar(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartHorizontalBar.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$1, ChartComponent$1);
  new Vue({
    el: "[data-js=\"chart-" + chartType$1 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.horizontalBar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartHorizontalBar.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$3 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$3 = {
  "extends": Line,
  mixins: [reactiveProp$3],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: false
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$3 = script$3;

/* template */

  /* style */
  var __vue_inject_styles__$3 = undefined;
  /* scoped */
  var __vue_scope_id__$3 = undefined;
  /* module identifier */
  var __vue_module_identifier__$3 = undefined;
  /* functional template */
  var __vue_is_functional_template__$3 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$2 = normalizeComponent_1(
    {},
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3,
    __vue_module_identifier__$3,
    undefined,
    undefined
  );

var chartType$2 = 'line';

var ChartLine = function ChartLine(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartLine.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$2, ChartComponent$2);
  new Vue({
    el: "[data-js=\"chart-" + chartType$2 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.bar.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartLine.prototype._constants = function _constants(param) {
  console.dir(param);
};

var reactiveProp$4 = mixins.reactiveProp;
Chart.defaults.global.title.padding = 20;
Chart.defaults.global.title.fontSize = 16;
Chart.defaults.global.title.lineHeight = 1.6;
var script$4 = {
  "extends": Pie,
  mixins: [reactiveProp$4],
  props: {
    options: {
      type: Object,
      "default": function default$1() {
        return {
          legend: {
            display: true
          },
          lineTension: 1
        };
      }
    }
  },
  mounted: function mounted() {
    this.renderChart(this.chartData, this.options);
  }
};

/* script */
var __vue_script__$4 = script$4;

/* template */

  /* style */
  var __vue_inject_styles__$4 = undefined;
  /* scoped */
  var __vue_scope_id__$4 = undefined;
  /* module identifier */
  var __vue_module_identifier__$4 = undefined;
  /* functional template */
  var __vue_is_functional_template__$4 = undefined;
  /* style inject */
  
  /* style inject SSR */
  

  
  var ChartComponent$3 = normalizeComponent_1(
    {},
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4,
    __vue_module_identifier__$4,
    undefined,
    undefined
  );

var chartType$3 = 'pie';

var ChartPie = function ChartPie(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


ChartPie.prototype.init = function init() {
  Vue.component("nyco-chart-" + chartType$3, ChartComponent$3);
  new Vue({
    el: "[data-js=\"chart-" + chartType$3 + "\"]",
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        data: ChartData.data,
        options: ChartData.pie.options
      };
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


ChartPie.prototype._constants = function _constants(param) {
  console.dir(param);
};

//
//
var script$5 = {
  props: {
    'layers': {
      type: Array
    },
    'config': {
      type: Object
    }
  },
  data: function data() {
    return {
      map: null,
      mapPopup: null,
      mapFilter: null,
      activeLayer: null,
      mapLoaded: false,
      menuItems: [],
      selectedItems: []
    };
  },
  mounted: function mounted() {
    this.initializeMap();
  },
  destroyed: function destroyed() {
    this.map.remove();
  },
  watch: {
    'layers': function layers() {
      var layers = this.layers;

      if (this.config.mapType === 'multi') {
        for (var i = 0; i < layers.length; i++) {
          var layer = layers[i];
          this.trackLayer(layer.name);

          if (layer["default"] || this.layers.length === 1) {
            this.activeLayer = layer.name;
          }

          if (this.mapLoaded) {
            this.initializeLayer(layer);
          }
        }
      } else if (this.config.mapType === 'single') {
        var layer$1 = this.layers[0];
        this.activeLayer = layer$1.name;
        this.generateLegend(layer$1.data);

        if (this.mapLoaded) {
          this.initializeLayer(layer$1);
        }
      } else {
        throw new Error('mapType must be defined');
      }
    },
    'mapLoaded': function mapLoaded() {
      if (this.mapLoaded && this.layers.length) {
        var layers = this.layers;

        for (var i = 0; i < layers.length; i++) {
          this.initializeLayer(layers[i]);
        }
      }
    },
    'menuItems': function menuItems() {
      if (this.menuItems.length > 1) {
        this.initializeToggle(this.menuItems);
      }
    },
    'selectedItems': function selectedItems() {
      var layer = this.layers[0];
      var filter = ['in', layer.legendColumn];

      for (var i = 0; i < this.selectedItems.length; i++) {
        filter.push(this.selectedItems[i]);
      }

      if (this.selectedItems.length > 0) {
        var relatedFeatures = this.map.querySourceFeatures(layer.name, {
          sourceLayer: layer.name,
          filter: filter
        }); // set filter when legend item selected

        this.map.setFilter(layer.name + "-highlighted", filter);
        this.map.setLayoutProperty(layer.name + "-highlighted", 'visibility', 'visible');
      }

      if (!this.selectedItems.length && !this.mapPopup) {
        this.map.setFilter(layer.name + "-highlighted", null);
        this.map.setLayoutProperty(layer.name + "-highlighted", 'visibility', 'none');
      }
    }
  },
  methods: {
    initializeMap: function initializeMap() {
      var this$1 = this;
      var mapConfig = this.config;
      var options = {
        container: mapConfig.containerId
      };

      if (mapConfig.center) {
        options.center = mapConfig.center;
      }

      if (mapConfig.style) {
        options.style = mapConfig.style;
      }

      if (mapConfig.zoom) {
        options.zoom = mapConfig.zoom;
      }

      mapboxgl.accessToken = mapConfig.APIKey;
      this.map = new mapboxgl.Map(options);
      this.map.addControl(new mapboxgl.NavigationControl()); // disable map zoom when using scroll

      if (mapConfig.disableScroll) {
        this.map.scrollZoom.disable();
      }

      this.map.on('load', function () {
        return this$1.mapLoaded = true;
      });
    },
    initializeLayer: function initializeLayer(layer) {
      if (this.map.getLayer(layer.name) === undefined && Object.entries(layer.data).length !== 0) {
        var visibility = layer.name === this.activeLayer ? 'visible' : 'none';
        var filter = layer.filterBy ? ['in', layer.filterBy, ''] : [];
        var fill = this.config.colors ? this.generateFillColor(this.config.colors) : layer.fill;
        this.map.addSource(layer.name, {
          'type': 'geojson',
          'data': layer.data
        });
        this.map.addLayer({
          'id': layer.name,
          'type': 'fill',
          'source': layer.name,
          'paint': {
            'fill-outline-color': fill[0],
            'fill-color': fill[1],
            'fill-opacity': 0.7
          },
          'layout': {
            'visibility': visibility
          }
        });
        this.map.addLayer({
          'id': layer.name + "-highlighted",
          'type': 'fill',
          'source': layer.name,
          'paint': {
            'fill-outline-color': fill[0],
            'fill-color': fill[1],
            'fill-opacity': 1
          },
          'filter': filter,
          'layout': {
            'visibility': visibility
          }
        });
        this.initializeFilter(layer);
        this.updateCursorOnHover(layer.name);
      }
    },
    initializePopup: function initializePopup(event, layer) {
      this.config.mapType === 'multi' ? this.popupMultiLayer(event, layer) : this.popupSingleLayer(event, layer);
    },
    initializeToggle: function initializeToggle(toggleList) {
      this.config.mapType === 'multi' ? this.toggleMultiLayer(toggleList) : this.toggleSingleLayer(toggleList);
    },
    initializeFilter: function initializeFilter(layer) {
      this.config.mapType === 'multi' ? this.filterMultiLayer(layer) : this.filterSingleLayer(layer);
    },
    updateCursorOnHover: function updateCursorOnHover(layerId) {
      var map = this.map; // change the cursor to a pointer when the mouse is over the layer.

      map.on('mouseenter', layerId, function () {
        map.getCanvas().style.cursor = 'pointer';
      }); // change the cursor back to the default when it leaves the layer.

      map.on('mouseleave', layerId, function () {
        map.getCanvas().style.cursor = '';
      });
    },
    generateFillColor: function generateFillColor(colors) {
      return colors[Math.floor(Math.random() * colors.length)];
    },
    // multi layer
    trackLayer: function trackLayer(reference) {
      if (!this.menuItems.includes(reference)) {
        this.menuItems.push(reference);
      }
    },
    popupMultiLayer: function popupMultiLayer(event, layer) {
      var $this = this;
      var map = $this.map;
      var layerName = layer.name + "-highlighted";
      var popup = new mapboxgl.Popup().setLngLat(event.lngLat).setHTML(event.features[0].properties[layer.filterBy]).addTo(map);

      if (popup.isOpen()) {
        $this.mapPopup = popup;
        map.setLayoutProperty(layerName, 'visibility', 'visible');
        map.setFilter(layerName, $this.mapFilter);
      }

      popup.on('close', function () {
        // reset associated states when popup dismissed while active
        if ($this.mapPopup === popup) {
          $this.mapPopup = null;
          $this.mapFilter = null;
          map.setFilter(layerName, null);
          map.setLayoutProperty(layerName, 'visibility', 'none');
        }
      });
    },
    filterMultiLayer: function filterMultiLayer(layer) {
      var $this = this;
      var map = $this.map;
      map.on('click', layer.name, function (e) {
        // set bbox as reactangle area around clicked point
        var bbox = [[e.point.x, e.point.y], [e.point.x, e.point.y]];
        var features = map.queryRenderedFeatures(bbox, {
          layers: [layer.name]
        });
        var filter = features.reduce(function (memo, feature) {
          memo.push(feature.properties[layer.filterBy]);
          return memo;
        }, ['in', "" + layer.filterBy]);
        $this.mapFilter = filter;
        $this.initializePopup(e, layer);
      });
    },
    toggleMultiLayer: function toggleMultiLayer(layersToToggle) {
      var $this = this;
      var map = $this.map;
      var activeLayer = $this.activeLayer;
      var linkContainer = document.getElementById(this.config.legendId); // clear all links before appending new ones to prevent duplicates

      while (linkContainer.firstChild) {
        linkContainer.removeChild(linkContainer.firstChild);
      }

      for (var i = 0; i < layersToToggle.length; i++) {
        var layerRef = layersToToggle[i];
        var link = document.createElement('a');
        link.href = '#';
        link.textContent = layerRef;

        if (layerRef === activeLayer) {
          link.classList.add('active');
        } // on click update link state, active layer reference, and layer visibility


        link.onclick = function (e) {
          e.preventDefault();
          e.stopPropagation();
          var selectedLayer = this.textContent;
          var links = linkContainer.getElementsByTagName('a'); // remove active popup

          if ($this.mapPopup) {
            $this.mapPopup.remove();
          }

          for (var i = 0; i < links.length; i++) {
            var currentLink = links[i];
            var currentLayer = currentLink.textContent;
            var currentLayerHighlight = currentLayer + "-highlighted";
            var layerVisibility = map.getLayoutProperty(currentLayer, 'visibility');

            if (currentLayer === selectedLayer) {
              // return if layer is already selected
              if (layerVisibility === 'visible' && currentLink.classList.contains('active')) {
                return;
              } // set our current layer as the global active layer,
              // add active class to link, set layer as visible


              $this.activeLayer = currentLayer;
              currentLink.classList.add('active');
              map.setLayoutProperty(currentLayer, 'visibility', 'visible');
            } else {
              // remove links active class, set layer visibility to none and remove filters
              currentLink.classList.remove('active');
              map.setLayoutProperty(currentLayer, 'visibility', 'none');
              map.setLayoutProperty(currentLayerHighlight, 'visibility', 'none');
              map.setFilter(currentLayerHighlight, null);
            }
          }
        };

        linkContainer.appendChild(link);
      }
    },
    // single layer
    generateLegend: function generateLegend(layerData) {
      var this$1 = this;
      layerData.features.forEach(function (feature) {
        var item = feature.properties[this$1.layers[0].legendColumn];

        if (!this$1.menuItems.includes(item) && item) {
          this$1.menuItems.push(item);
        }
      });
    },
    popupSingleLayer: function popupSingleLayer(event, layer) {
      var $this = this;
      var map = $this.map;
      var layerName = layer.name + "-highlighted"; // check whether shape falls under current legend selection

      var inCurrentSelection = true;
      var columnFilter = event.features[0].properties[layer.legendColumn];

      if (!$this.selectedItems.includes(columnFilter)) {
        inCurrentSelection = false;
      }

      var popup = new mapboxgl.Popup().setLngLat(event.lngLat).setHTML(event.features[0].properties[layer.filterBy]).addTo(map);

      if (popup.isOpen()) {
        $this.mapPopup = popup; // if there are no legend items selected, highlight selected map shape

        if (!$this.selectedItems.length) {
          map.setLayoutProperty(layerName, 'visibility', 'visible');
          map.setFilter(layerName, $this.mapFilter);
        } // if there are legend items selected and selected map shape isn't
        // within any of the selected legend items, highlight selected
        // map shape and clear legend


        if ($this.selectedItems.length > 0 && !inCurrentSelection) {
          map.setLayoutProperty(layerName, 'visibility', 'visible');
          map.setFilter(layerName, $this.mapFilter); // reset all checked legend items

          $this.selectedItems = [];
          var filterGroupInputs = document.getElementById(this.config.legendId).querySelectorAll('input:checked');

          for (var i = 0; i < filterGroupInputs.length; i++) {
            filterGroupInputs[i].checked = false;
          }
        }
      }

      popup.on('close', function () {
        // reset associated states when popup dismissed while active
        if ($this.mapPopup === popup) {
          $this.mapPopup = null;
          $this.mapFilter = null; // if there are no legend items selected, reset all filters

          if (!$this.selectedItems.length) {
            map.setFilter(layerName, null);
            map.setLayoutProperty(layerName, 'visibility', 'none');
          }
        }
      });
    },
    filterSingleLayer: function filterSingleLayer(layer) {
      var $this = this;
      var map = $this.map;
      map.on('click', layer.name, function (e) {
        // set bbox as reactangle area around clicked point
        var bbox = [[e.point.x, e.point.y], [e.point.x, e.point.y]];
        var features = map.queryRenderedFeatures(bbox, {
          layers: [layer.name]
        });
        var legendColumnValue = null;
        var filter = features.reduce(function (memo, feature) {
          legendColumnValue = feature.properties[layer.legendColumn];
          memo.push(feature.properties[layer.filterBy]);
          return memo;
        }, ['in', "" + layer.filterBy]);
        $this.mapFilter = filter;
        $this.initializePopup(e, layer);
      });
    },
    toggleSingleLayer: function toggleSingleLayer(filtersToToggle) {
      var $this = this;
      var map = $this.map;
      var filterGroup = document.getElementById(this.config.legendId);
      var layer = $this.layers[0];
      var legendColumn = layer.legendColumn; // clear all links before appending new ones to prevent duplicates

      while (filterGroup.firstChild) {
        filterGroup.removeChild(filterGroup.firstChild);
      } // initilize an input element for each filter type


      for (var i = 0; i < filtersToToggle.length; i++) {
        var layerRef = filtersToToggle[i]; // checkbox

        var input = document.createElement('input');
        input.type = 'checkbox';
        input.id = layerRef;
        input.value = layerRef;
        filterGroup.appendChild(input); // checkbox label

        var label = document.createElement('label');
        label.setAttribute('for', layerRef);
        label.setAttribute('title', layerRef);
        label.textContent = layerRef;
        filterGroup.appendChild(label); // when the checkbox changes state, update the selected items array.

        input.addEventListener('change', function (e) {
          var item = e.target.value; // reset the checkboxes checked state

          e.target.checked ? 'visible' : 'none'; // remove popup if one exists

          if ($this.mapPopup) {
            $this.mapPopup.remove();
          }

          if (e.target.checked && !$this.selectedItems.includes(item)) {
            $this.selectedItems.push(item);
          }

          if (!e.target.checked && $this.selectedItems.includes(item)) {
            $this.selectedItems = $this.selectedItems.filter(function (val) {
              return val !== item;
            });
          }
        });
      }
    }
  }
};

/* script */
var __vue_script__$5 = script$5;

/* template */
var __vue_render__$1 = function() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div")
};
var __vue_staticRenderFns__$1 = [];
__vue_render__$1._withStripped = true;

  /* style */
  var __vue_inject_styles__$5 = undefined;
  /* scoped */
  var __vue_scope_id__$5 = undefined;
  /* module identifier */
  var __vue_module_identifier__$5 = undefined;
  /* functional template */
  var __vue_is_functional_template__$5 = false;
  /* style inject */
  
  /* style inject SSR */
  

  
  var MapComponent = normalizeComponent_1(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$5,
    __vue_script__$5,
    __vue_scope_id__$5,
    __vue_is_functional_template__$5,
    __vue_module_identifier__$5,
    undefined,
    undefined
  );

/**
 * Config
 */
var nycoColors = {
  colors: {
    'primary-navy': '#2F334F',
    'primary-navy-70t': '#6E7085',
    'primary-navy-50t': '#9698A7',
    'primary-navy-30t': '#C0C2CA',
    'primary-blue': '#3155A6',
    'primary-blue-70t': '#6C88C1',
    'primary-blue-50t': '#96ABD2',
    'primary-blue-30t': '#C0CCE3',
    'primary-red': '#F2695D',
    'primary-red-70t': '#F6958D',
    'primary-red-50t': '#F8B2AD',
    'primary-red-30t': '#FBD1CE',
    'secondary-grey': '#ACAEB9',
    'secondary-grey-70t': '#C4C6CD',
    'secondary-grey-50t': '#D5D6DC',
    'secondary-grey-30t': '#E8E7E9',
    'secondary-white': '#F3F3F3',
    'secondary-white-70t': '#F6F6F6',
    'secondary-white-50t': '#F9F9FA',
    'secondary-white-30t': '#FBFCFC',
    'secondary-orange': '#F9A137',
    'secondary-orange-70t': '#FFA133',
    'secondary-orange-50t': '#FED09A',
    'secondary-orange-30t': '#FFE3C2',
    'secondary-pink': '#EBBCD8',
    'secondary-pink-70t': '#F2D0E3',
    'secondary-pink-50t': '#F7DDEB',
    'secondary-pink-30t': '#FDEBF3',
    'base-black': '#000000',
    'base-white': '#FFFFFF'
  },
  colorCombinations: {
    'light-background': {
      'color': 'base-black',
      'headings': 'primary-navy',
      'hyperlinks': 'primary-blue',
      'visited': 'primary-blue',
      'hover': 'primary-navy',
      'background-color': 'base-white',
      'border': 'secondary-grey',
      'placeholder': 'secondary-grey',
      'checkbox-background': 'primary-navy',
      'error': 'primary-red'
    },
    'mid-background': {
      'color': 'base-black',
      'headings': 'primary-navy',
      'hyperlinks': 'primary-blue',
      'visited': 'primary-blue',
      'hover': 'primary-navy',
      'background-color': 'secondary-white'
    },
    'dark-background': {
      'color': 'base-white',
      'font-smooth': true,
      'headings': 'base-white',
      'hyperlinks': 'base-white',
      'visited': 'base-white',
      'hover': 'base-white',
      'background-color': 'primary-navy'
    },
    'primary-button': {
      'font-weight': 'bold',
      'color': 'base-white',
      'font-smooth': true,
      'background-color': 'primary-blue'
    },
    'secondary-button': {
      'font-weight': 'bold',
      'color': 'base-white',
      'font-smooth': true,
      'background-color': 'primary-red'
    }
  }
};
var color = nycoColors.colors;
var mapColorCombinations = [[color['primary-navy'], color['primary-navy-70t']], [color['base-black'], color['secondary-orange']], [color['primary-navy'], color['secondary-grey']], [color['primary-blue'], color['secondary-orange']]];
var colors = {
  nycoColors: nycoColors,
  mapColorCombinations: mapColorCombinations
};
var colors_2 = colors.mapColorCombinations;

var MapData = {
  single: {
    layers: [],
    config: {
      APIKey: 'pk.eyJ1Ijoibnljby1wcm9kdWN0cyIsImEiOiJjanZjZ3Y4b2IxNXYwM3l0ZDN6bWN4ajA5In0.XSt-hoz5p3j2siyli0g0og',
      containerId: 'nyco-map-sl',
      legendId: 'nyco-map-legend',
      center: [-73.986710, 40.693391],
      zoom: 9,
      disableScroll: true,
      style: 'mapbox://styles/nyco-products/cjv6wjq8812ys1gp39mnvuk2w',
      mapType: 'single'
    }
  },
  multi: {
    layers: [],
    config: {
      APIKey: 'pk.eyJ1Ijoibnljby1wcm9kdWN0cyIsImEiOiJjanZjZ3Y4b2IxNXYwM3l0ZDN6bWN4ajA5In0.XSt-hoz5p3j2siyli0g0og',
      containerId: 'nyco-map-ml',
      legendId: 'nyco-map-menu',
      center: [-73.986710, 40.693391],
      zoom: 9,
      disableScroll: true,
      style: 'mapbox://styles/nyco-products/cjv6wjq8812ys1gp39mnvuk2w',
      mapType: 'multi',
      colors: colors_2
    }
  }
};

var geojson = createCommonjsModule(function (module) {
  (function (GeoJSON) {
    GeoJSON.version = '0.5.0'; // Allow user to specify default parameters

    GeoJSON.defaults = {
      doThrows: {
        invalidGeometry: false
      }
    };

    function InvalidGeometryError() {
      var args = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
      var item = args.shift();
      var params = args.shift();
      Error.apply(this, args);
      this.message = this.message || "Invalid Geometry: " + 'item: ' + JSON.stringify(item) + ', params: ' + JSON.stringify(params);
    }

    InvalidGeometryError.prototype = Error;
    GeoJSON.errors = {
      InvalidGeometryError: InvalidGeometryError
    }; //exposing so this can be overriden maybe by geojson-validation or the like

    GeoJSON.isGeometryValid = function (geometry) {
      if (!geometry || !Object.keys(geometry).length) {
        return false;
      }

      return !!geometry.type && !!geometry.coordinates && Array.isArray(geometry.coordinates) && !!geometry.coordinates.length;
    }; // The one and only public function.
    // Converts an array of objects into a GeoJSON feature collection


    GeoJSON.parse = function (objects, params, callback) {
      var geojson,
          settings = applyDefaults(params, this.defaults),
          propFunc;
      geomAttrs.length = 0; // Reset the list of geometry fields

      setGeom(settings);
      propFunc = getPropFunction(settings);

      if (Array.isArray(objects)) {
        geojson = {
          "type": "FeatureCollection",
          "features": []
        };
        objects.forEach(function (item) {
          geojson.features.push(getFeature({
            item: item,
            params: settings,
            propFunc: propFunc
          }));
        });
        addOptionals(geojson, settings);
      } else {
        geojson = getFeature({
          item: objects,
          params: settings,
          propFunc: propFunc
        });
        addOptionals(geojson, settings);
      }

      if (callback && typeof callback === 'function') {
        callback(geojson);
      } else {
        return geojson;
      }
    }; // Helper functions


    var geoms = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon', 'GeoJSON'],
        geomAttrs = []; // Adds default settings to user-specified params
    // Does not overwrite any settings--only adds defaults
    // the the user did not specify

    function applyDefaults(params, defaults) {
      var settings = params || {};

      for (var setting in defaults) {
        if (defaults.hasOwnProperty(setting) && !settings[setting]) {
          settings[setting] = defaults[setting];
        }
      }

      return settings;
    } // Adds the optional GeoJSON properties crs and bbox
    // if they have been specified


    function addOptionals(geojson, settings) {
      if (settings.crs && checkCRS(settings.crs)) {
        if (settings.isPostgres) {
          geojson.geometry.crs = settings.crs;
        } else {
          geojson.crs = settings.crs;
        }
      }

      if (settings.bbox) {
        geojson.bbox = settings.bbox;
      }

      if (settings.extraGlobal) {
        geojson.properties = {};

        for (var key in settings.extraGlobal) {
          geojson.properties[key] = settings.extraGlobal[key];
        }
      }
    } // Verify that the structure of CRS object is valid


    function checkCRS(crs) {
      if (crs.type === 'name') {
        if (crs.properties && crs.properties.name) {
          return true;
        } else {
          throw new Error('Invalid CRS. Properties must contain "name" key');
        }
      } else if (crs.type === 'link') {
        if (crs.properties && crs.properties.href && crs.properties.type) {
          return true;
        } else {
          throw new Error('Invalid CRS. Properties must contain "href" and "type" key');
        }
      } else {
        throw new Error('Invald CRS. Type attribute must be "name" or "link"');
      }
    } // Moves the user-specified geometry parameters
    // under the `geom` key in param for easier access


    function setGeom(params) {
      params.geom = {};

      for (var param in params) {
        if (params.hasOwnProperty(param) && geoms.indexOf(param) !== -1) {
          params.geom[param] = params[param];
          delete params[param];
        }
      }

      setGeomAttrList(params.geom);
    } // Adds fields which contain geometry data
    // to geomAttrs. This list is used when adding
    // properties to the features so that no geometry
    // fields are added the properties key


    function setGeomAttrList(params) {
      for (var param in params) {
        if (params.hasOwnProperty(param)) {
          if (typeof params[param] === 'string') {
            geomAttrs.push(params[param]);
          } else if (typeof params[param] === 'object') {
            // Array of coordinates for Point
            geomAttrs.push(params[param][0]);
            geomAttrs.push(params[param][1]);
          }
        }
      }

      if (geomAttrs.length === 0) {
        throw new Error('No geometry attributes specified');
      }
    } // Creates a feature object to be added
    // to the GeoJSON features array


    function getFeature(args) {
      var item = args.item,
          params = args.params,
          propFunc = args.propFunc;
      var feature = {
        "type": "Feature"
      };
      feature.geometry = buildGeom(item, params);
      feature.properties = propFunc.call(item);
      return feature;
    }

    function isNested(val) {
      return /^.+\..+$/.test(val);
    } // Assembles the `geometry` property
    // for the feature output


    function buildGeom(item, params) {
      var geom = {};

      for (var gtype in params.geom) {
        var val = params.geom[gtype]; // Geometry parameter specified as: {Point: 'coords'}

        if (typeof val === 'string' && item.hasOwnProperty(val)) {
          if (gtype === 'GeoJSON') {
            geom = item[val];
          } else {
            geom.type = gtype;
            geom.coordinates = item[val];
          }
        }
        /* Handle things like:
        Polygon: {
          northeast: ['lat', 'lng'],
          southwest: ['lat', 'lng']
        }
        */
        else if (typeof val === 'object' && !Array.isArray(val)) {
            /*jshint loopfunc: true */
            var points = Object.keys(val).map(function (key) {
              var order = val[key];
              var newItem = item[key];
              return buildGeom(newItem, {
                geom: {
                  Point: order
                }
              });
            });
            geom.type = gtype;
            /*jshint loopfunc: true */

            geom.coordinates = [].concat(points.map(function (p) {
              return p.coordinates;
            }));
          } // Geometry parameter specified as: {Point: ['lat', 'lng']}
          else if (Array.isArray(val) && item.hasOwnProperty(val[0]) && item.hasOwnProperty(val[1])) {
              geom.type = gtype;
              geom.coordinates = [Number(item[val[1]]), Number(item[val[0]])];
            } // Geometry parameter specified as: {Point: ['container.lat', 'container.lng']}
            else if (Array.isArray(val) && isNested(val[0]) && isNested(val[1])) {
                var coordinates = [];

                for (var i = 0; i < val.length; i++) {
                  // i.e. 0 and 1
                  var paths = val[i].split('.');
                  var itemClone = item;

                  for (var j = 0; j < paths.length; j++) {
                    if (!itemClone.hasOwnProperty(paths[j])) {
                      return false;
                    }

                    itemClone = itemClone[paths[j]]; // Iterate deeper into the object
                  }

                  coordinates[i] = itemClone;
                }

                geom.type = gtype;
                geom.coordinates = [Number(coordinates[1]), Number(coordinates[0])];
              }
      }

      if (params.doThrows && params.doThrows.invalidGeometry && !GeoJSON.isGeometryValid(geom)) {
        throw new InvalidGeometryError(item, params);
      }

      return geom;
    } // Returns the function to be used to
    // build the properties object for each feature


    function getPropFunction(params) {
      var func;

      if (!params.exclude && !params.include) {
        func = function (properties) {
          for (var attr in this) {
            if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1) {
              properties[attr] = this[attr];
            }
          }
        };
      } else if (params.include) {
        func = function (properties) {
          params.include.forEach(function (attr) {
            properties[attr] = this[attr];
          }, this);
        };
      } else if (params.exclude) {
        func = function (properties) {
          for (var attr in this) {
            if (this.hasOwnProperty(attr) && geomAttrs.indexOf(attr) === -1 && params.exclude.indexOf(attr) === -1) {
              properties[attr] = this[attr];
            }
          }
        };
      }

      return function () {
        var properties = {};
        func.call(this, properties);

        if (params.extra) {
          addExtra(properties, params.extra);
        }

        return properties;
      };
    } // Adds data contained in the `extra`
    // parameter if it has been specified


    function addExtra(properties, extra) {
      for (var key in extra) {
        if (extra.hasOwnProperty(key)) {
          properties[key] = extra[key];
        }
      }

      return properties;
    }
  })(module.exports);
});

var RADIUS = 6378137;
var FLATTENING = 1 / 298.257223563;
var POLAR_RADIUS = 6356752.3142;
var wgs84 = {
  RADIUS: RADIUS,
  FLATTENING: FLATTENING,
  POLAR_RADIUS: POLAR_RADIUS
};

var geometry_1 = geometry;
var ring = ringArea;

function geometry(_) {
  var area = 0,
      i;

  switch (_.type) {
    case 'Polygon':
      return polygonArea(_.coordinates);

    case 'MultiPolygon':
      for (i = 0; i < _.coordinates.length; i++) {
        area += polygonArea(_.coordinates[i]);
      }

      return area;

    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
      return 0;

    case 'GeometryCollection':
      for (i = 0; i < _.geometries.length; i++) {
        area += geometry(_.geometries[i]);
      }

      return area;
  }
}

function polygonArea(coords) {
  var area = 0;

  if (coords && coords.length > 0) {
    area += Math.abs(ringArea(coords[0]));

    for (var i = 1; i < coords.length; i++) {
      area -= Math.abs(ringArea(coords[i]));
    }
  }

  return area;
}
/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */


function ringArea(coords) {
  var p1,
      p2,
      p3,
      lowerIndex,
      middleIndex,
      upperIndex,
      i,
      area = 0,
      coordsLength = coords.length;

  if (coordsLength > 2) {
    for (i = 0; i < coordsLength; i++) {
      if (i === coordsLength - 2) {
        // i = N-2
        lowerIndex = coordsLength - 2;
        middleIndex = coordsLength - 1;
        upperIndex = 0;
      } else if (i === coordsLength - 1) {
        // i = N-1
        lowerIndex = coordsLength - 1;
        middleIndex = 0;
        upperIndex = 1;
      } else {
        // i = 0 to N-3
        lowerIndex = i;
        middleIndex = i + 1;
        upperIndex = i + 2;
      }

      p1 = coords[lowerIndex];
      p2 = coords[middleIndex];
      p3 = coords[upperIndex];
      area += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));
    }

    area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
  }

  return area;
}

function rad(_) {
  return _ * Math.PI / 180;
}

var geojsonArea = {
  geometry: geometry_1,
  ring: ring
};

var geojsonRewind = rewind;

function rewind(gj, outer) {
  switch (gj && gj.type || null) {
    case 'FeatureCollection':
      gj.features = gj.features.map(curryOuter(rewind, outer));
      return gj;

    case 'Feature':
      gj.geometry = rewind(gj.geometry, outer);
      return gj;

    case 'Polygon':
    case 'MultiPolygon':
      return correct(gj, outer);

    default:
      return gj;
  }
}

function curryOuter(a, b) {
  return function (_) {
    return a(_, b);
  };
}

function correct(_, outer) {
  if (_.type === 'Polygon') {
    _.coordinates = correctRings(_.coordinates, outer);
  } else if (_.type === 'MultiPolygon') {
    _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));
  }

  return _;
}

function correctRings(_, outer) {
  outer = !!outer;
  _[0] = wind(_[0], outer);

  for (var i = 1; i < _.length; i++) {
    _[i] = wind(_[i], !outer);
  }

  return _;
}

function wind(_, dir) {
  return cw(_) === dir ? _ : _.reverse();
}

function cw(_) {
  return geojsonArea.ring(_) >= 0;
}

var MapMultiLayer = function MapMultiLayer(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


MapMultiLayer.prototype.init = function init() {
  Vue.component('nyco-map-ml', MapComponent);
  new Vue({
    el: '[data-js="nyco-map-ml"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        layers: MapData.multi.layers,
        config: MapData.multi.config
      };
    },
    created: function created() {
      this.getZipcodeData();
      this.getBoroughData();
      this.getNeighborhoodData();
    },
    methods: {
      getZipcodeData: function getZipcodeData() {
        fetch('https://cdn.jsdelivr.net/gh/kimpenguin/geoJSON@master/tiger-zcta.geojson').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        })["catch"](function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          MapData.multi.layers.push({
            name: 'zipcodes',
            data: JSON.parse(data),
            "default": true,
            filterBy: 'GEOID10'
          });
        });
      },
      getBoroughData: function getBoroughData() {
        var this$1 = this;
        fetch('https://data.cityofnewyork.us/resource/7t3b-ywvw.json').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        })["catch"](function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          data = JSON.parse(data);
          MapData.multi.layers.push({
            name: 'boroughs',
            data: this$1.convertToGeoJSON(data),
            "default": false,
            filterBy: 'boro_name'
          });
        });
      },
      getNeighborhoodData: function getNeighborhoodData() {
        var this$1 = this;
        fetch('https://data.cityofnewyork.us/resource/q2z5-ai38.json').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        })["catch"](function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          data = JSON.parse(data);
          MapData.multi.layers.push({
            name: 'neighborhoods',
            data: this$1.convertToGeoJSON(data),
            "default": false,
            filterBy: 'ntaname'
          });
        });
      },
      convertToGeoJSON: function convertToGeoJSON(jsonData) {
        // ensure geojson satisfies right-hand rule
        var data = geojsonRewind(geojson.parse(jsonData, {
          GeoJSON: 'the_geom'
        }));
        return data;
      }
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


MapMultiLayer.prototype._constants = function _constants(param) {
  console.dir(param);
};

var MapSingleLayer = function MapSingleLayer(settings, data) {
  if (settings === void 0) settings = {};
  if (data === void 0) data = {};
  this.data = data;
  this.settings = settings;
  this.init();
};
/**
 * Initializes the module
 */


MapSingleLayer.prototype.init = function init() {
  Vue.component('nyco-map-sl', MapComponent);
  new Vue({
    el: '[data-js="nyco-map-sl"]',
    delimiters: ['v{', '}'],
    data: function data() {
      return {
        layers: MapData.single.layers,
        config: MapData.single.config
      };
    },
    created: function created() {
      this.getData();
    },
    methods: {
      getData: function getData() {
        fetch('https://cdn.jsdelivr.net/gh/kimpenguin/geoJSON@master/nyco-nyc_zipcodes.geojson').then(function (response) {
          if (response.ok) {
            return response.text();
          } else // eslint-disable-next-line no-console
            if (Utility.debug()) {
              console.dir(response);
            }
        })["catch"](function (error) {
          // eslint-disable-next-line no-console
          if (Utility.debug()) {
            console.dir(error);
          }
        }).then(function (data) {
          MapData.single.layers.push({
            name: 'nyco-nyc_zipcodes',
            data: JSON.parse(data),
            filterBy: 'ZCTA5CE10',
            legendColumn: 'BORO',
            fill: colors_2[3]
          });
        });
      }
    }
  });
};
/**
 * Logs constants to the debugger
 * @param{object} param - our constants
 */


MapSingleLayer.prototype._constants = function _constants(param) {
  console.dir(param);
};

/**
 * JaroWinkler function.
 * https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance
 * @param {string} s1 string one.
 * @param {string} s2 second string.
 * @return {number} amount of matches.
 */
function jaro(s1, s2) {
  var assign;
  var shorter;
  var longer;
  assign = s1.length > s2.length ? [s1, s2] : [s2, s1], longer = assign[0], shorter = assign[1];
  var matchingWindow = Math.floor(longer.length / 2) - 1;
  var shorterMatches = [];
  var longerMatches = [];

  for (var i = 0; i < shorter.length; i++) {
    var ch = shorter[i];
    var windowStart = Math.max(0, i - matchingWindow);
    var windowEnd = Math.min(i + matchingWindow + 1, longer.length);

    for (var j = windowStart; j < windowEnd; j++) {
      if (longerMatches[j] === undefined && ch === longer[j]) {
        shorterMatches[i] = longerMatches[j] = ch;
        break;
      }
    }
  }

  var shorterMatchesString = shorterMatches.join('');
  var longerMatchesString = longerMatches.join('');
  var numMatches = shorterMatchesString.length;
  var transpositions = 0;

  for (var i$1 = 0; i$1 < shorterMatchesString.length; i$1++) {
    if (shorterMatchesString[i$1] !== longerMatchesString[i$1]) {
      transpositions++;
    }
  }

  return numMatches > 0 ? (numMatches / shorter.length + numMatches / longer.length + (numMatches - Math.floor(transpositions / 2)) / numMatches) / 3.0 : 0;
}
/**
 * @param {string} s1 string one.
 * @param {string} s2 second string.
 * @param {number} prefixScalingFactor
 * @return {number} jaroSimilarity
 */


function jaroWinkler (s1, s2, prefixScalingFactor) {
  if (prefixScalingFactor === void 0) prefixScalingFactor = 0.2;
  var jaroSimilarity = jaro(s1, s2);
  var commonPrefixLength = 0;

  for (var i = 0; i < s1.length; i++) {
    if (s1[i] === s2[i]) {
      commonPrefixLength++;
    } else {
      break;
    }
  }

  return jaroSimilarity + Math.min(commonPrefixLength, 4) * prefixScalingFactor * (1 - jaroSimilarity);
}

function memoize$1 (fn) {
  var cache = {};
  return function () {
    var args = [],
        len = arguments.length;

    while (len--) {
      args[len] = arguments[len];
    }

    var key = JSON.stringify(args);
    return cache[key] || (cache[key] = fn.apply(void 0, args));
  };
}

/* eslint-env browser */
/**
 * Autocomplete for autocomplete.
 * Forked and modified from https://github.com/xavi/miss-plete
 */

var Autocomplete = function Autocomplete(settings) {
  var this$1 = this;
  if (settings === void 0) settings = {};
  this.settings = {
    'selector': settings.selector,
    // required
    'options': settings.options,
    // required
    'classname': settings.classname,
    // required
    'selected': settings.hasOwnProperty('selected') ? settings.selected : false,
    'score': settings.hasOwnProperty('score') ? settings.score : memoize$1(Autocomplete.score),
    'listItem': settings.hasOwnProperty('listItem') ? settings.listItem : Autocomplete.listItem,
    'getSiblingIndex': settings.hasOwnProperty('getSiblingIndex') ? settings.getSiblingIndex : Autocomplete.getSiblingIndex
  };
  this.scoredOptions = null;
  this.container = null;
  this.ul = null;
  this.highlighted = -1;
  this.SELECTORS = Autocomplete.selectors;
  this.STRINGS = Autocomplete.strings;
  this.MAX_ITEMS = Autocomplete.maxItems;
  window.addEventListener('keydown', function (e) {
    this$1.keydownEvent(e);
  });
  window.addEventListener('keyup', function (e) {
    this$1.keyupEvent(e);
  });
  window.addEventListener('input', function (e) {
    this$1.inputEvent(e);
  });
  var body = document.querySelector('body');
  body.addEventListener('focus', function (e) {
    this$1.focusEvent(e);
  }, true);
  body.addEventListener('blur', function (e) {
    this$1.blurEvent(e);
  }, true);
  return this;
};
/**
 * EVENTS
 */

/**
 * The input focus event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.focusEvent = function focusEvent(event) {
  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.input.value === '') {
    this.message('INIT');
  }
};
/**
 * The input keydown event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.keydownEvent = function keydownEvent(event) {
  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.ul) {
    switch (event.keyCode) {
      case 13:
        this.keyEnter(event);
        break;

      case 27:
        this.keyEscape(event);
        break;

      case 40:
        this.keyDown(event);
        break;

      case 38:
        this.keyUp(event);
        break;
    }
  }
};
/**
 * The input keyup event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.keyupEvent = function keyupEvent(event) {
  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;
};
/**
 * The input event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.inputEvent = function inputEvent(event) {
  var this$1 = this;

  if (!event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.input.value.length > 0) {
    this.scoredOptions = this.settings.options.map(function (option) {
      return this$1.settings.score(this$1.input.value, option);
    }).sort(function (a, b) {
      return b.score - a.score;
    });
  } else {
    this.scoredOptions = [];
  }

  this.dropdown();
};
/**
 * The input blur event
 * @param {object}eventThe event object
 */


Autocomplete.prototype.blurEvent = function blurEvent(event) {
  if (event.target === window || !event.target.matches(this.settings.selector)) {
    return;
  }

  this.input = event.target;

  if (this.input.dataset.persistDropdown === 'true') {
    return;
  }

  this.remove();
  this.highlighted = -1;
};
/**
 * KEY INPUT EVENTS
 */

/**
 * What happens when the user presses the down arrow
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyDown = function keyDown(event) {
  event.preventDefault();
  this.highlight(this.highlighted < this.ul.children.length - 1 ? this.highlighted + 1 : -1);
  return this;
};
/**
 * What happens when the user presses the up arrow
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyUp = function keyUp(event) {
  event.preventDefault();
  this.highlight(this.highlighted > -1 ? this.highlighted - 1 : this.ul.children.length - 1);
  return this;
};
/**
 * What happens when the user presses the enter key
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyEnter = function keyEnter(event) {
  this.selected();
  return this;
};
/**
 * What happens when the user presses the escape key
 * @param {object}eventThe event object
 * @return{object}       The Class
 */


Autocomplete.prototype.keyEscape = function keyEscape(event) {
  this.remove();
  return this;
};
/**
 * STATIC
 */

/**
 * It must return an object with at least the properties 'score'
 * and 'displayValue.' Default is a Jaro–Winkler similarity function.
 * @param{array}value
 * @param{array}synonyms
 * @return {int}  Score or displayValue
 */


Autocomplete.score = function score(value, synonyms) {
  var closestSynonym = null;
  synonyms.forEach(function (synonym) {
    var similarity = jaroWinkler(synonym.trim().toLowerCase(), value.trim().toLowerCase());

    if (closestSynonym === null || similarity > closestSynonym.similarity) {
      closestSynonym = {
        similarity: similarity,
        value: synonym
      };

      if (similarity === 1) {
        return;
      }
    }
  });
  return {
    score: closestSynonym.similarity,
    displayValue: synonyms[0]
  };
};
/**
 * List item for dropdown list.
 * @param{Number}scoredOption
 * @param{Number}index
 * @return {string}The a list item <li>.
 */


Autocomplete.listItem = function listItem(scoredOption, index, maxItems) {
  var normalizedIndex = index + 1; // start at 1

  var li = normalizedIndex > maxItems ? null : document.createElement('li');

  if (li) {
    li.setAttribute('role', 'option');
    li.setAttribute('tabindex', '-1');
    li.setAttribute('aria-selected', 'false');
  }

  li && li.appendChild(document.createTextNode(scoredOption.displayValue));
  return li;
};
/**
 * Get index of previous element.
 * @param{array} node
 * @return {number}index of previous element.
 */


Autocomplete.getSiblingIndex = function getSiblingIndex(node) {
  var index = -1;
  var n = node;

  do {
    index++;
    n = n.previousElementSibling;
  } while (n);

  return index;
};
/**
 * PUBLIC METHODS
 */

/**
 * Display options as a list.
 * @return{object} The Class
 */


Autocomplete.prototype.dropdown = function dropdown() {
  var this$1 = this;
  var documentFragment = document.createDocumentFragment();
  this.scoredOptions.every(function (scoredOption, i) {
    var listItem = this$1.settings.listItem(scoredOption, i, this$1.MAX_ITEMS);
    listItem && documentFragment.appendChild(listItem);
    return !!listItem;
  });
  this.remove();
  this.highlighted = -1;

  if (documentFragment.hasChildNodes()) {
    var newUl = document.createElement('ul');
    newUl.setAttribute('role', 'listbox');
    newUl.setAttribute('tabindex', '0');
    newUl.setAttribute('id', this.SELECTORS.OPTIONS);
    newUl.addEventListener('mouseover', function (event) {
      if (event.target.tagName === 'LI') {
        this$1.highlight(this$1.settings.getSiblingIndex(event.target));
      }
    });
    newUl.addEventListener('mousedown', function (event) {
      return event.preventDefault();
    });
    newUl.addEventListener('click', function (event) {
      if (event.target.tagName === 'LI') {
        this$1.selected();
      }
    });
    newUl.appendChild(documentFragment); // See CSS to understand why the <ul> has to be wrapped in a <div>

    var newContainer = document.createElement('div');
    newContainer.className = this.settings.classname;
    newContainer.appendChild(newUl);
    this.input.setAttribute('aria-expanded', 'true'); // Inserts the dropdown just after the <input> element

    this.input.parentNode.insertBefore(newContainer, this.input.nextSibling);
    this.container = newContainer;
    this.ul = newUl;
    this.message('TYPING', this.settings.options.length);
  }

  return this;
};
/**
 * Highlight new option selected.
 * @param {Number}newIndex
 * @return{object}The Class
 */


Autocomplete.prototype.highlight = function highlight(newIndex) {
  if (newIndex > -1 && newIndex < this.ul.children.length) {
    // If any option already selected, then unselect it
    if (this.highlighted !== -1) {
      this.ul.children[this.highlighted].classList.remove(this.SELECTORS.HIGHLIGHT);
      this.ul.children[this.highlighted].removeAttribute('aria-selected');
      this.ul.children[this.highlighted].removeAttribute('id');
      this.input.removeAttribute('aria-activedescendant');
    }

    this.highlighted = newIndex;

    if (this.highlighted !== -1) {
      this.ul.children[this.highlighted].classList.add(this.SELECTORS.HIGHLIGHT);
      this.ul.children[this.highlighted].setAttribute('aria-selected', 'true');
      this.ul.children[this.highlighted].setAttribute('id', this.SELECTORS.ACTIVE_DESCENDANT);
      this.input.setAttribute('aria-activedescendant', this.SELECTORS.ACTIVE_DESCENDANT);
    }
  }

  return this;
};
/**
 * Selects an option from a list of items.
 * @return{object} The Class
 */


Autocomplete.prototype.selected = function selected() {
  if (this.highlighted !== -1) {
    this.input.value = this.scoredOptions[this.highlighted].displayValue;
    this.remove();
    this.message('SELECTED', this.input.value);

    if (window.innerWidth <= 768) {
      this.input.scrollIntoView(true);
    }
  } // User provided callback method for selected option.


  if (this.settings.selected) {
    this.settings.selected(this.input.value, this);
  }

  return this;
};
/**
 * Remove dropdown list once a list item is selected.
 * @return{object} The Class
 */


Autocomplete.prototype.remove = function remove() {
  this.container && this.container.remove();
  this.input.setAttribute('aria-expanded', 'false');
  this.container = null;
  this.ul = null;
  return this;
};
/**
 * Messaging that is passed to the screen reader
 * @param {string}key     The Key of the message to write
 * @param {string}variableA variable to provide to the string.
 * @return{object}          The Class
 */


Autocomplete.prototype.message = function message(key, variable) {
  var this$1 = this;
  if (key === void 0) key = false;
  if (variable === void 0) variable = '';

  if (!key) {
    return this;
  }

  var messages = {
    'INIT': function INIT() {
      return this$1.STRINGS.DIRECTIONS_TYPE;
    },
    'TYPING': function TYPING() {
      return [this$1.STRINGS.OPTION_AVAILABLE.replace('{{ NUMBER }}', variable), this$1.STRINGS.DIRECTIONS_REVIEW].join('. ');
    },
    'SELECTED': function SELECTED() {
      return [this$1.STRINGS.OPTION_SELECTED.replace('{{ VALUE }}', variable), this$1.STRINGS.DIRECTIONS_TYPE].join('. ');
    }
  };
  document.querySelector("#" + this.input.getAttribute('aria-describedby')).innerHTML = messages[key]();
  return this;
};
/** Selectors for the Autocomplete class. */


Autocomplete.selectors = {
  'HIGHLIGHT': 'input-autocomplete__highlight',
  'OPTIONS': 'input-autocomplete__options',
  'ACTIVE_DESCENDANT': 'input-autocomplete__selected',
  'SCREEN_READER_ONLY': 'sr-only'
};
/**  */

Autocomplete.strings = {
  'DIRECTIONS_TYPE': 'Start typing to generate a list of potential input options',
  'DIRECTIONS_REVIEW': ['Keyboard users can use the up and down arrows to ', 'review options and press enter to select an option'].join(''),
  'OPTION_AVAILABLE': '{{ NUMBER }} options available',
  'OPTION_SELECTED': '{{ VALUE }} selected'
};
/** Maximum amount of results to be returned. */

Autocomplete.maxItems = 5;

/**
 * The InputAutocomplete class.
 */

var InputAutocomplete = function InputAutocomplete(settings) {
  if (settings === void 0) settings = {};
  this.library = new Autocomplete({
    options: settings.hasOwnProperty('options') ? settings.options : InputAutocomplete.options,
    selected: settings.hasOwnProperty('selected') ? settings.selected : false,
    selector: settings.hasOwnProperty('selector') ? settings.selector : InputAutocomplete.selector,
    classname: settings.hasOwnProperty('classname') ? settings.classname : InputAutocomplete.classname
  });
  return this;
};
/**
 * Setter for the Autocomplete options
 * @param{object} reset Set of array options for the Autocomplete class
 * @return {object} InputAutocomplete object with new options.
 */


InputAutocomplete.prototype.options = function options(reset) {
  this.library.settings.options = reset;
  return this;
};
/**
 * Setter for the Autocomplete strings
 * @param{object}localizedStringsObject containing strings.
 * @return {object} Autocomplete strings
 */


InputAutocomplete.prototype.strings = function strings(localizedStrings) {
  Object.assign(this.library.STRINGS, localizedStrings);
  return this;
};
/** @type {array} Default options for the autocomplete class */


InputAutocomplete.options = [];
/** @type {string} The search box dom selector */

InputAutocomplete.selector = '[data-js="input-autocomplete__input"]';
/** @type {string} The classname for the dropdown element */

InputAutocomplete.classname = 'input-autocomplete__dropdown';

/** import modules here as they are written */

/**
 * Methods for the global NycoPatterns instance
 */

var nyco = function nyco() {};

nyco.prototype.icons = function icons(path) {
  return new Icons(path);
};
/**
 * Method for the Feed Object
 * @param {Object}settingsSetting for the feed
 * @return{Object}          Feed instance
 */


nyco.prototype.feed = function feed(settings) {
  return new Feed(settings);
};
/**
 * Method for the Toggle Utility
 * @return{Object} Toggle instance
 */


nyco.prototype.toggle = function toggle(settings) {
  return new Toggle();
};
/**
 * Method for the Track Module
 * @return{Object} Track Module
 */


nyco.prototype.track = function track(settings) {
  return new Track();
};

nyco.prototype.select = function select() {
  return new Select();
};
/**
 * Method for the Chart Objects
 * @return{Object} Chart instance
 */


nyco.prototype.chart = function chart(type) {
  if (type === 'bar') {
    return new ChartBar();
  }

  if (type === 'horizontalBar') {
    return new ChartHorizontalBar();
  }

  if (type === 'line') {
    return new ChartLine();
  }

  if (type === 'pie') {
    return new ChartPie();
  }
};
/**
 * Method for the Map Module
 * @return{Object} Map Module
 */


nyco.prototype.map = function map(type) {
  if (type === 'multi') {
    return new MapMultiLayer();
  }

  if (type === 'single') {
    return new MapSingleLayer();
  }
};
/**
 * Method for the Input Autocomplete Element
 * @return{Object} Input Autocomplete instance
 */


nyco.prototype.inputAutocomplete = function inputAutocomplete(settings) {
  if (settings === void 0) settings = {};
  return new InputAutocomplete(settings);
};

module.exports = nyco;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTnljb1BhdHRlcm5zLmNvbW1vbi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2pzL21vZHVsZXMvdXRpbGl0eS5qcyIsIi4uLy4uL3NyYy9lbGVtZW50cy9pY29ucy9JY29ucy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvU291cmNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXROYXRpdmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19kZWZpbmVQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NpZ25WYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlPYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXBwbHkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyUmVzdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY29uc3RhbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0VG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaG9ydE91dC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvU3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJlc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUFzc2lnbmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5c0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzSW4uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbkluV2l0aC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRXJyb3IuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2F0dGVtcHQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXNjYXBlU3RyaW5nQ2hhci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlSW50ZXJwb2xhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUHJvcGVydHlPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZUh0bWxDaGFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUb1N0cmluZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9TdHJpbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VzY2FwZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlRXNjYXBlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVFdmFsdWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGVTZXR0aW5ncy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUVhY2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRm9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUZvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VGb3JPd24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVCYXNlRWFjaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdEZ1bmN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mb3JFYWNoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlQ2xlYXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NvY0luZGV4T2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVTZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19MaXN0Q2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0NsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RhY2tEZWxldGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja0dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3N0YWNrSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaENsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaERlbGV0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoSGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaFNldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX0hhc2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUNsZWFyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXlhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWFwRGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTWFwQ2FjaGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zdGFja1NldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N0YWNrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzaWduTWVyZ2VWYWx1ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQnVmZmVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fVWludDhBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jbG9uZVR5cGVkQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQ3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faW5pdENsb25lT2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZU9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NhZmVHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvUGxhaW5PYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlTWVyZ2VEZWVwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1lcmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9tZXJnZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0Q2FjaGVBZGQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRDYWNoZUhhcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1NldENhY2hlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTb21lLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FjaGVIYXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lcXVhbEFycmF5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcFRvQXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb0FycmF5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxCeVRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5UHVzaC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlGaWx0ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJBcnJheS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFN5bWJvbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRBbGxLZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXF1YWxPYmplY3RzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fRGF0YVZpZXcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19Qcm9taXNlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fV2Vha01hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFRhZy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0VxdWFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTWF0Y2guanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1N0cmljdENvbXBhcmFibGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRNYXRjaERhdGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VNYXRjaGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNLZXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21lbW9pemUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tZW1vaXplQ2FwcGVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaW5nVG9QYXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY2FzdFBhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b0tleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2dldC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VIYXNJbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc1BhdGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2hhc0luLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3Byb3BlcnR5LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUl0ZXJhdGVlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTb3J0QnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb21wYXJlQXNjZW5kaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29tcGFyZU11bHRpcGxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU9yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL29yZGVyQnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRmluZEluZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmFOLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaWN0SW5kZXhPZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub29wLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlU2V0LmpzIiwiLi4vLi4vc3JjL29iamVjdHMvZmVlZC9GZWVkLmpzIiwiLi4vLi4vc3JjL3V0aWxpdGllcy90b2dnbGUvVG9nZ2xlLmpzIiwiLi4vLi4vc3JjL3V0aWxpdGllcy90cmFjay9UcmFjay5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLmJyb3dzZXIuanMiLCIuLi8uLi9zcmMvZWxlbWVudHMvc2VsZWN0L3NlbGVjdC52dWUiLCIuLi8uLi9zcmMvZWxlbWVudHMvc2VsZWN0L3NlbGVjdC5kYXRhLmpzIiwiLi4vLi4vc3JjL2VsZW1lbnRzL3NlbGVjdC9zZWxlY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWNoYXJ0anMvZXMvbWl4aW5zL2luZGV4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9DaGFydC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy92dWUtY2hhcnRqcy9lcy9CYXNlQ2hhcnRzLmpzIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1iYXIudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LmRhdGEuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWJhci5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0taG9yaXpvbnRhbC1iYXIudnVlIiwiLi4vLi4vc3JjL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1ob3Jpem9udGFsLWJhci5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL2NoYXJ0cy9jaGFydC0tbGluZS52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLWxpbmUuanMiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZS52dWUiLCIuLi8uLi9zcmMvb2JqZWN0cy9jaGFydHMvY2hhcnQtLXBpZS5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL21hcC9tYXAudnVlIiwiLi4vLi4vY29uZmlnL2NvbG9ycy5qcyIsIi4uLy4uL3NyYy9vYmplY3RzL21hcC9tYXAuZGF0YS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9nZW9qc29uL2dlb2pzb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvd2dzODQvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hcGJveC9nZW9qc29uLWFyZWEvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvZ2VvanNvbi1yZXdpbmQvaW5kZXguanMiLCIuLi8uLi9zcmMvanMvTWFwLmpzIiwiLi4vLi4vc3JjL2pzL21vZHVsZXMvamFyb1dpbmtsZXIuanMiLCIuLi8uLi9zcmMvanMvbW9kdWxlcy9tZW1vaXplLmpzIiwiLi4vLi4vc3JjL2pzL21vZHVsZXMvYXV0b2NvbXBsZXRlLmpzIiwiLi4vLi4vc3JjL2VsZW1lbnRzL2lucHV0cy9pbnB1dC1hdXRvY29tcGxldGUuanMiLCIuLi8uLi9zcmMvanMvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIFV0aWxpdHkgY2xhc3NcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBVdGlsaXR5IHtcbiAgLyoqXG4gICAqIFRoZSBVdGlsaXR5IGNvbnN0cnVjdG9yXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIFV0aWxpdHkgY2xhc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxuICogQm9vbGVhbiBmb3IgZGVidWcgbW9kZVxuICogQHJldHVybiB7Ym9vbGVhbn0gd2V0aGVyIG9yIG5vdCB0aGUgZnJvbnQtZW5kIGlzIGluIGRlYnVnIG1vZGUuXG4gKi9cblV0aWxpdHkuZGVidWcgPSAoKSA9PiAoVXRpbGl0eS5nZXRVcmxQYXJhbWV0ZXIoVXRpbGl0eS5QQVJBTVMuREVCVUcpID09PSAnMScpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4ga2V5IGluIGEgVVJMIHF1ZXJ5IHN0cmluZy4gSWYgbm8gVVJMIHF1ZXJ5XG4gKiBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoZSBjdXJyZW50IFVSTCBsb2NhdGlvbiBpcyB1c2VkLlxuICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgICAgICAgLSBLZXkgbmFtZS5cbiAqIEBwYXJhbSAgez9zdHJpbmd9IHF1ZXJ5U3RyaW5nIC0gT3B0aW9uYWwgcXVlcnkgc3RyaW5nIHRvIGNoZWNrLlxuICogQHJldHVybiB7P3N0cmluZ30gUXVlcnkgcGFyYW1ldGVyIHZhbHVlLlxuICovXG5VdGlsaXR5LmdldFVybFBhcmFtZXRlciA9IChuYW1lLCBxdWVyeVN0cmluZykgPT4ge1xuICBjb25zdCBxdWVyeSA9IHF1ZXJ5U3RyaW5nIHx8IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XG4gIGNvbnN0IHBhcmFtID0gbmFtZS5yZXBsYWNlKC9bXFxbXS8sICdcXFxcWycpLnJlcGxhY2UoL1tcXF1dLywgJ1xcXFxdJyk7XG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW1xcXFw/Jl0nICsgcGFyYW0gKyAnPShbXiYjXSopJyk7XG4gIGNvbnN0IHJlc3VsdHMgPSByZWdleC5leGVjKHF1ZXJ5KTtcblxuICByZXR1cm4gcmVzdWx0cyA9PT0gbnVsbCA/ICcnIDpcbiAgICBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG59O1xuXG4vKipcbiAqIEZvciB0cmFuc2xhdGluZyBzdHJpbmdzLCB0aGVyZSBpcyBhIGdsb2JhbCBMT0NBTElaRURfU1RSSU5HUyBhcnJheSB0aGF0XG4gKiBpcyBkZWZpbmVkIG9uIHRoZSBIVE1MIHRlbXBsYXRlIGxldmVsIHNvIHRoYXQgdGhvc2Ugc3RyaW5ncyBhcmUgZXhwb3NlZCB0b1xuICogV1BNTCB0cmFuc2xhdGlvbi4gVGhlIExPQ0FMSVpFRF9TVFJJTkdTIGFycmF5IGlzIGNvbXBvc2VkIG9mIG9iamVjdHMgd2l0aCBhXG4gKiBgc2x1Z2Aga2V5IHdob3NlIHZhbHVlIGlzIHNvbWUgY29uc3RhbnQsIGFuZCBhIGBsYWJlbGAgdmFsdWUgd2hpY2ggaXMgdGhlXG4gKiB0cmFuc2xhdGVkIGVxdWl2YWxlbnQuIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBzbHVnIG5hbWUgYW5kIHJldHVybnMgdGhlXG4gKiBsYWJlbC5cbiAqIEBwYXJhbSAge3N0cmluZ30gc2x1Z1xuICogQHJldHVybiB7c3RyaW5nfSBsb2NhbGl6ZWQgdmFsdWVcbiAqL1xuVXRpbGl0eS5sb2NhbGl6ZSA9IGZ1bmN0aW9uKHNsdWcpIHtcbiAgbGV0IHRleHQgPSBzbHVnIHx8ICcnO1xuICBjb25zdCBzdHJpbmdzID0gd2luZG93LkxPQ0FMSVpFRF9TVFJJTkdTIHx8IFtdO1xuICBjb25zdCBtYXRjaCA9IHN0cmluZ3MuZmlsdGVyKFxuICAgIChzKSA9PiAocy5oYXNPd25Qcm9wZXJ0eSgnc2x1ZycpICYmIHNbJ3NsdWcnXSA9PT0gc2x1ZykgPyBzIDogZmFsc2VcbiAgKTtcbiAgcmV0dXJuIChtYXRjaFswXSAmJiBtYXRjaFswXS5oYXNPd25Qcm9wZXJ0eSgnbGFiZWwnKSkgPyBtYXRjaFswXS5sYWJlbCA6IHRleHQ7XG59O1xuXG4vKipcbiAqIEFwcGxpY2F0aW9uIHBhcmFtZXRlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblV0aWxpdHkuUEFSQU1TID0ge1xuICBERUJVRzogJ2RlYnVnJ1xufTtcblxuLyoqXG4gKiBTZWxlY3RvcnMgZm9yIHRoZSBVdGlsaXR5IG1vZHVsZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuVXRpbGl0eS5TRUxFQ1RPUlMgPSB7XG4gIHBhcnNlTWFya2Rvd246ICdbZGF0YS1qcz1cIm1hcmtkb3duXCJdJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVXRpbGl0eTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFV0aWxpdHkgZnJvbSAnLi4vLi4vanMvbW9kdWxlcy91dGlsaXR5JztcblxuLyoqXG4gKiBUaGUgSWNvbiBtb2R1bGVcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBJY29ucyB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBpY29uIGZpbGVcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgY2xhc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhdGgpIHtcbiAgICBwYXRoID0gKHBhdGgpID8gcGF0aCA6IEljb25zLnBhdGg7XG5cbiAgICBmZXRjaChwYXRoKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaylcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihyZXNwb25zZSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihlcnJvcik7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3Qgc3ByaXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHNwcml0ZS5pbm5lckhUTUwgPSBkYXRhO1xuICAgICAgICBzcHJpdGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgICBzcHJpdGUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNwcml0ZSk7XG4gICAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgcGF0aCBvZiB0aGUgaWNvbiBmaWxlICovXG5JY29ucy5wYXRoID0gJ2ljb25zLnN2Zyc7XG5cbmV4cG9ydCBkZWZhdWx0IEljb25zO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbmV4cG9ydCBkZWZhdWx0IGNvcmVKc0RhdGE7XG4iLCJpbXBvcnQgY29yZUpzRGF0YSBmcm9tICcuL19jb3JlSnNEYXRhLmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU291cmNlO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc01hc2tlZCBmcm9tICcuL19pc01hc2tlZC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYXRpdmU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VmFsdWU7XG4iLCJpbXBvcnQgYmFzZUlzTmF0aXZlIGZyb20gJy4vX2Jhc2VJc05hdGl2ZS5qcyc7XG5pbXBvcnQgZ2V0VmFsdWUgZnJvbSAnLi9fZ2V0VmFsdWUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXROYXRpdmU7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVQcm9wZXJ0eTtcbiIsImltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcTtcbiIsImltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduVmFsdWU7XG4iLCJpbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlkZW50aXR5O1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcHBseTtcbiIsImltcG9ydCBhcHBseSBmcm9tICcuL19hcHBseS5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJSZXN0O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnN0YW50O1xuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gJy4vY29uc3RhbnQuanMnO1xuaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZVByb3BlcnR5LmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hvcnRPdXQ7XG4iLCJpbXBvcnQgYmFzZVNldFRvU3RyaW5nIGZyb20gJy4vX2Jhc2VTZXRUb1N0cmluZy5qcyc7XG5pbXBvcnQgc2hvcnRPdXQgZnJvbSAnLi9fc2hvcnRPdXQuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5leHBvcnQgZGVmYXVsdCBzZXRUb1N0cmluZztcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBvdmVyUmVzdCBmcm9tICcuL19vdmVyUmVzdC5qcyc7XG5pbXBvcnQgc2V0VG9TdHJpbmcgZnJvbSAnLi9fc2V0VG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJlc3Q7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0luZGV4O1xuIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJdGVyYXRlZUNhbGw7XG4iLCJpbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGlzSXRlcmF0ZWVDYWxsIGZyb20gJy4vX2lzSXRlcmF0ZWVDYWxsLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQXNzaWduZXI7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVGltZXM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzQXJndW1lbnRzO1xuIiwiaW1wb3J0IGJhc2VJc0FyZ3VtZW50cyBmcm9tICcuL19iYXNlSXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViRmFsc2U7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzSW47XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXNJbiBmcm9tICcuL19uYXRpdmVLZXlzSW4uanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5c0luO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXNJbiBmcm9tICcuL19iYXNlS2V5c0luLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXNJbjtcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGNyZWF0ZUFzc2lnbmVyIGZyb20gJy4vX2NyZWF0ZUFzc2lnbmVyLmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBhbGlhcyBleHRlbmRXaXRoXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbldpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAqIH1cbiAqXG4gKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gKlxuICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduSW5XaXRoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJBcmc7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFByb3RvdHlwZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZG9tRXhjVGFnID0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFcnJvcihFcnJvcik7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Vycm9yO1xuIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcbmltcG9ydCBiYXNlUmVzdCBmcm9tICcuL19iYXNlUmVzdC5qcyc7XG5pbXBvcnQgaXNFcnJvciBmcm9tICcuL2lzRXJyb3IuanMnO1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICogfSwgJz5fPicpO1xuICpcbiAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gKiAgIGVsZW1lbnRzID0gW107XG4gKiB9XG4gKi9cbnZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXR0ZW1wdDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VWYWx1ZXM7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICByZXR1cm4gc3JjVmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9ialZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluO1xuIiwiLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgJ1xcXFwnOiAnXFxcXCcsXG4gIFwiJ1wiOiBcIidcIixcbiAgJ1xcbic6ICduJyxcbiAgJ1xccic6ICdyJyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGVTdHJpbmdDaGFyO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzIGZyb20gJy4vX2Jhc2VLZXlzLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXM7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVJbnRlcnBvbGF0ZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5T2Y7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5T2YgZnJvbSAnLi9fYmFzZVByb3BlcnR5T2YuanMnO1xuXG4vKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xudmFyIGh0bWxFc2NhcGVzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbnZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlSHRtbENoYXI7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUb1N0cmluZztcbiIsImltcG9ydCBiYXNlVG9TdHJpbmcgZnJvbSAnLi9fYmFzZVRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1N0cmluZztcbiIsImltcG9ydCBlc2NhcGVIdG1sQ2hhciBmcm9tICcuL19lc2NhcGVIdG1sQ2hhci5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbnZhciByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gKlxuICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAqXG4gKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAqIFhTUyB2ZWN0b3JzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVzY2FwZTtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVFc2NhcGU7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXZhbHVhdGUgPSAvPCUoW1xcc1xcU10rPyklPi9nO1xuXG5leHBvcnQgZGVmYXVsdCByZUV2YWx1YXRlO1xuIiwiaW1wb3J0IGVzY2FwZSBmcm9tICcuL2VzY2FwZS5qcyc7XG5pbXBvcnQgcmVFc2NhcGUgZnJvbSAnLi9fcmVFc2NhcGUuanMnO1xuaW1wb3J0IHJlRXZhbHVhdGUgZnJvbSAnLi9fcmVFdmFsdWF0ZS5qcyc7XG5pbXBvcnQgcmVJbnRlcnBvbGF0ZSBmcm9tICcuL19yZUludGVycG9sYXRlLmpzJztcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgJ2ltcG9ydHMnOiB7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgJ18nOiB7ICdlc2NhcGUnOiBlc2NhcGUgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZVNldHRpbmdzO1xuIiwiaW1wb3J0IGFzc2lnbkluV2l0aCBmcm9tICcuL2Fzc2lnbkluV2l0aC5qcyc7XG5pbXBvcnQgYXR0ZW1wdCBmcm9tICcuL2F0dGVtcHQuanMnO1xuaW1wb3J0IGJhc2VWYWx1ZXMgZnJvbSAnLi9fYmFzZVZhbHVlcy5qcyc7XG5pbXBvcnQgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiBmcm9tICcuL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzJztcbmltcG9ydCBlc2NhcGVTdHJpbmdDaGFyIGZyb20gJy4vX2VzY2FwZVN0cmluZ0NoYXIuanMnO1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi9pc0Vycm9yLmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuaW1wb3J0IHJlSW50ZXJwb2xhdGUgZnJvbSAnLi9fcmVJbnRlcnBvbGF0ZS5qcyc7XG5pbXBvcnQgdGVtcGxhdGVTZXR0aW5ncyBmcm9tICcuL3RlbXBsYXRlU2V0dGluZ3MuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xudmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLFxuICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2hcbiAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gKi9cbnZhciByZUVzVGVtcGxhdGUgPSAvXFwkXFx7KFteXFxcXH1dKig/OlxcXFwuW15cXFxcfV0qKSopXFx9L2c7XG5cbi8qKiBVc2VkIHRvIGVuc3VyZSBjYXB0dXJpbmcgb3JkZXIgb2YgdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciByZVVuZXNjYXBlZFN0cmluZyA9IC9bJ1xcblxcclxcdTIwMjhcXHUyMDI5XFxcXF0vZztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICpcbiAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSd0ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAqXG4gKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAqXG4gKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICpcbiAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICpcbiAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gKlxuICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gKiBjb21waWxlZChkYXRhKTtcbiAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gKlxuICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gKiBjb21waWxlZC5zb3VyY2U7XG4gKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gKiAvLyAgIHJldHVybiBfX3A7XG4gKiAvLyB9XG4gKlxuICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gKiAgIHZhciBKU1QgPSB7XFxcbiAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICogICB9O1xcXG4gKiAnKTtcbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gIHZhciBzZXR0aW5ncyA9IHRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0cy5fLnRlbXBsYXRlU2V0dGluZ3MgfHwgdGVtcGxhdGVTZXR0aW5ncztcblxuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICB2YXIgaXNFc2NhcGluZyxcbiAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICwgJ2cnKTtcblxuICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gIC8vIFRoZSBzb3VyY2VVUkwgZ2V0cyBpbmplY3RlZCBpbnRvIHRoZSBzb3VyY2UgdGhhdCdzIGV2YWwtZWQsIHNvIGJlIGNhcmVmdWxcbiAgLy8gd2l0aCBsb29rdXAgKGluIGNhc2Ugb2YgZS5nLiBwcm90b3R5cGUgcG9sbHV0aW9uKSwgYW5kIHN0cmlwIG5ld2xpbmVzIGlmIGFueS5cbiAgLy8gQSBuZXdsaW5lIHdvdWxkbid0IGJlIGEgdmFsaWQgc291cmNlVVJMIGFueXdheSwgYW5kIGl0J2QgZW5hYmxlIGNvZGUgaW5qZWN0aW9uLlxuICB2YXIgc291cmNlVVJMID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnc291cmNlVVJMJylcbiAgICA/ICgnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvW1xcclxcbl0vZywgJyAnKSArXG4gICAgICAgJ1xcbicpXG4gICAgOiAnJztcblxuICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICB9XG4gICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgfVxuICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICB9XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgIHJldHVybiBtYXRjaDtcbiAgfSk7XG5cbiAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgLy8gTGlrZSB3aXRoIHNvdXJjZVVSTCwgd2UgdGFrZSBjYXJlIHRvIG5vdCBjaGVjayB0aGUgb3B0aW9uJ3MgcHJvdG90eXBlLFxuICAvLyBhcyB0aGlzIGNvbmZpZ3VyYXRpb24gaXMgYSBjb2RlIGluamVjdGlvbiB2ZWN0b3IuXG4gIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgaWYgKCF2YXJpYWJsZSkge1xuICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICB9XG4gIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgKHZhcmlhYmxlXG4gICAgICA/ICcnXG4gICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgKSArXG4gICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAoaXNFc2NhcGluZ1xuICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgOiAnJ1xuICAgICkgK1xuICAgIChpc0V2YWx1YXRpbmdcbiAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgIDogJztcXG4nXG4gICAgKSArXG4gICAgc291cmNlICtcbiAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gIH0pO1xuXG4gIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgdGhyb3cgcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRlbXBsYXRlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUVhY2g7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQmFzZUZvcjtcbiIsImltcG9ydCBjcmVhdGVCYXNlRm9yIGZyb20gJy4vX2NyZWF0ZUJhc2VGb3IuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VGb3I7XG4iLCJpbXBvcnQgYmFzZUZvciBmcm9tICcuL19iYXNlRm9yLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUZvck93bjtcbiIsImltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlQmFzZUVhY2g7XG4iLCJpbXBvcnQgYmFzZUZvck93biBmcm9tICcuL19iYXNlRm9yT3duLmpzJztcbmltcG9ydCBjcmVhdGVCYXNlRWFjaCBmcm9tICcuL19jcmVhdGVCYXNlRWFjaC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlRWFjaDtcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FzdEZ1bmN0aW9uO1xuIiwiaW1wb3J0IGFycmF5RWFjaCBmcm9tICcuL19hcnJheUVhY2guanMnO1xuaW1wb3J0IGJhc2VFYWNoIGZyb20gJy4vX2Jhc2VFYWNoLmpzJztcbmltcG9ydCBjYXN0RnVuY3Rpb24gZnJvbSAnLi9fY2FzdEZ1bmN0aW9uLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGFsaWFzIGVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQHNlZSBfLmZvckVhY2hSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICpcbiAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGNhc3RGdW5jdGlvbihpdGVyYXRlZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JFYWNoO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBsaXN0Q2FjaGVDbGVhcjtcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzb2NJbmRleE9mO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZURlbGV0ZTtcbiIsImltcG9ydCBhc3NvY0luZGV4T2YgZnJvbSAnLi9fYXNzb2NJbmRleE9mLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlR2V0O1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbGlzdENhY2hlSGFzO1xuIiwiaW1wb3J0IGFzc29jSW5kZXhPZiBmcm9tICcuL19hc3NvY0luZGV4T2YuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpc3RDYWNoZVNldDtcbiIsImltcG9ydCBsaXN0Q2FjaGVDbGVhciBmcm9tICcuL19saXN0Q2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbGlzdENhY2hlRGVsZXRlIGZyb20gJy4vX2xpc3RDYWNoZURlbGV0ZS5qcyc7XG5pbXBvcnQgbGlzdENhY2hlR2V0IGZyb20gJy4vX2xpc3RDYWNoZUdldC5qcyc7XG5pbXBvcnQgbGlzdENhY2hlSGFzIGZyb20gJy4vX2xpc3RDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbGlzdENhY2hlU2V0IGZyb20gJy4vX2xpc3RDYWNoZVNldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTGlzdENhY2hlO1xuIiwiaW1wb3J0IExpc3RDYWNoZSBmcm9tICcuL19MaXN0Q2FjaGUuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdGFja0hhcztcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVDcmVhdGU7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXNoRGVsZXRlO1xuIiwiaW1wb3J0IG5hdGl2ZUNyZWF0ZSBmcm9tICcuL19uYXRpdmVDcmVhdGUuanMnO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hHZXQ7XG4iLCJpbXBvcnQgbmF0aXZlQ3JlYXRlIGZyb20gJy4vX25hdGl2ZUNyZWF0ZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzaEhhcztcbiIsImltcG9ydCBuYXRpdmVDcmVhdGUgZnJvbSAnLi9fbmF0aXZlQ3JlYXRlLmpzJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc2hTZXQ7XG4iLCJpbXBvcnQgaGFzaENsZWFyIGZyb20gJy4vX2hhc2hDbGVhci5qcyc7XG5pbXBvcnQgaGFzaERlbGV0ZSBmcm9tICcuL19oYXNoRGVsZXRlLmpzJztcbmltcG9ydCBoYXNoR2V0IGZyb20gJy4vX2hhc2hHZXQuanMnO1xuaW1wb3J0IGhhc2hIYXMgZnJvbSAnLi9faGFzaEhhcy5qcyc7XG5pbXBvcnQgaGFzaFNldCBmcm9tICcuL19oYXNoU2V0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbmV4cG9ydCBkZWZhdWx0IEhhc2g7XG4iLCJpbXBvcnQgSGFzaCBmcm9tICcuL19IYXNoLmpzJztcbmltcG9ydCBMaXN0Q2FjaGUgZnJvbSAnLi9fTGlzdENhY2hlLmpzJztcbmltcG9ydCBNYXAgZnJvbSAnLi9fTWFwLmpzJztcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUNsZWFyO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0tleWFibGU7XG4iLCJpbXBvcnQgaXNLZXlhYmxlIGZyb20gJy4vX2lzS2V5YWJsZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TWFwRGF0YTtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwQ2FjaGVEZWxldGU7XG4iLCJpbXBvcnQgZ2V0TWFwRGF0YSBmcm9tICcuL19nZXRNYXBEYXRhLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUdldDtcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXBDYWNoZUhhcztcbiIsImltcG9ydCBnZXRNYXBEYXRhIGZyb20gJy4vX2dldE1hcERhdGEuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcENhY2hlU2V0O1xuIiwiaW1wb3J0IG1hcENhY2hlQ2xlYXIgZnJvbSAnLi9fbWFwQ2FjaGVDbGVhci5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVEZWxldGUgZnJvbSAnLi9fbWFwQ2FjaGVEZWxldGUuanMnO1xuaW1wb3J0IG1hcENhY2hlR2V0IGZyb20gJy4vX21hcENhY2hlR2V0LmpzJztcbmltcG9ydCBtYXBDYWNoZUhhcyBmcm9tICcuL19tYXBDYWNoZUhhcy5qcyc7XG5pbXBvcnQgbWFwQ2FjaGVTZXQgZnJvbSAnLi9fbWFwQ2FjaGVTZXQuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuZXhwb3J0IGRlZmF1bHQgTWFwQ2FjaGU7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgTWFwIGZyb20gJy4vX01hcC5qcyc7XG5pbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RhY2tTZXQ7XG4iLCJpbXBvcnQgTGlzdENhY2hlIGZyb20gJy4vX0xpc3RDYWNoZS5qcyc7XG5pbXBvcnQgc3RhY2tDbGVhciBmcm9tICcuL19zdGFja0NsZWFyLmpzJztcbmltcG9ydCBzdGFja0RlbGV0ZSBmcm9tICcuL19zdGFja0RlbGV0ZS5qcyc7XG5pbXBvcnQgc3RhY2tHZXQgZnJvbSAnLi9fc3RhY2tHZXQuanMnO1xuaW1wb3J0IHN0YWNrSGFzIGZyb20gJy4vX3N0YWNrSGFzLmpzJztcbmltcG9ydCBzdGFja1NldCBmcm9tICcuL19zdGFja1NldC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuZXhwb3J0IGRlZmF1bHQgU3RhY2s7XG4iLCJpbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVCdWZmZXI7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgVWludDhBcnJheTtcbiIsImltcG9ydCBVaW50OEFycmF5IGZyb20gJy4vX1VpbnQ4QXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJpbXBvcnQgY2xvbmVBcnJheUJ1ZmZlciBmcm9tICcuL19jbG9uZUFycmF5QnVmZmVyLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmVUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlBcnJheTtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZUNyZWF0ZTtcbiIsImltcG9ydCBiYXNlQ3JlYXRlIGZyb20gJy4vX2Jhc2VDcmVhdGUuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpbml0Q2xvbmVPYmplY3Q7XG4iLCJpbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZU9iamVjdDtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzYWZlR2V0O1xuIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1BsYWluT2JqZWN0O1xuIiwiaW1wb3J0IGFzc2lnbk1lcmdlVmFsdWUgZnJvbSAnLi9fYXNzaWduTWVyZ2VWYWx1ZS5qcyc7XG5pbXBvcnQgY2xvbmVCdWZmZXIgZnJvbSAnLi9fY2xvbmVCdWZmZXIuanMnO1xuaW1wb3J0IGNsb25lVHlwZWRBcnJheSBmcm9tICcuL19jbG9uZVR5cGVkQXJyYXkuanMnO1xuaW1wb3J0IGNvcHlBcnJheSBmcm9tICcuL19jb3B5QXJyYXkuanMnO1xuaW1wb3J0IGluaXRDbG9uZU9iamVjdCBmcm9tICcuL19pbml0Q2xvbmVPYmplY3QuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0FycmF5TGlrZU9iamVjdCBmcm9tICcuL2lzQXJyYXlMaWtlT2JqZWN0LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QuanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgc2FmZUdldCBmcm9tICcuL19zYWZlR2V0LmpzJztcbmltcG9ydCB0b1BsYWluT2JqZWN0IGZyb20gJy4vdG9QbGFpbk9iamVjdC5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNZXJnZURlZXA7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGFzc2lnbk1lcmdlVmFsdWUgZnJvbSAnLi9fYXNzaWduTWVyZ2VWYWx1ZS5qcyc7XG5pbXBvcnQgYmFzZUZvciBmcm9tICcuL19iYXNlRm9yLmpzJztcbmltcG9ydCBiYXNlTWVyZ2VEZWVwIGZyb20gJy4vX2Jhc2VNZXJnZURlZXAuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5pbXBvcnQgc2FmZUdldCBmcm9tICcuL19zYWZlR2V0LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9LCBrZXlzSW4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWVyZ2U7XG4iLCJpbXBvcnQgYmFzZU1lcmdlIGZyb20gJy4vX2Jhc2VNZXJnZS5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC41LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHtcbiAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAqIH07XG4gKlxuICogdmFyIG90aGVyID0ge1xuICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICogfTtcbiAqXG4gKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICovXG52YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2U7XG4iLCJpbXBvcnQgYmFzZVZhbHVlcyBmcm9tICcuL19iYXNlVmFsdWVzLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZXM7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0Q2FjaGVBZGQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldENhY2hlSGFzO1xuIiwiaW1wb3J0IE1hcENhY2hlIGZyb20gJy4vX01hcENhY2hlLmpzJztcbmltcG9ydCBzZXRDYWNoZUFkZCBmcm9tICcuL19zZXRDYWNoZUFkZC5qcyc7XG5pbXBvcnQgc2V0Q2FjaGVIYXMgZnJvbSAnLi9fc2V0Q2FjaGVIYXMuanMnO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbmV4cG9ydCBkZWZhdWx0IFNldENhY2hlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlTb21lO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNhY2hlSGFzO1xuIiwiaW1wb3J0IFNldENhY2hlIGZyb20gJy4vX1NldENhY2hlLmpzJztcbmltcG9ydCBhcnJheVNvbWUgZnJvbSAnLi9fYXJyYXlTb21lLmpzJztcbmltcG9ydCBjYWNoZUhhcyBmcm9tICcuL19jYWNoZUhhcy5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsQXJyYXlzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNldFRvQXJyYXk7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgVWludDhBcnJheSBmcm9tICcuL19VaW50OEFycmF5LmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgbWFwVG9BcnJheSBmcm9tICcuL19tYXBUb0FycmF5LmpzJztcbmltcG9ydCBzZXRUb0FycmF5IGZyb20gJy4vX3NldFRvQXJyYXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcXVhbEJ5VGFnO1xuIiwiLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVB1c2g7XG4iLCJpbXBvcnQgYXJyYXlQdXNoIGZyb20gJy4vX2FycmF5UHVzaC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRBbGxLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUZpbHRlcjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJBcnJheTtcbiIsImltcG9ydCBhcnJheUZpbHRlciBmcm9tICcuL19hcnJheUZpbHRlci5qcyc7XG5pbXBvcnQgc3R1YkFycmF5IGZyb20gJy4vc3R1YkFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZXRTeW1ib2xzO1xuIiwiaW1wb3J0IGJhc2VHZXRBbGxLZXlzIGZyb20gJy4vX2Jhc2VHZXRBbGxLZXlzLmpzJztcbmltcG9ydCBnZXRTeW1ib2xzIGZyb20gJy4vX2dldFN5bWJvbHMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0QWxsS2V5cztcbiIsImltcG9ydCBnZXRBbGxLZXlzIGZyb20gJy4vX2dldEFsbEtleXMuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxPYmplY3RzO1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxuZXhwb3J0IGRlZmF1bHQgRGF0YVZpZXc7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5pbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvbWlzZTtcbiIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcbmltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxuZXhwb3J0IGRlZmF1bHQgU2V0O1xuIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbmV4cG9ydCBkZWZhdWx0IFdlYWtNYXA7XG4iLCJpbXBvcnQgRGF0YVZpZXcgZnJvbSAnLi9fRGF0YVZpZXcuanMnO1xuaW1wb3J0IE1hcCBmcm9tICcuL19NYXAuanMnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi9fUHJvbWlzZS5qcyc7XG5pbXBvcnQgU2V0IGZyb20gJy4vX1NldC5qcyc7XG5pbXBvcnQgV2Vha01hcCBmcm9tICcuL19XZWFrTWFwLmpzJztcbmltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VGFnO1xuIiwiaW1wb3J0IFN0YWNrIGZyb20gJy4vX1N0YWNrLmpzJztcbmltcG9ydCBlcXVhbEFycmF5cyBmcm9tICcuL19lcXVhbEFycmF5cy5qcyc7XG5pbXBvcnQgZXF1YWxCeVRhZyBmcm9tICcuL19lcXVhbEJ5VGFnLmpzJztcbmltcG9ydCBlcXVhbE9iamVjdHMgZnJvbSAnLi9fZXF1YWxPYmplY3RzLmpzJztcbmltcG9ydCBnZXRUYWcgZnJvbSAnLi9fZ2V0VGFnLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0VxdWFsRGVlcDtcbiIsImltcG9ydCBiYXNlSXNFcXVhbERlZXAgZnJvbSAnLi9fYmFzZUlzRXF1YWxEZWVwLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzRXF1YWw7XG4iLCJpbXBvcnQgU3RhY2sgZnJvbSAnLi9fU3RhY2suanMnO1xuaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc01hdGNoO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsImltcG9ydCBpc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9faXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRNYXRjaERhdGE7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiaW1wb3J0IGJhc2VJc01hdGNoIGZyb20gJy4vX2Jhc2VJc01hdGNoLmpzJztcbmltcG9ydCBnZXRNYXRjaERhdGEgZnJvbSAnLi9fZ2V0TWF0Y2hEYXRhLmpzJztcbmltcG9ydCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlTWF0Y2hlcztcbiIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNLZXk7XG4iLCJpbXBvcnQgTWFwQ2FjaGUgZnJvbSAnLi9fTWFwQ2FjaGUuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemU7XG4iLCJpbXBvcnQgbWVtb2l6ZSBmcm9tICcuL21lbW9pemUuanMnO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemVDYXBwZWQ7XG4iLCJpbXBvcnQgbWVtb2l6ZUNhcHBlZCBmcm9tICcuL19tZW1vaXplQ2FwcGVkLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdUb1BhdGg7XG4iLCJpbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCBzdHJpbmdUb1BhdGggZnJvbSAnLi9fc3RyaW5nVG9QYXRoLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2FzdFBhdGg7XG4iLCJpbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0tleTtcbiIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0O1xuIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VIYXNJbjtcbiIsImltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFzUGF0aDtcbiIsImltcG9ydCBiYXNlSGFzSW4gZnJvbSAnLi9fYmFzZUhhc0luLmpzJztcbmltcG9ydCBoYXNQYXRoIGZyb20gJy4vX2hhc1BhdGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhhc0luO1xuIiwiaW1wb3J0IGJhc2VJc0VxdWFsIGZyb20gJy4vX2Jhc2VJc0VxdWFsLmpzJztcbmltcG9ydCBnZXQgZnJvbSAnLi9nZXQuanMnO1xuaW1wb3J0IGhhc0luIGZyb20gJy4vaGFzSW4uanMnO1xuaW1wb3J0IGlzS2V5IGZyb20gJy4vX2lzS2V5LmpzJztcbmltcG9ydCBpc1N0cmljdENvbXBhcmFibGUgZnJvbSAnLi9faXNTdHJpY3RDb21wYXJhYmxlLmpzJztcbmltcG9ydCBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSBmcm9tICcuL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXRjaGVzUHJvcGVydHk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHk7XG4iLCJpbXBvcnQgYmFzZUdldCBmcm9tICcuL19iYXNlR2V0LmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eURlZXA7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5IGZyb20gJy4vX2Jhc2VQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgYmFzZVByb3BlcnR5RGVlcCBmcm9tICcuL19iYXNlUHJvcGVydHlEZWVwLmpzJztcbmltcG9ydCBpc0tleSBmcm9tICcuL19pc0tleS5qcyc7XG5pbXBvcnQgdG9LZXkgZnJvbSAnLi9fdG9LZXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByb3BlcnR5O1xuIiwiaW1wb3J0IGJhc2VNYXRjaGVzIGZyb20gJy4vX2Jhc2VNYXRjaGVzLmpzJztcbmltcG9ydCBiYXNlTWF0Y2hlc1Byb3BlcnR5IGZyb20gJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBwcm9wZXJ0eSBmcm9tICcuL3Byb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUl0ZXJhdGVlO1xuIiwiaW1wb3J0IGJhc2VFYWNoIGZyb20gJy4vX2Jhc2VFYWNoLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZU1hcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICogdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTb3J0Qnk7XG4iLCJpbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKlxuICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29tcGFyZUFzY2VuZGluZztcbiIsImltcG9ydCBjb21wYXJlQXNjZW5kaW5nIGZyb20gJy4vX2NvbXBhcmVBc2NlbmRpbmcuanMnO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gKlxuICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxuICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAvL1xuICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wYXJlTXVsdGlwbGU7XG4iLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGJhc2VNYXAgZnJvbSAnLi9fYmFzZU1hcC5qcyc7XG5pbXBvcnQgYmFzZVNvcnRCeSBmcm9tICcuL19iYXNlU29ydEJ5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBjb21wYXJlTXVsdGlwbGUgZnJvbSAnLi9fY29tcGFyZU11bHRpcGxlLmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcy5sZW5ndGggPyBpdGVyYXRlZXMgOiBbaWRlbnRpdHldLCBiYXNlVW5hcnkoYmFzZUl0ZXJhdGVlKSk7XG5cbiAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gIH0pO1xuXG4gIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VPcmRlckJ5O1xuIiwiaW1wb3J0IGJhc2VPcmRlckJ5IGZyb20gJy4vX2Jhc2VPcmRlckJ5LmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XG4gKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAqIF07XG4gKlxuICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAqL1xuZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgfVxuICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcbiAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gIH1cbiAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3JkZXJCeTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRmluZEluZGV4O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTmFOO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpY3RJbmRleE9mO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlJbmNsdWRlc1dpdGg7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5leHBvcnQgZGVmYXVsdCBub29wO1xuIiwiaW1wb3J0IFNldCBmcm9tICcuL19TZXQuanMnO1xuaW1wb3J0IG5vb3AgZnJvbSAnLi9ub29wLmpzJztcbmltcG9ydCBzZXRUb0FycmF5IGZyb20gJy4vX3NldFRvQXJyYXkuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVTZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbmltcG9ydCBfdGVtcGxhdGUgZnJvbSAnbG9kYXNoLWVzL3RlbXBsYXRlJztcbmltcG9ydCBfZm9yRWFjaCBmcm9tICdsb2Rhc2gtZXMvZm9yRWFjaCc7XG5pbXBvcnQgX21lcmdlIGZyb20gJ2xvZGFzaC1lcy9tZXJnZSc7XG5pbXBvcnQgX3ZhbHVlcyBmcm9tICdsb2Rhc2gtZXMvdmFsdWVzJztcbmltcG9ydCBfb3JkZXJCeSBmcm9tICdsb2Rhc2gtZXMvb3JkZXJCeSc7XG5pbXBvcnQgX3VuaXFCeSBmcm9tICdsb2Rhc2gtZXMvdW5pcUJ5JztcblxuLyoqXG4gKlxuICovXG5jbGFzcyBGZWVkIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5kZWZhdWx0ID0gRmVlZC5kZWZhdWx0O1xuXG4gICAgdGhpcy5fc2V0dGluZ3MgPSBfbWVyZ2Uoe30sIEZlZWQuZGVmYXVsdCwgY29uZmlnKTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgbGV0IGRhdGEgPSBbXTtcbiAgICBsZXQgZmVlZCA9IHRoaXMuX3NldHRpbmdzLmZlZWQ7XG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgIHJzc1RvSnNvbjogRmVlZC5yc3NUb0pzb24sXG4gICAgICByc3NVcmw6IChBcnJheS5pc0FycmF5KGZlZWQpKSA/IGZlZWQgOiBbZmVlZF1cbiAgICB9O1xuXG4gICAgLy8gR28gdGhyb3VnaCBlYWNoIGZlZWRcbiAgICBfZm9yRWFjaChjb25maWcucnNzVXJsLCAodXJsLCBpbmRleCkgPT4ge1xuICAgICAgLy8gTWFrZSB0aGUgcmVxdWVzdFxuICAgICAgdGhpcy5fcmVxdWVzdChjb25maWcsIHVybCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBkYXRhXG4gICAgICAgICAgZGF0YS5wdXNoKHRoaXMuX3Byb2Nlc3MoSlNPTi5wYXJzZShyZXNwb25zZSksIHRoaXMuX3NldHRpbmdzKSk7XG4gICAgICAgICAgLy8gV2hlbiBhbGwgZmVlZHMgaGF2ZSBiZWVuIHJlcXVlc3RlZCwgbWVyZ2UgdGhlIGRhdGEgYW5kIGNvbXBpbGVcbiAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IGNvbmZpZy5yc3NVcmwubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXJnZShkYXRhLCB0aGlzLl9zZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIGxldCBjb21waWxlZCA9IHRoaXMuX3JlbmRlcihcbiAgICAgICAgICAgICAgdGhpcy5fbWVyZ2UoZGF0YSwgdGhpcy5fc2V0dGluZ3MpLFxuICAgICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9zZXR0aW5ncy5zZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoZWwpIGVsLmlubmVySFRNTCA9IGNvbXBpbGVkO1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIFhIUiByZXF1ZXN0IGZvciB0aGUgZmVlZCBkYXRhXG4gICAqIEBwYXJhbSAge29iamVjdH0gY29uZmlnIFRoZSByZXF1ZXN0IGRhdGFcbiAgICogQHBhcmFtICB7c3RyaW5nfSB1cmwgICAgVGhlIHJlcXVlc3QgdXJsXG4gICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgIFJlc29sdmVzIHdoZW4gdGhlIHJlc3BvbnNlIGlzIHJlYWR5LCByZWplY3RzIHdoZW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9wZXJhdGlvbiB0aW1lcyBvdXQgb3IgdGhlcmUgaXMgYW4gZXJyb3IuXG4gICAqL1xuICBfcmVxdWVzdChjb25maWcsIHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgbGV0IF94aHIgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmIChfeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICBpZiAoX3hoci5zdGF0dXMgPj0gMjAwICYmIF94aHIuc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgICAgICByZXNvbHZlKF94aHIucmVzcG9uc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKF94aHIuc3RhdHVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgRmVlZCByZXF1ZXN0IHRpbWVkIG91dCcpKTtcbiAgICAgIH07XG4gICAgICB4aHIub3BlbignR0VUJywgYCR7Y29uZmlnLnJzc1RvSnNvbn0/cnNzX3VybD0ke3VybH1gLCB0cnVlKTtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgICB4aHIgPSBudWxsO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhc3MgZGF0YSB0byB0aGUgYXBwcm9wcmlhdGUgcHJvY2Vzc2luZyBmdW5jdGlvbiBiYXNlZCBvbiB0eXBlXG4gICAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAgICAgVGhlIHJlcXVlc3RlZCBmZWVkIGRhdGEgdG8gcGFzc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9IHNldHRpbmdzIFRoZSBhcHBsaWNhdGlvbiBzZXR0aW5nc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIFRoZSBwcm9jZXNzZWQgZGF0YVxuICAgKi9cbiAgX3Byb2Nlc3MoZGF0YSwgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gRmVlZC5wcm9jZXNzW3NldHRpbmdzLnR5cGVdKGRhdGEsIHNldHRpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXNzIGRhdGEgdG8gdGhlIGFwcHJvcHJpYXRlIG1lcmdlIGZ1bmN0aW9uIGJhc2VkIG9uIHR5cGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBkYXRhICAgICBUaGUgcmVxdWVzdGVkIGZlZWQgZGF0YSB0byBwYXNzXG4gICAqIEBwYXJhbSAge29iamVjdH0gc2V0dGluZ3MgVGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIG1lcmdlZCBmZWVkIGRhdGFcbiAgICovXG4gIF9tZXJnZShkYXRhLCBzZXR0aW5ncykge1xuICAgIHJldHVybiBGZWVkLm1lcmdlW3NldHRpbmdzLnR5cGVdKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgdGVtcGxhdGUgY29tcG9uZW50cywgcGFzcyBkYXRhLCBhbmQgcmV0dXJuIGNvbXBpbGVkIHRlbWxhdGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBkYXRhICAgICBUaGUgcmVxdWVzdGVkIGZlZWQgZGF0YSB0byBwYXNzXG4gICAqIEBwYXJhbSAge29iamVjdH0gc2V0dGluZ3MgVGhlIGFwcGxpY2F0aW9uIHNldHRpbmdzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgVGhlIGNvbXBsaWVkIGh0bWwgc3RyaW5nXG4gICAqL1xuICBfcmVuZGVyKGRhdGEsIHNldHRpbmdzKSB7XG4gICAgZGF0YS5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gICAgaWYgKHNldHRpbmdzLmxvZylcbiAgICAgIGNvbnNvbGUuZGlyKGRhdGEpO1xuXG4gICAgbGV0IHRlbXBsYXRlID0gX3ZhbHVlcyhzZXR0aW5ncy50ZW1wbGF0ZXMpLmpvaW4oJycpO1xuICAgIGxldCBjb21waWxlZCA9IF90ZW1wbGF0ZShcbiAgICAgIHRlbXBsYXRlLFxuICAgICAge1xuICAgICAgICAnaW1wb3J0cyc6IHtcbiAgICAgICAgICAnX2VhY2gnOiBfZm9yRWFjaFxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gY29tcGlsZWQoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBvcGVuIFJTUyB0byBKU09OIGFwaSwgc2VlIGh0dHBzOi8vcnNzMmpzb24uY29tXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5GZWVkLnJzc1RvSnNvbiA9ICdodHRwczovL2FwaS5yc3MyanNvbi5jb20vdjEvYXBpLmpzb24nO1xuXG4vKipcbiAqIFRoZSB0ZW1wbGF0ZSBmb3IgdGhlIHdpZGdldC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkZlZWQudGVtcGxhdGVzID0ge1xuICBtZWRpdW06IHtcbiAgICBvcGVuZXI6IFtcbiAgICAgICc8c2VjdGlvbiBjbGFzcz1cIm8tZmVlZCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy53cmFwcGVyICU+XCIgc3R5bGU9XCInLFxuICAgICAgICAnPCUgaWYgKHNldHRpbmdzLmZvbnRTaXplKSB7ICU+Zm9udC1zaXplOiA8JS0gc2V0dGluZ3MuZm9udFNpemUgJT47PCUgfSAlPicsXG4gICAgICAgICc8JSBpZiAoc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yKSB7ICU+Ym9yZGVyLWNvbG9yOiA8JS0gc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yICU+OzwlIH0gJT4nLFxuICAgICAgJ1wiPidcbiAgICBdLFxuICAgIGhlYWRlcjogW1xuICAgICAgJzxoZWFkZXIgY2xhc3M9XCJvLWZlZWRfX2hlYWRlciA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5oZWFkZXIgJT5cIj4nLFxuICAgICAgICAnPGRpdiBjbGFzcz1cIm8tZmVlZF9fYXZhdGFyIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmF2YXRhciAlPlwiPicsXG4gICAgICAgICAgJzxpbWcgc3JjPVwiJyxcbiAgICAgICAgICAgICAgICAnPCUgaWYgKHNldHRpbmdzLnByb2ZpbGVJbWcgIT09IFwiXCIpIHsgJT4nLFxuICAgICAgICAgICAgICAgICAgJzwlLSBzZXR0aW5ncy5wcm9maWxlSW1nICU+JyxcbiAgICAgICAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgICAgICAgJzwlLSBmZWVkLnByb2ZpbGVJbWcgJT4nLFxuICAgICAgICAgICAgICAgICc8JSB9ICU+XCIgJyxcbiAgICAgICAgICAgICAgICd3aWR0aD1cIjwlLSBzZXR0aW5ncy5yYXRpb1Byb2ZpbGVbMF0gJT5cIiAnLFxuICAgICAgICAgICAgICAgJ2hlaWdodD1cIjwlLSBzZXR0aW5ncy5yYXRpb1Byb2ZpbGVbMV0gJT5cIj4nLFxuICAgICAgICAnPC9kaXY+JyxcbiAgICAgICAgJzxhIGNsYXNzPVwiby1mZWVkX191cmwgPCUtIHNldHRpbmdzLmNsYXNzZXMuYXZhdGFyICU+XCIgJyxcbiAgICAgICAgICAnaHJlZj1cIjwlIGlmIChzZXR0aW5ncy50aXRsZVVybCAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAnPCUtIHNldHRpbmdzLnRpdGxlVXJsICU+JyxcbiAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgJzwlLSBmZWVkLnVybCAlPicsXG4gICAgICAgICAgJzwlIH0gJT5cIiAnLFxuICAgICAgICAgICAndGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvd1wiPicsXG4gICAgICAgICAgJzwlIGlmIChzZXR0aW5ncy50aXRsZSAhPT0gXCJcIikgeyAlPicsXG4gICAgICAgICAgICAnPCUtIHNldHRpbmdzLnRpdGxlICU+JyxcbiAgICAgICAgICAnPCUgfSBlbHNlIHsgJT4nLFxuICAgICAgICAgICAgJzwlLSBmZWVkLnRpdGxlICU+JyxcbiAgICAgICAgICAnPCUgfSAlPicsXG4gICAgICAgICc8L2E+JyxcbiAgICAgICc8L2hlYWRlcj4nXG4gICAgXSxcbiAgICBwb3N0czogW1xuICAgICAgJzxkaXYgY2xhc3M9XCJvLWZlZWRfX2l0ZW1zXCIgc3R5bGU9XCInLFxuICAgICAgICAnYm9yZGVyLWNvbG9yOiA8JS0gc2V0dGluZ3MucG9zdEJvcmRlckNvbG9yICU+OycsXG4gICAgICAnXCI+JyxcbiAgICAgICAgJzwlIF9lYWNoKGl0ZW1zLCBmdW5jdGlvbihwb3N0KSB7ICU+JyxcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImMtZmVlZC1pdGVtIDwlLSBzZXR0aW5ncy5jbGFzc2VzLmZlZWRJdGVtICU+XCI+JyxcbiAgICAgICAgICAgICc8aDQgY2xhc3M9XCJjLWZlZWQtaXRlbV9fdGl0bGUgPCUtIHNldHRpbmdzLmNsYXNzZXMudGl0bGUgJT5cIj4nLFxuICAgICAgICAgICAgICAnPGEgY2xhc3M9XCJjLWZlZWQtaXRlbV9fbGluayA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5saW5rICU+XCInLFxuICAgICAgICAgICAgICAgICAnaHJlZj1cIjwlLSBwb3N0Lmd1aWQgJT5cIicsXG4gICAgICAgICAgICAgICAgICd0YXJnZXQ9XCJfYmxhbmtcIicsXG4gICAgICAgICAgICAgICAgICdyZWw9XCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI+JyxcbiAgICAgICAgICAgICAgICAnPCUtIHBvc3QudGl0bGUgJT4nLFxuICAgICAgICAgICAgICAnPC9hPicsXG4gICAgICAgICAgICAnPC9oND4nLFxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiYy1mZWVkLWl0ZW1fX2RhdGUgPCUtIHNldHRpbmdzLmNsYXNzZXMuZGF0ZSAlPlwiICcsXG4gICAgICAgICAgICAgICAgICAndGl0bGU9XCI8JS0gc2V0dGluZ3MucG9zdERhdGVUaXRsZSAlPlwiPicsXG4gICAgICAgICAgICAgICc8JS0gcG9zdC5kYXRlICU+JyxcbiAgICAgICAgICAgICc8L3NwYW4+JyxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiYy1mZWVkLWl0ZW1fX3RodW1ibmFpbCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy50aHVtYm5haWwgJT5cIicsXG4gICAgICAgICAgICAgICAgICdzdHlsZT1cIicsXG4gICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlOiB1cmwoPCUtIHBvc3QudGh1bWJuYWlsICU+KTsnLFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0OiA8JS0gc2V0dGluZ3MucG9zdEltZ0hlaWdodCAlPjtcIicsXG4gICAgICAgICAgICAgICAgICdhcmlhLWhpZGRlbj1cInRydWVcIj4nLFxuICAgICAgICAgICAgICAnPGltZyBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCIgc3JjPVwiPCUtIHBvc3QudGh1bWJuYWlsICU+XCIgYWx0PVwiPCUtIHBvc3QudGl0bGUgJT5cIj4nLFxuICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgICAnPHAgY2xhc3M9XCJjLWZlZWQtaXRlbV9fZXhjZXJwdCA8JS0gc2V0dGluZ3MuY2xhc3Nlcy5leGNlcnB0ICU+XCI+JyxcbiAgICAgICAgICAgICAgJzwlLSBwb3N0LmV4Y2VycHQgJT48JS0gc2V0dGluZ3MucG9zdEV4Y2VycHRUcmFpbCAlPicsXG4gICAgICAgICAgICAnPC9wPicsXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImMtZmVlZC1pdGVtX19mb290ZXIgPCUtIHNldHRpbmdzLmNsYXNzZXMuaXRlbUZvb3RlciAlPlwiPicsXG4gICAgICAgICAgICAgICc8YSBjbGFzcz1cImMtZmVlZC1pdGVtX19jdGEgPCUtIHNldHRpbmdzLmNsYXNzZXMuY3RhICU+XCIgJyxcbiAgICAgICAgICAgICAgICAgJ2hyZWY9XCI8JS0gcG9zdC5ndWlkICU+XCIgJyxcbiAgICAgICAgICAgICAgICAgJ3RhcmdldD1cIl9ibGFua1wiICcsXG4gICAgICAgICAgICAgICAgICdyZWw9XCJub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93XCI+JyxcbiAgICAgICAgICAgICAgICAnPCUtIHNldHRpbmdzLnBvc3RDdGFUZXh0ICU+JyxcbiAgICAgICAgICAgICAgJzwvYT4nLFxuICAgICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICAgJzwvZGl2PicsXG4gICAgICAgICc8JSB9KTsgJT4nLFxuICAgICAgJzwvZGl2PidcbiAgICBdLFxuICAgIGNsb3NlcjogW1xuICAgICAgJzwvc2VjdGlvbj4nXG4gICAgXVxuICB9XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9ucyBmb3IgcHJvY2Vzc2luZyB0aGUgZGF0YSBiYXNlZCBvbiB0aGUgZmVlZCB0eXBlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuRmVlZC5wcm9jZXNzID0ge1xuICBtZWRpdW06IGZ1bmN0aW9uKGRhdGEsIHNldHRpbmdzKSB7XG4gICAgbGV0IGxlbmd0aCA9IHNldHRpbmdzLnBvc3RFeGNlcnB0TGVuZ3RoO1xuXG4gICAgX2ZvckVhY2goZGF0YS5pdGVtcywgZnVuY3Rpb24ocG9zdCwgaW5kZXgpIHtcbiAgICAgIGxldCBleGNlcnB0ID0gJyc7XG4gICAgICBsZXQgZGF0ZSA9ICcnO1xuXG4gICAgICAvLyBSZW1vdmUgZmlndXJlcyBmaXJzdFxuICAgICAgZXhjZXJwdCA9IHBvc3QuZGVzY3JpcHRpb25cbiAgICAgICAgLnJlcGxhY2UoLzxmaWd1cmUuKj4uKj88XFwvZmlndXJlPi9nLCAnJyk7XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgdGFnc1xuICAgICAgZXhjZXJwdCA9IGV4Y2VycHQucmVwbGFjZSgvPCgufFxcbikqPz4vZywgJycpO1xuXG4gICAgICAvLyBUcmltIHRoZSBleGNlcnB0XG4gICAgICBleGNlcnB0ID0gZXhjZXJwdC5zdWJzdHIoMCwgbGVuZ3RoKTtcbiAgICAgIGV4Y2VycHQgPSBleGNlcnB0LnN1YnN0cigwLFxuICAgICAgICBNYXRoLm1pbihleGNlcnB0Lmxlbmd0aCwgZXhjZXJwdC5sYXN0SW5kZXhPZignICcpKVxuICAgICAgKTtcblxuICAgICAgcG9zdC5leGNlcnB0ID0gZXhjZXJwdDtcblxuICAgICAgLy8gRm9ybWF0IHRoZSBkYXRlXG4gICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5wYXJzZShwb3N0LnB1YkRhdGUucmVwbGFjZSgnICcsICdUJykpKVxuICAgICAgICAudG9Mb2NhbGVEYXRlU3RyaW5nKHNldHRpbmdzLnBvc3REYXRlTG9jYWwsIHNldHRpbmdzLnBvc3REYXRlRm9ybWF0KTtcblxuICAgICAgcG9zdC5kYXRlID0gZGF0ZTtcblxuICAgICAgcmV0dXJuIHBvc3Q7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuXG4vKipcbiAqIEZ1bmN0aW9ucyBmb3IgbWVyZ2luZyB0aGUgZGF0YSBmZWVkcyB0b2dldGhlciwgYmFzZWQgb24gdGhlIGZlZWQgdHlwZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZlZWQubWVyZ2UgPSB7XG4gIG1lZGl1bTogZnVuY3Rpb24oZGF0YSkge1xuICAgIGxldCBtZXJnZWQgPSB7fTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcblxuICAgIC8vIENvbWJpbmUgdGhlIHBvc3QgaXRlbXNcbiAgICBkYXRhLmZvckVhY2goKGZlZWQpID0+IHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KGZlZWQuaXRlbXMpO1xuICAgIH0pO1xuXG4gICAgLy8gTWVyZ2UgdGhlIGRhdGEsIHRoaXMgd2lsbCBvdmVycmlkZSB2YWx1ZXMsIGl0IHByb2JhYmx5IHdvbid0IGJlXG4gICAgLy8gcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgZmVlZHMgdGhhdCBhcmUgdGhlIHNhbWUsIGJ1dCBwb3RlbnRpYWxseVxuICAgIC8vIGRpZmZlcmVudCBmZWVkIHR5cGVzIGNvdWxkIHVzZSB0aGlzIGFuZCBjb21iaW5lIHVuaXF1ZSBkYXRhXG4gICAgZGF0YS5mb3JFYWNoKChmZWVkKSA9PiB7XG4gICAgICBtZXJnZWQgPSBfbWVyZ2UobWVyZ2VkLCBmZWVkKTtcbiAgICB9KTtcblxuICAgIC8vIEdldCB1bmlxdWUgcG9zdHNcbiAgICAvLyBpdGVtcyA9IF91bmlxQnkoaXRlbXMsIChpdGVtKSA9PiBpdGVtLmd1aWQpO1xuXG4gICAgbWVyZ2VkLml0ZW1zID0gX29yZGVyQnkoaXRlbXMsICdwdWJEYXRlJywgJ2Rlc2MnKTtcblxuICAgIHJldHVybiBtZXJnZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9yc3MyanNvbi5jb20vZG9jcyBmb3IgZGV0YWlscyBvbiBkZWZhdWx0IHBhcmFtZXRlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZlZWQuZGVmYXVsdCA9IHtcbiAgZmVlZDogJycsXG4gIHNlbGVjdG9yOiAnI2pzLWZlZWQnLFxuICB0eXBlOiAnbWVkaXVtJyxcbiAgdGl0bGU6ICcnLFxuICB0aXRsZVVybDogJycsXG4gIHByb2ZpbGVJbWc6ICcnLFxuICBmb250U2l6ZTogJycsXG4gIHJhdGlvUHJvZmlsZTogWyc1MCcsICc1MCddLFxuICBwb3N0Qm9yZGVyQ29sb3I6ICdsaWdodHN0ZWVsYmx1ZScsXG4gIHBvc3RJbWdIZWlnaHQ6ICcyMDBweCcsXG4gIHBvc3RFeGNlcnB0TGVuZ3RoOiAxMjAsXG4gIHBvc3RFeGNlcnB0VHJhaWw6ICfigKYnLFxuICBwb3N0Q3RhVGV4dDogJ1JlYWQgdGhlIGZ1bGwgcG9zdCcsXG4gIHBvc3REYXRlTG9jYWw6ICdlbi1VUycsXG4gIHBvc3REYXRlRm9ybWF0OiB7XG4gICAgeWVhcjogJ251bWVyaWMnLFxuICAgIG1vbnRoOiAnbG9uZycsXG4gICAgZGF5OiAnbnVtZXJpYydcbiAgfSxcbiAgcG9zdERhdGVUaXRsZTogJ1B1Ymxpc2hlZCBEYXRlJyxcbiAgY2xhc3Nlczoge1xuICAgIHdyYXBwZXI6ICcnLFxuICAgIGhlYWRlcjogJycsXG4gICAgdXJsOiAnJyxcbiAgICBmZWVkSXRlbTogJycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGxpbms6ICcnLFxuICAgIHRodW1ibmFpbDogJycsXG4gICAgZXhjZXJwdDogJycsXG4gICAgaXRlbUZvb3RlcjogJycsXG4gICAgY3RhOiAnJyxcbiAgICBkYXRlOiAnJ1xuICB9LFxuICB0ZW1wbGF0ZXM6IHtcbiAgICBvcGVuZXI6IEZlZWQudGVtcGxhdGVzLm1lZGl1bS5vcGVuZXIuam9pbignJyksXG4gICAgaGVhZGVyOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0uaGVhZGVyLmpvaW4oJycpLFxuICAgIHBvc3RzOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0ucG9zdHMuam9pbignJyksXG4gICAgY2xvc2VyOiBGZWVkLnRlbXBsYXRlcy5tZWRpdW0uY2xvc2VyLmpvaW4oJycpXG4gIH0sXG4gIGxvZzogZmFsc2UsXG4gIHVuaXF1ZTogZmFsc2Vcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZlZWQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIFNpbXBsZSBUb2dnbGUgY2xhc3MuIFRoaXMgd2lsbCB0b2dnbGUgdGhlIGNsYXNzICdhY3RpdmUnIGFuZCAnaGlkZGVuJ1xuICogb24gdGFyZ2V0IGVsZW1lbnRzLCBkZXRlcm1pbmVkIGJ5IGEgY2xpY2sgZXZlbnQgb24gYSBzZWxlY3RlZCBsaW5rIG9yXG4gKiBlbGVtZW50LiBUaGlzIHdpbGwgYWxzbyB0b2dnbGUgdGhlIGFyaWEtaGlkZGVuIGF0dHJpYnV0ZSBmb3IgdGFyZ2V0ZWRcbiAqIGVsZW1lbnRzIHRvIHN1cHBvcnQgc2NyZWVuIHJlYWRlcnMuIFRhcmdldCBzZXR0aW5ncyBhbmQgb3RoZXIgZnVuY3Rpb25hbGl0eVxuICogY2FuIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBkYXRhIGF0dHJpYnV0ZXMuXG4gKlxuICogVGhpcyB1c2VzIHRoZSAubWF0Y2hlcygpIG1ldGhvZCB3aGljaCB3aWxsIHJlcXVpcmUgYSBwb2x5ZmlsbCBmb3IgSUVcbiAqIGh0dHBzOi8vcG9seWZpbGwuaW8vdjIvZG9jcy9mZWF0dXJlcy8jRWxlbWVudF9wcm90b3R5cGVfbWF0Y2hlc1xuICpcbiAqIEJhc2ljIFVzYWdlO1xuICpcbiAqIGphdmFzY3JpcHQ6XG4gKiAgIG5ldyBUb2dnbGUoKS5pbml0KCk7XG4gKlxuICogVG9nZ2xpbmcgQW5jaG9yIGxpbmtzOlxuICogICA8YSBkYXRhLWpzPSd0b2dnbGUnIGhyZWY9JyNtYWluLW1lbnUnPk1lbnU8L2E+XG4gKiAgIDxkaXYgaWQ9J21haW4tbWVudScgYXJpYS1oaWRkZW49J3RydWUnPiAuLi4gPC9kaXY+XG4gKlxuICogVG9nZ2xpbmcgYXJpYS1jb250cm9sIGVsZW1lbnRzOlxuICpcbiAqICAgPGJ1dHRvbiBkYXRhLWpzPSd0b2dnbGUnIGFyaWEtY29udHJvbHM9JyNtYWluLW1lbnUnIGFyaWEtcHJlc3NlZD0nZmFsc2UnPlxuICogICAgICBNZW51XG4gKiAgIDwvYnV0dG9uPlxuICogICA8ZGl2IGlkPSdtYWluLW1lbnUnIGFyaWEtaGlkZGVuPSd0cnVlJz4gLi4uIDwvZGl2PlxuICpcbiAqIENyZWF0ZSBcIlVuZG9cIiBFdmVudCAodG8gY2xvc2UgYSBkaWFsb2d1ZSk7XG4gKiAgIDxhIGhyZWY9JyNtYWluLW1lbnUnIGRhdGEtanM9J3RvZ2dsZScgZGF0YS10b2dnbGUtdW5kbz0nI2Nsb3NlJz5NZW51PC9hPlxuICogICA8ZGl2IGlkPSdtYWluLW1lbnUnIGFyaWEtaGlkZGVuPSd0cnVlJz5cbiAqICAgICA8YSBpZD1cImNsb3NlXCI+Q2xvc2U8L2E+XG4gKiAgIDwvZGl2PlxuICogQGNsYXNzXG4gKi9cbmNsYXNzIFRvZ2dsZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzIFNldHRpbmdzIGZvciB0aGlzIFRvZ2dsZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgVGhlIGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcblxuICAgIHMgPSAoIXMpID8ge30gOiBzO1xuXG4gICAgdGhpcy5fc2V0dGluZ3MgPSB7XG4gICAgICBzZWxlY3RvcjogKHMuc2VsZWN0b3IpID8gcy5zZWxlY3RvciA6IFRvZ2dsZS5zZWxlY3RvcixcbiAgICAgIG5hbWVzcGFjZTogKHMubmFtZXNwYWNlKSA/IHMubmFtZXNwYWNlIDogVG9nZ2xlLm5hbWVzcGFjZSxcbiAgICAgIGluYWN0aXZlQ2xhc3M6IChzLmluYWN0aXZlQ2xhc3MpID8gcy5pbmFjdGl2ZUNsYXNzIDogVG9nZ2xlLmluYWN0aXZlQ2xhc3MsXG4gICAgICBhY3RpdmVDbGFzczogKHMuYWN0aXZlQ2xhc3MpID8gcy5hY3RpdmVDbGFzcyA6IFRvZ2dsZS5hY3RpdmVDbGFzcyxcbiAgICB9O1xuXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLl9zZXR0aW5ncy5zZWxlY3RvcikpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5fdG9nZ2xlKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGV2ZW50ICBUaGUgbWFpbiBjbGljayBldmVudFxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICBUaGUgY2xhc3NcbiAgICovXG4gIF90b2dnbGUoZXZlbnQpIHtcbiAgICBsZXQgZWwgPSBldmVudC50YXJnZXQ7XG4gICAgbGV0IHRhcmdldCA9IGZhbHNlO1xuXG4gICAgLyoqIEFuY2hvciBMaW5rcyAqL1xuICAgIHRhcmdldCA9IChlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgP1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgOiB0YXJnZXQ7XG5cbiAgICAvKiogVG9nZ2xlIENvbnRyb2xzICovXG4gICAgLy8gY29uc29sZS5kaXIoZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJykpO1xuICAgIHRhcmdldCA9IChlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSkgP1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7ZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJyl9YCkgOiB0YXJnZXQ7XG5cbiAgICAvKiogTWFpbiBGdW5jdGlvbmFsaXR5ICovXG4gICAgaWYgKCF0YXJnZXQpIHJldHVybiB0aGlzO1xuICAgIHRoaXMuZWxlbWVudFRvZ2dsZShlbCwgdGFyZ2V0KTtcblxuICAgIC8qKiBVbmRvICovXG4gICAgaWYgKGVsLmRhdGFzZXRbYCR7dGhpcy5fc2V0dGluZ3MubmFtZXNwYWNlfVVuZG9gXSkge1xuICAgICAgY29uc3QgdW5kbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIGVsLmRhdGFzZXRbYCR7dGhpcy5fc2V0dGluZ3MubmFtZXNwYWNlfVVuZG9gXVxuICAgICAgKTtcblxuICAgICAgdW5kby5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnRUb2dnbGUoZWwsIHRhcmdldCk7XG4gICAgICAgIHVuZG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIHRvZ2dsaW5nIG1ldGhvZFxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGVsICAgICBUaGUgY3VycmVudCBlbGVtZW50IHRvIHRvZ2dsZSBhY3RpdmVcbiAgICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50IHRvIHRvZ2dsZSBhY3RpdmUvaGlkZGVuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgIFRoZSBjbGFzc1xuICAgKi9cbiAgZWxlbWVudFRvZ2dsZShlbCwgdGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUNsYXNzICE9PSAnJykge1xuICAgICAgZWwuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcyk7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NldHRpbmdzLmluYWN0aXZlQ2xhc3MgIT09ICcnKSB7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5pbmFjdGl2ZUNsYXNzKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgZWxlbWVudCBmb3IgZGVmaW5lZCBhcmlhIHJvbGVzIGFuZCB0b2dnbGUgdGhlbSBpZiB0aGV5IGV4aXN0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUb2dnbGUuZWxBcmlhUm9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoVG9nZ2xlLmVsQXJpYVJvbGVzW2ldKSlcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKFRvZ2dsZS5lbEFyaWFSb2xlc1tpXSxcbiAgICAgICAgICAhKGVsLmdldEF0dHJpYnV0ZShUb2dnbGUuZWxBcmlhUm9sZXNbaV0pID09PSAndHJ1ZScpKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgdGFyZ2V0IGZvciBkZWZpbmVkIGFyaWEgcm9sZXMgYW5kIHRvZ2dsZSB0aGVtIGlmIHRoZXkgZXhpc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRvZ2dsZS50YXJnZXRBcmlhUm9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YXJnZXQuZ2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0pKVxuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0sXG4gICAgICAgICAgISh0YXJnZXQuZ2V0QXR0cmlidXRlKFRvZ2dsZS50YXJnZXRBcmlhUm9sZXNbaV0pID09PSAndHJ1ZScpKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSAmJlxuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcykpXG4gICAge1xuICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gZWwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBtYWluIHNlbGVjdG9yIHRvIGFkZCB0aGUgdG9nZ2xpbmcgZnVuY3Rpb24gdG8gKi9cblRvZ2dsZS5zZWxlY3RvciA9ICdbZGF0YS1qcyo9XCJ0b2dnbGVcIl0nO1xuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIG5hbWVzcGFjZSBmb3Igb3VyIGRhdGEgYXR0cmlidXRlIHNldHRpbmdzICovXG5Ub2dnbGUubmFtZXNwYWNlID0gJ3RvZ2dsZSc7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgaGlkZSBjbGFzcyAqL1xuVG9nZ2xlLmluYWN0aXZlQ2xhc3MgPSAnaGlkZGVuJztcblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBhY3RpdmUgY2xhc3MgKi9cblRvZ2dsZS5hY3RpdmVDbGFzcyA9ICdhY3RpdmUnO1xuXG4vKiogQHR5cGUge0FycmF5fSBBcmlhIHJvbGVzIHRvIHRvZ2dsZSB0cnVlL2ZhbHNlIG9uIHRoZSB0b2dnbGluZyBlbGVtZW50ICovXG5Ub2dnbGUuZWxBcmlhUm9sZXMgPSBbJ2FyaWEtcHJlc3NlZCcsICdhcmlhLWV4cGFuZGVkJ107XG5cbi8qKiBAdHlwZSB7QXJyYXl9IEFyaWEgcm9sZXMgdG8gdG9nZ2xlIHRydWUvZmFsc2Ugb24gdGhlIHRhcmdldCBlbGVtZW50ICovXG5Ub2dnbGUudGFyZ2V0QXJpYVJvbGVzID0gWydhcmlhLWhpZGRlbiddO1xuXG5leHBvcnQgZGVmYXVsdCBUb2dnbGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVXRpbGl0eSBmcm9tICcuLi8uLi9qcy9tb2R1bGVzL3V0aWxpdHknO1xuXG4vKipcbiAqIFRyYWNraW5nIGJ1cyBmb3IgR29vZ2xlIGFuYWx5dGljcyBhbmQgV2VidHJlbmRzLlxuICovXG5jbGFzcyBUcmFjayB7XG4gIGNvbnN0cnVjdG9yKHMpIHtcbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgcyA9ICghcykgPyB7fSA6IHM7XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IHtcbiAgICAgIHNlbGVjdG9yOiAocy5zZWxlY3RvcikgPyBzLnNlbGVjdG9yIDogVHJhY2suc2VsZWN0b3IsXG4gICAgfTtcblxuICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmICghZXZlbnQudGFyZ2V0Lm1hdGNoZXModGhpcy5fc2V0dGluZ3Muc2VsZWN0b3IpKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGxldCBrZXkgPSBldmVudC50YXJnZXQuZGF0YXNldC50cmFja0tleTtcbiAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShldmVudC50YXJnZXQuZGF0YXNldC50cmFja0RhdGEpO1xuXG4gICAgICB0aGlzLmNsaWNrKGtleSwgZGF0YSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFja2luZyBmdW5jdGlvbiB3cmFwcGVyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKiBAcGFyYW0gIHtjb2xsZWN0aW9ufSBkYXRhIFRoZSBkYXRhIHRvIHRyYWNrXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIGZpbmFsIGRhdGEgb2JqZWN0XG4gICAqL1xuICBjbGljayhrZXksIGRhdGEpIHtcbiAgICAvLyBTZXQgdGhlIHBhdGggbmFtZSBiYXNlZCBvbiB0aGUgbG9jYXRpb25cbiAgICBjb25zdCBkID0gZGF0YS5tYXAoZWwgPT4ge1xuICAgICAgICBpZiAoZWwuaGFzT3duUHJvcGVydHkoVHJhY2sua2V5KSlcbiAgICAgICAgICBlbFtUcmFjay5rZXldID0gYCR7d2luZG93LmxvY2F0aW9uLnBhdGhuYW1lfS8ke2VsW1RyYWNrLmtleV19YFxuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9KTtcblxuICAgIGxldCB3dCA9IHRoaXMud2VidHJlbmRzKGtleSwgZCk7XG4gICAgbGV0IGdhID0gdGhpcy5ndGFnKGtleSwgZCk7XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgaWYgKFV0aWxpdHkuZGVidWcoKSlcbiAgICAgIGNvbnNvbGUuZGlyKHsnVHJhY2snOiBbd3QsIGdhXX0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXG4gICAgcmV0dXJuIGQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERhdGEgYnVzIGZvciB0cmFja2luZyB2aWV3cyBpbiBXZWJ0cmVuZHMgYW5kIEdvb2dsZSBBbmFseXRpY3NcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgYXBwICBUaGUgbmFtZSBvZiB0aGUgU2luZ2xlIFBhZ2UgQXBwbGljYXRpb24gdG8gdHJhY2tcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICovXG4gIHZpZXcoYXBwLCBrZXksIGRhdGEpIHtcbiAgICBsZXQgd3QgPSB0aGlzLndlYnRyZW5kcyhrZXksIGRhdGEpO1xuICAgIGxldCBnYSA9IHRoaXMuZ3RhZ1ZpZXcoYXBwLCBrZXkpO1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpXG4gICAgICBjb25zb2xlLmRpcih7J1RyYWNrJzogW3d0LCBnYV19KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgfTtcblxuICAvKipcbiAgICogUHVzaCBFdmVudHMgdG8gV2VidHJlbmRzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKiBAcGFyYW0gIHtjb2xsZWN0aW9ufSBkYXRhIFRoZSBkYXRhIHRvIHRyYWNrXG4gICAqL1xuICB3ZWJ0cmVuZHMoa2V5LCBkYXRhKSB7XG4gICAgbGV0IGV2ZW50ID0gW3tcbiAgICAgICdXVC50aSc6IGtleVxuICAgIH1dO1xuXG4gICAgaWYgKGRhdGFbMF0gJiYgZGF0YVswXS5oYXNPd25Qcm9wZXJ0eShUcmFjay5rZXkpKSB7XG4gICAgICBldmVudC5wdXNoKHtcbiAgICAgICAgJ0RDUy5kY3N1cmknOiBkYXRhWzBdW1RyYWNrLmtleV1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuYXNzaWduKGV2ZW50LCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgZGF0YSBmb3IgV2VidHJlbmRzXG4gICAgbGV0IHd0ZCA9IHthcmdzYTogZXZlbnQuZmxhdE1hcChlID0+IHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlKS5mbGF0TWFwKGsgPT4gW2ssIGVba11dKTtcbiAgICB9KX07XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgIGlmICh0eXBlb2YgV2VidHJlbmRzICE9PSAndW5kZWZpbmVkJylcbiAgICAgIFdlYnRyZW5kcy5tdWx0aVRyYWNrKHd0ZCk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblxuICAgIHJldHVybiBbJ1dlYnRyZW5kcycsIHd0ZF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggQ2xpY2sgRXZlbnRzIHRvIEdvb2dsZSBBbmFseXRpY3NcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgICAga2V5ICBUaGUga2V5IG9yIGV2ZW50IG9mIHRoZSBkYXRhXG4gICAqIEBwYXJhbSAge2NvbGxlY3Rpb259IGRhdGEgVGhlIGRhdGEgdG8gdHJhY2tcbiAgICovXG4gIGd0YWcoa2V5LCBkYXRhKSB7XG4gICAgbGV0IHVyaSA9IGRhdGEuZmluZCgoZWxlbWVudCkgPT4gZWxlbWVudC5oYXNPd25Qcm9wZXJ0eShUcmFjay5rZXkpKTtcblxuICAgIGxldCBldmVudCA9IHtcbiAgICAgICdldmVudF9jYXRlZ29yeSc6IGtleVxuICAgIH07XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuICAgIGlmICh0eXBlb2YgZ3RhZyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICBndGFnKFRyYWNrLmtleSwgdXJpW1RyYWNrLmtleV0sIGV2ZW50KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZGVmICovXG5cbiAgICByZXR1cm4gWydndGFnJywgVHJhY2sua2V5LCB1cmlbVHJhY2sua2V5XSwgZXZlbnRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQdXNoIFNjcmVlbiBWaWV3IEV2ZW50cyB0byBHb29nbGUgQW5hbHl0aWNzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGFwcCAgVGhlIG5hbWUgb2YgdGhlIGFwcGxpY2F0aW9uXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgIGtleSAgVGhlIGtleSBvciBldmVudCBvZiB0aGUgZGF0YVxuICAgKi9cbiAgZ3RhZ1ZpZXcoYXBwLCBrZXkpIHtcbiAgICBsZXQgdmlldyA9IHtcbiAgICAgIGFwcF9uYW1lOiBhcHAsXG4gICAgICBzY3JlZW5fbmFtZToga2V5XG4gICAgfTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG4gICAgaWYgKHR5cGVvZiBndGFnICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGd0YWcoJ2V2ZW50JywgJ3NjcmVlbl92aWV3Jywgdmlldyk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuXG4gICAgcmV0dXJuIFsnZ3RhZycsIFRyYWNrLmtleSwgJ3NjcmVlbl92aWV3Jywgdmlld107XG4gIH07XG59XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgbWFpbiBzZWxlY3RvciB0byBhZGQgdGhlIHRyYWNraW5nIGZ1bmN0aW9uIHRvICovXG5UcmFjay5zZWxlY3RvciA9ICdbZGF0YS1qcyo9XCJ0cmFja1wiXSc7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgbWFpbiBldmVudCB0cmFja2luZyBrZXkgdG8gbWFwIHRvIFdlYnRyZW5kcyBEQ1MudXJpICovXG5UcmFjay5rZXkgPSAnZXZlbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBUcmFjazsiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi42LjZcbiAqIChjKSAyMDE0LTIwMTkgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbmNvbnN0IGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZy5cbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICovXG5jb25zdCBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gKFxuICAgIGlzRGVmKHZhbCkgJiZcbiAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsLmNhdGNoID09PSAnZnVuY3Rpb24nXG4gIClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiBBcnJheS5pc0FycmF5KHZhbCkgfHwgKGlzUGxhaW5PYmplY3QodmFsKSAmJiB2YWwudG9TdHJpbmcgPT09IF90b1N0cmluZylcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgY29uc3QgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IHZhbCA9PiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldXG4gICAgOiB2YWwgPT4gbWFwW3ZhbF1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xuY29uc3QgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbmNvbnN0IGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICBjb25zdCBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCAoXywgYykgPT4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbmNvbnN0IGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICogc2luY2UgbmF0aXZlIGJpbmQgaXMgbm93IHBlcmZvcm1hbnQgZW5vdWdoIGluIG1vc3QgYnJvd3NlcnMuXG4gKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICByZXR1cm4gZm4uYmluZChjdHgpXG59XG5cbmNvbnN0IGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgbGV0IGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuICovXG5mdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbmNvbnN0IG5vID0gKGEsIGIsIGMpID0+IGZhbHNlO1xuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG5jb25zdCBpZGVudGl0eSA9IChfKSA9PiBfO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGljIGtleXMgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZSgoa2V5cywgbSkgPT4ge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWVcbiAgY29uc3QgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIGNvbnN0IGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICBjb25zdCBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIGNvbnN0IGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShrZXkgPT4ge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICogZm91bmQgaW4gdGhlIGFycmF5IChpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCwgdGhlIGFycmF5IG11c3RcbiAqIGNvbnRhaW4gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHNoYXBlKSwgb3IgLTEgaWYgaXQgaXMgbm90IHByZXNlbnQuXG4gKi9cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHJldHVybiBpXG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG5jb25zdCBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxuY29uc3QgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCcsXG4gICdzZXJ2ZXJQcmVmZXRjaCdcbl07XG5cbi8qICAqL1xuXG5cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcbiAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICovXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxuLyoqXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICovXG5jb25zdCB1bmljb2RlTGV0dGVycyA9ICdhLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEJztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIGNvbnN0IGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xuY29uc3QgYmFpbFJFID0gbmV3IFJlZ0V4cChgW14ke3VuaWNvZGVMZXR0ZXJzfS4kX1xcXFxkXWApO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSByZXR1cm5cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG5jb25zdCBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG5jb25zdCBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG5jb25zdCB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuY29uc3QgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbmNvbnN0IGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbmNvbnN0IGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG5jb25zdCBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbmNvbnN0IGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuY29uc3QgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xuY29uc3QgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcbmNvbnN0IGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG5jb25zdCBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxuY29uc3QgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG5sZXQgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxubGV0IF9pc1NlcnZlcjtcbmNvbnN0IGlzU2VydmVyUmVuZGVyaW5nID0gKCkgPT4ge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiAhaW5XZWV4ICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgIC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3NcbiAgICAgIF9pc1NlcnZlciA9IGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgX2lzU2VydmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfaXNTZXJ2ZXJcbn07XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xuY29uc3QgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxuY29uc3QgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxubGV0IF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IGNsYXNzIFNldCAgIHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH1cbiAgICBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5sZXQgd2FybiA9IG5vb3A7XG5sZXQgdGlwID0gbm9vcDtcbmxldCBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5sZXQgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxue1xuICBjb25zdCBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICBjb25zdCBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICBjb25zdCBjbGFzc2lmeSA9IHN0ciA9PiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBjID0+IGMudG9VcHBlckNhc2UoKSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7XG5cbiAgd2FybiA9IChtc2csIHZtKSA9PiB7XG4gICAgY29uc3QgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtWdWUgd2Fybl06ICR7bXNnfSR7dHJhY2V9YCk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IChtc2csIHZtKSA9PiB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKGBbVnVlIHRpcF06ICR7bXNnfWAgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSAodm0sIGluY2x1ZGVGaWxlKSA9PiB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm07XG4gICAgbGV0IG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIGNvbnN0IGZpbGUgPSBvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyBgPCR7Y2xhc3NpZnkobmFtZSl9PmAgOiBgPEFub255bW91cz5gKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyBgIGF0ICR7ZmlsZX1gIDogJycpXG4gICAgKVxuICB9O1xuXG4gIGNvbnN0IHJlcGVhdCA9IChzdHIsIG4pID0+IHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgcmVzICs9IHN0cjtcbiAgICAgIGlmIChuID4gMSkgc3RyICs9IHN0cjtcbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gdm0gPT4ge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgY29uc3QgdHJlZSA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKCh2bSwgaSkgPT4gYCR7XG4gICAgICAgICAgaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpXG4gICAgICAgIH0ke1xuICAgICAgICAgIEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/IGAke2Zvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pfS4uLiAoJHt2bVsxXX0gcmVjdXJzaXZlIGNhbGxzKWBcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSlcbiAgICAgICAgfWApXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYFxcblxcbihmb3VuZCBpbiAke2Zvcm1hdENvbXBvbmVudE5hbWUodm0pfSlgXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG5jbGFzcyBEZXAge1xuICBcbiAgXG4gIFxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmlkID0gdWlkKys7XG4gICAgdGhpcy5zdWJzID0gW107XG4gIH1cblxuICBhZGRTdWIgKHN1Yikge1xuICAgIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG4gIH1cblxuICByZW1vdmVTdWIgKHN1Yikge1xuICAgIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG4gIH1cblxuICBkZXBlbmQgKCkge1xuICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnkgKCkge1xuICAgIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gICAgY29uc3Qgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICAgIGlmICghY29uZmlnLmFzeW5jKSB7XG4gICAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgICAvLyBvcmRlclxuICAgICAgc3Vicy5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxuLy8gY2FuIGJlIGV2YWx1YXRlZCBhdCBhIHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbmNvbnN0IHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKHRhcmdldCkge1xuICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIHRhcmdldFN0YWNrLnBvcCgpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG59XG5cbi8qICAqL1xuXG5jbGFzcyBWTm9kZSB7XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gICAvLyByZW5kZXJlZCBpbiB0aGlzIGNvbXBvbmVudCdzIHNjb3BlXG4gIFxuICBcbiAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgLy8gY29tcG9uZW50IHBsYWNlaG9sZGVyIG5vZGVcblxuICAvLyBzdHJpY3RseSBpbnRlcm5hbFxuICAgLy8gY29udGFpbnMgcmF3IEhUTUw/IChzZXJ2ZXIgb25seSlcbiAgIC8vIGhvaXN0ZWQgc3RhdGljIG5vZGVcbiAgIC8vIG5lY2Vzc2FyeSBmb3IgZW50ZXIgdHJhbnNpdGlvbiBjaGVja1xuICAgLy8gZW1wdHkgY29tbWVudCBwbGFjZWhvbGRlcj9cbiAgIC8vIGlzIGEgY2xvbmVkIG5vZGU/XG4gICAvLyBpcyBhIHYtb25jZSBub2RlP1xuICAgLy8gYXN5bmMgY29tcG9uZW50IGZhY3RvcnkgZnVuY3Rpb25cbiAgXG4gIFxuICBcbiAgIC8vIHJlYWwgY29udGV4dCB2bSBmb3IgZnVuY3Rpb25hbCBub2Rlc1xuICAgLy8gZm9yIFNTUiBjYWNoaW5nXG4gICAvLyB1c2VkIHRvIHN0b3JlIGZ1bmN0aW9uYWwgcmVuZGVyIGNvbnRleHQgZm9yIGRldnRvb2xzXG4gICAvLyBmdW5jdGlvbmFsIHNjb3BlIGlkIHN1cHBvcnRcblxuICBjb25zdHJ1Y3RvciAoXG4gICAgdGFnLFxuICAgIGRhdGEsXG4gICAgY2hpbGRyZW4sXG4gICAgdGV4dCxcbiAgICBlbG0sXG4gICAgY29udGV4dCxcbiAgICBjb21wb25lbnRPcHRpb25zLFxuICAgIGFzeW5jRmFjdG9yeVxuICApIHtcbiAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuZWxtID0gZWxtO1xuICAgIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gICAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmF3ID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICAgIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICAgIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICAgIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG4gIH1cblxuICAvLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBjaGlsZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2VcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVFbXB0eVZOb2RlID0gKHRleHQgPSAnJykgPT4ge1xuICBjb25zdCBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICBjb25zdCBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgLy8gIzc5NzVcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAvLyBhIGNoaWxkLlxuICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxuY29uc3QgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbmNvbnN0IGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbmNvbnN0IG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICBjb25zdCBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICguLi5hcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgY29uc3Qgb2IgPSB0aGlzLl9fb2JfXztcbiAgICBsZXQgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpO1xuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxuY29uc3QgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcbiAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAqL1xubGV0IHNob3VsZE9ic2VydmUgPSB0cnVlO1xuXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xuY2xhc3MgT2JzZXJ2ZXIge1xuICBcbiAgXG4gICAvLyBudW1iZXIgb2Ygdm1zIHRoYXQgaGF2ZSB0aGlzIG9iamVjdCBhcyByb290ICRkYXRhXG5cbiAgY29uc3RydWN0b3IgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIHRoaXMudm1Db3VudCA9IDA7XG4gICAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2FsayB0aHJvdWdoIGFsbCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICAgKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAgICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gICAqL1xuICB3YWxrIChvYmopIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICAgKi9cbiAgb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUkJDEgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICBjb25zdCBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgY29uc3QgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICBjb25zdCBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIGNvbnN0IHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG5cbiAgbGV0IGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIC8vICM3OTgxOiBmb3IgYWNjZXNzb3IgcHJvcGVydGllcyB3aXRob3V0IHNldHRlclxuICAgICAgaWYgKGdldHRlciAmJiAhc2V0dGVyKSByZXR1cm5cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICApIHtcbiAgICB3YXJuKGBDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiAkeyh0YXJnZXQpfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBjb25zdCBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICApIHtcbiAgICB3YXJuKGBDYW5ub3QgZGVsZXRlIHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiAkeyh0YXJnZXQpfWApO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yIChsZXQgZSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbmNvbnN0IHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG57XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBvcHRpb24gXCIke2tleX1cIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBgICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgcmV0dXJuIHRvXG4gIGxldCBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gIGNvbnN0IGtleXMgPSBoYXNTeW1ib2xcbiAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgIGlmIChrZXkgPT09ICdfX29iX18nKSBjb250aW51ZVxuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRvVmFsICE9PSBmcm9tVmFsICYmXG4gICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxuICAgICAgaXNQbGFpbk9iamVjdChmcm9tVmFsKVxuICAgICkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICBjb25zdCBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIGNvbnN0IGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICBjb25zdCByZXMgPSBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWw7XG4gIHJldHVybiByZXNcbiAgICA/IGRlZHVwZUhvb2tzKHJlcylcbiAgICA6IHJlc1xufVxuXG5mdW5jdGlvbiBkZWR1cGVIb29rcyAoaG9va3MpIHtcbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGhvb2sgPT4ge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgY29uc3QgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgcGFyZW50VmFsID0gdW5kZWZpbmVkO1xuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSBjaGlsZFZhbCA9IHVuZGVmaW5lZDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKVxuICB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbFxuICBjb25zdCByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICBsZXQgcGFyZW50ID0gcmV0W2tleV07XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHJldHVybiBjaGlsZFZhbFxuICBjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBpZiAoY2hpbGRWYWwpIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG5jb25zdCBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICBpZiAoIW5ldyBSZWdFeHAoYF5bYS16QS1aXVtcXFxcLVxcXFwuMC05XyR7dW5pY29kZUxldHRlcnN9XSokYCkudGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICBjb25zdCBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHJldHVyblxuICBjb25zdCByZXMgPSB7fTtcbiAgbGV0IGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdhcm4oXG4gICAgICBgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwicHJvcHNcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBgICtcbiAgICAgIGBidXQgZ290ICR7dG9SYXdUeXBlKHByb3BzKX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICBjb25zdCBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHJldHVyblxuICBjb25zdCBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmplY3QpIHtcbiAgICAgIGNvbnN0IHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcImluamVjdFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIGAgK1xuICAgICAgYGJ1dCBnb3QgJHt0b1Jhd1R5cGUoaW5qZWN0KX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgY29uc3QgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkaXJzKSB7XG4gICAgICBjb25zdCBkZWYkJDEgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiQkMSwgdXBkYXRlOiBkZWYkJDEgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcIiR7bmFtZX1cIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBgICtcbiAgICAgIGBidXQgZ290ICR7dG9SYXdUeXBlKHZhbHVlKX0uYCxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxuICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgaWYgKCFjaGlsZC5fYmFzZSkge1xuICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgfVxuICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0ge307XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICBjb25zdCBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHJldHVybiBhc3NldHNbaWRdXG4gIGNvbnN0IGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXVxuICBjb25zdCBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgY29uc3QgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAod2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICBjb25zdCBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgY29uc3QgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIGxldCB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgY29uc3QgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgdmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGEgZnJlc2ggY29weSxcbiAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICBjb25zdCBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgY29uc3QgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbGV0IHR5cGUgPSBwcm9wLnR5cGU7XG4gIGxldCB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIGNvbnN0IGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgbGV0IHZhbGlkO1xuICBjb25zdCBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIGNvbnN0IG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UgKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuYCArXG4gICAgYCBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJyl9YDtcbiAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZXhwZWN0ZWRUeXBlc1swXTtcbiAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgY29uc3QgZXhwZWN0ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIGV4cGVjdGVkVHlwZSk7XG4gIGNvbnN0IHJlY2VpdmVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpO1xuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICBpc0V4cGxpY2FibGUoZXhwZWN0ZWRUeXBlKSAmJlxuICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcbiAgfVxuICBtZXNzYWdlICs9IGAsIGdvdCAke3JlY2VpdmVkVHlwZX0gYDtcbiAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXG4gIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gYHdpdGggdmFsdWUgJHtyZWNlaXZlZFZhbHVlfS5gO1xuICB9XG4gIHJldHVybiBtZXNzYWdlXG59XG5cbmZ1bmN0aW9uIHN0eWxlVmFsdWUgKHZhbHVlLCB0eXBlKSB7XG4gIGlmICh0eXBlID09PSAnU3RyaW5nJykge1xuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYFxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdOdW1iZXInKSB7XG4gICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHt2YWx1ZX1gXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICBjb25zdCBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShlbGVtID0+IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pXG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbiAoLi4uYXJncykge1xuICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAodm0pIHtcbiAgICBsZXQgY3VyID0gdm07XG4gICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSByZXR1cm5cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGludm9rZVdpdGhFcnJvckhhbmRsaW5nIChcbiAgaGFuZGxlcixcbiAgY29udGV4dCxcbiAgYXJncyxcbiAgdm0sXG4gIGluZm9cbikge1xuICBsZXQgcmVzO1xuICB0cnkge1xuICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgIGlmIChyZXMgJiYgIXJlcy5faXNWdWUgJiYgaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcy5jYXRjaChlID0+IGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgYCAoUHJvbWlzZS9hc3luYylgKSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIHtcbiAgICB3YXJuKGBFcnJvciBpbiAke2luZm99OiBcIiR7ZXJyLnRvU3RyaW5nKCl9XCJgLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG5cbmxldCBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5cbmNvbnN0IGNhbGxiYWNrcyA9IFtdO1xubGV0IHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIGNvbnN0IGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxuLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbi8vIEhvd2V2ZXIsIGl0IGhhcyBzdWJ0bGUgcHJvYmxlbXMgd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50XG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuLy8gdGhhdCBjYW5ub3QgYmUgY2lyY3VtdmVudGVkIChlLmcuICM3MTA5LCAjNzE1MywgIzc1NDYsICM3ODM0LCAjODEwOSkuXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXG4vLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Ncbi8vIHdoZXJlIG1pY3JvdGFza3MgaGF2ZSB0b28gaGlnaCBhIHByaW9yaXR5IGFuZCBmaXJlIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxuLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG5sZXQgdGltZXJGdW5jO1xuXG4vLyBUaGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXRhdGlvbk9ic2VydmVyIGhhcyB3aWRlciBzdXBwb3J0LCBob3dldmVyIGl0IGlzIHNlcmlvdXNseSBidWdnZWQgaW5cbi8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4vLyBQcm9taXNlIGlzIGF2YWlsYWJsZSwgd2Ugd2lsbCB1c2UgaXQ6XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCwgJGZsb3ctZGlzYWJsZS1saW5lICovXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gIGNvbnN0IHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHNldFRpbWVvdXQobm9vcCk7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICghaXNJRSAmJiB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuKSkge1xuICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgLy8gKCM2NDY2IE11dGF0aW9uT2JzZXJ2ZXIgaXMgdW5yZWxpYWJsZSBpbiBJRTExKVxuICBsZXQgY291bnRlciA9IDE7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICBjb25zdCB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gIH0pO1xuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgLy8gVGVjaGluaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIGxldCBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbmxldCBtYXJrO1xubGV0IG1lYXN1cmU7XG5cbntcbiAgY29uc3QgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gdGFnID0+IHBlcmYubWFyayh0YWcpO1xuICAgIG1lYXN1cmUgPSAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykgPT4ge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgLy8gcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpXG4gICAgfTtcbiAgfVxufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxubGV0IGluaXRQcm94eTtcblxue1xuICBjb25zdCBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICBjb25zdCB3YXJuTm9uUHJlc2VudCA9ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgIHdhcm4oXG4gICAgICBgUHJvcGVydHkgb3IgbWV0aG9kIFwiJHtrZXl9XCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBgICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCB3YXJuUmVzZXJ2ZWRQcmVmaXggPSAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICB3YXJuKFxuICAgICAgYFByb3BlcnR5IFwiJHtrZXl9XCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFwiJGRhdGEuJHtrZXl9XCIgYmVjYXVzZSBgICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9hcGkvI2RhdGEnLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICBjb25zdCBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgY29uc3QgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKGBBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC4ke2tleX1gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgY29uc3QgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5jaGFyQXQoMCkgPT09ICdfJyAmJiAhKGtleSBpbiB0YXJnZXQuJGRhdGEpKTtcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGVsc2Ugd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7XG4gICAgICAgIGVsc2Ugd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgY29uc3QgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuY29uc3Qgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIGxldCBpLCBrZXlzO1xuICBjb25zdCBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIGNvbnN0IGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pO1xuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBub3JtYWxpemVFdmVudCA9IGNhY2hlZCgobmFtZSkgPT4ge1xuICBjb25zdCBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgY29uc3Qgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgY29uc3QgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmUsXG4gICAgcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMsIHZtKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIGNvbnN0IGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMsIHZtLCBgdi1vbiBoYW5kbGVyYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBgdi1vbiBoYW5kbGVyYClcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIGNyZWF0ZU9uY2VIYW5kbGVyLFxuICB2bVxuKSB7XG4gIGxldCBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgZGVmJCQxID0gY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcIiR7ZXZlbnQubmFtZX1cIjogZ290IGAgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICBsZXQgaW52b2tlcjtcbiAgY29uc3Qgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICBjb25zdCBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgcmVzID0ge307XG4gIGNvbnN0IHsgYXR0cnMsIHByb3BzIH0gPSBkYXRhO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBjb25zdCBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIHtcbiAgICAgICAgY29uc3Qga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBgUHJvcCBcIiR7a2V5SW5Mb3dlckNhc2V9XCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBgICtcbiAgICAgICAgICAgIGAke2Zvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpfSwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNgICtcbiAgICAgICAgICAgIGAgXCIke2tleX1cIi4gYCArXG4gICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBgICtcbiAgICAgICAgICAgIGBwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIGAgK1xuICAgICAgICAgICAgYHRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2FsdEtleX1cIiBpbnN0ZWFkIG9mIFwiJHtrZXl9XCIuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBsZXQgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgY29udGludWVcbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsIGAke25lc3RlZEluZGV4IHx8ICcnfV8ke2l9YCk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IGBfX3ZsaXN0JHtuZXN0ZWRJbmRleH1fJHtpfV9fYDtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIGNvbnN0IHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgY29uc3QgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSwgKCkgPT4ge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBgICtcbiAgICAgICAgICAgIGBvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIGAgK1xuICAgICAgICAgICAgYGluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcIiR7a2V5fVwiYCxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgY29udGludWVcbiAgICAgIGNvbnN0IHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgbGV0IHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICBjb25zdCBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihgSW5qZWN0aW9uIFwiJHtrZXl9XCIgbm90IGZvdW5kYCwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICBjb25zdCBzbG90cyA9IHt9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgY29uc3QgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICBjb25zdCBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKGNvbnN0IG5hbWUgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgbm9ybWFsU2xvdHMsXG4gIHByZXZTbG90c1xuKSB7XG4gIGxldCByZXM7XG4gIGlmICghc2xvdHMpIHtcbiAgICByZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICB9IGVsc2UgaWYgKFxuICAgIHNsb3RzLiRzdGFibGUgJiZcbiAgICBwcmV2U2xvdHMgJiZcbiAgICBwcmV2U2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmXG4gICAgT2JqZWN0LmtleXMobm9ybWFsU2xvdHMpLmxlbmd0aCA9PT0gMFxuICApIHtcbiAgICAvLyBmYXN0IHBhdGggMjogc3RhYmxlIHNjb3BlZCBzbG90cyB3LyBubyBub3JtYWwgc2xvdHMgdG8gcHJveHksXG4gICAgLy8gb25seSBuZWVkIHRvIG5vcm1hbGl6ZSBvbmNlXG4gICAgcmV0dXJuIHByZXZTbG90c1xuICB9IGVsc2Uge1xuICAgIHJlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICBpZiAoc2xvdHNba2V5XSAmJiBrZXlbMF0gIT09ICckJykge1xuICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSwgc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGV4cG9zZSBub3JtYWwgc2xvdHMgb24gc2NvcGVkU2xvdHNcbiAgZm9yIChjb25zdCBrZXkgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICBpZiAoIShrZXkgaW4gcmVzKSkge1xuICAgICAgcmVzW2tleV0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcbiAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gIGlmIChzbG90cyAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHNsb3RzKSkge1xuICAgIChzbG90cykuX25vcm1hbGl6ZWQgPSByZXM7XG4gIH1cbiAgZGVmKHJlcywgJyRzdGFibGUnLCBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6IHRydWUpO1xuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3Qobm9ybWFsU2xvdHMsIGtleSwgZm4pIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICA6IG5vcm1hbGl6ZUNoaWxkcmVuKHJlcyk7XG4gICAgcmV0dXJuIHJlcyAmJiByZXMubGVuZ3RoID09PSAwXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gKCkgPT4gc2xvdHNba2V5XVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICBsZXQgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB2YWxbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgbGV0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgcmV0LnB1c2gocmVuZGVyKHJlc3VsdC52YWx1ZSwgcmV0Lmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNEZWYocmV0KSkge1xuICAgIHJldCA9IFtdO1xuICB9XG4gIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgY29uc3Qgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIGxldCBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgbm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXSB8fCBmYWxsYmFjaztcbiAgfVxuXG4gIGNvbnN0IHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIGNvbnN0IG1hcHBlZEtleUNvZGUgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluS2V5Q29kZTtcbiAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChidWlsdEluS2V5TmFtZSwgZXZlbnRLZXlOYW1lKVxuICB9IGVsc2UgaWYgKG1hcHBlZEtleUNvZGUpIHtcbiAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBsZXQgaGFzaDtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpICYmICEoY2FtZWxpemVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uW2B1cGRhdGU6JHtjYW1lbGl6ZWRLZXl9YF0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICBjb25zdCBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIGxldCB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIGBfX3N0YXRpY19fJHtpbmRleH1gLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIGBfX29uY2VfXyR7aW5kZXh9JHtrZXkgPyBgXyR7a2V5fWAgOiBgYH1gLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCBgJHtrZXl9XyR7aX1gLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgY29uc3Qgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICBoYXNEeW5hbWljS2V5cyxcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHsgJHN0YWJsZTogIWhhc0R5bmFtaWNLZXlzIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2xvdCA9IGZuc1tpXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzbG90KSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIGhhc0R5bmFtaWNLZXlzLCByZXMpO1xuICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gICAgICBpZiAoc2xvdC5wcm94eSkge1xuICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IGtleSA9IHZhbHVlc1tpXTtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5KSB7XG4gICAgICBiYXNlT2JqW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xuICAgIH0gZWxzZSBpZiAoa2V5ICE9PSAnJyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgYSBzcGVpY2FsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgd2FybihcbiAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6ICR7a2V5fWAsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlT2JqXG59XG5cbi8vIGhlbHBlciB0byBkeW5hbWljYWxseSBhcHBlbmQgbW9kaWZpZXIgcnVudGltZSBtYXJrZXJzIHRvIGV2ZW50IG5hbWVzLlxuLy8gZW5zdXJlIG9ubHkgYXBwZW5kIHdoZW4gdmFsdWUgaXMgYWxyZWFkeSBzdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGNhc3Rcbi8vIHRvIHN0cmluZyBhbmQgY2F1c2UgdGhlIHR5cGUgY2hlY2sgdG8gbWlzcy5cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllciAodmFsdWUsIHN5bWJvbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWVcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG4gIHRhcmdldC5fZCA9IGJpbmREeW5hbWljS2V5cztcbiAgdGFyZ2V0Ll9wID0gcHJlcGVuZE1vZGlmaWVyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICBkYXRhLFxuICBwcm9wcyxcbiAgY2hpbGRyZW4sXG4gIHBhcmVudCxcbiAgQ3RvclxuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICBsZXQgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICBjb25zdCBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgY29uc3QgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgdGhpcy5zbG90cyA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuJHNsb3RzKSB7XG4gICAgICBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgdGhpcy4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRzbG90c1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NvcGVkU2xvdHMnLCAoe1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0ICgpIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLnNsb3RzKCkpXG4gICAgfVxuICB9KSk7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKGRhdGEuc2NvcGVkU2xvdHMsIHRoaXMuJHNsb3RzKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IChhLCBiLCBjLCBkKSA9PiB7XG4gICAgICBjb25zdCB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICAgIHZub2RlLmZuQ29udGV4dCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fYyA9IChhLCBiLCBjLCBkKSA9PiBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICB9XG59XG5cbmluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHRWbSxcbiAgY2hpbGRyZW5cbikge1xuICBjb25zdCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBjb25zdCBwcm9wcyA9IHt9O1xuICBjb25zdCBwcm9wT3B0aW9ucyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIG1lcmdlUHJvcHMocHJvcHMsIGRhdGEuYXR0cnMpO1xuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7XG4gIH1cblxuICBjb25zdCByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICBjb25zdCB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICBjb25zdCB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XG4gICAgY29uc3QgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIGNvbnN0IGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAge1xuICAgIChjbG9uZS5kZXZ0b29sc01ldGEgPSBjbG9uZS5kZXZ0b29sc01ldGEgfHwge30pLnJlbmRlckNvbnRleHQgPSByZW5kZXJDb250ZXh0O1xuICB9XG4gIGlmIChkYXRhLnNsb3QpIHtcbiAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxuY29uc3QgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICBjb25zdCBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VcbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgY29uc3QgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydCAodm5vZGUpIHtcbiAgICBjb25zdCB7IGNvbnRleHQsIGNvbXBvbmVudEluc3RhbmNlIH0gPSB2bm9kZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveSAodm5vZGUpIHtcbiAgICBjb25zdCB7IGNvbXBvbmVudEluc3RhbmNlIH0gPSB2bm9kZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgd2FybihgSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogJHtTdHJpbmcoQ3Rvcil9YCwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIGxldCBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgY29uc3QgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIGNvbnN0IGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICBjb25zdCBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcbiAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIGNvbnN0IG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIGNvbnN0IHZub2RlID0gbmV3IFZOb2RlKFxuICAgIGB2dWUtY29tcG9uZW50LSR7Q3Rvci5jaWR9JHtuYW1lID8gYC0ke25hbWV9YCA6ICcnfWAsXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3IsIHByb3BzRGF0YSwgbGlzdGVuZXJzLCB0YWcsIGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBwYXJlbnRcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgY29uc3QgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIGNvbnN0IGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICBjb25zdCB0b01lcmdlID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICBob29rc1trZXldID0gZXhpc3RpbmcgPyBtZXJnZUhvb2skMSh0b01lcmdlLCBleGlzdGluZykgOiB0b01lcmdlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoZjEsIGYyKSB7XG4gIGNvbnN0IG1lcmdlZCA9IChhLCBiKSA9PiB7XG4gICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgIGYxKGEsIGIpO1xuICAgIGYyKGEsIGIpO1xuICB9O1xuICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XG4gIHJldHVybiBtZXJnZWRcbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICBjb25zdCBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICBjb25zdCBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgOyhkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIGNvbnN0IG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgY29uc3QgZXhpc3RpbmcgPSBvbltldmVudF07XG4gIGNvbnN0IGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgaWYgKGlzRGVmKGV4aXN0aW5nKSkge1xuICAgIGlmIChcbiAgICAgIEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpXG4gICAgICAgID8gZXhpc3RpbmcuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xXG4gICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG5jb25zdCBTSU1QTEVfTk9STUFMSVpFID0gMTtcbmNvbnN0IEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlXG4pIHtcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgd2FybihcbiAgICAgIGBBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfVxcbmAgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICBsZXQgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICBsZXQgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgYXBwbHlOUyh2bm9kZSwgbnMpO1xuICAgIGlmIChpc0RlZihkYXRhKSkgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICBjb25zdCBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIGNvbnN0IHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIGNvbnN0IHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSAoYSwgYiwgYywgZCkgPT4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpO1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpO1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgY29uc3QgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCAoKSA9PiB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oYCRhdHRycyBpcyByZWFkb25seS5gLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCAoKSA9PiB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oYCRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuYCwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9XG59XG5cbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgY29uc3QgeyByZW5kZXIsIF9wYXJlbnRWbm9kZSB9ID0gdm0uJG9wdGlvbnM7XG5cbiAgICBpZiAoX3BhcmVudFZub2RlKSB7XG4gICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHZtLiRzbG90cyxcbiAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICBsZXQgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1ZXMgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXG4gICAgICAvLyB3aGVuIHBhcmVudCBjb21wb25lbnQgaXMgcGF0Y2hlZC5cbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgYHJlbmRlcmApO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgcmVuZGVyRXJyb3JgKTtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpICYmIHZub2RlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gc2V0IHBhcmVudFxuICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICByZXR1cm4gdm5vZGVcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgY29uc3Qgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGNvbnN0IG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAoaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb3duZXJzID0gZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdO1xuICAgIGxldCBzeW5jID0gdHJ1ZTtcblxuICAgIGNvbnN0IGZvcmNlUmVuZGVyID0gKHJlbmRlckNvbXBsZXRlZCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByZXNvbHZlID0gb25jZSgocmVzKSA9PiB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVqZWN0ID0gb25jZShyZWFzb24gPT4ge1xuICAgICAgd2FybihcbiAgICAgICAgYEZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogJHtTdHJpbmcoZmFjdG9yeSl9YCArXG4gICAgICAgIChyZWFzb24gPyBgXFxuUmVhc29uOiAke3JlYXNvbn1gIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcihmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBgdGltZW91dCAoJHtyZXMudGltZW91dH1tcylgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICBjb25zdCBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbmxldCB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQ7XG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgY29uc3QgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICBfdGFyZ2V0LiRvZmYoZXZlbnQsIG9uY2VIYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIGNvbnN0IGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICBjb25zdCBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgbGV0IGNiO1xuICAgIGxldCBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAge1xuICAgICAgY29uc3QgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBgICtcbiAgICAgICAgICBgJHtmb3JtYXRDb21wb25lbnROYW1lKHZtKX0gYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFwiJHtldmVudH1cIi4gYCArXG4gICAgICAgICAgYE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIGAgK1xuICAgICAgICAgIGB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gYCArXG4gICAgICAgICAgYFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFwiJHtoeXBoZW5hdGUoZXZlbnQpfVwiIGluc3RlYWQgb2YgXCIke2V2ZW50fVwiLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgY29uc3QgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGNvbnN0IGluZm8gPSBgZXZlbnQgaGFuZGxlciBmb3IgXCIke2V2ZW50fVwiYDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbmxldCBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgY29uc3QgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gIHJldHVybiAoKSA9PiB7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIGxldCBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIGNvbnN0IHByZXZFbCA9IHZtLiRlbDtcbiAgICBjb25zdCBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgY29uc3QgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgY29uc3QgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgbGV0IGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICBsZXQgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgY29uc3QgaWQgPSB2bS5fdWlkO1xuICAgICAgY29uc3Qgc3RhcnRUYWcgPSBgdnVlLXBlcmYtc3RhcnQ6JHtpZH1gO1xuICAgICAgY29uc3QgZW5kVGFnID0gYHZ1ZS1wZXJmLWVuZDoke2lkfWA7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgY29uc3Qgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKGB2dWUgJHtuYW1lfSByZW5kZXJgLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZShgdnVlICR7bmFtZX0gcGF0Y2hgLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH1cblxuICAvLyB3ZSBzZXQgdGhpcyB0byB2bS5fd2F0Y2hlciBpbnNpZGUgdGhlIHdhdGNoZXIncyBjb25zdHJ1Y3RvclxuICAvLyBzaW5jZSB0aGUgd2F0Y2hlcidzIGluaXRpYWwgcGF0Y2ggbWF5IGNhbGwgJGZvcmNlVXBkYXRlIChlLmcuIGluc2lkZSBjaGlsZFxuICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gIG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3AsIHtcbiAgICBiZWZvcmUgKCkge1xuICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICBjb25zdCBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgIChwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzICYmICFwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgKHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIXZtLiRzY29wZWRTbG90cy4kc3RhYmxlKVxuICApO1xuXG4gIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gIC8vIHVwZGF0ZSBpcyBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3RuZXNzLlxuICBjb25zdCBuZWVkc0ZvcmNlVXBkYXRlID0gISEoXG4gICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICBoYXNEeW5hbWljU2NvcGVkU2xvdFxuICApO1xuXG4gIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXG4gIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICB2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG4gIH1cbiAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXG4gIC8vIHRoZXNlIGFyZSBhbHNvIHJlYWN0aXZlIHNvIHRoZXkgbWF5IHRyaWdnZXIgY2hpbGQgdXBkYXRlIGlmIHRoZSBjaGlsZFxuICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICB2bS4kYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBjb25zdCBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICBjb25zdCBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIGNvbnN0IHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgY29uc3Qgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG5cbiAge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXG4gIHB1c2hUYXJnZXQoKTtcbiAgY29uc3QgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgY29uc3QgaW5mbyA9IGAke2hvb2t9IGhvb2tgO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxuY29uc3QgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxuY29uc3QgcXVldWUgPSBbXTtcbmNvbnN0IGFjdGl2YXRlZENoaWxkcmVuID0gW107XG5sZXQgaGFzID0ge307XG5sZXQgY2lyY3VsYXIgPSB7fTtcbmxldCB3YWl0aW5nID0gZmFsc2U7XG5sZXQgZmx1c2hpbmcgPSBmYWxzZTtcbmxldCBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG5sZXQgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbmxldCBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbmlmIChpbkJyb3dzZXIgJiYgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXApIHtcbiAgLy8gaWYgdGhlIGxvdy1yZXMgdGltZXN0YW1wIHdoaWNoIGlzIGJpZ2dlciB0aGFuIHRoZSBldmVudCB0aW1lc3RhbXBcbiAgLy8gKHdoaWNoIGlzIGV2YWx1YXRlZCBBRlRFUikgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gdXNlIHRoZSBoaS1yZXMgdmVyc2lvbiBmb3IgZXZlbnQgbGlzdGVuZXJzIGFzIHdlbGwuXG4gIGdldE5vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgbGV0IHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IGBpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcIiR7d2F0Y2hlci5leHByZXNzaW9ufVwiYFxuICAgICAgICAgICAgICA6IGBpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uYFxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgY29uc3QgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICBjb25zdCB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgbGV0IGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgY29uc3Qgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIGNvbnN0IGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICBsZXQgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgICBmbHVzaFNjaGVkdWxlclF1ZXVlKCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5cblxubGV0IHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xuY2xhc3MgV2F0Y2hlciB7XG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcblxuICBjb25zdHJ1Y3RvciAoXG4gICAgdm0sXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zLFxuICAgIGlzUmVuZGVyV2F0Y2hlclxuICApIHtcbiAgICB0aGlzLnZtID0gdm07XG4gICAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICAgIH1cbiAgICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgICAvLyBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICAgICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuY2IgPSBjYjtcbiAgICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgIHRoaXMubmV3RGVwcyA9IFtdO1xuICAgIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gICAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbi50b1N0cmluZygpO1xuICAgIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICAgIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXCIke2V4cE9yRm59XCIgYCArXG4gICAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHRoaXMuZ2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgZ2V0ICgpIHtcbiAgICBwdXNoVGFyZ2V0KHRoaXMpO1xuICAgIGxldCB2YWx1ZTtcbiAgICBjb25zdCB2bSA9IHRoaXMudm07XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGBnZXR0ZXIgZm9yIHdhdGNoZXIgXCIke3RoaXMuZXhwcmVzc2lvbn1cImApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBwb3BUYXJnZXQoKTtcbiAgICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICovXG4gIGFkZERlcCAoZGVwKSB7XG4gICAgY29uc3QgaWQgPSBkZXAuaWQ7XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgY2xlYW51cERlcHMgKCkge1xuICAgIGxldCBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCB0bXAgPSB0aGlzLmRlcElkcztcbiAgICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICAgIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICAgIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gICAgdG1wID0gdGhpcy5kZXBzO1xuICAgIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gICAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gICAqL1xuICB1cGRhdGUgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAqL1xuICBydW4gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgICAgaWYgKFxuICAgICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgICB0aGlzLmRlZXBcbiAgICAgICkge1xuICAgICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIGBjYWxsYmFjayBmb3Igd2F0Y2hlciBcIiR7dGhpcy5leHByZXNzaW9ufVwiYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAgICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICAgKi9cbiAgZXZhbHVhdGUgKCkge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAgICovXG4gIGRlcGVuZCAoKSB7XG4gICAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gICAqL1xuICB0ZWFyZG93biAoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgICB9XG4gICAgICBsZXQgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3Qgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIGNvbnN0IG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7XG4gIGlmIChvcHRzLm1ldGhvZHMpIGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpO1xuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTtcbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICBjb25zdCBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIGNvbnN0IHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICBjb25zdCBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIGNvbnN0IGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIHByb3BzT3B0aW9ucykge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIGNvbnN0IGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYFwiJHtoeXBoZW5hdGVkS2V5fVwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5gLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgKCkgPT4ge1xuICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIGBBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgYCArXG4gICAgICAgICAgICBgb3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gYCArXG4gICAgICAgICAgICBgSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIGAgK1xuICAgICAgICAgICAgYHZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFwiJHtrZXl9XCJgLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBgX3Byb3BzYCwga2V5KTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgbGV0IGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGNvbnN0IG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LmAsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgd2FybihcbiAgICAgICAgYFRoZSBkYXRhIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIGAgK1xuICAgICAgICBgVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLmAsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIGBfZGF0YWAsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGBkYXRhKClgKTtcbiAgICByZXR1cm4ge31cbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5jb25zdCBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBjb25zdCB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgY29uc3QgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgY29uc3QgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgY29uc3QgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgaWYgKGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIuYCxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICB3YXJuKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5gLCB2bSk7XG4gICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICB3YXJuKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLmAsIHZtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICB0YXJnZXQsXG4gIGtleSxcbiAgdXNlckRlZlxuKSB7XG4gIGNvbnN0IHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gIH1cbiAgaWYgKHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgYENvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLmAsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICBjb25zdCB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVHZXR0ZXJJbnZva2VyKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdGhpcylcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgY29uc3QgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgYE1ldGhvZCBcIiR7a2V5fVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgbWV0aG9kc1trZXldfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gYCArXG4gICAgICAgICAgYERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YCxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBNZXRob2QgXCIke2tleX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLmAsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBgTWV0aG9kIFwiJHtrZXl9XCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gYCArXG4gICAgICAgICAgYEF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gdHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJyA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHdhdGNoKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgY29uc3QgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgY29uc3QgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oYCRwcm9wcyBpcyByZWFkb25seS5gLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICBjb25zdCB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCBgY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSB3YXRjaGVyIFwiJHt3YXRjaGVyLmV4cHJlc3Npb259XCJgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxubGV0IHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICBsZXQgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gYHZ1ZS1wZXJmLXN0YXJ0OiR7dm0uX3VpZH1gO1xuICAgICAgZW5kVGFnID0gYHZ1ZS1wZXJmLWVuZDoke3ZtLl91aWR9YDtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoYHZ1ZSAke3ZtLl9uYW1lfSBpbml0YCwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICBjb25zdCBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuXG4gIGNvbnN0IHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgbGV0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgY29uc3Qgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICBjb25zdCBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICBjb25zdCBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgbGV0IG1vZGlmaWVkO1xuICBjb25zdCBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIGNvbnN0IHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yIChjb25zdCBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgbW9kaWZpZWQgPSB7fTtcbiAgICAgIG1vZGlmaWVkW2tleV0gPSBsYXRlc3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIFZ1ZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVnVlKVxuICApIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSk7XG5zdGF0ZU1peGluKFZ1ZSk7XG5ldmVudHNNaXhpbihWdWUpO1xubGlmZWN5Y2xlTWl4aW4oVnVlKTtcbnJlbmRlck1peGluKFZ1ZSk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIGNvbnN0IGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICBsZXQgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IFN1cGVyID0gdGhpcztcbiAgICBjb25zdCBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIGNvbnN0IGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICBjb25zdCBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgYF9wcm9wc2AsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgY29uc3QgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICBjb25zdCB7IGNhY2hlLCBrZXlzLCBfdm5vZGUgfSA9IGtlZXBBbGl2ZUluc3RhbmNlO1xuICBmb3IgKGNvbnN0IGtleSBpbiBjYWNoZSkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIGNvbnN0IGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxuY29uc3QgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZCAoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCB2YWwgPT4ge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBuYW1lID0+IG1hdGNoZXModmFsLCBuYW1lKSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCB2YWwgPT4ge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBuYW1lID0+ICFtYXRjaGVzKHZhbCwgbmFtZSkpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlciAoKSB7XG4gICAgY29uc3Qgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgY29uc3Qgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIGNvbnN0IGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGNvbnN0IHsgaW5jbHVkZSwgZXhjbHVkZSB9ID0gdGhpcztcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBjYWNoZSwga2V5cyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gYDo6JHtjb21wb25lbnRPcHRpb25zLnRhZ31gIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgY29uc3QgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSAoKSA9PiBjb25maWc7XG4gIHtcbiAgICBjb25maWdEZWYuc2V0ID0gKCkgPT4ge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2FybixcbiAgICBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICBWdWUub2JzZXJ2YWJsZSA9IChvYmopID0+IHtcbiAgICBvYnNlcnZlKG9iaik7XG4gICAgcmV0dXJuIG9ialxuICB9O1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG4vLyBleHBvc2UgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgZm9yIHNzciBydW50aW1lIGhlbHBlciBpbnN0YWxsYXRpb25cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblxuVnVlLnZlcnNpb24gPSAnMi42LjYnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbmNvbnN0IGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xuY29uc3QgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0LHByb2dyZXNzJyk7XG5jb25zdCBtdXN0VXNlUHJvcCA9ICh0YWcsIHR5cGUsIGF0dHIpID0+IHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG5jb25zdCBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbmNvbnN0IGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcblxuY29uc3QgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgID8gJ2ZhbHNlJ1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6ICd0cnVlJ1xufTtcblxuY29uc3QgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbmNvbnN0IHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbmNvbnN0IGlzWGxpbmsgPSAobmFtZSkgPT4ge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG5jb25zdCBnZXRYbGlua1Byb3AgPSAobmFtZSkgPT4ge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbmNvbnN0IGlzRmFsc3lBdHRyVmFsdWUgPSAodmFsKSA9PiB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgbGV0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICBsZXQgcGFyZW50Tm9kZSA9IHZub2RlO1xuICBsZXQgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIGxldCByZXMgPSAnJztcbiAgbGV0IHN0cmluZ2lmaWVkO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSByZXMgKz0gJyAnO1xuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSByZXMgKz0gJyAnO1xuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuY29uc3QgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxuY29uc3QgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG5jb25zdCBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG5jb25zdCBpc1ByZVRhZyA9ICh0YWcpID0+IHRhZyA9PT0gJ3ByZSc7XG5cbmNvbnN0IGlzUmVzZXJ2ZWRUYWcgPSAodGFnKSA9PiB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG5jb25zdCB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxuY29uc3QgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICBjb25zdCBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cbnZhciBub2RlT3BzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG4gIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICB0YWdOYW1lOiB0YWdOYW1lLFxuICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG4gIHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgY29uc3Qga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgcmV0dXJuXG5cbiAgY29uc3Qgdm0gPSB2bm9kZS5jb250ZXh0O1xuICBjb25zdCByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIGNvbnN0IHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbmNvbnN0IGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxuY29uc3QgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgcmV0dXJuIHRydWVcbiAgbGV0IGk7XG4gIGNvbnN0IHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgY29uc3QgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgbGV0IGksIGtleTtcbiAgY29uc3QgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSBtYXBba2V5XSA9IGk7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIGxldCBpLCBqO1xuICBjb25zdCBjYnMgPSB7fTtcblxuICBjb25zdCB7IG1vZHVsZXMsIG5vZGVPcHMgfSA9IGJhY2tlbmQ7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIGNvbnN0IHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShpZ25vcmUgPT4ge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICBsZXQgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGNvbnN0IHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgbGV0IGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgY29uc3QgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBsZXQgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgbGV0IGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAobm9kZU9wcy5wYXJlbnROb2RlKHJlZiQkMSkgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuICAgIGxldCBpLCBqO1xuICAgIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSBpKHZub2RlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgY2JzLmRlc3Ryb3lbaV0odm5vZGUpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVWbm9kZXMgKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY29uc3QgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgbGV0IGk7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGxldCBvbGRTdGFydElkeCA9IDA7XG4gICAgbGV0IG5ld1N0YXJ0SWR4ID0gMDtcbiAgICBsZXQgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICBsZXQgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIGxldCBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgbGV0IG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgbGV0IG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICBsZXQgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIGxldCBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICBjb25zdCBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICBjb25zdCBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICcke2tleX0nLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuYCxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgIG9sZFZub2RlLFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4LFxuICAgIHJlbW92ZU9ubHlcbiAgKSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGk7XG4gICAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgY29uc3QgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gIGNvbnN0IGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHsgdGFnLCBkYXRhLCBjaGlsZHJlbiB9ID0gdm5vZGU7XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTtcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBsZXQgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICBjb25zdCBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICBjb25zdCBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIGNvbnN0IHBhcmVudEVsbSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIGxldCBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICBjb25zdCBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgIGNvbnN0IGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2ldKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0pKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3QgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICBjb25zdCBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuICBjb25zdCBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIGNvbnN0IG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICBjb25zdCBkaXJzV2l0aEluc2VydCA9IFtdO1xuICBjb25zdCBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIGxldCBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICBjb25zdCBjYWxsSW5zZXJ0ID0gKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIGNvbnN0IHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICBsZXQgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCBgJHtkaXIubmFtZX0uJHtPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJyl9YFxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIGNvbnN0IGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCBgZGlyZWN0aXZlICR7ZGlyLm5hbWV9ICR7aG9va30gaG9va2ApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgY29uc3Qgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIGxldCBrZXksIGN1ciwgb2xkO1xuICBjb25zdCBlbG0gPSB2bm9kZS5lbG07XG4gIGNvbnN0IG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgbGV0IGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICgoaXNJRSB8fCBpc0VkZ2UpICYmIGF0dHJzLnZhbHVlICE9PSBvbGRBdHRycy52YWx1ZSkge1xuICAgIHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgfSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgY29udmVydEVudW1lcmF0ZWRWYWx1ZShrZXksIHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgdmFsdWUgIT09ICcnICYmICFlbC5fX2llcGhcbiAgICApIHtcbiAgICAgIGNvbnN0IGJsb2NrZXIgPSBlID0+IHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIH07XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGNvbnN0IGVsID0gdm5vZGUuZWxtO1xuICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgY29uc3Qgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gIGlmIChcbiAgICBpc1VuZGVmKGRhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG4gICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vKiAgKi9cblxuY29uc3QgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgbGV0IGluU2luZ2xlID0gZmFsc2U7XG4gIGxldCBpbkRvdWJsZSA9IGZhbHNlO1xuICBsZXQgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICBsZXQgaW5SZWdleCA9IGZhbHNlO1xuICBsZXQgY3VybHkgPSAwO1xuICBsZXQgc3F1YXJlID0gMDtcbiAgbGV0IHBhcmVuID0gMDtcbiAgbGV0IGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIGxldCBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSBpblNpbmdsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIGluRG91YmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVDKSBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSBpblJlZ2V4ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICBsZXQgaiA9IGkgLSAxO1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICBjb25zdCBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gYF9mKFwiJHtmaWx0ZXJ9XCIpKCR7ZXhwfSlgXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICBjb25zdCBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gYF9mKFwiJHtuYW1lfVwiKSgke2V4cH0ke2FyZ3MgIT09ICcpJyA/ICcsJyArIGFyZ3MgOiBhcmdzfWBcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5mdW5jdGlvbiBiYXNlV2FybiAobXNnLCByYW5nZSkge1xuICBjb25zb2xlLmVycm9yKGBbVnVlIGNvbXBpbGVyXTogJHttc2d9YCk7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAobSA9PiBtW2tleV0pLmZpbHRlcihfID0+IF8pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZSwgdmFsdWUsIGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICBjb25zdCBhdHRycyA9IGR5bmFtaWNcbiAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICA6IChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpO1xuICBhdHRycy5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWUsIHZhbHVlLCBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lLCB2YWx1ZSB9LCByYW5nZSkpO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgaXNEeW5hbWljQXJnLFxuICBtb2RpZmllcnMsXG4gIHJhbmdlXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICBuYW1lLFxuICAgIHJhd05hbWUsXG4gICAgdmFsdWUsXG4gICAgYXJnLFxuICAgIGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnNcbiAgfSwgcmFuZ2UpKTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgcmV0dXJuIGR5bmFtaWNcbiAgICA/IGBfcCgke25hbWV9LFwiJHtzeW1ib2x9XCIpYFxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJyxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cbiAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gYCgke25hbWV9KT09PSdjbGljayc/J2NvbnRleHRtZW51JzooJHtuYW1lfSlgO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgIG5hbWUgPSBgKCR7bmFtZX0pPT09J2NsaWNrJz8nbW91c2V1cCc6KCR7bmFtZX0pYDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICB9XG4gIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCd+JywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cblxuICBsZXQgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG5cbiAgY29uc3QgbmV3SGFuZGxlciA9IHJhbmdlU2V0SXRlbSh7IHZhbHVlOiB2YWx1ZS50cmltKCksIGR5bmFtaWMgfSwgcmFuZ2UpO1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgY29uc3QgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSYXdCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lXG4pIHtcbiAgcmV0dXJuIGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICBlbC5yYXdBdHRyc01hcFtuYW1lXVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICBjb25zdCBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICBjb25zdCBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIGxldCB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXggKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBhdHRyID0gbGlzdFtpXTtcbiAgICBpZiAobmFtZS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuIGF0dHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmFuZ2VTZXRJdGVtIChcbiAgaXRlbSxcbiAgcmFuZ2Vcbikge1xuICBpZiAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICBjb25zdCB7IG51bWJlciwgdHJpbSB9ID0gbW9kaWZpZXJzIHx8IHt9O1xuXG4gIGNvbnN0IGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgbGV0IHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIGAodHlwZW9mICR7YmFzZVZhbHVlRXhwcmVzc2lvbn0gPT09ICdzdHJpbmcnYCArXG4gICAgICBgPyAke2Jhc2VWYWx1ZUV4cHJlc3Npb259LnRyaW0oKWAgK1xuICAgICAgYDogJHtiYXNlVmFsdWVFeHByZXNzaW9ufSlgO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBgX24oJHt2YWx1ZUV4cHJlc3Npb259KWA7XG4gIH1cbiAgY29uc3QgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiBgKCR7dmFsdWV9KWAsXG4gICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICAgIGNhbGxiYWNrOiBgZnVuY3Rpb24gKCR7YmFzZVZhbHVlRXhwcmVzc2lvbn0pIHske2Fzc2lnbm1lbnR9fWBcbiAgfTtcbn1cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuICB2YWx1ZSxcbiAgYXNzaWdubWVudFxuKSB7XG4gIGNvbnN0IHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBgJHt2YWx1ZX09JHthc3NpZ25tZW50fWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCRzZXQoJHtyZXMuZXhwfSwgJHtyZXMua2V5fSwgJHthc3NpZ25tZW50fSlgXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbmxldCBsZW4sIHN0ciwgY2hyLCBpbmRleCQxLCBleHByZXNzaW9uUG9zLCBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcbiAgdmFsID0gdmFsLnRyaW0oKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgaW5kZXgkMSA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4JDEpLFxuICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbCxcbiAgICAgICAga2V5OiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyID0gdmFsO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICBsZXQgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIGluQnJhY2tldCsrO1xuICAgIGlmIChjaHIgPT09IDB4NUQpIGluQnJhY2tldC0tO1xuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICBjb25zdCBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmxldCB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG5jb25zdCBSQU5HRV9UT0tFTiA9ICdfX3InO1xuY29uc3QgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICBjb25zdCB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgY29uc3QgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgY29uc3QgdGFnID0gZWwudGFnO1xuICBjb25zdCB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIiB0eXBlPVwiZmlsZVwiPjpcXG5gICtcbiAgICAgICAgYEZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgd2FybiQxKFxuICAgICAgYDwke2VsLnRhZ30gdi1tb2RlbD1cIiR7dmFsdWV9XCI+OiBgICtcbiAgICAgIGB2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIGAgK1xuICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgJ3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJyxcbiAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICBjb25zdCB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICBjb25zdCB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICBjb25zdCBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgYEFycmF5LmlzQXJyYXkoJHt2YWx1ZX0pYCArXG4gICAgYD9faSgke3ZhbHVlfSwke3ZhbHVlQmluZGluZ30pPi0xYCArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IGA6KCR7dmFsdWV9KWBcbiAgICAgICAgOiBgOl9xKCR7dmFsdWV9LCR7dHJ1ZVZhbHVlQmluZGluZ30pYFxuICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgYHZhciAkJGE9JHt2YWx1ZX0sYCArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIGAkJGM9JCRlbC5jaGVja2VkPygke3RydWVWYWx1ZUJpbmRpbmd9KTooJHtmYWxzZVZhbHVlQmluZGluZ30pO2AgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgYHZhciAkJHY9JHtudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZ30sYCArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIGBpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoJHtnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJyl9KX1gICtcbiAgICAgIGBlbHNleyQkaT4tMSYmKCR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKScpfSl9YCArXG4gICAgYH1lbHNleyR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKX19YCxcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGNvbnN0IG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICBsZXQgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gYF9uKCR7dmFsdWVCaW5kaW5nfSlgIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIGBfcSgke3ZhbHVlfSwke3ZhbHVlQmluZGluZ30pYCk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIGNvbnN0IHNlbGVjdGVkVmFsID0gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgICtcbiAgICBgLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlgICtcbiAgICBgLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXCJfdmFsdWVcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO2AgK1xuICAgIGByZXR1cm4gJHtudW1iZXIgPyAnX24odmFsKScgOiAndmFsJ319KWA7XG5cbiAgY29uc3QgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICBsZXQgY29kZSA9IGB2YXIgJCRzZWxlY3RlZFZhbCA9ICR7c2VsZWN0ZWRWYWx9O2A7XG4gIGNvZGUgPSBgJHtjb2RlfSAke2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KX1gO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgY29uc3QgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gIHtcbiAgICBjb25zdCB2YWx1ZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XG4gICAgY29uc3QgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICBpZiAodmFsdWUgJiYgIXR5cGVCaW5kaW5nKSB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcbiAgICAgIHdhcm4kMShcbiAgICAgICAgYCR7YmluZGluZ309XCIke3ZhbHVlfVwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBgICtcbiAgICAgICAgJ2JlY2F1c2UgdGhlIGxhdHRlciBhbHJlYWR5IGV4cGFuZHMgdG8gYSB2YWx1ZSBiaW5kaW5nIGludGVybmFsbHknLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFtiaW5kaW5nXVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB7IGxhenksIG51bWJlciwgdHJpbSB9ID0gbW9kaWZpZXJzIHx8IHt9O1xuICBjb25zdCBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIGNvbnN0IGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICBsZXQgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IGAkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKWA7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IGBfbigke3ZhbHVlRXhwcmVzc2lvbn0pYDtcbiAgfVxuXG4gIGxldCBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBgaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuOyR7Y29kZX1gO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgYCgke3ZhbHVlfSlgKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgY29uc3QgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG5sZXQgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICBjb25zdCByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gIzk0NDY6IEZpcmVmb3ggPD0gNTMgKGluIHBhcnRpY3VsYXIsIEVTUiA1MikgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXBcbi8vIGltcGxlbWVudGF0aW9uIGFuZCBkb2VzIG5vdCBmaXJlIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbiwgc29cbi8vIHNhZmUgdG8gZXhjbHVkZS5cbmNvbnN0IHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gIGlmICh1c2VNaWNyb3Rhc2tGaXgpIHtcbiAgICBjb25zdCBhdHRhY2hlZFRpbWVzdGFtcCA9IGN1cnJlbnRGbHVzaFRpbWVzdGFtcDtcbiAgICBjb25zdCBvcmlnaW5hbCA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IG9yaWdpbmFsLl93cmFwcGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cbiAgICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgc2FmZXR5IG5ldCBpbiBjYXNlIGV2ZW50LnRpbWVTdGFtcCBpcyB1bnJlbGlhYmxlIGluXG4gICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXG4gICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcbiAgICAgICAgLy8gZXZlbnQgaXMgZmlyZWQgYWZ0ZXIgaGFuZGxlciBhdHRhY2htZW50XG4gICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgIC8vICM5NDYyIGJhaWwgZm9yIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgZS50aW1lU3RhbXAgPT09IDAgfHxcbiAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAvLyBlbGVjdHJvbi9udy5qcyBhcHAsIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCB3aWxsIGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlLCBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIuX3dyYXBwZXIgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIGNvbnN0IG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgY3JlYXRlT25jZUhhbmRsZXIkMSwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5sZXQgc3ZnQ29udGFpbmVyO1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsZXQga2V5LCBjdXI7XG4gIGNvbnN0IGVsbSA9IHZub2RlLmVsbTtcbiAgY29uc3Qgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICBsZXQgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKGlzVW5kZWYocHJvcHNba2V5XSkpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSBjb250aW51ZVxuICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZWxtLnJlbW92ZUNoaWxkKGVsbS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAvLyB0aGUgb25seSBleGNlcHRpb24gaXMgYHZhbHVlYCB3aGVyZSB0aGUgRE9NIHZhbHVlIG1heSBiZSB0ZW1wb3JhcmlseVxuICAgIC8vIG91dCBvZiBzeW5jIHdpdGggVkRPTSBzdGF0ZSBkdWUgdG8gZm9jdXMsIGNvbXBvc2l0aW9uIGFuZCBtb2RpZmllcnMuXG4gICAgLy8gVGhpcyBhbHNvIGNvdmVycyAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc2FycnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICBpZiAoa2V5ICE9PSAndmFsdWUnICYmIGN1ciA9PT0gb2xkUHJvcHNba2V5XSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgY29uc3Qgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaW5uZXJIVE1MJyAmJiBpc1NWRyhlbG0udGFnTmFtZSkgJiYgaXNVbmRlZihlbG0uaW5uZXJIVE1MKSkge1xuICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGlubmVySFRNTCBmb3IgU1ZHIGVsZW1lbnRzXG4gICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gYDxzdmc+JHtjdXJ9PC9zdmc+YDtcbiAgICAgIGNvbnN0IHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtW2tleV0gPSBjdXI7XG4gICAgfVxuICB9XG59XG5cbi8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChlbG0sIGNoZWNrVmFsKSB7XG4gIHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNOb3RJbkZvY3VzQW5kRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAvLyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgbGV0IG5vdEluRm9jdXMgPSB0cnVlO1xuICAvLyAjNjE1N1xuICAvLyB3b3JrIGFyb3VuZCBJRSBidWcgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbiBhbiBpZnJhbWVcbiAgdHJ5IHsgbm90SW5Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbTsgfSBjYXRjaCAoZSkge31cbiAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyAoZWxtLCBuZXdWYWwpIHtcbiAgY29uc3QgdmFsdWUgPSBlbG0udmFsdWU7XG4gIGNvbnN0IG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVycy50cmltKSB7XG4gICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbmNvbnN0IHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBjb25zdCBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgY29uc3QgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgY29uc3Qgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBsZXQgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgbGV0IGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICBsZXQgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmNvbnN0IGNzc1ZhclJFID0gL14tLS87XG5jb25zdCBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuY29uc3Qgc2V0UHJvcCA9IChlbCwgbmFtZSwgdmFsKSA9PiB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKG5hbWUpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG5sZXQgZW1wdHlTdHlsZTtcbmNvbnN0IG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIGNvbnN0IGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGNvbnN0IGRhdGEgPSB2bm9kZS5kYXRhO1xuICBjb25zdCBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGN1ciwgbmFtZTtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gIGNvbnN0IG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgY29uc3Qgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICBjb25zdCBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICBjb25zdCBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICBjb25zdCBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuY29uc3Qgd2hpdGVzcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChjID0+IGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGN1ciA9IGAgJHtlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyd9IGA7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goYyA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGN1ciA9IGAgJHtlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyd9IGA7XG4gICAgY29uc3QgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG5jb25zdCBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChuYW1lID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiBgJHtuYW1lfS1lbnRlcmAsXG4gICAgZW50ZXJUb0NsYXNzOiBgJHtuYW1lfS1lbnRlci10b2AsXG4gICAgZW50ZXJBY3RpdmVDbGFzczogYCR7bmFtZX0tZW50ZXItYWN0aXZlYCxcbiAgICBsZWF2ZUNsYXNzOiBgJHtuYW1lfS1sZWF2ZWAsXG4gICAgbGVhdmVUb0NsYXNzOiBgJHtuYW1lfS1sZWF2ZS10b2AsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogYCR7bmFtZX0tbGVhdmUtYWN0aXZlYFxuICB9XG59KTtcblxuY29uc3QgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG5jb25zdCBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuY29uc3QgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmxldCB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbmxldCB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG5sZXQgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xubGV0IGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG5jb25zdCByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZuID0+IGZuKCk7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKCgpID0+IHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIGlmICghdHlwZSkgcmV0dXJuIGNiKClcbiAgY29uc3QgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIGxldCBlbmRlZCA9IDA7XG4gIGNvbnN0IGVuZCA9ICgpID0+IHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgY29uc3Qgb25FbmQgPSBlID0+IHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbmNvbnN0IHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gIGNvbnN0IHRyYW5zaXRpb25EZWxheXMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xuICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICBjb25zdCBhbmltYXRpb25EZWxheXMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIGNvbnN0IGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIGxldCB0eXBlO1xuICBsZXQgdGltZW91dCA9IDA7XG4gIGxldCBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgY29uc3QgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICB0aW1lb3V0LFxuICAgIHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4ge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4vLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICBjb25zdCBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qge1xuICAgIGNzcyxcbiAgICB0eXBlLFxuICAgIGVudGVyQ2xhc3MsXG4gICAgZW50ZXJUb0NsYXNzLFxuICAgIGVudGVyQWN0aXZlQ2xhc3MsXG4gICAgYXBwZWFyQ2xhc3MsXG4gICAgYXBwZWFyVG9DbGFzcyxcbiAgICBhcHBlYXJBY3RpdmVDbGFzcyxcbiAgICBiZWZvcmVFbnRlcixcbiAgICBlbnRlcixcbiAgICBhZnRlckVudGVyLFxuICAgIGVudGVyQ2FuY2VsbGVkLFxuICAgIGJlZm9yZUFwcGVhcixcbiAgICBhcHBlYXIsXG4gICAgYWZ0ZXJBcHBlYXIsXG4gICAgYXBwZWFyQ2FuY2VsbGVkLFxuICAgIGR1cmF0aW9uXG4gIH0gPSBkYXRhO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICBsZXQgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICBsZXQgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIGNvbnN0IGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIGNvbnN0IGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICBjb25zdCB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIGNvbnN0IGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIGNvbnN0IGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIGNvbnN0IGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgY29uc3QgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICBjb25zdCBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAoZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgY29uc3QgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICBjb25zdCB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIGNvbnN0IGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKCgpID0+IHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgY29uc3QgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3Qge1xuICAgIGNzcyxcbiAgICB0eXBlLFxuICAgIGxlYXZlQ2xhc3MsXG4gICAgbGVhdmVUb0NsYXNzLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3MsXG4gICAgYmVmb3JlTGVhdmUsXG4gICAgbGVhdmUsXG4gICAgYWZ0ZXJMZWF2ZSxcbiAgICBsZWF2ZUNhbmNlbGxlZCxcbiAgICBkZWxheUxlYXZlLFxuICAgIGR1cmF0aW9uXG4gIH0gPSBkYXRhO1xuXG4gIGNvbnN0IGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgY29uc3QgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIGNvbnN0IGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIGNvbnN0IGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKCgpID0+IHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBgPHRyYW5zaXRpb24+IGV4cGxpY2l0ICR7bmFtZX0gZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXG4gICAgICBgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgYDx0cmFuc2l0aW9uPiBleHBsaWNpdCAke25hbWV9IGR1cmF0aW9uIGlzIE5hTiAtIGAgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBjb25zdCBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG5jb25zdCBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbmNvbnN0IHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHMsIG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCAoKSA9PiB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gIzY5MDNcbiAgICAgIGlmIChvbGRWbm9kZS5lbG0gJiYgIW9sZFZub2RlLmVsbS5fdk9wdGlvbnMpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCAoKSA9PiB7XG4gICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICBlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuICAgICAgaWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG4gICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxuICAgICAgICAvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICBjb25zdCBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIGNvbnN0IGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKChvLCBpKSA9PiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSkpKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIGNvbnN0IG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUodiA9PiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpKVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBjb25zdCB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIGNvbnN0IGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XCIke2JpbmRpbmcuZXhwcmVzc2lvbn1cIj4gYCArXG4gICAgICBgZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgJHtcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbiAgICAgIH1gLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGxldCBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShvID0+ICFsb29zZUVxdWFsKG8sIHZhbHVlKSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHJldHVyblxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcbmZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG4gIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICA/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuICAgIDogdm5vZGVcbn1cblxudmFyIHNob3cgPSB7XG4gIGJpbmQgKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgY29uc3Qgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCAoKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGUgKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB2bm9kZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSkgcmV0dXJuXG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsICgpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCAoKSA9PiB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3dcbn07XG5cbi8qICAqL1xuXG5jb25zdCB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIGNvbnN0IGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG4gIGNvbnN0IGRhdGEgPSB7fTtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMucHJvcHNEYXRhKSB7XG4gICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICB9XG4gIC8vIGV2ZW50cy5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gIGNvbnN0IGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yIChjb25zdCBrZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkpXSA9IGxpc3RlbmVyc1trZXldO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxuY29uc3QgaXNOb3RUZXh0Tm9kZSA9IChjKSA9PiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7XG5cbmNvbnN0IGlzVlNob3dEaXJlY3RpdmUgPSBkID0+IGQubmFtZSA9PT0gJ3Nob3cnO1xuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXIgKGgpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIGNvbnN0IGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICBjb25zdCBpZCA9IGBfX3RyYW5zaXRpb24tJHt0aGlzLl91aWR9LWA7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgY29uc3QgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIGNvbnN0IG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgY29uc3Qgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIGNvbnN0IG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4geyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGxlYXZlID0+IHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuY29uc3QgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wcyxcblxuICBiZWZvcmVNb3VudCAoKSB7XG4gICAgY29uc3QgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgIHRoaXMuX3VwZGF0ZSA9ICh2bm9kZSwgaHlkcmF0aW5nKSA9PiB7XG4gICAgICBjb25zdCByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgICB0aGlzLl92bm9kZSxcbiAgICAgICAgdGhpcy5rZXB0LFxuICAgICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgKTtcbiAgICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICB1cGRhdGUuY2FsbCh0aGlzLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9LFxuXG4gIHJlbmRlciAoaCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICBjb25zdCByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgY29uc3QgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKGA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPCR7bmFtZX0+YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBrZXB0ID0gW107XG4gICAgICBjb25zdCByZW1vdmVkID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJldkNoaWxkcmVuW2ldO1xuICAgICAgICBjLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjLmRhdGEucG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYy5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIHVwZGF0ZWQgKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgY29uc3QgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgY29uc3QgZWwgPSBjLmVsbTtcbiAgICAgICAgY29uc3QgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKGUgJiYgZS50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKChjbHMpID0+IHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgY29uc3QgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICBjb25zdCBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICBjb25zdCBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICBjb25zdCBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgY29uc3QgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIGBZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuYCArXG4gICAgICAgIGBNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuYCArXG4gICAgICAgIGBTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbGBcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbmNvbnN0IGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xuY29uc3QgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbmNvbnN0IGJ1aWxkUmVnZXggPSBjYWNoZWQoZGVsaW1pdGVycyA9PiB7XG4gIGNvbnN0IG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICBjb25zdCBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICBjb25zdCB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xuICBpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgY29uc3QgcmF3VG9rZW5zID0gW107XG4gIGxldCBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICBsZXQgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICBjb25zdCBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaChgX3MoJHtleHB9KWApO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgY29uc3Qgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgY29uc3QgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBjbGFzcz1cIiR7c3RhdGljQ2xhc3N9XCI6IGAgK1xuICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnY2xhc3MnXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgY29uc3QgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgbGV0IGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBgc3RhdGljQ2xhc3M6JHtlbC5zdGF0aWNDbGFzc30sYDtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBgY2xhc3M6JHtlbC5jbGFzc0JpbmRpbmd9LGA7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgY29uc3Qgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgY29uc3Qgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgY29uc3QgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGBzdHlsZT1cIiR7c3RhdGljU3R5bGV9XCI6IGAgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIGNvbnN0IHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgbGV0IGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBgc3RhdGljU3R5bGU6JHtlbC5zdGF0aWNTdHlsZX0sYDtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBgc3R5bGU6KCR7ZWwuc3R5bGVCaW5kaW5nfSksYDtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbmxldCBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZSAoaHRtbCkge1xuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICB9XG59O1xuXG4vKiAgKi9cblxuY29uc3QgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG5jb25zdCBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbmNvbnN0IGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG5jb25zdCBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbmNvbnN0IGR5bmFtaWNBcmdBdHRyaWJ1dGUgPSAvXlxccyooKD86di1bXFx3LV0rOnxAfDp8IylcXFtbXj1dK1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG5jb25zdCBuY25hbWUgPSBgW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aJHt1bmljb2RlTGV0dGVyc31dKmA7XG5jb25zdCBxbmFtZUNhcHR1cmUgPSBgKCg/OiR7bmNuYW1lfVxcXFw6KT8ke25jbmFtZX0pYDtcbmNvbnN0IHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoYF48JHtxbmFtZUNhcHR1cmV9YCk7XG5jb25zdCBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG5jb25zdCBlbmRUYWcgPSBuZXcgUmVnRXhwKGBePFxcXFwvJHtxbmFtZUNhcHR1cmV9W14+XSo+YCk7XG5jb25zdCBkb2N0eXBlID0gL148IURPQ1RZUEUgW14+XSs+L2k7XG4vLyAjNzI5ODogZXNjYXBlIC0gdG8gYXZvaWQgYmVpbmcgcGFzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG5jb25zdCBjb21tZW50ID0gL148IVxcLS0vO1xuY29uc3QgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxuY29uc3QgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG5jb25zdCByZUNhY2hlID0ge307XG5cbmNvbnN0IGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nLFxuICAnJiM5Oyc6ICdcXHQnLFxuICAnJiMzOTsnOiBcIidcIlxufTtcbmNvbnN0IGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xuY29uc3QgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nO1xuXG4vLyAjNTk5MlxuY29uc3QgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG5jb25zdCBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSAodGFnLCBodG1sKSA9PiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICBjb25zdCByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIG1hdGNoID0+IGRlY29kaW5nTWFwW21hdGNoXSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGNvbnN0IGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIGNvbnN0IGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIGNvbnN0IGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIGxldCB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgY29uc3QgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgY29uc3QgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICBjb25zdCBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgY29uc3QgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIGNvbnN0IGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCB0ZXh0LCByZXN0LCBuZXh0O1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSBicmVha1xuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgYWR2YW5jZSh0ZXh0Lmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0LCBpbmRleCAtIHRleHQubGVuZ3RoLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgY29uc3Qgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIGNvbnN0IHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgY29uc3QgcmVzdCA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICBodG1sID0gcmVzdDtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmICghc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oYE1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXCIke2h0bWx9XCJgLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICBjb25zdCBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICBsZXQgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIGNvbnN0IHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIGNvbnN0IGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgY29uc3QgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICBjb25zdCBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgPyBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZlxuICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogYXJnc1sxXSxcbiAgICAgICAgdmFsdWU6IGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gYXJncy5zdGFydCArIGFyZ3NbMF0ubWF0Y2goL15cXHMqLykubGVuZ3RoO1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICBzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycywgc3RhcnQ6IG1hdGNoLnN0YXJ0LCBlbmQ6IG1hdGNoLmVuZCB9KTtcbiAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkgc3RhcnQgPSBpbmRleDtcbiAgICBpZiAoZW5kID09IG51bGwpIGVuZCA9IGluZGV4O1xuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcbiAgICBpZiAodGFnTmFtZSkge1xuICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKGkgPiBwb3MgfHwgIXRhZ05hbWUgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgYHRhZyA8JHtzdGFja1tpXS50YWd9PiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5gLFxuICAgICAgICAgICAgeyBzdGFydDogc3RhY2tbaV0uc3RhcnQgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuY29uc3Qgb25SRSA9IC9eQHxedi1vbjovO1xuY29uc3QgZGlyUkUgPSAvXnYtfF5AfF46LztcbmNvbnN0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG5jb25zdCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuY29uc3Qgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcbmNvbnN0IGR5bmFtaWNBcmdSRSA9IC9eXFxbLipcXF0kLztcblxuY29uc3QgYXJnUkUgPSAvOiguKikkLztcbmNvbnN0IGJpbmRSRSA9IC9eOnxeXFwufF52LWJpbmQ6LztcbmNvbnN0IG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxuY29uc3Qgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XG5cbmNvbnN0IGxpbmVCcmVha1JFID0gL1tcXHJcXG5dLztcbmNvbnN0IHdoaXRlc3BhY2VSRSQxID0gL1xccysvZztcblxuY29uc3QgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcblxuY29uc3QgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG5jb25zdCBlbXB0eVNsb3RTY29wZVRva2VuID0gYF9lbXB0eV9gO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbmxldCB3YXJuJDI7XG5sZXQgZGVsaW1pdGVycztcbmxldCB0cmFuc2Zvcm1zO1xubGV0IHByZVRyYW5zZm9ybXM7XG5sZXQgcG9zdFRyYW5zZm9ybXM7XG5sZXQgcGxhdGZvcm1Jc1ByZVRhZztcbmxldCBwbGF0Zm9ybU11c3RVc2VQcm9wO1xubGV0IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xubGV0IG1heWJlQ29tcG9uZW50O1xuXG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgdGFnLFxuICBhdHRycyxcbiAgcGFyZW50XG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxLFxuICAgIHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICBwYXJlbnQsXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIGNvbnN0IGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIG1heWJlQ29tcG9uZW50ID0gKGVsKSA9PiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpO1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIGNvbnN0IHN0YWNrID0gW107XG4gIGNvbnN0IHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgY29uc3Qgd2hpdGVzcGFjZU9wdGlvbiA9IG9wdGlvbnMud2hpdGVzcGFjZTtcbiAgbGV0IHJvb3Q7XG4gIGxldCBjdXJyZW50UGFyZW50O1xuICBsZXQgaW5WUHJlID0gZmFsc2U7XG4gIGxldCBpblByZSA9IGZhbHNlO1xuICBsZXQgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZywgcmFuZ2UpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2csIHJhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgaWYgKCFzdGFjay5sZW5ndGggJiYgZWxlbWVudCAhPT0gcm9vdCkge1xuICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBgQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gYCArXG4gICAgICAgICAgYElmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgYCArXG4gICAgICAgICAgYHVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLmAsXG4gICAgICAgICAgeyBzdGFydDogZWxlbWVudC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgLy8gc2NvcGVkIHNsb3RcbiAgICAgICAgICAvLyBrZWVwIGl0IGluIHRoZSBjaGlsZHJlbiBsaXN0IHNvIHRoYXQgdi1lbHNlKC1pZikgY29uZGl0aW9ucyBjYW5cbiAgICAgICAgICAvLyBmaW5kIGl0IGFzIHRoZSBwcmV2IG5vZGUuXG4gICAgICAgICAgY29uc3QgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnBhcmVudCA9IGN1cnJlbnRQYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluYWwgY2hpbGRyZW4gY2xlYW51cFxuICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGMgPT4gIShjKS5zbG90U2NvcGUpO1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGUgYWdhaW5cbiAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcblxuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UgKGVsKSB7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZVxuICAgIGlmICghaW5QcmUpIHtcbiAgICAgIGxldCBsYXN0Tm9kZTtcbiAgICAgIHdoaWxlIChcbiAgICAgICAgKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgIGxhc3ROb2RlLnR5cGUgPT09IDMgJiZcbiAgICAgICAgbGFzdE5vZGUudGV4dCA9PT0gJyAnXG4gICAgICApIHtcbiAgICAgICAgZWwuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIGBDYW5ub3QgdXNlIDwke2VsLnRhZ30+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgYCArXG4gICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLicsXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgb3V0cHV0U291cmNlUmFuZ2U6IG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UsXG4gICAgc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5LCBzdGFydCkge1xuICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICBjb25zdCBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICBsZXQgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoKGN1bXVsYXRlZCwgYXR0cikgPT4ge1xuICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgcmV0dXJuIGN1bXVsYXRlZFxuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBhdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIGR5bmFtaWMgYXJndW1lbnQgZXhwcmVzc2lvbjogYXR0cmlidXRlIG5hbWVzIGNhbm5vdCBjb250YWluIGAgK1xuICAgICAgICAgICAgICBgc3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5gLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUuaW5kZXhPZihgW2ApLFxuICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIGA8JHt0YWd9PmAgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQgKHRhZywgc3RhcnQsIGVuZCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGVsZW1lbnQuZW5kID0gZW5kO1xuICAgICAgfVxuICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgeyBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICBgdGV4dCBcIiR7dGV4dH1cIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuYCxcbiAgICAgICAgICAgICAgeyBzdGFydCB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgfSBlbHNlIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAvLyBsaW5lIGJyZWFrLCBvdGhlcndpc2UgY29uZGVuc2UgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gbGluZUJyZWFrUkUudGVzdCh0ZXh0KSA/ICcnIDogJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgPSAnICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gY29uZGVuc2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZXMgaW50byBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQgKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIGFkZGluZyBhbnl0aW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHtcbiAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICBjb25zdCBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgaWYgKGxlbikge1xuICAgIGNvbnN0IGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogbGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgICBpZiAobGlzdFtpXS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgZWxlbWVudCxcbiAgb3B0aW9uc1xuKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAoXG4gICAgIWVsZW1lbnQua2V5ICYmXG4gICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoXG4gICk7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdE91dGxldChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIGNvbnN0IGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICB7XG4gICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBgPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLmAsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGVsLmZvcikge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIGBEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIGAgK1xuICAgICAgICAgICAgYHRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuYCxcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICB0cnVlIC8qIHRpcCAqL1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIGNvbnN0IHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICBsZXQgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIGNvbnN0IHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgaWYgKHJlcykge1xuICAgICAgZXh0ZW5kKGVsLCByZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGBJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246ICR7ZXhwfWAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICBjb25zdCBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHJldHVyblxuICBjb25zdCByZXMgPSB7fTtcbiAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICBjb25zdCBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICBjb25zdCBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgY29uc3QgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgaWYgKGV4cCkge1xuICAgIGVsLmlmID0gZXhwO1xuICAgIGFkZElmQ29uZGl0aW9uKGVsLCB7XG4gICAgICBleHA6IGV4cCxcbiAgICAgIGJsb2NrOiBlbFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgZWwuZWxzZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgY29uc3QgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuJDIoXG4gICAgICBgdi0ke2VsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJ30gYCArXG4gICAgICBgdXNlZCBvbiBlbGVtZW50IDwke2VsLnRhZ30+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLmAsXG4gICAgICBlbC5yYXdBdHRyc01hcFtlbC5lbHNlaWYgPyAndi1lbHNlLWlmJyA6ICd2LWVsc2UnXVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICBsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgYHRleHQgXCIke2NoaWxkcmVuW2ldLnRleHQudHJpbSgpfVwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgYCArXG4gICAgICAgICAgYHdpbGwgYmUgaWdub3JlZC5gLFxuICAgICAgICAgIGNoaWxkcmVuW2ldXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgaWYgKCFlbC5pZkNvbmRpdGlvbnMpIHtcbiAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgfVxuICBlbC5pZkNvbmRpdGlvbnMucHVzaChjb25kaXRpb24pO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgY29uc3Qgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbi8vIGhhbmRsZSBjb250ZW50IGJlaW5nIHBhc3NlZCB0byBhIGNvbXBvbmVudCBhcyBzbG90LFxuLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG5mdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQgKGVsKSB7XG4gIGxldCBzbG90U2NvcGU7XG4gIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoc2xvdFNjb3BlKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGB0aGUgXCJzY29wZVwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBgICtcbiAgICAgICAgYHJlcGxhY2VkIGJ5IFwic2xvdC1zY29wZVwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcInNsb3Qtc2NvcGVcIiBhdHRyaWJ1dGUgYCArXG4gICAgICAgIGBjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gYCArXG4gICAgICAgIGBkZW5vdGUgc2NvcGVkIHNsb3RzLmAsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYEFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8JHtlbC50YWd9PiBgICtcbiAgICAgICAgYCh2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBgICtcbiAgICAgICAgYHNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2xvdC1zY29wZSddLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGU7XG4gIH1cblxuICAvLyBzbG90PVwieHh4XCJcbiAgY29uc3Qgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICBpZiAoc2xvdFRhcmdldCkge1xuICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdzbG90JykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gIHtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgY29uc3Qgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGVsLnNsb3RUYXJnZXQgfHwgZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLmAsXG4gICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGA8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIGAgK1xuICAgICAgICAgICAgICBgdGhlIHJlY2VpdmluZyB0aGUgY29tcG9uZW50YCxcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZHluYW1pYyB9ID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmcpO1xuICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90QmluZGluZy52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuOyAvLyBmb3JjZSBpdCBpbnRvIGEgc2NvcGVkIHNsb3QgZm9yIHBlcmZcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdi1zbG90IG9uIGNvbXBvbmVudCwgZGVub3RlcyBkZWZhdWx0IHNsb3RcbiAgICAgIGNvbnN0IHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICBpZiAoc2xvdEJpbmRpbmcpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGB2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4uYCxcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zbG90U2NvcGUgfHwgZWwuc2xvdFRhcmdldCkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBgVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5gLFxuICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIGBUbyBhdm9pZCBzY29wZSBhbWJpZ3VpdHksIHRoZSBkZWZhdWx0IHNsb3Qgc2hvdWxkIGFsc28gdXNlIGAgK1xuICAgICAgICAgICAgICBgPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuYCxcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCB0aGUgY29tcG9uZW50J3MgY2hpbGRyZW4gdG8gaXRzIGRlZmF1bHQgc2xvdFxuICAgICAgICBjb25zdCBzbG90cyA9IGVsLnNjb3BlZFNsb3RzIHx8IChlbC5zY29wZWRTbG90cyA9IHt9KTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBkeW5hbWljIH0gPSBnZXRTbG90TmFtZShzbG90QmluZGluZyk7XG4gICAgICAgIGNvbnN0IHNsb3RDb250YWluZXIgPSBzbG90c1tuYW1lXSA9IGNyZWF0ZUFTVEVsZW1lbnQoJ3RlbXBsYXRlJywgW10sIGVsKTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoKGMpID0+IHtcbiAgICAgICAgICBpZiAoIWMuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICBjLnBhcmVudCA9IHNsb3RDb250YWluZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjtcbiAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIG1hcmsgZWwgbm9uLXBsYWluIHNvIGRhdGEgZ2V0cyBnZW5lcmF0ZWRcbiAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2xvdE5hbWUgKGJpbmRpbmcpIHtcbiAgbGV0IG5hbWUgPSBiaW5kaW5nLm5hbWUucmVwbGFjZShzbG90UkUsICcnKTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgaWYgKGJpbmRpbmcubmFtZVswXSAhPT0gJyMnKSB7XG4gICAgICBuYW1lID0gJ2RlZmF1bHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGB2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5gLFxuICAgICAgICBiaW5kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgLy8gc3RhdGljIG5hbWVcbiAgICA6IHsgbmFtZTogYFwiJHtuYW1lfVwiYCwgZHluYW1pYzogZmFsc2UgfVxufVxuXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAoZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIGBcXGBrZXlcXGAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBgICtcbiAgICAgICAgYGFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIGAgK1xuICAgICAgICBgVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuYCxcbiAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgbGV0IGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIGxldCBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZS5yZXBsYWNlKGRpclJFLCAnJykpO1xuICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBgVGhlIHZhbHVlIGZvciBhIHYtYmluZCBleHByZXNzaW9uIGNhbm5vdCBiZSBlbXB0eS4gRm91bmQgaW4gXCJ2LWJpbmQ6JHtuYW1lfVwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIG5hbWUgPSAnaW5uZXJIVE1MJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xuICAgICAgICAgICAgc3luY0dlbiA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBgJGV2ZW50YCk7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIGB1cGRhdGU6JHtjYW1lbGl6ZShuYW1lKX1gLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIGB1cGRhdGU6JHtoeXBoZW5hdGUobmFtZSl9YCxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICBgXCJ1cGRhdGU6XCIrKCR7bmFtZX0pYCxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgY29uc3QgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgbGV0IGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpc0R5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgICBpZiAoZHluYW1pY0FyZ1JFLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljLCBtb2RpZmllcnMsIGxpc3RbaV0pO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBgJHtuYW1lfT1cIiR7dmFsdWV9XCI6IGAgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICBsZXQgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICBjb25zdCBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2gobSA9PiB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXSk7XG4gICAgfVxuICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICB9XG4gIHJldHVybiBtYXBcbn1cblxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gIHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xufVxuXG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgcmV0dXJuIChcbiAgICBlbC50YWcgPT09ICdzdHlsZScgfHxcbiAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAhZWwuYXR0cnNNYXAudHlwZSB8fFxuICAgICAgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCdcbiAgICApKVxuICApXG59XG5cbmNvbnN0IGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG5jb25zdCBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIGxldCBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgYDwke2VsLnRhZ30gdi1tb2RlbD1cIiR7dmFsdWV9XCI+OiBgICtcbiAgICAgICAgYFlvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBgICtcbiAgICAgICAgYFRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIGAgK1xuICAgICAgICBgd3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gYCArXG4gICAgICAgIGBDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5gLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgY29uc3QgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHR5cGVCaW5kaW5nO1xuICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHlwZScpO1xuICAgIH1cbiAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICB0eXBlQmluZGluZyA9IGAoJHttYXBbJ3YtYmluZCddfSkudHlwZWA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICBjb25zdCBpZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJywgdHJ1ZSk7XG4gICAgICBjb25zdCBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyBgJiYoJHtpZkNvbmRpdGlvbn0pYCA6IGBgO1xuICAgICAgY29uc3QgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgY29uc3QgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgLy8gMS4gY2hlY2tib3hcbiAgICAgIGNvbnN0IGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IGAoJHt0eXBlQmluZGluZ30pPT09J2NoZWNrYm94J2AgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgY29uc3QgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGJyYW5jaDEsICd2LWZvcicsIHRydWUpO1xuICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogYCgke3R5cGVCaW5kaW5nfSk9PT0ncmFkaW8nYCArIGlmQ29uZGl0aW9uRXh0cmEsXG4gICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICB9KTtcbiAgICAgIC8vIDMuIG90aGVyXG4gICAgICBjb25zdCBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBwcmVUcmFuc2Zvcm1Ob2RlXG59O1xuXG52YXIgbW9kdWxlcyQxID0gW1xuICBrbGFzcyQxLFxuICBzdHlsZSQxLFxuICBtb2RlbCQxXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuICBpZiAoZGlyLnZhbHVlKSB7XG4gICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICB9XG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XG4gIG1vZGVsLFxuICB0ZXh0LFxuICBodG1sXG59O1xuXG4vKiAgKi9cblxuY29uc3QgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZyxcbiAgaXNVbmFyeVRhZyxcbiAgbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpXG59O1xuXG4vKiAgKi9cblxubGV0IGlzU3RhdGljS2V5O1xubGV0IGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxuY29uc3QgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHJldHVyblxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaV0uYmxvY2s7XG4gICAgICAgIG1hcmtTdGF0aWMkMShibG9jayk7XG4gICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuICAgIH1cbiAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG4gICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxuICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuICAgICkpIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuICEhKG5vZGUucHJlIHx8IChcbiAgICAhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG4gICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG4gICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChub2RlLmZvcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG5jb25zdCBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLztcbmNvbnN0IGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbmNvbnN0IHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG5jb25zdCBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgdGFiOiA5LFxuICBlbnRlcjogMTMsXG4gIHNwYWNlOiAzMixcbiAgdXA6IDM4LFxuICBsZWZ0OiAzNyxcbiAgcmlnaHQ6IDM5LFxuICBkb3duOiA0MCxcbiAgJ2RlbGV0ZSc6IFs4LCA0Nl1cbn07XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbmNvbnN0IGtleU5hbWVzID0ge1xuICAvLyAjNzg4MDogSUUxMSBhbmQgRWRnZSB1c2UgYEVzY2AgZm9yIEVzY2FwZSBrZXkgbmFtZS5cbiAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcbiAgdGFiOiAnVGFiJyxcbiAgZW50ZXI6ICdFbnRlcicsXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXG4gIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgLy8gIzc4MDY6IElFMTEgdXNlcyBrZXkgbmFtZXMgd2l0aG91dCBgQXJyb3dgIHByZWZpeCBmb3IgYXJyb3cga2V5cy5cbiAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gIHJpZ2h0OiBbJ1JpZ2h0JywgJ0Fycm93UmlnaHQnXSxcbiAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICdkZWxldGUnOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cbn07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG5jb25zdCBnZW5HdWFyZCA9IGNvbmRpdGlvbiA9PiBgaWYoJHtjb25kaXRpb259KXJldHVybiBudWxsO2A7XG5cbmNvbnN0IG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogZ2VuR3VhcmQoYCRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0YCksXG4gIGN0cmw6IGdlbkd1YXJkKGAhJGV2ZW50LmN0cmxLZXlgKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKGAhJGV2ZW50LnNoaWZ0S2V5YCksXG4gIGFsdDogZ2VuR3VhcmQoYCEkZXZlbnQuYWx0S2V5YCksXG4gIG1ldGE6IGdlbkd1YXJkKGAhJGV2ZW50Lm1ldGFLZXlgKSxcbiAgbGVmdDogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwYCksXG4gIG1pZGRsZTogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxYCksXG4gIHJpZ2h0OiBnZW5HdWFyZChgJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJgKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgY29uc3QgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICBsZXQgc3RhdGljSGFuZGxlcnMgPSBgYDtcbiAgbGV0IGR5bmFtaWNIYW5kbGVycyA9IGBgO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgY29uc3QgaGFuZGxlckNvZGUgPSBnZW5IYW5kbGVyKGV2ZW50c1tuYW1lXSk7XG4gICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgZHluYW1pY0hhbmRsZXJzICs9IGAke25hbWV9LCR7aGFuZGxlckNvZGV9LGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRpY0hhbmRsZXJzICs9IGBcIiR7bmFtZX1cIjoke2hhbmRsZXJDb2RlfSxgO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IGB7JHtzdGF0aWNIYW5kbGVycy5zbGljZSgwLCAtMSl9fWA7XG4gIGlmIChkeW5hbWljSGFuZGxlcnMpIHtcbiAgICByZXR1cm4gcHJlZml4ICsgYF9kKCR7c3RhdGljSGFuZGxlcnN9LFske2R5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSl9XSlgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSGFuZGxlciAoaGFuZGxlcikge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgcmV0dXJuIGBbJHtoYW5kbGVyLm1hcChoYW5kbGVyID0+IGdlbkhhbmRsZXIoaGFuZGxlcikpLmpvaW4oJywnKX1dYFxuICB9XG5cbiAgY29uc3QgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIGNvbnN0IGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICBjb25zdCBpc0Z1bmN0aW9uSW52b2NhdGlvbiA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUucmVwbGFjZShmbkludm9rZVJFLCAnJykpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgIH1cbiAgICByZXR1cm4gYGZ1bmN0aW9uKCRldmVudCl7JHtcbiAgICAgIGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gYHJldHVybiAke2hhbmRsZXIudmFsdWV9YCA6IGhhbmRsZXIudmFsdWVcbiAgICB9fWAgLy8gaW5saW5lIHN0YXRlbWVudFxuICB9IGVsc2Uge1xuICAgIGxldCBjb2RlID0gJyc7XG4gICAgbGV0IGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSAoaGFuZGxlci5tb2RpZmllcnMpO1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gZ2VuR3VhcmQoXG4gICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgIC5maWx0ZXIoa2V5TW9kaWZpZXIgPT4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl0pXG4gICAgICAgICAgICAubWFwKGtleU1vZGlmaWVyID0+IGAkZXZlbnQuJHtrZXlNb2RpZmllcn1LZXlgKVxuICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgIGlmIChnZW5Nb2RpZmllckNvZGUpIHtcbiAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX0oJGV2ZW50KWBcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyBgcmV0dXJuICgke2hhbmRsZXIudmFsdWV9KSgkZXZlbnQpYFxuICAgICAgICA6IGlzRnVuY3Rpb25JbnZvY2F0aW9uXG4gICAgICAgICAgPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX1gXG4gICAgICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiBgZnVuY3Rpb24oJGV2ZW50KXske2NvZGV9JHtoYW5kbGVyQ29kZX19YFxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICBgaWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZgICtcbiAgICBgJHtrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpfSlyZXR1cm4gbnVsbDtgXG4gIClcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIGNvbnN0IGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIGAkZXZlbnQua2V5Q29kZSE9PSR7a2V5VmFsfWBcbiAgfVxuICBjb25zdCBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgY29uc3Qga2V5TmFtZSA9IGtleU5hbWVzW2tleV07XG4gIHJldHVybiAoXG4gICAgYF9rKCRldmVudC5rZXlDb2RlLGAgK1xuICAgIGAke0pTT04uc3RyaW5naWZ5KGtleSl9LGAgK1xuICAgIGAke0pTT04uc3RyaW5naWZ5KGtleUNvZGUpfSxgICtcbiAgICBgJGV2ZW50LmtleSxgICtcbiAgICBgJHtKU09OLnN0cmluZ2lmeShrZXlOYW1lKX1gICtcbiAgICBgKWBcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKGB2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuYCk7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IChjb2RlKSA9PiBgX2coJHtjb2RlfSwke2Rpci52YWx1ZX0pYDtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IChjb2RlKSA9PiB7XG4gICAgcmV0dXJuIGBfYigke2NvZGV9LCcke2VsLnRhZ30nLCR7ZGlyLnZhbHVlfSwke1xuICAgICAgZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgfSR7XG4gICAgICBkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJ1xuICAgIH0pYFxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cblxuXG5cblxuY2xhc3MgQ29kZWdlblN0YXRlIHtcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcbiAgXG4gIFxuICBcblxuICBjb25zdHJ1Y3RvciAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICAgIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICAgIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgICBjb25zdCBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAgIHRoaXMubWF5YmVDb21wb25lbnQgPSAoZWwpID0+ICEhZWwuY29tcG9uZW50IHx8ICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7XG4gICAgdGhpcy5vbmNlSWQgPSAwO1xuICAgIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG4gICAgdGhpcy5wcmUgPSBmYWxzZTtcbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIGNvbnN0IGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IGB3aXRoKHRoaXMpe3JldHVybiAke2NvZGV9fWAsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnBhcmVudCkge1xuICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICB9XG5cbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCdcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgIGxldCBjb2RlO1xuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGF0YTtcbiAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkpKSB7XG4gICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IGBfYygnJHtlbC50YWd9JyR7XG4gICAgICAgIGRhdGEgPyBgLCR7ZGF0YX1gIDogJycgLy8gZGF0YVxuICAgICAgfSR7XG4gICAgICAgIGNoaWxkcmVuID8gYCwke2NoaWxkcmVufWAgOiAnJyAvLyBjaGlsZHJlblxuICAgICAgfSlgO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsLCBzdGF0ZSkge1xuICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gIC8vIG5vZGUuICBBbGwgcHJlIG5vZGVzIGFyZSBzdGF0aWMgcm9vdHMsIHNvIHdlIGNhbiB1c2UgdGhpcyBhcyBhIGxvY2F0aW9uIHRvXG4gIC8vIHdyYXAgYSBzdGF0ZSBjaGFuZ2UgYW5kIHJlc2V0IGl0IHVwb24gZXhpdGluZyB0aGUgcHJlIG5vZGUuXG4gIGNvbnN0IG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gIGlmIChlbC5wcmUpIHtcbiAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gIH1cbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goYHdpdGgodGhpcyl7cmV0dXJuICR7Z2VuRWxlbWVudChlbCwgc3RhdGUpfX1gKTtcbiAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgcmV0dXJuIGBfbSgke1xuICAgIHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxXG4gIH0ke1xuICAgIGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnXG4gIH0pYFxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICBsZXQga2V5ID0gJyc7XG4gICAgbGV0IHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHN0YXRlLndhcm4oXG4gICAgICAgIGB2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gYCxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gYF9vKCR7Z2VuRWxlbWVudChlbCwgc3RhdGUpfSwke3N0YXRlLm9uY2VJZCsrfSwke2tleX0pYFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIGNvbnN0IGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gYCgke2NvbmRpdGlvbi5leHB9KT8ke1xuICAgICAgZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spXG4gICAgfToke1xuICAgICAgZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KVxuICAgIH1gXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGAke2dlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKX1gXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIGNvbnN0IGV4cCA9IGVsLmZvcjtcbiAgY29uc3QgYWxpYXMgPSBlbC5hbGlhcztcbiAgY29uc3QgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gYCwke2VsLml0ZXJhdG9yMX1gIDogJyc7XG4gIGNvbnN0IGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IGAsJHtlbC5pdGVyYXRvcjJ9YCA6ICcnO1xuXG4gIGlmIChzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIGA8JHtlbC50YWd9IHYtZm9yPVwiJHthbGlhc30gaW4gJHtleHB9XCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBgICtcbiAgICAgIGB2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBgICtcbiAgICAgIGBTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLmAsXG4gICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXSxcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gYCR7YWx0SGVscGVyIHx8ICdfbCd9KCgke2V4cH0pLGAgK1xuICAgIGBmdW5jdGlvbigke2FsaWFzfSR7aXRlcmF0b3IxfSR7aXRlcmF0b3IyfSl7YCArXG4gICAgICBgcmV0dXJuICR7KGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpfWAgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgbGV0IGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgY29uc3QgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgaWYgKGRpcnMpIGRhdGEgKz0gZGlycyArICcsJztcblxuICAvLyBrZXlcbiAgaWYgKGVsLmtleSkge1xuICAgIGRhdGEgKz0gYGtleToke2VsLmtleX0sYDtcbiAgfVxuICAvLyByZWZcbiAgaWYgKGVsLnJlZikge1xuICAgIGRhdGEgKz0gYHJlZjoke2VsLnJlZn0sYDtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IGByZWZJbkZvcjp0cnVlLGA7XG4gIH1cbiAgLy8gcHJlXG4gIGlmIChlbC5wcmUpIHtcbiAgICBkYXRhICs9IGBwcmU6dHJ1ZSxgO1xuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBkYXRhICs9IGB0YWc6XCIke2VsLnRhZ31cIixgO1xuICB9XG4gIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgIGRhdGEgKz0gc3RhdGUuZGF0YUdlbkZuc1tpXShlbCk7XG4gIH1cbiAgLy8gYXR0cmlidXRlc1xuICBpZiAoZWwuYXR0cnMpIHtcbiAgICBkYXRhICs9IGBhdHRyczoke2dlblByb3BzKGVsLmF0dHJzKX0sYDtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBgZG9tUHJvcHM6JHtnZW5Qcm9wcyhlbC5wcm9wcyl9LGA7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gYCR7Z2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSl9LGA7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gYCR7Z2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKX0sYDtcbiAgfVxuICAvLyBzbG90IHRhcmdldFxuICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICBkYXRhICs9IGBzbG90OiR7ZWwuc2xvdFRhcmdldH0sYDtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSBgJHtnZW5TY29wZWRTbG90cyhlbCwgZWwuc2NvcGVkU2xvdHMsIHN0YXRlKX0sYDtcbiAgfVxuICAvLyBjb21wb25lbnQgdi1tb2RlbFxuICBpZiAoZWwubW9kZWwpIHtcbiAgICBkYXRhICs9IGBtb2RlbDp7dmFsdWU6JHtcbiAgICAgIGVsLm1vZGVsLnZhbHVlXG4gICAgfSxjYWxsYmFjazoke1xuICAgICAgZWwubW9kZWwuY2FsbGJhY2tcbiAgICB9LGV4cHJlc3Npb246JHtcbiAgICAgIGVsLm1vZGVsLmV4cHJlc3Npb25cbiAgICB9fSxgO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICBjb25zdCBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgICBkYXRhICs9IGAke2lubGluZVRlbXBsYXRlfSxgO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGR5bmFtaWMgYXJndW1lbnQgd3JhcFxuICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gIGlmIChlbC5keW5hbWljQXR0cnMpIHtcbiAgICBkYXRhID0gYF9iKCR7ZGF0YX0sXCIke2VsLnRhZ31cIiwke2dlblByb3BzKGVsLmR5bmFtaWNBdHRycyl9KWA7XG4gIH1cbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgY29uc3QgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gIGlmICghZGlycykgcmV0dXJuXG4gIGxldCByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgbGV0IGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgbGV0IGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIGNvbnN0IGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IGB7bmFtZTpcIiR7ZGlyLm5hbWV9XCIscmF3TmFtZTpcIiR7ZGlyLnJhd05hbWV9XCIke1xuICAgICAgICBkaXIudmFsdWUgPyBgLHZhbHVlOigke2Rpci52YWx1ZX0pLGV4cHJlc3Npb246JHtKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpfWAgOiAnJ1xuICAgICAgfSR7XG4gICAgICAgIGRpci5hcmcgPyBgLGFyZzoke2Rpci5pc0R5bmFtaWNBcmcgPyBkaXIuYXJnIDogYFwiJHtkaXIuYXJnfVwiYH1gIDogJydcbiAgICAgIH0ke1xuICAgICAgICBkaXIubW9kaWZpZXJzID8gYCxtb2RpZmllcnM6JHtKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKX1gIDogJydcbiAgICAgIH19LGA7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIGNvbnN0IGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAoZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGFzdC50eXBlICE9PSAxKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIGNvbnN0IGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIGBpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7JHtcbiAgICAgIGlubGluZVJlbmRlckZucy5yZW5kZXJcbiAgICB9fSxzdGF0aWNSZW5kZXJGbnM6WyR7XG4gICAgICBpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChjb2RlID0+IGBmdW5jdGlvbigpeyR7Y29kZX19YCkuam9pbignLCcpXG4gICAgfV19YFxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChcbiAgZWwsXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gIC8vIGNvbXBvbmVudHMgd2l0aCBvbmx5IHNjb3BlZCBzbG90cyB0byBza2lwIGZvcmNlZCB1cGRhdGVzIGZyb20gcGFyZW50LlxuICAvLyBidXQgaW4gc29tZSBjYXNlcyB3ZSBoYXZlIHRvIGJhaWwtb3V0IG9mIHRoaXMgb3B0aW1pemF0aW9uXG4gIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgbGV0IG5lZWRzRm9yY2VVcGRhdGUgPSBPYmplY3Qua2V5cyhzbG90cykuc29tZShrZXkgPT4ge1xuICAgIGNvbnN0IHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuICAvLyBPUiB3aGVuIGl0IGlzIGluc2lkZSBhbm90aGVyIHNjb3BlZCBzbG90ICh0aGUgcmVhY3Rpdml0eSBpcyBkaXNjb25uZWN0ZWQpXG4gIC8vICM5NDM4XG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIGxldCBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5zbG90U2NvcGUgJiYgcGFyZW50LnNsb3RTY29wZSAhPT0gZW1wdHlTbG90U2NvcGVUb2tlbikge1xuICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGBzY29wZWRTbG90czpfdShbJHtcbiAgICBPYmplY3Qua2V5cyhzbG90cykubWFwKGtleSA9PiB7XG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChzbG90c1trZXldLCBzdGF0ZSlcbiAgICB9KS5qb2luKCcsJylcbiAgfV0ke25lZWRzRm9yY2VVcGRhdGUgPyBgLHRydWVgIDogYGB9KWBcbn1cblxuZnVuY3Rpb24gY29udGFpbnNTbG90Q2hpbGQgKGVsKSB7XG4gIGlmIChlbC50eXBlID09PSAxKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZWwuY2hpbGRyZW4uc29tZShjb250YWluc1Nsb3RDaGlsZClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGNvbnN0IGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBgbnVsbGApXG4gIH1cbiAgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QpXG4gIH1cbiAgY29uc3Qgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBgYFxuICAgIDogU3RyaW5nKGVsLnNsb3RTY29wZSk7XG4gIGNvbnN0IGZuID0gYGZ1bmN0aW9uKCR7c2xvdFNjb3BlfSl7YCArXG4gICAgYHJldHVybiAke2VsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgPyBlbC5pZiAmJiBpc0xlZ2FjeVN5bnRheFxuICAgICAgICA/IGAoJHtlbC5pZn0pPyR7Z2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ306dW5kZWZpbmVkYFxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gICAgfX1gO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIGNvbnN0IHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IGBgIDogYCxwcm94eTp0cnVlYDtcbiAgcmV0dXJuIGB7a2V5OiR7ZWwuc2xvdFRhcmdldCB8fCBgXCJkZWZhdWx0XCJgfSxmbjoke2ZufSR7cmV2ZXJzZVByb3h5fX1gXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICBjb25zdCBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY29uc3QgZWwgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbC5mb3IgJiZcbiAgICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIGNvbnN0IG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwpID8gYCwxYCA6IGAsMGBcbiAgICAgICAgOiBgYDtcbiAgICAgIHJldHVybiBgJHsoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpfSR7bm9ybWFsaXphdGlvblR5cGV9YFxuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgY29uc3QgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiBgWyR7Y2hpbGRyZW4ubWFwKGMgPT4gZ2VuKGMsIHN0YXRlKSkuam9pbignLCcpfV0ke1xuICAgICAgbm9ybWFsaXphdGlvblR5cGUgPyBgLCR7bm9ybWFsaXphdGlvblR5cGV9YCA6ICcnXG4gICAgfWBcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICBjaGlsZHJlbixcbiAgbWF5YmVDb21wb25lbnRcbikge1xuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoYyA9PiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jaykpKSkge1xuICAgICAgcmVzID0gMjtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShjID0+IG1heWJlQ29tcG9uZW50KGMuYmxvY2spKSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gYF92KCR7dGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpXG4gIH0pYFxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiBgX2UoJHtKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpfSlgXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICBjb25zdCBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIGNvbnN0IGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgbGV0IHJlcyA9IGBfdCgke3Nsb3ROYW1lfSR7Y2hpbGRyZW4gPyBgLCR7Y2hpbGRyZW59YCA6ICcnfWA7XG4gIGNvbnN0IGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChhdHRyID0+ICh7XG4gICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxuICAgICAgICBuYW1lOiBjYW1lbGl6ZShhdHRyLm5hbWUpLFxuICAgICAgICB2YWx1ZTogYXR0ci52YWx1ZSxcbiAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXG4gICAgICB9KSkpXG4gICAgOiBudWxsO1xuICBjb25zdCBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBgLG51bGxgO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBgLCR7YXR0cnN9YDtcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSBgJHthdHRycyA/ICcnIDogJyxudWxsJ30sJHtiaW5kJCQxfWA7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBjb25zdCBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiBgX2MoJHtjb21wb25lbnROYW1lfSwke2dlbkRhdGEkMihlbCwgc3RhdGUpfSR7XG4gICAgY2hpbGRyZW4gPyBgLCR7Y2hpbGRyZW59YCA6ICcnXG4gIH0pYFxufVxuXG5mdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgbGV0IHN0YXRpY1Byb3BzID0gYGA7XG4gIGxldCBkeW5hbWljUHJvcHMgPSBgYDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICBjb25zdCB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICBkeW5hbWljUHJvcHMgKz0gYCR7cHJvcC5uYW1lfSwke3ZhbHVlfSxgO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNQcm9wcyArPSBgXCIke3Byb3AubmFtZX1cIjoke3ZhbHVlfSxgO1xuICAgIH1cbiAgfVxuICBzdGF0aWNQcm9wcyA9IGB7JHtzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSl9fWA7XG4gIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICByZXR1cm4gYF9kKCR7c3RhdGljUHJvcHN9LFske2R5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSl9XSlgXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YXRpY1Byb3BzXG4gIH1cbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cblxuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxuY29uc3QgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbmNvbnN0IHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xuY29uc3Qgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QsIHdhcm4pIHtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgd2Fybikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSBub2RlLnJhd0F0dHJzTWFwW25hbWVdO1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCBgdi1mb3I9XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCBgJHtuYW1lfT1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgYCR7bmFtZX09XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCB3YXJuLCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIGNvbnN0IHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIGNvbnN0IGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIHdhcm4oXG4gICAgICBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBgICtcbiAgICAgIGBcIiR7a2V5d29yZE1hdGNoWzBdfVwiIGluIGV4cHJlc3Npb24gJHt0ZXh0LnRyaW0oKX1gLFxuICAgICAgcmFuZ2VcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICB3YXJuLFxuICByYW5nZVxuKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbihgdmFyICR7aWRlbnR9PV9gKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YXJuKGBpbnZhbGlkICR7dHlwZX0gXCIke2lkZW50fVwiIGluIGV4cHJlc3Npb246ICR7dGV4dC50cmltKCl9YCwgcmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oYHJldHVybiAke2V4cH1gKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IGAgK1xuICAgICAgICBgXCIke2tleXdvcmRNYXRjaFswXX1cIlxcbiAgUmF3IGV4cHJlc3Npb246ICR7dGV4dC50cmltKCl9YCxcbiAgICAgICAgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGBpbnZhbGlkIGV4cHJlc3Npb246ICR7ZS5tZXNzYWdlfSBpblxcblxcbmAgK1xuICAgICAgICBgICAgICR7ZXhwfVxcblxcbmAgK1xuICAgICAgICBgICBSYXcgZXhwcmVzc2lvbjogJHt0ZXh0LnRyaW0oKX1cXG5gLFxuICAgICAgICByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmNvbnN0IHJhbmdlID0gMjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICBzb3VyY2UsXG4gIHN0YXJ0ID0gMCxcbiAgZW5kID0gc291cmNlLmxlbmd0aFxuKSB7XG4gIGNvbnN0IGxpbmVzID0gc291cmNlLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcbiAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKSBjb250aW51ZVxuICAgICAgICByZXMucHVzaChgJHtqICsgMX0ke3JlcGVhdChgIGAsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCl9fCAgJHtsaW5lc1tqXX1gKTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGxpbmVzW2pdLmxlbmd0aDtcbiAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxuICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgIHJlcy5wdXNoKGAgICB8ICBgICsgcmVwZWF0KGAgYCwgcGFkKSArIHJlcGVhdChgXmAsIGxlbmd0aCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihlbmQgLSBjb3VudCwgbGluZUxlbmd0aCk7XG4gICAgICAgICAgICByZXMucHVzaChgICAgfCAgYCArIHJlcGVhdChgXmAsIGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxufVxuXG5mdW5jdGlvbiByZXBlYXQgKHN0ciwgbikge1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIHdoaWxlICh0cnVlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAobiAmIDEpIHJlc3VsdCArPSBzdHI7XG4gICAgbiA+Pj49IDE7XG4gICAgaWYgKG4gPD0gMCkgYnJlYWtcbiAgICBzdHIgKz0gc3RyO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVyciwgY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgY29uc3Qgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oJ3JldHVybiAxJyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcbiAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgICAncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG4gICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgY29uc3Qga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIGNvbnN0IGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIHtcbiAgICAgIGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgYEVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG4ke2UubXNnfVxcblxcbmAgK1xuICAgICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZS5zdGFydCwgZS5lbmQpLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgYEVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG4ke3RlbXBsYXRlfVxcblxcbmAgK1xuICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChlID0+IGAtICR7ZX1gKS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChlID0+IHRpcChlLm1zZywgdm0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2gobXNnID0+IHRpcChtc2csIHZtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBjb25zdCBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChjb2RlID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbihjb2RlLCBmbkdlbkVycm9ycylcbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgIC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG4gICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgYEZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuYCArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKCh7IGVyciwgY29kZSB9KSA9PiBgJHtlcnIudG9TdHJpbmcoKX0gaW5cXG5cXG4ke2NvZGV9XFxuYCkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgY29uc3QgdGlwcyA9IFtdO1xuXG4gICAgICBsZXQgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgY29uc3QgbGVhZGluZ1NwYWNlTGVuZ3RoID0gdGVtcGxhdGUubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7IG1zZyB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gd2FybjtcblxuICAgICAgY29uc3QgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICB7XG4gICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG5jb25zdCBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgY29uc3QgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgfVxuICBjb25zdCBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3QsXG4gICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICBzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn0pO1xuXG4vKiAgKi9cblxuY29uc3QgeyBjb21waWxlLCBjb21waWxlVG9GdW5jdGlvbnMgfSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5sZXQgZGl2O1xuZnVuY3Rpb24gZ2V0U2hvdWxkRGVjb2RlIChocmVmKSB7XG4gIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBgPGEgaHJlZj1cIlxcblwiLz5gIDogYDxkaXYgYT1cIlxcblwiLz5gO1xuICByZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKCcmIzEwOycpID4gMFxufVxuXG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxuY29uc3Qgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG5jb25zdCBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUodHJ1ZSkgOiBmYWxzZTtcblxuLyogICovXG5cbmNvbnN0IGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChpZCA9PiB7XG4gIGNvbnN0IGVsID0gcXVlcnkoaWQpO1xuICByZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG59KTtcblxuY29uc3QgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgd2FybihcbiAgICAgIGBEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5gXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICBsZXQgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIGBUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogJHtvcHRpb25zLnRlbXBsYXRlfWAsXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgIG1lYXN1cmUoYHZ1ZSAke3RoaXMuX25hbWV9IGNvbXBpbGVgLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgZGVmYXVsdCBWdWU7XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPHNlbGVjdCBjbGFzcz0nc2VsZWN0JyB2LW1vZGVsPSdzZWxlY3RlZCcgQGlucHV0PSdldmVudCA9PiB7ICRlbWl0KFwiaW5wdXRcIiwgZXZlbnQudGFyZ2V0LnZhbHVlKSB9Jz5cbiAgICAgIDxvcHRpb24gdi1mb3I9J29wdGlvbiBpbiBvcHRpb25zJyA6a2V5PSdvcHRpb24udmFsdWUnIDp2YWx1ZT0nb3B0aW9uLnZhbHVlJz5cbiAgICAgICAge3sgb3B0aW9uLnRleHQgfX1cbiAgICAgIDwvb3B0aW9uPlxuICAgIDwvc2VsZWN0PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZT48L3N0eWxlPlxuXG48c2NyaXB0PlxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgcHJvcHM6IFsnb3B0aW9ucycsICd2YWx1ZSddLFxuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3RlZDogbnVsbCxcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy52YWx1ZTtcbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTZWxlY3REYXRhID0gW1xuICB7IHRleHQ6ICdBbGwgQm9yb3VnaHMnLCB2YWx1ZTogJ2FsbCcgfSxcbiAgeyB0ZXh0OiAnQnJvb2tseW4nLCB2YWx1ZTogJ2Jyb29rbHluJyB9LFxuICB7IHRleHQ6ICdRdWVlbnMnLCB2YWx1ZTogJ3F1ZWVucycgfSxcbiAgeyB0ZXh0OiAnTWFuaGF0dGFuJywgdmFsdWU6ICdtYW5oYXR0YW4nIH0sXG4gIHsgdGV4dDogJ1N0YXRlbiBJc2xhbmQnLCB2YWx1ZTogJ3N0YXRlbiBpc2xhbmQnIH0sXG4gIHsgdGV4dDogJ1RoZSBCcm9ueCcsIHZhbHVlOiAnYnJvbngnIH1cbl07XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdERhdGE7IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5lc20uYnJvd3Nlcic7IC8vXG5pbXBvcnQgU2VsZWN0Q29tcG9uZW50IGZyb20gJy4vc2VsZWN0LnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBTZWxlY3REYXRhIGZyb20gJy4vc2VsZWN0LmRhdGEuanMnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY2xhc3MgU2VsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KCdueWNvLXNlbGVjdCcsIFNlbGVjdENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiAnW2RhdGEtanM9XCJhcHBcIl0nLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wdGlvbnM6IFNlbGVjdC5kYXRhLFxuICAgICAgICAgIHNlbGVjdGVkOiAnYWxsJyxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5TZWxlY3QuZGF0YSA9IFNlbGVjdERhdGE7XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdDsiLCJmdW5jdGlvbiBkYXRhSGFuZGxlcihuZXdEYXRhLCBvbGREYXRhKSB7XG4gIGlmIChvbGREYXRhKSB7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcy4kZGF0YS5fY2hhcnQ7XG4gICAgdmFyIG5ld0RhdGFzZXRMYWJlbHMgPSBuZXdEYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQubGFiZWw7XG4gICAgfSk7XG4gICAgdmFyIG9sZERhdGFzZXRMYWJlbHMgPSBvbGREYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQubGFiZWw7XG4gICAgfSk7XG4gICAgdmFyIG9sZExhYmVscyA9IEpTT04uc3RyaW5naWZ5KG9sZERhdGFzZXRMYWJlbHMpO1xuICAgIHZhciBuZXdMYWJlbHMgPSBKU09OLnN0cmluZ2lmeShuZXdEYXRhc2V0TGFiZWxzKTtcblxuICAgIGlmIChuZXdMYWJlbHMgPT09IG9sZExhYmVscyAmJiBvbGREYXRhLmRhdGFzZXRzLmxlbmd0aCA9PT0gbmV3RGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIG5ld0RhdGEuZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YXNldCwgaSkge1xuICAgICAgICB2YXIgb2xkRGF0YXNldEtleXMgPSBPYmplY3Qua2V5cyhvbGREYXRhLmRhdGFzZXRzW2ldKTtcbiAgICAgICAgdmFyIG5ld0RhdGFzZXRLZXlzID0gT2JqZWN0LmtleXMoZGF0YXNldCk7XG4gICAgICAgIHZhciBkZWxldGlvbktleXMgPSBvbGREYXRhc2V0S2V5cy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBrZXkgIT09ICdfbWV0YScgJiYgbmV3RGF0YXNldEtleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0aW9uS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChkZWxldGlvbktleSkge1xuICAgICAgICAgIGRlbGV0ZSBjaGFydC5kYXRhLmRhdGFzZXRzW2ldW2RlbGV0aW9uS2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgYXR0cmlidXRlIGluIGRhdGFzZXQpIHtcbiAgICAgICAgICBpZiAoZGF0YXNldC5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICBjaGFydC5kYXRhLmRhdGFzZXRzW2ldW2F0dHJpYnV0ZV0gPSBkYXRhc2V0W2F0dHJpYnV0ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKG5ld0RhdGEuaGFzT3duUHJvcGVydHkoJ2xhYmVscycpKSB7XG4gICAgICAgIGNoYXJ0LmRhdGEubGFiZWxzID0gbmV3RGF0YS5sYWJlbHM7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2xhYmVsczp1cGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0RhdGEuaGFzT3duUHJvcGVydHkoJ3hMYWJlbHMnKSkge1xuICAgICAgICBjaGFydC5kYXRhLnhMYWJlbHMgPSBuZXdEYXRhLnhMYWJlbHM7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3hsYWJlbHM6dXBkYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdEYXRhLmhhc093blByb3BlcnR5KCd5TGFiZWxzJykpIHtcbiAgICAgICAgY2hhcnQuZGF0YS55TGFiZWxzID0gbmV3RGF0YS55TGFiZWxzO1xuICAgICAgICB0aGlzLiRlbWl0KCd5bGFiZWxzOnVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OnVwZGF0ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2hhcnQpIHtcbiAgICAgICAgY2hhcnQuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFydDpkZXN0cm95Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFydDpyZW5kZXInKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB7XG4gICAgICB0aGlzLiRkYXRhLl9jaGFydC5kZXN0cm95KCk7XG5cbiAgICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OmRlc3Ryb3knKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlckNoYXJ0KHRoaXMuY2hhcnREYXRhLCB0aGlzLm9wdGlvbnMpO1xuICAgIHRoaXMuJGVtaXQoJ2NoYXJ0OnJlbmRlcicpO1xuICB9XG59XG5cbmV4cG9ydCB2YXIgcmVhY3RpdmVEYXRhID0ge1xuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGFydERhdGE6IG51bGxcbiAgICB9O1xuICB9LFxuICB3YXRjaDoge1xuICAgICdjaGFydERhdGEnOiBkYXRhSGFuZGxlclxuICB9XG59O1xuZXhwb3J0IHZhciByZWFjdGl2ZVByb3AgPSB7XG4gIHByb3BzOiB7XG4gICAgY2hhcnREYXRhOiB7XG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAnY2hhcnREYXRhJzogZGF0YUhhbmRsZXJcbiAgfVxufTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgcmVhY3RpdmVEYXRhOiByZWFjdGl2ZURhdGEsXG4gIHJlYWN0aXZlUHJvcDogcmVhY3RpdmVQcm9wXG59OyIsIi8vISBtb21lbnQuanNcblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjIgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICAgICAgdmFyIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9IGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDAsIC0yKTsgLy8gUmVtb3ZlIHRyYWlsaW5nIGNvbW1hIGFuZCBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG5Bcmd1bWVudHM6ICcgKyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5qb2luKCcnKSArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobmFtZSwgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICh0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlLnNvdXJjZSB8fCB0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlKSArXG4gICAgICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQgICA6ICdoOm1tIEEnLFxuICAgICAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTCAgOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyLnJlcGxhY2UoL01NTU18TU18RER8ZGRkZC9nLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnO1xuICAgIHZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzIDogJyVkIHNlY29uZHMnLFxuICAgICAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoICA6ICdhbiBob3VyJyxcbiAgICAgICAgaGggOiAnJWQgaG91cnMnLFxuICAgICAgICBkICA6ICdhIGRheScsXG4gICAgICAgIGRkIDogJyVkIGRheXMnLFxuICAgICAgICBNICA6ICdhIG1vbnRoJyxcbiAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeSAgOiAnYSB5ZWFyJyxcbiAgICAgICAgeXkgOiAnJWQgeWVhcnMnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgdW5pdHMucHVzaCh7dW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV19KTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbiAgICB2YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICB2YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG4gICAgdmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgIC8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuICAgIHZhciBXRUVLID0gNztcbiAgICB2YXIgV0VFS0RBWSA9IDg7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/ICcnICsgeSA6ICcrJyArIHk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJiBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmIG1vbS5tb250aCgpID09PSAxICYmIG1vbS5kYXRlKCkgPT09IDI5KSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXNbcHJpb3JpdGl6ZWRbaV0udW5pdF0odW5pdHNbcHJpb3JpdGl6ZWRbaV0udW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAgICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSwgbW9tO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGFyZ3NbMF0gPSB5ICsgNDAwO1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGxvY2FsV2Vla2RheSA9ICg3ICsgd2Vla2RheSAtIGRvdykgJSA3LFxuICAgICAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICAgICAgcmVzWWVhciwgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgLSAxO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWsgLSB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSk7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyAod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5cyAobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbKG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddO1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHdlZWtkYXlzW20uZGF5KCldIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzU2hvcnQsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNTaG9ydDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiAobSA9PT0gdHJ1ZSkgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAgICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuXG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KHRoaXMuZGF5KCkgJSA3ID8gd2Vla2RheSA6IHdlZWtkYXkgLSA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHNob3J0cCA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdrJywgWydraycsIDJdLCAwLCBrRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciB0aGV5IHdhbnQuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlXG4gICAgfTtcblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdMb2NhbGUgJyArIGtleSArICAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsIHRtcExvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIC8vIE1FUkdFXG4gICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93O1xuICAgICAgICB2YXIgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQyA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKSA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB2YXIgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbiAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG5cbiAgICB2YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvXFxkXFxkL11cbiAgICBdO1xuXG4gICAgdmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBsLFxuICAgICAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgbWF0Y2ggPSBleHRlbmRlZElzb1JlZ2V4LmV4ZWMoc3RyaW5nKSB8fCBiYXNpY0lzb1JlZ2V4LmV4ZWMoc3RyaW5nKSxcbiAgICAgICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoWzJdIHNob3VsZCBiZSAnVCcgb3Igc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgICAgIGlmICh0elJlZ2V4LmV4ZWMobWF0Y2hbNF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAgICB2YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXG4gICAgICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydC5pbmRleE9mKG1vbnRoU3RyKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGRheVN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICAgICAgcGFyc2VJbnQobWludXRlU3RyLCAxMClcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcKFteKV0qXFwpfFtcXG5cXHRdL2csICcgJykucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVudGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShwYXJzZWRJbnB1dFswXSwgcGFyc2VkSW5wdXRbMV0sIHBhcnNlZElucHV0WzJdKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgVVQ6IDAsXG4gICAgICAgIEdNVDogMCxcbiAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgIENEVDogLTUgKiA2MCxcbiAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgIE1TVDogLTcgKiA2MCxcbiAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICBQU1Q6IC04ICogNjBcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCk7XG4gICAgICAgICAgICB2YXIgbSA9IGhtICUgMTAwLCBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MobWF0Y2hbNF0sIG1hdGNoWzNdLCBtYXRjaFsyXSwgbWF0Y2hbNV0sIG1hdGNoWzZdLCBtYXRjaFs3XSk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cblxuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gIGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gWyd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKCEoaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJiAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgICAgICB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgICAgIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAgICAgMCA6XG4gICAgICAgICAgcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKVxcOihcXGQrKSg/OlxcOihcXGQrKShcXC5cXGQqKT8pPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgIHZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbiAoaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zIDogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGxvY2FsRnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCxcbiAgICAgICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gNmU0OyBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTU7IGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDogb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xuICAgIH1cblxuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlO1xuICAgICAgICB2YXIgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICBpZiAodXRjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAgICAgKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCc7XG4gICAgICAgIHZhciB6b25lID0gJyc7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDA7XG4gICAgdmFyIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQ7XG4gICAgdmFyIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFO1xuICAgIHZhciBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1dGNTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIERhdGUuVVRDIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHksIG0sIGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMywgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpIC0gdGhpcy5tb250aCgpICUgMyArIDMsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpICsgNykgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3KSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpICsgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX0hPVVIgLSBtb2QkMSh0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSwgTVNfUEVSX0hPVVIpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCAoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgP1xuICAgICAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xuICAgIHByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbiAgICBwcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xuICAgIHByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xuICAgIHByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbiAgICBwcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIHByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xuICAgIHByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xuICAgIHByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIHByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG4gICAgcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xuICAgIHByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgcHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG4gICAgcHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG4gICAgcHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbiAgICBwcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIHByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuICAgIHByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcbiAgICBwcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuICAgIHByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcbiAgICBwcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayAgICAgICAgPSBwcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbiAgICBwcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBwcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIHByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIHByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIHByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIHByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG4gICAgcHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4gICAgcHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICBwcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICBob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6ICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzogcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6ICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1F1YXJ0ZXJzICAgICA9IG1ha2VBcygnUScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQkMiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKTtcbiAgICB2YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xuICAgIHZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG4gICAgdmFyIGhvdXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyk7XG4gICAgdmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG4gICAgdmFyIHllYXJzICAgICAgICA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG4gICAgdmFyIHRocmVzaG9sZHMgPSB7XG4gICAgICAgIHNzOiA0NCwgICAgICAgICAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgaCA6IDIyLCAgICAgICAgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPD0gMSAgICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggICAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPD0gMSAgICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyAocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0geWVhcnM7XG4gICAgICAgIHZhciBNID0gbW9udGhzO1xuICAgICAgICB2YXIgRCA9IGRheXM7XG4gICAgICAgIHZhciBoID0gaG91cnM7XG4gICAgICAgIHZhciBtID0gbWludXRlcztcbiAgICAgICAgdmFyIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHZhciB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIHZhciBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiB0b3RhbFNpZ24gKyAnUCcgK1xuICAgICAgICAgICAgKFkgPyB5bVNpZ24gKyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8geW1TaWduICsgTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IGRheXNTaWduICsgRCArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaCA/IGhtc1NpZ24gKyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gaG1zU2lnbiArIG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcbiAgICBwcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XG4gICAgcHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XG4gICAgcHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzICAgICA9IGFzUXVhcnRlcnM7XG4gICAgcHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIHByb3RvJDIuY2xvbmUgICAgICAgICAgPSBjbG9uZSQxO1xuICAgIHByb3RvJDIuZ2V0ICAgICAgICAgICAgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIHByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBwcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBwcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgcHJvdG8kMi5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIHByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9KU09OICAgICAgICAgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjQuMCc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG4gICAgaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIGhvb2tzLm1heCAgICAgICAgICAgICAgICAgICA9IG1heDtcbiAgICBob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG4gICAgaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG4gICAgaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuICAgIGhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbiAgICBob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdFdlZWtkYXlzTWluO1xuICAgIGhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICBob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG4gICAgaG9va3MubG9jYWxlcyAgICAgICAgICAgICAgID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIGhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBUSU1FX01TOiAnSEg6bW06c3MuU1NTJywgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgICAgICBNT05USDogJ1lZWVktTU0nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiLyohXG4gKiBDaGFydC5qcyB2Mi44LjBcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAxOSBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsncmVxdWlyZSddLCBmdW5jdGlvbihyZXF1aXJlKSB7IHJldHVybiBmYWN0b3J5KGZ1bmN0aW9uKCkgeyB0cnkgeyByZXR1cm4gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2goZSkgeyB9IH0oKSk7IH0pIDpcbihnbG9iYWwuQ2hhcnQgPSBmYWN0b3J5KGdsb2JhbC5tb21lbnQpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChtb21lbnQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5tb21lbnQgPSBtb21lbnQgJiYgbW9tZW50Lmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBtb21lbnRbJ2RlZmF1bHQnXSA6IG1vbWVudDtcblxuLyogTUlUIGxpY2Vuc2UgKi9cblxudmFyIGNvbnZlcnNpb25zID0ge1xuICByZ2IyaHNsOiByZ2IyaHNsLFxuICByZ2IyaHN2OiByZ2IyaHN2LFxuICByZ2IyaHdiOiByZ2IyaHdiLFxuICByZ2IyY215azogcmdiMmNteWssXG4gIHJnYjJrZXl3b3JkOiByZ2Iya2V5d29yZCxcbiAgcmdiMnh5ejogcmdiMnh5eixcbiAgcmdiMmxhYjogcmdiMmxhYixcbiAgcmdiMmxjaDogcmdiMmxjaCxcblxuICBoc2wycmdiOiBoc2wycmdiLFxuICBoc2wyaHN2OiBoc2wyaHN2LFxuICBoc2wyaHdiOiBoc2wyaHdiLFxuICBoc2wyY215azogaHNsMmNteWssXG4gIGhzbDJrZXl3b3JkOiBoc2wya2V5d29yZCxcblxuICBoc3YycmdiOiBoc3YycmdiLFxuICBoc3YyaHNsOiBoc3YyaHNsLFxuICBoc3YyaHdiOiBoc3YyaHdiLFxuICBoc3YyY215azogaHN2MmNteWssXG4gIGhzdjJrZXl3b3JkOiBoc3Yya2V5d29yZCxcblxuICBod2IycmdiOiBod2IycmdiLFxuICBod2IyaHNsOiBod2IyaHNsLFxuICBod2IyaHN2OiBod2IyaHN2LFxuICBod2IyY215azogaHdiMmNteWssXG4gIGh3YjJrZXl3b3JkOiBod2Iya2V5d29yZCxcblxuICBjbXlrMnJnYjogY215azJyZ2IsXG4gIGNteWsyaHNsOiBjbXlrMmhzbCxcbiAgY215azJoc3Y6IGNteWsyaHN2LFxuICBjbXlrMmh3YjogY215azJod2IsXG4gIGNteWsya2V5d29yZDogY215azJrZXl3b3JkLFxuXG4gIGtleXdvcmQycmdiOiBrZXl3b3JkMnJnYixcbiAga2V5d29yZDJoc2w6IGtleXdvcmQyaHNsLFxuICBrZXl3b3JkMmhzdjoga2V5d29yZDJoc3YsXG4gIGtleXdvcmQyaHdiOiBrZXl3b3JkMmh3YixcbiAga2V5d29yZDJjbXlrOiBrZXl3b3JkMmNteWssXG4gIGtleXdvcmQybGFiOiBrZXl3b3JkMmxhYixcbiAga2V5d29yZDJ4eXo6IGtleXdvcmQyeHl6LFxuXG4gIHh5ejJyZ2I6IHh5ejJyZ2IsXG4gIHh5ejJsYWI6IHh5ejJsYWIsXG4gIHh5ejJsY2g6IHh5ejJsY2gsXG5cbiAgbGFiMnh5ejogbGFiMnh5eixcbiAgbGFiMnJnYjogbGFiMnJnYixcbiAgbGFiMmxjaDogbGFiMmxjaCxcblxuICBsY2gybGFiOiBsY2gybGFiLFxuICBsY2gyeHl6OiBsY2gyeHl6LFxuICBsY2gycmdiOiBsY2gycmdiXG59O1xuXG5cbmZ1bmN0aW9uIHJnYjJoc2wocmdiKSB7XG4gIHZhciByID0gcmdiWzBdLzI1NSxcbiAgICAgIGcgPSByZ2JbMV0vMjU1LFxuICAgICAgYiA9IHJnYlsyXS8yNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgZGVsdGEgPSBtYXggLSBtaW4sXG4gICAgICBoLCBzLCBsO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpLyBkZWx0YTtcblxuICBoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG4gIGlmIChoIDwgMClcbiAgICBoICs9IDM2MDtcblxuICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChsIDw9IDAuNSlcbiAgICBzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcbiAgZWxzZVxuICAgIHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblxuICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufVxuXG5mdW5jdGlvbiByZ2IyaHN2KHJnYikge1xuICB2YXIgciA9IHJnYlswXSxcbiAgICAgIGcgPSByZ2JbMV0sXG4gICAgICBiID0gcmdiWzJdLFxuICAgICAgbWluID0gTWF0aC5taW4ociwgZywgYiksXG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcbiAgICAgIGRlbHRhID0gbWF4IC0gbWluLFxuICAgICAgaCwgcywgdjtcblxuICBpZiAobWF4ID09IDApXG4gICAgcyA9IDA7XG4gIGVsc2VcbiAgICBzID0gKGRlbHRhL21heCAqIDEwMDApLzEwO1xuXG4gIGlmIChtYXggPT0gbWluKVxuICAgIGggPSAwO1xuICBlbHNlIGlmIChyID09IG1heClcbiAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICBlbHNlIGlmIChnID09IG1heClcbiAgICBoID0gMiArIChiIC0gcikgLyBkZWx0YTtcbiAgZWxzZSBpZiAoYiA9PSBtYXgpXG4gICAgaCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cbiAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICBpZiAoaCA8IDApXG4gICAgaCArPSAzNjA7XG5cbiAgdiA9ICgobWF4IC8gMjU1KSAqIDEwMDApIC8gMTA7XG5cbiAgcmV0dXJuIFtoLCBzLCB2XTtcbn1cblxuZnVuY3Rpb24gcmdiMmh3YihyZ2IpIHtcbiAgdmFyIHIgPSByZ2JbMF0sXG4gICAgICBnID0gcmdiWzFdLFxuICAgICAgYiA9IHJnYlsyXSxcbiAgICAgIGggPSByZ2IyaHNsKHJnYilbMF0sXG4gICAgICB3ID0gMS8yNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSksXG4gICAgICBiID0gMSAtIDEvMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG4gIHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJjbXlrKHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1LFxuICAgICAgYywgbSwgeSwgaztcblxuICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gIGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZUtleXdvcmRzW0pTT04uc3RyaW5naWZ5KHJnYildO1xufVxuXG5mdW5jdGlvbiByZ2IyeHl6KHJnYikge1xuICB2YXIgciA9IHJnYlswXSAvIDI1NSxcbiAgICAgIGcgPSByZ2JbMV0gLyAyNTUsXG4gICAgICBiID0gcmdiWzJdIC8gMjU1O1xuXG4gIC8vIGFzc3VtZSBzUkdCXG4gIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KCgociArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChyIC8gMTIuOTIpO1xuICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKGcgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAoZyAvIDEyLjkyKTtcbiAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChiICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGIgLyAxMi45Mik7XG5cbiAgdmFyIHggPSAociAqIDAuNDEyNCkgKyAoZyAqIDAuMzU3NikgKyAoYiAqIDAuMTgwNSk7XG4gIHZhciB5ID0gKHIgKiAwLjIxMjYpICsgKGcgKiAwLjcxNTIpICsgKGIgKiAwLjA3MjIpO1xuICB2YXIgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuICByZXR1cm4gW3ggKiAxMDAsIHkgKjEwMCwgeiAqIDEwMF07XG59XG5cbmZ1bmN0aW9uIHJnYjJsYWIocmdiKSB7XG4gIHZhciB4eXogPSByZ2IyeHl6KHJnYiksXG4gICAgICAgIHggPSB4eXpbMF0sXG4gICAgICAgIHkgPSB4eXpbMV0sXG4gICAgICAgIHogPSB4eXpbMl0sXG4gICAgICAgIGwsIGEsIGI7XG5cbiAgeCAvPSA5NS4wNDc7XG4gIHkgLz0gMTAwO1xuICB6IC89IDEwOC44ODM7XG5cbiAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEvMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG4gIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxLzMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMS8zKSA6ICg3Ljc4NyAqIHopICsgKDE2IC8gMTE2KTtcblxuICBsID0gKDExNiAqIHkpIC0gMTY7XG4gIGEgPSA1MDAgKiAoeCAtIHkpO1xuICBiID0gMjAwICogKHkgLSB6KTtcblxuICByZXR1cm4gW2wsIGEsIGJdO1xufVxuXG5mdW5jdGlvbiByZ2IybGNoKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJsY2gocmdiMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGhzbDJyZ2IoaHNsKSB7XG4gIHZhciBoID0gaHNsWzBdIC8gMzYwLFxuICAgICAgcyA9IGhzbFsxXSAvIDEwMCxcbiAgICAgIGwgPSBoc2xbMl0gLyAxMDAsXG4gICAgICB0MSwgdDIsIHQzLCByZ2IsIHZhbDtcblxuICBpZiAocyA9PSAwKSB7XG4gICAgdmFsID0gbCAqIDI1NTtcbiAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICB9XG5cbiAgaWYgKGwgPCAwLjUpXG4gICAgdDIgPSBsICogKDEgKyBzKTtcbiAgZWxzZVxuICAgIHQyID0gbCArIHMgLSBsICogcztcbiAgdDEgPSAyICogbCAtIHQyO1xuXG4gIHJnYiA9IFswLCAwLCAwXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICB0MyA9IGggKyAxIC8gMyAqIC0gKGkgLSAxKTtcbiAgICB0MyA8IDAgJiYgdDMrKztcbiAgICB0MyA+IDEgJiYgdDMtLTtcblxuICAgIGlmICg2ICogdDMgPCAxKVxuICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgZWxzZSBpZiAoMiAqIHQzIDwgMSlcbiAgICAgIHZhbCA9IHQyO1xuICAgIGVsc2UgaWYgKDMgKiB0MyA8IDIpXG4gICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG4gICAgZWxzZVxuICAgICAgdmFsID0gdDE7XG5cbiAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gIH1cblxuICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoc2wyaHN2KGhzbCkge1xuICB2YXIgaCA9IGhzbFswXSxcbiAgICAgIHMgPSBoc2xbMV0gLyAxMDAsXG4gICAgICBsID0gaHNsWzJdIC8gMTAwLFxuICAgICAgc3YsIHY7XG5cbiAgaWYobCA9PT0gMCkge1xuICAgICAgLy8gbm8gbmVlZCB0byBkbyBjYWxjIG9uIGJsYWNrXG4gICAgICAvLyBhbHNvIGF2b2lkcyBkaXZpZGUgYnkgMCBlcnJvclxuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgfVxuXG4gIGwgKj0gMjtcbiAgcyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcbiAgdiA9IChsICsgcykgLyAyO1xuICBzdiA9ICgyICogcykgLyAobCArIHMpO1xuICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHNsMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzbDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc2wyY215ayhhcmdzKSB7XG4gIHJldHVybiByZ2IyY215ayhoc2wycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHNsMmtleXdvcmQoYXJncykge1xuICByZXR1cm4gcmdiMmtleXdvcmQoaHNsMnJnYihhcmdzKSk7XG59XG5cblxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0gLyA2MCxcbiAgICAgIHMgPSBoc3ZbMV0gLyAxMDAsXG4gICAgICB2ID0gaHN2WzJdIC8gMTAwLFxuICAgICAgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuICB2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpLFxuICAgICAgcCA9IDI1NSAqIHYgKiAoMSAtIHMpLFxuICAgICAgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpLFxuICAgICAgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpLFxuICAgICAgdiA9IDI1NSAqIHY7XG5cbiAgc3dpdGNoKGhpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFt2LCB0LCBwXTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gW3EsIHYsIHBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBbcCwgdiwgdF07XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFtwLCBxLCB2XTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gW3QsIHAsIHZdO1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaHN2MmhzbChoc3YpIHtcbiAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdIC8gMTAwLFxuICAgICAgdiA9IGhzdlsyXSAvIDEwMCxcbiAgICAgIHNsLCBsO1xuXG4gIGwgPSAoMiAtIHMpICogdjtcbiAgc2wgPSBzICogdjtcbiAgc2wgLz0gKGwgPD0gMSkgPyBsIDogMiAtIGw7XG4gIHNsID0gc2wgfHwgMDtcbiAgbCAvPSAyO1xuICByZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn1cblxuZnVuY3Rpb24gaHN2Mmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGhzdjJyZ2IoYXJncykpXG59XG5cbmZ1bmN0aW9uIGhzdjJjbXlrKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJjbXlrKGhzdjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBoc3Yya2V5d29yZChhcmdzKSB7XG4gIHJldHVybiByZ2Iya2V5d29yZChoc3YycmdiKGFyZ3MpKTtcbn1cblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5mdW5jdGlvbiBod2IycmdiKGh3Yikge1xuICB2YXIgaCA9IGh3YlswXSAvIDM2MCxcbiAgICAgIHdoID0gaHdiWzFdIC8gMTAwLFxuICAgICAgYmwgPSBod2JbMl0gLyAxMDAsXG4gICAgICByYXRpbyA9IHdoICsgYmwsXG4gICAgICBpLCB2LCBmLCBuO1xuXG4gIC8vIHdoICsgYmwgY2FudCBiZSA+IDFcbiAgaWYgKHJhdGlvID4gMSkge1xuICAgIHdoIC89IHJhdGlvO1xuICAgIGJsIC89IHJhdGlvO1xuICB9XG5cbiAgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICB2ID0gMSAtIGJsO1xuICBmID0gNiAqIGggLSBpO1xuICBpZiAoKGkgJiAweDAxKSAhPSAwKSB7XG4gICAgZiA9IDEgLSBmO1xuICB9XG4gIG4gPSB3aCArIGYgKiAodiAtIHdoKTsgIC8vIGxpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgc3dpdGNoIChpKSB7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIDY6XG4gICAgY2FzZSAwOiByID0gdjsgZyA9IG47IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAxOiByID0gbjsgZyA9IHY7IGIgPSB3aDsgYnJlYWs7XG4gICAgY2FzZSAyOiByID0gd2g7IGcgPSB2OyBiID0gbjsgYnJlYWs7XG4gICAgY2FzZSAzOiByID0gd2g7IGcgPSBuOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA0OiByID0gbjsgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG4gICAgY2FzZSA1OiByID0gdjsgZyA9IHdoOyBiID0gbjsgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufVxuXG5mdW5jdGlvbiBod2IyaHNsKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc2woaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihod2IycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gaHdiMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoaHdiMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGh3YjJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGh3YjJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMnJnYihjbXlrKSB7XG4gIHZhciBjID0gY215a1swXSAvIDEwMCxcbiAgICAgIG0gPSBjbXlrWzFdIC8gMTAwLFxuICAgICAgeSA9IGNteWtbMl0gLyAxMDAsXG4gICAgICBrID0gY215a1szXSAvIDEwMCxcbiAgICAgIHIsIGcsIGI7XG5cbiAgciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuICBnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG4gIGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn1cblxuZnVuY3Rpb24gY215azJoc2woYXJncykge1xuICByZXR1cm4gcmdiMmhzbChjbXlrMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGNteWsyaHN2KGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJoc3YoY215azJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBjbXlrMmh3YihhcmdzKSB7XG4gIHJldHVybiByZ2IyaHdiKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gY215azJrZXl3b3JkKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJrZXl3b3JkKGNteWsycmdiKGFyZ3MpKTtcbn1cblxuXG5mdW5jdGlvbiB4eXoycmdiKHh5eikge1xuICB2YXIgeCA9IHh5elswXSAvIDEwMCxcbiAgICAgIHkgPSB4eXpbMV0gLyAxMDAsXG4gICAgICB6ID0geHl6WzJdIC8gMTAwLFxuICAgICAgciwgZywgYjtcblxuICByID0gKHggKiAzLjI0MDYpICsgKHkgKiAtMS41MzcyKSArICh6ICogLTAuNDk4Nik7XG4gIGcgPSAoeCAqIC0wLjk2ODkpICsgKHkgKiAxLjg3NTgpICsgKHogKiAwLjA0MTUpO1xuICBiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuICAvLyBhc3N1bWUgc1JHQlxuICByID0gciA+IDAuMDAzMTMwOCA/ICgoMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuICAgIDogciA9IChyICogMTIuOTIpO1xuXG4gIGcgPSBnID4gMC4wMDMxMzA4ID8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG4gICAgOiBnID0gKGcgKiAxMi45Mik7XG5cbiAgYiA9IGIgPiAwLjAwMzEzMDggPyAoKDEuMDU1ICogTWF0aC5wb3coYiwgMS4wIC8gMi40KSkgLSAwLjA1NSlcbiAgICA6IGIgPSAoYiAqIDEyLjkyKTtcblxuICByID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuICBnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuXG4gIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59XG5cbmZ1bmN0aW9uIHh5ejJsYWIoeHl6KSB7XG4gIHZhciB4ID0geHl6WzBdLFxuICAgICAgeSA9IHh5elsxXSxcbiAgICAgIHogPSB4eXpbMl0sXG4gICAgICBsLCBhLCBiO1xuXG4gIHggLz0gOTUuMDQ3O1xuICB5IC89IDEwMDtcbiAgeiAvPSAxMDguODgzO1xuXG4gIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxLzMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMS8zKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcbiAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEvMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cbiAgbCA9ICgxMTYgKiB5KSAtIDE2O1xuICBhID0gNTAwICogKHggLSB5KTtcbiAgYiA9IDIwMCAqICh5IC0geik7XG5cbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24geHl6MmxjaChhcmdzKSB7XG4gIHJldHVybiBsYWIybGNoKHh5ejJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgeCwgeSwgeiwgeTI7XG5cbiAgaWYgKGwgPD0gOCkge1xuICAgIHkgPSAobCAqIDEwMCkgLyA5MDMuMztcbiAgICB5MiA9ICg3Ljc4NyAqICh5IC8gMTAwKSkgKyAoMTYgLyAxMTYpO1xuICB9IGVsc2Uge1xuICAgIHkgPSAxMDAgKiBNYXRoLnBvdygobCArIDE2KSAvIDExNiwgMyk7XG4gICAgeTIgPSBNYXRoLnBvdyh5IC8gMTAwLCAxLzMpO1xuICB9XG5cbiAgeCA9IHggLyA5NS4wNDcgPD0gMC4wMDg4NTYgPyB4ID0gKDk1LjA0NyAqICgoYSAvIDUwMCkgKyB5MiAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogOTUuMDQ3ICogTWF0aC5wb3coKGEgLyA1MDApICsgeTIsIDMpO1xuXG4gIHogPSB6IC8gMTA4Ljg4MyA8PSAwLjAwODg1OSA/IHogPSAoMTA4Ljg4MyAqICh5MiAtIChiIC8gMjAwKSAtICgxNiAvIDExNikpKSAvIDcuNzg3IDogMTA4Ljg4MyAqIE1hdGgucG93KHkyIC0gKGIgLyAyMDApLCAzKTtcblxuICByZXR1cm4gW3gsIHksIHpdO1xufVxuXG5mdW5jdGlvbiBsYWIybGNoKGxhYikge1xuICB2YXIgbCA9IGxhYlswXSxcbiAgICAgIGEgPSBsYWJbMV0sXG4gICAgICBiID0gbGFiWzJdLFxuICAgICAgaHIsIGgsIGM7XG5cbiAgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICBoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcbiAgaWYgKGggPCAwKSB7XG4gICAgaCArPSAzNjA7XG4gIH1cbiAgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgcmV0dXJuIFtsLCBjLCBoXTtcbn1cblxuZnVuY3Rpb24gbGFiMnJnYihhcmdzKSB7XG4gIHJldHVybiB4eXoycmdiKGxhYjJ4eXooYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gybGFiKGxjaCkge1xuICB2YXIgbCA9IGxjaFswXSxcbiAgICAgIGMgPSBsY2hbMV0sXG4gICAgICBoID0gbGNoWzJdLFxuICAgICAgYSwgYiwgaHI7XG5cbiAgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG4gIGEgPSBjICogTWF0aC5jb3MoaHIpO1xuICBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgcmV0dXJuIFtsLCBhLCBiXTtcbn1cblxuZnVuY3Rpb24gbGNoMnh5eihhcmdzKSB7XG4gIHJldHVybiBsYWIyeHl6KGxjaDJsYWIoYXJncykpO1xufVxuXG5mdW5jdGlvbiBsY2gycmdiKGFyZ3MpIHtcbiAgcmV0dXJuIGxhYjJyZ2IobGNoMmxhYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQycmdiKGtleXdvcmQpIHtcbiAgcmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmhzbChhcmdzKSB7XG4gIHJldHVybiByZ2IyaHNsKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJoc3YoYXJncykge1xuICByZXR1cm4gcmdiMmhzdihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIGtleXdvcmQyaHdiKGFyZ3MpIHtcbiAgcmV0dXJuIHJnYjJod2Ioa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmNteWsoYXJncykge1xuICByZXR1cm4gcmdiMmNteWsoa2V5d29yZDJyZ2IoYXJncykpO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkMmxhYihhcmdzKSB7XG4gIHJldHVybiByZ2IybGFiKGtleXdvcmQycmdiKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24ga2V5d29yZDJ4eXooYXJncykge1xuICByZXR1cm4gcmdiMnh5eihrZXl3b3JkMnJnYihhcmdzKSk7XG59XG5cbnZhciBjc3NLZXl3b3JkcyA9IHtcbiAgYWxpY2VibHVlOiAgWzI0MCwyNDgsMjU1XSxcbiAgYW50aXF1ZXdoaXRlOiBbMjUwLDIzNSwyMTVdLFxuICBhcXVhOiBbMCwyNTUsMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywyNTUsMjEyXSxcbiAgYXp1cmU6ICBbMjQwLDI1NSwyNTVdLFxuICBiZWlnZTogIFsyNDUsMjQ1LDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwyMjgsMTk2XSxcbiAgYmxhY2s6ICBbMCwwLDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwyMzUsMjA1XSxcbiAgYmx1ZTogWzAsMCwyNTVdLFxuICBibHVldmlvbGV0OiBbMTM4LDQzLDIyNl0sXG4gIGJyb3duOiAgWzE2NSw0Miw0Ml0sXG4gIGJ1cmx5d29vZDogIFsyMjIsMTg0LDEzNV0sXG4gIGNhZGV0Ymx1ZTogIFs5NSwxNTgsMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywyNTUsMF0sXG4gIGNob2NvbGF0ZTogIFsyMTAsMTA1LDMwXSxcbiAgY29yYWw6ICBbMjU1LDEyNyw4MF0sXG4gIGNvcm5mbG93ZXJibHVlOiBbMTAwLDE0OSwyMzddLFxuICBjb3Juc2lsazogWzI1NSwyNDgsMjIwXSxcbiAgY3JpbXNvbjogIFsyMjAsMjAsNjBdLFxuICBjeWFuOiBbMCwyNTUsMjU1XSxcbiAgZGFya2JsdWU6IFswLDAsMTM5XSxcbiAgZGFya2N5YW46IFswLDEzOSwxMzldLFxuICBkYXJrZ29sZGVucm9kOiAgWzE4NCwxMzQsMTFdLFxuICBkYXJrZ3JheTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2dyZWVuOiAgWzAsMTAwLDBdLFxuICBkYXJrZ3JleTogWzE2OSwxNjksMTY5XSxcbiAgZGFya2toYWtpOiAgWzE4OSwxODMsMTA3XSxcbiAgZGFya21hZ2VudGE6ICBbMTM5LDAsMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwxMDcsNDddLFxuICBkYXJrb3JhbmdlOiBbMjU1LDE0MCwwXSxcbiAgZGFya29yY2hpZDogWzE1Myw1MCwyMDRdLFxuICBkYXJrcmVkOiAgWzEzOSwwLDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLDE1MCwxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsMTg4LDE0M10sXG4gIGRhcmtzbGF0ZWJsdWU6ICBbNzIsNjEsMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogIFs0Nyw3OSw3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6ICBbNDcsNzksNzldLFxuICBkYXJrdHVycXVvaXNlOiAgWzAsMjA2LDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsMCwyMTFdLFxuICBkZWVwcGluazogWzI1NSwyMCwxNDddLFxuICBkZWVwc2t5Ymx1ZTogIFswLDE5MSwyNTVdLFxuICBkaW1ncmF5OiAgWzEwNSwxMDUsMTA1XSxcbiAgZGltZ3JleTogIFsxMDUsMTA1LDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwxNDQsMjU1XSxcbiAgZmlyZWJyaWNrOiAgWzE3OCwzNCwzNF0sXG4gIGZsb3JhbHdoaXRlOiAgWzI1NSwyNTAsMjQwXSxcbiAgZm9yZXN0Z3JlZW46ICBbMzQsMTM5LDM0XSxcbiAgZnVjaHNpYTogIFsyNTUsMCwyNTVdLFxuICBnYWluc2Jvcm86ICBbMjIwLDIyMCwyMjBdLFxuICBnaG9zdHdoaXRlOiBbMjQ4LDI0OCwyNTVdLFxuICBnb2xkOiBbMjU1LDIxNSwwXSxcbiAgZ29sZGVucm9kOiAgWzIxOCwxNjUsMzJdLFxuICBncmF5OiBbMTI4LDEyOCwxMjhdLFxuICBncmVlbjogIFswLDEyOCwwXSxcbiAgZ3JlZW55ZWxsb3c6ICBbMTczLDI1NSw0N10sXG4gIGdyZXk6IFsxMjgsMTI4LDEyOF0sXG4gIGhvbmV5ZGV3OiBbMjQwLDI1NSwyNDBdLFxuICBob3RwaW5rOiAgWzI1NSwxMDUsMTgwXSxcbiAgaW5kaWFucmVkOiAgWzIwNSw5Miw5Ml0sXG4gIGluZGlnbzogWzc1LDAsMTMwXSxcbiAgaXZvcnk6ICBbMjU1LDI1NSwyNDBdLFxuICBraGFraTogIFsyNDAsMjMwLDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLDIzMCwyNTBdLFxuICBsYXZlbmRlcmJsdXNoOiAgWzI1NSwyNDAsMjQ1XSxcbiAgbGF3bmdyZWVuOiAgWzEyNCwyNTIsMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwyNTAsMjA1XSxcbiAgbGlnaHRibHVlOiAgWzE3MywyMTYsMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwxMjgsMTI4XSxcbiAgbGlnaHRjeWFuOiAgWzIyNCwyNTUsMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsMjUwLDIxMF0sXG4gIGxpZ2h0Z3JheTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsMjM4LDE0NF0sXG4gIGxpZ2h0Z3JleTogIFsyMTEsMjExLDIxMV0sXG4gIGxpZ2h0cGluazogIFsyNTUsMTgyLDE5M10sXG4gIGxpZ2h0c2FsbW9uOiAgWzI1NSwxNjAsMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogIFszMiwxNzgsMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LDIwNiwyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwxMzYsMTUzXSxcbiAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksMTM2LDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LDE5NiwyMjJdLFxuICBsaWdodHllbGxvdzogIFsyNTUsMjU1LDIyNF0sXG4gIGxpbWU6IFswLDI1NSwwXSxcbiAgbGltZWdyZWVuOiAgWzUwLDIwNSw1MF0sXG4gIGxpbmVuOiAgWzI1MCwyNDAsMjMwXSxcbiAgbWFnZW50YTogIFsyNTUsMCwyNTVdLFxuICBtYXJvb246IFsxMjgsMCwwXSxcbiAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwyMDUsMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsMCwyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsODUsMjExXSxcbiAgbWVkaXVtcHVycGxlOiBbMTQ3LDExMiwyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLDE3OSwxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICBbMTIzLDEwNCwyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogIFswLDI1MCwxNTRdLFxuICBtZWRpdW10dXJxdW9pc2U6ICBbNzIsMjA5LDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogIFsxOTksMjEsMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsMjUsMTEyXSxcbiAgbWludGNyZWFtOiAgWzI0NSwyNTUsMjUwXSxcbiAgbWlzdHlyb3NlOiAgWzI1NSwyMjgsMjI1XSxcbiAgbW9jY2FzaW46IFsyNTUsMjI4LDE4MV0sXG4gIG5hdmFqb3doaXRlOiAgWzI1NSwyMjIsMTczXSxcbiAgbmF2eTogWzAsMCwxMjhdLFxuICBvbGRsYWNlOiAgWzI1MywyNDUsMjMwXSxcbiAgb2xpdmU6ICBbMTI4LDEyOCwwXSxcbiAgb2xpdmVkcmFiOiAgWzEwNywxNDIsMzVdLFxuICBvcmFuZ2U6IFsyNTUsMTY1LDBdLFxuICBvcmFuZ2VyZWQ6ICBbMjU1LDY5LDBdLFxuICBvcmNoaWQ6IFsyMTgsMTEyLDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6ICBbMjM4LDIzMiwxNzBdLFxuICBwYWxlZ3JlZW46ICBbMTUyLDI1MSwxNTJdLFxuICBwYWxldHVycXVvaXNlOiAgWzE3NSwyMzgsMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogIFsyMTksMTEyLDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsMjM5LDIxM10sXG4gIHBlYWNocHVmZjogIFsyNTUsMjE4LDE4NV0sXG4gIHBlcnU6IFsyMDUsMTMzLDYzXSxcbiAgcGluazogWzI1NSwxOTIsMjAzXSxcbiAgcGx1bTogWzIyMSwxNjAsMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwyMjQsMjMwXSxcbiAgcHVycGxlOiBbMTI4LDAsMTI4XSxcbiAgcmViZWNjYXB1cnBsZTogWzEwMiwgNTEsIDE1M10sXG4gIHJlZDogIFsyNTUsMCwwXSxcbiAgcm9zeWJyb3duOiAgWzE4OCwxNDMsMTQzXSxcbiAgcm95YWxibHVlOiAgWzY1LDEwNSwyMjVdLFxuICBzYWRkbGVicm93bjogIFsxMzksNjksMTldLFxuICBzYWxtb246IFsyNTAsMTI4LDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsMTY0LDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwxMzksODddLFxuICBzZWFzaGVsbDogWzI1NSwyNDUsMjM4XSxcbiAgc2llbm5hOiBbMTYwLDgyLDQ1XSxcbiAgc2lsdmVyOiBbMTkyLDE5MiwxOTJdLFxuICBza3libHVlOiAgWzEzNSwyMDYsMjM1XSxcbiAgc2xhdGVibHVlOiAgWzEwNiw5MCwyMDVdLFxuICBzbGF0ZWdyYXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbGF0ZWdyZXk6ICBbMTEyLDEyOCwxNDRdLFxuICBzbm93OiBbMjU1LDI1MCwyNTBdLFxuICBzcHJpbmdncmVlbjogIFswLDI1NSwxMjddLFxuICBzdGVlbGJsdWU6ICBbNzAsMTMwLDE4MF0sXG4gIHRhbjogIFsyMTAsMTgwLDE0MF0sXG4gIHRlYWw6IFswLDEyOCwxMjhdLFxuICB0aGlzdGxlOiAgWzIxNiwxOTEsMjE2XSxcbiAgdG9tYXRvOiBbMjU1LDk5LDcxXSxcbiAgdHVycXVvaXNlOiAgWzY0LDIyNCwyMDhdLFxuICB2aW9sZXQ6IFsyMzgsMTMwLDIzOF0sXG4gIHdoZWF0OiAgWzI0NSwyMjIsMTc5XSxcbiAgd2hpdGU6ICBbMjU1LDI1NSwyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LDI0NSwyNDVdLFxuICB5ZWxsb3c6IFsyNTUsMjU1LDBdLFxuICB5ZWxsb3dncmVlbjogIFsxNTQsMjA1LDUwXVxufTtcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNzc0tleXdvcmRzKSB7XG4gIHJldmVyc2VLZXl3b3Jkc1tKU09OLnN0cmluZ2lmeShjc3NLZXl3b3Jkc1trZXldKV0gPSBrZXk7XG59XG5cbnZhciBjb252ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gbmV3IENvbnZlcnRlcigpO1xufTtcblxuZm9yICh2YXIgZnVuYyBpbiBjb252ZXJzaW9ucykge1xuICAvLyBleHBvcnQgUmF3IHZlcnNpb25zXG4gIGNvbnZlcnRbZnVuYyArIFwiUmF3XCJdID0gIChmdW5jdGlvbihmdW5jKSB7XG4gICAgLy8gYWNjZXB0IGFycmF5IG9yIHBsYWluIGFyZ3NcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNvbnZlcnNpb25zW2Z1bmNdKGFyZyk7XG4gICAgfVxuICB9KShmdW5jKTtcblxuICB2YXIgcGFpciA9IC8oXFx3KykyKFxcdyspLy5leGVjKGZ1bmMpLFxuICAgICAgZnJvbSA9IHBhaXJbMV0sXG4gICAgICB0byA9IHBhaXJbMl07XG5cbiAgLy8gZXhwb3J0IHJnYjJoc2wgYW5kIFtcInJnYlwiXVtcImhzbFwiXVxuICBjb252ZXJ0W2Zyb21dID0gY29udmVydFtmcm9tXSB8fCB7fTtcblxuICBjb252ZXJ0W2Zyb21dW3RvXSA9IGNvbnZlcnRbZnVuY10gPSAoZnVuY3Rpb24oZnVuYykgeyBcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PSBcIm51bWJlclwiKVxuICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgXG4gICAgICB2YXIgdmFsID0gY29udmVyc2lvbnNbZnVuY10oYXJnKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09IFwic3RyaW5nXCIgfHwgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB2YWw7IC8vIGtleXdvcmRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspXG4gICAgICAgIHZhbFtpXSA9IE1hdGgucm91bmQodmFsW2ldKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9KShmdW5jKTtcbn1cblxuXG4vKiBDb252ZXJ0ZXIgZG9lcyBsYXp5IGNvbnZlcnNpb24gYW5kIGNhY2hpbmcgKi9cbnZhciBDb252ZXJ0ZXIgPSBmdW5jdGlvbigpIHtcbiAgIHRoaXMuY29udnMgPSB7fTtcbn07XG5cbi8qIEVpdGhlciBnZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSBvclxuICBzZXQgdGhlIHZhbHVlcyBmb3IgYSBzcGFjZSwgZGVwZW5kaW5nIG9uIGFyZ3MgKi9cbkNvbnZlcnRlci5wcm90b3R5cGUucm91dGVTcGFjZSA9IGZ1bmN0aW9uKHNwYWNlLCBhcmdzKSB7XG4gICB2YXIgdmFsdWVzID0gYXJnc1swXTtcbiAgIGlmICh2YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY29sb3IucmdiKClcbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlcyhzcGFjZSk7XG4gICB9XG4gICAvLyBjb2xvci5yZ2IoMTAsIDEwLCAxMClcbiAgIGlmICh0eXBlb2YgdmFsdWVzID09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhbHVlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpOyAgICAgICAgXG4gICB9XG5cbiAgIHJldHVybiB0aGlzLnNldFZhbHVlcyhzcGFjZSwgdmFsdWVzKTtcbn07XG4gIFxuLyogU2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UsIGludmFsaWRhdGluZyBjYWNoZSAqL1xuQ29udmVydGVyLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbihzcGFjZSwgdmFsdWVzKSB7XG4gICB0aGlzLnNwYWNlID0gc3BhY2U7XG4gICB0aGlzLmNvbnZzID0ge307XG4gICB0aGlzLmNvbnZzW3NwYWNlXSA9IHZhbHVlcztcbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyogR2V0IHRoZSB2YWx1ZXMgZm9yIGEgc3BhY2UuIElmIHRoZXJlJ3MgYWxyZWFkeVxuICBhIGNvbnZlcnNpb24gZm9yIHRoZSBzcGFjZSwgZmV0Y2ggaXQsIG90aGVyd2lzZVxuICBjb21wdXRlIGl0ICovXG5Db252ZXJ0ZXIucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uKHNwYWNlKSB7XG4gICB2YXIgdmFscyA9IHRoaXMuY29udnNbc3BhY2VdO1xuICAgaWYgKCF2YWxzKSB7XG4gICAgICB2YXIgZnNwYWNlID0gdGhpcy5zcGFjZSxcbiAgICAgICAgICBmcm9tID0gdGhpcy5jb252c1tmc3BhY2VdO1xuICAgICAgdmFscyA9IGNvbnZlcnRbZnNwYWNlXVtzcGFjZV0oZnJvbSk7XG5cbiAgICAgIHRoaXMuY29udnNbc3BhY2VdID0gdmFscztcbiAgIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG5bXCJyZ2JcIiwgXCJoc2xcIiwgXCJoc3ZcIiwgXCJjbXlrXCIsIFwia2V5d29yZFwiXS5mb3JFYWNoKGZ1bmN0aW9uKHNwYWNlKSB7XG4gICBDb252ZXJ0ZXIucHJvdG90eXBlW3NwYWNlXSA9IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvdXRlU3BhY2Uoc3BhY2UsIGFyZ3VtZW50cyk7XG4gICB9O1xufSk7XG5cbnZhciBjb2xvckNvbnZlcnQgPSBjb252ZXJ0O1xuXG52YXIgY29sb3JOYW1lID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTtcblxuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG52YXIgY29sb3JTdHJpbmcgPSB7XG4gICBnZXRSZ2JhOiBnZXRSZ2JhLFxuICAgZ2V0SHNsYTogZ2V0SHNsYSxcbiAgIGdldFJnYjogZ2V0UmdiLFxuICAgZ2V0SHNsOiBnZXRIc2wsXG4gICBnZXRId2I6IGdldEh3YixcbiAgIGdldEFscGhhOiBnZXRBbHBoYSxcblxuICAgaGV4U3RyaW5nOiBoZXhTdHJpbmcsXG4gICByZ2JTdHJpbmc6IHJnYlN0cmluZyxcbiAgIHJnYmFTdHJpbmc6IHJnYmFTdHJpbmcsXG4gICBwZXJjZW50U3RyaW5nOiBwZXJjZW50U3RyaW5nLFxuICAgcGVyY2VudGFTdHJpbmc6IHBlcmNlbnRhU3RyaW5nLFxuICAgaHNsU3RyaW5nOiBoc2xTdHJpbmcsXG4gICBoc2xhU3RyaW5nOiBoc2xhU3RyaW5nLFxuICAgaHdiU3RyaW5nOiBod2JTdHJpbmcsXG4gICBrZXl3b3JkOiBrZXl3b3JkXG59O1xuXG5mdW5jdGlvbiBnZXRSZ2JhKHN0cmluZykge1xuICAgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBhYmJyID0gIC9eIyhbYS1mQS1GMC05XXszLDR9KSQvaSxcbiAgICAgICBoZXggPSAgL14jKFthLWZBLUYwLTldezZ9KFthLWZBLUYwLTldezJ9KT8pJC9pLFxuICAgICAgIHJnYmEgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkL2ksXG4gICAgICAgcGVyID0gL15yZ2JhP1xcKFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC9pLFxuICAgICAgIGtleXdvcmQgPSAvKFxcdyspLztcblxuICAgdmFyIHJnYiA9IFswLCAwLCAwXSxcbiAgICAgICBhID0gMSxcbiAgICAgICBtYXRjaCA9IHN0cmluZy5tYXRjaChhYmJyKSxcbiAgICAgICBoZXhBbHBoYSA9IFwiXCI7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBoZXhBbHBoYSA9IG1hdGNoWzNdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHJnYltpXSA9IHBhcnNlSW50KG1hdGNoW2ldICsgbWF0Y2hbaV0sIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgICAgYSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhICsgaGV4QWxwaGEsIDE2KSAvIDI1NSkgKiAxMDApIC8gMTAwO1xuICAgICAgfVxuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuICAgICAgaGV4QWxwaGEgPSBtYXRjaFsyXTtcbiAgICAgIG1hdGNoID0gbWF0Y2hbMV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2guc2xpY2UoaSAqIDIsIGkgKiAyICsgMiksIDE2KTtcbiAgICAgIH1cbiAgICAgIGlmIChoZXhBbHBoYSkge1xuICAgICAgICAgYSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhLCAxNikgLyAyNTUpICogMTAwKSAvIDEwMDtcbiAgICAgIH1cbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHJnYmEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgcmdiW2ldID0gcGFyc2VJbnQobWF0Y2hbaSArIDFdKTtcbiAgICAgIH1cbiAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcbiAgIH1cbiAgIGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHBlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICByZ2JbaV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWF0Y2hbaSArIDFdKSAqIDIuNTUpO1xuICAgICAgfVxuICAgICAgYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgfVxuICAgZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goa2V5d29yZCkpIHtcbiAgICAgIGlmIChtYXRjaFsxXSA9PSBcInRyYW5zcGFyZW50XCIpIHtcbiAgICAgICAgIHJldHVybiBbMCwgMCwgMCwgMF07XG4gICAgICB9XG4gICAgICByZ2IgPSBjb2xvck5hbWVbbWF0Y2hbMV1dO1xuICAgICAgaWYgKCFyZ2IpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgIH1cblxuICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZ2IubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJnYltpXSA9IHNjYWxlKHJnYltpXSwgMCwgMjU1KTtcbiAgIH1cbiAgIGlmICghYSAmJiBhICE9IDApIHtcbiAgICAgIGEgPSAxO1xuICAgfVxuICAgZWxzZSB7XG4gICAgICBhID0gc2NhbGUoYSwgMCwgMSk7XG4gICB9XG4gICByZ2JbM10gPSBhO1xuICAgcmV0dXJuIHJnYjtcbn1cblxuZnVuY3Rpb24gZ2V0SHNsYShzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHNsID0gL15oc2xhP1xcKFxccyooWystXT9cXGQrKSg/OmRlZyk/XFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkvO1xuICAgdmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKGhzbCk7XG4gICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuICAgICAgdmFyIGggPSBzY2FsZShwYXJzZUludChtYXRjaFsxXSksIDAsIDM2MCksXG4gICAgICAgICAgcyA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApLFxuICAgICAgICAgIGwgPSBzY2FsZShwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKSxcbiAgICAgICAgICBhID0gc2NhbGUoaXNOYU4oYWxwaGEpID8gMSA6IGFscGhhLCAwLCAxKTtcbiAgICAgIHJldHVybiBbaCwgcywgbCwgYV07XG4gICB9XG59XG5cbmZ1bmN0aW9uIGdldEh3YihzdHJpbmcpIHtcbiAgIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICB9XG4gICB2YXIgaHdiID0gL15od2JcXChcXHMqKFsrLV0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpLztcbiAgIHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChod2IpO1xuICAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGFscGhhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG4gICAgICB2YXIgaCA9IHNjYWxlKHBhcnNlSW50KG1hdGNoWzFdKSwgMCwgMzYwKSxcbiAgICAgICAgICB3ID0gc2NhbGUocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCksXG4gICAgICAgICAgYiA9IHNjYWxlKHBhcnNlRmxvYXQobWF0Y2hbM10pLCAwLCAxMDApLFxuICAgICAgICAgIGEgPSBzY2FsZShpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuICAgICAgcmV0dXJuIFtoLCB3LCBiLCBhXTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmdiKHN0cmluZykge1xuICAgdmFyIHJnYmEgPSBnZXRSZ2JhKHN0cmluZyk7XG4gICByZXR1cm4gcmdiYSAmJiByZ2JhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRIc2woc3RyaW5nKSB7XG4gIHZhciBoc2xhID0gZ2V0SHNsYShzdHJpbmcpO1xuICByZXR1cm4gaHNsYSAmJiBoc2xhLnNsaWNlKDAsIDMpO1xufVxuXG5mdW5jdGlvbiBnZXRBbHBoYShzdHJpbmcpIHtcbiAgIHZhciB2YWxzID0gZ2V0UmdiYShzdHJpbmcpO1xuICAgaWYgKHZhbHMpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxuICAgZWxzZSBpZiAodmFscyA9IGdldEhzbGEoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHZhbHNbM107XG4gICB9XG4gICBlbHNlIGlmICh2YWxzID0gZ2V0SHdiKHN0cmluZykpIHtcbiAgICAgIHJldHVybiB2YWxzWzNdO1xuICAgfVxufVxuXG4vLyBnZW5lcmF0b3JzXG5mdW5jdGlvbiBoZXhTdHJpbmcocmdiYSwgYSkge1xuICAgdmFyIGEgPSAoYSAhPT0gdW5kZWZpbmVkICYmIHJnYmEubGVuZ3RoID09PSAzKSA/IGEgOiByZ2JhWzNdO1xuICAgcmV0dXJuIFwiI1wiICsgaGV4RG91YmxlKHJnYmFbMF0pIFxuICAgICAgICAgICAgICArIGhleERvdWJsZShyZ2JhWzFdKVxuICAgICAgICAgICAgICArIGhleERvdWJsZShyZ2JhWzJdKVxuICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgKGEgPj0gMCAmJiBhIDwgMSlcbiAgICAgICAgICAgICAgICAgPyBoZXhEb3VibGUoTWF0aC5yb3VuZChhICogMjU1KSlcbiAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICk7XG59XG5cbmZ1bmN0aW9uIHJnYlN0cmluZyhyZ2JhLCBhbHBoYSkge1xuICAgaWYgKGFscGhhIDwgMSB8fCAocmdiYVszXSAmJiByZ2JhWzNdIDwgMSkpIHtcbiAgICAgIHJldHVybiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKTtcbiAgIH1cbiAgIHJldHVybiBcInJnYihcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiByZ2JhU3RyaW5nKHJnYmEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAocmdiYVszXSAhPT0gdW5kZWZpbmVkID8gcmdiYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwicmdiYShcIiArIHJnYmFbMF0gKyBcIiwgXCIgKyByZ2JhWzFdICsgXCIsIFwiICsgcmdiYVsyXVxuICAgICAgICAgICArIFwiLCBcIiArIGFscGhhICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIHBlcmNlbnRTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKHJnYmFbM10gJiYgcmdiYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpO1xuICAgfVxuICAgdmFyIHIgPSBNYXRoLnJvdW5kKHJnYmFbMF0vMjU1ICogMTAwKSxcbiAgICAgICBnID0gTWF0aC5yb3VuZChyZ2JhWzFdLzI1NSAqIDEwMCksXG4gICAgICAgYiA9IE1hdGgucm91bmQocmdiYVsyXS8yNTUgKiAxMDApO1xuXG4gICByZXR1cm4gXCJyZ2IoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSlcIjtcbn1cblxuZnVuY3Rpb24gcGVyY2VudGFTdHJpbmcocmdiYSwgYWxwaGEpIHtcbiAgIHZhciByID0gTWF0aC5yb3VuZChyZ2JhWzBdLzI1NSAqIDEwMCksXG4gICAgICAgZyA9IE1hdGgucm91bmQocmdiYVsxXS8yNTUgKiAxMDApLFxuICAgICAgIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0vMjU1ICogMTAwKTtcbiAgIHJldHVybiBcInJnYmEoXCIgKyByICsgXCIlLCBcIiArIGcgKyBcIiUsIFwiICsgYiArIFwiJSwgXCIgKyAoYWxwaGEgfHwgcmdiYVszXSB8fCAxKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xTdHJpbmcoaHNsYSwgYWxwaGEpIHtcbiAgIGlmIChhbHBoYSA8IDEgfHwgKGhzbGFbM10gJiYgaHNsYVszXSA8IDEpKSB7XG4gICAgICByZXR1cm4gaHNsYVN0cmluZyhoc2xhLCBhbHBoYSk7XG4gICB9XG4gICByZXR1cm4gXCJoc2woXCIgKyBoc2xhWzBdICsgXCIsIFwiICsgaHNsYVsxXSArIFwiJSwgXCIgKyBoc2xhWzJdICsgXCIlKVwiO1xufVxuXG5mdW5jdGlvbiBoc2xhU3RyaW5nKGhzbGEsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHNsYVszXSAhPT0gdW5kZWZpbmVkID8gaHNsYVszXSA6IDEpO1xuICAgfVxuICAgcmV0dXJuIFwiaHNsYShcIiArIGhzbGFbMF0gKyBcIiwgXCIgKyBoc2xhWzFdICsgXCIlLCBcIiArIGhzbGFbMl0gKyBcIiUsIFwiXG4gICAgICAgICAgICsgYWxwaGEgKyBcIilcIjtcbn1cblxuLy8gaHdiIGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHJnYihhKSAmIGhzbChhKSBzaW5jZSB0aGVyZSBpcyBubyBhbHBoYSBzcGVjaWZpYyBzeW50YXhcbi8vIChod2IgaGF2ZSBhbHBoYSBvcHRpb25hbCAmIDEgaXMgZGVmYXVsdCB2YWx1ZSlcbmZ1bmN0aW9uIGh3YlN0cmluZyhod2IsIGFscGhhKSB7XG4gICBpZiAoYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWxwaGEgPSAoaHdiWzNdICE9PSB1bmRlZmluZWQgPyBod2JbM10gOiAxKTtcbiAgIH1cbiAgIHJldHVybiBcImh3YihcIiArIGh3YlswXSArIFwiLCBcIiArIGh3YlsxXSArIFwiJSwgXCIgKyBod2JbMl0gKyBcIiVcIlxuICAgICAgICAgICArIChhbHBoYSAhPT0gdW5kZWZpbmVkICYmIGFscGhhICE9PSAxID8gXCIsIFwiICsgYWxwaGEgOiBcIlwiKSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkKHJnYikge1xuICByZXR1cm4gcmV2ZXJzZU5hbWVzW3JnYi5zbGljZSgwLCAzKV07XG59XG5cbi8vIGhlbHBlcnNcbmZ1bmN0aW9uIHNjYWxlKG51bSwgbWluLCBtYXgpIHtcbiAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIG51bSksIG1heCk7XG59XG5cbmZ1bmN0aW9uIGhleERvdWJsZShudW0pIHtcbiAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgcmV0dXJuIChzdHIubGVuZ3RoIDwgMikgPyBcIjBcIiArIHN0ciA6IHN0cjtcbn1cblxuXG4vL2NyZWF0ZSBhIGxpc3Qgb2YgcmV2ZXJzZSBjb2xvciBuYW1lc1xudmFyIHJldmVyc2VOYW1lcyA9IHt9O1xuZm9yICh2YXIgbmFtZSBpbiBjb2xvck5hbWUpIHtcbiAgIHJldmVyc2VOYW1lc1tjb2xvck5hbWVbbmFtZV1dID0gbmFtZTtcbn1cblxuLyogTUlUIGxpY2Vuc2UgKi9cblxuXG5cbnZhciBDb2xvciA9IGZ1bmN0aW9uIChvYmopIHtcblx0aWYgKG9iaiBpbnN0YW5jZW9mIENvbG9yKSB7XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29sb3IpKSB7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcihvYmopO1xuXHR9XG5cblx0dGhpcy52YWxpZCA9IGZhbHNlO1xuXHR0aGlzLnZhbHVlcyA9IHtcblx0XHRyZ2I6IFswLCAwLCAwXSxcblx0XHRoc2w6IFswLCAwLCAwXSxcblx0XHRoc3Y6IFswLCAwLCAwXSxcblx0XHRod2I6IFswLCAwLCAwXSxcblx0XHRjbXlrOiBbMCwgMCwgMCwgMF0sXG5cdFx0YWxwaGE6IDFcblx0fTtcblxuXHQvLyBwYXJzZSBDb2xvcigpIGFyZ3VtZW50XG5cdHZhciB2YWxzO1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcblx0XHR2YWxzID0gY29sb3JTdHJpbmcuZ2V0UmdiYShvYmopO1xuXHRcdGlmICh2YWxzKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gY29sb3JTdHJpbmcuZ2V0SHNsYShvYmopKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzID0gY29sb3JTdHJpbmcuZ2V0SHdiKG9iaikpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcblx0XHR2YWxzID0gb2JqO1xuXHRcdGlmICh2YWxzLnIgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnJlZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLmwgIT09IHVuZGVmaW5lZCB8fCB2YWxzLmxpZ2h0bmVzcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgdmFscyk7XG5cdFx0fSBlbHNlIGlmICh2YWxzLnYgIT09IHVuZGVmaW5lZCB8fCB2YWxzLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdoc3YnLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMudyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMud2hpdGVuZXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWVzKCdod2InLCB2YWxzKTtcblx0XHR9IGVsc2UgaWYgKHZhbHMuYyAhPT0gdW5kZWZpbmVkIHx8IHZhbHMuY3lhbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnNldFZhbHVlcygnY215aycsIHZhbHMpO1xuXHRcdH1cblx0fVxufTtcblxuQ29sb3IucHJvdG90eXBlID0ge1xuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsaWQ7XG5cdH0sXG5cdHJnYjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdyZ2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRoc2w6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRTcGFjZSgnaHNsJywgYXJndW1lbnRzKTtcblx0fSxcblx0aHN2OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2hzdicsIGFyZ3VtZW50cyk7XG5cdH0sXG5cdGh3YjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNldFNwYWNlKCdod2InLCBhcmd1bWVudHMpO1xuXHR9LFxuXHRjbXlrOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0U3BhY2UoJ2NteWsnLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdHJnYkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVzLnJnYjtcblx0fSxcblx0aHNsQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuaHNsO1xuXHR9LFxuXHRoc3ZBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlcy5oc3Y7XG5cdH0sXG5cdGh3YkFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdGlmICh2YWx1ZXMuYWxwaGEgIT09IDEpIHtcblx0XHRcdHJldHVybiB2YWx1ZXMuaHdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZXMuaHdiO1xuXHR9LFxuXHRjbXlrQXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMuY215aztcblx0fSxcblx0cmdiYUFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdHJldHVybiB2YWx1ZXMucmdiLmNvbmNhdChbdmFsdWVzLmFscGhhXSk7XG5cdH0sXG5cdGhzbGFBcnJheTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0XHRyZXR1cm4gdmFsdWVzLmhzbC5jb25jYXQoW3ZhbHVlcy5hbHBoYV0pO1xuXHR9LFxuXHRhbHBoYTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVzLmFscGhhO1xuXHRcdH1cblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCB2YWwpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlZDogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDAsIHZhbCk7XG5cdH0sXG5cdGdyZWVuOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgncmdiJywgMSwgdmFsKTtcblx0fSxcblx0Ymx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ3JnYicsIDIsIHZhbCk7XG5cdH0sXG5cdGh1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdGlmICh2YWwpIHtcblx0XHRcdHZhbCAlPSAzNjA7XG5cdFx0XHR2YWwgPSB2YWwgPCAwID8gMzYwICsgdmFsIDogdmFsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc2wnLCAwLCB2YWwpO1xuXHR9LFxuXHRzYXR1cmF0aW9uOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMSwgdmFsKTtcblx0fSxcblx0bGlnaHRuZXNzOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2V0Q2hhbm5lbCgnaHNsJywgMiwgdmFsKTtcblx0fSxcblx0c2F0dXJhdGlvbnY6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdoc3YnLCAxLCB2YWwpO1xuXHR9LFxuXHR3aGl0ZW5lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAxLCB2YWwpO1xuXHR9LFxuXHRibGFja25lc3M6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdod2InLCAyLCB2YWwpO1xuXHR9LFxuXHR2YWx1ZTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2hzdicsIDIsIHZhbCk7XG5cdH0sXG5cdGN5YW46IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMCwgdmFsKTtcblx0fSxcblx0bWFnZW50YTogZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB0aGlzLnNldENoYW5uZWwoJ2NteWsnLCAxLCB2YWwpO1xuXHR9LFxuXHR5ZWxsb3c6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMiwgdmFsKTtcblx0fSxcblx0YmxhY2s6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdGhpcy5zZXRDaGFubmVsKCdjbXlrJywgMywgdmFsKTtcblx0fSxcblxuXHRoZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaGV4U3RyaW5nKHRoaXMudmFsdWVzLnJnYik7XG5cdH0sXG5cdHJnYlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5yZ2JTdHJpbmcodGhpcy52YWx1ZXMucmdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdHJnYmFTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcucmdiYVN0cmluZyh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblx0cGVyY2VudFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5wZXJjZW50U3RyaW5nKHRoaXMudmFsdWVzLnJnYiwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcuaHNsU3RyaW5nKHRoaXMudmFsdWVzLmhzbCwgdGhpcy52YWx1ZXMuYWxwaGEpO1xuXHR9LFxuXHRoc2xhU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLmhzbGFTdHJpbmcodGhpcy52YWx1ZXMuaHNsLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGh3YlN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBjb2xvclN0cmluZy5od2JTdHJpbmcodGhpcy52YWx1ZXMuaHdiLCB0aGlzLnZhbHVlcy5hbHBoYSk7XG5cdH0sXG5cdGtleXdvcmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gY29sb3JTdHJpbmcua2V5d29yZCh0aGlzLnZhbHVlcy5yZ2IsIHRoaXMudmFsdWVzLmFscGhhKTtcblx0fSxcblxuXHRyZ2JOdW1iZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHJldHVybiAocmdiWzBdIDw8IDE2KSB8IChyZ2JbMV0gPDwgOCkgfCByZ2JbMl07XG5cdH0sXG5cblx0bHVtaW5vc2l0eTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jcmVsYXRpdmVsdW1pbmFuY2VkZWZcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciBsdW0gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJnYi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGNoYW4gPSByZ2JbaV0gLyAyNTU7XG5cdFx0XHRsdW1baV0gPSAoY2hhbiA8PSAwLjAzOTI4KSA/IGNoYW4gLyAxMi45MiA6IE1hdGgucG93KCgoY2hhbiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuMjEyNiAqIGx1bVswXSArIDAuNzE1MiAqIGx1bVsxXSArIDAuMDcyMiAqIGx1bVsyXTtcblx0fSxcblxuXHRjb250cmFzdDogZnVuY3Rpb24gKGNvbG9yMikge1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1dDQUcyMC8jY29udHJhc3QtcmF0aW9kZWZcblx0XHR2YXIgbHVtMSA9IHRoaXMubHVtaW5vc2l0eSgpO1xuXHRcdHZhciBsdW0yID0gY29sb3IyLmx1bWlub3NpdHkoKTtcblx0XHRpZiAobHVtMSA+IGx1bTIpIHtcblx0XHRcdHJldHVybiAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KTtcblx0XHR9XG5cdFx0cmV0dXJuIChsdW0yICsgMC4wNSkgLyAobHVtMSArIDAuMDUpO1xuXHR9LFxuXG5cdGxldmVsOiBmdW5jdGlvbiAoY29sb3IyKSB7XG5cdFx0dmFyIGNvbnRyYXN0UmF0aW8gPSB0aGlzLmNvbnRyYXN0KGNvbG9yMik7XG5cdFx0aWYgKGNvbnRyYXN0UmF0aW8gPj0gNy4xKSB7XG5cdFx0XHRyZXR1cm4gJ0FBQSc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChjb250cmFzdFJhdGlvID49IDQuNSkgPyAnQUEnIDogJyc7XG5cdH0sXG5cblx0ZGFyazogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFlJUSBlcXVhdGlvbiBmcm9tIGh0dHA6Ly8yNHdheXMub3JnLzIwMTAvY2FsY3VsYXRpbmctY29sb3ItY29udHJhc3Rcblx0XHR2YXIgcmdiID0gdGhpcy52YWx1ZXMucmdiO1xuXHRcdHZhciB5aXEgPSAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvIDEwMDA7XG5cdFx0cmV0dXJuIHlpcSA8IDEyODtcblx0fSxcblxuXHRsaWdodDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5kYXJrKCk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSAyNTUgLSB0aGlzLnZhbHVlcy5yZ2JbaV07XG5cdFx0fVxuXHRcdHRoaXMuc2V0VmFsdWVzKCdyZ2InLCByZ2IpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGxpZ2h0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzJdICs9IGhzbFsyXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRhcmtlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMudmFsdWVzLmhzbDtcblx0XHRoc2xbMl0gLT0gaHNsWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2hzbCcsIGhzbCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdICs9IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGRlc2F0dXJhdGU6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLnZhbHVlcy5oc2w7XG5cdFx0aHNsWzFdIC09IGhzbFsxXSAqIHJhdGlvO1xuXHRcdHRoaXMuc2V0VmFsdWVzKCdoc2wnLCBoc2wpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdoaXRlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMV0gKz0gaHdiWzFdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YmxhY2tlbjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGh3YiA9IHRoaXMudmFsdWVzLmh3Yjtcblx0XHRod2JbMl0gKz0gaHdiWzJdICogcmF0aW87XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2h3YicsIGh3Yik7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z3JleXNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMudmFsdWVzLnJnYjtcblx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyYXlzY2FsZSNDb252ZXJ0aW5nX2NvbG9yX3RvX2dyYXlzY2FsZVxuXHRcdHZhciB2YWwgPSByZ2JbMF0gKiAwLjMgKyByZ2JbMV0gKiAwLjU5ICsgcmdiWzJdICogMC4xMTtcblx0XHR0aGlzLnNldFZhbHVlcygncmdiJywgW3ZhbCwgdmFsLCB2YWxdKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbGVhcmVyOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgYWxwaGEgPSB0aGlzLnZhbHVlcy5hbHBoYTtcblx0XHR0aGlzLnNldFZhbHVlcygnYWxwaGEnLCBhbHBoYSAtIChhbHBoYSAqIHJhdGlvKSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b3BhcXVlcjogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0dmFyIGFscGhhID0gdGhpcy52YWx1ZXMuYWxwaGE7XG5cdFx0dGhpcy5zZXRWYWx1ZXMoJ2FscGhhJywgYWxwaGEgKyAoYWxwaGEgKiByYXRpbykpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24gKGRlZ3JlZXMpIHtcblx0XHR2YXIgaHNsID0gdGhpcy52YWx1ZXMuaHNsO1xuXHRcdHZhciBodWUgPSAoaHNsWzBdICsgZGVncmVlcykgJSAzNjA7XG5cdFx0aHNsWzBdID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblx0XHR0aGlzLnNldFZhbHVlcygnaHNsJywgaHNsKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogUG9ydGVkIGZyb20gc2FzcyBpbXBsZW1lbnRhdGlvbiBpbiBDXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXNzL2xpYnNhc3MvYmxvYi8wZTZiNGEyODUwMDkyMzU2YWEzZWNlMDdjNmIyNDlmMDIyMWNhY2VkL2Z1bmN0aW9ucy5jcHAjTDIwOVxuXHQgKi9cblx0bWl4OiBmdW5jdGlvbiAobWl4aW5Db2xvciwgd2VpZ2h0KSB7XG5cdFx0dmFyIGNvbG9yMSA9IHRoaXM7XG5cdFx0dmFyIGNvbG9yMiA9IG1peGluQ29sb3I7XG5cdFx0dmFyIHAgPSB3ZWlnaHQgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHdlaWdodDtcblxuXHRcdHZhciB3ID0gMiAqIHAgLSAxO1xuXHRcdHZhciBhID0gY29sb3IxLmFscGhhKCkgLSBjb2xvcjIuYWxwaGEoKTtcblxuXHRcdHZhciB3MSA9ICgoKHcgKiBhID09PSAtMSkgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuXHRcdHZhciB3MiA9IDEgLSB3MTtcblxuXHRcdHJldHVybiB0aGlzXG5cdFx0XHQucmdiKFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5yZWQoKSArIHcyICogY29sb3IyLnJlZCgpLFxuXHRcdFx0XHR3MSAqIGNvbG9yMS5ncmVlbigpICsgdzIgKiBjb2xvcjIuZ3JlZW4oKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuYmx1ZSgpICsgdzIgKiBjb2xvcjIuYmx1ZSgpXG5cdFx0XHQpXG5cdFx0XHQuYWxwaGEoY29sb3IxLmFscGhhKCkgKiBwICsgY29sb3IyLmFscGhhKCkgKiAoMSAtIHApKTtcblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZ2IoKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIE5PVEUoU0IpOiB1c2luZyBub2RlLWNsb25lIGNyZWF0ZXMgYSBkZXBlbmRlbmN5IHRvIEJ1ZmZlciB3aGVuIHVzaW5nIGJyb3dzZXJpZnksXG5cdFx0Ly8gbWFraW5nIHRoZSBmaW5hbCBidWlsZCB3YXkgdG8gYmlnIHRvIGVtYmVkIGluIENoYXJ0LmpzLiBTbyBsZXQncyBkbyBpdCBtYW51YWxseSxcblx0XHQvLyBhc3N1bWluZyB0aGF0IHZhbHVlcyB0byBjbG9uZSBhcmUgMSBkaW1lbnNpb24gYXJyYXlzIGNvbnRhaW5pbmcgb25seSBudW1iZXJzLFxuXHRcdC8vIGV4Y2VwdCAnYWxwaGEnIHdoaWNoIGlzIGEgbnVtYmVyLlxuXHRcdHZhciByZXN1bHQgPSBuZXcgQ29sb3IoKTtcblx0XHR2YXIgc291cmNlID0gdGhpcy52YWx1ZXM7XG5cdFx0dmFyIHRhcmdldCA9IHJlc3VsdC52YWx1ZXM7XG5cdFx0dmFyIHZhbHVlLCB0eXBlO1xuXG5cdFx0Zm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcblx0XHRcdGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0dmFsdWUgPSBzb3VyY2VbcHJvcF07XG5cdFx0XHRcdHR5cGUgPSAoe30pLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuXHRcdFx0XHRcdHRhcmdldFtwcm9wXSA9IHZhbHVlLnNsaWNlKDApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcigndW5leHBlY3RlZCBjb2xvciB2YWx1ZTonLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc3BhY2VzID0ge1xuXHRyZ2I6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSxcblx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRoc3Y6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAndmFsdWUnXSxcblx0aHdiOiBbJ2h1ZScsICd3aGl0ZW5lc3MnLCAnYmxhY2tuZXNzJ10sXG5cdGNteWs6IFsnY3lhbicsICdtYWdlbnRhJywgJ3llbGxvdycsICdibGFjayddXG59O1xuXG5Db2xvci5wcm90b3R5cGUubWF4ZXMgPSB7XG5cdHJnYjogWzI1NSwgMjU1LCAyNTVdLFxuXHRoc2w6IFszNjAsIDEwMCwgMTAwXSxcblx0aHN2OiBbMzYwLCAxMDAsIDEwMF0sXG5cdGh3YjogWzM2MCwgMTAwLCAxMDBdLFxuXHRjbXlrOiBbMTAwLCAxMDAsIDEwMCwgMTAwXVxufTtcblxuQ29sb3IucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uIChzcGFjZSkge1xuXHR2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdHZhciB2YWxzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdHZhbHNbc3BhY2UuY2hhckF0KGkpXSA9IHZhbHVlc1tzcGFjZV1baV07XG5cdH1cblxuXHRpZiAodmFsdWVzLmFscGhhICE9PSAxKSB7XG5cdFx0dmFscy5hID0gdmFsdWVzLmFscGhhO1xuXHR9XG5cblx0Ly8ge3I6IDI1NSwgZzogMjU1LCBiOiAyNTUsIGE6IDAuNH1cblx0cmV0dXJuIHZhbHM7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gKHNwYWNlLCB2YWxzKSB7XG5cdHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcblx0dmFyIHNwYWNlcyA9IHRoaXMuc3BhY2VzO1xuXHR2YXIgbWF4ZXMgPSB0aGlzLm1heGVzO1xuXHR2YXIgYWxwaGEgPSAxO1xuXHR2YXIgaTtcblxuXHR0aGlzLnZhbGlkID0gdHJ1ZTtcblxuXHRpZiAoc3BhY2UgPT09ICdhbHBoYScpIHtcblx0XHRhbHBoYSA9IHZhbHM7XG5cdH0gZWxzZSBpZiAodmFscy5sZW5ndGgpIHtcblx0XHQvLyBbMTAsIDEwLCAxMF1cblx0XHR2YWx1ZXNbc3BhY2VdID0gdmFscy5zbGljZSgwLCBzcGFjZS5sZW5ndGgpO1xuXHRcdGFscGhhID0gdmFsc1tzcGFjZS5sZW5ndGhdO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2UuY2hhckF0KDApXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8ge3I6IDEwLCBnOiAxMCwgYjogMTB9XG5cdFx0Zm9yIChpID0gMDsgaSA8IHNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YWx1ZXNbc3BhY2VdW2ldID0gdmFsc1tzcGFjZS5jaGFyQXQoaSldO1xuXHRcdH1cblxuXHRcdGFscGhhID0gdmFscy5hO1xuXHR9IGVsc2UgaWYgKHZhbHNbc3BhY2VzW3NwYWNlXVswXV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIHtyZWQ6IDEwLCBncmVlbjogMTAsIGJsdWU6IDEwfVxuXHRcdHZhciBjaGFucyA9IHNwYWNlc1tzcGFjZV07XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhbHVlc1tzcGFjZV1baV0gPSB2YWxzW2NoYW5zW2ldXTtcblx0XHR9XG5cblx0XHRhbHBoYSA9IHZhbHMuYWxwaGE7XG5cdH1cblxuXHR2YWx1ZXMuYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoYWxwaGEgPT09IHVuZGVmaW5lZCA/IHZhbHVlcy5hbHBoYSA6IGFscGhhKSkpO1xuXG5cdGlmIChzcGFjZSA9PT0gJ2FscGhhJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBjYXBwZWQ7XG5cblx0Ly8gY2FwIHZhbHVlcyBvZiB0aGUgc3BhY2UgcHJpb3IgY29udmVydGluZyBhbGwgdmFsdWVzXG5cdGZvciAoaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdGNhcHBlZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG1heGVzW3NwYWNlXVtpXSwgdmFsdWVzW3NwYWNlXVtpXSkpO1xuXHRcdHZhbHVlc1tzcGFjZV1baV0gPSBNYXRoLnJvdW5kKGNhcHBlZCk7XG5cdH1cblxuXHQvLyBjb252ZXJ0IHRvIGFsbCB0aGUgb3RoZXIgY29sb3Igc3BhY2VzXG5cdGZvciAodmFyIHNuYW1lIGluIHNwYWNlcykge1xuXHRcdGlmIChzbmFtZSAhPT0gc3BhY2UpIHtcblx0XHRcdHZhbHVlc1tzbmFtZV0gPSBjb2xvckNvbnZlcnRbc3BhY2VdW3NuYW1lXSh2YWx1ZXNbc3BhY2VdKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRTcGFjZSA9IGZ1bmN0aW9uIChzcGFjZSwgYXJncykge1xuXHR2YXIgdmFscyA9IGFyZ3NbMF07XG5cblx0aWYgKHZhbHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIGNvbG9yLnJnYigpXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmFsdWVzKHNwYWNlKTtcblx0fVxuXG5cdC8vIGNvbG9yLnJnYigxMCwgMTAsIDEwKVxuXHRpZiAodHlwZW9mIHZhbHMgPT09ICdudW1iZXInKSB7XG5cdFx0dmFscyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuXHR9XG5cblx0dGhpcy5zZXRWYWx1ZXMoc3BhY2UsIHZhbHMpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbkNvbG9yLnByb3RvdHlwZS5zZXRDaGFubmVsID0gZnVuY3Rpb24gKHNwYWNlLCBpbmRleCwgdmFsKSB7XG5cdHZhciBzdmFsdWVzID0gdGhpcy52YWx1ZXNbc3BhY2VdO1xuXHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHQvLyBjb2xvci5yZWQoKVxuXHRcdHJldHVybiBzdmFsdWVzW2luZGV4XTtcblx0fSBlbHNlIGlmICh2YWwgPT09IHN2YWx1ZXNbaW5kZXhdKSB7XG5cdFx0Ly8gY29sb3IucmVkKGNvbG9yLnJlZCgpKVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Ly8gY29sb3IucmVkKDEwMClcblx0c3ZhbHVlc1tpbmRleF0gPSB2YWw7XG5cdHRoaXMuc2V0VmFsdWVzKHNwYWNlLCBzdmFsdWVzKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHR3aW5kb3cuQ29sb3IgPSBDb2xvcjtcbn1cblxudmFyIGNoYXJ0anNDb2xvciA9IENvbG9yO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVyc1xuICovXG52YXIgaGVscGVycyA9IHtcblx0LyoqXG5cdCAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG5cdCAqL1xuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdW5pcXVlIGlkLCBzZXF1ZW50aWFsbHkgZ2VuZXJhdGVkIGZyb20gYSBnbG9iYWwgdmFyaWFibGUuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0dWlkOiAoZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlkID0gMDtcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gaWQrKztcblx0XHR9O1xuXHR9KCkpLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBuZWl0aGVyIG51bGwgbm9yIHVuZGVmaW5lZCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGlzTnVsbE9yVW5kZWY6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IChpbmNsdWRpbmcgdHlwZWQgYXJyYXlzKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGlzQXJyYXk6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdFx0aWYgKHR5cGUuc3Vic3RyKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zdWJzdHIoLTYpID09PSAnQXJyYXldJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IChleGNsdWRpbmcgbnVsbCksIGVsc2UgcmV0dXJucyBmYWxzZS5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICogQHNpbmNlIDIuNy4wXG5cdCAqL1xuXHRpc09iamVjdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSByZXR1cm5zIGZhbHNlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aXNGaW5pdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0cmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYHZhbHVlYCBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHR2YWx1ZU9yRGVmYXVsdDogZnVuY3Rpb24odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdmFsdWUgYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gYXJyYXkgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSAtIFRoZSBhcnJheSB0byBsb29rdXAgZm9yIHZhbHVlIGF0IGBpbmRleGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbiBgdmFsdWVgIHRvIGxvb2t1cCBmb3IgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVbaW5kZXhdYCBpcyB1bmRlZmluZWQuXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0dmFsdWVBdEluZGV4T3JEZWZhdWx0OiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdHJldHVybiBoZWxwZXJzLnZhbHVlT3JEZWZhdWx0KGhlbHBlcnMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVtpbmRleF0gOiB2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgYGZuYCB3aXRoIHRoZSBnaXZlbiBgYXJnc2AgaW4gdGhlIHNjb3BlIGRlZmluZWQgYnkgYHRoaXNBcmdgIGFuZCByZXR1cm5zIHRoZVxuXHQgKiB2YWx1ZSByZXR1cm5lZCBieSBgZm5gLiBJZiBgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uLCB0aGlzIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZC5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbC5cblx0ICogQHBhcmFtIHtBcnJheXx1bmRlZmluZWR8bnVsbH0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNhbGxiYWNrOiBmdW5jdGlvbihmbiwgYXJncywgdGhpc0FyZykge1xuXHRcdGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG5cdCAqIGlzIHVua25vd24gb3IgaW4gbm9uZSBpbnRlbnNpdmUgY29kZSAobm90IGNhbGxlZCBvZnRlbiBhbmQgc21hbGwgbG9vcGFibGUpLiBFbHNlXG5cdCAqIGl0J3MgcHJlZmVyYWJsZSB0byB1c2UgYSByZWd1bGFyIGZvcigpIGxvb3AgYW5kIHNhdmUgZXh0cmEgZnVuY3Rpb24gY2FsbHMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fEFycmF5fSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuXHQgKi9cblx0ZWFjaDogZnVuY3Rpb24obG9vcGFibGUsIGZuLCB0aGlzQXJnLCByZXZlcnNlKSB7XG5cdFx0dmFyIGksIGxlbiwga2V5cztcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KGxvb3BhYmxlKSkge1xuXHRcdFx0bGVuID0gbG9vcGFibGUubGVuZ3RoO1xuXHRcdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGhlbHBlcnMuaXNPYmplY3QobG9vcGFibGUpKSB7XG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuXHRcdFx0bGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Zm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuXHQgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDg1Mzk3NFxuXHQgKiBAcGFyYW0ge0FycmF5fSBhMCAtIFRoZSBhcnJheSB0byBjb21wYXJlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRhcnJheUVxdWFsczogZnVuY3Rpb24oYTAsIGExKSB7XG5cdFx0dmFyIGksIGlsZW4sIHYwLCB2MTtcblxuXHRcdGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0djAgPSBhMFtpXTtcblx0XHRcdHYxID0gYTFbaV07XG5cblx0XHRcdGlmICh2MCBpbnN0YW5jZW9mIEFycmF5ICYmIHYxIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdFx0aWYgKCFoZWxwZXJzLmFycmF5RXF1YWxzKHYwLCB2MSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodjAgIT09IHYxKSB7XG5cdFx0XHRcdC8vIE5PVEU6IHR3byBkaWZmZXJlbnQgb2JqZWN0IGluc3RhbmNlcyB3aWxsIG5ldmVyIGJlIGVxdWFsOiB7eDoyMH0gIT0ge3g6MjB9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIGRlZXAgY29weSBvZiBgc291cmNlYCB3aXRob3V0IGtlZXBpbmcgcmVmZXJlbmNlcyBvbiBvYmplY3RzIGFuZCBhcnJheXMuXG5cdCAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHZhbHVlIHRvIGNsb25lLlxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNsb25lOiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRpZiAoaGVscGVycy5pc0FycmF5KHNvdXJjZSkpIHtcblx0XHRcdHJldHVybiBzb3VyY2UubWFwKGhlbHBlcnMuY2xvbmUpO1xuXHRcdH1cblxuXHRcdGlmIChoZWxwZXJzLmlzT2JqZWN0KHNvdXJjZSkpIHtcblx0XHRcdHZhciB0YXJnZXQgPSB7fTtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcblx0XHRcdHZhciBrbGVuID0ga2V5cy5sZW5ndGg7XG5cdFx0XHR2YXIgayA9IDA7XG5cblx0XHRcdGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG5cdFx0XHRcdHRhcmdldFtrZXlzW2tdXSA9IGhlbHBlcnMuY2xvbmUoc291cmNlW2tleXNba11dKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc291cmNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCBtZXJnZXIgd2hlbiBDaGFydC5oZWxwZXJzLm1lcmdlIGlzIGNhbGxlZCB3aXRob3V0IG1lcmdlciBvcHRpb24uXG5cdCAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzLmNsb25lKHN2YWwpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogTWVyZ2VzIHNvdXJjZVtrZXldIGluIHRhcmdldFtrZXldIG9ubHkgaWYgdGFyZ2V0W2tleV0gaXMgdW5kZWZpbmVkLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X21lcmdlcklmOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlKSB7XG5cdFx0dmFyIHR2YWwgPSB0YXJnZXRba2V5XTtcblx0XHR2YXIgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG5cdFx0aWYgKGhlbHBlcnMuaXNPYmplY3QodHZhbCkgJiYgaGVscGVycy5pc09iamVjdChzdmFsKSkge1xuXHRcdFx0aGVscGVycy5tZXJnZUlmKHR2YWwsIHN2YWwpO1xuXHRcdH0gZWxzZSBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IGhlbHBlcnMuY2xvbmUoc3ZhbCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMubWVyZ2VyXSAtIFRoZSBtZXJnZSBtZXRob2QgKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRtZXJnZTogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHR2YXIgc291cmNlcyA9IGhlbHBlcnMuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG5cdFx0dmFyIGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblx0XHR2YXIgbWVyZ2UsIGksIGtleXMsIGtsZW4sIGs7XG5cblx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3QodGFyZ2V0KSkge1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRtZXJnZSA9IG9wdGlvbnMubWVyZ2VyIHx8IGhlbHBlcnMuX21lcmdlcjtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbaV07XG5cdFx0XHRpZiAoIWhlbHBlcnMuaXNPYmplY3Qoc291cmNlKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG5cdFx0XHRmb3IgKGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcblx0XHRcdFx0bWVyZ2Uoa2V5c1trXSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuXHQgKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIGB0YXJnZXRgIG9iamVjdC5cblx0ICovXG5cdG1lcmdlSWY6IGZ1bmN0aW9uKHRhcmdldCwgc291cmNlKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMubWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IGhlbHBlcnMuX21lcmdlcklmfSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFwcGxpZXMgdGhlIGNvbnRlbnRzIG9mIHR3byBvciBtb3JlIG9iamVjdHMgdG9nZXRoZXIgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIG9iamVjdHMgYXJlIG1lcmdlZCBpbnRvLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJnMSAtIE9iamVjdCBjb250YWluaW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdOIC0gQWRkaXRpb25hbCBvYmplY3RzIGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBtZXJnZSBpbiB0YXJnZXQuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBgdGFyZ2V0YCBvYmplY3QuXG5cdCAqL1xuXHRleHRlbmQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHRcdHZhciBzZXRGbiA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdHRhcmdldFtrZXldID0gdmFsdWU7XG5cdFx0fTtcblx0XHRmb3IgKHZhciBpID0gMSwgaWxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGhlbHBlcnMuZWFjaChhcmd1bWVudHNbaV0sIHNldEZuKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fSxcblxuXHQvKipcblx0ICogQmFzaWMgamF2YXNjcmlwdCBpbmhlcml0YW5jZSBiYXNlZCBvbiB0aGUgbW9kZWwgY3JlYXRlZCBpbiBCYWNrYm9uZS5qc1xuXHQgKi9cblx0aW5oZXJpdHM6IGZ1bmN0aW9uKGV4dGVuc2lvbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBDaGFydEVsZW1lbnQgPSAoZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpKSA/IGV4dGVuc2lvbnMuY29uc3RydWN0b3IgOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHR2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmNvbnN0cnVjdG9yID0gQ2hhcnRFbGVtZW50O1xuXHRcdH07XG5cblx0XHRTdXJyb2dhdGUucHJvdG90eXBlID0gbWUucHJvdG90eXBlO1xuXHRcdENoYXJ0RWxlbWVudC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlKCk7XG5cdFx0Q2hhcnRFbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMuaW5oZXJpdHM7XG5cblx0XHRpZiAoZXh0ZW5zaW9ucykge1xuXHRcdFx0aGVscGVycy5leHRlbmQoQ2hhcnRFbGVtZW50LnByb3RvdHlwZSwgZXh0ZW5zaW9ucyk7XG5cdFx0fVxuXG5cdFx0Q2hhcnRFbGVtZW50Ll9fc3VwZXJfXyA9IG1lLnByb3RvdHlwZTtcblx0XHRyZXR1cm4gQ2hhcnRFbGVtZW50O1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19jb3JlID0gaGVscGVycztcblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLmNhbGxiYWNrIGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5jYWxsQ2FsbGJhY2tcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMuY2FsbENhbGxiYWNrID0gaGVscGVycy5jYWxsYmFjaztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGluc3RlYWQuXG4gKiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhLCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuaW5kZXhPZlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb21JbmRleCkge1xuXHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnJheSwgaXRlbSwgZnJvbUluZGV4KTtcbn07XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlT3JEZWZhdWx0IGluc3RlYWQuXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycy5nZXRWYWx1ZU9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVPckRlZmF1bHQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHVzZSBDaGFydC5oZWxwZXJzLnZhbHVlQXRJbmRleE9yRGVmYXVsdCBpbnN0ZWFkLlxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuZ2V0VmFsdWVBdEluZGV4T3JEZWZhdWx0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzLmdldFZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMudmFsdWVBdEluZGV4T3JEZWZhdWx0O1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZ0VmZmVjdHNcbiAqIEBzZWUgaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy9cbiAqL1xudmFyIGVmZmVjdHMgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0O1xuXHR9LFxuXG5cdGVhc2VJblF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQ7XG5cdH0sXG5cblx0ZWFzZU91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLXQgKiAodCAtIDIpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSk7XG5cdH0sXG5cblx0ZWFzZUluQ3ViaWM6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0O1xuXHR9LFxuXG5cdGVhc2VPdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiB0ICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMik7XG5cdH0sXG5cblx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLSgodCA9IHQgLSAxKSAqIHQgKiB0ICogdCAtIDEpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogdCAqIHQgKiB0ICogdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKTtcblx0fSxcblxuXHRlYXNlSW5RdWludDogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcblx0fSxcblxuXHRlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gKHQgPSB0IC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMTtcblx0fSxcblxuXHRlYXNlSW5PdXRRdWludDogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xuXHR9LFxuXG5cdGVhc2VJblNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLU1hdGguY29zKHQgKiAoTWF0aC5QSSAvIDIpKSArIDE7XG5cdH0sXG5cblx0ZWFzZU91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gTWF0aC5zaW4odCAqIChNYXRoLlBJIC8gMikpO1xuXHR9LFxuXG5cdGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcblx0XHRyZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcblx0fSxcblxuXHRlYXNlSW5FeHBvOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuXHR9LFxuXG5cdGVhc2VPdXRFeHBvOiBmdW5jdGlvbih0KSB7XG5cdFx0cmV0dXJuICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxO1xuXHR9LFxuXG5cdGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCh0IC89IDAuNSkgPCAxKSB7XG5cdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpO1xuXHR9LFxuXG5cdGVhc2VJbkNpcmM6IGZ1bmN0aW9uKHQpIHtcblx0XHRpZiAodCA+PSAxKSB7XG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9XG5cdFx0cmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0fSxcblxuXHRlYXNlT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQoMSAtICh0ID0gdCAtIDEpICogdCk7XG5cdH0sXG5cblx0ZWFzZUluT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuXHRcdGlmICgodCAvPSAwLjUpIDwgMSkge1xuXHRcdFx0cmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcblx0fSxcblxuXHRlYXNlSW5FbGFzdGljOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHZhciBwID0gMDtcblx0XHR2YXIgYSA9IDE7XG5cdFx0aWYgKHQgPT09IDApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblx0XHRpZiAodCA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdGlmICghcCkge1xuXHRcdFx0cCA9IDAuMztcblx0XHR9XG5cdFx0aWYgKGEgPCAxKSB7XG5cdFx0XHRhID0gMTtcblx0XHRcdHMgPSBwIC8gNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cyA9IHAgLyAoMiAqIE1hdGguUEkpICogTWF0aC5hc2luKDEgLyBhKTtcblx0XHR9XG5cdFx0cmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG5cdH0sXG5cblx0ZWFzZU91dEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcblx0XHR2YXIgcyA9IDEuNzAxNTg7XG5cdFx0dmFyIHAgPSAwO1xuXHRcdHZhciBhID0gMTtcblx0XHRpZiAodCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXHRcdGlmICh0ID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0aWYgKCFwKSB7XG5cdFx0XHRwID0gMC4zO1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHR2YXIgcCA9IDA7XG5cdFx0dmFyIGEgPSAxO1xuXHRcdGlmICh0ID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cdFx0aWYgKCh0IC89IDAuNSkgPT09IDIpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRpZiAoIXApIHtcblx0XHRcdHAgPSAwLjQ1O1xuXHRcdH1cblx0XHRpZiAoYSA8IDEpIHtcblx0XHRcdGEgPSAxO1xuXHRcdFx0cyA9IHAgLyA0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuXHRcdH1cblx0XHRpZiAodCA8IDEpIHtcblx0XHRcdHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqICh0IC09IDEpKSAqIE1hdGguc2luKCh0IC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXHR9LFxuXHRlYXNlSW5CYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuXHR9LFxuXG5cdGVhc2VPdXRCYWNrOiBmdW5jdGlvbih0KSB7XG5cdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdHJldHVybiAodCA9IHQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG5cdH0sXG5cblx0ZWFzZUluT3V0QmFjazogZnVuY3Rpb24odCkge1xuXHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRpZiAoKHQgLz0gMC41KSA8IDEpIHtcblx0XHRcdHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuXHRcdH1cblx0XHRyZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuXHR9LFxuXG5cdGVhc2VJbkJvdW5jZTogZnVuY3Rpb24odCkge1xuXHRcdHJldHVybiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KTtcblx0fSxcblxuXHRlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAoMSAvIDIuNzUpKSB7XG5cdFx0XHRyZXR1cm4gNy41NjI1ICogdCAqIHQ7XG5cdFx0fVxuXHRcdGlmICh0IDwgKDIgLyAyLjc1KSkge1xuXHRcdFx0cmV0dXJuIDcuNTYyNSAqICh0IC09ICgxLjUgLyAyLjc1KSkgKiB0ICsgMC43NTtcblx0XHR9XG5cdFx0aWYgKHQgPCAoMi41IC8gMi43NSkpIHtcblx0XHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMi4yNSAvIDIuNzUpKSAqIHQgKyAwLjkzNzU7XG5cdFx0fVxuXHRcdHJldHVybiA3LjU2MjUgKiAodCAtPSAoMi42MjUgLyAyLjc1KSkgKiB0ICsgMC45ODQzNzU7XG5cdH0sXG5cblx0ZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG5cdFx0aWYgKHQgPCAwLjUpIHtcblx0XHRcdHJldHVybiBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjU7XG5cdFx0fVxuXHRcdHJldHVybiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNTtcblx0fVxufTtcblxudmFyIGhlbHBlcnNfZWFzaW5nID0ge1xuXHRlZmZlY3RzOiBlZmZlY3RzXG59O1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nLmVmZmVjdHMgaW5zdGVhZC5cbiAqIEBmdW5jdGlvbiBDaGFydC5oZWxwZXJzLmVhc2luZ0VmZmVjdHNcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnNfY29yZS5lYXNpbmdFZmZlY3RzID0gZWZmZWN0cztcblxudmFyIFBJID0gTWF0aC5QSTtcbnZhciBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xudmFyIERPVUJMRV9QSSA9IFBJICogMjtcbnZhciBIQUxGX1BJID0gUEkgLyAyO1xudmFyIFFVQVJURVJfUEkgPSBQSSAvIDQ7XG52YXIgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNhbnZhc1xuICovXG52YXIgZXhwb3J0cyQxID0ge1xuXHQvKipcblx0ICogQ2xlYXJzIHRoZSBlbnRpcmUgY2FudmFzIGFzc29jaWF0ZWQgdG8gdGhlIGdpdmVuIGBjaGFydGAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGZvciB3aGljaCB0byBjbGVhciB0aGUgY2FudmFzLlxuXHQgKi9cblx0Y2xlYXI6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0Y2hhcnQuY3R4LmNsZWFyUmVjdCgwLCAwLCBjaGFydC53aWR0aCwgY2hhcnQuaGVpZ2h0KTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIFwicGF0aFwiIGZvciBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycyBhdCBwb3NpdGlvbiAoeCwgeSkgd2l0aCBhXG5cdCAqIGdpdmVuIHNpemUgKHdpZHRoLCBoZWlnaHQpIGFuZCB0aGUgc2FtZSBgcmFkaXVzYCBmb3IgYWxsIGNvcm5lcnMuXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBUaGUgY2FudmFzIDJEIENvbnRleHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIHggYXhpcyBvZiB0aGUgY29vcmRpbmF0ZSBmb3IgdGhlIHJlY3RhbmdsZSBzdGFydGluZyBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgeSBheGlzIG9mIHRoZSBjb29yZGluYXRlIGZvciB0aGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIHBvaW50LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgcmVjdGFuZ2xlJ3Mgd2lkdGguXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgcmVjdGFuZ2xlJ3MgaGVpZ2h0LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJvdW5kZWQgYW1vdW50IChpbiBwaXhlbHMpIGZvciB0aGUgZm91ciBjb3JuZXJzLlxuXHQgKiBAdG9kbyBoYW5kbGUgYHJhZGl1c2AgYXMgdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLXJpZ2h0LCBib3R0b20tbGVmdCBhcnJheS9vYmplY3Q/XG5cdCAqL1xuXHRyb3VuZGVkUmVjdDogZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcblx0XHRpZiAocmFkaXVzKSB7XG5cdFx0XHR2YXIgciA9IE1hdGgubWluKHJhZGl1cywgaGVpZ2h0IC8gMiwgd2lkdGggLyAyKTtcblx0XHRcdHZhciBsZWZ0ID0geCArIHI7XG5cdFx0XHR2YXIgdG9wID0geSArIHI7XG5cdFx0XHR2YXIgcmlnaHQgPSB4ICsgd2lkdGggLSByO1xuXHRcdFx0dmFyIGJvdHRvbSA9IHkgKyBoZWlnaHQgLSByO1xuXG5cdFx0XHRjdHgubW92ZVRvKHgsIHRvcCk7XG5cdFx0XHRpZiAobGVmdCA8IHJpZ2h0ICYmIHRvcCA8IGJvdHRvbSkge1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCAtSEFMRl9QSSk7XG5cdFx0XHRcdGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIDApO1xuXHRcdFx0XHRjdHguYXJjKHJpZ2h0LCBib3R0b20sIHIsIDAsIEhBTEZfUEkpO1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIGJvdHRvbSwgciwgSEFMRl9QSSwgUEkpO1xuXHRcdFx0fSBlbHNlIGlmIChsZWZ0IDwgcmlnaHQpIHtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhsZWZ0LCB5KTtcblx0XHRcdFx0Y3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgSEFMRl9QSSk7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgdG9wLCByLCBIQUxGX1BJLCBQSSArIEhBTEZfUEkpO1xuXHRcdFx0fSBlbHNlIGlmICh0b3AgPCBib3R0b20pIHtcblx0XHRcdFx0Y3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1QSSwgMCk7XG5cdFx0XHRcdGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCAwLCBQSSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHguYXJjKGxlZnQsIHRvcCwgciwgLVBJLCBQSSk7XG5cdFx0XHR9XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhd1BvaW50OiBmdW5jdGlvbihjdHgsIHN0eWxlLCByYWRpdXMsIHgsIHksIHJvdGF0aW9uKSB7XG5cdFx0dmFyIHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIGNvcm5lclJhZGl1cztcblx0XHR2YXIgcmFkID0gKHJvdGF0aW9uIHx8IDApICogUkFEX1BFUl9ERUc7XG5cblx0XHRpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0dHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcblx0XHRcdFx0Y3R4LmRyYXdJbWFnZShzdHlsZSwgeCAtIHN0eWxlLndpZHRoIC8gMiwgeSAtIHN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRzd2l0Y2ggKHN0eWxlKSB7XG5cdFx0Ly8gRGVmYXVsdCBpbmNsdWRlcyBjaXJjbGVcblx0XHRkZWZhdWx0OlxuXHRcdFx0Y3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIERPVUJMRV9QSSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICd0cmlhbmdsZSc6XG5cdFx0XHRjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRyYWQgKz0gVFdPX1RISVJEU19QSTtcblx0XHRcdGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcblx0XHRcdHJhZCArPSBUV09fVEhJUkRTX1BJO1xuXHRcdFx0Y3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAncmVjdFJvdW5kZWQnOlxuXHRcdFx0Ly8gTk9URTogdGhlIHJvdW5kZWQgcmVjdCBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIHRvIHVzZSBgYXJjYCBpbnN0ZWFkIG9mXG5cdFx0XHQvLyBgcXVhZHJhdGljQ3VydmVUb2Agc2luY2UgaXQgZ2VuZXJhdGVzIGJldHRlciByZXN1bHRzIHdoZW4gcmVjdCBpc1xuXHRcdFx0Ly8gYWxtb3N0IGEgY2lyY2xlLiAwLjUxNiAoaW5zdGVhZCBvZiAwLjUpIHByb2R1Y2VzIHJlc3VsdHMgd2l0aCB2aXN1YWxseVxuXHRcdFx0Ly8gY2xvc2VyIHByb3BvcnRpb24gdG8gdGhlIHByZXZpb3VzIGltcGwgYW5kIGl0IGlzIGluc2NyaWJlZCBpbiB0aGVcblx0XHRcdC8vIGNpcmNsZSB3aXRoIGByYWRpdXNgLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZvbGxvd2luZyBQUnM6XG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTU5N1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU4NThcblx0XHRcdGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuXHRcdFx0c2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuXHRcdFx0Y3R4LmFyYyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuXHRcdFx0Y3R4LmFyYyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcblx0XHRcdGN0eC5hcmMoeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG5cdFx0XHRjdHguYXJjKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdyZWN0Jzpcblx0XHRcdGlmICghcm90YXRpb24pIHtcblx0XHRcdFx0c2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcblx0XHRcdFx0Y3R4LnJlY3QoeCAtIHNpemUsIHkgLSBzaXplLCAyICogc2l6ZSwgMiAqIHNpemUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgJ3JlY3RSb3QnOlxuXHRcdFx0eE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG5cdFx0XHR5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcblx0XHRcdGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcblx0XHRcdGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcblx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2Nyb3NzUm90Jzpcblx0XHRcdHJhZCArPSBRVUFSVEVSX1BJO1xuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgJ2Nyb3NzJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdzdGFyJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRyYWQgKz0gUVVBUlRFUl9QSTtcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsaW5lJzpcblx0XHRcdHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuXHRcdFx0eU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG5cdFx0XHRjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG5cdFx0XHRjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdkYXNoJzpcblx0XHRcdGN0eC5tb3ZlVG8oeCwgeSk7XG5cdFx0XHRjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogcmFkaXVzLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRjdHguZmlsbCgpO1xuXHRcdGN0eC5zdHJva2UoKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdFxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJlYSAtIFRoZSByZWN0YW5nbGVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaXNQb2ludEluQXJlYTogZnVuY3Rpb24ocG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgZXBzaWxvbiA9IDFlLTY7IC8vIDFlLTYgaXMgbWFyZ2luIGluIHBpeGVscyBmb3IgYWNjdW11bGF0ZWQgZXJyb3IuXG5cblx0XHRyZXR1cm4gcG9pbnQueCA+IGFyZWEubGVmdCAtIGVwc2lsb24gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBlcHNpbG9uICYmXG5cdFx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBlcHNpbG9uICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIGVwc2lsb247XG5cdH0sXG5cblx0Y2xpcEFyZWE6IGZ1bmN0aW9uKGN0eCwgYXJlYSkge1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuXHRcdGN0eC5jbGlwKCk7XG5cdH0sXG5cblx0dW5jbGlwQXJlYTogZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fSxcblxuXHRsaW5lVG86IGZ1bmN0aW9uKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCkge1xuXHRcdHZhciBzdGVwcGVkID0gdGFyZ2V0LnN0ZXBwZWRMaW5lO1xuXHRcdGlmIChzdGVwcGVkKSB7XG5cdFx0XHRpZiAoc3RlcHBlZCA9PT0gJ21pZGRsZScpIHtcblx0XHRcdFx0dmFyIG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG5cdFx0XHRcdGN0eC5saW5lVG8obWlkcG9pbnQsIGZsaXAgPyB0YXJnZXQueSA6IHByZXZpb3VzLnkpO1xuXHRcdFx0XHRjdHgubGluZVRvKG1pZHBvaW50LCBmbGlwID8gcHJldmlvdXMueSA6IHRhcmdldC55KTtcblx0XHRcdH0gZWxzZSBpZiAoKHN0ZXBwZWQgPT09ICdhZnRlcicgJiYgIWZsaXApIHx8IChzdGVwcGVkICE9PSAnYWZ0ZXInICYmIGZsaXApKSB7XG5cdFx0XHRcdGN0eC5saW5lVG8ocHJldmlvdXMueCwgdGFyZ2V0LnkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG5cdFx0XHR9XG5cdFx0XHRjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCF0YXJnZXQudGVuc2lvbikge1xuXHRcdFx0Y3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGN0eC5iZXppZXJDdXJ2ZVRvKFxuXHRcdFx0ZmxpcCA/IHByZXZpb3VzLmNvbnRyb2xQb2ludFByZXZpb3VzWCA6IHByZXZpb3VzLmNvbnRyb2xQb2ludE5leHRYLFxuXHRcdFx0ZmxpcCA/IHByZXZpb3VzLmNvbnRyb2xQb2ludFByZXZpb3VzWSA6IHByZXZpb3VzLmNvbnRyb2xQb2ludE5leHRZLFxuXHRcdFx0ZmxpcCA/IHRhcmdldC5jb250cm9sUG9pbnROZXh0WCA6IHRhcmdldC5jb250cm9sUG9pbnRQcmV2aW91c1gsXG5cdFx0XHRmbGlwID8gdGFyZ2V0LmNvbnRyb2xQb2ludE5leHRZIDogdGFyZ2V0LmNvbnRyb2xQb2ludFByZXZpb3VzWSxcblx0XHRcdHRhcmdldC54LFxuXHRcdFx0dGFyZ2V0LnkpO1xuXHR9XG59O1xuXG52YXIgaGVscGVyc19jYW52YXMgPSBleHBvcnRzJDE7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMuY2xlYXIgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5jbGVhclxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVyc19jb3JlLmNsZWFyID0gZXhwb3J0cyQxLmNsZWFyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQuaGVscGVycy5jYW52YXMucm91bmRlZFJlY3QgaW5zdGVhZC5cbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVycy5kcmF3Um91bmRlZFJlY3RhbmdsZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVyc19jb3JlLmRyYXdSb3VuZGVkUmVjdGFuZ2xlID0gZnVuY3Rpb24oY3R4KSB7XG5cdGN0eC5iZWdpblBhdGgoKTtcblx0ZXhwb3J0cyQxLnJvdW5kZWRSZWN0LmFwcGx5KGV4cG9ydHMkMSwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBkZWZhdWx0cyA9IHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfc2V0OiBmdW5jdGlvbihzY29wZSwgdmFsdWVzKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnNfY29yZS5tZXJnZSh0aGlzW3Njb3BlXSB8fCAodGhpc1tzY29wZV0gPSB7fSksIHZhbHVlcyk7XG5cdH1cbn07XG5cbmRlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZGVmYXVsdENvbG9yOiAncmdiYSgwLDAsMCwwLjEpJyxcblx0ZGVmYXVsdEZvbnRDb2xvcjogJyM2NjYnLFxuXHRkZWZhdWx0Rm9udEZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuXHRkZWZhdWx0Rm9udFNpemU6IDEyLFxuXHRkZWZhdWx0Rm9udFN0eWxlOiAnbm9ybWFsJyxcblx0ZGVmYXVsdExpbmVIZWlnaHQ6IDEuMixcblx0c2hvd0xpbmVzOiB0cnVlXG59KTtcblxudmFyIGNvcmVfZGVmYXVsdHMgPSBkZWZhdWx0cztcblxudmFyIHZhbHVlT3JEZWZhdWx0ID0gaGVscGVyc19jb3JlLnZhbHVlT3JEZWZhdWx0O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBmb250IG9iamVjdCBpbnRvIGEgQ1NTIGZvbnQgc3RyaW5nLlxuICogQHBhcmFtIHtvYmplY3R9IGZvbnQgLSBBIGZvbnQgb2JqZWN0LlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgQ1NTIGZvbnQgc3RyaW5nLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRvRm9udFN0cmluZyhmb250KSB7XG5cdGlmICghZm9udCB8fCBoZWxwZXJzX2NvcmUuaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGhlbHBlcnNfY29yZS5pc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cblxuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBoZWxwZXJzX29wdGlvbnMgPSB7XG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBpbiBwaXhlbHMgKHNpemUgKiAxLjIgaWYgdmFsdWUgaXMgaW52YWxpZCkuXG5cdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0dG9MaW5lSGVpZ2h0OiBmdW5jdGlvbih2YWx1ZSwgc2l6ZSkge1xuXHRcdHZhciBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvKTtcblx0XHRpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcblx0XHRcdHJldHVybiBzaXplICogMS4yO1xuXHRcdH1cblxuXHRcdHZhbHVlID0gK21hdGNoZXNbMl07XG5cblx0XHRzd2l0Y2ggKG1hdGNoZXNbM10pIHtcblx0XHRjYXNlICdweCc6XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0Y2FzZSAnJSc6XG5cdFx0XHR2YWx1ZSAvPSAxMDA7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNpemUgKiB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBwYWRkaW5nIG9iamVjdCB3aXRoIHByZS1jb21wdXRlZCB3aWR0aC9oZWlnaHQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfG9iamVjdH0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG5cdCAqICBlbHNlLCBpZiBhbmQgb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdHRvUGFkZGluZzogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgdCwgciwgYiwgbDtcblxuXHRcdGlmIChoZWxwZXJzX2NvcmUuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0XHR0ID0gK3ZhbHVlLnRvcCB8fCAwO1xuXHRcdFx0ciA9ICt2YWx1ZS5yaWdodCB8fCAwO1xuXHRcdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcblx0XHRcdGwgPSArdmFsdWUubGVmdCB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogdCxcblx0XHRcdHJpZ2h0OiByLFxuXHRcdFx0Ym90dG9tOiBiLFxuXHRcdFx0bGVmdDogbCxcblx0XHRcdGhlaWdodDogdCArIGIsXG5cdFx0XHR3aWR0aDogbCArIHJcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgZm9udCBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBmb250IG9iamVjdC5cblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBIG9iamVjdCB0aGF0IGNvbnRhaW5zIGZvbnQgb3B0aW9ucyB0byBiZSBwYXJzZWQuXG5cdCAqIEByZXR1cm4ge29iamVjdH0gVGhlIGZvbnQgb2JqZWN0LlxuXHQgKiBAdG9kbyBTdXBwb3J0IGZvbnQuKiBvcHRpb25zIGFuZCByZW5hbWVkIHRvIHRvRm9udCgpLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3BhcnNlRm9udDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKTtcblx0XHR2YXIgZm9udCA9IHtcblx0XHRcdGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0XHRsaW5lSGVpZ2h0OiBoZWxwZXJzX2NvcmUub3B0aW9ucy50b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0TGluZUhlaWdodCksIHNpemUpLFxuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdHN0eWxlOiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZvbnRTdHlsZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTdHlsZSksXG5cdFx0XHR3ZWlnaHQ6IG51bGwsXG5cdFx0XHRzdHJpbmc6ICcnXG5cdFx0fTtcblxuXHRcdGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuXHRcdHJldHVybiBmb250O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIGBpbnB1dHNgIHNlcXVlbnRpYWxseSBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcblx0ICogaXMgY2FsbGVkIHdpdGggYGNvbnRleHRgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgcmVzdWx0IGJlY29tZXMgdGhlIG5ldyBpbnB1dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF0gLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlIHZhbHVlXG5cdCAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXG5cdCAqIEBzaW5jZSAyLjcuMFxuXHQgKi9cblx0cmVzb2x2ZTogZnVuY3Rpb24oaW5wdXRzLCBjb250ZXh0LCBpbmRleCkge1xuXHRcdHZhciBpLCBpbGVuLCB2YWx1ZTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR2YWx1ZSA9IGlucHV0c1tpXTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZShjb250ZXh0KTtcblx0XHRcdH1cblx0XHRcdGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGhlbHBlcnNfY29yZS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW2luZGV4XTtcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbnZhciBoZWxwZXJzJDEgPSBoZWxwZXJzX2NvcmU7XG52YXIgZWFzaW5nID0gaGVscGVyc19lYXNpbmc7XG52YXIgY2FudmFzID0gaGVscGVyc19jYW52YXM7XG52YXIgb3B0aW9ucyA9IGhlbHBlcnNfb3B0aW9ucztcbmhlbHBlcnMkMS5lYXNpbmcgPSBlYXNpbmc7XG5oZWxwZXJzJDEuY2FudmFzID0gY2FudmFzO1xuaGVscGVycyQxLm9wdGlvbnMgPSBvcHRpb25zO1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpIHtcblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhtb2RlbCk7XG5cdHZhciBpLCBpbGVuLCBrZXksIGFjdHVhbCwgb3JpZ2luLCB0YXJnZXQsIHR5cGUsIGMwLCBjMTtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRrZXkgPSBrZXlzW2ldO1xuXG5cdFx0dGFyZ2V0ID0gbW9kZWxba2V5XTtcblxuXHRcdC8vIGlmIGEgdmFsdWUgaXMgYWRkZWQgdG8gdGhlIG1vZGVsIGFmdGVyIHBpdm90KCkgaGFzIGJlZW4gY2FsbGVkLCB0aGUgdmlld1xuXHRcdC8vIGRvZXNuJ3QgY29udGFpbiBpdCwgc28gbGV0J3MgaW5pdGlhbGl6ZSB0aGUgdmlldyB0byB0aGUgdGFyZ2V0IHZhbHVlLlxuXHRcdGlmICghdmlldy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHR2aWV3W2tleV0gPSB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0YWN0dWFsID0gdmlld1trZXldO1xuXG5cdFx0aWYgKGFjdHVhbCA9PT0gdGFyZ2V0IHx8IGtleVswXSA9PT0gJ18nKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIXN0YXJ0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHN0YXJ0W2tleV0gPSBhY3R1YWw7XG5cdFx0fVxuXG5cdFx0b3JpZ2luID0gc3RhcnRba2V5XTtcblxuXHRcdHR5cGUgPSB0eXBlb2YgdGFyZ2V0O1xuXG5cdFx0aWYgKHR5cGUgPT09IHR5cGVvZiBvcmlnaW4pIHtcblx0XHRcdGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRjMCA9IGNoYXJ0anNDb2xvcihvcmlnaW4pO1xuXHRcdFx0XHRpZiAoYzAudmFsaWQpIHtcblx0XHRcdFx0XHRjMSA9IGNoYXJ0anNDb2xvcih0YXJnZXQpO1xuXHRcdFx0XHRcdGlmIChjMS52YWxpZCkge1xuXHRcdFx0XHRcdFx0dmlld1trZXldID0gYzEubWl4KGMwLCBlYXNlKS5yZ2JTdHJpbmcoKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzJDEuaXNGaW5pdGUob3JpZ2luKSAmJiBoZWxwZXJzJDEuaXNGaW5pdGUodGFyZ2V0KSkge1xuXHRcdFx0XHR2aWV3W2tleV0gPSBvcmlnaW4gKyAodGFyZ2V0IC0gb3JpZ2luKSAqIGVhc2U7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZpZXdba2V5XSA9IHRhcmdldDtcblx0fVxufVxuXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uKGNvbmZpZ3VyYXRpb24pIHtcblx0aGVscGVycyQxLmV4dGVuZCh0aGlzLCBjb25maWd1cmF0aW9uKTtcblx0dGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5oZWxwZXJzJDEuZXh0ZW5kKEVsZW1lbnQucHJvdG90eXBlLCB7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oaWRkZW4gPSBmYWxzZTtcblx0fSxcblxuXHRwaXZvdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRpZiAoIW1lLl92aWV3KSB7XG5cdFx0XHRtZS5fdmlldyA9IGhlbHBlcnMkMS5jbG9uZShtZS5fbW9kZWwpO1xuXHRcdH1cblx0XHRtZS5fc3RhcnQgPSB7fTtcblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsO1xuXHRcdHZhciBzdGFydCA9IG1lLl9zdGFydDtcblx0XHR2YXIgdmlldyA9IG1lLl92aWV3O1xuXG5cdFx0Ly8gTm8gYW5pbWF0aW9uIC0+IE5vIFRyYW5zaXRpb25cblx0XHRpZiAoIW1vZGVsIHx8IGVhc2UgPT09IDEpIHtcblx0XHRcdG1lLl92aWV3ID0gbW9kZWw7XG5cdFx0XHRtZS5fc3RhcnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIG1lO1xuXHRcdH1cblxuXHRcdGlmICghdmlldykge1xuXHRcdFx0dmlldyA9IG1lLl92aWV3ID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKCFzdGFydCkge1xuXHRcdFx0c3RhcnQgPSBtZS5fc3RhcnQgPSB7fTtcblx0XHR9XG5cblx0XHRpbnRlcnBvbGF0ZShzdGFydCwgdmlldywgbW9kZWwsIGVhc2UpO1xuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHRoaXMuX21vZGVsLngsXG5cdFx0XHR5OiB0aGlzLl9tb2RlbC55XG5cdFx0fTtcblx0fSxcblxuXHRoYXNWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGhlbHBlcnMkMS5pc051bWJlcih0aGlzLl9tb2RlbC54KSAmJiBoZWxwZXJzJDEuaXNOdW1iZXIodGhpcy5fbW9kZWwueSk7XG5cdH1cbn0pO1xuXG5FbGVtZW50LmV4dGVuZCA9IGhlbHBlcnMkMS5pbmhlcml0cztcblxudmFyIGNvcmVfZWxlbWVudCA9IEVsZW1lbnQ7XG5cbnZhciBleHBvcnRzJDIgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0Y2hhcnQ6IG51bGwsIC8vIHRoZSBhbmltYXRpb24gYXNzb2NpYXRlZCBjaGFydCBpbnN0YW5jZVxuXHRjdXJyZW50U3RlcDogMCwgLy8gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0ZXBcblx0bnVtU3RlcHM6IDYwLCAvLyBkZWZhdWx0IG51bWJlciBvZiBzdGVwc1xuXHRlYXNpbmc6ICcnLCAvLyB0aGUgZWFzaW5nIHRvIHVzZSBmb3IgdGhpcyBhbmltYXRpb25cblx0cmVuZGVyOiBudWxsLCAvLyByZW5kZXIgZnVuY3Rpb24gdXNlZCBieSB0aGUgYW5pbWF0aW9uIHNlcnZpY2VcblxuXHRvbkFuaW1hdGlvblByb2dyZXNzOiBudWxsLCAvLyB1c2VyIHNwZWNpZmllZCBjYWxsYmFjayB0byBmaXJlIG9uIGVhY2ggc3RlcCBvZiB0aGUgYW5pbWF0aW9uXG5cdG9uQW5pbWF0aW9uQ29tcGxldGU6IG51bGwsIC8vIHVzZXIgc3BlY2lmaWVkIGNhbGxiYWNrIHRvIGZpcmUgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzXG59KTtcblxudmFyIGNvcmVfYW5pbWF0aW9uID0gZXhwb3J0cyQyO1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiBpbnN0ZWFkXG4gKiBAcHJvcCBDaGFydC5BbmltYXRpb24jYW5pbWF0aW9uT2JqZWN0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNi4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzJDIucHJvdG90eXBlLCAnYW5pbWF0aW9uT2JqZWN0Jywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LkFuaW1hdGlvbiNjaGFydCBpbnN0ZWFkXG4gKiBAcHJvcCBDaGFydC5BbmltYXRpb24jY2hhcnRJbnN0YW5jZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyQyLnByb3RvdHlwZSwgJ2NoYXJ0SW5zdGFuY2UnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQ7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzLmNoYXJ0ID0gdmFsdWU7XG5cdH1cbn0pO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0YW5pbWF0aW9uOiB7XG5cdFx0ZHVyYXRpb246IDEwMDAsXG5cdFx0ZWFzaW5nOiAnZWFzZU91dFF1YXJ0Jyxcblx0XHRvblByb2dyZXNzOiBoZWxwZXJzJDEubm9vcCxcblx0XHRvbkNvbXBsZXRlOiBoZWxwZXJzJDEubm9vcFxuXHR9XG59KTtcblxudmFyIGNvcmVfYW5pbWF0aW9ucyA9IHtcblx0YW5pbWF0aW9uczogW10sXG5cdHJlcXVlc3Q6IG51bGwsXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IHRvIGFuaW1hdGUuXG5cdCAqIEBwYXJhbSB7Q2hhcnQuQW5pbWF0aW9ufSBhbmltYXRpb24gLSBUaGUgYW5pbWF0aW9uIHRoYXQgd2Ugd2lsbCBhbmltYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gLSBUaGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1zLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxhenkgLSBpZiB0cnVlLCB0aGUgY2hhcnQgaXMgbm90IG1hcmtlZCBhcyBhbmltYXRpbmcgdG8gZW5hYmxlIG1vcmUgcmVzcG9uc2l2ZSBpbnRlcmFjdGlvbnNcblx0ICovXG5cdGFkZEFuaW1hdGlvbjogZnVuY3Rpb24oY2hhcnQsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpIHtcblx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdGFuaW1hdGlvbi5jaGFydCA9IGNoYXJ0O1xuXHRcdGFuaW1hdGlvbi5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG5cdFx0aWYgKCFsYXp5KSB7XG5cdFx0XHRjaGFydC5hbmltYXRpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBhbmltYXRpb25zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGFuaW1hdGlvbnNbaV0uY2hhcnQgPT09IGNoYXJ0KSB7XG5cdFx0XHRcdGFuaW1hdGlvbnNbaV0gPSBhbmltYXRpb247XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcblxuXHRcdC8vIElmIHRoZXJlIGFyZSBubyBhbmltYXRpb25zIHF1ZXVlZCwgbWFudWFsbHkga2lja3N0YXJ0IGEgZGlnZXN0LCBmb3IgbGFjayBvZiBhIGJldHRlciB3b3JkXG5cdFx0aWYgKGFuaW1hdGlvbnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuXHRcdH1cblx0fSxcblxuXHRjYW5jZWxBbmltYXRpb246IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0dmFyIGluZGV4ID0gaGVscGVycyQxLmZpbmRJbmRleCh0aGlzLmFuaW1hdGlvbnMsIGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbi5jaGFydCA9PT0gY2hhcnQ7XG5cdFx0fSk7XG5cblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR0aGlzLmFuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdGNoYXJ0LmFuaW1hdGluZyA9IGZhbHNlO1xuXHRcdH1cblx0fSxcblxuXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLnJlcXVlc3QgPT09IG51bGwpIHtcblx0XHRcdC8vIFNraXAgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3RzIHVudGlsIHRoZSBhY3RpdmUgb25lIGlzIGV4ZWN1dGVkLlxuXHRcdFx0Ly8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gcHJvY2Vzc2luZyBtb3VzZSBldmVudHMsIGUuZy4gJ21vdXNlbW92ZSdcblx0XHRcdC8vIGFuZCAnbW91c2VvdXQnIGV2ZW50cyB3aWxsIHRyaWdnZXIgbXVsdGlwbGUgcmVuZGVycy5cblx0XHRcdG1lLnJlcXVlc3QgPSBoZWxwZXJzJDEucmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdG1lLnJlcXVlc3QgPSBudWxsO1xuXHRcdFx0XHRtZS5zdGFydERpZ2VzdCgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c3RhcnREaWdlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRtZS5hZHZhbmNlKCk7XG5cblx0XHQvLyBEbyB3ZSBoYXZlIG1vcmUgc3R1ZmYgdG8gYW5pbWF0ZT9cblx0XHRpZiAobWUuYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7XG5cdFx0XHRtZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRhZHZhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYW5pbWF0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucztcblx0XHR2YXIgYW5pbWF0aW9uLCBjaGFydCwgbnVtU3RlcHMsIG5leHRTdGVwO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdC8vIDEgYW5pbWF0aW9uIHBlciBjaGFydCwgc28gd2UgYXJlIGxvb3BpbmcgY2hhcnRzIGhlcmVcblx0XHR3aGlsZSAoaSA8IGFuaW1hdGlvbnMubGVuZ3RoKSB7XG5cdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb25zW2ldO1xuXHRcdFx0Y2hhcnQgPSBhbmltYXRpb24uY2hhcnQ7XG5cdFx0XHRudW1TdGVwcyA9IGFuaW1hdGlvbi5udW1TdGVwcztcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgY3VycmVudFN0ZXAgc3RhcnRzIGF0IDFcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82MTA0XG5cdFx0XHRuZXh0U3RlcCA9IE1hdGguZmxvb3IoKERhdGUubm93KCkgLSBhbmltYXRpb24uc3RhcnRUaW1lKSAvIGFuaW1hdGlvbi5kdXJhdGlvbiAqIG51bVN0ZXBzKSArIDE7XG5cdFx0XHRhbmltYXRpb24uY3VycmVudFN0ZXAgPSBNYXRoLm1pbihuZXh0U3RlcCwgbnVtU3RlcHMpO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLnJlbmRlciwgW2NoYXJ0LCBhbmltYXRpb25dLCBjaGFydCk7XG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uLm9uQW5pbWF0aW9uUHJvZ3Jlc3MsIFthbmltYXRpb25dLCBjaGFydCk7XG5cblx0XHRcdGlmIChhbmltYXRpb24uY3VycmVudFN0ZXAgPj0gbnVtU3RlcHMpIHtcblx0XHRcdFx0aGVscGVycyQxLmNhbGxiYWNrKGFuaW1hdGlvbi5vbkFuaW1hdGlvbkNvbXBsZXRlLCBbYW5pbWF0aW9uXSwgY2hhcnQpO1xuXHRcdFx0XHRjaGFydC5hbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0YW5pbWF0aW9ucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQrK2k7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgcmVzb2x2ZSA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbnZhciBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXTtcblxuLyoqXG4gKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxuICogJ3Vuc2hpZnQnKSBhbmQgbm90aWZ5IHRoZSBsaXN0ZW5lciBBRlRFUiB0aGUgYXJyYXkgaGFzIGJlZW4gYWx0ZXJlZC4gTGlzdGVuZXJzIGFyZVxuICogY2FsbGVkIG9uIHRoZSAnb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIG9uRGF0YVB1c2gsIGV0Yy4pIHdpdGggc2FtZSBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuXHRpZiAoYXJyYXkuX2NoYXJ0anMpIHtcblx0XHRhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdHZhbHVlOiB7XG5cdFx0XHRsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cblx0XHR9XG5cdH0pO1xuXG5cdGFycmF5RXZlbnRzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIG1ldGhvZCA9ICdvbkRhdGEnICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpO1xuXHRcdHZhciBiYXNlID0gYXJyYXlba2V5XTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwga2V5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdFx0XHR2YXIgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcblxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMsIGZ1bmN0aW9uKG9iamVjdCkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdG9iamVjdFttZXRob2RdLmFwcGx5KG9iamVjdCwgYXJncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5mdW5jdGlvbiB1bmxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuXHR2YXIgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuXHRpZiAoIXN0dWIpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG5cdHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcblx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHR9XG5cblx0aWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0YXJyYXlFdmVudHMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRkZWxldGUgYXJyYXlba2V5XTtcblx0fSk7XG5cblx0ZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuXG4vLyBCYXNlIGNsYXNzIGZvciBhbGwgZGF0YXNldCBjb250cm9sbGVycyAobGluZSwgYmFyLCBldGMpXG52YXIgRGF0YXNldENvbnRyb2xsZXIgPSBmdW5jdGlvbihjaGFydCwgZGF0YXNldEluZGV4KSB7XG5cdHRoaXMuaW5pdGlhbGl6ZShjaGFydCwgZGF0YXNldEluZGV4KTtcbn07XG5cbmhlbHBlcnMkMS5leHRlbmQoRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG5cblx0LyoqXG5cdCAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhc2V0IChlLmcuIENoYXJ0LmVsZW1lbnQuTGluZSkuXG5cdCAqIEB0eXBlIHtDaGFydC5jb3JlLmVsZW1lbnR9XG5cdCAqL1xuXHRkYXRhc2V0RWxlbWVudFR5cGU6IG51bGwsXG5cblx0LyoqXG5cdCAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhIChlLmcuIENoYXJ0LmVsZW1lbnQuUG9pbnQpLlxuXHQgKiBAdHlwZSB7Q2hhcnQuY29yZS5lbGVtZW50fVxuXHQgKi9cblx0ZGF0YUVsZW1lbnRUeXBlOiBudWxsLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLmNoYXJ0ID0gY2hhcnQ7XG5cdFx0bWUuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdFx0bWUubGlua1NjYWxlcygpO1xuXHRcdG1lLmFkZEVsZW1lbnRzKCk7XG5cdH0sXG5cblx0dXBkYXRlSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG5cdH0sXG5cblx0bGlua1NjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblxuXHRcdGlmIChtZXRhLnhBeGlzSUQgPT09IG51bGwgfHwgIShtZXRhLnhBeGlzSUQgaW4gbWUuY2hhcnQuc2NhbGVzKSkge1xuXHRcdFx0bWV0YS54QXhpc0lEID0gZGF0YXNldC54QXhpc0lEIHx8IG1lLmNoYXJ0Lm9wdGlvbnMuc2NhbGVzLnhBeGVzWzBdLmlkO1xuXHRcdH1cblx0XHRpZiAobWV0YS55QXhpc0lEID09PSBudWxsIHx8ICEobWV0YS55QXhpc0lEIGluIG1lLmNoYXJ0LnNjYWxlcykpIHtcblx0XHRcdG1ldGEueUF4aXNJRCA9IGRhdGFzZXQueUF4aXNJRCB8fCBtZS5jaGFydC5vcHRpb25zLnNjYWxlcy55QXhlc1swXS5pZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RGF0YXNldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcblx0fSxcblxuXHRnZXRNZXRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcblx0fSxcblxuXHRnZXRTY2FsZUZvcklkOiBmdW5jdGlvbihzY2FsZUlEKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnlBeGlzSUQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueEF4aXNJRDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWYWx1ZVNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuX2dldFZhbHVlU2NhbGVJZCgpKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRJbmRleFNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTY2FsZUZvcklkKHRoaXMuX2dldEluZGV4U2NhbGVJZCgpKTtcblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGUodHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fZGF0YSkge1xuXHRcdFx0dW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0Y3JlYXRlTWV0YURhdGFzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHR5cGUgPSBtZS5kYXRhc2V0RWxlbWVudFR5cGU7XG5cdFx0cmV0dXJuIHR5cGUgJiYgbmV3IHR5cGUoe1xuXHRcdFx0X2NoYXJ0OiBtZS5jaGFydCxcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fSk7XG5cdH0sXG5cblx0Y3JlYXRlTWV0YURhdGE6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdHlwZSA9IG1lLmRhdGFFbGVtZW50VHlwZTtcblx0XHRyZXR1cm4gdHlwZSAmJiBuZXcgdHlwZSh7XG5cdFx0XHRfY2hhcnQ6IG1lLmNoYXJ0LFxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRfaW5kZXg6IGluZGV4XG5cdFx0fSk7XG5cdH0sXG5cblx0YWRkRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGRhdGEgPSBtZS5nZXREYXRhc2V0KCkuZGF0YSB8fCBbXTtcblx0XHR2YXIgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1ldGFEYXRhW2ldID0gbWV0YURhdGFbaV0gfHwgbWUuY3JlYXRlTWV0YURhdGEoaSk7XG5cdFx0fVxuXG5cdFx0bWV0YS5kYXRhc2V0ID0gbWV0YS5kYXRhc2V0IHx8IG1lLmNyZWF0ZU1ldGFEYXRhc2V0KCk7XG5cdH0sXG5cblx0YWRkRWxlbWVudEFuZFJlc2V0OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVNZXRhRGF0YShpbmRleCk7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zcGxpY2UoaW5kZXgsIDAsIGVsZW1lbnQpO1xuXHRcdHRoaXMudXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgdHJ1ZSk7XG5cdH0sXG5cblx0YnVpbGRPclVwZGF0ZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG5cblx0XHQvLyBJbiBvcmRlciB0byBjb3JyZWN0bHkgaGFuZGxlIGRhdGEgYWRkaXRpb24vZGVsZXRpb24gYW5pbWF0aW9uIChhbiB0aHVzIHNpbXVsYXRlXG5cdFx0Ly8gcmVhbC10aW1lIGNoYXJ0cyksIHdlIG5lZWQgdG8gbW9uaXRvciB0aGVzZSBkYXRhIG1vZGlmaWNhdGlvbnMgYW5kIHN5bmNocm9uaXplXG5cdFx0Ly8gdGhlIGludGVybmFsIG1ldGEgZGF0YSBhY2NvcmRpbmdseS5cblx0XHRpZiAobWUuX2RhdGEgIT09IGRhdGEpIHtcblx0XHRcdGlmIChtZS5fZGF0YSkge1xuXHRcdFx0XHQvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuXHRcdFx0XHR1bmxpc3RlbkFycmF5RXZlbnRzKG1lLl9kYXRhLCBtZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcblx0XHRcdFx0bGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgbWUpO1xuXHRcdFx0fVxuXHRcdFx0bWUuX2RhdGEgPSBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG5cdFx0Ly8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cblx0XHRtZS5yZXN5bmNFbGVtZW50cygpO1xuXHR9LFxuXG5cdHVwZGF0ZTogaGVscGVycyQxLm5vb3AsXG5cblx0dHJhbnNpdGlvbjogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZWxlbWVudHNbaV0udHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG1ldGEuZGF0YXNldCkge1xuXHRcdFx0bWV0YS5kYXRhc2V0LnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciBlbGVtZW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRpZiAobWV0YS5kYXRhc2V0KSB7XG5cdFx0XHRtZXRhLmRhdGFzZXQuZHJhdygpO1xuXHRcdH1cblxuXHRcdGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRlbGVtZW50c1tpXS5kcmF3KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRoZWxwZXJzJDEubWVyZ2UoZWxlbWVudC5fbW9kZWwsIGVsZW1lbnQuJHByZXZpb3VzU3R5bGUgfHwge30pO1xuXHRcdGRlbGV0ZSBlbGVtZW50LiRwcmV2aW91c1N0eWxlO1xuXHR9LFxuXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tlbGVtZW50Ll9kYXRhc2V0SW5kZXhdO1xuXHRcdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgbW9kZWwgPSBlbGVtZW50Ll9tb2RlbDtcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0ZWxlbWVudC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHJlc29sdmUoW2N1c3RvbS5ob3ZlckJhY2tncm91bmRDb2xvciwgZGF0YXNldC5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihtb2RlbC5iYWNrZ3JvdW5kQ29sb3IpXSwgdW5kZWZpbmVkLCBpbmRleCk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSByZXNvbHZlKFtjdXN0b20uaG92ZXJCb3JkZXJDb2xvciwgZGF0YXNldC5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG1vZGVsLmJvcmRlckNvbG9yKV0sIHVuZGVmaW5lZCwgaW5kZXgpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gcmVzb2x2ZShbY3VzdG9tLmhvdmVyQm9yZGVyV2lkdGgsIGRhdGFzZXQuaG92ZXJCb3JkZXJXaWR0aCwgbW9kZWwuYm9yZGVyV2lkdGhdLCB1bmRlZmluZWQsIGluZGV4KTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlc3luY0VsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBkYXRhID0gbWUuZ2V0RGF0YXNldCgpLmRhdGE7XG5cdFx0dmFyIG51bU1ldGEgPSBtZXRhLmRhdGEubGVuZ3RoO1xuXHRcdHZhciBudW1EYXRhID0gZGF0YS5sZW5ndGg7XG5cblx0XHRpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcblx0XHRcdG1ldGEuZGF0YS5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuXHRcdH0gZWxzZSBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcblx0XHRcdG1lLmluc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbnNlcnRFbGVtZW50czogZnVuY3Rpb24oc3RhcnQsIGNvdW50KSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG5cdFx0XHR0aGlzLmFkZEVsZW1lbnRBbmRSZXNldChzdGFydCArIGkpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVB1c2g6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0dGhpcy5pbnNlcnRFbGVtZW50cyh0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFQb3A6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZ2V0TWV0YSgpLmRhdGEucG9wKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRvbkRhdGFTaGlmdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5nZXRNZXRhKCkuZGF0YS5zaGlmdCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0b25EYXRhU3BsaWNlOiBmdW5jdGlvbihzdGFydCwgY291bnQpIHtcblx0XHR0aGlzLmdldE1ldGEoKS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggLSAyKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdG9uRGF0YVVuc2hpZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaW5zZXJ0RWxlbWVudHMoMCwgYXJndW1lbnRzLmxlbmd0aCk7XG5cdH1cbn0pO1xuXG5EYXRhc2V0Q29udHJvbGxlci5leHRlbmQgPSBoZWxwZXJzJDEuaW5oZXJpdHM7XG5cbnZhciBjb3JlX2RhdGFzZXRDb250cm9sbGVyID0gRGF0YXNldENvbnRyb2xsZXI7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdGFyYzoge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogJyNmZmYnLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDIsXG5cdFx0XHRib3JkZXJBbGlnbjogJ2NlbnRlcidcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZWxlbWVudF9hcmMgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtKSB7XG5cdFx0XHRyZXR1cm4gKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpIDwgTWF0aC5wb3codm0ucmFkaXVzICsgdm0uaG92ZXJSYWRpdXMsIDIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGluUmFuZ2U6IGZ1bmN0aW9uKGNoYXJ0WCwgY2hhcnRZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblxuXHRcdGlmICh2bSkge1xuXHRcdFx0dmFyIHBvaW50UmVsYXRpdmVQb3NpdGlvbiA9IGhlbHBlcnMkMS5nZXRBbmdsZUZyb21Qb2ludCh2bSwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG5cdFx0XHR2YXJcdGFuZ2xlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmFuZ2xlO1xuXHRcdFx0dmFyIGRpc3RhbmNlID0gcG9pbnRSZWxhdGl2ZVBvc2l0aW9uLmRpc3RhbmNlO1xuXG5cdFx0XHQvLyBTYW5pdGlzZSBhbmdsZSByYW5nZVxuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB2bS5zdGFydEFuZ2xlO1xuXHRcdFx0dmFyIGVuZEFuZ2xlID0gdm0uZW5kQW5nbGU7XG5cdFx0XHR3aGlsZSAoZW5kQW5nbGUgPCBzdGFydEFuZ2xlKSB7XG5cdFx0XHRcdGVuZEFuZ2xlICs9IDIuMCAqIE1hdGguUEk7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoYW5nbGUgPiBlbmRBbmdsZSkge1xuXHRcdFx0XHRhbmdsZSAtPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGFuZ2xlIDwgc3RhcnRBbmdsZSkge1xuXHRcdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBpZiB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBvcGVuL2Nsb3NlIGFuZ2xlXG5cdFx0XHR2YXIgYmV0d2VlbkFuZ2xlcyA9IChhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciB3aXRoaW5SYWRpdXMgPSAoZGlzdGFuY2UgPj0gdm0uaW5uZXJSYWRpdXMgJiYgZGlzdGFuY2UgPD0gdm0ub3V0ZXJSYWRpdXMpO1xuXG5cdFx0XHRyZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGdldENlbnRlclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciBoYWxmQW5nbGUgPSAodm0uc3RhcnRBbmdsZSArIHZtLmVuZEFuZ2xlKSAvIDI7XG5cdFx0dmFyIGhhbGZSYWRpdXMgPSAodm0uaW5uZXJSYWRpdXMgKyB2bS5vdXRlclJhZGl1cykgLyAyO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG5cdFx0XHR5OiB2bS55ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcblx0XHR9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIE1hdGguUEkgKiAoKHZtLmVuZEFuZ2xlIC0gdm0uc3RhcnRBbmdsZSkgLyAoMiAqIE1hdGguUEkpKSAqIChNYXRoLnBvdyh2bS5vdXRlclJhZGl1cywgMikgLSBNYXRoLnBvdyh2bS5pbm5lclJhZGl1cywgMikpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgY2VudHJlQW5nbGUgPSB2bS5zdGFydEFuZ2xlICsgKCh2bS5lbmRBbmdsZSAtIHZtLnN0YXJ0QW5nbGUpIC8gMik7XG5cdFx0dmFyIHJhbmdlRnJvbUNlbnRyZSA9ICh2bS5vdXRlclJhZGl1cyAtIHZtLmlubmVyUmFkaXVzKSAvIDIgKyB2bS5pbm5lclJhZGl1cztcblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB2bS54ICsgKE1hdGguY29zKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSksXG5cdFx0XHR5OiB2bS55ICsgKE1hdGguc2luKGNlbnRyZUFuZ2xlKSAqIHJhbmdlRnJvbUNlbnRyZSlcblx0XHR9O1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdHggPSB0aGlzLl9jaGFydC5jdHg7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgc0EgPSB2bS5zdGFydEFuZ2xlO1xuXHRcdHZhciBlQSA9IHZtLmVuZEFuZ2xlO1xuXHRcdHZhciBwaXhlbE1hcmdpbiA9ICh2bS5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcblx0XHR2YXIgYW5nbGVNYXJnaW47XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGN0eC5hcmModm0ueCwgdm0ueSwgTWF0aC5tYXgodm0ub3V0ZXJSYWRpdXMgLSBwaXhlbE1hcmdpbiwgMCksIHNBLCBlQSk7XG5cdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5pbm5lclJhZGl1cywgZUEsIHNBLCB0cnVlKTtcblx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5maWxsKCk7XG5cblx0XHRpZiAodm0uYm9yZGVyV2lkdGgpIHtcblx0XHRcdGlmICh2bS5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykge1xuXHRcdFx0XHQvLyBEcmF3IGFuIGlubmVyIGJvcmRlciBieSBjbGlwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG5cdFx0XHRcdC8vIEVubGFyZ2UgdGhlIGNsaXBwaW5nIGFyYyBieSAwLjMzIHBpeGVscyB0byBlbGltaW5hdGUgZ2xpdGNoZXMgYmV0d2VlbiBib3JkZXJzXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0YW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIHZtLm91dGVyUmFkaXVzO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLm91dGVyUmFkaXVzLCBzQSAtIGFuZ2xlTWFyZ2luLCBlQSArIGFuZ2xlTWFyZ2luKTtcblx0XHRcdFx0aWYgKHZtLmlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcblx0XHRcdFx0XHRhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gdm0uaW5uZXJSYWRpdXM7XG5cdFx0XHRcdFx0Y3R4LmFyYyh2bS54LCB2bS55LCB2bS5pbm5lclJhZGl1cyAtIHBpeGVsTWFyZ2luLCBlQSArIGFuZ2xlTWFyZ2luLCBzQSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHBpeGVsTWFyZ2luLCBlQSArIE1hdGguUEkgLyAyLCBzQSAtIE1hdGguUEkgLyAyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGN0eC5jbGlwKCk7XG5cblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLm91dGVyUmFkaXVzLCBzQSwgZUEpO1xuXHRcdFx0XHRjdHguYXJjKHZtLngsIHZtLnksIHZtLmlubmVyUmFkaXVzLCBlQSwgc0EsIHRydWUpO1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZtLmJvcmRlcldpZHRoICogMjtcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gJ3JvdW5kJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gJ2JldmVsJztcblx0XHRcdH1cblxuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQxID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG52YXIgZGVmYXVsdENvbG9yID0gY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdENvbG9yO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHtcblx0XHRsaW5lOiB7XG5cdFx0XHR0ZW5zaW9uOiAwLjQsXG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IGRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiAzLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IGRlZmF1bHRDb2xvcixcblx0XHRcdGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG5cdFx0XHRib3JkZXJEYXNoOiBbXSxcblx0XHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcblx0XHRcdGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcblx0XHRcdGNhcEJlemllclBvaW50czogdHJ1ZSxcblx0XHRcdGZpbGw6IHRydWUsIC8vIGRvIHdlIGZpbGwgaW4gdGhlIGFyZWEgYmV0d2VlbiB0aGUgbGluZSBhbmQgaXRzIGJhc2UgYXhpc1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBlbGVtZW50X2xpbmUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdm0gPSBtZS5fdmlldztcblx0XHR2YXIgY3R4ID0gbWUuX2NoYXJ0LmN0eDtcblx0XHR2YXIgc3BhbkdhcHMgPSB2bS5zcGFuR2Fwcztcblx0XHR2YXIgcG9pbnRzID0gbWUuX2NoaWxkcmVuLnNsaWNlKCk7IC8vIGNsb25lIGFycmF5XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGdsb2JhbE9wdGlvbkxpbmVFbGVtZW50cyA9IGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLmxpbmU7XG5cdFx0dmFyIGxhc3REcmF3bkluZGV4ID0gLTE7XG5cdFx0dmFyIGluZGV4LCBjdXJyZW50LCBwcmV2aW91cywgY3VycmVudFZNO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGxvb3BpbmcsIGFkZGluZyB0aGUgZmlyc3QgcG9pbnQgYWdhaW5cblx0XHRpZiAobWUuX2xvb3AgJiYgcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0cG9pbnRzLnB1c2gocG9pbnRzWzBdKTtcblx0XHR9XG5cblx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0Ly8gU3Ryb2tlIExpbmUgT3B0aW9uc1xuXHRcdGN0eC5saW5lQ2FwID0gdm0uYm9yZGVyQ2FwU3R5bGUgfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckNhcFN0eWxlO1xuXG5cdFx0Ly8gSUUgOSBhbmQgMTAgZG8gbm90IHN1cHBvcnQgbGluZSBkYXNoXG5cdFx0aWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKHZtLmJvcmRlckRhc2ggfHwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2gpO1xuXHRcdH1cblxuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JDEodm0uYm9yZGVyRGFzaE9mZnNldCwgZ2xvYmFsT3B0aW9uTGluZUVsZW1lbnRzLmJvcmRlckRhc2hPZmZzZXQpO1xuXHRcdGN0eC5saW5lSm9pbiA9IHZtLmJvcmRlckpvaW5TdHlsZSB8fCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVySm9pblN0eWxlO1xuXHRcdGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQxKHZtLmJvcmRlcldpZHRoLCBnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMuYm9yZGVyV2lkdGgpO1xuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yIHx8IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjtcblxuXHRcdC8vIFN0cm9rZSBMaW5lXG5cdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdGxhc3REcmF3bkluZGV4ID0gLTE7XG5cblx0XHRmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwb2ludHMubGVuZ3RoOyArK2luZGV4KSB7XG5cdFx0XHRjdXJyZW50ID0gcG9pbnRzW2luZGV4XTtcblx0XHRcdHByZXZpb3VzID0gaGVscGVycyQxLnByZXZpb3VzSXRlbShwb2ludHMsIGluZGV4KTtcblx0XHRcdGN1cnJlbnRWTSA9IGN1cnJlbnQuX3ZpZXc7XG5cblx0XHRcdC8vIEZpcnN0IHBvaW50IG1vdmVzIHRvIGl0J3Mgc3RhcnRpbmcgcG9zaXRpb24gbm8gbWF0dGVyIHdoYXRcblx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRpZiAoIWN1cnJlbnRWTS5za2lwKSB7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJyZW50Vk0ueCwgY3VycmVudFZNLnkpO1xuXHRcdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByZXZpb3VzID0gbGFzdERyYXduSW5kZXggPT09IC0xID8gcHJldmlvdXMgOiBwb2ludHNbbGFzdERyYXduSW5kZXhdO1xuXG5cdFx0XHRcdGlmICghY3VycmVudFZNLnNraXApIHtcblx0XHRcdFx0XHRpZiAoKGxhc3REcmF3bkluZGV4ICE9PSAoaW5kZXggLSAxKSAmJiAhc3BhbkdhcHMpIHx8IGxhc3REcmF3bkluZGV4ID09PSAtMSkge1xuXHRcdFx0XHRcdFx0Ly8gVGhlcmUgd2FzIGEgZ2FwIGFuZCB0aGlzIGlzIHRoZSBmaXJzdCBwb2ludCBhZnRlciB0aGUgZ2FwXG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKGN1cnJlbnRWTS54LCBjdXJyZW50Vk0ueSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIExpbmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRcdFx0aGVscGVycyQxLmNhbnZhcy5saW5lVG8oY3R4LCBwcmV2aW91cy5fdmlldywgY3VycmVudC5fdmlldyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxhc3REcmF3bkluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQyID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG52YXIgZGVmYXVsdENvbG9yJDEgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdHBvaW50OiB7XG5cdFx0XHRyYWRpdXM6IDMsXG5cdFx0XHRwb2ludFN0eWxlOiAnY2lyY2xlJyxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogZGVmYXVsdENvbG9yJDEsXG5cdFx0XHRib3JkZXJDb2xvcjogZGVmYXVsdENvbG9yJDEsXG5cdFx0XHRib3JkZXJXaWR0aDogMSxcblx0XHRcdC8vIEhvdmVyXG5cdFx0XHRoaXRSYWRpdXM6IDEsXG5cdFx0XHRob3ZlclJhZGl1czogNCxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6IDFcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiB4UmFuZ2UobW91c2VYKSB7XG5cdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdHJldHVybiB2bSA/IChNYXRoLmFicyhtb3VzZVggLSB2bS54KSA8IHZtLnJhZGl1cyArIHZtLmhpdFJhZGl1cykgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24geVJhbmdlKG1vdXNlWSkge1xuXHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRyZXR1cm4gdm0gPyAoTWF0aC5hYnMobW91c2VZIC0gdm0ueSkgPCB2bS5yYWRpdXMgKyB2bS5oaXRSYWRpdXMpIDogZmFsc2U7XG59XG5cbnZhciBlbGVtZW50X3BvaW50ID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluUmFuZ2U6IGZ1bmN0aW9uKG1vdXNlWCwgbW91c2VZKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gdm0gPyAoKE1hdGgucG93KG1vdXNlWCAtIHZtLngsIDIpICsgTWF0aC5wb3cobW91c2VZIC0gdm0ueSwgMikpIDwgTWF0aC5wb3codm0uaGl0UmFkaXVzICsgdm0ucmFkaXVzLCAyKSkgOiBmYWxzZTtcblx0fSxcblxuXHRpbkxhYmVsUmFuZ2U6IHhSYW5nZSxcblx0aW5YUmFuZ2U6IHhSYW5nZSxcblx0aW5ZUmFuZ2U6IHlSYW5nZSxcblxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBNYXRoLlBJICogTWF0aC5wb3codGhpcy5fdmlldy5yYWRpdXMsIDIpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnksXG5cdFx0XHRwYWRkaW5nOiB2bS5yYWRpdXMgKyB2bS5ib3JkZXJXaWR0aFxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciBwb2ludFN0eWxlID0gdm0ucG9pbnRTdHlsZTtcblx0XHR2YXIgcm90YXRpb24gPSB2bS5yb3RhdGlvbjtcblx0XHR2YXIgcmFkaXVzID0gdm0ucmFkaXVzO1xuXHRcdHZhciB4ID0gdm0ueDtcblx0XHR2YXIgeSA9IHZtLnk7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGRlZmF1bHRDb2xvciA9IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zaGFkb3dcblxuXHRcdGlmICh2bS5za2lwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2xpcHBpbmcgZm9yIFBvaW50cy5cblx0XHRpZiAoY2hhcnRBcmVhID09PSB1bmRlZmluZWQgfHwgaGVscGVycyQxLmNhbnZhcy5faXNQb2ludEluQXJlYSh2bSwgY2hhcnRBcmVhKSkge1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdm0uYm9yZGVyQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xuXHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDIodm0uYm9yZGVyV2lkdGgsIGdsb2JhbERlZmF1bHRzLmVsZW1lbnRzLnBvaW50LmJvcmRlcldpZHRoKTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5iYWNrZ3JvdW5kQ29sb3IgfHwgZGVmYXVsdENvbG9yO1xuXHRcdFx0aGVscGVycyQxLmNhbnZhcy5kcmF3UG9pbnQoY3R4LCBwb2ludFN0eWxlLCByYWRpdXMsIHgsIHksIHJvdGF0aW9uKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZGVmYXVsdENvbG9yJDIgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRlbGVtZW50czoge1xuXHRcdHJlY3RhbmdsZToge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBkZWZhdWx0Q29sb3IkMixcblx0XHRcdGJvcmRlckNvbG9yOiBkZWZhdWx0Q29sb3IkMixcblx0XHRcdGJvcmRlclNraXBwZWQ6ICdib3R0b20nLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IDBcblx0XHR9XG5cdH1cbn0pO1xuXG5mdW5jdGlvbiBpc1ZlcnRpY2FsKHZtKSB7XG5cdHJldHVybiB2bSAmJiB2bS53aWR0aCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgYmFyIHJlZ2FyZGxlc3Mgb2YgdGhlIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0gYmFyIHtDaGFydC5FbGVtZW50LlJlY3RhbmdsZX0gdGhlIGJhclxuICogQHJldHVybiB7Qm91bmRzfSBib3VuZHMgb2YgdGhlIGJhclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKHZtKSB7XG5cdHZhciB4MSwgeDIsIHkxLCB5MiwgaGFsZjtcblxuXHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcblx0XHRoYWxmID0gdm0ud2lkdGggLyAyO1xuXHRcdHgxID0gdm0ueCAtIGhhbGY7XG5cdFx0eDIgPSB2bS54ICsgaGFsZjtcblx0XHR5MSA9IE1hdGgubWluKHZtLnksIHZtLmJhc2UpO1xuXHRcdHkyID0gTWF0aC5tYXgodm0ueSwgdm0uYmFzZSk7XG5cdH0gZWxzZSB7XG5cdFx0aGFsZiA9IHZtLmhlaWdodCAvIDI7XG5cdFx0eDEgPSBNYXRoLm1pbih2bS54LCB2bS5iYXNlKTtcblx0XHR4MiA9IE1hdGgubWF4KHZtLngsIHZtLmJhc2UpO1xuXHRcdHkxID0gdm0ueSAtIGhhbGY7XG5cdFx0eTIgPSB2bS55ICsgaGFsZjtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bGVmdDogeDEsXG5cdFx0dG9wOiB5MSxcblx0XHRyaWdodDogeDIsXG5cdFx0Ym90dG9tOiB5MlxuXHR9O1xufVxuXG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuXHRyZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlclNraXBwZWQodm0pIHtcblx0dmFyIGVkZ2UgPSB2bS5ib3JkZXJTa2lwcGVkO1xuXHR2YXIgcmVzID0ge307XG5cblx0aWYgKCFlZGdlKSB7XG5cdFx0cmV0dXJuIHJlcztcblx0fVxuXG5cdGlmICh2bS5ob3Jpem9udGFsKSB7XG5cdFx0aWYgKHZtLmJhc2UgPiB2bS54KSB7XG5cdFx0XHRlZGdlID0gc3dhcChlZGdlLCAnbGVmdCcsICdyaWdodCcpO1xuXHRcdH1cblx0fSBlbHNlIGlmICh2bS5iYXNlIDwgdm0ueSkge1xuXHRcdGVkZ2UgPSBzd2FwKGVkZ2UsICdib3R0b20nLCAndG9wJyk7XG5cdH1cblxuXHRyZXNbZWRnZV0gPSB0cnVlO1xuXHRyZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKHZtLCBtYXhXLCBtYXhIKSB7XG5cdHZhciB2YWx1ZSA9IHZtLmJvcmRlcldpZHRoO1xuXHR2YXIgc2tpcCA9IHBhcnNlQm9yZGVyU2tpcHBlZCh2bSk7XG5cdHZhciB0LCByLCBiLCBsO1xuXG5cdGlmIChoZWxwZXJzJDEuaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0dCA9ICt2YWx1ZS50b3AgfHwgMDtcblx0XHRyID0gK3ZhbHVlLnJpZ2h0IHx8IDA7XG5cdFx0YiA9ICt2YWx1ZS5ib3R0b20gfHwgMDtcblx0XHRsID0gK3ZhbHVlLmxlZnQgfHwgMDtcblx0fSBlbHNlIHtcblx0XHR0ID0gciA9IGIgPSBsID0gK3ZhbHVlIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHQ6IHNraXAudG9wIHx8ICh0IDwgMCkgPyAwIDogdCA+IG1heEggPyBtYXhIIDogdCxcblx0XHRyOiBza2lwLnJpZ2h0IHx8IChyIDwgMCkgPyAwIDogciA+IG1heFcgPyBtYXhXIDogcixcblx0XHRiOiBza2lwLmJvdHRvbSB8fCAoYiA8IDApID8gMCA6IGIgPiBtYXhIID8gbWF4SCA6IGIsXG5cdFx0bDogc2tpcC5sZWZ0IHx8IChsIDwgMCkgPyAwIDogbCA+IG1heFcgPyBtYXhXIDogbFxuXHR9O1xufVxuXG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKHZtKSB7XG5cdHZhciBib3VuZHMgPSBnZXRCYXJCb3VuZHModm0pO1xuXHR2YXIgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcblx0dmFyIGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuXHR2YXIgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aCh2bSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuXHRyZXR1cm4ge1xuXHRcdG91dGVyOiB7XG5cdFx0XHR4OiBib3VuZHMubGVmdCxcblx0XHRcdHk6IGJvdW5kcy50b3AsXG5cdFx0XHR3OiB3aWR0aCxcblx0XHRcdGg6IGhlaWdodFxuXHRcdH0sXG5cdFx0aW5uZXI6IHtcblx0XHRcdHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG5cdFx0XHR5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG5cdFx0XHR3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG5cdFx0XHRoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iXG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBpblJhbmdlKHZtLCB4LCB5KSB7XG5cdHZhciBza2lwWCA9IHggPT09IG51bGw7XG5cdHZhciBza2lwWSA9IHkgPT09IG51bGw7XG5cdHZhciBib3VuZHMgPSAhdm0gfHwgKHNraXBYICYmIHNraXBZKSA/IGZhbHNlIDogZ2V0QmFyQm91bmRzKHZtKTtcblxuXHRyZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IHggPj0gYm91bmRzLmxlZnQgJiYgeCA8PSBib3VuZHMucmlnaHQpXG5cdFx0JiYgKHNraXBZIHx8IHkgPj0gYm91bmRzLnRvcCAmJiB5IDw9IGJvdW5kcy5ib3R0b20pO1xufVxuXG52YXIgZWxlbWVudF9yZWN0YW5nbGUgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXHRcdHZhciByZWN0cyA9IGJvdW5kaW5nUmVjdHModm0pO1xuXHRcdHZhciBvdXRlciA9IHJlY3RzLm91dGVyO1xuXHRcdHZhciBpbm5lciA9IHJlY3RzLmlubmVyO1xuXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJhY2tncm91bmRDb2xvcjtcblx0XHRjdHguZmlsbFJlY3Qob3V0ZXIueCwgb3V0ZXIueSwgb3V0ZXIudywgb3V0ZXIuaCk7XG5cblx0XHRpZiAob3V0ZXIudyA9PT0gaW5uZXIudyAmJiBvdXRlci5oID09PSBpbm5lci5oKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4LnJlY3Qob3V0ZXIueCwgb3V0ZXIueSwgb3V0ZXIudywgb3V0ZXIuaCk7XG5cdFx0Y3R4LmNsaXAoKTtcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYm9yZGVyQ29sb3I7XG5cdFx0Y3R4LnJlY3QoaW5uZXIueCwgaW5uZXIueSwgaW5uZXIudywgaW5uZXIuaCk7XG5cdFx0Y3R4LmZpbGwoJ2V2ZW5vZGQnKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHR9LFxuXG5cdGhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4gdm0uYmFzZSAtIHZtLnk7XG5cdH0sXG5cblx0aW5SYW5nZTogZnVuY3Rpb24obW91c2VYLCBtb3VzZVkpIHtcblx0XHRyZXR1cm4gaW5SYW5nZSh0aGlzLl92aWV3LCBtb3VzZVgsIG1vdXNlWSk7XG5cdH0sXG5cblx0aW5MYWJlbFJhbmdlOiBmdW5jdGlvbihtb3VzZVgsIG1vdXNlWSkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0cmV0dXJuIGlzVmVydGljYWwodm0pXG5cdFx0XHQ/IGluUmFuZ2Uodm0sIG1vdXNlWCwgbnVsbClcblx0XHRcdDogaW5SYW5nZSh2bSwgbnVsbCwgbW91c2VZKTtcblx0fSxcblxuXHRpblhSYW5nZTogZnVuY3Rpb24obW91c2VYKSB7XG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbW91c2VYLCBudWxsKTtcblx0fSxcblxuXHRpbllSYW5nZTogZnVuY3Rpb24obW91c2VZKSB7XG5cdFx0cmV0dXJuIGluUmFuZ2UodGhpcy5fdmlldywgbnVsbCwgbW91c2VZKTtcblx0fSxcblxuXHRnZXRDZW50ZXJQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHR2YXIgeCwgeTtcblx0XHRpZiAoaXNWZXJ0aWNhbCh2bSkpIHtcblx0XHRcdHggPSB2bS54O1xuXHRcdFx0eSA9ICh2bS55ICsgdm0uYmFzZSkgLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR4ID0gKHZtLnggKyB2bS5iYXNlKSAvIDI7XG5cdFx0XHR5ID0gdm0ueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge3g6IHgsIHk6IHl9O1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cblx0XHRyZXR1cm4gaXNWZXJ0aWNhbCh2bSlcblx0XHRcdD8gdm0ud2lkdGggKiBNYXRoLmFicyh2bS55IC0gdm0uYmFzZSlcblx0XHRcdDogdm0uaGVpZ2h0ICogTWF0aC5hYnModm0ueCAtIHZtLmJhc2UpO1xuXHR9LFxuXG5cdHRvb2x0aXBQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZtID0gdGhpcy5fdmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIGVsZW1lbnRzID0ge307XG52YXIgQXJjID0gZWxlbWVudF9hcmM7XG52YXIgTGluZSA9IGVsZW1lbnRfbGluZTtcbnZhciBQb2ludCA9IGVsZW1lbnRfcG9pbnQ7XG52YXIgUmVjdGFuZ2xlID0gZWxlbWVudF9yZWN0YW5nbGU7XG5lbGVtZW50cy5BcmMgPSBBcmM7XG5lbGVtZW50cy5MaW5lID0gTGluZTtcbmVsZW1lbnRzLlBvaW50ID0gUG9pbnQ7XG5lbGVtZW50cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG5cbnZhciByZXNvbHZlJDEgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2JhcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnbGFiZWwnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0Y2F0ZWdvcnlQZXJjZW50YWdlOiAwLjgsXG5cdFx0XHRiYXJQZXJjZW50YWdlOiAwLjksXG5cdFx0XHRvZmZzZXQ6IHRydWUsXG5cdFx0XHRncmlkTGluZXM6IHtcblx0XHRcdFx0b2Zmc2V0R3JpZExpbmVzOiB0cnVlXG5cdFx0XHR9XG5cdFx0fV0sXG5cblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInXG5cdFx0fV1cblx0fVxufSk7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShzY2FsZSwgcGl4ZWxzKSB7XG5cdHZhciBtaW4gPSBzY2FsZS5pc0hvcml6b250YWwoKSA/IHNjYWxlLndpZHRoIDogc2NhbGUuaGVpZ2h0O1xuXHR2YXIgdGlja3MgPSBzY2FsZS5nZXRUaWNrcygpO1xuXHR2YXIgcHJldiwgY3VyciwgaSwgaWxlbjtcblxuXHRmb3IgKGkgPSAxLCBpbGVuID0gcGl4ZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMocGl4ZWxzW2ldIC0gcGl4ZWxzW2kgLSAxXSkpO1xuXHR9XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XG5cdFx0bWluID0gaSA+IDAgPyBNYXRoLm1pbihtaW4sIGN1cnIgLSBwcmV2KSA6IG1pbjtcblx0XHRwcmV2ID0gY3Vycjtcblx0fVxuXG5cdHJldHVybiBtaW47XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJpZGVhbFwiIGNhdGVnb3J5IGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBiYXIgdGhpY2tuZXNzIG9yLCBpZiB1bmRlZmluZWQgb3IgbnVsbCxcbiAqIHVzZXMgdGhlIHNtYWxsZXN0IGludGVydmFsIChzZWUgY29tcHV0ZU1pblNhbXBsZVNpemUpIHRoYXQgcHJldmVudHMgYmFyIG92ZXJsYXBwaW5nLiBUaGlzXG4gKiBtb2RlIGN1cnJlbnRseSBhbHdheXMgZ2VuZXJhdGVzIGJhcnMgZXF1YWxseSBzaXplZCAodW50aWwgd2UgaW50cm9kdWNlIHNjcmlwdGFibGUgb3B0aW9ucz8pLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucykge1xuXHR2YXIgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG5cdHZhciBjb3VudCA9IHJ1bGVyLnN0YWNrQ291bnQ7XG5cdHZhciBjdXJyID0gcnVsZXIucGl4ZWxzW2luZGV4XTtcblx0dmFyIHNpemUsIHJhdGlvO1xuXG5cdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG5cdFx0c2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXHRcdHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuXHR9IGVsc2Uge1xuXHRcdC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cblx0XHQvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcblx0XHQvLyBhbmQgZGVwcmVjYXRlIGJhclBlcmNlbnRhZ2Ugc2luY2UgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIHdoZW4gdGhpY2tuZXNzIGlzIGFic29sdXRlLlxuXHRcdHNpemUgPSB0aGlja25lc3MgKiBjb3VudDtcblx0XHRyYXRpbyA9IDE7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGNodW5rOiBzaXplIC8gY291bnQsXG5cdFx0cmF0aW86IHJhdGlvLFxuXHRcdHN0YXJ0OiBjdXJyIC0gKHNpemUgLyAyKVxuXHR9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcbiAqIGdlbmVyYXRlcyBiYXJzIHdpdGggZGlmZmVyZW50IHdpZHRocyB3aGVuIGRhdGEgYXJlIG5vdCBldmVubHkgc3BhY2VkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMpIHtcblx0dmFyIHBpeGVscyA9IHJ1bGVyLnBpeGVscztcblx0dmFyIGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuXHR2YXIgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcblx0dmFyIG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuXHR2YXIgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXHR2YXIgc3RhcnQsIHNpemU7XG5cblx0aWYgKHByZXYgPT09IG51bGwpIHtcblx0XHQvLyBmaXJzdCBkYXRhOiBpdHMgc2l6ZSBpcyBkb3VibGUgYmFzZWQgb24gdGhlIG5leHQgcG9pbnQgb3IsXG5cdFx0Ly8gaWYgaXQncyBhbHNvIHRoZSBsYXN0IGRhdGEsIHdlIHVzZSB0aGUgc2NhbGUgc2l6ZS5cblx0XHRwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG5cdH1cblxuXHRpZiAobmV4dCA9PT0gbnVsbCkge1xuXHRcdC8vIGxhc3QgZGF0YTogaXRzIHNpemUgaXMgYWxzbyBkb3VibGUgYmFzZWQgb24gdGhlIHByZXZpb3VzIHBvaW50LlxuXHRcdG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG5cdH1cblxuXHRzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuXHRzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG5cblx0cmV0dXJuIHtcblx0XHRjaHVuazogc2l6ZSAvIHJ1bGVyLnN0YWNrQ291bnQsXG5cdFx0cmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcblx0XHRzdGFydDogc3RhcnRcblx0fTtcbn1cblxudmFyIGNvbnRyb2xsZXJfYmFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUmVjdGFuZ2xlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGE7XG5cblx0XHRjb3JlX2RhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0bWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHRtZXRhLnN0YWNrID0gbWUuZ2V0RGF0YXNldCgpLnN0YWNrO1xuXHRcdG1ldGEuYmFyID0gdHJ1ZTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgcmVjdHMgPSBtZS5nZXRNZXRhKCkuZGF0YTtcblx0XHR2YXIgaSwgaWxlbjtcblxuXHRcdG1lLl9ydWxlciA9IG1lLmdldFJ1bGVyKCk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcmVjdHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHJlY3RzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMocmVjdGFuZ2xlLCBpbmRleCk7XG5cblx0XHRyZWN0YW5nbGUuX3hTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHRyZWN0YW5nbGUuX3lTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHRyZWN0YW5nbGUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdHJlY3RhbmdsZS5faW5kZXggPSBpbmRleDtcblx0XHRyZWN0YW5nbGUuX21vZGVsID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyU2tpcHBlZDogb3B0aW9ucy5ib3JkZXJTa2lwcGVkLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRkYXRhc2V0TGFiZWw6IGRhdGFzZXQubGFiZWwsXG5cdFx0XHRsYWJlbDogbWUuY2hhcnQuZGF0YS5sYWJlbHNbaW5kZXhdXG5cdFx0fTtcblxuXHRcdG1lLl91cGRhdGVFbGVtZW50R2VvbWV0cnkocmVjdGFuZ2xlLCBpbmRleCwgcmVzZXQpO1xuXG5cdFx0cmVjdGFuZ2xlLnBpdm90KCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdXBkYXRlRWxlbWVudEdlb21ldHJ5OiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1vZGVsID0gcmVjdGFuZ2xlLl9tb2RlbDtcblx0XHR2YXIgdnNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcblx0XHR2YXIgYmFzZSA9IHZzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcblx0XHR2YXIgaG9yaXpvbnRhbCA9IHZzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgcnVsZXIgPSBtZS5fcnVsZXIgfHwgbWUuZ2V0UnVsZXIoKTtcblx0XHR2YXIgdnBpeGVscyA9IG1lLmNhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKG1lLmluZGV4LCBpbmRleCk7XG5cdFx0dmFyIGlwaXhlbHMgPSBtZS5jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhtZS5pbmRleCwgaW5kZXgsIHJ1bGVyKTtcblxuXHRcdG1vZGVsLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuXHRcdG1vZGVsLmJhc2UgPSByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmJhc2U7XG5cdFx0bW9kZWwueCA9IGhvcml6b250YWwgPyByZXNldCA/IGJhc2UgOiB2cGl4ZWxzLmhlYWQgOiBpcGl4ZWxzLmNlbnRlcjtcblx0XHRtb2RlbC55ID0gaG9yaXpvbnRhbCA/IGlwaXhlbHMuY2VudGVyIDogcmVzZXQgPyBiYXNlIDogdnBpeGVscy5oZWFkO1xuXHRcdG1vZGVsLmhlaWdodCA9IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiB1bmRlZmluZWQ7XG5cdFx0bW9kZWwud2lkdGggPSBob3Jpem9udGFsID8gdW5kZWZpbmVkIDogaXBpeGVscy5zaXplO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtsYXN0XSAtIFRoZSBkYXRhc2V0IGluZGV4XG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0U3RhY2tzOiBmdW5jdGlvbihsYXN0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpO1xuXHRcdHZhciBzdGFja2VkID0gc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuXHRcdHZhciBpbGVuID0gbGFzdCA9PT0gdW5kZWZpbmVkID8gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGggOiBsYXN0ICsgMTtcblx0XHR2YXIgc3RhY2tzID0gW107XG5cdFx0dmFyIGksIG1ldGE7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cdFx0XHRpZiAobWV0YS5iYXIgJiYgY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSAmJlxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gZmFsc2UgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHRydWUgJiYgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xKSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIChtZXRhLnN0YWNrID09PSB1bmRlZmluZWQgfHwgc3RhY2tzLmluZGV4T2YobWV0YS5zdGFjaykgPT09IC0xKSkpKSB7XG5cdFx0XHRcdHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBzdGFja3M7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBudW1iZXIgb2Ygc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRTdGFja0NvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0U3RhY2tzKCkubGVuZ3RoO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFjayBpbmRleCBmb3IgdGhlIGdpdmVuIGRhdGFzZXQgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhc2V0SW5kZXhdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBzdGFjayBuYW1lIHRvIGZpbmRcblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRTdGFja0luZGV4OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgsIG5hbWUpIHtcblx0XHR2YXIgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCk7XG5cdFx0dmFyIGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcblx0XHRcdD8gc3RhY2tzLmluZGV4T2YobmFtZSlcblx0XHRcdDogLTE7IC8vIGluZGV4T2YgcmV0dXJucyAtMSBpZiBlbGVtZW50IGlzIG5vdCBwcmVzZW50XG5cblx0XHRyZXR1cm4gKGluZGV4ID09PSAtMSlcblx0XHRcdD8gc3RhY2tzLmxlbmd0aCAtIDFcblx0XHRcdDogaW5kZXg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRSdWxlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0SW5kZXhTY2FsZSgpO1xuXHRcdHZhciBzdGFja0NvdW50ID0gbWUuZ2V0U3RhY2tDb3VudCgpO1xuXHRcdHZhciBkYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIHN0YXJ0ID0gaXNIb3Jpem9udGFsID8gc2NhbGUubGVmdCA6IHNjYWxlLnRvcDtcblx0XHR2YXIgZW5kID0gc3RhcnQgKyAoaXNIb3Jpem9udGFsID8gc2NhbGUud2lkdGggOiBzY2FsZS5oZWlnaHQpO1xuXHRcdHZhciBwaXhlbHMgPSBbXTtcblx0XHR2YXIgaSwgaWxlbiwgbWluO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmdldE1ldGEoKS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cGl4ZWxzLnB1c2goc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShudWxsLCBpLCBkYXRhc2V0SW5kZXgpKTtcblx0XHR9XG5cblx0XHRtaW4gPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZihzY2FsZS5vcHRpb25zLmJhclRoaWNrbmVzcylcblx0XHRcdD8gY29tcHV0ZU1pblNhbXBsZVNpemUoc2NhbGUsIHBpeGVscylcblx0XHRcdDogLTE7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0bWluOiBtaW4sXG5cdFx0XHRwaXhlbHM6IHBpeGVscyxcblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGVuZDogZW5kLFxuXHRcdFx0c3RhY2tDb3VudDogc3RhY2tDb3VudCxcblx0XHRcdHNjYWxlOiBzY2FsZVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIE5vdGU6IHBpeGVsIHZhbHVlcyBhcmUgbm90IGNsYW1wZWQgdG8gdGhlIHNjYWxlIGFyZWEuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjYWxjdWxhdGVCYXJWYWx1ZVBpeGVsczogZnVuY3Rpb24oZGF0YXNldEluZGV4LCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHNjYWxlID0gbWUuX2dldFZhbHVlU2NhbGUoKTtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgdmFsdWUgPSArc2NhbGUuZ2V0UmlnaHRWYWx1ZShkYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0XHR2YXIgbWluQmFyTGVuZ3RoID0gc2NhbGUub3B0aW9ucy5taW5CYXJMZW5ndGg7XG5cdFx0dmFyIHN0YWNrZWQgPSBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG5cdFx0dmFyIHN0YWNrID0gbWV0YS5zdGFjaztcblx0XHR2YXIgc3RhcnQgPSAwO1xuXHRcdHZhciBpLCBpbWV0YSwgaXZhbHVlLCBiYXNlLCBoZWFkLCBzaXplO1xuXG5cdFx0aWYgKHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBzdGFjayAhPT0gdW5kZWZpbmVkKSkge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG5cdFx0XHRcdGltZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG5cblx0XHRcdFx0aWYgKGltZXRhLmJhciAmJlxuXHRcdFx0XHRcdGltZXRhLnN0YWNrID09PSBzdGFjayAmJlxuXHRcdFx0XHRcdGltZXRhLmNvbnRyb2xsZXIuX2dldFZhbHVlU2NhbGVJZCgpID09PSBzY2FsZS5pZCAmJlxuXHRcdFx0XHRcdGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblxuXHRcdFx0XHRcdGl2YWx1ZSA9ICtzY2FsZS5nZXRSaWdodFZhbHVlKGRhdGFzZXRzW2ldLmRhdGFbaW5kZXhdKTtcblx0XHRcdFx0XHRpZiAoKHZhbHVlIDwgMCAmJiBpdmFsdWUgPCAwKSB8fCAodmFsdWUgPj0gMCAmJiBpdmFsdWUgPiAwKSkge1xuXHRcdFx0XHRcdFx0c3RhcnQgKz0gaXZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGJhc2UgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0KTtcblx0XHRoZWFkID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIHZhbHVlKTtcblx0XHRzaXplID0gaGVhZCAtIGJhc2U7XG5cblx0XHRpZiAobWluQmFyTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgTWF0aC5hYnMoc2l6ZSkgPCBtaW5CYXJMZW5ndGgpIHtcblx0XHRcdHNpemUgPSBtaW5CYXJMZW5ndGg7XG5cdFx0XHRpZiAodmFsdWUgPj0gMCAmJiAhaXNIb3Jpem9udGFsIHx8IHZhbHVlIDwgMCAmJiBpc0hvcml6b250YWwpIHtcblx0XHRcdFx0aGVhZCA9IGJhc2UgLSBtaW5CYXJMZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoZWFkID0gYmFzZSArIG1pbkJhckxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2l6ZTogc2l6ZSxcblx0XHRcdGJhc2U6IGJhc2UsXG5cdFx0XHRoZWFkOiBoZWFkLFxuXHRcdFx0Y2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Y2FsY3VsYXRlQmFySW5kZXhQaXhlbHM6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCwgaW5kZXgsIHJ1bGVyKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IHJ1bGVyLnNjYWxlLm9wdGlvbnM7XG5cdFx0dmFyIHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuXHRcdFx0PyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucylcblx0XHRcdDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucyk7XG5cblx0XHR2YXIgc3RhY2tJbmRleCA9IG1lLmdldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBtZS5nZXRNZXRhKCkuc3RhY2spO1xuXHRcdHZhciBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG5cdFx0dmFyIHNpemUgPSBNYXRoLm1pbihcblx0XHRcdGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpLFxuXHRcdFx0cmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXG5cdFx0XHRoZWFkOiBjZW50ZXIgKyBzaXplIC8gMixcblx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0c2l6ZTogc2l6ZVxuXHRcdH07XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgc2NhbGUgPSBtZS5fZ2V0VmFsdWVTY2FsZSgpO1xuXHRcdHZhciByZWN0cyA9IG1lLmdldE1ldGEoKS5kYXRhO1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBpbGVuID0gcmVjdHMubGVuZ3RoO1xuXHRcdHZhciBpID0gMDtcblxuXHRcdGhlbHBlcnMkMS5jYW52YXMuY2xpcEFyZWEoY2hhcnQuY3R4LCBjaGFydC5jaGFydEFyZWEpO1xuXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmICghaXNOYU4oc2NhbGUuZ2V0UmlnaHRWYWx1ZShkYXRhc2V0LmRhdGFbaV0pKSkge1xuXHRcdFx0XHRyZWN0c1tpXS5kcmF3KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihyZWN0YW5nbGUsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBkYXRhc2V0ID0gZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSByZWN0YW5nbGUuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5yZWN0YW5nbGU7XG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdHZhciBpLCBpbGVuLCBrZXk7XG5cblx0XHQvLyBTY3JpcHRhYmxlIG9wdGlvbnNcblx0XHR2YXIgY29udGV4dCA9IHtcblx0XHRcdGNoYXJ0OiBjaGFydCxcblx0XHRcdGRhdGFJbmRleDogaW5kZXgsXG5cdFx0XHRkYXRhc2V0OiBkYXRhc2V0LFxuXHRcdFx0ZGF0YXNldEluZGV4OiBtZS5pbmRleFxuXHRcdH07XG5cblx0XHR2YXIga2V5cyA9IFtcblx0XHRcdCdiYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJTa2lwcGVkJyxcblx0XHRcdCdib3JkZXJXaWR0aCdcblx0XHRdO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dmFsdWVzW2tleV0gPSByZXNvbHZlJDEoW1xuXHRcdFx0XHRjdXN0b21ba2V5XSxcblx0XHRcdFx0ZGF0YXNldFtrZXldLFxuXHRcdFx0XHRvcHRpb25zW2tleV1cblx0XHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG59KTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JDMgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG52YXIgcmVzb2x2ZSQyID0gaGVscGVycyQxLm9wdGlvbnMucmVzb2x2ZTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdidWJibGUnLCB7XG5cdGhvdmVyOiB7XG5cdFx0bW9kZTogJ3NpbmdsZSdcblx0fSxcblxuXHRzY2FsZXM6IHtcblx0XHR4QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLCAvLyBidWJibGUgc2hvdWxkIHByb2JhYmx5IHVzZSBhIGxpbmVhciBzY2FsZSBieSBkZWZhdWx0XG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbScsXG5cdFx0XHRpZDogJ3gtYXhpcy0wJyAvLyBuZWVkIGFuIElEIHNvIGRhdGFzZXRzIGNhbiByZWZlcmVuY2UgdGhlIHNjYWxlXG5cdFx0fV0sXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnbGluZWFyJyxcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHRpZDogJ3ktYXhpcy0wJ1xuXHRcdH1dXG5cdH0sXG5cblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGl0bGUgZG9lc24ndCBtYWtlIHNlbnNlIGZvciBzY2F0dGVyIHNpbmNlIHdlIGZvcm1hdCB0aGUgZGF0YSBhcyBhIHBvaW50XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgZGF0YXNldExhYmVsID0gZGF0YS5kYXRhc2V0c1tpdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cdFx0XHRcdHZhciBkYXRhUG9pbnQgPSBkYXRhLmRhdGFzZXRzW2l0ZW0uZGF0YXNldEluZGV4XS5kYXRhW2l0ZW0uaW5kZXhdO1xuXHRcdFx0XHRyZXR1cm4gZGF0YXNldExhYmVsICsgJzogKCcgKyBpdGVtLnhMYWJlbCArICcsICcgKyBpdGVtLnlMYWJlbCArICcsICcgKyBkYXRhUG9pbnQuciArICcpJztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9idWJibGUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlBvaW50LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHR1cGRhdGU6IGZ1bmN0aW9uKHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhO1xuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGhlbHBlcnMkMS5lYWNoKHBvaW50cywgZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50LCBpbmRleCwgcmVzZXQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciB4U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueEF4aXNJRCk7XG5cdFx0dmFyIHlTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS55QXhpc0lEKTtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblx0XHR2YXIgZGF0YSA9IG1lLmdldERhdGFzZXQoKS5kYXRhW2luZGV4XTtcblx0XHR2YXIgZHNJbmRleCA9IG1lLmluZGV4O1xuXG5cdFx0dmFyIHggPSByZXNldCA/IHhTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMC41KSA6IHhTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGEgOiBOYU4sIGluZGV4LCBkc0luZGV4KTtcblx0XHR2YXIgeSA9IHJlc2V0ID8geVNjYWxlLmdldEJhc2VQaXhlbCgpIDogeVNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZGF0YSwgaW5kZXgsIGRzSW5kZXgpO1xuXG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcblx0XHRwb2ludC5feVNjYWxlID0geVNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZHNJbmRleDtcblx0XHRwb2ludC5faW5kZXggPSBpbmRleDtcblx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcblx0XHRcdGhpdFJhZGl1czogb3B0aW9ucy5oaXRSYWRpdXMsXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdHJhZGl1czogcmVzZXQgPyAwIDogb3B0aW9ucy5yYWRpdXMsXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdHg6IHgsXG5cdFx0XHR5OiB5LFxuXHRcdH07XG5cblx0XHRwb2ludC5waXZvdCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRzZXRIb3ZlclN0eWxlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBtb2RlbCA9IHBvaW50Ll9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IHBvaW50Ll9vcHRpb25zO1xuXHRcdHZhciBnZXRIb3ZlckNvbG9yID0gaGVscGVycyQxLmdldEhvdmVyQ29sb3I7XG5cblx0XHRwb2ludC4kcHJldmlvdXNTdHlsZSA9IHtcblx0XHRcdGJhY2tncm91bmRDb2xvcjogbW9kZWwuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0Ym9yZGVyQ29sb3I6IG1vZGVsLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG1vZGVsLmJvcmRlcldpZHRoLFxuXHRcdFx0cmFkaXVzOiBtb2RlbC5yYWRpdXNcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQkMyhvcHRpb25zLmhvdmVyQmFja2dyb3VuZENvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQzKG9wdGlvbnMuaG92ZXJCb3JkZXJDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKSk7XG5cdFx0bW9kZWwuYm9yZGVyV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCQzKG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdFx0bW9kZWwucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhvdmVyUmFkaXVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVFbGVtZW50T3B0aW9uczogZnVuY3Rpb24ocG9pbnQsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBkYXRhc2V0ID0gZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLnBvaW50O1xuXHRcdHZhciBkYXRhID0gZGF0YXNldC5kYXRhW2luZGV4XTtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XHQnaG92ZXJSYWRpdXMnLFxuXHRcdFx0J2hpdFJhZGl1cycsXG5cdFx0XHQncG9pbnRTdHlsZScsXG5cdFx0XHQncm90YXRpb24nXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQyKFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ3VzdG9tIHJhZGl1cyByZXNvbHV0aW9uXG5cdFx0dmFsdWVzLnJhZGl1cyA9IHJlc29sdmUkMihbXG5cdFx0XHRjdXN0b20ucmFkaXVzLFxuXHRcdFx0ZGF0YSA/IGRhdGEuciA6IHVuZGVmaW5lZCxcblx0XHRcdGRhdGFzZXQucmFkaXVzLFxuXHRcdFx0b3B0aW9ucy5yYWRpdXNcblx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9XG59KTtcblxudmFyIHJlc29sdmUkMyA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG52YXIgdmFsdWVPckRlZmF1bHQkNCA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdkb3VnaG51dCcsIHtcblx0YW5pbWF0aW9uOiB7XG5cdFx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgd2UgYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIERvdWdobnV0XG5cdFx0YW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcblx0XHQvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxuXHRcdGFuaW1hdGVTY2FsZTogZmFsc2Vcblx0fSxcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdHRleHQucHVzaCgnPHVsIGNsYXNzPVwiJyArIGNoYXJ0LmlkICsgJy1sZWdlbmRcIj4nKTtcblxuXHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHR2YXIgZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzO1xuXHRcdHZhciBsYWJlbHMgPSBkYXRhLmxhYmVscztcblxuXHRcdGlmIChkYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YXNldHNbMF0uZGF0YS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0ZXh0LnB1c2goJzxsaT48c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGRhdGFzZXRzWzBdLmJhY2tncm91bmRDb2xvcltpXSArICdcIj48L3NwYW4+Jyk7XG5cdFx0XHRcdGlmIChsYWJlbHNbaV0pIHtcblx0XHRcdFx0XHR0ZXh0LnB1c2gobGFiZWxzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0LnB1c2goJzwvbGk+Jyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGV4dC5wdXNoKCc8L3VsPicpO1xuXHRcdHJldHVybiB0ZXh0LmpvaW4oJycpO1xuXHR9LFxuXHRsZWdlbmQ6IHtcblx0XHRsYWJlbHM6IHtcblx0XHRcdGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0XHRcdGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YS5sYWJlbHMubWFwKGZ1bmN0aW9uKGxhYmVsLCBpKSB7XG5cdFx0XHRcdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuXHRcdFx0XHRcdFx0dmFyIGRzID0gZGF0YS5kYXRhc2V0c1swXTtcblx0XHRcdFx0XHRcdHZhciBhcmMgPSBtZXRhLmRhdGFbaV07XG5cdFx0XHRcdFx0XHR2YXIgY3VzdG9tID0gYXJjICYmIGFyYy5jdXN0b20gfHwge307XG5cdFx0XHRcdFx0XHR2YXIgYXJjT3B0cyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdFx0XHRcdFx0dmFyIGZpbGwgPSByZXNvbHZlJDMoW2N1c3RvbS5iYWNrZ3JvdW5kQ29sb3IsIGRzLmJhY2tncm91bmRDb2xvciwgYXJjT3B0cy5iYWNrZ3JvdW5kQ29sb3JdLCB1bmRlZmluZWQsIGkpO1xuXHRcdFx0XHRcdFx0dmFyIHN0cm9rZSA9IHJlc29sdmUkMyhbY3VzdG9tLmJvcmRlckNvbG9yLCBkcy5ib3JkZXJDb2xvciwgYXJjT3B0cy5ib3JkZXJDb2xvcl0sIHVuZGVmaW5lZCwgaSk7XG5cdFx0XHRcdFx0XHR2YXIgYncgPSByZXNvbHZlJDMoW2N1c3RvbS5ib3JkZXJXaWR0aCwgZHMuYm9yZGVyV2lkdGgsIGFyY09wdHMuYm9yZGVyV2lkdGhdLCB1bmRlZmluZWQsIGkpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBsYWJlbCxcblx0XHRcdFx0XHRcdFx0ZmlsbFN0eWxlOiBmaWxsLFxuXHRcdFx0XHRcdFx0XHRzdHJva2VTdHlsZTogc3Ryb2tlLFxuXHRcdFx0XHRcdFx0XHRsaW5lV2lkdGg6IGJ3LFxuXHRcdFx0XHRcdFx0XHRoaWRkZW46IGlzTmFOKGRzLmRhdGFbaV0pIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4sXG5cblx0XHRcdFx0XHRcdFx0Ly8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5pbmRleDtcblx0XHRcdHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cdFx0XHR2YXIgaSwgaWxlbiwgbWV0YTtcblxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHQvLyB0b2dnbGUgdmlzaWJpbGl0eSBvZiBpbmRleCBpZiBleGlzdHNcblx0XHRcdFx0aWYgKG1ldGEuZGF0YVtpbmRleF0pIHtcblx0XHRcdFx0XHRtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiA9ICFtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjaGFydC51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuXHRjdXRvdXRQZXJjZW50YWdlOiA1MCxcblxuXHQvLyBUaGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0LCB3aGVyZSB0aGUgZmlyc3QgZGF0YSBhcmMgYmVnaW5zLlxuXHRyb3RhdGlvbjogTWF0aC5QSSAqIC0wLjUsXG5cblx0Ly8gVGhlIHRvdGFsIGNpcmN1bWZlcmVuY2Ugb2YgdGhlIGNoYXJ0LlxuXHRjaXJjdW1mZXJlbmNlOiBNYXRoLlBJICogMi4wLFxuXG5cdC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWw6IGZ1bmN0aW9uKHRvb2x0aXBJdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHZhciBkYXRhTGFiZWwgPSBkYXRhLmxhYmVsc1t0b29sdGlwSXRlbS5pbmRleF07XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICc6ICcgKyBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0uZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XG5cblx0XHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGRhdGFMYWJlbCkpIHtcblx0XHRcdFx0XHQvLyBzaG93IHZhbHVlIG9uIGZpcnN0IGxpbmUgb2YgbXVsdGlsaW5lIGxhYmVsXG5cdFx0XHRcdFx0Ly8gbmVlZCB0byBjbG9uZSBiZWNhdXNlIHdlIGFyZSBjaGFuZ2luZyB0aGUgdmFsdWVcblx0XHRcdFx0XHRkYXRhTGFiZWwgPSBkYXRhTGFiZWwuc2xpY2UoKTtcblx0XHRcdFx0XHRkYXRhTGFiZWxbMF0gKz0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YUxhYmVsICs9IHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGRhdGFMYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9kb3VnaG51dCA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXIuZXh0ZW5kKHtcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLkFyYyxcblxuXHRsaW5rU2NhbGVzOiBoZWxwZXJzJDEubm9vcCxcblxuXHQvLyBHZXQgaW5kZXggb2YgdGhlIGRhdGFzZXQgaW4gcmVsYXRpb24gdG8gdGhlIHZpc2libGUgZGF0YXNldHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxuXHRnZXRSaW5nSW5kZXg6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciByaW5nSW5kZXggPSAwO1xuXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkYXRhc2V0SW5kZXg7ICsraikge1xuXHRcdFx0aWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShqKSkge1xuXHRcdFx0XHQrK3JpbmdJbmRleDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmluZ0luZGV4O1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIG9wdHMgPSBjaGFydC5vcHRpb25zO1xuXHRcdHZhciBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0O1xuXHRcdHZhciBhdmFpbGFibGVIZWlnaHQgPSBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcDtcblx0XHR2YXIgbWluU2l6ZSA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpO1xuXHRcdHZhciBvZmZzZXQgPSB7eDogMCwgeTogMH07XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGFyY3MgPSBtZXRhLmRhdGE7XG5cdFx0dmFyIGN1dG91dFBlcmNlbnRhZ2UgPSBvcHRzLmN1dG91dFBlcmNlbnRhZ2U7XG5cdFx0dmFyIGNpcmN1bWZlcmVuY2UgPSBvcHRzLmNpcmN1bWZlcmVuY2U7XG5cdFx0dmFyIGNoYXJ0V2VpZ2h0ID0gbWUuX2dldFJpbmdXZWlnaHQobWUuaW5kZXgpO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0Ly8gSWYgdGhlIGNoYXJ0J3MgY2lyY3VtZmVyZW5jZSBpc24ndCBhIGZ1bGwgY2lyY2xlLCBjYWxjdWxhdGUgbWluU2l6ZSBhcyBhIHJhdGlvIG9mIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGFyY1xuXHRcdGlmIChjaXJjdW1mZXJlbmNlIDwgTWF0aC5QSSAqIDIuMCkge1xuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uICUgKE1hdGguUEkgKiAyLjApO1xuXHRcdFx0c3RhcnRBbmdsZSArPSBNYXRoLlBJICogMi4wICogKHN0YXJ0QW5nbGUgPj0gTWF0aC5QSSA/IC0xIDogc3RhcnRBbmdsZSA8IC1NYXRoLlBJID8gMSA6IDApO1xuXHRcdFx0dmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG5cdFx0XHR2YXIgc3RhcnQgPSB7eDogTWF0aC5jb3Moc3RhcnRBbmdsZSksIHk6IE1hdGguc2luKHN0YXJ0QW5nbGUpfTtcblx0XHRcdHZhciBlbmQgPSB7eDogTWF0aC5jb3MoZW5kQW5nbGUpLCB5OiBNYXRoLnNpbihlbmRBbmdsZSl9O1xuXHRcdFx0dmFyIGNvbnRhaW5zMCA9IChzdGFydEFuZ2xlIDw9IDAgJiYgZW5kQW5nbGUgPj0gMCkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDIuMCAmJiBNYXRoLlBJICogMi4wIDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciBjb250YWluczkwID0gKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDAuNSAmJiBNYXRoLlBJICogMC41IDw9IGVuZEFuZ2xlKSB8fCAoc3RhcnRBbmdsZSA8PSBNYXRoLlBJICogMi41ICYmIE1hdGguUEkgKiAyLjUgPD0gZW5kQW5nbGUpO1xuXHRcdFx0dmFyIGNvbnRhaW5zMTgwID0gKHN0YXJ0QW5nbGUgPD0gLU1hdGguUEkgJiYgLU1hdGguUEkgPD0gZW5kQW5nbGUpIHx8IChzdGFydEFuZ2xlIDw9IE1hdGguUEkgJiYgTWF0aC5QSSA8PSBlbmRBbmdsZSk7XG5cdFx0XHR2YXIgY29udGFpbnMyNzAgPSAoc3RhcnRBbmdsZSA8PSAtTWF0aC5QSSAqIDAuNSAmJiAtTWF0aC5QSSAqIDAuNSA8PSBlbmRBbmdsZSkgfHwgKHN0YXJ0QW5nbGUgPD0gTWF0aC5QSSAqIDEuNSAmJiBNYXRoLlBJICogMS41IDw9IGVuZEFuZ2xlKTtcblx0XHRcdHZhciBjdXRvdXQgPSBjdXRvdXRQZXJjZW50YWdlIC8gMTAwLjA7XG5cdFx0XHR2YXIgbWluID0ge3g6IGNvbnRhaW5zMTgwID8gLTEgOiBNYXRoLm1pbihzdGFydC54ICogKHN0YXJ0LnggPCAwID8gMSA6IGN1dG91dCksIGVuZC54ICogKGVuZC54IDwgMCA/IDEgOiBjdXRvdXQpKSwgeTogY29udGFpbnMyNzAgPyAtMSA6IE1hdGgubWluKHN0YXJ0LnkgKiAoc3RhcnQueSA8IDAgPyAxIDogY3V0b3V0KSwgZW5kLnkgKiAoZW5kLnkgPCAwID8gMSA6IGN1dG91dCkpfTtcblx0XHRcdHZhciBtYXggPSB7eDogY29udGFpbnMwID8gMSA6IE1hdGgubWF4KHN0YXJ0LnggKiAoc3RhcnQueCA+IDAgPyAxIDogY3V0b3V0KSwgZW5kLnggKiAoZW5kLnggPiAwID8gMSA6IGN1dG91dCkpLCB5OiBjb250YWluczkwID8gMSA6IE1hdGgubWF4KHN0YXJ0LnkgKiAoc3RhcnQueSA+IDAgPyAxIDogY3V0b3V0KSwgZW5kLnkgKiAoZW5kLnkgPiAwID8gMSA6IGN1dG91dCkpfTtcblx0XHRcdHZhciBzaXplID0ge3dpZHRoOiAobWF4LnggLSBtaW4ueCkgKiAwLjUsIGhlaWdodDogKG1heC55IC0gbWluLnkpICogMC41fTtcblx0XHRcdG1pblNpemUgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCAvIHNpemUud2lkdGgsIGF2YWlsYWJsZUhlaWdodCAvIHNpemUuaGVpZ2h0KTtcblx0XHRcdG9mZnNldCA9IHt4OiAobWF4LnggKyBtaW4ueCkgKiAtMC41LCB5OiAobWF4LnkgKyBtaW4ueSkgKiAtMC41fTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGFyY3NbaV0sIGkpO1xuXHRcdH1cblxuXHRcdGNoYXJ0LmJvcmRlcldpZHRoID0gbWUuZ2V0TWF4Qm9yZGVyV2lkdGgoKTtcblx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KChtaW5TaXplIC0gY2hhcnQuYm9yZGVyV2lkdGgpIC8gMiwgMCk7XG5cdFx0Y2hhcnQuaW5uZXJSYWRpdXMgPSBNYXRoLm1heChjdXRvdXRQZXJjZW50YWdlID8gKGNoYXJ0Lm91dGVyUmFkaXVzIC8gMTAwKSAqIChjdXRvdXRQZXJjZW50YWdlKSA6IDAsIDApO1xuXHRcdGNoYXJ0LnJhZGl1c0xlbmd0aCA9IChjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LmlubmVyUmFkaXVzKSAvIChtZS5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHx8IDEpO1xuXHRcdGNoYXJ0Lm9mZnNldFggPSBvZmZzZXQueCAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xuXHRcdGNoYXJ0Lm9mZnNldFkgPSBvZmZzZXQueSAqIGNoYXJ0Lm91dGVyUmFkaXVzO1xuXG5cdFx0bWV0YS50b3RhbCA9IG1lLmNhbGN1bGF0ZVRvdGFsKCk7XG5cblx0XHRtZS5vdXRlclJhZGl1cyA9IGNoYXJ0Lm91dGVyUmFkaXVzIC0gY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuX2dldFJpbmdXZWlnaHRPZmZzZXQobWUuaW5kZXgpO1xuXHRcdG1lLmlubmVyUmFkaXVzID0gTWF0aC5tYXgobWUub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1lLnVwZGF0ZUVsZW1lbnQoYXJjc1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihhcmMsIGluZGV4LCByZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcblx0XHR2YXIgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuXHRcdHZhciBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSBvcHRzLnJvdGF0aW9uOyAvLyBub24gcmVzZXQgY2FzZSBoYW5kbGVkIGxhdGVyXG5cdFx0dmFyIGVuZEFuZ2xlID0gb3B0cy5yb3RhdGlvbjsgLy8gbm9uIHJlc2V0IGNhc2UgaGFuZGxlZCBsYXRlclxuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBjaXJjdW1mZXJlbmNlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gMCA6IGFyYy5oaWRkZW4gPyAwIDogbWUuY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZShkYXRhc2V0LmRhdGFbaW5kZXhdKSAqIChvcHRzLmNpcmN1bWZlcmVuY2UgLyAoMi4wICogTWF0aC5QSSkpO1xuXHRcdHZhciBpbm5lclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLmlubmVyUmFkaXVzO1xuXHRcdHZhciBvdXRlclJhZGl1cyA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlID8gMCA6IG1lLm91dGVyUmFkaXVzO1xuXHRcdHZhciBvcHRpb25zID0gYXJjLl9vcHRpb25zIHx8IHt9O1xuXG5cdFx0aGVscGVycyQxLmV4dGVuZChhcmMsIHtcblx0XHRcdC8vIFV0aWxpdHlcblx0XHRcdF9kYXRhc2V0SW5kZXg6IG1lLmluZGV4LFxuXHRcdFx0X2luZGV4OiBpbmRleCxcblxuXHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdGJvcmRlckFsaWduOiBvcHRpb25zLmJvcmRlckFsaWduLFxuXHRcdFx0XHR4OiBjZW50ZXJYICsgY2hhcnQub2Zmc2V0WCxcblx0XHRcdFx0eTogY2VudGVyWSArIGNoYXJ0Lm9mZnNldFksXG5cdFx0XHRcdHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG5cdFx0XHRcdGVuZEFuZ2xlOiBlbmRBbmdsZSxcblx0XHRcdFx0Y2lyY3VtZmVyZW5jZTogY2lyY3VtZmVyZW5jZSxcblx0XHRcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuXHRcdFx0XHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXG5cdFx0XHRcdGxhYmVsOiBoZWxwZXJzJDEudmFsdWVBdEluZGV4T3JEZWZhdWx0KGRhdGFzZXQubGFiZWwsIGluZGV4LCBjaGFydC5kYXRhLmxhYmVsc1tpbmRleF0pXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgbW9kZWwgPSBhcmMuX21vZGVsO1xuXG5cdFx0Ly8gU2V0IGNvcnJlY3QgYW5nbGVzIGlmIG5vdCByZXNldHRpbmdcblx0XHRpZiAoIXJlc2V0IHx8ICFhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcblx0XHRcdGlmIChpbmRleCA9PT0gMCkge1xuXHRcdFx0XHRtb2RlbC5zdGFydEFuZ2xlID0gb3B0cy5yb3RhdGlvbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1vZGVsLnN0YXJ0QW5nbGUgPSBtZS5nZXRNZXRhKCkuZGF0YVtpbmRleCAtIDFdLl9tb2RlbC5lbmRBbmdsZTtcblx0XHRcdH1cblxuXHRcdFx0bW9kZWwuZW5kQW5nbGUgPSBtb2RlbC5zdGFydEFuZ2xlICsgbW9kZWwuY2lyY3VtZmVyZW5jZTtcblx0XHR9XG5cblx0XHRhcmMucGl2b3QoKTtcblx0fSxcblxuXHRjYWxjdWxhdGVUb3RhbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuXHRcdHZhciB0b3RhbCA9IDA7XG5cdFx0dmFyIHZhbHVlO1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWV0YS5kYXRhLCBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuXHRcdFx0dmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdFx0aWYgKCFpc05hTih2YWx1ZSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XG5cdFx0XHRcdHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8qIGlmICh0b3RhbCA9PT0gMCkge1xuXHRcdFx0dG90YWwgPSBOYU47XG5cdFx0fSovXG5cblx0XHRyZXR1cm4gdG90YWw7XG5cdH0sXG5cblx0Y2FsY3VsYXRlQ2lyY3VtZmVyZW5jZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgdG90YWwgPSB0aGlzLmdldE1ldGEoKS50b3RhbDtcblx0XHRpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcblx0XHRcdHJldHVybiAoTWF0aC5QSSAqIDIuMCkgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBnZXRzIHRoZSBtYXggYm9yZGVyIG9yIGhvdmVyIHdpZHRoIHRvIHByb3Blcmx5IHNjYWxlIHBpZSBjaGFydHNcblx0Z2V0TWF4Qm9yZGVyV2lkdGg6IGZ1bmN0aW9uKGFyY3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtYXggPSAwO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBpLCBpbGVuLCBtZXRhLCBhcmMsIGNvbnRyb2xsZXIsIG9wdGlvbnMsIGJvcmRlcldpZHRoLCBob3ZlcldpZHRoO1xuXG5cdFx0aWYgKCFhcmNzKSB7XG5cdFx0XHQvLyBGaW5kIHRoZSBvdXRtb3N0IHZpc2libGUgZGF0YXNldFxuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRcdGFyY3MgPSBtZXRhLmRhdGE7XG5cdFx0XHRcdFx0aWYgKGkgIT09IG1lLmluZGV4KSB7XG5cdFx0XHRcdFx0XHRjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghYXJjcykge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRhcmMgPSBhcmNzW2ldO1xuXHRcdFx0b3B0aW9ucyA9IGNvbnRyb2xsZXIgPyBjb250cm9sbGVyLl9yZXNvbHZlRWxlbWVudE9wdGlvbnMoYXJjLCBpKSA6IGFyYy5fb3B0aW9ucztcblx0XHRcdGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG5cdFx0XHRcdGJvcmRlcldpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcblx0XHRcdFx0aG92ZXJXaWR0aCA9IG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aDtcblxuXHRcdFx0XHRtYXggPSBib3JkZXJXaWR0aCA+IG1heCA/IGJvcmRlcldpZHRoIDogbWF4O1xuXHRcdFx0XHRtYXggPSBob3ZlcldpZHRoID4gbWF4ID8gaG92ZXJXaWR0aCA6IG1heDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1heDtcblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24oYXJjKSB7XG5cdFx0dmFyIG1vZGVsID0gYXJjLl9tb2RlbDtcblx0XHR2YXIgb3B0aW9ucyA9IGFyYy5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0YXJjLiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDQob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNChvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVFbGVtZW50T3B0aW9uczogZnVuY3Rpb24oYXJjLCBpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGN1c3RvbSA9IGFyYy5jdXN0b20gfHwge307XG5cdFx0dmFyIG9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlcldpZHRoJyxcblx0XHRcdCdib3JkZXJBbGlnbicsXG5cdFx0XHQnaG92ZXJCYWNrZ3JvdW5kQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyQ29sb3InLFxuXHRcdFx0J2hvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkMyhbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCByYWRpdXMgbGVuZ3RoIG9mZnNldCBvZiB0aGUgZGF0YXNldCBpbiByZWxhdGlvbiB0byB0aGUgdmlzaWJsZSBkYXRhc2V0cyB3ZWlnaHRzLiBUaGlzIGFsbG93cyBkZXRlcm1pbmluZyB0aGUgaW5uZXIgYW5kIG91dGVyIHJhZGl1cyBjb3JyZWN0bHlcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRSaW5nV2VpZ2h0T2Zmc2V0OiBmdW5jdGlvbihkYXRhc2V0SW5kZXgpIHtcblx0XHR2YXIgcmluZ1dlaWdodE9mZnNldCA9IDA7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG5cdFx0XHRpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRSaW5nV2VpZ2h0OiBmdW5jdGlvbihkYXRhU2V0SW5kZXgpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQkNCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YVNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc3VtIG9mIGFsbCB2aXNpYmlsZSBkYXRhIHNldCB3ZWlnaHRzLiAgVGhpcyB2YWx1ZSBjYW4gYmUgMC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnaG9yaXpvbnRhbEJhcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnaW5kZXgnLFxuXHRcdGF4aXM6ICd5J1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2xpbmVhcicsXG5cdFx0XHRwb3NpdGlvbjogJ2JvdHRvbSdcblx0XHR9XSxcblxuXHRcdHlBeGVzOiBbe1xuXHRcdFx0dHlwZTogJ2NhdGVnb3J5Jyxcblx0XHRcdHBvc2l0aW9uOiAnbGVmdCcsXG5cdFx0XHRjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcblx0XHRcdGJhclBlcmNlbnRhZ2U6IDAuOSxcblx0XHRcdG9mZnNldDogdHJ1ZSxcblx0XHRcdGdyaWRMaW5lczoge1xuXHRcdFx0XHRvZmZzZXRHcmlkTGluZXM6IHRydWVcblx0XHRcdH1cblx0XHR9XVxuXHR9LFxuXG5cdGVsZW1lbnRzOiB7XG5cdFx0cmVjdGFuZ2xlOiB7XG5cdFx0XHRib3JkZXJTa2lwcGVkOiAnbGVmdCdcblx0XHR9XG5cdH0sXG5cblx0dG9vbHRpcHM6IHtcblx0XHRtb2RlOiAnaW5kZXgnLFxuXHRcdGF4aXM6ICd5J1xuXHR9XG59KTtcblxudmFyIGNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhciA9IGNvbnRyb2xsZXJfYmFyLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldFZhbHVlU2NhbGVJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0YSgpLnhBeGlzSUQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0SW5kZXhTY2FsZUlkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRhKCkueUF4aXNJRDtcblx0fVxufSk7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ1ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHJlc29sdmUkNCA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG52YXIgaXNQb2ludEluQXJlYSA9IGhlbHBlcnMkMS5jYW52YXMuX2lzUG9pbnRJbkFyZWE7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnbGluZScsIHtcblx0c2hvd0xpbmVzOiB0cnVlLFxuXHRzcGFuR2FwczogZmFsc2UsXG5cblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnbGFiZWwnXG5cdH0sXG5cblx0c2NhbGVzOiB7XG5cdFx0eEF4ZXM6IFt7XG5cdFx0XHR0eXBlOiAnY2F0ZWdvcnknLFxuXHRcdFx0aWQ6ICd4LWF4aXMtMCdcblx0XHR9XSxcblx0XHR5QXhlczogW3tcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0aWQ6ICd5LWF4aXMtMCdcblx0XHR9XVxuXHR9XG59KTtcblxuZnVuY3Rpb24gbGluZUVuYWJsZWQoZGF0YXNldCwgb3B0aW9ucykge1xuXHRyZXR1cm4gdmFsdWVPckRlZmF1bHQkNShkYXRhc2V0LnNob3dMaW5lLCBvcHRpb25zLnNob3dMaW5lcyk7XG59XG5cbnZhciBjb250cm9sbGVyX2xpbmUgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YXNldEVsZW1lbnRUeXBlOiBlbGVtZW50cy5MaW5lLFxuXG5cdGRhdGFFbGVtZW50VHlwZTogZWxlbWVudHMuUG9pbnQsXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgc2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIHNob3dMaW5lID0gbGluZUVuYWJsZWQoZGF0YXNldCwgbWUuY2hhcnQub3B0aW9ucyk7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHQvLyBVcGRhdGUgTGluZVxuXHRcdGlmIChzaG93TGluZSkge1xuXHRcdFx0Ly8gQ29tcGF0aWJpbGl0eTogSWYgdGhlIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgd2l0aCBvbmx5IHRoZSBvbGQgbmFtZSwgdXNlIHRob3NlIHZhbHVlc1xuXHRcdFx0aWYgKChkYXRhc2V0LnRlbnNpb24gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdFx0ZGF0YXNldC5saW5lVGVuc2lvbiA9IGRhdGFzZXQudGVuc2lvbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0bGluZS5fc2NhbGUgPSBzY2FsZTtcblx0XHRcdGxpbmUuX2RhdGFzZXRJbmRleCA9IG1lLmluZGV4O1xuXHRcdFx0Ly8gRGF0YVxuXHRcdFx0bGluZS5fY2hpbGRyZW4gPSBwb2ludHM7XG5cdFx0XHQvLyBNb2RlbFxuXHRcdFx0bGluZS5fbW9kZWwgPSBtZS5fcmVzb2x2ZUxpbmVPcHRpb25zKGxpbmUpO1xuXG5cdFx0XHRsaW5lLnBpdm90KCk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblxuXHRcdGlmIChzaG93TGluZSAmJiBsaW5lLl9tb2RlbC50ZW5zaW9uICE9PSAwKSB7XG5cdFx0XHRtZS51cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKCk7XG5cdFx0fVxuXG5cdFx0Ly8gTm93IHBpdm90IHRoZSBwb2ludCBmb3IgYW5pbWF0aW9uXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBvaW50c1tpXS5waXZvdCgpO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVFbGVtZW50OiBmdW5jdGlvbihwb2ludCwgaW5kZXgsIHJlc2V0KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgY3VzdG9tID0gcG9pbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBkYXRhc2V0SW5kZXggPSBtZS5pbmRleDtcblx0XHR2YXIgdmFsdWUgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuXHRcdHZhciB5U2NhbGUgPSBtZS5nZXRTY2FsZUZvcklkKG1ldGEueUF4aXNJRCk7XG5cdFx0dmFyIHhTY2FsZSA9IG1lLmdldFNjYWxlRm9ySWQobWV0YS54QXhpc0lEKTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWV0YS5kYXRhc2V0Ll9tb2RlbDtcblx0XHR2YXIgeCwgeTtcblxuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVQb2ludE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblxuXHRcdHggPSB4U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgOiBOYU4sIGluZGV4LCBkYXRhc2V0SW5kZXgpO1xuXHRcdHkgPSByZXNldCA/IHlTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IG1lLmNhbGN1bGF0ZVBvaW50WSh2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCk7XG5cblx0XHQvLyBVdGlsaXR5XG5cdFx0cG9pbnQuX3hTY2FsZSA9IHhTY2FsZTtcblx0XHRwb2ludC5feVNjYWxlID0geVNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gZGF0YXNldEluZGV4O1xuXHRcdHBvaW50Ll9pbmRleCA9IGluZGV4O1xuXG5cdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRwb2ludC5fbW9kZWwgPSB7XG5cdFx0XHR4OiB4LFxuXHRcdFx0eTogeSxcblx0XHRcdHNraXA6IGN1c3RvbS5za2lwIHx8IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuXHRcdFx0Ly8gQXBwZWFyYW5jZVxuXHRcdFx0cmFkaXVzOiBvcHRpb25zLnJhZGl1cyxcblx0XHRcdHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcblx0XHRcdHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuXHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHR0ZW5zaW9uOiB2YWx1ZU9yRGVmYXVsdCQ1KGN1c3RvbS50ZW5zaW9uLCBsaW5lTW9kZWwgPyBsaW5lTW9kZWwudGVuc2lvbiA6IDApLFxuXHRcdFx0c3RlcHBlZExpbmU6IGxpbmVNb2RlbCA/IGxpbmVNb2RlbC5zdGVwcGVkTGluZSA6IGZhbHNlLFxuXHRcdFx0Ly8gVG9vbHRpcFxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1c1xuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZVBvaW50T3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBFTEVNRU5UX09QVElPTlMgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxuXHRcdFx0Ym9yZGVyV2lkdGg6ICdwb2ludEJvcmRlcldpZHRoJyxcblx0XHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcblx0XHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRob3ZlckJvcmRlckNvbG9yOiAncG9pbnRIb3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcblx0XHRcdHBvaW50U3R5bGU6ICdwb2ludFN0eWxlJyxcblx0XHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcblx0XHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcblx0XHR9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoRUxFTUVOVF9PUFRJT05TKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ0KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRbRUxFTUVOVF9PUFRJT05TW2tleV1dLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUxpbmVPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnM7XG5cdFx0dmFyIGVsZW1lbnRPcHRpb25zID0gb3B0aW9ucy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJXaWR0aCcsXG5cdFx0XHQnYm9yZGVyQ29sb3InLFxuXHRcdFx0J2JvcmRlckNhcFN0eWxlJyxcblx0XHRcdCdib3JkZXJEYXNoJyxcblx0XHRcdCdib3JkZXJEYXNoT2Zmc2V0Jyxcblx0XHRcdCdib3JkZXJKb2luU3R5bGUnLFxuXHRcdFx0J2ZpbGwnLFxuXHRcdFx0J2N1YmljSW50ZXJwb2xhdGlvbk1vZGUnXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ0KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0ZWxlbWVudE9wdGlvbnNba2V5XVxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgbGluZXMgaXMgdG8gYnJlYWsgYXQgbnVsbCB2YWx1ZXMsIGFjY29yZGluZ1xuXHRcdC8vIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNDM1I2lzc3VlY29tbWVudC0yMTY3MTgxNThcblx0XHQvLyBUaGlzIG9wdGlvbiBnaXZlcyBsaW5lcyB0aGUgYWJpbGl0eSB0byBzcGFuIGdhcHNcblx0XHR2YWx1ZXMuc3BhbkdhcHMgPSB2YWx1ZU9yRGVmYXVsdCQ1KGRhdGFzZXQuc3BhbkdhcHMsIG9wdGlvbnMuc3BhbkdhcHMpO1xuXHRcdHZhbHVlcy50ZW5zaW9uID0gdmFsdWVPckRlZmF1bHQkNShkYXRhc2V0LmxpbmVUZW5zaW9uLCBlbGVtZW50T3B0aW9ucy50ZW5zaW9uKTtcblx0XHR2YWx1ZXMuc3RlcHBlZExpbmUgPSByZXNvbHZlJDQoW2N1c3RvbS5zdGVwcGVkTGluZSwgZGF0YXNldC5zdGVwcGVkTGluZSwgZWxlbWVudE9wdGlvbnMuc3RlcHBlZF0pO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHRjYWxjdWxhdGVQb2ludFk6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgeVNjYWxlID0gbWUuZ2V0U2NhbGVGb3JJZChtZXRhLnlBeGlzSUQpO1xuXHRcdHZhciBzdW1Qb3MgPSAwO1xuXHRcdHZhciBzdW1OZWcgPSAwO1xuXHRcdHZhciBpLCBkcywgZHNNZXRhO1xuXG5cdFx0aWYgKHlTY2FsZS5vcHRpb25zLnN0YWNrZWQpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7IGkrKykge1xuXHRcdFx0XHRkcyA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbaV07XG5cdFx0XHRcdGRzTWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRpZiAoZHNNZXRhLnR5cGUgPT09ICdsaW5lJyAmJiBkc01ldGEueUF4aXNJRCA9PT0geVNjYWxlLmlkICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0XHR2YXIgc3RhY2tlZFJpZ2h0VmFsdWUgPSBOdW1iZXIoeVNjYWxlLmdldFJpZ2h0VmFsdWUoZHMuZGF0YVtpbmRleF0pKTtcblx0XHRcdFx0XHRpZiAoc3RhY2tlZFJpZ2h0VmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRzdW1OZWcgKz0gc3RhY2tlZFJpZ2h0VmFsdWUgfHwgMDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3VtUG9zICs9IHN0YWNrZWRSaWdodFZhbHVlIHx8IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciByaWdodFZhbHVlID0gTnVtYmVyKHlTY2FsZS5nZXRSaWdodFZhbHVlKHZhbHVlKSk7XG5cdFx0XHRpZiAocmlnaHRWYWx1ZSA8IDApIHtcblx0XHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bU5lZyArIHJpZ2h0VmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN1bVBvcyArIHJpZ2h0VmFsdWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiB5U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG5cdH0sXG5cblx0dXBkYXRlQmV6aWVyQ29udHJvbFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWV0YS5kYXRhc2V0Ll9tb2RlbDtcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuXHRcdHZhciBpLCBpbGVuLCBtb2RlbCwgY29udHJvbFBvaW50cztcblxuXHRcdC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG5cdFx0aWYgKGxpbmVNb2RlbC5zcGFuR2Fwcykge1xuXHRcdFx0cG9pbnRzID0gcG9pbnRzLmZpbHRlcihmdW5jdGlvbihwdCkge1xuXHRcdFx0XHRyZXR1cm4gIXB0Ll9tb2RlbC5za2lwO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0LCBtaW4sIG1heCkge1xuXHRcdFx0cmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xuXHRcdH1cblxuXHRcdGlmIChsaW5lTW9kZWwuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuXHRcdFx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdFx0bW9kZWwgPSBwb2ludHNbaV0uX21vZGVsO1xuXHRcdFx0XHRjb250cm9sUG9pbnRzID0gaGVscGVycyQxLnNwbGluZUN1cnZlKFxuXHRcdFx0XHRcdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpKS5fbW9kZWwsXG5cdFx0XHRcdFx0bW9kZWwsXG5cdFx0XHRcdFx0aGVscGVycyQxLm5leHRJdGVtKHBvaW50cywgaSkuX21vZGVsLFxuXHRcdFx0XHRcdGxpbmVNb2RlbC50ZW5zaW9uXG5cdFx0XHRcdCk7XG5cdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcblx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuXHRcdFx0XHRtb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjaGFydC5vcHRpb25zLmVsZW1lbnRzLmxpbmUuY2FwQmV6aWVyUG9pbnRzKSB7XG5cdFx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0XHRtb2RlbCA9IHBvaW50c1tpXS5fbW9kZWw7XG5cdFx0XHRcdGlmIChpc1BvaW50SW5BcmVhKG1vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBpc1BvaW50SW5BcmVhKHBvaW50c1tpIC0gMV0uX21vZGVsLCBhcmVhKSkge1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWCwgYXJlYS5sZWZ0LCBhcmVhLnJpZ2h0KTtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IGNhcENvbnRyb2xQb2ludChtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChpIDwgcG9pbnRzLmxlbmd0aCAtIDEgJiYgaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLl9tb2RlbCwgYXJlYSkpIHtcblx0XHRcdFx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KG1vZGVsLmNvbnRyb2xQb2ludE5leHRYLCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0XHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQobW9kZWwuY29udHJvbFBvaW50TmV4dFksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcblx0XHR2YXIgaWxlbiA9IHBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGhhbGZCb3JkZXJXaWR0aDtcblx0XHR2YXIgaSA9IDA7XG5cblx0XHRpZiAobGluZUVuYWJsZWQobWUuZ2V0RGF0YXNldCgpLCBjaGFydC5vcHRpb25zKSkge1xuXHRcdFx0aGFsZkJvcmRlcldpZHRoID0gKG1ldGEuZGF0YXNldC5fbW9kZWwuYm9yZGVyV2lkdGggfHwgMCkgLyAyO1xuXG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsaXBBcmVhKGNoYXJ0LmN0eCwge1xuXHRcdFx0XHRsZWZ0OiBhcmVhLmxlZnQsXG5cdFx0XHRcdHJpZ2h0OiBhcmVhLnJpZ2h0LFxuXHRcdFx0XHR0b3A6IGFyZWEudG9wIC0gaGFsZkJvcmRlcldpZHRoLFxuXHRcdFx0XHRib3R0b206IGFyZWEuYm90dG9tICsgaGFsZkJvcmRlcldpZHRoXG5cdFx0XHR9KTtcblxuXHRcdFx0bWV0YS5kYXRhc2V0LmRyYXcoKTtcblxuXHRcdFx0aGVscGVycyQxLmNhbnZhcy51bmNsaXBBcmVhKGNoYXJ0LmN0eCk7XG5cdFx0fVxuXG5cdFx0Ly8gRHJhdyB0aGUgcG9pbnRzXG5cdFx0Zm9yICg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdHBvaW50c1tpXS5kcmF3KGFyZWEpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0c2V0SG92ZXJTdHlsZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgbW9kZWwgPSBwb2ludC5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBwb2ludC5fb3B0aW9ucztcblx0XHR2YXIgZ2V0SG92ZXJDb2xvciA9IGhlbHBlcnMkMS5nZXRIb3ZlckNvbG9yO1xuXG5cdFx0cG9pbnQuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHRcdHJhZGl1czogbW9kZWwucmFkaXVzXG5cdFx0fTtcblxuXHRcdG1vZGVsLmJhY2tncm91bmRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQm9yZGVyQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5ib3JkZXJDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlcldpZHRoID0gdmFsdWVPckRlZmF1bHQkNShvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuXHRcdG1vZGVsLnJhZGl1cyA9IHZhbHVlT3JEZWZhdWx0JDUob3B0aW9ucy5ob3ZlclJhZGl1cywgb3B0aW9ucy5yYWRpdXMpO1xuXHR9LFxufSk7XG5cbnZhciByZXNvbHZlJDUgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ3BvbGFyQXJlYScsIHtcblx0c2NhbGU6IHtcblx0XHR0eXBlOiAncmFkaWFsTGluZWFyJyxcblx0XHRhbmdsZUxpbmVzOiB7XG5cdFx0XHRkaXNwbGF5OiBmYWxzZVxuXHRcdH0sXG5cdFx0Z3JpZExpbmVzOiB7XG5cdFx0XHRjaXJjdWxhcjogdHJ1ZVxuXHRcdH0sXG5cdFx0cG9pbnRMYWJlbHM6IHtcblx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0fSxcblx0XHR0aWNrczoge1xuXHRcdFx0YmVnaW5BdFplcm86IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQm9vbGVhbiAtIFdoZXRoZXIgdG8gYW5pbWF0ZSB0aGUgcm90YXRpb24gb2YgdGhlIGNoYXJ0XG5cdGFuaW1hdGlvbjoge1xuXHRcdGFuaW1hdGVSb3RhdGU6IHRydWUsXG5cdFx0YW5pbWF0ZVNjYWxlOiB0cnVlXG5cdH0sXG5cblx0c3RhcnRBbmdsZTogLTAuNSAqIE1hdGguUEksXG5cdGxlZ2VuZENhbGxiYWNrOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0ZXh0ID0gW107XG5cdFx0dGV4dC5wdXNoKCc8dWwgY2xhc3M9XCInICsgY2hhcnQuaWQgKyAnLWxlZ2VuZFwiPicpO1xuXG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGxhYmVscyA9IGRhdGEubGFiZWxzO1xuXG5cdFx0aWYgKGRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhc2V0c1swXS5kYXRhLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgZGF0YXNldHNbMF0uYmFja2dyb3VuZENvbG9yW2ldICsgJ1wiPjwvc3Bhbj4nKTtcblx0XHRcdFx0aWYgKGxhYmVsc1tpXSkge1xuXHRcdFx0XHRcdHRleHQucHVzaChsYWJlbHNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRleHQucHVzaCgnPC9saT4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdH0sXG5cdGxlZ2VuZDoge1xuXHRcdGxhYmVsczoge1xuXHRcdFx0Z2VuZXJhdGVMYWJlbHM6IGZ1bmN0aW9uKGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gY2hhcnQuZGF0YTtcblx0XHRcdFx0aWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLmxhYmVscy5tYXAoZnVuY3Rpb24obGFiZWwsIGkpIHtcblx0XHRcdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG5cdFx0XHRcdFx0XHR2YXIgZHMgPSBkYXRhLmRhdGFzZXRzWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGFyYyA9IG1ldGEuZGF0YVtpXTtcblx0XHRcdFx0XHRcdHZhciBjdXN0b20gPSBhcmMuY3VzdG9tIHx8IHt9O1xuXHRcdFx0XHRcdFx0dmFyIGFyY09wdHMgPSBjaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYztcblx0XHRcdFx0XHRcdHZhciBmaWxsID0gcmVzb2x2ZSQ1KFtjdXN0b20uYmFja2dyb3VuZENvbG9yLCBkcy5iYWNrZ3JvdW5kQ29sb3IsIGFyY09wdHMuYmFja2dyb3VuZENvbG9yXSwgdW5kZWZpbmVkLCBpKTtcblx0XHRcdFx0XHRcdHZhciBzdHJva2UgPSByZXNvbHZlJDUoW2N1c3RvbS5ib3JkZXJDb2xvciwgZHMuYm9yZGVyQ29sb3IsIGFyY09wdHMuYm9yZGVyQ29sb3JdLCB1bmRlZmluZWQsIGkpO1xuXHRcdFx0XHRcdFx0dmFyIGJ3ID0gcmVzb2x2ZSQ1KFtjdXN0b20uYm9yZGVyV2lkdGgsIGRzLmJvcmRlcldpZHRoLCBhcmNPcHRzLmJvcmRlcldpZHRoXSwgdW5kZWZpbmVkLCBpKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dGV4dDogbGFiZWwsXG5cdFx0XHRcdFx0XHRcdGZpbGxTdHlsZTogZmlsbCxcblx0XHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IHN0cm9rZSxcblx0XHRcdFx0XHRcdFx0bGluZVdpZHRoOiBidyxcblx0XHRcdFx0XHRcdFx0aGlkZGVuOiBpc05hTihkcy5kYXRhW2ldKSB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuLFxuXG5cdFx0XHRcdFx0XHRcdC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuXHRcdFx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGUsIGxlZ2VuZEl0ZW0pIHtcblx0XHRcdHZhciBpbmRleCA9IGxlZ2VuZEl0ZW0uaW5kZXg7XG5cdFx0XHR2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIGksIGlsZW4sIG1ldGE7XG5cblx0XHRcdGZvciAoaSA9IDAsIGlsZW4gPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcblx0XHRcdFx0bWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gPSAhbWV0YS5kYXRhW2luZGV4XS5oaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJ0LnVwZGF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcblx0dG9vbHRpcHM6IHtcblx0XHRjYWxsYmFja3M6IHtcblx0XHRcdHRpdGxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbihpdGVtLCBkYXRhKSB7XG5cdFx0XHRcdHJldHVybiBkYXRhLmxhYmVsc1tpdGVtLmluZGV4XSArICc6ICcgKyBpdGVtLnlMYWJlbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgY29udHJvbGxlcl9wb2xhckFyZWEgPSBjb3JlX2RhdGFzZXRDb250cm9sbGVyLmV4dGVuZCh7XG5cblx0ZGF0YUVsZW1lbnRUeXBlOiBlbGVtZW50cy5BcmMsXG5cblx0bGlua1NjYWxlczogaGVscGVycyQxLm5vb3AsXG5cblx0dXBkYXRlOiBmdW5jdGlvbihyZXNldCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIHN0YXJ0ID0gbWUuY2hhcnQub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG5cdFx0dmFyIHN0YXJ0cyA9IG1lLl9zdGFydHMgPSBbXTtcblx0XHR2YXIgYW5nbGVzID0gbWUuX2FuZ2xlcyA9IFtdO1xuXHRcdHZhciBhcmNzID0gbWV0YS5kYXRhO1xuXHRcdHZhciBpLCBpbGVuLCBhbmdsZTtcblxuXHRcdG1lLl91cGRhdGVSYWRpdXMoKTtcblxuXHRcdG1ldGEuY291bnQgPSBtZS5jb3VudFZpc2libGVFbGVtZW50cygpO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXQuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcblx0XHRcdHN0YXJ0c1tpXSA9IHN0YXJ0O1xuXHRcdFx0YW5nbGUgPSBtZS5fY29tcHV0ZUFuZ2xlKGkpO1xuXHRcdFx0YW5nbGVzW2ldID0gYW5nbGU7XG5cdFx0XHRzdGFydCArPSBhbmdsZTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGFyY3NbaV0uX29wdGlvbnMgPSBtZS5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGFyY3NbaV0sIGkpO1xuXHRcdFx0bWUudXBkYXRlRWxlbWVudChhcmNzW2ldLCBpLCByZXNldCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3VwZGF0ZVJhZGl1czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG5cblx0XHRjaGFydC5vdXRlclJhZGl1cyA9IE1hdGgubWF4KG1pblNpemUgLyAyLCAwKTtcblx0XHRjaGFydC5pbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IChjaGFydC5vdXRlclJhZGl1cyAvIDEwMCkgKiAob3B0cy5jdXRvdXRQZXJjZW50YWdlKSA6IDEsIDApO1xuXHRcdGNoYXJ0LnJhZGl1c0xlbmd0aCA9IChjaGFydC5vdXRlclJhZGl1cyAtIGNoYXJ0LmlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcblxuXHRcdG1lLm91dGVyUmFkaXVzID0gY2hhcnQub3V0ZXJSYWRpdXMgLSAoY2hhcnQucmFkaXVzTGVuZ3RoICogbWUuaW5kZXgpO1xuXHRcdG1lLmlubmVyUmFkaXVzID0gbWUub3V0ZXJSYWRpdXMgLSBjaGFydC5yYWRpdXNMZW5ndGg7XG5cdH0sXG5cblx0dXBkYXRlRWxlbWVudDogZnVuY3Rpb24oYXJjLCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gbWUuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBvcHRzID0gY2hhcnQub3B0aW9ucztcblx0XHR2YXIgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuXHRcdHZhciBzY2FsZSA9IGNoYXJ0LnNjYWxlO1xuXHRcdHZhciBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscztcblxuXHRcdHZhciBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcblx0XHR2YXIgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG5cblx0XHQvLyB2YXIgbmVnSGFsZlBJID0gLTAuNSAqIE1hdGguUEk7XG5cdFx0dmFyIGRhdGFzZXRTdGFydEFuZ2xlID0gb3B0cy5zdGFydEFuZ2xlO1xuXHRcdHZhciBkaXN0YW5jZSA9IGFyYy5oaWRkZW4gPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSBtZS5fc3RhcnRzW2luZGV4XTtcblx0XHR2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGFyYy5oaWRkZW4gPyAwIDogbWUuX2FuZ2xlc1tpbmRleF0pO1xuXG5cdFx0dmFyIHJlc2V0UmFkaXVzID0gYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUgPyAwIDogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUoZGF0YXNldC5kYXRhW2luZGV4XSk7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnMgfHwge307XG5cblx0XHRoZWxwZXJzJDEuZXh0ZW5kKGFyYywge1xuXHRcdFx0Ly8gVXRpbGl0eVxuXHRcdFx0X2RhdGFzZXRJbmRleDogbWUuaW5kZXgsXG5cdFx0XHRfaW5kZXg6IGluZGV4LFxuXHRcdFx0X3NjYWxlOiBzY2FsZSxcblxuXHRcdFx0Ly8gRGVzaXJlZCB2aWV3IHByb3BlcnRpZXNcblx0XHRcdF9tb2RlbDoge1xuXHRcdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuXHRcdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdFx0Ym9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG5cdFx0XHRcdGJvcmRlckFsaWduOiBvcHRpb25zLmJvcmRlckFsaWduLFxuXHRcdFx0XHR4OiBjZW50ZXJYLFxuXHRcdFx0XHR5OiBjZW50ZXJZLFxuXHRcdFx0XHRpbm5lclJhZGl1czogMCxcblx0XHRcdFx0b3V0ZXJSYWRpdXM6IHJlc2V0ID8gcmVzZXRSYWRpdXMgOiBkaXN0YW5jZSxcblx0XHRcdFx0c3RhcnRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBzdGFydEFuZ2xlLFxuXHRcdFx0XHRlbmRBbmdsZTogcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlID8gZGF0YXNldFN0YXJ0QW5nbGUgOiBlbmRBbmdsZSxcblx0XHRcdFx0bGFiZWw6IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQobGFiZWxzLCBpbmRleCwgbGFiZWxzW2luZGV4XSlcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFyYy5waXZvdCgpO1xuXHR9LFxuXG5cdGNvdW50VmlzaWJsZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXHRcdHZhciBtZXRhID0gdGhpcy5nZXRNZXRhKCk7XG5cdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKG1ldGEuZGF0YSwgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHRcdGlmICghaXNOYU4oZGF0YXNldC5kYXRhW2luZGV4XSkgJiYgIWVsZW1lbnQuaGlkZGVuKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY291bnQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKGFyYykge1xuXHRcdHZhciBtb2RlbCA9IGFyYy5fbW9kZWw7XG5cdFx0dmFyIG9wdGlvbnMgPSBhcmMuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblx0XHR2YXIgdmFsdWVPckRlZmF1bHQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cblx0XHRhcmMuJHByZXZpb3VzU3R5bGUgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6IG1vZGVsLmJhY2tncm91bmRDb2xvcixcblx0XHRcdGJvcmRlckNvbG9yOiBtb2RlbC5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBtb2RlbC5ib3JkZXJXaWR0aCxcblx0XHR9O1xuXG5cdFx0bW9kZWwuYmFja2dyb3VuZENvbG9yID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJhY2tncm91bmRDb2xvciwgZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcikpO1xuXHRcdG1vZGVsLmJvcmRlckNvbG9yID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUVsZW1lbnRPcHRpb25zOiBmdW5jdGlvbihhcmMsIGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgY3VzdG9tID0gYXJjLmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMuYXJjO1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHR2YXIgaSwgaWxlbiwga2V5O1xuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdCdib3JkZXJDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2JvcmRlckFsaWduJyxcblx0XHRcdCdob3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJDb2xvcicsXG5cdFx0XHQnaG92ZXJCb3JkZXJXaWR0aCcsXG5cdFx0XTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ1KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRba2V5XSxcblx0XHRcdFx0b3B0aW9uc1trZXldXG5cdFx0XHRdLCBjb250ZXh0LCBpbmRleCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jb21wdXRlQW5nbGU6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY291bnQgPSB0aGlzLmdldE1ldGEoKS5jb3VudDtcblx0XHR2YXIgZGF0YXNldCA9IG1lLmdldERhdGFzZXQoKTtcblx0XHR2YXIgbWV0YSA9IG1lLmdldE1ldGEoKTtcblxuXHRcdGlmIChpc05hTihkYXRhc2V0LmRhdGFbaW5kZXhdKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbikge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU2NyaXB0YWJsZSBvcHRpb25zXG5cdFx0dmFyIGNvbnRleHQgPSB7XG5cdFx0XHRjaGFydDogbWUuY2hhcnQsXG5cdFx0XHRkYXRhSW5kZXg6IGluZGV4LFxuXHRcdFx0ZGF0YXNldDogZGF0YXNldCxcblx0XHRcdGRhdGFzZXRJbmRleDogbWUuaW5kZXhcblx0XHR9O1xuXG5cdFx0cmV0dXJuIHJlc29sdmUkNShbXG5cdFx0XHRtZS5jaGFydC5vcHRpb25zLmVsZW1lbnRzLmFyYy5hbmdsZSxcblx0XHRcdCgyICogTWF0aC5QSSkgLyBjb3VudFxuXHRcdF0sIGNvbnRleHQsIGluZGV4KTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncGllJywgaGVscGVycyQxLmNsb25lKGNvcmVfZGVmYXVsdHMuZG91Z2hudXQpKTtcbmNvcmVfZGVmYXVsdHMuX3NldCgncGllJywge1xuXHRjdXRvdXRQZXJjZW50YWdlOiAwXG59KTtcblxuLy8gUGllIGNoYXJ0cyBhcmUgRG91Z2hudXQgY2hhcnQgd2l0aCBkaWZmZXJlbnQgZGVmYXVsdHNcbnZhciBjb250cm9sbGVyX3BpZSA9IGNvbnRyb2xsZXJfZG91Z2hudXQ7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ2ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHJlc29sdmUkNiA9IGhlbHBlcnMkMS5vcHRpb25zLnJlc29sdmU7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgncmFkYXInLCB7XG5cdHNjYWxlOiB7XG5cdFx0dHlwZTogJ3JhZGlhbExpbmVhcidcblx0fSxcblx0ZWxlbWVudHM6IHtcblx0XHRsaW5lOiB7XG5cdFx0XHR0ZW5zaW9uOiAwIC8vIG5vIGJlemllciBpbiByYWRhclxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBjb250cm9sbGVyX3JhZGFyID0gY29yZV9kYXRhc2V0Q29udHJvbGxlci5leHRlbmQoe1xuXG5cdGRhdGFzZXRFbGVtZW50VHlwZTogZWxlbWVudHMuTGluZSxcblxuXHRkYXRhRWxlbWVudFR5cGU6IGVsZW1lbnRzLlBvaW50LFxuXG5cdGxpbmtTY2FsZXM6IGhlbHBlcnMkMS5ub29wLFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24ocmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0TWV0YSgpO1xuXHRcdHZhciBsaW5lID0gbWV0YS5kYXRhc2V0O1xuXHRcdHZhciBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG5cdFx0dmFyIHNjYWxlID0gbWUuY2hhcnQuc2NhbGU7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHQvLyBDb21wYXRpYmlsaXR5OiBJZiB0aGUgcHJvcGVydGllcyBhcmUgZGVmaW5lZCB3aXRoIG9ubHkgdGhlIG9sZCBuYW1lLCB1c2UgdGhvc2UgdmFsdWVzXG5cdFx0aWYgKChkYXRhc2V0LnRlbnNpb24gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGFzZXQubGluZVRlbnNpb24gPT09IHVuZGVmaW5lZCkpIHtcblx0XHRcdGRhdGFzZXQubGluZVRlbnNpb24gPSBkYXRhc2V0LnRlbnNpb247XG5cdFx0fVxuXG5cdFx0Ly8gVXRpbGl0eVxuXHRcdGxpbmUuX3NjYWxlID0gc2NhbGU7XG5cdFx0bGluZS5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0Ly8gRGF0YVxuXHRcdGxpbmUuX2NoaWxkcmVuID0gcG9pbnRzO1xuXHRcdGxpbmUuX2xvb3AgPSB0cnVlO1xuXHRcdC8vIE1vZGVsXG5cdFx0bGluZS5fbW9kZWwgPSBtZS5fcmVzb2x2ZUxpbmVPcHRpb25zKGxpbmUpO1xuXG5cdFx0bGluZS5waXZvdCgpO1xuXG5cdFx0Ly8gVXBkYXRlIFBvaW50c1xuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS51cGRhdGVFbGVtZW50KHBvaW50c1tpXSwgaSwgcmVzZXQpO1xuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSBiZXppZXIgY29udHJvbCBwb2ludHNcblx0XHRtZS51cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKCk7XG5cblx0XHQvLyBOb3cgcGl2b3QgdGhlIHBvaW50IGZvciBhbmltYXRpb25cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cG9pbnRzW2ldLnBpdm90KCk7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZUVsZW1lbnQ6IGZ1bmN0aW9uKHBvaW50LCBpbmRleCwgcmVzZXQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjdXN0b20gPSBwb2ludC5jdXN0b20gfHwge307XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5nZXREYXRhc2V0KCk7XG5cdFx0dmFyIHNjYWxlID0gbWUuY2hhcnQuc2NhbGU7XG5cdFx0dmFyIHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIGRhdGFzZXQuZGF0YVtpbmRleF0pO1xuXHRcdHZhciBvcHRpb25zID0gbWUuX3Jlc29sdmVQb2ludE9wdGlvbnMocG9pbnQsIGluZGV4KTtcblx0XHR2YXIgbGluZU1vZGVsID0gbWUuZ2V0TWV0YSgpLmRhdGFzZXQuX21vZGVsO1xuXHRcdHZhciB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuXHRcdHZhciB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xuXG5cdFx0Ly8gVXRpbGl0eVxuXHRcdHBvaW50Ll9zY2FsZSA9IHNjYWxlO1xuXHRcdHBvaW50Ll9vcHRpb25zID0gb3B0aW9ucztcblx0XHRwb2ludC5fZGF0YXNldEluZGV4ID0gbWUuaW5kZXg7XG5cdFx0cG9pbnQuX2luZGV4ID0gaW5kZXg7XG5cblx0XHQvLyBEZXNpcmVkIHZpZXcgcHJvcGVydGllc1xuXHRcdHBvaW50Ll9tb2RlbCA9IHtcblx0XHRcdHg6IHgsIC8vIHZhbHVlIG5vdCB1c2VkIGluIGRhdGFzZXQgc2NhbGUsIGJ1dCB3ZSB3YW50IGEgY29uc2lzdGVudCBBUEkgYmV0d2VlbiBzY2FsZXNcblx0XHRcdHk6IHksXG5cdFx0XHRza2lwOiBjdXN0b20uc2tpcCB8fCBpc05hTih4KSB8fCBpc05hTih5KSxcblx0XHRcdC8vIEFwcGVhcmFuY2Vcblx0XHRcdHJhZGl1czogb3B0aW9ucy5yYWRpdXMsXG5cdFx0XHRwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG5cdFx0XHRyb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcblx0XHRcdGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcblx0XHRcdGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuXHRcdFx0dGVuc2lvbjogdmFsdWVPckRlZmF1bHQkNihjdXN0b20udGVuc2lvbiwgbGluZU1vZGVsID8gbGluZU1vZGVsLnRlbnNpb24gOiAwKSxcblxuXHRcdFx0Ly8gVG9vbHRpcFxuXHRcdFx0aGl0UmFkaXVzOiBvcHRpb25zLmhpdFJhZGl1c1xuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZVBvaW50T3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1ttZS5pbmRleF07XG5cdFx0dmFyIGN1c3RvbSA9IGVsZW1lbnQuY3VzdG9tIHx8IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY2hhcnQub3B0aW9ucy5lbGVtZW50cy5wb2ludDtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdC8vIFNjcmlwdGFibGUgb3B0aW9uc1xuXHRcdHZhciBjb250ZXh0ID0ge1xuXHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0ZGF0YUluZGV4OiBpbmRleCxcblx0XHRcdGRhdGFzZXQ6IGRhdGFzZXQsXG5cdFx0XHRkYXRhc2V0SW5kZXg6IG1lLmluZGV4XG5cdFx0fTtcblxuXHRcdHZhciBFTEVNRU5UX09QVElPTlMgPSB7XG5cdFx0XHRiYWNrZ3JvdW5kQ29sb3I6ICdwb2ludEJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRib3JkZXJDb2xvcjogJ3BvaW50Qm9yZGVyQ29sb3InLFxuXHRcdFx0Ym9yZGVyV2lkdGg6ICdwb2ludEJvcmRlcldpZHRoJyxcblx0XHRcdGhpdFJhZGl1czogJ3BvaW50SGl0UmFkaXVzJyxcblx0XHRcdGhvdmVyQmFja2dyb3VuZENvbG9yOiAncG9pbnRIb3ZlckJhY2tncm91bmRDb2xvcicsXG5cdFx0XHRob3ZlckJvcmRlckNvbG9yOiAncG9pbnRIb3ZlckJvcmRlckNvbG9yJyxcblx0XHRcdGhvdmVyQm9yZGVyV2lkdGg6ICdwb2ludEhvdmVyQm9yZGVyV2lkdGgnLFxuXHRcdFx0aG92ZXJSYWRpdXM6ICdwb2ludEhvdmVyUmFkaXVzJyxcblx0XHRcdHBvaW50U3R5bGU6ICdwb2ludFN0eWxlJyxcblx0XHRcdHJhZGl1czogJ3BvaW50UmFkaXVzJyxcblx0XHRcdHJvdGF0aW9uOiAncG9pbnRSb3RhdGlvbidcblx0XHR9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoRUxFTUVOVF9PUFRJT05TKTtcblxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHZhbHVlc1trZXldID0gcmVzb2x2ZSQ2KFtcblx0XHRcdFx0Y3VzdG9tW2tleV0sXG5cdFx0XHRcdGRhdGFzZXRbRUxFTUVOVF9PUFRJT05TW2tleV1dLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSwgY29udGV4dCwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzb2x2ZUxpbmVPcHRpb25zOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbbWUuaW5kZXhdO1xuXHRcdHZhciBjdXN0b20gPSBlbGVtZW50LmN1c3RvbSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuZWxlbWVudHMubGluZTtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cdFx0dmFyIGksIGlsZW4sIGtleTtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0J2JhY2tncm91bmRDb2xvcicsXG5cdFx0XHQnYm9yZGVyV2lkdGgnLFxuXHRcdFx0J2JvcmRlckNvbG9yJyxcblx0XHRcdCdib3JkZXJDYXBTdHlsZScsXG5cdFx0XHQnYm9yZGVyRGFzaCcsXG5cdFx0XHQnYm9yZGVyRGFzaE9mZnNldCcsXG5cdFx0XHQnYm9yZGVySm9pblN0eWxlJyxcblx0XHRcdCdmaWxsJ1xuXHRcdF07XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHR2YWx1ZXNba2V5XSA9IHJlc29sdmUkNihbXG5cdFx0XHRcdGN1c3RvbVtrZXldLFxuXHRcdFx0XHRkYXRhc2V0W2tleV0sXG5cdFx0XHRcdG9wdGlvbnNba2V5XVxuXHRcdFx0XSk7XG5cdFx0fVxuXG5cdFx0dmFsdWVzLnRlbnNpb24gPSB2YWx1ZU9yRGVmYXVsdCQ2KGRhdGFzZXQubGluZVRlbnNpb24sIG9wdGlvbnMudGVuc2lvbik7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdHVwZGF0ZUJlemllckNvbnRyb2xQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1ldGEgPSBtZS5nZXRNZXRhKCk7XG5cdFx0dmFyIGFyZWEgPSBtZS5jaGFydC5jaGFydEFyZWE7XG5cdFx0dmFyIHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcblx0XHR2YXIgaSwgaWxlbiwgbW9kZWwsIGNvbnRyb2xQb2ludHM7XG5cblx0XHRmdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdG1vZGVsID0gcG9pbnRzW2ldLl9tb2RlbDtcblx0XHRcdGNvbnRyb2xQb2ludHMgPSBoZWxwZXJzJDEuc3BsaW5lQ3VydmUoXG5cdFx0XHRcdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXG5cdFx0XHRcdG1vZGVsLFxuXHRcdFx0XHRoZWxwZXJzJDEubmV4dEl0ZW0ocG9pbnRzLCBpLCB0cnVlKS5fbW9kZWwsXG5cdFx0XHRcdG1vZGVsLnRlbnNpb25cblx0XHRcdCk7XG5cblx0XHRcdC8vIFByZXZlbnQgdGhlIGJlemllciBnb2luZyBvdXRzaWRlIG9mIHRoZSBib3VuZHMgb2YgdGhlIGdyYXBoXG5cdFx0XHRtb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5wcmV2aW91cy54LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50UHJldmlvdXNZID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMucHJldmlvdXMueSwgYXJlYS50b3AsIGFyZWEuYm90dG9tKTtcblx0XHRcdG1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gY2FwQ29udHJvbFBvaW50KGNvbnRyb2xQb2ludHMubmV4dC54LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuXHRcdFx0bW9kZWwuY29udHJvbFBvaW50TmV4dFkgPSBjYXBDb250cm9sUG9pbnQoY29udHJvbFBvaW50cy5uZXh0LnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNldEhvdmVyU3R5bGU6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIG1vZGVsID0gcG9pbnQuX21vZGVsO1xuXHRcdHZhciBvcHRpb25zID0gcG9pbnQuX29wdGlvbnM7XG5cdFx0dmFyIGdldEhvdmVyQ29sb3IgPSBoZWxwZXJzJDEuZ2V0SG92ZXJDb2xvcjtcblxuXHRcdHBvaW50LiRwcmV2aW91c1N0eWxlID0ge1xuXHRcdFx0YmFja2dyb3VuZENvbG9yOiBtb2RlbC5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0XHRib3JkZXJDb2xvcjogbW9kZWwuYm9yZGVyQ29sb3IsXG5cdFx0XHRib3JkZXJXaWR0aDogbW9kZWwuYm9yZGVyV2lkdGgsXG5cdFx0XHRyYWRpdXM6IG1vZGVsLnJhZGl1c1xuXHRcdH07XG5cblx0XHRtb2RlbC5iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IsIGdldEhvdmVyQ29sb3Iob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJvcmRlckNvbG9yLCBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpKTtcblx0XHRtb2RlbC5ib3JkZXJXaWR0aCA9IHZhbHVlT3JEZWZhdWx0JDYob3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcblx0XHRtb2RlbC5yYWRpdXMgPSB2YWx1ZU9yRGVmYXVsdCQ2KG9wdGlvbnMuaG92ZXJSYWRpdXMsIG9wdGlvbnMucmFkaXVzKTtcblx0fVxufSk7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnc2NhdHRlcicsIHtcblx0aG92ZXI6IHtcblx0XHRtb2RlOiAnc2luZ2xlJ1xuXHR9LFxuXG5cdHNjYWxlczoge1xuXHRcdHhBeGVzOiBbe1xuXHRcdFx0aWQ6ICd4LWF4aXMtMScsICAgIC8vIG5lZWQgYW4gSUQgc28gZGF0YXNldHMgY2FuIHJlZmVyZW5jZSB0aGUgc2NhbGVcblx0XHRcdHR5cGU6ICdsaW5lYXInLCAgICAvLyBzY2F0dGVyIHNob3VsZCBub3QgdXNlIGEgY2F0ZWdvcnkgYXhpc1xuXHRcdFx0cG9zaXRpb246ICdib3R0b20nXG5cdFx0fV0sXG5cdFx0eUF4ZXM6IFt7XG5cdFx0XHRpZDogJ3ktYXhpcy0xJyxcblx0XHRcdHR5cGU6ICdsaW5lYXInLFxuXHRcdFx0cG9zaXRpb246ICdsZWZ0J1xuXHRcdH1dXG5cdH0sXG5cblx0c2hvd0xpbmVzOiBmYWxzZSxcblxuXHR0b29sdGlwczoge1xuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0dGl0bGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJyc7ICAgICAvLyBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIHNjYXR0ZXIgc2luY2UgZGF0YSBhcmUgZm9ybWF0dGVkIGFzIGEgcG9pbnRcblx0XHRcdH0sXG5cdFx0XHRsYWJlbDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gJygnICsgaXRlbS54TGFiZWwgKyAnLCAnICsgaXRlbS55TGFiZWwgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gU2NhdHRlciBjaGFydHMgdXNlIGxpbmUgY29udHJvbGxlcnNcbnZhciBjb250cm9sbGVyX3NjYXR0ZXIgPSBjb250cm9sbGVyX2xpbmU7XG5cbi8vIE5PVEUgZXhwb3J0IGEgbWFwIGluIHdoaWNoIHRoZSBrZXkgcmVwcmVzZW50cyB0aGUgY29udHJvbGxlciB0eXBlLCBub3Rcbi8vIHRoZSBjbGFzcywgYW5kIHNvIG11c3QgYmUgQ2FtZWxDYXNlIGluIG9yZGVyIHRvIGJlIGNvcnJlY3RseSByZXRyaWV2ZWRcbi8vIGJ5IHRoZSBjb250cm9sbGVyIGluIGNvcmUuY29udHJvbGxlci5qcyAoYGNvbnRyb2xsZXJzW21ldGEudHlwZV1gKS5cblxudmFyIGNvbnRyb2xsZXJzID0ge1xuXHRiYXI6IGNvbnRyb2xsZXJfYmFyLFxuXHRidWJibGU6IGNvbnRyb2xsZXJfYnViYmxlLFxuXHRkb3VnaG51dDogY29udHJvbGxlcl9kb3VnaG51dCxcblx0aG9yaXpvbnRhbEJhcjogY29udHJvbGxlcl9ob3Jpem9udGFsQmFyLFxuXHRsaW5lOiBjb250cm9sbGVyX2xpbmUsXG5cdHBvbGFyQXJlYTogY29udHJvbGxlcl9wb2xhckFyZWEsXG5cdHBpZTogY29udHJvbGxlcl9waWUsXG5cdHJhZGFyOiBjb250cm9sbGVyX3JhZGFyLFxuXHRzY2F0dGVyOiBjb250cm9sbGVyX3NjYXR0ZXJcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCByZWxhdGl2ZSBwb3NpdGlvbiBmb3IgYW4gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR8SUV2ZW50fSBldmVudCAtIFRoZSBldmVudCB0byBnZXQgdGhlIHBvc2l0aW9uIGZvclxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnRcbiAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBldmVudCBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KSB7XG5cdGlmIChlLm5hdGl2ZSkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBlLngsXG5cdFx0XHR5OiBlLnlcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhdmVyc2UgYWxsIG9mIHRoZSB2aXNpYmxlIGVsZW1lbnRzIGluIHRoZSBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCB2aXNpYmxlIGl0ZW1cbiAqL1xuZnVuY3Rpb24gcGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGhhbmRsZXIpIHtcblx0dmFyIGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcblx0dmFyIG1ldGEsIGksIGosIGlsZW4sIGpsZW47XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGlmICghY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdGZvciAoaiA9IDAsIGpsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IG1ldGEuZGF0YVtqXTtcblx0XHRcdGlmICghZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRcdGhhbmRsZXIoZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0RWxlbWVudFtdfSBpdGVtcyAtIGVsZW1lbnRzIHRvIGZpbHRlclxuICogQHBhcmFtIHtvYmplY3R9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG9cbiAqIEByZXR1cm4ge0NoYXJ0RWxlbWVudFtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24pIHtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRlaCBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge29iamVjdH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0b1xuICogQHBhcmFtIHtib29sZWFufSBpbnRlcnNlY3QgLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZGlzdGFuY2VNZXRyaWMgLSBmdW5jdGlvbiB0byBwcm92aWRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50c1xuICogQHJldHVybiB7Q2hhcnRFbGVtZW50W119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGludGVyc2VjdCwgZGlzdGFuY2VNZXRyaWMpIHtcblx0dmFyIG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHR2YXIgbmVhcmVzdEl0ZW1zID0gW107XG5cblx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoaW50ZXJzZWN0ICYmICFlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCgpO1xuXHRcdHZhciBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuXHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRuZWFyZXN0SXRlbXMgPSBbZWxlbWVudF07XG5cdFx0XHRtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHQvLyBDYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSBkaXN0YW5jZSBpbiB3aGljaCBjYXNlIHdlIHNvcnQgYnkgc2l6ZVxuXHRcdFx0bmVhcmVzdEl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gbmVhcmVzdEl0ZW1zO1xufVxuXG4vKipcbiAqIEdldCBhIGRpc3RhbmNlIG1ldHJpYyBmdW5jdGlvbiBmb3IgdHdvIHBvaW50cyBiYXNlZCBvbiB0aGVcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eVxuICovXG5mdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuXHR2YXIgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcblx0dmFyIHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG5cdFx0dmFyIGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG5cdFx0dmFyIGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGluZGV4TW9kZShjaGFydCwgZSwgb3B0aW9ucykge1xuXHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0Ly8gRGVmYXVsdCBheGlzIGZvciBpbmRleCBtb2RlIGlzICd4JyB0byBtYXRjaCBvbGQgYmVoYXZpb3VyXG5cdG9wdGlvbnMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG5cdHZhciBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhvcHRpb25zLmF4aXMpO1xuXHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblxuXHRpZiAoIWl0ZW1zLmxlbmd0aCkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaChmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpKSB7XG5cdFx0XHR2YXIgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHR2YXIgZWxlbWVudCA9IG1ldGEuZGF0YVtpdGVtc1swXS5faW5kZXhdO1xuXG5cdFx0XHQvLyBkb24ndCBjb3VudCBpdGVtcyB0aGF0IGFyZSBza2lwcGVkIChudWxsIGRhdGEpXG5cdFx0XHRpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5fdmlldy5za2lwKSB7XG5cdFx0XHRcdGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBJSW50ZXJhY3Rpb25PcHRpb25zXG4gKi9cbi8qKlxuICogSWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9pbnRcbiAqIEBuYW1lIElJbnRlcmZhY2VPcHRpb25zI2Jvb2xlYW5cbiAqIEB0eXBlIEJvb2xlYW5cbiAqL1xuXG4vKipcbiAqIENvbnRhaW5zIGludGVyYWN0aW9uIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkludGVyYWN0aW9uXG4gKi9cbnZhciBjb3JlX2ludGVyYWN0aW9uID0ge1xuXHQvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCBtb2Rlc1xuXHRtb2Rlczoge1xuXHRcdHNpbmdsZTogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0XHRcdHBhcnNlVmlzaWJsZUl0ZW1zKGNoYXJ0LCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSkpIHtcblx0XHRcdFx0XHRlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50cztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiBlbGVtZW50cy5zbGljZSgwLCAxKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmxhYmVsXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjQuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGxhYmVsOiBpbmRleE1vZGUsXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgbW9kZSBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4IGFzIHRoYXQgaXRlbVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbmRleFxuXHRcdCAqIEBzaW5jZSB2Mi40LjBcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SUludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlIGR1cmluZyBpbnRlcmFjdGlvblxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRpbmRleDogaW5kZXhNb2RlLFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBpbiB0aGF0IGRhdGFzZXRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2UgZHVyaW5nIGludGVyYWN0aW9uXG5cdFx0ICogQHJldHVybiB7Q2hhcnQuRWxlbWVudFtdfSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSB1bmRlciB0aGUgcG9pbnQuIElmIG5vbmUgYXJlIGZvdW5kLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZFxuXHRcdCAqL1xuXHRcdGRhdGFzZXQ6IGZ1bmN0aW9uKGNoYXJ0LCBlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcblx0XHRcdG9wdGlvbnMuYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuXHRcdFx0dmFyIGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKG9wdGlvbnMuYXhpcyk7XG5cdFx0XHR2YXIgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbikgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBmYWxzZSwgZGlzdGFuY2VNZXRyaWMpO1xuXG5cdFx0XHRpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRpdGVtcyA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLl9kYXRhc2V0SW5kZXgpLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLngtYXhpc1xuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi40LjAuIFVzZSBpbmRleCBtb2RlIGFuZCBpbnRlcnNlY3QgPT0gdHJ1ZVxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdCd4LWF4aXMnOiBmdW5jdGlvbihjaGFydCwgZSkge1xuXHRcdFx0cmV0dXJuIGluZGV4TW9kZShjaGFydCwgZSwge2ludGVyc2VjdDogZmFsc2V9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIG9mIHRoZSBldmVudFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHRwb2ludDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0cmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbik7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0bmVhcmVzdDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0b3B0aW9ucy5heGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG5cdFx0XHR2YXIgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMob3B0aW9ucy5heGlzKTtcblx0XHRcdHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBvcHRpb25zLmludGVyc2VjdCwgZGlzdGFuY2VNZXRyaWMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiB4IG1vZGUgcmV0dXJucyB0aGUgZWxlbWVudHMgdGhhdCBoaXQtdGVzdCBhdCB0aGUgY3VycmVudCB4IGNvb3JkaW5hdGVcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMueFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJSW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcmV0dXJuIHtDaGFydC5FbGVtZW50W119IEFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHVuZGVyIHRoZSBwb2ludC4gSWYgbm9uZSBhcmUgZm91bmQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkXG5cdFx0ICovXG5cdFx0eDogZnVuY3Rpb24oY2hhcnQsIGUsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuXHRcdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0XHR2YXIgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcblxuXHRcdFx0cGFyc2VWaXNpYmxlSXRlbXMoY2hhcnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5YUmFuZ2UocG9zaXRpb24ueCkpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGludGVyc2VjdHNJdGVtID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG5cdFx0XHQvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG5cdFx0XHRpZiAob3B0aW9ucy5pbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG5cdFx0XHRcdGl0ZW1zID0gW107XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIHkgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHkgY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy55XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0lJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEByZXR1cm4ge0NoYXJ0LkVsZW1lbnRbXX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgdW5kZXIgdGhlIHBvaW50LiBJZiBub25lIGFyZSBmb3VuZCwgYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWRcblx0XHQgKi9cblx0XHR5OiBmdW5jdGlvbihjaGFydCwgZSwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG5cdFx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRcdHZhciBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG5cdFx0XHRwYXJzZVZpc2libGVJdGVtcyhjaGFydCwgZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5pbllSYW5nZShwb3NpdGlvbi55KSkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2goZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpKSB7XG5cdFx0XHRcdFx0aW50ZXJzZWN0c0l0ZW0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gSWYgd2Ugd2FudCB0byB0cmlnZ2VyIG9uIGFuIGludGVyc2VjdCBhbmQgd2UgZG9uJ3QgaGF2ZSBhbnkgaXRlbXNcblx0XHRcdC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcblx0XHRcdGlmIChvcHRpb25zLmludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcblx0XHRcdFx0aXRlbXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdH1cbn07XG5cbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG5cdHJldHVybiBoZWxwZXJzJDEud2hlcmUoYXJyYXksIGZ1bmN0aW9uKHYpIHtcblx0XHRyZXR1cm4gdi5wb3NpdGlvbiA9PT0gcG9zaXRpb247XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcblx0YXJyYXkuZm9yRWFjaChmdW5jdGlvbih2LCBpKSB7XG5cdFx0di5fdG1wSW5kZXhfID0gaTtcblx0XHRyZXR1cm4gdjtcblx0fSk7XG5cdGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdHZhciB2MCA9IHJldmVyc2UgPyBiIDogYTtcblx0XHR2YXIgdjEgPSByZXZlcnNlID8gYSA6IGI7XG5cdFx0cmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cblx0XHRcdHYwLl90bXBJbmRleF8gLSB2MS5fdG1wSW5kZXhfIDpcblx0XHRcdHYwLndlaWdodCAtIHYxLndlaWdodDtcblx0fSk7XG5cdGFycmF5LmZvckVhY2goZnVuY3Rpb24odikge1xuXHRcdGRlbGV0ZSB2Ll90bXBJbmRleF87XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kTWF4UGFkZGluZyhib3hlcykge1xuXHR2YXIgdG9wID0gMDtcblx0dmFyIGxlZnQgPSAwO1xuXHR2YXIgYm90dG9tID0gMDtcblx0dmFyIHJpZ2h0ID0gMDtcblx0aGVscGVycyQxLmVhY2goYm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdGlmIChib3guZ2V0UGFkZGluZykge1xuXHRcdFx0dmFyIGJveFBhZGRpbmcgPSBib3guZ2V0UGFkZGluZygpO1xuXHRcdFx0dG9wID0gTWF0aC5tYXgodG9wLCBib3hQYWRkaW5nLnRvcCk7XG5cdFx0XHRsZWZ0ID0gTWF0aC5tYXgobGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcblx0XHRcdGJvdHRvbSA9IE1hdGgubWF4KGJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuXHRcdFx0cmlnaHQgPSBNYXRoLm1heChyaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHtcblx0XHR0b3A6IHRvcCxcblx0XHRsZWZ0OiBsZWZ0LFxuXHRcdGJvdHRvbTogYm90dG9tLFxuXHRcdHJpZ2h0OiByaWdodFxuXHR9O1xufVxuXG5mdW5jdGlvbiBhZGRTaXplQnlQb3NpdGlvbihib3hlcywgc2l6ZSkge1xuXHRoZWxwZXJzJDEuZWFjaChib3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0c2l6ZVtib3gucG9zaXRpb25dICs9IGJveC5pc0hvcml6b250YWwoKSA/IGJveC5oZWlnaHQgOiBib3gud2lkdGg7XG5cdH0pO1xufVxuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0bGF5b3V0OiB7XG5cdFx0cGFkZGluZzoge1xuXHRcdFx0dG9wOiAwLFxuXHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRib3R0b206IDAsXG5cdFx0XHRsZWZ0OiAwXG5cdFx0fVxuXHR9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIElMYXlvdXRJdGVtXG4gKiBAcHJvcCB7c3RyaW5nfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSBpbiB0aGUgY2hhcnQgbGF5b3V0LiBQb3NzaWJsZSB2YWx1ZXMgYXJlXG4gKiAnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgYW5kICdjaGFydEFyZWEnXG4gKiBAcHJvcCB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0IHVzZWQgdG8gc29ydCB0aGUgaXRlbS4gSGlnaGVyIHdlaWdodHMgYXJlIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBjaGFydCBhcmVhXG4gKiBAcHJvcCB7Ym9vbGVhbn0gZnVsbFdpZHRoIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBnZXRQYWRkaW5nIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbnZhciBjb3JlX2xheW91dHMgPSB7XG5cdGRlZmF1bHRzOiB7fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7SUxheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGF5ZWQgb3V0XG5cdCAqL1xuXHRhZGRCb3g6IGZ1bmN0aW9uKGNoYXJ0LCBpdGVtKSB7XG5cdFx0aWYgKCFjaGFydC5ib3hlcykge1xuXHRcdFx0Y2hhcnQuYm94ZXMgPSBbXTtcblx0XHR9XG5cblx0XHQvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuXHRcdGl0ZW0uZnVsbFdpZHRoID0gaXRlbS5mdWxsV2lkdGggfHwgZmFsc2U7XG5cdFx0aXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG5cdFx0aXRlbS53ZWlnaHQgPSBpdGVtLndlaWdodCB8fCAwO1xuXG5cdFx0Y2hhcnQuYm94ZXMucHVzaChpdGVtKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlIGEgbGF5b3V0SXRlbSBmcm9tIGEgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gcmVtb3ZlIHRoZSBib3ggZnJvbVxuXHQgKiBAcGFyYW0ge0lMYXlvdXRJdGVtfSBsYXlvdXRJdGVtIC0gdGhlIGl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxheW91dFxuXHQgKi9cblx0cmVtb3ZlQm94OiBmdW5jdGlvbihjaGFydCwgbGF5b3V0SXRlbSkge1xuXHRcdHZhciBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIChvciB1cGRhdGVzKSBvcHRpb25zIG9uIHRoZSBnaXZlbiBgaXRlbWAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IGluIHdoaWNoIHRoZSBpdGVtIGxpdmVzIChvciB3aWxsIGJlIGFkZGVkIHRvKVxuXHQgKiBAcGFyYW0ge0lMYXlvdXRJdGVtfSBpdGVtIC0gdGhlIGl0ZW0gdG8gY29uZmlndXJlIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSB0aGUgbmV3IGl0ZW0gb3B0aW9ucy5cblx0ICovXG5cdGNvbmZpZ3VyZTogZnVuY3Rpb24oY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgcHJvcHMgPSBbJ2Z1bGxXaWR0aCcsICdwb3NpdGlvbicsICd3ZWlnaHQnXTtcblx0XHR2YXIgaWxlbiA9IHByb3BzLmxlbmd0aDtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dmFyIHByb3A7XG5cblx0XHRmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0cHJvcCA9IHByb3BzW2ldO1xuXHRcdFx0aWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcblx0XHRcdFx0aXRlbVtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRpZiAoIWNoYXJ0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxheW91dE9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmxheW91dCB8fCB7fTtcblx0XHR2YXIgcGFkZGluZyA9IGhlbHBlcnMkMS5vcHRpb25zLnRvUGFkZGluZyhsYXlvdXRPcHRpb25zLnBhZGRpbmcpO1xuXHRcdHZhciBsZWZ0UGFkZGluZyA9IHBhZGRpbmcubGVmdDtcblx0XHR2YXIgcmlnaHRQYWRkaW5nID0gcGFkZGluZy5yaWdodDtcblx0XHR2YXIgdG9wUGFkZGluZyA9IHBhZGRpbmcudG9wO1xuXHRcdHZhciBib3R0b21QYWRkaW5nID0gcGFkZGluZy5ib3R0b207XG5cblx0XHR2YXIgbGVmdEJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ2xlZnQnKTtcblx0XHR2YXIgcmlnaHRCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICdyaWdodCcpO1xuXHRcdHZhciB0b3BCb3hlcyA9IGZpbHRlckJ5UG9zaXRpb24oY2hhcnQuYm94ZXMsICd0b3AnKTtcblx0XHR2YXIgYm90dG9tQm94ZXMgPSBmaWx0ZXJCeVBvc2l0aW9uKGNoYXJ0LmJveGVzLCAnYm90dG9tJyk7XG5cdFx0dmFyIGNoYXJ0QXJlYUJveGVzID0gZmlsdGVyQnlQb3NpdGlvbihjaGFydC5ib3hlcywgJ2NoYXJ0QXJlYScpO1xuXG5cdFx0Ly8gU29ydCBib3hlcyBieSB3ZWlnaHQuIEEgaGlnaGVyIHdlaWdodCBpcyBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuXHRcdHNvcnRCeVdlaWdodChsZWZ0Qm94ZXMsIHRydWUpO1xuXHRcdHNvcnRCeVdlaWdodChyaWdodEJveGVzLCBmYWxzZSk7XG5cdFx0c29ydEJ5V2VpZ2h0KHRvcEJveGVzLCB0cnVlKTtcblx0XHRzb3J0QnlXZWlnaHQoYm90dG9tQm94ZXMsIGZhbHNlKTtcblxuXHRcdHZhciB2ZXJ0aWNhbEJveGVzID0gbGVmdEJveGVzLmNvbmNhdChyaWdodEJveGVzKTtcblx0XHR2YXIgaG9yaXpvbnRhbEJveGVzID0gdG9wQm94ZXMuY29uY2F0KGJvdHRvbUJveGVzKTtcblx0XHR2YXIgb3V0ZXJCb3hlcyA9IHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyk7XG5cblx0XHQvLyBFc3NlbnRpYWxseSB3ZSBub3cgaGF2ZSBhbnkgbnVtYmVyIG9mIGJveGVzIG9uIGVhY2ggb2YgdGhlIDQgc2lkZXMuXG5cdFx0Ly8gT3VyIGNhbnZhcyBsb29rcyBsaWtlIHRoZSBmb2xsb3dpbmcuXG5cdFx0Ly8gVGhlIGFyZWFzIEwxIGFuZCBMMiBhcmUgdGhlIGxlZnQgYXhlcy4gUjEgaXMgdGhlIHJpZ2h0IGF4aXMsIFQxIGlzIHRoZSB0b3AgYXhpcyBhbmRcblx0XHQvLyBCMSBpcyB0aGUgYm90dG9tIGF4aXNcblx0XHQvLyBUaGVyZSBhcmUgYWxzbyA0IHF1YWRyYW50LWxpa2UgbG9jYXRpb25zIChsZWZ0IHRvIHJpZ2h0IGluc3RlYWQgb2YgY2xvY2t3aXNlKSByZXNlcnZlZCBmb3IgY2hhcnQgb3ZlcmxheXNcblx0XHQvLyBUaGVzZSBsb2NhdGlvbnMgYXJlIHNpbmdsZS1ib3ggbG9jYXRpb25zIG9ubHksIHdoZW4gdHJ5aW5nIHRvIHJlZ2lzdGVyIGEgY2hhcnRBcmVhIGxvY2F0aW9uIHRoYXQgaXMgYWxyZWFkeSB0YWtlbixcblx0XHQvLyBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cblx0XHQvL1xuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgICAgICAgICAgICAgICBUMSAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBUMiAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8IEMxIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEMyIHwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgTDEgfCBMMiB8ICAgICAgICAgICBDaGFydEFyZWEgKEMwKSAgICAgICAgICAgIHwgUjEgfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8LS0tLXwgICAgICAgICAgICAgICAgICAgICAgICAgICB8LS0tLXwgICAgfFxuXHRcdC8vIHwgICAgfCAgICB8IEMzIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8IEM0IHwgICAgfFxuXHRcdC8vIHwgICAgfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tfFxuXHRcdC8vIHwgICAgfCAgICB8ICAgICAgICAgICAgICAgICBCMSAgICAgICAgICAgICAgICAgIHwgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vIHwgICAgICAgICAgICAgICAgICBCMiAoRnVsbCBXaWR0aCkgICAgICAgICAgICAgICAgICAgfFxuXHRcdC8vIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuXHRcdC8vXG5cdFx0Ly8gV2hhdCB3ZSBkbyB0byBmaW5kIHRoZSBiZXN0IHNpemluZywgd2UgZG8gdGhlIGZvbGxvd2luZ1xuXHRcdC8vIDEuIERldGVybWluZSB0aGUgbWluaW11bSBzaXplIG9mIHRoZSBjaGFydCBhcmVhLlxuXHRcdC8vIDIuIFNwbGl0IHRoZSByZW1haW5pbmcgd2lkdGggZXF1YWxseSBiZXR3ZWVuIGVhY2ggdmVydGljYWwgYXhpc1xuXHRcdC8vIDMuIFNwbGl0IHRoZSByZW1haW5pbmcgaGVpZ2h0IGVxdWFsbHkgYmV0d2VlbiBlYWNoIGhvcml6b250YWwgYXhpc1xuXHRcdC8vIDQuIEdpdmUgZWFjaCBsYXlvdXQgdGhlIG1heGltdW0gc2l6ZSBpdCBjYW4gYmUuIFRoZSBsYXlvdXQgd2lsbCByZXR1cm4gaXQncyBtaW5pbXVtIHNpemVcblx0XHQvLyA1LiBBZGp1c3QgdGhlIHNpemVzIG9mIGVhY2ggYXhpcyBiYXNlZCBvbiBpdCdzIG1pbmltdW0gcmVwb3J0ZWQgc2l6ZS5cblx0XHQvLyA2LiBSZWZpdCBlYWNoIGF4aXNcblx0XHQvLyA3LiBQb3NpdGlvbiBlYWNoIGF4aXMgaW4gdGhlIGZpbmFsIGxvY2F0aW9uXG5cdFx0Ly8gOC4gVGVsbCB0aGUgY2hhcnQgdGhlIGZpbmFsIGxvY2F0aW9uIG9mIHRoZSBjaGFydCBhcmVhXG5cdFx0Ly8gOS4gVGVsbCBhbnkgYXhlcyB0aGF0IG92ZXJsYXkgdGhlIGNoYXJ0IGFyZWEgdGhlIHBvc2l0aW9ucyBvZiB0aGUgY2hhcnQgYXJlYVxuXG5cdFx0Ly8gU3RlcCAxXG5cdFx0dmFyIGNoYXJ0V2lkdGggPSB3aWR0aCAtIGxlZnRQYWRkaW5nIC0gcmlnaHRQYWRkaW5nO1xuXHRcdHZhciBjaGFydEhlaWdodCA9IGhlaWdodCAtIHRvcFBhZGRpbmcgLSBib3R0b21QYWRkaW5nO1xuXHRcdHZhciBjaGFydEFyZWFXaWR0aCA9IGNoYXJ0V2lkdGggLyAyOyAvLyBtaW4gNTAlXG5cblx0XHQvLyBTdGVwIDJcblx0XHR2YXIgdmVydGljYWxCb3hXaWR0aCA9ICh3aWR0aCAtIGNoYXJ0QXJlYVdpZHRoKSAvIHZlcnRpY2FsQm94ZXMubGVuZ3RoO1xuXG5cdFx0Ly8gU3RlcCAzXG5cdFx0Ly8gVE9ETyByZS1saW1pdCBob3Jpem9udGFsIGF4aXMgaGVpZ2h0ICh0aGlzIGxpbWl0IGhhcyBhZmZlY3RlZCBvbmx5IHBhZGRpbmcgY2FsY3VsYXRpb24gc2luY2UgUFIgMTgzNylcblx0XHQvLyB2YXIgaG9yaXpvbnRhbEJveEhlaWdodCA9IChoZWlnaHQgLSBjaGFydEFyZWFIZWlnaHQpIC8gaG9yaXpvbnRhbEJveGVzLmxlbmd0aDtcblxuXHRcdC8vIFN0ZXAgNFxuXHRcdHZhciBtYXhDaGFydEFyZWFXaWR0aCA9IGNoYXJ0V2lkdGg7XG5cdFx0dmFyIG1heENoYXJ0QXJlYUhlaWdodCA9IGNoYXJ0SGVpZ2h0O1xuXHRcdHZhciBvdXRlckJveFNpemVzID0ge3RvcDogdG9wUGFkZGluZywgbGVmdDogbGVmdFBhZGRpbmcsIGJvdHRvbTogYm90dG9tUGFkZGluZywgcmlnaHQ6IHJpZ2h0UGFkZGluZ307XG5cdFx0dmFyIG1pbkJveFNpemVzID0gW107XG5cdFx0dmFyIG1heFBhZGRpbmc7XG5cblx0XHRmdW5jdGlvbiBnZXRNaW5pbXVtQm94U2l6ZShib3gpIHtcblx0XHRcdHZhciBtaW5TaXplO1xuXHRcdFx0dmFyIGlzSG9yaXpvbnRhbCA9IGJveC5pc0hvcml6b250YWwoKTtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRtaW5TaXplID0gYm94LnVwZGF0ZShib3guZnVsbFdpZHRoID8gY2hhcnRXaWR0aCA6IG1heENoYXJ0QXJlYVdpZHRoLCBjaGFydEhlaWdodCAvIDIpO1xuXHRcdFx0XHRtYXhDaGFydEFyZWFIZWlnaHQgLT0gbWluU2l6ZS5oZWlnaHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtaW5TaXplID0gYm94LnVwZGF0ZSh2ZXJ0aWNhbEJveFdpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQpO1xuXHRcdFx0XHRtYXhDaGFydEFyZWFXaWR0aCAtPSBtaW5TaXplLndpZHRoO1xuXHRcdFx0fVxuXG5cdFx0XHRtaW5Cb3hTaXplcy5wdXNoKHtcblx0XHRcdFx0aG9yaXpvbnRhbDogaXNIb3Jpem9udGFsLFxuXHRcdFx0XHR3aWR0aDogbWluU2l6ZS53aWR0aCxcblx0XHRcdFx0Ym94OiBib3gsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRoZWxwZXJzJDEuZWFjaChvdXRlckJveGVzLCBnZXRNaW5pbXVtQm94U2l6ZSk7XG5cblx0XHQvLyBJZiBhIGhvcml6b250YWwgYm94IGhhcyBwYWRkaW5nLCB3ZSBtb3ZlIHRoZSBsZWZ0IGJveGVzIG92ZXIgdG8gYXZvaWQgdWdseSBjaGFydHMgKHNlZSBpc3N1ZSAjMjQ3OClcblx0XHRtYXhQYWRkaW5nID0gZmluZE1heFBhZGRpbmcob3V0ZXJCb3hlcyk7XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCBtYXhDaGFydEFyZWFIZWlnaHQgYW5kIG1heENoYXJ0QXJlYVdpZHRoIGFyZSB0aGUgc2l6ZSB0aGUgY2hhcnQgYXJlYSBjb3VsZFxuXHRcdC8vIGJlIGlmIHRoZSBheGVzIGFyZSBkcmF3biBhdCB0aGVpciBtaW5pbXVtIHNpemVzLlxuXHRcdC8vIFN0ZXBzIDUgJiA2XG5cblx0XHQvLyBGdW5jdGlvbiB0byBmaXQgYSBib3hcblx0XHRmdW5jdGlvbiBmaXRCb3goYm94KSB7XG5cdFx0XHR2YXIgbWluQm94U2l6ZSA9IGhlbHBlcnMkMS5maW5kTmV4dFdoZXJlKG1pbkJveFNpemVzLCBmdW5jdGlvbihtaW5Cb3gpIHtcblx0XHRcdFx0cmV0dXJuIG1pbkJveC5ib3ggPT09IGJveDtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAobWluQm94U2l6ZSkge1xuXHRcdFx0XHRpZiAobWluQm94U2l6ZS5ob3Jpem9udGFsKSB7XG5cdFx0XHRcdFx0dmFyIHNjYWxlTWFyZ2luID0ge1xuXHRcdFx0XHRcdFx0bGVmdDogTWF0aC5tYXgob3V0ZXJCb3hTaXplcy5sZWZ0LCBtYXhQYWRkaW5nLmxlZnQpLFxuXHRcdFx0XHRcdFx0cmlnaHQ6IE1hdGgubWF4KG91dGVyQm94U2l6ZXMucmlnaHQsIG1heFBhZGRpbmcucmlnaHQpLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0Ym90dG9tOiAwXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIERvbid0IHVzZSBtaW4gc2l6ZSBoZXJlIGJlY2F1c2Ugb2YgbGFiZWwgcm90YXRpb24uIFdoZW4gdGhlIGxhYmVscyBhcmUgcm90YXRlZCwgdGhlaXIgcm90YXRpb24gaGlnaGx5IGRlcGVuZHNcblx0XHRcdFx0XHQvLyBvbiB0aGUgbWFyZ2luLiBTb21ldGltZXMgdGhleSBuZWVkIHRvIGluY3JlYXNlIGluIHNpemUgc2xpZ2h0bHlcblx0XHRcdFx0XHRib3gudXBkYXRlKGJveC5mdWxsV2lkdGggPyBjaGFydFdpZHRoIDogbWF4Q2hhcnRBcmVhV2lkdGgsIGNoYXJ0SGVpZ2h0IC8gMiwgc2NhbGVNYXJnaW4pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJveC51cGRhdGUobWluQm94U2l6ZS53aWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSwgYW5kIGNhbGN1bGF0ZSB0aGUgbGVmdCBhbmQgcmlnaHQgbWFyZ2lucyBmb3IgdGhlIGhvcml6b250YWwgYm94ZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh2ZXJ0aWNhbEJveGVzLCBmaXRCb3gpO1xuXHRcdGFkZFNpemVCeVBvc2l0aW9uKHZlcnRpY2FsQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0Ly8gU2V0IHRoZSBMZWZ0IGFuZCBSaWdodCBtYXJnaW5zIGZvciB0aGUgaG9yaXpvbnRhbCBib3hlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKGhvcml6b250YWxCb3hlcywgZml0Qm94KTtcblx0XHRhZGRTaXplQnlQb3NpdGlvbihob3Jpem9udGFsQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0ZnVuY3Rpb24gZmluYWxGaXRWZXJ0aWNhbEJveChib3gpIHtcblx0XHRcdHZhciBtaW5Cb3hTaXplID0gaGVscGVycyQxLmZpbmROZXh0V2hlcmUobWluQm94U2l6ZXMsIGZ1bmN0aW9uKG1pblNpemUpIHtcblx0XHRcdFx0cmV0dXJuIG1pblNpemUuYm94ID09PSBib3g7XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIHNjYWxlTWFyZ2luID0ge1xuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0dG9wOiBvdXRlckJveFNpemVzLnRvcCxcblx0XHRcdFx0Ym90dG9tOiBvdXRlckJveFNpemVzLmJvdHRvbVxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKG1pbkJveFNpemUpIHtcblx0XHRcdFx0Ym94LnVwZGF0ZShtaW5Cb3hTaXplLndpZHRoLCBtYXhDaGFydEFyZWFIZWlnaHQsIHNjYWxlTWFyZ2luKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBMZXQgdGhlIGxlZnQgbGF5b3V0IGtub3cgdGhlIGZpbmFsIG1hcmdpblxuXHRcdGhlbHBlcnMkMS5lYWNoKHZlcnRpY2FsQm94ZXMsIGZpbmFsRml0VmVydGljYWxCb3gpO1xuXG5cdFx0Ly8gUmVjYWxjdWxhdGUgYmVjYXVzZSB0aGUgc2l6ZSBvZiBlYWNoIGxheW91dCBtaWdodCBoYXZlIGNoYW5nZWQgc2xpZ2h0bHkgZHVlIHRvIHRoZSBtYXJnaW5zIChsYWJlbCByb3RhdGlvbiBmb3IgaW5zdGFuY2UpXG5cdFx0b3V0ZXJCb3hTaXplcyA9IHt0b3A6IHRvcFBhZGRpbmcsIGxlZnQ6IGxlZnRQYWRkaW5nLCBib3R0b206IGJvdHRvbVBhZGRpbmcsIHJpZ2h0OiByaWdodFBhZGRpbmd9O1xuXHRcdGFkZFNpemVCeVBvc2l0aW9uKG91dGVyQm94ZXMsIG91dGVyQm94U2l6ZXMpO1xuXG5cdFx0Ly8gV2UgbWF5IGJlIGFkZGluZyBzb21lIHBhZGRpbmcgdG8gYWNjb3VudCBmb3Igcm90YXRlZCB4IGF4aXMgbGFiZWxzXG5cdFx0dmFyIGxlZnRQYWRkaW5nQWRkaXRpb24gPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQgLSBvdXRlckJveFNpemVzLmxlZnQsIDApO1xuXHRcdG91dGVyQm94U2l6ZXMubGVmdCArPSBsZWZ0UGFkZGluZ0FkZGl0aW9uO1xuXHRcdG91dGVyQm94U2l6ZXMucmlnaHQgKz0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCAtIG91dGVyQm94U2l6ZXMucmlnaHQsIDApO1xuXG5cdFx0dmFyIHRvcFBhZGRpbmdBZGRpdGlvbiA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wIC0gb3V0ZXJCb3hTaXplcy50b3AsIDApO1xuXHRcdG91dGVyQm94U2l6ZXMudG9wICs9IHRvcFBhZGRpbmdBZGRpdGlvbjtcblx0XHRvdXRlckJveFNpemVzLmJvdHRvbSArPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSAtIG91dGVyQm94U2l6ZXMuYm90dG9tLCAwKTtcblxuXHRcdC8vIEZpZ3VyZSBvdXQgaWYgb3VyIGNoYXJ0IGFyZWEgY2hhbmdlZC4gVGhpcyB3b3VsZCBvY2N1ciBpZiB0aGUgZGF0YXNldCBsYXlvdXQgbGFiZWwgcm90YXRpb25cblx0XHQvLyBjaGFuZ2VkIGR1ZSB0byB0aGUgYXBwbGljYXRpb24gb2YgdGhlIG1hcmdpbnMgaW4gc3RlcCA2LiBTaW5jZSB3ZSBjYW4gb25seSBnZXQgYmlnZ2VyLCB0aGlzIGlzIHNhZmUgdG8gZG9cblx0XHQvLyB3aXRob3V0IGNhbGxpbmcgYGZpdGAgYWdhaW5cblx0XHR2YXIgbmV3TWF4Q2hhcnRBcmVhSGVpZ2h0ID0gaGVpZ2h0IC0gb3V0ZXJCb3hTaXplcy50b3AgLSBvdXRlckJveFNpemVzLmJvdHRvbTtcblx0XHR2YXIgbmV3TWF4Q2hhcnRBcmVhV2lkdGggPSB3aWR0aCAtIG91dGVyQm94U2l6ZXMubGVmdCAtIG91dGVyQm94U2l6ZXMucmlnaHQ7XG5cblx0XHRpZiAobmV3TWF4Q2hhcnRBcmVhV2lkdGggIT09IG1heENoYXJ0QXJlYVdpZHRoIHx8IG5ld01heENoYXJ0QXJlYUhlaWdodCAhPT0gbWF4Q2hhcnRBcmVhSGVpZ2h0KSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh2ZXJ0aWNhbEJveGVzLCBmdW5jdGlvbihib3gpIHtcblx0XHRcdFx0Ym94LmhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChob3Jpem9udGFsQm94ZXMsIGZ1bmN0aW9uKGJveCkge1xuXHRcdFx0XHRpZiAoIWJveC5mdWxsV2lkdGgpIHtcblx0XHRcdFx0XHRib3gud2lkdGggPSBuZXdNYXhDaGFydEFyZWFXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdG1heENoYXJ0QXJlYUhlaWdodCA9IG5ld01heENoYXJ0QXJlYUhlaWdodDtcblx0XHRcdG1heENoYXJ0QXJlYVdpZHRoID0gbmV3TWF4Q2hhcnRBcmVhV2lkdGg7XG5cdFx0fVxuXG5cdFx0Ly8gU3RlcCA3IC0gUG9zaXRpb24gdGhlIGJveGVzXG5cdFx0dmFyIGxlZnQgPSBsZWZ0UGFkZGluZyArIGxlZnRQYWRkaW5nQWRkaXRpb247XG5cdFx0dmFyIHRvcCA9IHRvcFBhZGRpbmcgKyB0b3BQYWRkaW5nQWRkaXRpb247XG5cblx0XHRmdW5jdGlvbiBwbGFjZUJveChib3gpIHtcblx0XHRcdGlmIChib3guaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdFx0Ym94LmxlZnQgPSBib3guZnVsbFdpZHRoID8gbGVmdFBhZGRpbmcgOiBvdXRlckJveFNpemVzLmxlZnQ7XG5cdFx0XHRcdGJveC5yaWdodCA9IGJveC5mdWxsV2lkdGggPyB3aWR0aCAtIHJpZ2h0UGFkZGluZyA6IG91dGVyQm94U2l6ZXMubGVmdCArIG1heENoYXJ0QXJlYVdpZHRoO1xuXHRcdFx0XHRib3gudG9wID0gdG9wO1xuXHRcdFx0XHRib3guYm90dG9tID0gdG9wICsgYm94LmhlaWdodDtcblxuXHRcdFx0XHQvLyBNb3ZlIHRvIG5leHQgcG9pbnRcblx0XHRcdFx0dG9wID0gYm94LmJvdHRvbTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRib3gubGVmdCA9IGxlZnQ7XG5cdFx0XHRcdGJveC5yaWdodCA9IGxlZnQgKyBib3gud2lkdGg7XG5cdFx0XHRcdGJveC50b3AgPSBvdXRlckJveFNpemVzLnRvcDtcblx0XHRcdFx0Ym94LmJvdHRvbSA9IG91dGVyQm94U2l6ZXMudG9wICsgbWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXG5cdFx0XHRcdC8vIE1vdmUgdG8gbmV4dCBwb2ludFxuXHRcdFx0XHRsZWZ0ID0gYm94LnJpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhlbHBlcnMkMS5lYWNoKGxlZnRCb3hlcy5jb25jYXQodG9wQm94ZXMpLCBwbGFjZUJveCk7XG5cblx0XHQvLyBBY2NvdW50IGZvciBjaGFydCB3aWR0aCBhbmQgaGVpZ2h0XG5cdFx0bGVmdCArPSBtYXhDaGFydEFyZWFXaWR0aDtcblx0XHR0b3AgKz0gbWF4Q2hhcnRBcmVhSGVpZ2h0O1xuXG5cdFx0aGVscGVycyQxLmVhY2gocmlnaHRCb3hlcywgcGxhY2VCb3gpO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGJvdHRvbUJveGVzLCBwbGFjZUJveCk7XG5cblx0XHQvLyBTdGVwIDhcblx0XHRjaGFydC5jaGFydEFyZWEgPSB7XG5cdFx0XHRsZWZ0OiBvdXRlckJveFNpemVzLmxlZnQsXG5cdFx0XHR0b3A6IG91dGVyQm94U2l6ZXMudG9wLFxuXHRcdFx0cmlnaHQ6IG91dGVyQm94U2l6ZXMubGVmdCArIG1heENoYXJ0QXJlYVdpZHRoLFxuXHRcdFx0Ym90dG9tOiBvdXRlckJveFNpemVzLnRvcCArIG1heENoYXJ0QXJlYUhlaWdodFxuXHRcdH07XG5cblx0XHQvLyBTdGVwIDlcblx0XHRoZWxwZXJzJDEuZWFjaChjaGFydEFyZWFCb3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRib3gubGVmdCA9IGNoYXJ0LmNoYXJ0QXJlYS5sZWZ0O1xuXHRcdFx0Ym94LnRvcCA9IGNoYXJ0LmNoYXJ0QXJlYS50b3A7XG5cdFx0XHRib3gucmlnaHQgPSBjaGFydC5jaGFydEFyZWEucmlnaHQ7XG5cdFx0XHRib3guYm90dG9tID0gY2hhcnQuY2hhcnRBcmVhLmJvdHRvbTtcblxuXHRcdFx0Ym94LnVwZGF0ZShtYXhDaGFydEFyZWFXaWR0aCwgbWF4Q2hhcnRBcmVhSGVpZ2h0KTtcblx0XHR9KTtcblx0fVxufTtcblxuLyoqXG4gKiBQbGF0Zm9ybSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAobWluaW1hbCkuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU5MSNpc3N1ZWNvbW1lbnQtMzE5NTc1OTM5XG4gKi9cblxudmFyIHBsYXRmb3JtX2Jhc2ljID0ge1xuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG5cdFx0XHQvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcblx0XHRcdGl0ZW0gPSBpdGVtLmNhbnZhcztcblx0XHR9XG5cblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcblx0fVxufTtcblxudmFyIHBsYXRmb3JtX2RvbSA9IFwiLypcXG4gKiBET00gZWxlbWVudCByZW5kZXJpbmcgZGV0ZWN0aW9uXFxuICogaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXFxuICovXFxuQGtleWZyYW1lcyBjaGFydGpzLXJlbmRlci1hbmltYXRpb24ge1xcblxcdGZyb20geyBvcGFjaXR5OiAwLjk5OyB9XFxuXFx0dG8geyBvcGFjaXR5OiAxOyB9XFxufVxcblxcbi5jaGFydGpzLXJlbmRlci1tb25pdG9yIHtcXG5cXHRhbmltYXRpb246IGNoYXJ0anMtcmVuZGVyLWFuaW1hdGlvbiAwLjAwMXM7XFxufVxcblxcbi8qXFxuICogRE9NIGVsZW1lbnQgcmVzaXppbmcgZGV0ZWN0aW9uXFxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXNcXG4gKi9cXG4uY2hhcnRqcy1zaXplLW1vbml0b3IsXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLWV4cGFuZCxcXG4uY2hhcnRqcy1zaXplLW1vbml0b3Itc2hyaW5rIHtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0ZGlyZWN0aW9uOiBsdHI7XFxuXFx0bGVmdDogMDtcXG5cXHR0b3A6IDA7XFxuXFx0cmlnaHQ6IDA7XFxuXFx0Ym90dG9tOiAwO1xcblxcdG92ZXJmbG93OiBoaWRkZW47XFxuXFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XFxuXFx0dmlzaWJpbGl0eTogaGlkZGVuO1xcblxcdHotaW5kZXg6IC0xO1xcbn1cXG5cXG4uY2hhcnRqcy1zaXplLW1vbml0b3ItZXhwYW5kID4gZGl2IHtcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxuXFx0d2lkdGg6IDEwMDAwMDBweDtcXG5cXHRoZWlnaHQ6IDEwMDAwMDBweDtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG59XFxuXFxuLmNoYXJ0anMtc2l6ZS1tb25pdG9yLXNocmluayA+IGRpdiB7XFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcblxcdHdpZHRoOiAyMDAlO1xcblxcdGhlaWdodDogMjAwJTtcXG5cXHRsZWZ0OiAwO1xcblxcdHRvcDogMDtcXG59XFxuXCI7XG5cbnZhciBwbGF0Zm9ybV9kb20kMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbmRlZmF1bHQ6IHBsYXRmb3JtX2RvbVxufSk7XG5cbmZ1bmN0aW9uIGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UgKG4pIHtcblx0cmV0dXJuIG4gJiYgbi5kZWZhdWx0IHx8IG47XG59XG5cbnZhciBzdHlsZXNoZWV0ID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShwbGF0Zm9ybV9kb20kMSk7XG5cbnZhciBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG52YXIgQ1NTX1BSRUZJWCA9ICdjaGFydGpzLSc7XG52YXIgQ1NTX1NJWkVfTU9OSVRPUiA9IENTU19QUkVGSVggKyAnc2l6ZS1tb25pdG9yJztcbnZhciBDU1NfUkVOREVSX01PTklUT1IgPSBDU1NfUFJFRklYICsgJ3JlbmRlci1tb25pdG9yJztcbnZhciBDU1NfUkVOREVSX0FOSU1BVElPTiA9IENTU19QUkVGSVggKyAncmVuZGVyLWFuaW1hdGlvbic7XG52YXIgQU5JTUFUSU9OX1NUQVJUX0VWRU5UUyA9IFsnYW5pbWF0aW9uc3RhcnQnLCAnd2Via2l0QW5pbWF0aW9uU3RhcnQnXTtcblxuLyoqXG4gKiBET00gZXZlbnQgdHlwZXMgLT4gQ2hhcnQuanMgZXZlbnQgdHlwZXMuXG4gKiBOb3RlOiBvbmx5IGV2ZW50cyB3aXRoIGRpZmZlcmVudCB0eXBlcyBhcmUgbWFwcGVkLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHNcbiAqL1xudmFyIEVWRU5UX1RZUEVTID0ge1xuXHR0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcblx0dG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcblx0dG91Y2hlbmQ6ICdtb3VzZXVwJyxcblx0cG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG5cdHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcblx0cG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuXHRwb2ludGVydXA6ICdtb3VzZXVwJyxcblx0cG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuXHRwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG4vKipcbiAqIFRoZSBcInVzZWRcIiBzaXplIGlzIHRoZSBmaW5hbCB2YWx1ZSBvZiBhIGRpbWVuc2lvbiBwcm9wZXJ0eSBhZnRlciBhbGwgY2FsY3VsYXRpb25zIGhhdmVcbiAqIGJlZW4gcGVyZm9ybWVkLiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjb21wdXRlZCBzdHlsZSBvZiBgZWxlbWVudGAgYnV0IHJldHVybnMgdW5kZWZpbmVkXG4gKiBpZiB0aGUgY29tcHV0ZWQgc3R5bGUgaXMgbm90IGV4cHJlc3NlZCBpbiBwaXhlbHMuIFRoYXQgY2FuIGhhcHBlbiBpbiBzb21lIGNhc2VzIHdoZXJlXG4gKiBgZWxlbWVudGAgaGFzIGEgc2l6ZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGFuZCB0aGlzIGxhc3Qgb25lIGlzIG5vdCB5ZXQgZGlzcGxheWVkLFxuICogZm9yIGV4YW1wbGUgYmVjYXVzZSBvZiBgZGlzcGxheTogbm9uZWAgb24gYSBwYXJlbnQgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3VzZWRfdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpemUgaW4gcGl4ZWxzIG9yIHVuZGVmaW5lZCBpZiB1bmtub3duLlxuICovXG5mdW5jdGlvbiByZWFkVXNlZFNpemUoZWxlbWVudCwgcHJvcGVydHkpIHtcblx0dmFyIHZhbHVlID0gaGVscGVycyQxLmdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcblx0dmFyIG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcblx0cmV0dXJuIG1hdGNoZXMgPyBOdW1iZXIobWF0Y2hlc1sxXSkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBzdHlsZSBhbmQgcmVuZGVyIHNpemUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNhbnZhcyBkaXNwbGF5IHNpemUsXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXG4gKiB0byBkZXRlcm1pbmUgdGhlIGFzcGVjdCByYXRpbyB0byBhcHBseSBpbiBjYXNlIG5vIGV4cGxpY2l0IGhlaWdodCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBjb25maWcpIHtcblx0dmFyIHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG5cdC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcblx0Ly8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cblx0dmFyIHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuXHR2YXIgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuXG5cdC8vIENoYXJ0LmpzIG1vZGlmaWVzIHNvbWUgY2FudmFzIHZhbHVlcyB0aGF0IHdlIHdhbnQgdG8gcmVzdG9yZSBvbiBkZXN0cm95XG5cdGNhbnZhc1tFWFBBTkRPX0tFWV0gPSB7XG5cdFx0aW5pdGlhbDoge1xuXHRcdFx0aGVpZ2h0OiByZW5kZXJIZWlnaHQsXG5cdFx0XHR3aWR0aDogcmVuZGVyV2lkdGgsXG5cdFx0XHRzdHlsZToge1xuXHRcdFx0XHRkaXNwbGF5OiBzdHlsZS5kaXNwbGF5LFxuXHRcdFx0XHRoZWlnaHQ6IHN0eWxlLmhlaWdodCxcblx0XHRcdFx0d2lkdGg6IHN0eWxlLndpZHRoXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEZvcmNlIGNhbnZhcyB0byBkaXNwbGF5IGFzIGJsb2NrIHRvIGF2b2lkIGV4dHJhIHNwYWNlIGNhdXNlZCBieSBpbmxpbmVcblx0Ly8gZWxlbWVudHMsIHdoaWNoIHdvdWxkIGludGVyZmVyZSB3aXRoIHRoZSByZXNwb25zaXZlIHJlc2l6ZSBwcm9jZXNzLlxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjUzOFxuXHRzdHlsZS5kaXNwbGF5ID0gc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snO1xuXG5cdGlmIChyZW5kZXJXaWR0aCA9PT0gbnVsbCB8fCByZW5kZXJXaWR0aCA9PT0gJycpIHtcblx0XHR2YXIgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG5cdFx0aWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHJlbmRlckhlaWdodCA9PT0gbnVsbCB8fCByZW5kZXJIZWlnaHQgPT09ICcnKSB7XG5cdFx0aWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG5cdFx0XHQvLyBJZiBubyBleHBsaWNpdCByZW5kZXIgaGVpZ2h0IGFuZCBzdHlsZSBoZWlnaHQsIGxldCdzIGFwcGx5IHRoZSBhc3BlY3QgcmF0aW8sXG5cdFx0XHQvLyB3aGljaCBvbmUgY2FuIGJlIHNwZWNpZmllZCBieSB0aGUgdXNlciBidXQgYWxzbyBieSBjaGFydHMgYXMgZGVmYXVsdCBvcHRpb25cblx0XHRcdC8vIChpLmUuIG9wdGlvbnMuYXNwZWN0UmF0aW8pLiBJZiBub3Qgc3BlY2lmaWVkLCB1c2UgY2FudmFzIGFzcGVjdCByYXRpbyBvZiAyLlxuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCAvIChjb25maWcub3B0aW9ucy5hc3BlY3RSYXRpbyB8fCAyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG5cdFx0XHRpZiAoZGlzcGxheVdpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGRpc3BsYXlIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNhbnZhcztcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcblx0dmFyIHN1cHBvcnRzID0gZmFsc2U7XG5cdHRyeSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdldHRlci1yZXR1cm5cblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHN1cHBvcnRzID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZScsIG51bGwsIG9wdGlvbnMpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuXHR9XG5cdHJldHVybiBzdXBwb3J0cztcbn0oKSk7XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG52YXIgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuXHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnQodHlwZSwgY2hhcnQsIHgsIHksIG5hdGl2ZUV2ZW50KSB7XG5cdHJldHVybiB7XG5cdFx0dHlwZTogdHlwZSxcblx0XHRjaGFydDogY2hhcnQsXG5cdFx0bmF0aXZlOiBuYXRpdmVFdmVudCB8fCBudWxsLFxuXHRcdHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuXHRcdHk6IHkgIT09IHVuZGVmaW5lZCA/IHkgOiBudWxsLFxuXHR9O1xufVxuXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG5cdHZhciB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcblx0dmFyIHBvcyA9IGhlbHBlcnMkMS5nZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG5cdHJldHVybiBjcmVhdGVFdmVudCh0eXBlLCBjaGFydCwgcG9zLngsIHBvcy55LCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZykge1xuXHR2YXIgdGlja2luZyA9IGZhbHNlO1xuXHR2YXIgYXJncyA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR0aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xuXG5cdFx0aWYgKCF0aWNraW5nKSB7XG5cdFx0XHR0aWNraW5nID0gdHJ1ZTtcblx0XHRcdGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGlja2luZyA9IGZhbHNlO1xuXHRcdFx0XHRmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGl2KGNscykge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ZWwuY2xhc3NOYW1lID0gY2xzIHx8ICcnO1xuXHRyZXR1cm4gZWw7XG59XG5cbi8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJjai9jc3MtZWxlbWVudC1xdWVyaWVzXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVyKGhhbmRsZXIpIHtcblx0dmFyIG1heFNpemUgPSAxMDAwMDAwO1xuXG5cdC8vIE5PVEUoU0IpIERvbid0IHVzZSBpbm5lckhUTUwgYmVjYXVzZSBpdCBjb3VsZCBiZSBjb25zaWRlcmVkIHVuc2FmZS5cblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU5MDJcblx0dmFyIHJlc2l6ZXIgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUik7XG5cdHZhciBleHBhbmQgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUiArICctZXhwYW5kJyk7XG5cdHZhciBzaHJpbmsgPSBjcmVhdGVEaXYoQ1NTX1NJWkVfTU9OSVRPUiArICctc2hyaW5rJyk7XG5cblx0ZXhwYW5kLmFwcGVuZENoaWxkKGNyZWF0ZURpdigpKTtcblx0c2hyaW5rLmFwcGVuZENoaWxkKGNyZWF0ZURpdigpKTtcblxuXHRyZXNpemVyLmFwcGVuZENoaWxkKGV4cGFuZCk7XG5cdHJlc2l6ZXIuYXBwZW5kQ2hpbGQoc2hyaW5rKTtcblx0cmVzaXplci5fcmVzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRleHBhbmQuc2Nyb2xsTGVmdCA9IG1heFNpemU7XG5cdFx0ZXhwYW5kLnNjcm9sbFRvcCA9IG1heFNpemU7XG5cdFx0c2hyaW5rLnNjcm9sbExlZnQgPSBtYXhTaXplO1xuXHRcdHNocmluay5zY3JvbGxUb3AgPSBtYXhTaXplO1xuXHR9O1xuXG5cdHZhciBvblNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0aGFuZGxlcigpO1xuXHR9O1xuXG5cdGFkZExpc3RlbmVyKGV4cGFuZCwgJ3Njcm9sbCcsIG9uU2Nyb2xsLmJpbmQoZXhwYW5kLCAnZXhwYW5kJykpO1xuXHRhZGRMaXN0ZW5lcihzaHJpbmssICdzY3JvbGwnLCBvblNjcm9sbC5iaW5kKHNocmluaywgJ3NocmluaycpKTtcblxuXHRyZXR1cm4gcmVzaXplcjtcbn1cblxuLy8gaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5vZGUtaW5zZXJ0aW9uXG5mdW5jdGlvbiB3YXRjaEZvclJlbmRlcihub2RlLCBoYW5kbGVyKSB7XG5cdHZhciBleHBhbmRvID0gbm9kZVtFWFBBTkRPX0tFWV0gfHwgKG5vZGVbRVhQQU5ET19LRVldID0ge30pO1xuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5ID0gZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlLmFuaW1hdGlvbk5hbWUgPT09IENTU19SRU5ERVJfQU5JTUFUSU9OKSB7XG5cdFx0XHRoYW5kbGVyKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBwcm94eSk7XG5cdH0pO1xuXG5cdC8vICM0NzM3OiBDaHJvbWUgbWlnaHQgc2tpcCB0aGUgQ1NTIGFuaW1hdGlvbiB3aGVuIHRoZSBDU1NfUkVOREVSX01PTklUT1IgY2xhc3Ncblx0Ly8gaXMgcmVtb3ZlZCB0aGVuIGFkZGVkIGJhY2sgaW1tZWRpYXRlbHkgKHNhbWUgYW5pbWF0aW9uIGZyYW1lPykuIEFjY2Vzc2luZyB0aGVcblx0Ly8gYG9mZnNldFBhcmVudGAgcHJvcGVydHkgd2lsbCBmb3JjZSBhIHJlZmxvdyBhbmQgcmUtZXZhbHVhdGUgdGhlIENTUyBhbmltYXRpb24uXG5cdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC81ZDUyZmIwODFiMzU3MGM4MWUzYSNib3gtbWV0cmljc1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDczN1xuXHRleHBhbmRvLnJlZmxvdyA9ICEhbm9kZS5vZmZzZXRQYXJlbnQ7XG5cblx0bm9kZS5jbGFzc0xpc3QuYWRkKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIHVud2F0Y2hGb3JSZW5kZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcHJveHkgPSBleHBhbmRvLnJlbmRlclByb3h5O1xuXG5cdGlmIChwcm94eSkge1xuXHRcdGhlbHBlcnMkMS5lYWNoKEFOSU1BVElPTl9TVEFSVF9FVkVOVFMsIGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJlbW92ZUxpc3RlbmVyKG5vZGUsIHR5cGUsIHByb3h5KTtcblx0XHR9KTtcblxuXHRcdGRlbGV0ZSBleHBhbmRvLnJlbmRlclByb3h5O1xuXHR9XG5cblx0bm9kZS5jbGFzc0xpc3QucmVtb3ZlKENTU19SRU5ERVJfTU9OSVRPUik7XG59XG5cbmZ1bmN0aW9uIGFkZFJlc2l6ZUxpc3RlbmVyKG5vZGUsIGxpc3RlbmVyLCBjaGFydCkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IChub2RlW0VYUEFORE9fS0VZXSA9IHt9KTtcblxuXHQvLyBMZXQncyBrZWVwIHRyYWNrIG9mIHRoaXMgYWRkZWQgcmVzaXplciBhbmQgdGh1cyBhdm9pZCBET00gcXVlcnkgd2hlbiByZW1vdmluZyBpdC5cblx0dmFyIHJlc2l6ZXIgPSBleHBhbmRvLnJlc2l6ZXIgPSBjcmVhdGVSZXNpemVyKHRocm90dGxlZChmdW5jdGlvbigpIHtcblx0XHRpZiAoZXhwYW5kby5yZXNpemVyKSB7XG5cdFx0XHR2YXIgY29udGFpbmVyID0gY2hhcnQub3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIG5vZGUucGFyZW50Tm9kZTtcblx0XHRcdHZhciB3ID0gY29udGFpbmVyID8gY29udGFpbmVyLmNsaWVudFdpZHRoIDogMDtcblx0XHRcdGxpc3RlbmVyKGNyZWF0ZUV2ZW50KCdyZXNpemUnLCBjaGFydCkpO1xuXHRcdFx0aWYgKGNvbnRhaW5lciAmJiBjb250YWluZXIuY2xpZW50V2lkdGggPCB3ICYmIGNoYXJ0LmNhbnZhcykge1xuXHRcdFx0XHQvLyBJZiB0aGUgY29udGFpbmVyIHNpemUgc2hyYW5rIGR1cmluZyBjaGFydCByZXNpemUsIGxldCdzIGFzc3VtZVxuXHRcdFx0XHQvLyBzY3JvbGxiYXIgYXBwZWFyZWQuIFNvIHdlIHJlc2l6ZSBhZ2FpbiB3aXRoIHRoZSBzY3JvbGxiYXIgdmlzaWJsZSAtXG5cdFx0XHRcdC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cblx0XHRcdFx0Ly8gQmVjYXVzZSB3ZSBhcmUgaW5zaWRlIGB0aHJvdHRsZWRgLCBhbmQgY3VycmVudGx5IGB0aWNraW5nYCwgc2Nyb2xsXG5cdFx0XHRcdC8vIGV2ZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyB3aG9sZSAyIHJlc2l6ZSBwcm9jZXNzLlxuXHRcdFx0XHQvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG5cdFx0XHRcdC8vIHR3aWNlIGluIGEgZnJhbWUgKHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZSlcblx0XHRcdFx0bGlzdGVuZXIoY3JlYXRlRXZlbnQoJ3Jlc2l6ZScsIGNoYXJ0KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KSk7XG5cblx0Ly8gVGhlIHJlc2l6ZXIgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIG5vZGUgcGFyZW50LCBzbyB3ZSBmaXJzdCBuZWVkIHRvIGJlXG5cdC8vIHN1cmUgdGhhdCBgbm9kZWAgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSBiZWZvcmUgaW5qZWN0aW5nIHRoZSByZXNpemVyIGVsZW1lbnQuXG5cdHdhdGNoRm9yUmVuZGVyKG5vZGUsIGZ1bmN0aW9uKCkge1xuXHRcdGlmIChleHBhbmRvLnJlc2l6ZXIpIHtcblx0XHRcdHZhciBjb250YWluZXIgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoY29udGFpbmVyICYmIGNvbnRhaW5lciAhPT0gcmVzaXplci5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGNvbnRhaW5lci5pbnNlcnRCZWZvcmUocmVzaXplciwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgY29udGFpbmVyIHNpemUgbWlnaHQgaGF2ZSBjaGFuZ2VkLCBsZXQncyByZXNldCB0aGUgcmVzaXplciBzdGF0ZS5cblx0XHRcdHJlc2l6ZXIuX3Jlc2V0KCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUmVzaXplTGlzdGVuZXIobm9kZSkge1xuXHR2YXIgZXhwYW5kbyA9IG5vZGVbRVhQQU5ET19LRVldIHx8IHt9O1xuXHR2YXIgcmVzaXplciA9IGV4cGFuZG8ucmVzaXplcjtcblxuXHRkZWxldGUgZXhwYW5kby5yZXNpemVyO1xuXHR1bndhdGNoRm9yUmVuZGVyKG5vZGUpO1xuXG5cdGlmIChyZXNpemVyICYmIHJlc2l6ZXIucGFyZW50Tm9kZSkge1xuXHRcdHJlc2l6ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChyZXNpemVyKTtcblx0fVxufVxuXG5mdW5jdGlvbiBpbmplY3RDU1MocGxhdGZvcm0sIGNzcykge1xuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzkyMjEzOVxuXHR2YXIgc3R5bGUgPSBwbGF0Zm9ybS5fc3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0aWYgKCFwbGF0Zm9ybS5fc3R5bGUpIHtcblx0XHRwbGF0Zm9ybS5fc3R5bGUgPSBzdHlsZTtcblx0XHRjc3MgPSAnLyogQ2hhcnQuanMgKi9cXG4nICsgY3NzO1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuXHRcdGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9XG5cblx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG59XG5cbnZhciBwbGF0Zm9ybV9kb20kMiA9IHtcblx0LyoqXG5cdCAqIFdoZW4gYHRydWVgLCBwcmV2ZW50cyB0aGUgYXV0b21hdGljIGluamVjdGlvbiBvZiB0aGUgc3R5bGVzaGVldCByZXF1aXJlZCB0b1xuXHQgKiBjb3JyZWN0bHkgZGV0ZWN0IHdoZW4gdGhlIGNoYXJ0IGlzIGFkZGVkIHRvIHRoZSBET00gYW5kIHRoZW4gcmVzaXplZC4gVGhpc1xuXHQgKiBzd2l0Y2ggaGFzIGJlZW4gYWRkZWQgdG8gYWxsb3cgZXh0ZXJuYWwgc3R5bGVzaGVldCAoYGRpc3QvQ2hhcnQoLm1pbik/LmpzYClcblx0ICogdG8gYmUgbWFudWFsbHkgaW1wb3J0ZWQgdG8gbWFrZSB0aGlzIGxpYnJhcnkgY29tcGF0aWJsZSB3aXRoIGFueSBDU1AuXG5cdCAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTIwOFxuXHQgKi9cblx0ZGlzYWJsZUNTU0luamVjdGlvbjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIFRoaXMgcHJvcGVydHkgaG9sZHMgd2hldGhlciB0aGlzIHBsYXRmb3JtIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlxuXHQgKiBDdXJyZW50bHkgdXNlZCBieSBwbGF0Zm9ybS5qcyB0byBzZWxlY3QgdGhlIHByb3BlciBpbXBsZW1lbnRhdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbmFibGVkOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2Vuc3VyZUxvYWRlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xvYWRlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTIwOFxuXHRcdGlmICghdGhpcy5kaXNhYmxlQ1NTSW5qZWN0aW9uKSB7XG5cdFx0XHRpbmplY3RDU1ModGhpcywgc3R5bGVzaGVldCk7XG5cdFx0fVxuXHR9LFxuXG5cdGFjcXVpcmVDb250ZXh0OiBmdW5jdGlvbihpdGVtLCBjb25maWcpIHtcblx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG5cdFx0fSBlbHNlIGlmIChpdGVtLmxlbmd0aCkge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYXJyYXkgYmFzZWQgcXVlcmllcyAoc3VjaCBhcyBqUXVlcnkpXG5cdFx0XHRpdGVtID0gaXRlbVswXTtcblx0XHR9XG5cblx0XHRpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG5cdFx0XHRpdGVtID0gaXRlbS5jYW52YXM7XG5cdFx0fVxuXG5cdFx0Ly8gVG8gcHJldmVudCBjYW52YXMgZmluZ2VycHJpbnRpbmcsIHNvbWUgYWRkLW9ucyB1bmRlZmluZSB0aGUgZ2V0Q29udGV4dFxuXHRcdC8vIG1ldGhvZCwgZm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ra2Fwc25lci9DYW52YXNCbG9ja2VyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcblx0XHR2YXIgY29udGV4dCA9IGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIHBvc3NpYmxlIHRvIGNoYW5nZVxuXHRcdC8vIHBsYXRmb3JtIG9wdGlvbnMgYWZ0ZXIgaW1wb3J0aW5nIHRoZSBsaWJyYXJ5IChlLmcuIGBkaXNhYmxlQ1NTSW5qZWN0aW9uYCkuXG5cdFx0dGhpcy5fZW5zdXJlTG9hZGVkKCk7XG5cblx0XHQvLyBgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudC9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGZhaWxzIHdoZW4gdGhlIGl0ZW0gaXNcblx0XHQvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIHdoZW4gcnVubmluZyBpbiBhIHByb3RlY3RlZCBlbnZpcm9ubWVudC4gV2UgY291bGQgZ3Vlc3MgdGhlXG5cdFx0Ly8gdHlwZXMgZnJvbSB0aGVpciB0b1N0cmluZygpIHZhbHVlIGJ1dCBsZXQncyBrZWVwIHRoaW5ncyBmbGV4aWJsZSBhbmQgYXNzdW1lIGl0J3Ncblx0XHQvLyBhIHN1ZmZpY2llbnQgY29uZGl0aW9uIGlmIHRoZSBpdGVtIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgaXRlbSBhcyBgY2FudmFzYC5cblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzg4N1xuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTAyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNTJcblx0XHRpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gaXRlbSkge1xuXHRcdFx0aW5pdENhbnZhcyhpdGVtLCBjb25maWcpO1xuXHRcdFx0cmV0dXJuIGNvbnRleHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0cmVsZWFzZUNvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0XHR2YXIgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG5cdFx0aWYgKCFjYW52YXNbRVhQQU5ET19LRVldKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG5cdFx0WydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdHZhciB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG5cdFx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG5cdFx0XHRcdGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKGluaXRpYWwuc3R5bGUgfHwge30sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdGNhbnZhcy5zdHlsZVtrZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cblx0XHQvLyBUaGUgY2FudmFzIHJlbmRlciBzaXplIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkIChhbmQgdGh1cyB0aGUgc3RhdGUgc3RhY2sgZGlzY2FyZGVkKSxcblx0XHQvLyB3ZSBjYW4ndCB1c2Ugc2F2ZSgpIGFuZCByZXN0b3JlKCkgdG8gcmVzdG9yZSB0aGUgaW5pdGlhbCBzdGF0ZS4gU28gbWFrZSBzdXJlIHRoYXQgYXRcblx0XHQvLyBsZWFzdCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3RhdGUgYnkgc2V0dGluZyB0aGUgY2FudmFzIHdpZHRoLlxuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwNTI1L3RoZS1jYW52YXMtZWxlbWVudC5odG1sXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG5cdFx0Y2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuXG5cdFx0ZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG5cdH0sXG5cblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG5cdFx0dmFyIGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblx0XHRpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcblx0XHRcdC8vIE5vdGU6IHRoZSByZXNpemUgZXZlbnQgaXMgbm90IHN1cHBvcnRlZCBvbiBhbGwgYnJvd3NlcnMuXG5cdFx0XHRhZGRSZXNpemVMaXN0ZW5lcihjYW52YXMsIGxpc3RlbmVyLCBjaGFydCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGV4cGFuZG8gPSBsaXN0ZW5lcltFWFBBTkRPX0tFWV0gfHwgKGxpc3RlbmVyW0VYUEFORE9fS0VZXSA9IHt9KTtcblx0XHR2YXIgcHJveGllcyA9IGV4cGFuZG8ucHJveGllcyB8fCAoZXhwYW5kby5wcm94aWVzID0ge30pO1xuXHRcdHZhciBwcm94eSA9IHByb3hpZXNbY2hhcnQuaWQgKyAnXycgKyB0eXBlXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG5cdFx0fTtcblxuXHRcdGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXHR9LFxuXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuXHRcdHZhciBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cdFx0aWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG5cdFx0XHQvLyBOb3RlOiB0aGUgcmVzaXplIGV2ZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gYWxsIGJyb3dzZXJzLlxuXHRcdFx0cmVtb3ZlUmVzaXplTGlzdGVuZXIoY2FudmFzKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgZXhwYW5kbyA9IGxpc3RlbmVyW0VYUEFORE9fS0VZXSB8fCB7fTtcblx0XHR2YXIgcHJveGllcyA9IGV4cGFuZG8ucHJveGllcyB8fCB7fTtcblx0XHR2YXIgcHJveHkgPSBwcm94aWVzW2NoYXJ0LmlkICsgJ18nICsgdHlwZV07XG5cdFx0aWYgKCFwcm94eSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHJlbW92ZUxpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXHR9XG59O1xuXG4vLyBERVBSRUNBVElPTlNcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgaW5zdGVhZC5cbiAqIEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgY29tcGF0aWJpbGl0eTogQ2hyb21lLCBPcGVyYSA3LCBTYWZhcmksIEZGMS41KywgSUU5K1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lclxuICogQGZ1bmN0aW9uIENoYXJ0LmhlbHBlcnMuYWRkRXZlbnRcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi43LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5hZGRFdmVudCA9IGFkZExpc3RlbmVyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBpbnN0ZWFkLlxuICogRXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciBjb21wYXRpYmlsaXR5OiBDaHJvbWUsIE9wZXJhIDcsIFNhZmFyaSwgRkYxLjUrLCBJRTkrXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9yZW1vdmVFdmVudExpc3RlbmVyXG4gKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5yZW1vdmVFdmVudFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjcuMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuaGVscGVycyQxLnJlbW92ZUV2ZW50ID0gcmVtb3ZlTGlzdGVuZXI7XG5cbi8vIEBUT0RPIE1ha2UgcG9zc2libGUgdG8gc2VsZWN0IGFub3RoZXIgcGxhdGZvcm0gYXQgYnVpbGQgdGltZS5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHBsYXRmb3JtX2RvbSQyLl9lbmFibGVkID8gcGxhdGZvcm1fZG9tJDIgOiBwbGF0Zm9ybV9iYXNpYztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsYXRmb3JtXG4gKiBAc2VlIGh0dHBzOi8vY2hhcnRqcy5naXRib29rcy5pby9wcm9wb3NhbHMvY29udGVudC9QbGF0Zm9ybS5odG1sXG4gKiBAc2luY2UgMi40LjBcbiAqL1xudmFyIHBsYXRmb3JtID0gaGVscGVycyQxLmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIENhbGxlZCBhdCBjaGFydCBjb25zdHJ1Y3Rpb24gdGltZSwgcmV0dXJucyBhIGNvbnRleHQyZCBpbnN0YW5jZSBpbXBsZW1lbnRpbmdcblx0ICogdGhlIFtXM0MgQ2FudmFzIDJEIENvbnRleHQgQVBJIHN0YW5kYXJkXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0L30uXG5cdCAqIEBwYXJhbSB7Kn0gaXRlbSAtIFRoZSBuYXRpdmUgaXRlbSBmcm9tIHdoaWNoIHRvIGFjcXVpcmUgY29udGV4dCAocGxhdGZvcm0gc3BlY2lmaWMpXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gVGhlIGNoYXJ0IG9wdGlvbnNcblx0ICogQHJldHVybnMge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dDJkIGluc3RhbmNlXG5cdCAqL1xuXHRhY3F1aXJlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGRlc3RydWN0aW9uIHRpbWUsIHJlbGVhc2VzIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGV4dFxuXHQgKiBwcmV2aW91c2x5IHJldHVybmVkIGJ5IHRoZSBhY3F1aXJlQ29udGV4dCgpIG1ldGhvZC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dDJkIGluc3RhbmNlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBtZXRob2Qgc3VjY2VlZGVkLCBlbHNlIGZhbHNlXG5cdCAqL1xuXHRyZWxlYXNlQ29udGV4dDogZnVuY3Rpb24oKSB7fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgb24gdGhlIGdpdmVuIGNoYXJ0LlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gbGlzdGVuIGZvciBldmVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIElFdmVudH0pIHR5cGUgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG5cdCAqIHRoZSB7QGxpbmsgSUV2ZW50fSBpbnRlcmZhY2UpIHdoZW4gYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIG9jY3Vycy5cblx0ICovXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKCkge30sXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhZGRFdmVudExpc3RlbmVyLlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIElFdmVudH0pIHR5cGUgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudCB0YXJnZXQuXG5cdCAqL1xuXHRyZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9XG5cbn0sIGltcGxlbWVudGF0aW9uKTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHBsdWdpbnM6IHt9XG59KTtcblxuLyoqXG4gKiBUaGUgcGx1Z2luIHNlcnZpY2Ugc2luZ2xldG9uXG4gKiBAbmFtZXNwYWNlIENoYXJ0LnBsdWdpbnNcbiAqIEBzaW5jZSAyLjEuMFxuICovXG52YXIgY29yZV9wbHVnaW5zID0ge1xuXHQvKipcblx0ICogR2xvYmFsbHkgcmVnaXN0ZXJlZCBwbHVnaW5zLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3BsdWdpbnM6IFtdLFxuXG5cdC8qKlxuXHQgKiBUaGlzIGlkZW50aWZpZXIgaXMgdXNlZCB0byBpbnZhbGlkYXRlIHRoZSBkZXNjcmlwdG9ycyBjYWNoZSBhdHRhY2hlZCB0byBlYWNoIGNoYXJ0XG5cdCAqIHdoZW4gYSBnbG9iYWwgcGx1Z2luIGlzIHJlZ2lzdGVyZWQgb3IgdW5yZWdpc3RlcmVkLiBJbiB0aGlzIGNhc2UsIHRoZSBjYWNoZSBJRCBpc1xuXHQgKiBpbmNyZW1lbnRlZCBhbmQgZGVzY3JpcHRvcnMgYXJlIHJlZ2VuZXJhdGVkIGR1cmluZyBmb2xsb3dpbmcgQVBJIGNhbGxzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NhY2hlSWQ6IDAsXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gcGx1Z2luKHMpIGlmIG5vdCBhbHJlYWR5IHJlZ2lzdGVyZWQuXG5cdCAqIEBwYXJhbSB7SVBsdWdpbltdfElQbHVnaW59IHBsdWdpbnMgcGx1Z2luIGluc3RhbmNlKHMpLlxuXHQgKi9cblx0cmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHR2YXIgcCA9IHRoaXMuX3BsdWdpbnM7XG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdGlmIChwLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcblx0XHRcdFx0cC5wdXNoKHBsdWdpbik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVucmVnaXN0ZXJzIHRoZSBnaXZlbiBwbHVnaW4ocykgb25seSBpZiByZWdpc3RlcmVkLlxuXHQgKiBAcGFyYW0ge0lQbHVnaW5bXXxJUGx1Z2lufSBwbHVnaW5zIHBsdWdpbiBpbnN0YW5jZShzKS5cblx0ICovXG5cdHVucmVnaXN0ZXI6IGZ1bmN0aW9uKHBsdWdpbnMpIHtcblx0XHR2YXIgcCA9IHRoaXMuX3BsdWdpbnM7XG5cdFx0KFtdKS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW4pIHtcblx0XHRcdHZhciBpZHggPSBwLmluZGV4T2YocGx1Z2luKTtcblx0XHRcdGlmIChpZHggIT09IC0xKSB7XG5cdFx0XHRcdHAuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9jYWNoZUlkKys7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgcmVnaXN0ZXJlZCBwbHVnaW5zLlxuXHQgKiBAc2luY2UgMi4xLjVcblx0ICovXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wbHVnaW5zID0gW107XG5cdFx0dGhpcy5fY2FjaGVJZCsrO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgcmVnaXN0ZXJlZCBwbHVnaW5zP1xuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHQgKiBAc2luY2UgMi4xLjVcblx0ICovXG5cdGNvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucy5sZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgcGx1Z2luIGluc3RhbmNlcy5cblx0ICogQHJldHVybnMge0lQbHVnaW5bXX0gYXJyYXkgb2YgcGx1Z2luIG9iamVjdHMuXG5cdCAqIEBzaW5jZSAyLjEuNVxuXHQgKi9cblx0Z2V0QWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGx1Z2lucztcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIGZvciBgY2hhcnRgIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlIGZvciB3aGljaCBwbHVnaW5zIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgYW55IG9mIHRoZSBwbHVnaW5zIHJldHVybiBmYWxzZSwgZWxzZSByZXR1cm5zIHRydWUuXG5cdCAqL1xuXHRub3RpZnk6IGZ1bmN0aW9uKGNoYXJ0LCBob29rLCBhcmdzKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3JzID0gdGhpcy5kZXNjcmlwdG9ycyhjaGFydCk7XG5cdFx0dmFyIGlsZW4gPSBkZXNjcmlwdG9ycy5sZW5ndGg7XG5cdFx0dmFyIGksIGRlc2NyaXB0b3IsIHBsdWdpbiwgcGFyYW1zLCBtZXRob2Q7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRkZXNjcmlwdG9yID0gZGVzY3JpcHRvcnNbaV07XG5cdFx0XHRwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcblx0XHRcdG1ldGhvZCA9IHBsdWdpbltob29rXTtcblx0XHRcdGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHBhcmFtcyA9IFtjaGFydF0uY29uY2F0KGFyZ3MgfHwgW10pO1xuXHRcdFx0XHRwYXJhbXMucHVzaChkZXNjcmlwdG9yLm9wdGlvbnMpO1xuXHRcdFx0XHRpZiAobWV0aG9kLmFwcGx5KHBsdWdpbiwgcGFyYW1zKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBkZXNjcmlwdG9ycyBvZiBlbmFibGVkIHBsdWdpbnMgZm9yIHRoZSBnaXZlbiBjaGFydC5cblx0ICogQHJldHVybnMge29iamVjdFtdfSBbeyBwbHVnaW4sIG9wdGlvbnMgfV1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRlc2NyaXB0b3JzOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciBjYWNoZSA9IGNoYXJ0LiRwbHVnaW5zIHx8IChjaGFydC4kcGx1Z2lucyA9IHt9KTtcblx0XHRpZiAoY2FjaGUuaWQgPT09IHRoaXMuX2NhY2hlSWQpIHtcblx0XHRcdHJldHVybiBjYWNoZS5kZXNjcmlwdG9ycztcblx0XHR9XG5cblx0XHR2YXIgcGx1Z2lucyA9IFtdO1xuXHRcdHZhciBkZXNjcmlwdG9ycyA9IFtdO1xuXHRcdHZhciBjb25maWcgPSAoY2hhcnQgJiYgY2hhcnQuY29uZmlnKSB8fCB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zKSB8fCB7fTtcblxuXHRcdHRoaXMuX3BsdWdpbnMuY29uY2F0KGNvbmZpZy5wbHVnaW5zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHBsdWdpbikge1xuXHRcdFx0dmFyIGlkeCA9IHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pO1xuXHRcdFx0aWYgKGlkeCAhPT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaWQgPSBwbHVnaW4uaWQ7XG5cdFx0XHR2YXIgb3B0cyA9IG9wdGlvbnNbaWRdO1xuXHRcdFx0aWYgKG9wdHMgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMgPT09IHRydWUpIHtcblx0XHRcdFx0b3B0cyA9IGhlbHBlcnMkMS5jbG9uZShjb3JlX2RlZmF1bHRzLmdsb2JhbC5wbHVnaW5zW2lkXSk7XG5cdFx0XHR9XG5cblx0XHRcdHBsdWdpbnMucHVzaChwbHVnaW4pO1xuXHRcdFx0ZGVzY3JpcHRvcnMucHVzaCh7XG5cdFx0XHRcdHBsdWdpbjogcGx1Z2luLFxuXHRcdFx0XHRvcHRpb25zOiBvcHRzIHx8IHt9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdGNhY2hlLmRlc2NyaXB0b3JzID0gZGVzY3JpcHRvcnM7XG5cdFx0Y2FjaGUuaWQgPSB0aGlzLl9jYWNoZUlkO1xuXHRcdHJldHVybiBkZXNjcmlwdG9ycztcblx0fSxcblxuXHQvKipcblx0ICogSW52YWxpZGF0ZXMgY2FjaGUgZm9yIHRoZSBnaXZlbiBjaGFydDogZGVzY3JpcHRvcnMgaG9sZCBhIHJlZmVyZW5jZSBvbiBwbHVnaW4gb3B0aW9uLFxuXHQgKiBidXQgaW4gc29tZSBjYXNlcywgdGhpcyByZWZlcmVuY2UgY2FuIGJlIGNoYW5nZWQgYnkgdGhlIHVzZXIgd2hlbiB1cGRhdGluZyBvcHRpb25zLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTExMSNpc3N1ZWNvbW1lbnQtMzU1OTM0MTY3XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaW52YWxpZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRkZWxldGUgY2hhcnQuJHBsdWdpbnM7XG5cdH1cbn07XG5cbnZhciBjb3JlX3NjYWxlU2VydmljZSA9IHtcblx0Ly8gU2NhbGUgcmVnaXN0cmF0aW9uIG9iamVjdC4gRXh0ZW5zaW9ucyBjYW4gcmVnaXN0ZXIgbmV3IHNjYWxlIHR5cGVzIChzdWNoIGFzIGxvZyBvciBEQiBzY2FsZXMpIGFuZCB0aGVuXG5cdC8vIHVzZSB0aGUgbmV3IGNoYXJ0IG9wdGlvbnMgdG8gZ3JhYiB0aGUgY29ycmVjdCBzY2FsZVxuXHRjb25zdHJ1Y3RvcnM6IHt9LFxuXHQvLyBVc2UgYSByZWdpc3RyYXRpb24gZnVuY3Rpb24gc28gdGhhdCB3ZSBjYW4gbW92ZSB0byBhbiBFUzYgbWFwIHdoZW4gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gc3VwcG9ydFxuXHQvLyBvbGQgYnJvd3NlcnNcblxuXHQvLyBTY2FsZSBjb25maWcgZGVmYXVsdHNcblx0ZGVmYXVsdHM6IHt9LFxuXHRyZWdpc3RlclNjYWxlVHlwZTogZnVuY3Rpb24odHlwZSwgc2NhbGVDb25zdHJ1Y3Rvciwgc2NhbGVEZWZhdWx0cykge1xuXHRcdHRoaXMuY29uc3RydWN0b3JzW3R5cGVdID0gc2NhbGVDb25zdHJ1Y3Rvcjtcblx0XHR0aGlzLmRlZmF1bHRzW3R5cGVdID0gaGVscGVycyQxLmNsb25lKHNjYWxlRGVmYXVsdHMpO1xuXHR9LFxuXHRnZXRTY2FsZUNvbnN0cnVjdG9yOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3JzLmhhc093blByb3BlcnR5KHR5cGUpID8gdGhpcy5jb25zdHJ1Y3RvcnNbdHlwZV0gOiB1bmRlZmluZWQ7XG5cdH0sXG5cdGdldFNjYWxlRGVmYXVsdHM6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHQvLyBSZXR1cm4gdGhlIHNjYWxlIGRlZmF1bHRzIG1lcmdlZCB3aXRoIHRoZSBnbG9iYWwgc2V0dGluZ3Mgc28gdGhhdCB3ZSBhbHdheXMgdXNlIHRoZSBsYXRlc3Qgb25lc1xuXHRcdHJldHVybiB0aGlzLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpID8gaGVscGVycyQxLm1lcmdlKHt9LCBbY29yZV9kZWZhdWx0cy5zY2FsZSwgdGhpcy5kZWZhdWx0c1t0eXBlXV0pIDoge307XG5cdH0sXG5cdHVwZGF0ZVNjYWxlRGVmYXVsdHM6IGZ1bmN0aW9uKHR5cGUsIGFkZGl0aW9ucykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLmRlZmF1bHRzLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG5cdFx0XHRtZS5kZWZhdWx0c1t0eXBlXSA9IGhlbHBlcnMkMS5leHRlbmQobWUuZGVmYXVsdHNbdHlwZV0sIGFkZGl0aW9ucyk7XG5cdFx0fVxuXHR9LFxuXHRhZGRTY2FsZXNUb0xheW91dDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHQvLyBBZGRzIGVhY2ggc2NhbGUgdG8gdGhlIGNoYXJ0LmJveGVzIGFycmF5IHRvIGJlIHNpemVkIGFjY29yZGluZ2x5XG5cdFx0aGVscGVycyQxLmVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuXHRcdFx0Ly8gU2V0IElMYXlvdXRJdGVtIHBhcmFtZXRlcnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRzY2FsZS5mdWxsV2lkdGggPSBzY2FsZS5vcHRpb25zLmZ1bGxXaWR0aDtcblx0XHRcdHNjYWxlLnBvc2l0aW9uID0gc2NhbGUub3B0aW9ucy5wb3NpdGlvbjtcblx0XHRcdHNjYWxlLndlaWdodCA9IHNjYWxlLm9wdGlvbnMud2VpZ2h0O1xuXHRcdFx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgc2NhbGUpO1xuXHRcdH0pO1xuXHR9XG59O1xuXG52YXIgdmFsdWVPckRlZmF1bHQkNyA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHRvb2x0aXBzOiB7XG5cdFx0ZW5hYmxlZDogdHJ1ZSxcblx0XHRjdXN0b206IG51bGwsXG5cdFx0bW9kZTogJ25lYXJlc3QnLFxuXHRcdHBvc2l0aW9uOiAnYXZlcmFnZScsXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxuXHRcdGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG5cdFx0dGl0bGVGb250U3R5bGU6ICdib2xkJyxcblx0XHR0aXRsZVNwYWNpbmc6IDIsXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IDYsXG5cdFx0dGl0bGVGb250Q29sb3I6ICcjZmZmJyxcblx0XHR0aXRsZUFsaWduOiAnbGVmdCcsXG5cdFx0Ym9keVNwYWNpbmc6IDIsXG5cdFx0Ym9keUZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGJvZHlBbGlnbjogJ2xlZnQnLFxuXHRcdGZvb3RlckZvbnRTdHlsZTogJ2JvbGQnLFxuXHRcdGZvb3RlclNwYWNpbmc6IDIsXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiA2LFxuXHRcdGZvb3RlckZvbnRDb2xvcjogJyNmZmYnLFxuXHRcdGZvb3RlckFsaWduOiAnbGVmdCcsXG5cdFx0eVBhZGRpbmc6IDYsXG5cdFx0eFBhZGRpbmc6IDYsXG5cdFx0Y2FyZXRQYWRkaW5nOiAyLFxuXHRcdGNhcmV0U2l6ZTogNSxcblx0XHRjb3JuZXJSYWRpdXM6IDYsXG5cdFx0bXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG5cdFx0ZGlzcGxheUNvbG9yczogdHJ1ZSxcblx0XHRib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuXHRcdGJvcmRlcldpZHRoOiAwLFxuXHRcdGNhbGxiYWNrczoge1xuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVUaXRsZTogaGVscGVycyQxLm5vb3AsXG5cdFx0XHR0aXRsZTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XG5cdFx0XHRcdHZhciB0aXRsZSA9ICcnO1xuXHRcdFx0XHR2YXIgbGFiZWxzID0gZGF0YS5sYWJlbHM7XG5cdFx0XHRcdHZhciBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cblx0XHRcdFx0aWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG5cdFx0XHRcdFx0aWYgKGl0ZW0ubGFiZWwpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gaXRlbS5sYWJlbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGl0ZW0ueExhYmVsKSB7XG5cdFx0XHRcdFx0XHR0aXRsZSA9IGl0ZW0ueExhYmVsO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5pbmRleCA8IGxhYmVsQ291bnQpIHtcblx0XHRcdFx0XHRcdHRpdGxlID0gbGFiZWxzW2l0ZW0uaW5kZXhdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aXRsZTtcblx0XHRcdH0sXG5cdFx0XHRhZnRlclRpdGxlOiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRiZWZvcmVCb2R5OiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0XHRcdGJlZm9yZUxhYmVsOiBoZWxwZXJzJDEubm9vcCxcblx0XHRcdGxhYmVsOiBmdW5jdGlvbih0b29sdGlwSXRlbSwgZGF0YSkge1xuXHRcdFx0XHR2YXIgbGFiZWwgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF0ubGFiZWwgfHwgJyc7XG5cblx0XHRcdFx0aWYgKGxhYmVsKSB7XG5cdFx0XHRcdFx0bGFiZWwgKz0gJzogJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWhlbHBlcnMkMS5pc051bGxPclVuZGVmKHRvb2x0aXBJdGVtLnZhbHVlKSkge1xuXHRcdFx0XHRcdGxhYmVsICs9IHRvb2x0aXBJdGVtLnZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxhYmVsICs9IHRvb2x0aXBJdGVtLnlMYWJlbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0XHR9LFxuXHRcdFx0bGFiZWxDb2xvcjogZnVuY3Rpb24odG9vbHRpcEl0ZW0sIGNoYXJ0KSB7XG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcblx0XHRcdFx0dmFyIGFjdGl2ZUVsZW1lbnQgPSBtZXRhLmRhdGFbdG9vbHRpcEl0ZW0uaW5kZXhdO1xuXHRcdFx0XHR2YXIgdmlldyA9IGFjdGl2ZUVsZW1lbnQuX3ZpZXc7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Ym9yZGVyQ29sb3I6IHZpZXcuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0YmFja2dyb3VuZENvbG9yOiB2aWV3LmJhY2tncm91bmRDb2xvclxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGxhYmVsVGV4dENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX29wdGlvbnMuYm9keUZvbnRDb2xvcjtcblx0XHRcdH0sXG5cdFx0XHRhZnRlckxhYmVsOiBoZWxwZXJzJDEubm9vcCxcblxuXHRcdFx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG5cdFx0XHRhZnRlckJvZHk6IGhlbHBlcnMkMS5ub29wLFxuXG5cdFx0XHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcblx0XHRcdGJlZm9yZUZvb3RlcjogaGVscGVycyQxLm5vb3AsXG5cdFx0XHRmb290ZXI6IGhlbHBlcnMkMS5ub29wLFxuXHRcdFx0YWZ0ZXJGb290ZXI6IGhlbHBlcnMkMS5ub29wXG5cdFx0fVxuXHR9XG59KTtcblxudmFyIHBvc2l0aW9uZXJzID0ge1xuXHQvKipcblx0ICogQXZlcmFnZSBtb2RlIHBsYWNlcyB0aGUgdG9vbHRpcCBhdCB0aGUgYXZlcmFnZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudHMgc2hvd25cblx0ICogQGZ1bmN0aW9uIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnMuYXZlcmFnZVxuXHQgKiBAcGFyYW0gZWxlbWVudHMge0NoYXJ0RWxlbWVudFtdfSB0aGUgZWxlbWVudHMgYmVpbmcgZGlzcGxheWVkIGluIHRoZSB0b29sdGlwXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRvb2x0aXAgcG9zaXRpb25cblx0ICovXG5cdGF2ZXJhZ2U6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cdFx0aWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgaSwgbGVuO1xuXHRcdHZhciB4ID0gMDtcblx0XHR2YXIgeSA9IDA7XG5cdFx0dmFyIGNvdW50ID0gMDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG5cdFx0XHRcdHZhciBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcblx0XHRcdFx0eCArPSBwb3MueDtcblx0XHRcdFx0eSArPSBwb3MueTtcblx0XHRcdFx0Kytjb3VudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCAvIGNvdW50LFxuXHRcdFx0eTogeSAvIGNvdW50XG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdG9vbHRpcCBwb3NpdGlvbiBuZWFyZXN0IG9mIHRoZSBpdGVtIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdCAqIEBmdW5jdGlvbiBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzLm5lYXJlc3Rcblx0ICogQHBhcmFtIGVsZW1lbnRzIHtDaGFydC5FbGVtZW50W119IHRoZSB0b29sdGlwIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSBldmVudFBvc2l0aW9uIHtvYmplY3R9IHRoZSBwb3NpdGlvbiBvZiB0aGUgZXZlbnQgaW4gY2FudmFzIGNvb3JkaW5hdGVzXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSB0b29sdGlwIHBvc2l0aW9uXG5cdCAqL1xuXHRuZWFyZXN0OiBmdW5jdGlvbihlbGVtZW50cywgZXZlbnRQb3NpdGlvbikge1xuXHRcdHZhciB4ID0gZXZlbnRQb3NpdGlvbi54O1xuXHRcdHZhciB5ID0gZXZlbnRQb3NpdGlvbi55O1xuXHRcdHZhciBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0XHR2YXIgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0XHR2YXIgZWwgPSBlbGVtZW50c1tpXTtcblx0XHRcdGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuXHRcdFx0XHR2YXIgZCA9IGhlbHBlcnMkMS5kaXN0YW5jZUJldHdlZW5Qb2ludHMoZXZlbnRQb3NpdGlvbiwgY2VudGVyKTtcblxuXHRcdFx0XHRpZiAoZCA8IG1pbkRpc3RhbmNlKSB7XG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBkO1xuXHRcdFx0XHRcdG5lYXJlc3RFbGVtZW50ID0gZWw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobmVhcmVzdEVsZW1lbnQpIHtcblx0XHRcdHZhciB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuXHRcdFx0eCA9IHRwLng7XG5cdFx0XHR5ID0gdHAueTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0eDogeCxcblx0XHRcdHk6IHlcblx0XHR9O1xuXHR9XG59O1xuXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG5cdGlmICh0b1B1c2gpIHtcblx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodG9QdXNoKSkge1xuXHRcdFx0Ly8gYmFzZSA9IGJhc2UuY29uY2F0KHRvUHVzaCk7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRiYXNlLnB1c2godG9QdXNoKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYmFzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNwbGl0IGJ5IG5ld2xpbmUuXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IHZhbHVlIGlmIG5ld2xpbmUgcHJlc2VudCAtIFJldHVybmVkIGZyb20gU3RyaW5nIHNwbGl0KCkgbWV0aG9kXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcblx0aWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG5cdH1cblx0cmV0dXJuIHN0cjtcbn1cblxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIHRvIGNyZWF0ZSBhIHRvb2x0aXAgaXRlbSBtb2RlbFxuICogQHBhcmFtIGVsZW1lbnQgLSB0aGUgY2hhcnQgZWxlbWVudCAocG9pbnQsIGFyYywgYmFyKSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3JcbiAqIEByZXR1cm4gbmV3IHRvb2x0aXAgaXRlbVxuICovXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShlbGVtZW50KSB7XG5cdHZhciB4U2NhbGUgPSBlbGVtZW50Ll94U2NhbGU7XG5cdHZhciB5U2NhbGUgPSBlbGVtZW50Ll95U2NhbGUgfHwgZWxlbWVudC5fc2NhbGU7IC8vIGhhbmRsZSByYWRhciB8fCBwb2xhckFyZWEgY2hhcnRzXG5cdHZhciBpbmRleCA9IGVsZW1lbnQuX2luZGV4O1xuXHR2YXIgZGF0YXNldEluZGV4ID0gZWxlbWVudC5fZGF0YXNldEluZGV4O1xuXHR2YXIgY29udHJvbGxlciA9IGVsZW1lbnQuX2NoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcblx0dmFyIGluZGV4U2NhbGUgPSBjb250cm9sbGVyLl9nZXRJbmRleFNjYWxlKCk7XG5cdHZhciB2YWx1ZVNjYWxlID0gY29udHJvbGxlci5fZ2V0VmFsdWVTY2FsZSgpO1xuXG5cdHJldHVybiB7XG5cdFx0eExhYmVsOiB4U2NhbGUgPyB4U2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdHlMYWJlbDogeVNjYWxlID8geVNjYWxlLmdldExhYmVsRm9ySW5kZXgoaW5kZXgsIGRhdGFzZXRJbmRleCkgOiAnJyxcblx0XHRsYWJlbDogaW5kZXhTY2FsZSA/ICcnICsgaW5kZXhTY2FsZS5nZXRMYWJlbEZvckluZGV4KGluZGV4LCBkYXRhc2V0SW5kZXgpIDogJycsXG5cdFx0dmFsdWU6IHZhbHVlU2NhbGUgPyAnJyArIHZhbHVlU2NhbGUuZ2V0TGFiZWxGb3JJbmRleChpbmRleCwgZGF0YXNldEluZGV4KSA6ICcnLFxuXHRcdGluZGV4OiBpbmRleCxcblx0XHRkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCxcblx0XHR4OiBlbGVtZW50Ll9tb2RlbC54LFxuXHRcdHk6IGVsZW1lbnQuX21vZGVsLnlcblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSByZXNldCBtb2RlbCBmb3IgdGhlIHRvb2x0aXBcbiAqIEBwYXJhbSB0b29sdGlwT3B0cyB7b2JqZWN0fSB0aGUgdG9vbHRpcCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldEJhc2VNb2RlbCh0b29sdGlwT3B0cykge1xuXHR2YXIgZ2xvYmFsRGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbDtcblxuXHRyZXR1cm4ge1xuXHRcdC8vIFBvc2l0aW9uaW5nXG5cdFx0eFBhZGRpbmc6IHRvb2x0aXBPcHRzLnhQYWRkaW5nLFxuXHRcdHlQYWRkaW5nOiB0b29sdGlwT3B0cy55UGFkZGluZyxcblx0XHR4QWxpZ246IHRvb2x0aXBPcHRzLnhBbGlnbixcblx0XHR5QWxpZ246IHRvb2x0aXBPcHRzLnlBbGlnbixcblxuXHRcdC8vIEJvZHlcblx0XHRib2R5Rm9udENvbG9yOiB0b29sdGlwT3B0cy5ib2R5Rm9udENvbG9yLFxuXHRcdF9ib2R5Rm9udEZhbWlseTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5ib2R5Rm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdF9ib2R5Rm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLmJvZHlGb250U3R5bGUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U3R5bGUpLFxuXHRcdF9ib2R5QWxpZ246IHRvb2x0aXBPcHRzLmJvZHlBbGlnbixcblx0XHRib2R5Rm9udFNpemU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuYm9keUZvbnRTaXplLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFNpemUpLFxuXHRcdGJvZHlTcGFjaW5nOiB0b29sdGlwT3B0cy5ib2R5U3BhY2luZyxcblxuXHRcdC8vIFRpdGxlXG5cdFx0dGl0bGVGb250Q29sb3I6IHRvb2x0aXBPcHRzLnRpdGxlRm9udENvbG9yLFxuXHRcdF90aXRsZUZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMudGl0bGVGb250RmFtaWx5LCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udEZhbWlseSksXG5cdFx0X3RpdGxlRm9udFN0eWxlOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLnRpdGxlRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHR0aXRsZUZvbnRTaXplOiB2YWx1ZU9yRGVmYXVsdCQ3KHRvb2x0aXBPcHRzLnRpdGxlRm9udFNpemUsIGdsb2JhbERlZmF1bHRzLmRlZmF1bHRGb250U2l6ZSksXG5cdFx0X3RpdGxlQWxpZ246IHRvb2x0aXBPcHRzLnRpdGxlQWxpZ24sXG5cdFx0dGl0bGVTcGFjaW5nOiB0b29sdGlwT3B0cy50aXRsZVNwYWNpbmcsXG5cdFx0dGl0bGVNYXJnaW5Cb3R0b206IHRvb2x0aXBPcHRzLnRpdGxlTWFyZ2luQm90dG9tLFxuXG5cdFx0Ly8gRm9vdGVyXG5cdFx0Zm9vdGVyRm9udENvbG9yOiB0b29sdGlwT3B0cy5mb290ZXJGb250Q29sb3IsXG5cdFx0X2Zvb3RlckZvbnRGYW1pbHk6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuZm9vdGVyRm9udEZhbWlseSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRGYW1pbHkpLFxuXHRcdF9mb290ZXJGb250U3R5bGU6IHZhbHVlT3JEZWZhdWx0JDcodG9vbHRpcE9wdHMuZm9vdGVyRm9udFN0eWxlLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udFN0eWxlKSxcblx0XHRmb290ZXJGb250U2l6ZTogdmFsdWVPckRlZmF1bHQkNyh0b29sdGlwT3B0cy5mb290ZXJGb250U2l6ZSwgZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRTaXplKSxcblx0XHRfZm9vdGVyQWxpZ246IHRvb2x0aXBPcHRzLmZvb3RlckFsaWduLFxuXHRcdGZvb3RlclNwYWNpbmc6IHRvb2x0aXBPcHRzLmZvb3RlclNwYWNpbmcsXG5cdFx0Zm9vdGVyTWFyZ2luVG9wOiB0b29sdGlwT3B0cy5mb290ZXJNYXJnaW5Ub3AsXG5cblx0XHQvLyBBcHBlYXJhbmNlXG5cdFx0Y2FyZXRTaXplOiB0b29sdGlwT3B0cy5jYXJldFNpemUsXG5cdFx0Y29ybmVyUmFkaXVzOiB0b29sdGlwT3B0cy5jb3JuZXJSYWRpdXMsXG5cdFx0YmFja2dyb3VuZENvbG9yOiB0b29sdGlwT3B0cy5iYWNrZ3JvdW5kQ29sb3IsXG5cdFx0b3BhY2l0eTogMCxcblx0XHRsZWdlbmRDb2xvckJhY2tncm91bmQ6IHRvb2x0aXBPcHRzLm11bHRpS2V5QmFja2dyb3VuZCxcblx0XHRkaXNwbGF5Q29sb3JzOiB0b29sdGlwT3B0cy5kaXNwbGF5Q29sb3JzLFxuXHRcdGJvcmRlckNvbG9yOiB0b29sdGlwT3B0cy5ib3JkZXJDb2xvcixcblx0XHRib3JkZXJXaWR0aDogdG9vbHRpcE9wdHMuYm9yZGVyV2lkdGhcblx0fTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRvb2x0aXBcbiAqL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgbW9kZWwpIHtcblx0dmFyIGN0eCA9IHRvb2x0aXAuX2NoYXJ0LmN0eDtcblxuXHR2YXIgaGVpZ2h0ID0gbW9kZWwueVBhZGRpbmcgKiAyOyAvLyBUb29sdGlwIFBhZGRpbmdcblx0dmFyIHdpZHRoID0gMDtcblxuXHQvLyBDb3VudCBvZiBhbGwgbGluZXMgaW4gdGhlIGJvZHlcblx0dmFyIGJvZHkgPSBtb2RlbC5ib2R5O1xuXHR2YXIgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoZnVuY3Rpb24oY291bnQsIGJvZHlJdGVtKSB7XG5cdFx0cmV0dXJuIGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aDtcblx0fSwgMCk7XG5cdGNvbWJpbmVkQm9keUxlbmd0aCArPSBtb2RlbC5iZWZvcmVCb2R5Lmxlbmd0aCArIG1vZGVsLmFmdGVyQm9keS5sZW5ndGg7XG5cblx0dmFyIHRpdGxlTGluZUNvdW50ID0gbW9kZWwudGl0bGUubGVuZ3RoO1xuXHR2YXIgZm9vdGVyTGluZUNvdW50ID0gbW9kZWwuZm9vdGVyLmxlbmd0aDtcblx0dmFyIHRpdGxlRm9udFNpemUgPSBtb2RlbC50aXRsZUZvbnRTaXplO1xuXHR2YXIgYm9keUZvbnRTaXplID0gbW9kZWwuYm9keUZvbnRTaXplO1xuXHR2YXIgZm9vdGVyRm9udFNpemUgPSBtb2RlbC5mb290ZXJGb250U2l6ZTtcblxuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnRTaXplOyAvLyBUaXRsZSBMaW5lc1xuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG1vZGVsLnRpdGxlU3BhY2luZyA6IDA7IC8vIFRpdGxlIExpbmUgU3BhY2luZ1xuXHRoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgPyBtb2RlbC50aXRsZU1hcmdpbkJvdHRvbSA6IDA7IC8vIFRpdGxlJ3MgYm90dG9tIE1hcmdpblxuXHRoZWlnaHQgKz0gY29tYmluZWRCb2R5TGVuZ3RoICogYm9keUZvbnRTaXplOyAvLyBCb2R5IExpbmVzXG5cdGhlaWdodCArPSBjb21iaW5lZEJvZHlMZW5ndGggPyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBtb2RlbC5ib2R5U3BhY2luZyA6IDA7IC8vIEJvZHkgTGluZSBTcGFjaW5nXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgPyBtb2RlbC5mb290ZXJNYXJnaW5Ub3AgOiAwOyAvLyBGb290ZXIgTWFyZ2luXG5cdGhlaWdodCArPSBmb290ZXJMaW5lQ291bnQgKiAoZm9vdGVyRm9udFNpemUpOyAvLyBGb290ZXIgTGluZXNcblx0aGVpZ2h0ICs9IGZvb3RlckxpbmVDb3VudCA/IChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG1vZGVsLmZvb3RlclNwYWNpbmcgOiAwOyAvLyBGb290ZXIgTGluZSBTcGFjaW5nXG5cblx0Ly8gVGl0bGUgd2lkdGhcblx0dmFyIHdpZHRoUGFkZGluZyA9IDA7XG5cdHZhciBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG5cdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcblx0fTtcblxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIG1vZGVsLl90aXRsZUZvbnRTdHlsZSwgbW9kZWwuX3RpdGxlRm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEJvZHkgd2lkdGhcblx0Y3R4LmZvbnQgPSBoZWxwZXJzJDEuZm9udFN0cmluZyhib2R5Rm9udFNpemUsIG1vZGVsLl9ib2R5Rm9udFN0eWxlLCBtb2RlbC5fYm9keUZvbnRGYW1pbHkpO1xuXHRoZWxwZXJzJDEuZWFjaChtb2RlbC5iZWZvcmVCb2R5LmNvbmNhdChtb2RlbC5hZnRlckJvZHkpLCBtYXhMaW5lV2lkdGgpO1xuXG5cdC8vIEJvZHkgbGluZXMgbWF5IGluY2x1ZGUgc29tZSBleHRyYSB3aWR0aCBkdWUgdG8gdGhlIGNvbG9yIGJveFxuXHR3aWR0aFBhZGRpbmcgPSBtb2RlbC5kaXNwbGF5Q29sb3JzID8gKGJvZHlGb250U2l6ZSArIDIpIDogMDtcblx0aGVscGVycyQxLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0pIHtcblx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5iZWZvcmUsIG1heExpbmVXaWR0aCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG5cdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG5cdH0pO1xuXG5cdC8vIFJlc2V0IGJhY2sgdG8gMFxuXHR3aWR0aFBhZGRpbmcgPSAwO1xuXG5cdC8vIEZvb3RlciB3aWR0aFxuXHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGZvb3RlckZvbnRTaXplLCBtb2RlbC5fZm9vdGVyRm9udFN0eWxlLCBtb2RlbC5fZm9vdGVyRm9udEZhbWlseSk7XG5cdGhlbHBlcnMkMS5lYWNoKG1vZGVsLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcblxuXHQvLyBBZGQgcGFkZGluZ1xuXHR3aWR0aCArPSAyICogbW9kZWwueFBhZGRpbmc7XG5cblx0cmV0dXJuIHtcblx0XHR3aWR0aDogd2lkdGgsXG5cdFx0aGVpZ2h0OiBoZWlnaHRcblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBhbGlnbm1lbnQgb2YgYSB0b29sdGlwIGdpdmVuIHRoZSBzaXplXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudCh0b29sdGlwLCBzaXplKSB7XG5cdHZhciBtb2RlbCA9IHRvb2x0aXAuX21vZGVsO1xuXHR2YXIgY2hhcnQgPSB0b29sdGlwLl9jaGFydDtcblx0dmFyIGNoYXJ0QXJlYSA9IHRvb2x0aXAuX2NoYXJ0LmNoYXJ0QXJlYTtcblx0dmFyIHhBbGlnbiA9ICdjZW50ZXInO1xuXHR2YXIgeUFsaWduID0gJ2NlbnRlcic7XG5cblx0aWYgKG1vZGVsLnkgPCBzaXplLmhlaWdodCkge1xuXHRcdHlBbGlnbiA9ICd0b3AnO1xuXHR9IGVsc2UgaWYgKG1vZGVsLnkgPiAoY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpKSB7XG5cdFx0eUFsaWduID0gJ2JvdHRvbSc7XG5cdH1cblxuXHR2YXIgbGYsIHJmOyAvLyBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIGxlZnQsIHJpZ2h0IGFsaWdubWVudFxuXHR2YXIgb2xmLCBvcmY7IC8vIGZ1bmN0aW9ucyB0byBkZXRlcm1pbmUgaWYgbGVmdC9yaWdodCBhbGlnbm1lbnQgY2F1c2VzIHRvb2x0aXAgdG8gZ28gb3V0c2lkZSBjaGFydFxuXHR2YXIgeWY7IC8vIGZ1bmN0aW9uIHRvIGdldCB0aGUgeSBhbGlnbm1lbnQgaWYgdGhlIHRvb2x0aXAgZ29lcyBvdXRzaWRlIG9mIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2VzXG5cdHZhciBtaWRYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG5cdHZhciBtaWRZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG5cblx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcblx0XHRsZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4IDw9IG1pZFg7XG5cdFx0fTtcblx0XHRyZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRcdHJldHVybiB4ID4gbWlkWDtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGxmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPD0gKHNpemUud2lkdGggLyAyKTtcblx0XHR9O1xuXHRcdHJmID0gZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIHggPj0gKGNoYXJ0LndpZHRoIC0gKHNpemUud2lkdGggLyAyKSk7XG5cdFx0fTtcblx0fVxuXG5cdG9sZiA9IGZ1bmN0aW9uKHgpIHtcblx0XHRyZXR1cm4geCArIHNpemUud2lkdGggKyBtb2RlbC5jYXJldFNpemUgKyBtb2RlbC5jYXJldFBhZGRpbmcgPiBjaGFydC53aWR0aDtcblx0fTtcblx0b3JmID0gZnVuY3Rpb24oeCkge1xuXHRcdHJldHVybiB4IC0gc2l6ZS53aWR0aCAtIG1vZGVsLmNhcmV0U2l6ZSAtIG1vZGVsLmNhcmV0UGFkZGluZyA8IDA7XG5cdH07XG5cdHlmID0gZnVuY3Rpb24oeSkge1xuXHRcdHJldHVybiB5IDw9IG1pZFkgPyAndG9wJyA6ICdib3R0b20nO1xuXHR9O1xuXG5cdGlmIChsZihtb2RlbC54KSkge1xuXHRcdHhBbGlnbiA9ICdsZWZ0JztcblxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3ZlciB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgY2hhcnQuP1xuXHRcdGlmIChvbGYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKHJmKG1vZGVsLngpKSB7XG5cdFx0eEFsaWduID0gJ3JpZ2h0JztcblxuXHRcdC8vIElzIHRvb2x0aXAgdG9vIHdpZGUgYW5kIGdvZXMgb3V0c2lkZSBsZWZ0IGVkZ2Ugb2YgY2FudmFzP1xuXHRcdGlmIChvcmYobW9kZWwueCkpIHtcblx0XHRcdHhBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0eUFsaWduID0geWYobW9kZWwueSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIG9wdHMgPSB0b29sdGlwLl9vcHRpb25zO1xuXHRyZXR1cm4ge1xuXHRcdHhBbGlnbjogb3B0cy54QWxpZ24gPyBvcHRzLnhBbGlnbiA6IHhBbGlnbixcblx0XHR5QWxpZ246IG9wdHMueUFsaWduID8gb3B0cy55QWxpZ24gOiB5QWxpZ25cblx0fTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuICovXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQodm0sIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcblx0Ly8gQmFja2dyb3VuZCBQb3NpdGlvblxuXHR2YXIgeCA9IHZtLng7XG5cdHZhciB5ID0gdm0ueTtcblxuXHR2YXIgY2FyZXRTaXplID0gdm0uY2FyZXRTaXplO1xuXHR2YXIgY2FyZXRQYWRkaW5nID0gdm0uY2FyZXRQYWRkaW5nO1xuXHR2YXIgY29ybmVyUmFkaXVzID0gdm0uY29ybmVyUmFkaXVzO1xuXHR2YXIgeEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcblx0dmFyIHlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdHZhciBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcblx0dmFyIHJhZGl1c0FuZFBhZGRpbmcgPSBjb3JuZXJSYWRpdXMgKyBjYXJldFBhZGRpbmc7XG5cblx0aWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdHggLT0gc2l6ZS53aWR0aDtcblx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0eCAtPSAoc2l6ZS53aWR0aCAvIDIpO1xuXHRcdGlmICh4ICsgc2l6ZS53aWR0aCA+IGNoYXJ0LndpZHRoKSB7XG5cdFx0XHR4ID0gY2hhcnQud2lkdGggLSBzaXplLndpZHRoO1xuXHRcdH1cblx0XHRpZiAoeCA8IDApIHtcblx0XHRcdHggPSAwO1xuXHRcdH1cblx0fVxuXG5cdGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG5cdFx0eSArPSBwYWRkaW5nQW5kU2l6ZTtcblx0fSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG5cdFx0eSAtPSBzaXplLmhlaWdodCArIHBhZGRpbmdBbmRTaXplO1xuXHR9IGVsc2Uge1xuXHRcdHkgLT0gKHNpemUuaGVpZ2h0IC8gMik7XG5cdH1cblxuXHRpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuXHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0eCArPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0eCAtPSBwYWRkaW5nQW5kU2l6ZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHR4IC09IHJhZGl1c0FuZFBhZGRpbmc7XG5cdH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG5cdFx0eCArPSByYWRpdXNBbmRQYWRkaW5nO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR4OiB4LFxuXHRcdHk6IHlcblx0fTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodm0sIGFsaWduKSB7XG5cdHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcblx0XHQ/IHZtLnggKyB2bS53aWR0aCAvIDJcblx0XHQ6IGFsaWduID09PSAncmlnaHQnXG5cdFx0XHQ/IHZtLnggKyB2bS53aWR0aCAtIHZtLnhQYWRkaW5nXG5cdFx0XHQ6IHZtLnggKyB2bS54UGFkZGluZztcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gYnVpbGQgYmVmb3JlIGFuZCBhZnRlciBib2R5IGxpbmVzXG4gKi9cbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG5cdHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cblxudmFyIGV4cG9ydHMkMyA9IGNvcmVfZWxlbWVudC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9tb2RlbCA9IGdldEJhc2VNb2RlbCh0aGlzLl9vcHRpb25zKTtcblx0XHR0aGlzLl9sYXN0QWN0aXZlID0gW107XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSB0aXRsZVxuXHQvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtLCBkYXRhKVxuXHRnZXRUaXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLl9vcHRpb25zO1xuXHRcdHZhciBjYWxsYmFja3MgPSBvcHRzLmNhbGxiYWNrcztcblxuXHRcdHZhciBiZWZvcmVUaXRsZSA9IGNhbGxiYWNrcy5iZWZvcmVUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblx0XHR2YXIgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGFmdGVyVGl0bGUgPSBjYWxsYmFja3MuYWZ0ZXJUaXRsZS5hcHBseShtZSwgYXJndW1lbnRzKTtcblxuXHRcdHZhciBsaW5lcyA9IFtdO1xuXHRcdGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcblx0XHRsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG5cblx0XHRyZXR1cm4gbGluZXM7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0QmVmb3JlQm9keTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKHRoaXMuX29wdGlvbnMuY2FsbGJhY2tzLmJlZm9yZUJvZHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0Qm9keTogZnVuY3Rpb24odG9vbHRpcEl0ZW1zLCBkYXRhKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXHRcdHZhciBib2R5SXRlbXMgPSBbXTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHRvb2x0aXBJdGVtcywgZnVuY3Rpb24odG9vbHRpcEl0ZW0pIHtcblx0XHRcdHZhciBib2R5SXRlbSA9IHtcblx0XHRcdFx0YmVmb3JlOiBbXSxcblx0XHRcdFx0bGluZXM6IFtdLFxuXHRcdFx0XHRhZnRlcjogW11cblx0XHRcdH07XG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrcy5iZWZvcmVMYWJlbC5jYWxsKG1lLCB0b29sdGlwSXRlbSwgZGF0YSkpKTtcblx0XHRcdHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgY2FsbGJhY2tzLmxhYmVsLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBkYXRhKSk7XG5cdFx0XHRwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoY2FsbGJhY2tzLmFmdGVyTGFiZWwuY2FsbChtZSwgdG9vbHRpcEl0ZW0sIGRhdGEpKSk7XG5cblx0XHRcdGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBib2R5SXRlbXM7XG5cdH0sXG5cblx0Ly8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcblx0Z2V0QWZ0ZXJCb2R5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXModGhpcy5fb3B0aW9ucy5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG5cdC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG5cdGdldEZvb3RlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FsbGJhY2tzID0gbWUuX29wdGlvbnMuY2FsbGJhY2tzO1xuXG5cdFx0dmFyIGJlZm9yZUZvb3RlciA9IGNhbGxiYWNrcy5iZWZvcmVGb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkobWUsIGFyZ3VtZW50cyk7XG5cdFx0dmFyIGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXG5cdFx0dmFyIGxpbmVzID0gW107XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG5cdFx0bGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcblxuXHRcdHJldHVybiBsaW5lcztcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKGNoYW5nZWQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUuX29wdGlvbnM7XG5cblx0XHQvLyBOZWVkIHRvIHJlZ2VuZXJhdGUgdGhlIG1vZGVsIGJlY2F1c2UgaXRzIGZhc3RlciB0aGFuIHVzaW5nIGV4dGVuZCBhbmQgaXQgaXMgbmVjZXNzYXJ5IGR1ZSB0byB0aGUgb3B0aW1pemF0aW9uIGluIENoYXJ0LkVsZW1lbnQudHJhbnNpdGlvblxuXHRcdC8vIHRoYXQgZG9lcyBfdmlldyA9IF9tb2RlbCBpZiBlYXNlID09PSAxLiBUaGlzIGNhdXNlcyB0aGUgMm5kIHRvb2x0aXAgdXBkYXRlIHRvIHNldCBwcm9wZXJ0aWVzIGluIGJvdGggdGhlIHZpZXcgYW5kIG1vZGVsIGF0IHRoZSBzYW1lIHRpbWVcblx0XHQvLyB3aGljaCBicmVha3MgYW55IGFuaW1hdGlvbnMuXG5cdFx0dmFyIGV4aXN0aW5nTW9kZWwgPSBtZS5fbW9kZWw7XG5cdFx0dmFyIG1vZGVsID0gbWUuX21vZGVsID0gZ2V0QmFzZU1vZGVsKG9wdHMpO1xuXHRcdHZhciBhY3RpdmUgPSBtZS5fYWN0aXZlO1xuXG5cdFx0dmFyIGRhdGEgPSBtZS5fZGF0YTtcblxuXHRcdC8vIEluIHRoZSBjYXNlIHdoZXJlIGFjdGl2ZS5sZW5ndGggPT09IDAgd2UgbmVlZCB0byBrZWVwIHRoZXNlIGF0IGV4aXN0aW5nIHZhbHVlcyBmb3IgZ29vZCBhbmltYXRpb25zXG5cdFx0dmFyIGFsaWdubWVudCA9IHtcblx0XHRcdHhBbGlnbjogZXhpc3RpbmdNb2RlbC54QWxpZ24sXG5cdFx0XHR5QWxpZ246IGV4aXN0aW5nTW9kZWwueUFsaWduXG5cdFx0fTtcblx0XHR2YXIgYmFja2dyb3VuZFBvaW50ID0ge1xuXHRcdFx0eDogZXhpc3RpbmdNb2RlbC54LFxuXHRcdFx0eTogZXhpc3RpbmdNb2RlbC55XG5cdFx0fTtcblx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHR3aWR0aDogZXhpc3RpbmdNb2RlbC53aWR0aCxcblx0XHRcdGhlaWdodDogZXhpc3RpbmdNb2RlbC5oZWlnaHRcblx0XHR9O1xuXHRcdHZhciB0b29sdGlwUG9zaXRpb24gPSB7XG5cdFx0XHR4OiBleGlzdGluZ01vZGVsLmNhcmV0WCxcblx0XHRcdHk6IGV4aXN0aW5nTW9kZWwuY2FyZXRZXG5cdFx0fTtcblxuXHRcdHZhciBpLCBsZW47XG5cblx0XHRpZiAoYWN0aXZlLmxlbmd0aCkge1xuXHRcdFx0bW9kZWwub3BhY2l0eSA9IDE7XG5cblx0XHRcdHZhciBsYWJlbENvbG9ycyA9IFtdO1xuXHRcdFx0dmFyIGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuXHRcdFx0dG9vbHRpcFBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0cy5wb3NpdGlvbl0uY2FsbChtZSwgYWN0aXZlLCBtZS5fZXZlbnRQb3NpdGlvbik7XG5cblx0XHRcdHZhciB0b29sdGlwSXRlbXMgPSBbXTtcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHR0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbShhY3RpdmVbaV0pKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBmaWx0ZXIgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdGlmIChvcHRzLmZpbHRlcikge1xuXHRcdFx0XHR0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0cy5maWx0ZXIoYSwgZGF0YSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcblx0XHRcdGlmIChvcHRzLml0ZW1Tb3J0KSB7XG5cdFx0XHRcdHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0cy5pdGVtU29ydChhLCBiLCBkYXRhKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG5cdFx0XHRoZWxwZXJzJDEuZWFjaCh0b29sdGlwSXRlbXMsIGZ1bmN0aW9uKHRvb2x0aXBJdGVtKSB7XG5cdFx0XHRcdGxhYmVsQ29sb3JzLnB1c2gob3B0cy5jYWxsYmFja3MubGFiZWxDb2xvci5jYWxsKG1lLCB0b29sdGlwSXRlbSwgbWUuX2NoYXJ0KSk7XG5cdFx0XHRcdGxhYmVsVGV4dENvbG9ycy5wdXNoKG9wdHMuY2FsbGJhY2tzLmxhYmVsVGV4dENvbG9yLmNhbGwobWUsIHRvb2x0aXBJdGVtLCBtZS5fY2hhcnQpKTtcblx0XHRcdH0pO1xuXG5cblx0XHRcdC8vIEJ1aWxkIHRoZSBUZXh0IExpbmVzXG5cdFx0XHRtb2RlbC50aXRsZSA9IG1lLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cdFx0XHRtb2RlbC5iZWZvcmVCb2R5ID0gbWUuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuYm9keSA9IG1lLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBkYXRhKTtcblx0XHRcdG1vZGVsLmFmdGVyQm9keSA9IG1lLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIGRhdGEpO1xuXHRcdFx0bW9kZWwuZm9vdGVyID0gbWUuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgZGF0YSk7XG5cblx0XHRcdC8vIEluaXRpYWwgcG9zaXRpb25pbmcgYW5kIGNvbG9yc1xuXHRcdFx0bW9kZWwueCA9IHRvb2x0aXBQb3NpdGlvbi54O1xuXHRcdFx0bW9kZWwueSA9IHRvb2x0aXBQb3NpdGlvbi55O1xuXHRcdFx0bW9kZWwuY2FyZXRQYWRkaW5nID0gb3B0cy5jYXJldFBhZGRpbmc7XG5cdFx0XHRtb2RlbC5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuXHRcdFx0bW9kZWwubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuXG5cdFx0XHQvLyBkYXRhIHBvaW50c1xuXHRcdFx0bW9kZWwuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcblxuXHRcdFx0Ly8gV2UgbmVlZCB0byBkZXRlcm1pbmUgYWxpZ25tZW50IG9mIHRoZSB0b29sdGlwXG5cdFx0XHR0b29sdGlwU2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG1vZGVsKTtcblx0XHRcdGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLCB0b29sdGlwU2l6ZSk7XG5cdFx0XHQvLyBGaW5hbCBTaXplIGFuZCBQb3NpdGlvblxuXHRcdFx0YmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG1vZGVsLCB0b29sdGlwU2l6ZSwgYWxpZ25tZW50LCBtZS5fY2hhcnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb2RlbC5vcGFjaXR5ID0gMDtcblx0XHR9XG5cblx0XHRtb2RlbC54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuXHRcdG1vZGVsLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cdFx0bW9kZWwueCA9IGJhY2tncm91bmRQb2ludC54O1xuXHRcdG1vZGVsLnkgPSBiYWNrZ3JvdW5kUG9pbnQueTtcblx0XHRtb2RlbC53aWR0aCA9IHRvb2x0aXBTaXplLndpZHRoO1xuXHRcdG1vZGVsLmhlaWdodCA9IHRvb2x0aXBTaXplLmhlaWdodDtcblxuXHRcdC8vIFBvaW50IHdoZXJlIHRoZSBjYXJldCBvbiB0aGUgdG9vbHRpcCBwb2ludHMgdG9cblx0XHRtb2RlbC5jYXJldFggPSB0b29sdGlwUG9zaXRpb24ueDtcblx0XHRtb2RlbC5jYXJldFkgPSB0b29sdGlwUG9zaXRpb24ueTtcblxuXHRcdG1lLl9tb2RlbCA9IG1vZGVsO1xuXG5cdFx0aWYgKGNoYW5nZWQgJiYgb3B0cy5jdXN0b20pIHtcblx0XHRcdG9wdHMuY3VzdG9tLmNhbGwobWUsIG1vZGVsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0ZHJhd0NhcmV0OiBmdW5jdGlvbih0b29sdGlwUG9pbnQsIHNpemUpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY2hhcnQuY3R4O1xuXHRcdHZhciB2bSA9IHRoaXMuX3ZpZXc7XG5cdFx0dmFyIGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSk7XG5cblx0XHRjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuXHRcdGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG5cdFx0Y3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcblx0fSxcblx0Z2V0Q2FyZXRQb3NpdGlvbjogZnVuY3Rpb24odG9vbHRpcFBvaW50LCBzaXplLCB2bSkge1xuXHRcdHZhciB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuXHRcdHZhciBjYXJldFNpemUgPSB2bS5jYXJldFNpemU7XG5cdFx0dmFyIGNvcm5lclJhZGl1cyA9IHZtLmNvcm5lclJhZGl1cztcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xuXHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0dmFyIHB0WCA9IHRvb2x0aXBQb2ludC54O1xuXHRcdHZhciBwdFkgPSB0b29sdGlwUG9pbnQueTtcblx0XHR2YXIgd2lkdGggPSBzaXplLndpZHRoO1xuXHRcdHZhciBoZWlnaHQgPSBzaXplLmhlaWdodDtcblxuXHRcdGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG5cdFx0XHR5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcblxuXHRcdFx0aWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdHgxID0gcHRYO1xuXHRcdFx0XHR4MiA9IHgxIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdHkxID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR4MSA9IHB0WCArIHdpZHRoO1xuXHRcdFx0XHR4MiA9IHgxICsgY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgxO1xuXG5cdFx0XHRcdHkxID0geTIgLSBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTIgKyBjYXJldFNpemU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuXHRcdFx0XHR4MiA9IHB0WCArIGNvcm5lclJhZGl1cyArIChjYXJldFNpemUpO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdFx0eDIgPSBwdFggKyB3aWR0aCAtIGNvcm5lclJhZGl1cyAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDEgPSB4MiAtIGNhcmV0U2l6ZTtcblx0XHRcdFx0eDMgPSB4MiArIGNhcmV0U2l6ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHgyID0gdm0uY2FyZXRYO1xuXHRcdFx0XHR4MSA9IHgyIC0gY2FyZXRTaXplO1xuXHRcdFx0XHR4MyA9IHgyICsgY2FyZXRTaXplO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0eTEgPSBwdFk7XG5cdFx0XHRcdHkyID0geTEgLSBjYXJldFNpemU7XG5cdFx0XHRcdHkzID0geTE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR5MSA9IHB0WSArIGhlaWdodDtcblx0XHRcdFx0eTIgPSB5MSArIGNhcmV0U2l6ZTtcblx0XHRcdFx0eTMgPSB5MTtcblx0XHRcdFx0Ly8gaW52ZXJ0IGRyYXdpbmcgb3JkZXJcblx0XHRcdFx0dmFyIHRtcCA9IHgzO1xuXHRcdFx0XHR4MyA9IHgxO1xuXHRcdFx0XHR4MSA9IHRtcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHt4MTogeDEsIHgyOiB4MiwgeDM6IHgzLCB5MTogeTEsIHkyOiB5MiwgeTM6IHkzfTtcblx0fSxcblxuXHRkcmF3VGl0bGU6IGZ1bmN0aW9uKHB0LCB2bSwgY3R4KSB7XG5cdFx0dmFyIHRpdGxlID0gdm0udGl0bGU7XG5cblx0XHRpZiAodGl0bGUubGVuZ3RoKSB7XG5cdFx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIHZtLl90aXRsZUFsaWduKTtcblxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IHZtLl90aXRsZUFsaWduO1xuXHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0XHR2YXIgdGl0bGVGb250U2l6ZSA9IHZtLnRpdGxlRm9udFNpemU7XG5cdFx0XHR2YXIgdGl0bGVTcGFjaW5nID0gdm0udGl0bGVTcGFjaW5nO1xuXG5cdFx0XHRjdHguZmlsbFN0eWxlID0gdm0udGl0bGVGb250Q29sb3I7XG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHRpdGxlRm9udFNpemUsIHZtLl90aXRsZUZvbnRTdHlsZSwgdm0uX3RpdGxlRm9udEZhbWlseSk7XG5cblx0XHRcdHZhciBpLCBsZW47XG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aXRsZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQodGl0bGVbaV0sIHB0LngsIHB0LnkpO1xuXHRcdFx0XHRwdC55ICs9IHRpdGxlRm9udFNpemUgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cblx0XHRcdFx0aWYgKGkgKyAxID09PSB0aXRsZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRwdC55ICs9IHZtLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nOyAvLyBJZiBMYXN0LCBhZGQgbWFyZ2luLCByZW1vdmUgc3BhY2luZ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXdCb2R5OiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xuXHRcdHZhciBib2R5Rm9udFNpemUgPSB2bS5ib2R5Rm9udFNpemU7XG5cdFx0dmFyIGJvZHlTcGFjaW5nID0gdm0uYm9keVNwYWNpbmc7XG5cdFx0dmFyIGJvZHlBbGlnbiA9IHZtLl9ib2R5QWxpZ247XG5cdFx0dmFyIGJvZHkgPSB2bS5ib2R5O1xuXHRcdHZhciBkcmF3Q29sb3JCb3hlcyA9IHZtLmRpc3BsYXlDb2xvcnM7XG5cdFx0dmFyIGxhYmVsQ29sb3JzID0gdm0ubGFiZWxDb2xvcnM7XG5cdFx0dmFyIHhMaW5lUGFkZGluZyA9IDA7XG5cdFx0dmFyIGNvbG9yWCA9IGRyYXdDb2xvckJveGVzID8gZ2V0QWxpZ25lZFgodm0sICdsZWZ0JykgOiAwO1xuXHRcdHZhciB0ZXh0Q29sb3I7XG5cblx0XHRjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuXHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcblx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKGJvZHlGb250U2l6ZSwgdm0uX2JvZHlGb250U3R5bGUsIHZtLl9ib2R5Rm9udEZhbWlseSk7XG5cblx0XHRwdC54ID0gZ2V0QWxpZ25lZFgodm0sIGJvZHlBbGlnbik7XG5cblx0XHQvLyBCZWZvcmUgQm9keVxuXHRcdHZhciBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCBwdC54ICsgeExpbmVQYWRkaW5nLCBwdC55KTtcblx0XHRcdHB0LnkgKz0gYm9keUZvbnRTaXplICsgYm9keVNwYWNpbmc7XG5cdFx0fTtcblxuXHRcdC8vIEJlZm9yZSBib2R5IGxpbmVzXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IHZtLmJvZHlGb250Q29sb3I7XG5cdFx0aGVscGVycyQxLmVhY2godm0uYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG5cdFx0eExpbmVQYWRkaW5nID0gZHJhd0NvbG9yQm94ZXMgJiYgYm9keUFsaWduICE9PSAncmlnaHQnXG5cdFx0XHQ/IGJvZHlBbGlnbiA9PT0gJ2NlbnRlcicgPyAoYm9keUZvbnRTaXplIC8gMiArIDEpIDogKGJvZHlGb250U2l6ZSArIDIpXG5cdFx0XHQ6IDA7XG5cblx0XHQvLyBEcmF3IGJvZHkgbGluZXMgbm93XG5cdFx0aGVscGVycyQxLmVhY2goYm9keSwgZnVuY3Rpb24oYm9keUl0ZW0sIGkpIHtcblx0XHRcdHRleHRDb2xvciA9IHZtLmxhYmVsVGV4dENvbG9yc1tpXTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2goYm9keUl0ZW0ubGluZXMsIGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRcdFx0Ly8gRHJhdyBMZWdlbmQtbGlrZSBib3hlcyBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKGRyYXdDb2xvckJveGVzKSB7XG5cdFx0XHRcdFx0Ly8gRmlsbCBhIHdoaXRlIHJlY3Qgc28gdGhhdCBjb2xvdXJzIG1lcmdlIG5pY2VseSBpZiB0aGUgb3BhY2l0eSBpcyA8IDFcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gdm0ubGVnZW5kQ29sb3JCYWNrZ3JvdW5kO1xuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChjb2xvclgsIHB0LnksIGJvZHlGb250U2l6ZSwgYm9keUZvbnRTaXplKTtcblxuXHRcdFx0XHRcdC8vIEJvcmRlclxuXHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSAxO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzW2ldLmJvcmRlckNvbG9yO1xuXHRcdFx0XHRcdGN0eC5zdHJva2VSZWN0KGNvbG9yWCwgcHQueSwgYm9keUZvbnRTaXplLCBib2R5Rm9udFNpemUpO1xuXG5cdFx0XHRcdFx0Ly8gSW5uZXIgc3F1YXJlXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzW2ldLmJhY2tncm91bmRDb2xvcjtcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoY29sb3JYICsgMSwgcHQueSArIDEsIGJvZHlGb250U2l6ZSAtIDIsIGJvZHlGb250U2l6ZSAtIDIpO1xuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmaWxsTGluZU9mVGV4dChsaW5lKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVzZXQgYmFjayB0byAwIGZvciBhZnRlciBib2R5XG5cdFx0eExpbmVQYWRkaW5nID0gMDtcblxuXHRcdC8vIEFmdGVyIGJvZHkgbGluZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh2bS5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblx0XHRwdC55IC09IGJvZHlTcGFjaW5nOyAvLyBSZW1vdmUgbGFzdCBib2R5IHNwYWNpbmdcblx0fSxcblxuXHRkcmF3Rm9vdGVyOiBmdW5jdGlvbihwdCwgdm0sIGN0eCkge1xuXHRcdHZhciBmb290ZXIgPSB2bS5mb290ZXI7XG5cblx0XHRpZiAoZm9vdGVyLmxlbmd0aCkge1xuXHRcdFx0cHQueCA9IGdldEFsaWduZWRYKHZtLCB2bS5fZm9vdGVyQWxpZ24pO1xuXHRcdFx0cHQueSArPSB2bS5mb290ZXJNYXJnaW5Ub3A7XG5cblx0XHRcdGN0eC50ZXh0QWxpZ24gPSB2bS5fZm9vdGVyQWxpZ247XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG5cblx0XHRcdGN0eC5maWxsU3R5bGUgPSB2bS5mb290ZXJGb250Q29sb3I7XG5cdFx0XHRjdHguZm9udCA9IGhlbHBlcnMkMS5mb250U3RyaW5nKHZtLmZvb3RlckZvbnRTaXplLCB2bS5fZm9vdGVyRm9udFN0eWxlLCB2bS5fZm9vdGVyRm9udEZhbWlseSk7XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGZvb3RlciwgZnVuY3Rpb24obGluZSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQobGluZSwgcHQueCwgcHQueSk7XG5cdFx0XHRcdHB0LnkgKz0gdm0uZm9vdGVyRm9udFNpemUgKyB2bS5mb290ZXJTcGFjaW5nO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdGRyYXdCYWNrZ3JvdW5kOiBmdW5jdGlvbihwdCwgdm0sIGN0eCwgdG9vbHRpcFNpemUpIHtcblx0XHRjdHguZmlsbFN0eWxlID0gdm0uYmFja2dyb3VuZENvbG9yO1xuXHRcdGN0eC5zdHJva2VTdHlsZSA9IHZtLmJvcmRlckNvbG9yO1xuXHRcdGN0eC5saW5lV2lkdGggPSB2bS5ib3JkZXJXaWR0aDtcblx0XHR2YXIgeEFsaWduID0gdm0ueEFsaWduO1xuXHRcdHZhciB5QWxpZ24gPSB2bS55QWxpZ247XG5cdFx0dmFyIHggPSBwdC54O1xuXHRcdHZhciB5ID0gcHQueTtcblx0XHR2YXIgd2lkdGggPSB0b29sdGlwU2l6ZS53aWR0aDtcblx0XHR2YXIgaGVpZ2h0ID0gdG9vbHRpcFNpemUuaGVpZ2h0O1xuXHRcdHZhciByYWRpdXMgPSB2bS5jb3JuZXJSYWRpdXM7XG5cblx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0Y3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcblx0XHRpZiAoeUFsaWduID09PSAndG9wJykge1xuXHRcdFx0dGhpcy5kcmF3Q2FyZXQocHQsIHRvb2x0aXBTaXplKTtcblx0XHR9XG5cdFx0Y3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuXHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcblx0XHRpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcblx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG5cdFx0aWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcblx0XHRcdHRoaXMuZHJhd0NhcmV0KHB0LCB0b29sdGlwU2l6ZSk7XG5cdFx0fVxuXHRcdGN0eC5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG5cdFx0Y3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHJhZGl1cywgeSk7XG5cdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXG5cdFx0Y3R4LmZpbGwoKTtcblxuXHRcdGlmICh2bS5ib3JkZXJXaWR0aCA+IDApIHtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NoYXJ0LmN0eDtcblx0XHR2YXIgdm0gPSB0aGlzLl92aWV3O1xuXG5cdFx0aWYgKHZtLm9wYWNpdHkgPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgdG9vbHRpcFNpemUgPSB7XG5cdFx0XHR3aWR0aDogdm0ud2lkdGgsXG5cdFx0XHRoZWlnaHQ6IHZtLmhlaWdodFxuXHRcdH07XG5cdFx0dmFyIHB0ID0ge1xuXHRcdFx0eDogdm0ueCxcblx0XHRcdHk6IHZtLnlcblx0XHR9O1xuXG5cdFx0Ly8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxuXHRcdHZhciBvcGFjaXR5ID0gTWF0aC5hYnModm0ub3BhY2l0eSA8IDFlLTMpID8gMCA6IHZtLm9wYWNpdHk7XG5cblx0XHQvLyBUcnV0aHkvZmFsc2V5IHZhbHVlIGZvciBlbXB0eSB0b29sdGlwXG5cdFx0dmFyIGhhc1Rvb2x0aXBDb250ZW50ID0gdm0udGl0bGUubGVuZ3RoIHx8IHZtLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHZtLmJvZHkubGVuZ3RoIHx8IHZtLmFmdGVyQm9keS5sZW5ndGggfHwgdm0uZm9vdGVyLmxlbmd0aDtcblxuXHRcdGlmICh0aGlzLl9vcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXG5cdFx0XHQvLyBEcmF3IEJhY2tncm91bmRcblx0XHRcdHRoaXMuZHJhd0JhY2tncm91bmQocHQsIHZtLCBjdHgsIHRvb2x0aXBTaXplKTtcblxuXHRcdFx0Ly8gRHJhdyBUaXRsZSwgQm9keSwgYW5kIEZvb3RlclxuXHRcdFx0cHQueSArPSB2bS55UGFkZGluZztcblxuXHRcdFx0Ly8gVGl0bGVzXG5cdFx0XHR0aGlzLmRyYXdUaXRsZShwdCwgdm0sIGN0eCk7XG5cblx0XHRcdC8vIEJvZHlcblx0XHRcdHRoaXMuZHJhd0JvZHkocHQsIHZtLCBjdHgpO1xuXG5cdFx0XHQvLyBGb290ZXJcblx0XHRcdHRoaXMuZHJhd0Zvb3RlcihwdCwgdm0sIGN0eCk7XG5cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdCAqL1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5fb3B0aW9ucztcblx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG5cdFx0bWUuX2xhc3RBY3RpdmUgPSBtZS5fbGFzdEFjdGl2ZSB8fCBbXTtcblxuXHRcdC8vIEZpbmQgQWN0aXZlIEVsZW1lbnRzIGZvciB0b29sdGlwc1xuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdG1lLl9hY3RpdmUgPSBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuX2FjdGl2ZSA9IG1lLl9jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgTGFzdCBBY3RpdmVzXG5cdFx0Y2hhbmdlZCA9ICFoZWxwZXJzJDEuYXJyYXlFcXVhbHMobWUuX2FjdGl2ZSwgbWUuX2xhc3RBY3RpdmUpO1xuXG5cdFx0Ly8gT25seSBoYW5kbGUgdGFyZ2V0IGV2ZW50IG9uIHRvb2x0aXAgY2hhbmdlXG5cdFx0aWYgKGNoYW5nZWQpIHtcblx0XHRcdG1lLl9sYXN0QWN0aXZlID0gbWUuX2FjdGl2ZTtcblxuXHRcdFx0aWYgKG9wdGlvbnMuZW5hYmxlZCB8fCBvcHRpb25zLmN1c3RvbSkge1xuXHRcdFx0XHRtZS5fZXZlbnRQb3NpdGlvbiA9IHtcblx0XHRcdFx0XHR4OiBlLngsXG5cdFx0XHRcdFx0eTogZS55XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0bWUudXBkYXRlKHRydWUpO1xuXHRcdFx0XHRtZS5waXZvdCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjaGFuZ2VkO1xuXHR9XG59KTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcbiAqL1xudmFyIHBvc2l0aW9uZXJzXzEgPSBwb3NpdGlvbmVycztcblxudmFyIGNvcmVfdG9vbHRpcCA9IGV4cG9ydHMkMztcbmNvcmVfdG9vbHRpcC5wb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzXzE7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ4ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG5jb3JlX2RlZmF1bHRzLl9zZXQoJ2dsb2JhbCcsIHtcblx0ZWxlbWVudHM6IHt9LFxuXHRldmVudHM6IFtcblx0XHQnbW91c2Vtb3ZlJyxcblx0XHQnbW91c2VvdXQnLFxuXHRcdCdjbGljaycsXG5cdFx0J3RvdWNoc3RhcnQnLFxuXHRcdCd0b3VjaG1vdmUnXG5cdF0sXG5cdGhvdmVyOiB7XG5cdFx0b25Ib3ZlcjogbnVsbCxcblx0XHRtb2RlOiAnbmVhcmVzdCcsXG5cdFx0aW50ZXJzZWN0OiB0cnVlLFxuXHRcdGFuaW1hdGlvbkR1cmF0aW9uOiA0MDBcblx0fSxcblx0b25DbGljazogbnVsbCxcblx0bWFpbnRhaW5Bc3BlY3RSYXRpbzogdHJ1ZSxcblx0cmVzcG9uc2l2ZTogdHJ1ZSxcblx0cmVzcG9uc2l2ZUFuaW1hdGlvbkR1cmF0aW9uOiAwXG59KTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZSB0aGUgZ2l2ZW4gY29uZmlnIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBgc2NhbGVzYCBvcHRpb25cbiAqIGJ5IGluY29ycG9yYXRpbmcgc2NhbGUgZGVmYXVsdHMgaW4gYHhBeGVzYCBhbmQgYHlBeGVzYCBhcnJheSBpdGVtcywgdGhlblxuICogcmV0dXJucyBhIGRlZXAgY29weSBvZiB0aGUgcmVzdWx0LCB0aHVzIGRvZXNuJ3QgYWx0ZXIgaW5wdXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKC8qIGNvbmZpZyBvYmplY3RzIC4uLiAqLykge1xuXHRyZXR1cm4gaGVscGVycyQxLm1lcmdlKHt9LCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIHtcblx0XHRtZXJnZXI6IGZ1bmN0aW9uKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRcdGlmIChrZXkgPT09ICd4QXhlcycgfHwga2V5ID09PSAneUF4ZXMnKSB7XG5cdFx0XHRcdHZhciBzbGVuID0gc291cmNlW2tleV0ubGVuZ3RoO1xuXHRcdFx0XHR2YXIgaSwgdHlwZSwgc2NhbGU7XG5cblx0XHRcdFx0aWYgKCF0YXJnZXRba2V5XSkge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2xlbjsgKytpKSB7XG5cdFx0XHRcdFx0c2NhbGUgPSBzb3VyY2Vba2V5XVtpXTtcblx0XHRcdFx0XHR0eXBlID0gdmFsdWVPckRlZmF1bHQkOChzY2FsZS50eXBlLCBrZXkgPT09ICd4QXhlcycgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcicpO1xuXG5cdFx0XHRcdFx0aWYgKGkgPj0gdGFyZ2V0W2tleV0ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRba2V5XS5wdXNoKHt9KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIXRhcmdldFtrZXldW2ldLnR5cGUgfHwgKHNjYWxlLnR5cGUgJiYgc2NhbGUudHlwZSAhPT0gdGFyZ2V0W2tleV1baV0udHlwZSkpIHtcblx0XHRcdFx0XHRcdC8vIG5ldy91bnR5cGVkIHNjYWxlIG9yIHR5cGUgY2hhbmdlZDogbGV0J3MgYXBwbHkgdGhlIG5ldyBkZWZhdWx0c1xuXHRcdFx0XHRcdFx0Ly8gdGhlbiBtZXJnZSBzb3VyY2Ugc2NhbGUgdG8gY29ycmVjdGx5IG92ZXJ3cml0ZSB0aGUgZGVmYXVsdHMuXG5cdFx0XHRcdFx0XHRoZWxwZXJzJDEubWVyZ2UodGFyZ2V0W2tleV1baV0sIFtjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZURlZmF1bHRzKHR5cGUpLCBzY2FsZV0pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBzY2FsZXMgdHlwZSBhcmUgdGhlIHNhbWVcblx0XHRcdFx0XHRcdGhlbHBlcnMkMS5tZXJnZSh0YXJnZXRba2V5XVtpXSwgc2NhbGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVscGVycyQxLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZSB0aGUgZ2l2ZW4gY29uZmlnIG9iamVjdHMgYXMgdGhlIHJvb3Qgb3B0aW9ucyBieSBoYW5kbGluZ1xuICogZGVmYXVsdCBzY2FsZSBvcHRpb25zIGZvciB0aGUgYHNjYWxlc2AgYW5kIGBzY2FsZWAgcHJvcGVydGllcywgdGhlbiByZXR1cm5zXG4gKiBhIGRlZXAgY29weSBvZiB0aGUgcmVzdWx0LCB0aHVzIGRvZXNuJ3QgYWx0ZXIgaW5wdXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZUNvbmZpZygvKiBjb25maWcgb2JqZWN0cyAuLi4gKi8pIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5tZXJnZSh7fSwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLCB7XG5cdFx0bWVyZ2VyOiBmdW5jdGlvbihrZXksIHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgdHZhbCA9IHRhcmdldFtrZXldIHx8IHt9O1xuXHRcdFx0dmFyIHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuXHRcdFx0aWYgKGtleSA9PT0gJ3NjYWxlcycpIHtcblx0XHRcdFx0Ly8gc2NhbGUgY29uZmlnIG1lcmdpbmcgaXMgY29tcGxleC4gQWRkIG91ciBvd24gZnVuY3Rpb24gaGVyZSBmb3IgdGhhdFxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IG1lcmdlU2NhbGVDb25maWcodHZhbCwgc3ZhbCk7XG5cdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3NjYWxlJykge1xuXHRcdFx0XHQvLyB1c2VkIGluIHBvbGFyIGFyZWEgJiByYWRhciBjaGFydHMgc2luY2UgdGhlcmUgaXMgb25seSBvbmUgc2NhbGVcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBoZWxwZXJzJDEubWVyZ2UodHZhbCwgW2NvcmVfc2NhbGVTZXJ2aWNlLmdldFNjYWxlRGVmYXVsdHMoc3ZhbC50eXBlKSwgc3ZhbF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGVscGVycyQxLl9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcblx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG5cdC8vIERvIE5PVCB1c2UgbWVyZ2VDb25maWcgZm9yIHRoZSBkYXRhIG9iamVjdCBiZWNhdXNlIHRoaXMgbWV0aG9kIG1lcmdlcyBhcnJheXNcblx0Ly8gYW5kIHNvIHdvdWxkIGNoYW5nZSByZWZlcmVuY2VzIHRvIGxhYmVscyBhbmQgZGF0YXNldHMsIHByZXZlbnRpbmcgZGF0YSB1cGRhdGVzLlxuXHR2YXIgZGF0YSA9IGNvbmZpZy5kYXRhID0gY29uZmlnLmRhdGEgfHwge307XG5cdGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuXHRkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuXG5cdGNvbmZpZy5vcHRpb25zID0gbWVyZ2VDb25maWcoXG5cdFx0Y29yZV9kZWZhdWx0cy5nbG9iYWwsXG5cdFx0Y29yZV9kZWZhdWx0c1tjb25maWcudHlwZV0sXG5cdFx0Y29uZmlnLm9wdGlvbnMgfHwge30pO1xuXG5cdHJldHVybiBjb25maWc7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbmZpZyhjaGFydCkge1xuXHR2YXIgbmV3T3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnM7XG5cblx0aGVscGVycyQxLmVhY2goY2hhcnQuc2NhbGVzLCBmdW5jdGlvbihzY2FsZSkge1xuXHRcdGNvcmVfbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHNjYWxlKTtcblx0fSk7XG5cblx0bmV3T3B0aW9ucyA9IG1lcmdlQ29uZmlnKFxuXHRcdGNvcmVfZGVmYXVsdHMuZ2xvYmFsLFxuXHRcdGNvcmVfZGVmYXVsdHNbY2hhcnQuY29uZmlnLnR5cGVdLFxuXHRcdG5ld09wdGlvbnMpO1xuXG5cdGNoYXJ0Lm9wdGlvbnMgPSBjaGFydC5jb25maWcub3B0aW9ucyA9IG5ld09wdGlvbnM7XG5cdGNoYXJ0LmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcblx0Y2hhcnQuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuXG5cdC8vIFRvb2x0aXBcblx0Y2hhcnQudG9vbHRpcC5fb3B0aW9ucyA9IG5ld09wdGlvbnMudG9vbHRpcHM7XG5cdGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbikge1xuXHRyZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJztcbn1cblxudmFyIENoYXJ0ID0gZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdHRoaXMuY29uc3RydWN0KGl0ZW0sIGNvbmZpZyk7XG5cdHJldHVybiB0aGlzO1xufTtcblxuaGVscGVycyQxLmV4dGVuZChDaGFydC5wcm90b3R5cGUsIC8qKiBAbGVuZHMgQ2hhcnQgKi8ge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGNvbnN0cnVjdDogZnVuY3Rpb24oaXRlbSwgY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGNvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcblxuXHRcdHZhciBjb250ZXh0ID0gcGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaXRlbSwgY29uZmlnKTtcblx0XHR2YXIgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcblx0XHR2YXIgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG5cdFx0dmFyIHdpZHRoID0gY2FudmFzICYmIGNhbnZhcy53aWR0aDtcblxuXHRcdG1lLmlkID0gaGVscGVycyQxLnVpZCgpO1xuXHRcdG1lLmN0eCA9IGNvbnRleHQ7XG5cdFx0bWUuY2FudmFzID0gY2FudmFzO1xuXHRcdG1lLmNvbmZpZyA9IGNvbmZpZztcblx0XHRtZS53aWR0aCA9IHdpZHRoO1xuXHRcdG1lLmhlaWdodCA9IGhlaWdodDtcblx0XHRtZS5hc3BlY3RSYXRpbyA9IGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcblx0XHRtZS5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cblx0XHQvKipcblx0XHQgKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgQ2hhcnQgYW5kIENoYXJ0LkNvbnRyb2xsZXIgaGF2ZSBiZWVuIG1lcmdlZCxcblx0XHQgKiB0aGUgXCJpbnN0YW5jZVwiIHN0aWxsIG5lZWQgdG8gYmUgZGVmaW5lZCBzaW5jZSBpdCBtaWdodCBiZSBjYWxsZWQgZnJvbSBwbHVnaW5zLlxuXHRcdCAqIEBwcm9wIENoYXJ0I2NoYXJ0XG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjYuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdG1lLmNoYXJ0ID0gbWU7XG5cdFx0bWUuY29udHJvbGxlciA9IG1lOyAvLyBjaGFydC5jaGFydC5jb250cm9sbGVyICNpbmNlcHRpb25cblxuXHRcdC8vIEFkZCB0aGUgY2hhcnQgaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2Vcblx0XHRDaGFydC5pbnN0YW5jZXNbbWUuaWRdID0gbWU7XG5cblx0XHQvLyBEZWZpbmUgYWxpYXMgdG8gdGhlIGNvbmZpZyBkYXRhOiBgY2hhcnQuZGF0YSA9PT0gY2hhcnQuY29uZmlnLmRhdGFgXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1lLCAnZGF0YScsIHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtZS5jb25maWcuZGF0YTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdG1lLmNvbmZpZy5kYXRhID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuXHRcdFx0Ly8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXG5cdFx0XHQvLyB0aGUgY2hhcnQgaW5pdGlhbGl6YXRpb24gYnV0IGFmdGVyIHNldHRpbmcgYmFzaWMgY2hhcnQgLyBjb250cm9sbGVyIHByb3BlcnRpZXMgdGhhdFxuXHRcdFx0Ly8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRtZS5pbml0aWFsaXplKCk7XG5cdFx0bWUudXBkYXRlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gQmVmb3JlIGluaXQgcGx1Z2luIG5vdGlmaWNhdGlvblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVJbml0Jyk7XG5cblx0XHRoZWxwZXJzJDEucmV0aW5hU2NhbGUobWUsIG1lLm9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyk7XG5cblx0XHRtZS5iaW5kRXZlbnRzKCk7XG5cblx0XHRpZiAobWUub3B0aW9ucy5yZXNwb25zaXZlKSB7XG5cdFx0XHQvLyBJbml0aWFsIHJlc2l6ZSBiZWZvcmUgY2hhcnQgZHJhd3MgKG11c3QgYmUgc2lsZW50IHRvIHByZXNlcnZlIGluaXRpYWwgYW5pbWF0aW9ucykuXG5cdFx0XHRtZS5yZXNpemUodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHNjYWxlcyBoYXZlIElEcyBhbmQgYXJlIGJ1aWx0IGJlZm9yZSB3ZSBidWlsZCBhbnkgY29udHJvbGxlcnMuXG5cdFx0bWUuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuXHRcdG1lLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcblx0XHRtZS5pbml0VG9vbFRpcCgpO1xuXG5cdFx0Ly8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVySW5pdCcpO1xuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FudmFzLmNsZWFyKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdC8vIFN0b3BzIGFueSBjdXJyZW50IGFuaW1hdGlvbiBsb29wIG9jY3VycmluZ1xuXHRcdGNvcmVfYW5pbWF0aW9ucy5jYW5jZWxBbmltYXRpb24odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVzaXplOiBmdW5jdGlvbihzaWxlbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xuXHRcdHZhciBhc3BlY3RSYXRpbyA9IChvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgbWUuYXNwZWN0UmF0aW8pIHx8IG51bGw7XG5cblx0XHQvLyB0aGUgY2FudmFzIHJlbmRlciB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgYmUgY2FzdGVkIHRvIGludGVnZXJzIHNvIG1ha2Ugc3VyZSB0aGF0XG5cdFx0Ly8gdGhlIGNhbnZhcyBkaXNwbGF5IHN0eWxlIHVzZXMgdGhlIHNhbWUgaW50ZWdlciB2YWx1ZXMgdG8gYXZvaWQgYmx1cnJpbmcgZWZmZWN0LlxuXG5cdFx0Ly8gU2V0IHRvIDAgaW5zdGVhZCBvZiBjYW52YXMuc2l6ZSBiZWNhdXNlIHRoZSBzaXplIGRlZmF1bHRzIHRvIDMwMHgxNTAgaWYgdGhlIGVsZW1lbnQgaXMgY29sbGFwc2VkXG5cdFx0dmFyIG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEuZ2V0TWF4aW11bVdpZHRoKGNhbnZhcykpKTtcblx0XHR2YXIgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihhc3BlY3RSYXRpbyA/IG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8gOiBoZWxwZXJzJDEuZ2V0TWF4aW11bUhlaWdodChjYW52YXMpKSk7XG5cblx0XHRpZiAobWUud2lkdGggPT09IG5ld1dpZHRoICYmIG1lLmhlaWdodCA9PT0gbmV3SGVpZ2h0KSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2FudmFzLndpZHRoID0gbWUud2lkdGggPSBuZXdXaWR0aDtcblx0XHRjYW52YXMuaGVpZ2h0ID0gbWUuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4Jztcblx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gbmV3SGVpZ2h0ICsgJ3B4JztcblxuXHRcdGhlbHBlcnMkMS5yZXRpbmFTY2FsZShtZSwgb3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuXHRcdGlmICghc2lsZW50KSB7XG5cdFx0XHQvLyBOb3RpZnkgYW55IHBsdWdpbnMgYWJvdXQgdGhlIHJlc2l6ZVxuXHRcdFx0dmFyIG5ld1NpemUgPSB7d2lkdGg6IG5ld1dpZHRoLCBoZWlnaHQ6IG5ld0hlaWdodH07XG5cdFx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAncmVzaXplJywgW25ld1NpemVdKTtcblxuXHRcdFx0Ly8gTm90aWZ5IG9mIHJlc2l6ZVxuXHRcdFx0aWYgKG9wdGlvbnMub25SZXNpemUpIHtcblx0XHRcdFx0b3B0aW9ucy5vblJlc2l6ZShtZSwgbmV3U2l6ZSk7XG5cdFx0XHR9XG5cblx0XHRcdG1lLnN0b3AoKTtcblx0XHRcdG1lLnVwZGF0ZSh7XG5cdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLnJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvblxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdGVuc3VyZVNjYWxlc0hhdmVJRHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHRcdHZhciBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG5cdFx0dmFyIHNjYWxlT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGU7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChzY2FsZXNPcHRpb25zLnhBeGVzLCBmdW5jdGlvbih4QXhpc09wdGlvbnMsIGluZGV4KSB7XG5cdFx0XHR4QXhpc09wdGlvbnMuaWQgPSB4QXhpc09wdGlvbnMuaWQgfHwgKCd4LWF4aXMtJyArIGluZGV4KTtcblx0XHR9KTtcblxuXHRcdGhlbHBlcnMkMS5lYWNoKHNjYWxlc09wdGlvbnMueUF4ZXMsIGZ1bmN0aW9uKHlBeGlzT3B0aW9ucywgaW5kZXgpIHtcblx0XHRcdHlBeGlzT3B0aW9ucy5pZCA9IHlBeGlzT3B0aW9ucy5pZCB8fCAoJ3ktYXhpcy0nICsgaW5kZXgpO1xuXHRcdH0pO1xuXG5cdFx0aWYgKHNjYWxlT3B0aW9ucykge1xuXHRcdFx0c2NhbGVPcHRpb25zLmlkID0gc2NhbGVPcHRpb25zLmlkIHx8ICdzY2FsZSc7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBCdWlsZHMgYSBtYXAgb2Ygc2NhbGUgSUQgdG8gc2NhbGUgb2JqZWN0IGZvciBmdXR1cmUgbG9va3VwLlxuXHQgKi9cblx0YnVpbGRPclVwZGF0ZVNjYWxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHNjYWxlcyA9IG1lLnNjYWxlcyB8fCB7fTtcblx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHR2YXIgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgaWQpIHtcblx0XHRcdG9ialtpZF0gPSBmYWxzZTtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSwge30pO1xuXG5cdFx0aWYgKG9wdGlvbnMuc2NhbGVzKSB7XG5cdFx0XHRpdGVtcyA9IGl0ZW1zLmNvbmNhdChcblx0XHRcdFx0KG9wdGlvbnMuc2NhbGVzLnhBeGVzIHx8IFtdKS5tYXAoZnVuY3Rpb24oeEF4aXNPcHRpb25zKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtvcHRpb25zOiB4QXhpc09wdGlvbnMsIGR0eXBlOiAnY2F0ZWdvcnknLCBkcG9zaXRpb246ICdib3R0b20nfTtcblx0XHRcdFx0fSksXG5cdFx0XHRcdChvcHRpb25zLnNjYWxlcy55QXhlcyB8fCBbXSkubWFwKGZ1bmN0aW9uKHlBeGlzT3B0aW9ucykge1xuXHRcdFx0XHRcdHJldHVybiB7b3B0aW9uczogeUF4aXNPcHRpb25zLCBkdHlwZTogJ2xpbmVhcicsIGRwb3NpdGlvbjogJ2xlZnQnfTtcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuc2NhbGUpIHtcblx0XHRcdGl0ZW1zLnB1c2goe1xuXHRcdFx0XHRvcHRpb25zOiBvcHRpb25zLnNjYWxlLFxuXHRcdFx0XHRkdHlwZTogJ3JhZGlhbExpbmVhcicsXG5cdFx0XHRcdGlzRGVmYXVsdDogdHJ1ZSxcblx0XHRcdFx0ZHBvc2l0aW9uOiAnY2hhcnRBcmVhJ1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aGVscGVycyQxLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHZhciBzY2FsZU9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG5cdFx0XHR2YXIgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG5cdFx0XHR2YXIgc2NhbGVUeXBlID0gdmFsdWVPckRlZmF1bHQkOChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cblx0XHRcdGlmIChwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24pICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcblx0XHRcdFx0c2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZWRbaWRdID0gdHJ1ZTtcblx0XHRcdHZhciBzY2FsZSA9IG51bGw7XG5cdFx0XHRpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG5cdFx0XHRcdHNjYWxlID0gc2NhbGVzW2lkXTtcblx0XHRcdFx0c2NhbGUub3B0aW9ucyA9IHNjYWxlT3B0aW9ucztcblx0XHRcdFx0c2NhbGUuY3R4ID0gbWUuY3R4O1xuXHRcdFx0XHRzY2FsZS5jaGFydCA9IG1lO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNjYWxlQ2xhc3MgPSBjb3JlX3NjYWxlU2VydmljZS5nZXRTY2FsZUNvbnN0cnVjdG9yKHNjYWxlVHlwZSk7XG5cdFx0XHRcdGlmICghc2NhbGVDbGFzcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcblx0XHRcdFx0XHRpZDogaWQsXG5cdFx0XHRcdFx0dHlwZTogc2NhbGVUeXBlLFxuXHRcdFx0XHRcdG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcblx0XHRcdFx0XHRjdHg6IG1lLmN0eCxcblx0XHRcdFx0XHRjaGFydDogbWVcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcblx0XHRcdH1cblxuXHRcdFx0c2NhbGUubWVyZ2VUaWNrc09wdGlvbnMoKTtcblxuXHRcdFx0Ly8gVE9ETyhTQik6IEkgdGhpbmsgd2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgY3VzdG9tIGNhc2UgKG9wdGlvbnMuc2NhbGUpXG5cdFx0XHQvLyBhbmQgY29uc2lkZXIgaXQgYXMgYSByZWd1bGFyIHNjYWxlIHBhcnQgb2YgdGhlIFwic2NhbGVzXCJcIiBtYXAgb25seSEgVGhpcyB3b3VsZFxuXHRcdFx0Ly8gbWFrZSB0aGUgbG9naWMgZWFzaWVyIGFuZCByZW1vdmUgc29tZSB1c2VsZXNzPyBjdXN0b20gY29kZS5cblx0XHRcdGlmIChpdGVtLmlzRGVmYXVsdCkge1xuXHRcdFx0XHRtZS5zY2FsZSA9IHNjYWxlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdC8vIGNsZWFyIHVwIGRpc2NhcmRlZCBzY2FsZXNcblx0XHRoZWxwZXJzJDEuZWFjaCh1cGRhdGVkLCBmdW5jdGlvbihoYXNVcGRhdGVkLCBpZCkge1xuXHRcdFx0aWYgKCFoYXNVcGRhdGVkKSB7XG5cdFx0XHRcdGRlbGV0ZSBzY2FsZXNbaWRdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bWUuc2NhbGVzID0gc2NhbGVzO1xuXG5cdFx0Y29yZV9zY2FsZVNlcnZpY2UuYWRkU2NhbGVzVG9MYXlvdXQodGhpcyk7XG5cdH0sXG5cblx0YnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBuZXdDb250cm9sbGVycyA9IFtdO1xuXG5cdFx0aGVscGVycyQxLmVhY2gobWUuZGF0YS5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCwgZGF0YXNldEluZGV4KSB7XG5cdFx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHR2YXIgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBtZS5jb25maWcudHlwZTtcblxuXHRcdFx0aWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcblx0XHRcdFx0bWUuZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cdFx0XHRcdG1ldGEgPSBtZS5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0fVxuXHRcdFx0bWV0YS50eXBlID0gdHlwZTtcblxuXHRcdFx0aWYgKG1ldGEuY29udHJvbGxlcikge1xuXHRcdFx0XHRtZXRhLmNvbnRyb2xsZXIudXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0bWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBDb250cm9sbGVyQ2xhc3MgPSBjb250cm9sbGVyc1ttZXRhLnR5cGVdO1xuXHRcdFx0XHRpZiAoQ29udHJvbGxlckNsYXNzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIG1ldGEudHlwZSArICdcIiBpcyBub3QgYSBjaGFydCB0eXBlLicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyhtZSwgZGF0YXNldEluZGV4KTtcblx0XHRcdFx0bmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuXHRcdFx0fVxuXHRcdH0sIG1lKTtcblxuXHRcdHJldHVybiBuZXdDb250cm9sbGVycztcblx0fSxcblxuXHQvKipcblx0ICogUmVzZXQgdGhlIGVsZW1lbnRzIG9mIGFsbCBkYXRhc2V0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVzZXRFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdG1lLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuXHRcdH0sIG1lKTtcblx0fSxcblxuXHQvKipcblx0KiBSZXNldHMgdGhlIGNoYXJ0IGJhY2sgdG8gaXQncyBzdGF0ZSBiZWZvcmUgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG5cdCovXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlc2V0RWxlbWVudHMoKTtcblx0XHR0aGlzLnRvb2x0aXAuaW5pdGlhbGl6ZSgpO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0Y29uZmlnID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxuXHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dXBkYXRlQ29uZmlnKG1lKTtcblxuXHRcdC8vIHBsdWdpbnMgb3B0aW9ucyByZWZlcmVuY2VzIG1pZ2h0IGhhdmUgY2hhbmdlLCBsZXQncyBpbnZhbGlkYXRlIHRoZSBjYWNoZVxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcblx0XHRjb3JlX3BsdWdpbnMuX2ludmFsaWRhdGUobWUpO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVVcGRhdGUnKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJbiBjYXNlIHRoZSBlbnRpcmUgZGF0YSBvYmplY3QgY2hhbmdlZFxuXHRcdG1lLnRvb2x0aXAuX2RhdGEgPSBtZS5kYXRhO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcblx0XHR2YXIgbmV3Q29udHJvbGxlcnMgPSBtZS5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBhbGwgZGF0YXNldCBjb250cm9sbGVycyBoYXZlIGNvcnJlY3QgbWV0YSBkYXRhIGNvdW50c1xuXHRcdGhlbHBlcnMkMS5lYWNoKG1lLmRhdGEuZGF0YXNldHMsIGZ1bmN0aW9uKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkge1xuXHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cygpO1xuXHRcdH0sIG1lKTtcblxuXHRcdG1lLnVwZGF0ZUxheW91dCgpO1xuXG5cdFx0Ly8gQ2FuIG9ubHkgcmVzZXQgdGhlIG5ldyBjb250cm9sbGVycyBhZnRlciB0aGUgc2NhbGVzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0aWYgKG1lLm9wdGlvbnMuYW5pbWF0aW9uICYmIG1lLm9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uKSB7XG5cdFx0XHRoZWxwZXJzJDEuZWFjaChuZXdDb250cm9sbGVycywgZnVuY3Rpb24oY29udHJvbGxlcikge1xuXHRcdFx0XHRjb250cm9sbGVyLnJlc2V0KCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRtZS51cGRhdGVEYXRhc2V0cygpO1xuXG5cdFx0Ly8gTmVlZCB0byByZXNldCB0b29sdGlwIGluIGNhc2UgaXQgaXMgZGlzcGxheWVkIHdpdGggZWxlbWVudHMgdGhhdCBhcmUgcmVtb3ZlZFxuXHRcdC8vIGFmdGVyIHVwZGF0ZS5cblx0XHRtZS50b29sdGlwLmluaXRpYWxpemUoKTtcblxuXHRcdC8vIExhc3QgYWN0aXZlIGNvbnRhaW5zIGl0ZW1zIHRoYXQgd2VyZSBwcmV2aW91c2x5IGluIHRoZSB0b29sdGlwLlxuXHRcdC8vIFdoZW4gd2UgcmVzZXQgdGhlIHRvb2x0aXAsIHdlIG5lZWQgdG8gY2xlYXIgaXRcblx0XHRtZS5sYXN0QWN0aXZlID0gW107XG5cblx0XHQvLyBEbyB0aGlzIGJlZm9yZSByZW5kZXIgc28gdGhhdCBhbnkgcGx1Z2lucyB0aGF0IG5lZWQgZmluYWwgc2NhbGUgdXBkYXRlcyBjYW4gdXNlIGl0XG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyVXBkYXRlJyk7XG5cblx0XHRpZiAobWUuX2J1ZmZlcmVkUmVuZGVyKSB7XG5cdFx0XHRtZS5fYnVmZmVyZWRSZXF1ZXN0ID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLmR1cmF0aW9uLFxuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcsXG5cdFx0XHRcdGxhenk6IGNvbmZpZy5sYXp5XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5yZW5kZXIoY29uZmlnKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJMYXlvdXRgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlTGF5b3V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVMYXlvdXQnKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb3JlX2xheW91dHMudXBkYXRlKHRoaXMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuXHRcdC8qKlxuXHRcdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgYGFmdGVyTGF5b3V0YCBpbnN0ZWFkLlxuXHRcdCAqIEBtZXRob2QgSVBsdWdpbiNhZnRlclNjYWxlVXBkYXRlXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjUuMFxuXHRcdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqL1xuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclNjYWxlVXBkYXRlJyk7XG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyTGF5b3V0Jyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgYWxsIGRhdGFzZXRzIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVEYXRhc2V0c1VwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlRGF0YXNldHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRzVXBkYXRlJykgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGlsZW4gPSBtZS5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bWUudXBkYXRlRGF0YXNldChpKTtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJEYXRhc2V0c1VwZGF0ZScpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRVcGRhdGVgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dXBkYXRlRGF0YXNldDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtZXRhID0gbWUuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuXHRcdHZhciBhcmdzID0ge1xuXHRcdFx0bWV0YTogbWV0YSxcblx0XHRcdGluZGV4OiBpbmRleFxuXHRcdH07XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBbYXJnc10pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG1ldGEuY29udHJvbGxlci51cGRhdGUoKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRhdGFzZXRVcGRhdGUnLCBbYXJnc10pO1xuXHR9LFxuXG5cdHJlbmRlcjogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGlmICghY29uZmlnIHx8IHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XG5cdFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0Y29uZmlnID0ge1xuXHRcdFx0XHRkdXJhdGlvbjogY29uZmlnLFxuXHRcdFx0XHRsYXp5OiBhcmd1bWVudHNbMV1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dmFyIGFuaW1hdGlvbk9wdGlvbnMgPSBtZS5vcHRpb25zLmFuaW1hdGlvbjtcblx0XHR2YXIgZHVyYXRpb24gPSB2YWx1ZU9yRGVmYXVsdCQ4KGNvbmZpZy5kdXJhdGlvbiwgYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLmR1cmF0aW9uKTtcblx0XHR2YXIgbGF6eSA9IGNvbmZpZy5sYXp5O1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVSZW5kZXInKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb25Db21wbGV0ZSA9IGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuXHRcdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyUmVuZGVyJyk7XG5cdFx0XHRoZWxwZXJzJDEuY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFthbmltYXRpb25dLCBtZSk7XG5cdFx0fTtcblxuXHRcdGlmIChhbmltYXRpb25PcHRpb25zICYmIGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gbmV3IGNvcmVfYW5pbWF0aW9uKHtcblx0XHRcdFx0bnVtU3RlcHM6IGR1cmF0aW9uIC8gMTYuNjYsIC8vIDYwIGZwc1xuXHRcdFx0XHRlYXNpbmc6IGNvbmZpZy5lYXNpbmcgfHwgYW5pbWF0aW9uT3B0aW9ucy5lYXNpbmcsXG5cblx0XHRcdFx0cmVuZGVyOiBmdW5jdGlvbihjaGFydCwgYW5pbWF0aW9uT2JqZWN0KSB7XG5cdFx0XHRcdFx0dmFyIGVhc2luZ0Z1bmN0aW9uID0gaGVscGVycyQxLmVhc2luZy5lZmZlY3RzW2FuaW1hdGlvbk9iamVjdC5lYXNpbmddO1xuXHRcdFx0XHRcdHZhciBjdXJyZW50U3RlcCA9IGFuaW1hdGlvbk9iamVjdC5jdXJyZW50U3RlcDtcblx0XHRcdFx0XHR2YXIgc3RlcERlY2ltYWwgPSBjdXJyZW50U3RlcCAvIGFuaW1hdGlvbk9iamVjdC5udW1TdGVwcztcblxuXHRcdFx0XHRcdGNoYXJ0LmRyYXcoZWFzaW5nRnVuY3Rpb24oc3RlcERlY2ltYWwpLCBzdGVwRGVjaW1hbCwgY3VycmVudFN0ZXApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdG9uQW5pbWF0aW9uUHJvZ3Jlc3M6IGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcyxcblx0XHRcdFx0b25BbmltYXRpb25Db21wbGV0ZTogb25Db21wbGV0ZVxuXHRcdFx0fSk7XG5cblx0XHRcdGNvcmVfYW5pbWF0aW9ucy5hZGRBbmltYXRpb24obWUsIGFuaW1hdGlvbiwgZHVyYXRpb24sIGxhenkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5kcmF3KCk7XG5cblx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzc4MVxuXHRcdFx0b25Db21wbGV0ZShuZXcgY29yZV9hbmltYXRpb24oe251bVN0ZXBzOiAwLCBjaGFydDogbWV9KSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdG1lLmNsZWFyKCk7XG5cblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoZWFzaW5nVmFsdWUpKSB7XG5cdFx0XHRlYXNpbmdWYWx1ZSA9IDE7XG5cdFx0fVxuXG5cdFx0bWUudHJhbnNpdGlvbihlYXNpbmdWYWx1ZSk7XG5cblx0XHRpZiAobWUud2lkdGggPD0gMCB8fCBtZS5oZWlnaHQgPD0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRHJhdycsIFtlYXNpbmdWYWx1ZV0pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERyYXcgYWxsIHRoZSBzY2FsZXNcblx0XHRoZWxwZXJzJDEuZWFjaChtZS5ib3hlcywgZnVuY3Rpb24oYm94KSB7XG5cdFx0XHRib3guZHJhdyhtZS5jaGFydEFyZWEpO1xuXHRcdH0sIG1lKTtcblxuXHRcdG1lLmRyYXdEYXRhc2V0cyhlYXNpbmdWYWx1ZSk7XG5cdFx0bWUuX2RyYXdUb29sdGlwKGVhc2luZ1ZhbHVlKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlckRyYXcnLCBbZWFzaW5nVmFsdWVdKTtcblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRyYW5zaXRpb246IGZ1bmN0aW9uKGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gKG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKG1lLmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0bWUuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci50cmFuc2l0aW9uKGVhc2luZ1ZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRtZS50b29sdGlwLnRyYW5zaXRpb24oZWFzaW5nVmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3cyBhbGwgZGF0YXNldHMgdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXRzRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldHNEcmF3YC5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRyYXdEYXRhc2V0czogZnVuY3Rpb24oZWFzaW5nVmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0c0RyYXcnLCBbZWFzaW5nVmFsdWVdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEcmF3IGRhdGFzZXRzIHJldmVyc2VkIHRvIHN1cHBvcnQgcHJvcGVyIGxpbmUgc3RhY2tpbmdcblx0XHRmb3IgKHZhciBpID0gKG1lLmRhdGEuZGF0YXNldHMgfHwgW10pLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG5cdFx0XHRpZiAobWUuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRtZS5kcmF3RGF0YXNldChpLCBlYXNpbmdWYWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldHNEcmF3JywgW2Vhc2luZ1ZhbHVlXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERyYXdzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXREcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0RHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkcmF3RGF0YXNldDogZnVuY3Rpb24oaW5kZXgsIGVhc2luZ1ZhbHVlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbWV0YSA9IG1lLmdldERhdGFzZXRNZXRhKGluZGV4KTtcblx0XHR2YXIgYXJncyA9IHtcblx0XHRcdG1ldGE6IG1ldGEsXG5cdFx0XHRpbmRleDogaW5kZXgsXG5cdFx0XHRlYXNpbmdWYWx1ZTogZWFzaW5nVmFsdWVcblx0XHR9O1xuXG5cdFx0aWYgKGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdiZWZvcmVEYXRhc2V0RHJhdycsIFthcmdzXSkgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bWV0YS5jb250cm9sbGVyLmRyYXcoZWFzaW5nVmFsdWUpO1xuXG5cdFx0Y29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2FmdGVyRGF0YXNldERyYXcnLCBbYXJnc10pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEcmF3cyB0b29sdGlwIHVubGVzcyBhIHBsdWdpbiByZXR1cm5zIGBmYWxzZWAgdG8gdGhlIGBiZWZvcmVUb29sdGlwRHJhd2Bcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyVG9vbHRpcERyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RyYXdUb29sdGlwOiBmdW5jdGlvbihlYXNpbmdWYWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRvb2x0aXAgPSBtZS50b29sdGlwO1xuXHRcdHZhciBhcmdzID0ge1xuXHRcdFx0dG9vbHRpcDogdG9vbHRpcCxcblx0XHRcdGVhc2luZ1ZhbHVlOiBlYXNpbmdWYWx1ZVxuXHRcdH07XG5cblx0XHRpZiAoY29yZV9wbHVnaW5zLm5vdGlmeShtZSwgJ2JlZm9yZVRvb2x0aXBEcmF3JywgW2FyZ3NdKSA9PT0gZmFsc2UpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0b29sdGlwLmRyYXcoKTtcblxuXHRcdGNvcmVfcGx1Z2lucy5ub3RpZnkobWUsICdhZnRlclRvb2x0aXBEcmF3JywgW2FyZ3NdKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBzaW5nbGUgZWxlbWVudCB0aGF0IHdhcyBjbGlja2VkIG9uXG5cdCAqIEByZXR1cm4gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGFzZXQgaW5kZXggYW5kIGVsZW1lbnQgaW5kZXggb2YgdGhlIG1hdGNoaW5nIGVsZW1lbnQuIEFsc28gY29udGFpbnMgdGhlIHJlY3RhbmdsZSB0aGF0IHdhcyBkcmF3XG5cdCAqL1xuXHRnZXRFbGVtZW50QXRFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHJldHVybiBjb3JlX2ludGVyYWN0aW9uLm1vZGVzLnNpbmdsZSh0aGlzLCBlKTtcblx0fSxcblxuXHRnZXRFbGVtZW50c0F0RXZlbnQ6IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gY29yZV9pbnRlcmFjdGlvbi5tb2Rlcy5sYWJlbCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudHNBdFhBeGlzOiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXNbJ3gtYXhpcyddKHRoaXMsIGUsIHtpbnRlcnNlY3Q6IHRydWV9KTtcblx0fSxcblxuXHRnZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlOiBmdW5jdGlvbihlLCBtb2RlLCBvcHRpb25zKSB7XG5cdFx0dmFyIG1ldGhvZCA9IGNvcmVfaW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG5cdFx0aWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtdO1xuXHR9LFxuXG5cdGdldERhdGFzZXRBdEV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIGNvcmVfaW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldCh0aGlzLCBlLCB7aW50ZXJzZWN0OiB0cnVlfSk7XG5cdH0sXG5cblx0Z2V0RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGRhdGFzZXQgPSBtZS5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG5cdFx0aWYgKCFkYXRhc2V0Ll9tZXRhKSB7XG5cdFx0XHRkYXRhc2V0Ll9tZXRhID0ge307XG5cdFx0fVxuXG5cdFx0dmFyIG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXTtcblx0XHRpZiAoIW1ldGEpIHtcblx0XHRcdG1ldGEgPSBkYXRhc2V0Ll9tZXRhW21lLmlkXSA9IHtcblx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0ZGF0YTogW10sXG5cdFx0XHRcdGRhdGFzZXQ6IG51bGwsXG5cdFx0XHRcdGNvbnRyb2xsZXI6IG51bGwsXG5cdFx0XHRcdGhpZGRlbjogbnVsbCxcdFx0XHQvLyBTZWUgaXNEYXRhc2V0VmlzaWJsZSgpIGNvbW1lbnRcblx0XHRcdFx0eEF4aXNJRDogbnVsbCxcblx0XHRcdFx0eUF4aXNJRDogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWV0YTtcblx0fSxcblxuXHRnZXRWaXNpYmxlRGF0YXNldENvdW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY291bnQgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY291bnQ7XG5cdH0sXG5cblx0aXNEYXRhc2V0VmlzaWJsZTogZnVuY3Rpb24oZGF0YXNldEluZGV4KSB7XG5cdFx0dmFyIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG5cblx0XHQvLyBtZXRhLmhpZGRlbiBpcyBhIHBlciBjaGFydCBkYXRhc2V0IGhpZGRlbiBmbGFnIG92ZXJyaWRlIHdpdGggMyBzdGF0ZXM6IGlmIHRydWUgb3IgZmFsc2UsXG5cdFx0Ly8gdGhlIGRhdGFzZXQuaGlkZGVuIHZhbHVlIGlzIGlnbm9yZWQsIGVsc2UgaWYgbnVsbCwgdGhlIGRhdGFzZXQgaGlkZGVuIHN0YXRlIGlzIHJldHVybmVkLlxuXHRcdHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICF0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5oaWRkZW47XG5cdH0sXG5cblx0Z2VuZXJhdGVMZWdlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMubGVnZW5kQ2FsbGJhY2sodGhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRkZXN0cm95RGF0YXNldE1ldGE6IGZ1bmN0aW9uKGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBpZCA9IHRoaXMuaWQ7XG5cdFx0dmFyIGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcblx0XHR2YXIgbWV0YSA9IGRhdGFzZXQuX21ldGEgJiYgZGF0YXNldC5fbWV0YVtpZF07XG5cblx0XHRpZiAobWV0YSkge1xuXHRcdFx0bWV0YS5jb250cm9sbGVyLmRlc3Ryb3koKTtcblx0XHRcdGRlbGV0ZSBkYXRhc2V0Ll9tZXRhW2lkXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2FudmFzID0gbWUuY2FudmFzO1xuXHRcdHZhciBpLCBpbGVuO1xuXG5cdFx0bWUuc3RvcCgpO1xuXG5cdFx0Ly8gZGF0YXNldCBjb250cm9sbGVycyBuZWVkIHRvIGNsZWFudXAgYXNzb2NpYXRlZCBkYXRhXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IG1lLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRtZS5kZXN0cm95RGF0YXNldE1ldGEoaSk7XG5cdFx0fVxuXG5cdFx0aWYgKGNhbnZhcykge1xuXHRcdFx0bWUudW5iaW5kRXZlbnRzKCk7XG5cdFx0XHRoZWxwZXJzJDEuY2FudmFzLmNsZWFyKG1lKTtcblx0XHRcdHBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KG1lLmN0eCk7XG5cdFx0XHRtZS5jYW52YXMgPSBudWxsO1xuXHRcdFx0bWUuY3R4ID0gbnVsbDtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnZGVzdHJveScpO1xuXG5cdFx0ZGVsZXRlIENoYXJ0Lmluc3RhbmNlc1ttZS5pZF07XG5cdH0sXG5cblx0dG9CYXNlNjRJbWFnZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTC5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRpbml0VG9vbFRpcDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHRtZS50b29sdGlwID0gbmV3IGNvcmVfdG9vbHRpcCh7XG5cdFx0XHRfY2hhcnQ6IG1lLFxuXHRcdFx0X2NoYXJ0SW5zdGFuY2U6IG1lLCAvLyBkZXByZWNhdGVkLCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdFx0XHRfZGF0YTogbWUuZGF0YSxcblx0XHRcdF9vcHRpb25zOiBtZS5vcHRpb25zLnRvb2x0aXBzXG5cdFx0fSwgbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0YmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycyA9IHt9O1xuXHRcdHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0bWUuZXZlbnRIYW5kbGVyLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cblx0XHRoZWxwZXJzJDEuZWFjaChtZS5vcHRpb25zLmV2ZW50cywgZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0cGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihtZSwgdHlwZSwgbGlzdGVuZXIpO1xuXHRcdFx0bGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG5cdFx0fSk7XG5cblx0XHQvLyBFbGVtZW50cyB1c2VkIHRvIGRldGVjdCBzaXplIGNoYW5nZSBzaG91bGQgbm90IGJlIGluamVjdGVkIGZvciBub24gcmVzcG9uc2l2ZSBjaGFydHMuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yMjEwXG5cdFx0aWYgKG1lLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuXHRcdFx0bGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWUucmVzaXplKCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKG1lLCAncmVzaXplJywgbGlzdGVuZXIpO1xuXHRcdFx0bGlzdGVuZXJzLnJlc2l6ZSA9IGxpc3RlbmVyO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHVuYmluZEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGlzdGVuZXJzID0gbWUuX2xpc3RlbmVycztcblx0XHRpZiAoIWxpc3RlbmVycykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGRlbGV0ZSBtZS5fbGlzdGVuZXJzO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIsIHR5cGUpIHtcblx0XHRcdHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIobWUsIHR5cGUsIGxpc3RlbmVyKTtcblx0XHR9KTtcblx0fSxcblxuXHR1cGRhdGVIb3ZlclN0eWxlOiBmdW5jdGlvbihlbGVtZW50cywgbW9kZSwgZW5hYmxlZCkge1xuXHRcdHZhciBtZXRob2QgPSBlbmFibGVkID8gJ3NldEhvdmVyU3R5bGUnIDogJ3JlbW92ZUhvdmVyU3R5bGUnO1xuXHRcdHZhciBlbGVtZW50LCBpLCBpbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0ZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5nZXREYXRhc2V0TWV0YShlbGVtZW50Ll9kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXJbbWV0aG9kXShlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRldmVudEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0b29sdGlwID0gbWUudG9vbHRpcDtcblxuXHRcdGlmIChjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYmVmb3JlRXZlbnQnLCBbZV0pID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEJ1ZmZlciBhbnkgdXBkYXRlIGNhbGxzIHNvIHRoYXQgcmVuZGVycyBkbyBub3Qgb2NjdXJcblx0XHRtZS5fYnVmZmVyZWRSZW5kZXIgPSB0cnVlO1xuXHRcdG1lLl9idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG5cdFx0dmFyIGNoYW5nZWQgPSBtZS5oYW5kbGVFdmVudChlKTtcblx0XHQvLyBmb3Igc21vb3RoIHRvb2x0aXAgYW5pbWF0aW9ucyBpc3N1ZSAjNDk4OVxuXHRcdC8vIHRoZSB0b29sdGlwIHNob3VsZCBiZSB0aGUgc291cmNlIG9mIGNoYW5nZVxuXHRcdC8vIEFuaW1hdGlvbiBjaGVjayB3b3JrYXJvdW5kOlxuXHRcdC8vIHRvb2x0aXAuX3N0YXJ0IHdpbGwgYmUgbnVsbCB3aGVuIHRvb2x0aXAgaXNuJ3QgYW5pbWF0aW5nXG5cdFx0aWYgKHRvb2x0aXApIHtcblx0XHRcdGNoYW5nZWQgPSB0b29sdGlwLl9zdGFydFxuXHRcdFx0XHQ/IHRvb2x0aXAuaGFuZGxlRXZlbnQoZSlcblx0XHRcdFx0OiBjaGFuZ2VkIHwgdG9vbHRpcC5oYW5kbGVFdmVudChlKTtcblx0XHR9XG5cblx0XHRjb3JlX3BsdWdpbnMubm90aWZ5KG1lLCAnYWZ0ZXJFdmVudCcsIFtlXSk7XG5cblx0XHR2YXIgYnVmZmVyZWRSZXF1ZXN0ID0gbWUuX2J1ZmZlcmVkUmVxdWVzdDtcblx0XHRpZiAoYnVmZmVyZWRSZXF1ZXN0KSB7XG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGFuIHVwZGF0ZSB0aGF0IHdhcyB0cmlnZ2VyZWQsIHdlIG5lZWQgdG8gZG8gYSBub3JtYWwgcmVuZGVyXG5cdFx0XHRtZS5yZW5kZXIoYnVmZmVyZWRSZXF1ZXN0KTtcblx0XHR9IGVsc2UgaWYgKGNoYW5nZWQgJiYgIW1lLmFuaW1hdGluZykge1xuXHRcdFx0Ly8gSWYgZW50ZXJpbmcsIGxlYXZpbmcsIG9yIGNoYW5naW5nIGVsZW1lbnRzLCBhbmltYXRlIHRoZSBjaGFuZ2UgdmlhIHBpdm90XG5cdFx0XHRtZS5zdG9wKCk7XG5cblx0XHRcdC8vIFdlIG9ubHkgbmVlZCB0byByZW5kZXIgYXQgdGhpcyBwb2ludC4gVXBkYXRpbmcgd2lsbCBjYXVzZSBzY2FsZXMgdG8gYmVcblx0XHRcdC8vIHJlY29tcHV0ZWQgZ2VuZXJhdGluZyBmbGlja2VyICYgdXNpbmcgbW9yZSBtZW1vcnkgdGhhbiBuZWNlc3NhcnkuXG5cdFx0XHRtZS5yZW5kZXIoe1xuXHRcdFx0XHRkdXJhdGlvbjogbWUub3B0aW9ucy5ob3Zlci5hbmltYXRpb25EdXJhdGlvbixcblx0XHRcdFx0bGF6eTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0bWUuX2J1ZmZlcmVkUmVuZGVyID0gZmFsc2U7XG5cdFx0bWUuX2J1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cblx0XHRyZXR1cm4gbWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgdGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFydCBuZWVkcyB0byByZS1yZW5kZXJcblx0ICovXG5cdGhhbmRsZUV2ZW50OiBmdW5jdGlvbihlKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnMgfHwge307XG5cdFx0dmFyIGhvdmVyT3B0aW9ucyA9IG9wdGlvbnMuaG92ZXI7XG5cdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdG1lLmxhc3RBY3RpdmUgPSBtZS5sYXN0QWN0aXZlIHx8IFtdO1xuXG5cdFx0Ly8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIGhvdmVyIGFuZCB0b29sdGlwc1xuXHRcdGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdG1lLmFjdGl2ZSA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5hY3RpdmUgPSBtZS5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdC8vIEludm9rZSBvbkhvdmVyIGhvb2tcblx0XHQvLyBOZWVkIHRvIGNhbGwgd2l0aCBuYXRpdmUgZXZlbnQgaGVyZSB0byBub3QgYnJlYWsgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sob3B0aW9ucy5vbkhvdmVyIHx8IG9wdGlvbnMuaG92ZXIub25Ib3ZlciwgW2UubmF0aXZlLCBtZS5hY3RpdmVdLCBtZSk7XG5cblx0XHRpZiAoZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAob3B0aW9ucy5vbkNsaWNrKSB7XG5cdFx0XHRcdC8vIFVzZSBlLm5hdGl2ZSBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdFx0XHRvcHRpb25zLm9uQ2xpY2suY2FsbChtZSwgZS5uYXRpdmUsIG1lLmFjdGl2ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHN0eWxpbmcgZm9yIGxhc3QgYWN0aXZlIChldmVuIGlmIGl0IG1heSBzdGlsbCBiZSBhY3RpdmUpXG5cdFx0aWYgKG1lLmxhc3RBY3RpdmUubGVuZ3RoKSB7XG5cdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmxhc3RBY3RpdmUsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0Ly8gQnVpbHQgaW4gaG92ZXIgc3R5bGluZ1xuXHRcdGlmIChtZS5hY3RpdmUubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG5cdFx0XHRtZS51cGRhdGVIb3ZlclN0eWxlKG1lLmFjdGl2ZSwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuXHRcdH1cblxuXHRcdGNoYW5nZWQgPSAhaGVscGVycyQxLmFycmF5RXF1YWxzKG1lLmFjdGl2ZSwgbWUubGFzdEFjdGl2ZSk7XG5cblx0XHQvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcblx0XHRtZS5sYXN0QWN0aXZlID0gbWUuYWN0aXZlO1xuXG5cdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdH1cbn0pO1xuXG4vKipcbiAqIE5PVEUoU0IpIFdlIGFjdHVhbGx5IGRvbid0IHVzZSB0aGlzIGNvbnRhaW5lciBhbnltb3JlIGJ1dCB3ZSBuZWVkIHRvIGtlZXAgaXRcbiAqIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBUaG91Z2gsIGl0IGNhbiBzdGlsbCBiZSB1c2VmdWwgZm9yIHBsdWdpbnMgdGhhdFxuICogd291bGQgbmVlZCB0byB3b3JrIG9uIG11bHRpcGxlIGNoYXJ0cz8hXG4gKi9cbkNoYXJ0Lmluc3RhbmNlcyA9IHt9O1xuXG52YXIgY29yZV9jb250cm9sbGVyID0gQ2hhcnQ7XG5cbi8vIERFUFJFQ0FUSU9OU1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQgaW5zdGVhZC5cbiAqIEBjbGFzcyBDaGFydC5Db250cm9sbGVyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNlxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuQ2hhcnQuQ29udHJvbGxlciA9IENoYXJ0O1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuQ2hhcnQudHlwZXMgPSB7fTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmNvbmZpZ01lcmdlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5oZWxwZXJzJDEuY29uZmlnTWVyZ2UgPSBtZXJnZUNvbmZpZztcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgbm90IGF2YWlsYWJsZSBhbnltb3JlLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLnNjYWxlTWVyZ2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmhlbHBlcnMkMS5zY2FsZU1lcmdlID0gbWVyZ2VTY2FsZUNvbmZpZztcblxudmFyIGNvcmVfaGVscGVycyA9IGZ1bmN0aW9uKCkge1xuXG5cdC8vIC0tIEJhc2ljIGpzIHV0aWxpdHkgbWV0aG9kc1xuXG5cdGhlbHBlcnMkMS53aGVyZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGZpbHRlckNhbGxiYWNrKSB7XG5cdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KGNvbGxlY3Rpb24pICYmIEFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcblx0XHRcdHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcihmaWx0ZXJDYWxsYmFjayk7XG5cdFx0fVxuXHRcdHZhciBmaWx0ZXJlZCA9IFtdO1xuXG5cdFx0aGVscGVycyQxLmVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0aWYgKGZpbHRlckNhbGxiYWNrKGl0ZW0pKSB7XG5cdFx0XHRcdGZpbHRlcmVkLnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZmlsdGVyZWQ7XG5cdH07XG5cdGhlbHBlcnMkMS5maW5kSW5kZXggPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4ID9cblx0XHRmdW5jdGlvbihhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG5cdFx0XHRyZXR1cm4gYXJyYXkuZmluZEluZGV4KGNhbGxiYWNrLCBzY29wZSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xuXHRcdFx0c2NvcGUgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gYXJyYXkgOiBzY29wZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRcdGlmIChjYWxsYmFjay5jYWxsKHNjb3BlLCBhcnJheVtpXSwgaSwgYXJyYXkpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAtMTtcblx0XHR9O1xuXHRoZWxwZXJzJDEuZmluZE5leHRXaGVyZSA9IGZ1bmN0aW9uKGFycmF5VG9TZWFyY2gsIGZpbHRlckNhbGxiYWNrLCBzdGFydEluZGV4KSB7XG5cdFx0Ly8gRGVmYXVsdCB0byBzdGFydCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoc3RhcnRJbmRleCkpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSAtMTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggKyAxOyBpIDwgYXJyYXlUb1NlYXJjaC5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycyQxLmZpbmRQcmV2aW91c1doZXJlID0gZnVuY3Rpb24oYXJyYXlUb1NlYXJjaCwgZmlsdGVyQ2FsbGJhY2ssIHN0YXJ0SW5kZXgpIHtcblx0XHQvLyBEZWZhdWx0IHRvIGVuZCBvZiB0aGUgYXJyYXlcblx0XHRpZiAoaGVscGVycyQxLmlzTnVsbE9yVW5kZWYoc3RhcnRJbmRleCkpIHtcblx0XHRcdHN0YXJ0SW5kZXggPSBhcnJheVRvU2VhcmNoLmxlbmd0aDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnJlbnRJdGVtID0gYXJyYXlUb1NlYXJjaFtpXTtcblx0XHRcdGlmIChmaWx0ZXJDYWxsYmFjayhjdXJyZW50SXRlbSkpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRJdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvLyAtLSBNYXRoIG1ldGhvZHNcblx0aGVscGVycyQxLmlzTnVtYmVyID0gZnVuY3Rpb24obikge1xuXHRcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG5cdH07XG5cdGhlbHBlcnMkMS5hbG1vc3RFcXVhbHMgPSBmdW5jdGlvbih4LCB5LCBlcHNpbG9uKSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG5cdH07XG5cdGhlbHBlcnMkMS5hbG1vc3RXaG9sZSA9IGZ1bmN0aW9uKHgsIGVwc2lsb24pIHtcblx0XHR2YXIgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG5cdFx0cmV0dXJuICgoKHJvdW5kZWQgLSBlcHNpbG9uKSA8IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID4geCkpO1xuXHR9O1xuXHRoZWxwZXJzJDEubWF4ID0gZnVuY3Rpb24oYXJyYXkpIHtcblx0XHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKG1heCwgdmFsdWUpIHtcblx0XHRcdGlmICghaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLm1heChtYXgsIHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXg7XG5cdFx0fSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcblx0fTtcblx0aGVscGVycyQxLm1pbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG5cdFx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihtaW4sIHZhbHVlKSB7XG5cdFx0XHRpZiAoIWlzTmFOKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5taW4obWluLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWluO1xuXHRcdH0sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG5cdH07XG5cdGhlbHBlcnMkMS5zaWduID0gTWF0aC5zaWduID9cblx0XHRmdW5jdGlvbih4KSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5zaWduKHgpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKHgpIHtcblx0XHRcdHggPSAreDsgLy8gY29udmVydCB0byBhIG51bWJlclxuXHRcdFx0aWYgKHggPT09IDAgfHwgaXNOYU4oeCkpIHtcblx0XHRcdFx0cmV0dXJuIHg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geCA+IDAgPyAxIDogLTE7XG5cdFx0fTtcblx0aGVscGVycyQxLmxvZzEwID0gTWF0aC5sb2cxMCA/XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0cmV0dXJuIE1hdGgubG9nMTAoeCk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oeCkge1xuXHRcdFx0dmFyIGV4cG9uZW50ID0gTWF0aC5sb2coeCkgKiBNYXRoLkxPRzEwRTsgLy8gTWF0aC5MT0cxMEUgPSAxIC8gTWF0aC5MTjEwLlxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHdob2xlIHBvd2VycyBvZiAxMCxcblx0XHRcdC8vIHdoaWNoIGR1ZSB0byBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvciBzaG91bGQgYmUgY29ycmVjdGVkLlxuXHRcdFx0dmFyIHBvd2VyT2YxMCA9IE1hdGgucm91bmQoZXhwb25lbnQpO1xuXHRcdFx0dmFyIGlzUG93ZXJPZjEwID0geCA9PT0gTWF0aC5wb3coMTAsIHBvd2VyT2YxMCk7XG5cblx0XHRcdHJldHVybiBpc1Bvd2VyT2YxMCA/IHBvd2VyT2YxMCA6IGV4cG9uZW50O1xuXHRcdH07XG5cdGhlbHBlcnMkMS50b1JhZGlhbnMgPSBmdW5jdGlvbihkZWdyZWVzKSB7XG5cdFx0cmV0dXJuIGRlZ3JlZXMgKiAoTWF0aC5QSSAvIDE4MCk7XG5cdH07XG5cdGhlbHBlcnMkMS50b0RlZ3JlZXMgPSBmdW5jdGlvbihyYWRpYW5zKSB7XG5cdFx0cmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gTWF0aC5QSSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuXHQgKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gQSBudW1iZXIuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoZWxwZXJzJDEuX2RlY2ltYWxQbGFjZXMgPSBmdW5jdGlvbih4KSB7XG5cdFx0aWYgKCFoZWxwZXJzJDEuaXNGaW5pdGUoeCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGUgPSAxO1xuXHRcdHZhciBwID0gMDtcblx0XHR3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG5cdFx0XHRlICo9IDEwO1xuXHRcdFx0cCsrO1xuXHRcdH1cblx0XHRyZXR1cm4gcDtcblx0fTtcblxuXHQvLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuXHRoZWxwZXJzJDEuZ2V0QW5nbGVGcm9tUG9pbnQgPSBmdW5jdGlvbihjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuXHRcdHZhciBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcblx0XHR2YXIgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG5cdFx0dmFyIHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcblxuXHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG5cblx0XHRpZiAoYW5nbGUgPCAoLTAuNSAqIE1hdGguUEkpKSB7XG5cdFx0XHRhbmdsZSArPSAyLjAgKiBNYXRoLlBJOyAvLyBtYWtlIHN1cmUgdGhlIHJldHVybmVkIGFuZ2xlIGlzIGluIHRoZSByYW5nZSBvZiAoLVBJLzIsIDNQSS8yXVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbmdsZTogYW5nbGUsXG5cdFx0XHRkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG5cdFx0fTtcblx0fTtcblx0aGVscGVycyQxLmRpc3RhbmNlQmV0d2VlblBvaW50cyA9IGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcblx0fTtcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuXHQgKiBAZnVuY3Rpb24gQ2hhcnQuaGVscGVycy5hbGlhc1BpeGVsXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKi9cblx0aGVscGVycyQxLmFsaWFzUGl4ZWwgPSBmdW5jdGlvbihwaXhlbFdpZHRoKSB7XG5cdFx0cmV0dXJuIChwaXhlbFdpZHRoICUgMiA9PT0gMCkgPyAwIDogMC41O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIFRoZSBjaGFydCBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50LlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgYWxpZ25lZCBwaXhlbCB2YWx1ZS5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGhlbHBlcnMkMS5fYWxpZ25QaXhlbCA9IGZ1bmN0aW9uKGNoYXJ0LCBwaXhlbCwgd2lkdGgpIHtcblx0XHR2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuXHRcdHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcblx0fTtcblxuXHRoZWxwZXJzJDEuc3BsaW5lQ3VydmUgPSBmdW5jdGlvbihmaXJzdFBvaW50LCBtaWRkbGVQb2ludCwgYWZ0ZXJQb2ludCwgdCkge1xuXHRcdC8vIFByb3BzIHRvIFJvYiBTcGVuY2VyIGF0IHNjYWxlZCBpbm5vdmF0aW9uIGZvciBoaXMgcG9zdCBvbiBzcGxpbmluZyBiZXR3ZWVuIHBvaW50c1xuXHRcdC8vIGh0dHA6Ly9zY2FsZWRpbm5vdmF0aW9uLmNvbS9hbmFseXRpY3Mvc3BsaW5lcy9hYm91dFNwbGluZXMuaHRtbFxuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuXHRcdHZhciBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcblx0XHR2YXIgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuXHRcdHZhciBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuXG5cdFx0dmFyIGQwMSA9IE1hdGguc3FydChNYXRoLnBvdyhjdXJyZW50LnggLSBwcmV2aW91cy54LCAyKSArIE1hdGgucG93KGN1cnJlbnQueSAtIHByZXZpb3VzLnksIDIpKTtcblx0XHR2YXIgZDEyID0gTWF0aC5zcXJ0KE1hdGgucG93KG5leHQueCAtIGN1cnJlbnQueCwgMikgKyBNYXRoLnBvdyhuZXh0LnkgLSBjdXJyZW50LnksIDIpKTtcblxuXHRcdHZhciBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcblx0XHR2YXIgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cblx0XHQvLyBJZiBhbGwgcG9pbnRzIGFyZSB0aGUgc2FtZSwgczAxICYgczAyIHdpbGwgYmUgaW5mXG5cdFx0czAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG5cdFx0czEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cblx0XHR2YXIgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcblx0XHR2YXIgZmIgPSB0ICogczEyO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHByZXZpb3VzOiB7XG5cdFx0XHRcdHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuXHRcdFx0XHR5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuXHRcdFx0fSxcblx0XHRcdG5leHQ6IHtcblx0XHRcdFx0eDogY3VycmVudC54ICsgZmIgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG5cdFx0XHRcdHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblx0aGVscGVycyQxLkVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcblx0aGVscGVycyQxLnNwbGluZUN1cnZlTW9ub3RvbmUgPSBmdW5jdGlvbihwb2ludHMpIHtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcblx0XHQvLyBidXQgcHJlc2VydmVzIG1vbm90b25pY2l0eSBvZiB0aGUgcHJvdmlkZWQgZGF0YSBhbmQgZW5zdXJlcyBubyBsb2NhbCBleHRyZW11bXMgYXJlIGFkZGVkXG5cdFx0Ly8gYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuXHRcdC8vIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cblxuXHRcdHZhciBwb2ludHNXaXRoVGFuZ2VudHMgPSAocG9pbnRzIHx8IFtdKS5tYXAoZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1vZGVsOiBwb2ludC5fbW9kZWwsXG5cdFx0XHRcdGRlbHRhSzogMCxcblx0XHRcdFx0bUs6IDBcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHQvLyBDYWxjdWxhdGUgc2xvcGVzIChkZWx0YUspIGFuZCBpbml0aWFsaXplIHRhbmdlbnRzIChtSylcblx0XHR2YXIgcG9pbnRzTGVuID0gcG9pbnRzV2l0aFRhbmdlbnRzLmxlbmd0aDtcblx0XHR2YXIgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudCwgcG9pbnRBZnRlcjtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcblx0XHRcdHBvaW50Q3VycmVudCA9IHBvaW50c1dpdGhUYW5nZW50c1tpXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cG9pbnRCZWZvcmUgPSBpID4gMCA/IHBvaW50c1dpdGhUYW5nZW50c1tpIC0gMV0gOiBudWxsO1xuXHRcdFx0cG9pbnRBZnRlciA9IGkgPCBwb2ludHNMZW4gLSAxID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXSA6IG51bGw7XG5cdFx0XHRpZiAocG9pbnRBZnRlciAmJiAhcG9pbnRBZnRlci5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdHZhciBzbG9wZURlbHRhWCA9IChwb2ludEFmdGVyLm1vZGVsLnggLSBwb2ludEN1cnJlbnQubW9kZWwueCk7XG5cblx0XHRcdFx0Ly8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG5cdFx0XHRcdHBvaW50Q3VycmVudC5kZWx0YUsgPSBzbG9wZURlbHRhWCAhPT0gMCA/IChwb2ludEFmdGVyLm1vZGVsLnkgLSBwb2ludEN1cnJlbnQubW9kZWwueSkgLyBzbG9wZURlbHRhWCA6IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghcG9pbnRCZWZvcmUgfHwgcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICghcG9pbnRBZnRlciB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRCZWZvcmUuZGVsdGFLO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLnNpZ24ocG9pbnRCZWZvcmUuZGVsdGFLKSAhPT0gdGhpcy5zaWduKHBvaW50Q3VycmVudC5kZWx0YUspKSB7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tSyA9IDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludEN1cnJlbnQubUsgPSAocG9pbnRCZWZvcmUuZGVsdGFLICsgcG9pbnRDdXJyZW50LmRlbHRhSykgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcblx0XHR2YXIgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKSB7XG5cdFx0XHRwb2ludEN1cnJlbnQgPSBwb2ludHNXaXRoVGFuZ2VudHNbaV07XG5cdFx0XHRwb2ludEFmdGVyID0gcG9pbnRzV2l0aFRhbmdlbnRzW2kgKyAxXTtcblx0XHRcdGlmIChwb2ludEN1cnJlbnQubW9kZWwuc2tpcCB8fCBwb2ludEFmdGVyLm1vZGVsLnNraXApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoZWxwZXJzJDEuYWxtb3N0RXF1YWxzKHBvaW50Q3VycmVudC5kZWx0YUssIDAsIHRoaXMuRVBTSUxPTikpIHtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1LID0gcG9pbnRBZnRlci5tSyA9IDA7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRhbHBoYUsgPSBwb2ludEN1cnJlbnQubUsgLyBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdFx0YmV0YUsgPSBwb2ludEFmdGVyLm1LIC8gcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuXHRcdFx0aWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dGF1SyA9IDMgLyBNYXRoLnNxcnQoc3F1YXJlZE1hZ25pdHVkZSk7XG5cdFx0XHRwb2ludEN1cnJlbnQubUsgPSBhbHBoYUsgKiB0YXVLICogcG9pbnRDdXJyZW50LmRlbHRhSztcblx0XHRcdHBvaW50QWZ0ZXIubUsgPSBiZXRhSyAqIHRhdUsgKiBwb2ludEN1cnJlbnQuZGVsdGFLO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGUgY29udHJvbCBwb2ludHNcblx0XHR2YXIgZGVsdGFYO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuXHRcdFx0cG9pbnRDdXJyZW50ID0gcG9pbnRzV2l0aFRhbmdlbnRzW2ldO1xuXHRcdFx0aWYgKHBvaW50Q3VycmVudC5tb2RlbC5za2lwKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRwb2ludEJlZm9yZSA9IGkgPiAwID8gcG9pbnRzV2l0aFRhbmdlbnRzW2kgLSAxXSA6IG51bGw7XG5cdFx0XHRwb2ludEFmdGVyID0gaSA8IHBvaW50c0xlbiAtIDEgPyBwb2ludHNXaXRoVGFuZ2VudHNbaSArIDFdIDogbnVsbDtcblx0XHRcdGlmIChwb2ludEJlZm9yZSAmJiAhcG9pbnRCZWZvcmUubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRDdXJyZW50Lm1vZGVsLnggLSBwb2ludEJlZm9yZS5tb2RlbC54KSAvIDM7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnRQcmV2aW91c1ggPSBwb2ludEN1cnJlbnQubW9kZWwueCAtIGRlbHRhWDtcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludFByZXZpb3VzWSA9IHBvaW50Q3VycmVudC5tb2RlbC55IC0gZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBvaW50QWZ0ZXIgJiYgIXBvaW50QWZ0ZXIubW9kZWwuc2tpcCkge1xuXHRcdFx0XHRkZWx0YVggPSAocG9pbnRBZnRlci5tb2RlbC54IC0gcG9pbnRDdXJyZW50Lm1vZGVsLngpIC8gMztcblx0XHRcdFx0cG9pbnRDdXJyZW50Lm1vZGVsLmNvbnRyb2xQb2ludE5leHRYID0gcG9pbnRDdXJyZW50Lm1vZGVsLnggKyBkZWx0YVg7XG5cdFx0XHRcdHBvaW50Q3VycmVudC5tb2RlbC5jb250cm9sUG9pbnROZXh0WSA9IHBvaW50Q3VycmVudC5tb2RlbC55ICsgZGVsdGFYICogcG9pbnRDdXJyZW50Lm1LO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aGVscGVycyQxLm5leHRJdGVtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgaW5kZXgsIGxvb3ApIHtcblx0XHRpZiAobG9vcCkge1xuXHRcdFx0cmV0dXJuIGluZGV4ID49IGNvbGxlY3Rpb24ubGVuZ3RoIC0gMSA/IGNvbGxlY3Rpb25bMF0gOiBjb2xsZWN0aW9uW2luZGV4ICsgMV07XG5cdFx0fVxuXHRcdHJldHVybiBpbmRleCA+PSBjb2xsZWN0aW9uLmxlbmd0aCAtIDEgPyBjb2xsZWN0aW9uW2NvbGxlY3Rpb24ubGVuZ3RoIC0gMV0gOiBjb2xsZWN0aW9uW2luZGV4ICsgMV07XG5cdH07XG5cdGhlbHBlcnMkMS5wcmV2aW91c0l0ZW0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBpbmRleCwgbG9vcCkge1xuXHRcdGlmIChsb29wKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXggPD0gMCA/IGNvbGxlY3Rpb25bY29sbGVjdGlvbi5sZW5ndGggLSAxXSA6IGNvbGxlY3Rpb25baW5kZXggLSAxXTtcblx0XHR9XG5cdFx0cmV0dXJuIGluZGV4IDw9IDAgPyBjb2xsZWN0aW9uWzBdIDogY29sbGVjdGlvbltpbmRleCAtIDFdO1xuXHR9O1xuXHQvLyBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuXHRoZWxwZXJzJDEubmljZU51bSA9IGZ1bmN0aW9uKHJhbmdlLCByb3VuZCkge1xuXHRcdHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKHJhbmdlKSk7XG5cdFx0dmFyIGZyYWN0aW9uID0gcmFuZ2UgLyBNYXRoLnBvdygxMCwgZXhwb25lbnQpO1xuXHRcdHZhciBuaWNlRnJhY3Rpb247XG5cblx0XHRpZiAocm91bmQpIHtcblx0XHRcdGlmIChmcmFjdGlvbiA8IDEuNSkge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8IDMpIHtcblx0XHRcdFx0bmljZUZyYWN0aW9uID0gMjtcblx0XHRcdH0gZWxzZSBpZiAoZnJhY3Rpb24gPCA3KSB7XG5cdFx0XHRcdG5pY2VGcmFjdGlvbiA9IDU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuaWNlRnJhY3Rpb24gPSAxMDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDEuMCkge1xuXHRcdFx0bmljZUZyYWN0aW9uID0gMTtcblx0XHR9IGVsc2UgaWYgKGZyYWN0aW9uIDw9IDIpIHtcblx0XHRcdG5pY2VGcmFjdGlvbiA9IDI7XG5cdFx0fSBlbHNlIGlmIChmcmFjdGlvbiA8PSA1KSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSA1O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuaWNlRnJhY3Rpb24gPSAxMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmljZUZyYWN0aW9uICogTWF0aC5wb3coMTAsIGV4cG9uZW50KTtcblx0fTtcblx0Ly8gUmVxdWVzdCBhbmltYXRpb24gcG9seWZpbGwgLSBodHRwczovL3d3dy5wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG5cdGhlbHBlcnMkMS5yZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0d2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcblx0XHRcdHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuXHRcdFx0ZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuXHRcdFx0fTtcblx0fSgpKTtcblx0Ly8gLS0gRE9NIG1ldGhvZHNcblx0aGVscGVycyQxLmdldFJlbGF0aXZlUG9zaXRpb24gPSBmdW5jdGlvbihldnQsIGNoYXJ0KSB7XG5cdFx0dmFyIG1vdXNlWCwgbW91c2VZO1xuXHRcdHZhciBlID0gZXZ0Lm9yaWdpbmFsRXZlbnQgfHwgZXZ0O1xuXHRcdHZhciBjYW52YXMgPSBldnQudGFyZ2V0IHx8IGV2dC5zcmNFbGVtZW50O1xuXHRcdHZhciBib3VuZGluZ1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR2YXIgdG91Y2hlcyA9IGUudG91Y2hlcztcblx0XHRpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdG1vdXNlWCA9IHRvdWNoZXNbMF0uY2xpZW50WDtcblx0XHRcdG1vdXNlWSA9IHRvdWNoZXNbMF0uY2xpZW50WTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb3VzZVggPSBlLmNsaWVudFg7XG5cdFx0XHRtb3VzZVkgPSBlLmNsaWVudFk7XG5cdFx0fVxuXG5cdFx0Ly8gU2NhbGUgbW91c2UgY29vcmRpbmF0ZXMgaW50byBjYW52YXMgY29vcmRpbmF0ZXNcblx0XHQvLyBieSBmb2xsb3dpbmcgdGhlIHBhdHRlcm4gbGFpZCBvdXQgYnkgJ2plcnJ5aicgaW4gdGhlIGNvbW1lbnRzIG9mXG5cdFx0Ly8gaHR0cHM6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2FkdmFuY2VkL2h0bWw1LWNhbnZhcy1tb3VzZS1jb29yZGluYXRlcy9cblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLWxlZnQnKSk7XG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBwYXJzZUZsb2F0KGhlbHBlcnMkMS5nZXRTdHlsZShjYW52YXMsICdwYWRkaW5nLXRvcCcpKTtcblx0XHR2YXIgcGFkZGluZ1JpZ2h0ID0gcGFyc2VGbG9hdChoZWxwZXJzJDEuZ2V0U3R5bGUoY2FudmFzLCAncGFkZGluZy1yaWdodCcpKTtcblx0XHR2YXIgcGFkZGluZ0JvdHRvbSA9IHBhcnNlRmxvYXQoaGVscGVycyQxLmdldFN0eWxlKGNhbnZhcywgJ3BhZGRpbmctYm90dG9tJykpO1xuXHRcdHZhciB3aWR0aCA9IGJvdW5kaW5nUmVjdC5yaWdodCAtIGJvdW5kaW5nUmVjdC5sZWZ0IC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQ7XG5cdFx0dmFyIGhlaWdodCA9IGJvdW5kaW5nUmVjdC5ib3R0b20gLSBib3VuZGluZ1JlY3QudG9wIC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG5cblx0XHQvLyBXZSBkaXZpZGUgYnkgdGhlIGN1cnJlbnQgZGV2aWNlIHBpeGVsIHJhdGlvLCBiZWNhdXNlIHRoZSBjYW52YXMgaXMgc2NhbGVkIHVwIGJ5IHRoYXQgYW1vdW50IGluIGVhY2ggZGlyZWN0aW9uLiBIb3dldmVyXG5cdFx0Ly8gdGhlIGJhY2tlbmQgbW9kZWwgaXMgaW4gdW5zY2FsZWQgY29vcmRpbmF0ZXMuIFNpbmNlIHdlIGFyZSBnb2luZyB0byBkZWFsIHdpdGggb3VyIG1vZGVsIGNvb3JkaW5hdGVzLCB3ZSBnbyBiYWNrIGhlcmVcblx0XHRtb3VzZVggPSBNYXRoLnJvdW5kKChtb3VzZVggLSBib3VuZGluZ1JlY3QubGVmdCAtIHBhZGRpbmdMZWZ0KSAvICh3aWR0aCkgKiBjYW52YXMud2lkdGggLyBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyk7XG5cdFx0bW91c2VZID0gTWF0aC5yb3VuZCgobW91c2VZIC0gYm91bmRpbmdSZWN0LnRvcCAtIHBhZGRpbmdUb3ApIC8gKGhlaWdodCkgKiBjYW52YXMuaGVpZ2h0IC8gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8pO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IG1vdXNlWCxcblx0XHRcdHk6IG1vdXNlWVxuXHRcdH07XG5cblx0fTtcblxuXHQvLyBQcml2YXRlIGhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG5cdGZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcblx0XHR2YXIgdmFsdWVJblBpeGVscztcblx0XHRpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YWx1ZUluUGl4ZWxzID0gcGFyc2VJbnQoc3R5bGVWYWx1ZSwgMTApO1xuXG5cdFx0XHRpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG5cdFx0XHRcdC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuXHRcdFx0XHR2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZUluUGl4ZWxzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgaWYgdGhlIGdpdmVuIHZhbHVlIGNvbnRhaW5zIGFuIGVmZmVjdGl2ZSBjb25zdHJhaW50LlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNDb25zdHJhaW5lZFZhbHVlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09ICdub25lJztcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXggd2lkdGggb3IgaGVpZ2h0IG9mIHRoZSBnaXZlbiBET00gbm9kZSBpbiBhIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsZSBmYXNoaW9uXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbU5vZGUgLSB0aGUgbm9kZSB0byBjaGVjayB0aGUgY29uc3RyYWludCBvblxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWF4U3R5bGUgLSB0aGUgc3R5bGUgdGhhdCBkZWZpbmVzIHRoZSBtYXhpbXVtIGZvciB0aGUgZGlyZWN0aW9uIHdlIGFyZSB1c2luZyAoJ21heC13aWR0aCcgLyAnbWF4LWhlaWdodCcpXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwZXJjZW50YWdlUHJvcGVydHkgLSBwcm9wZXJ0eSBvZiBwYXJlbnQgdG8gdXNlIHdoZW4gY2FsY3VsYXRpbmcgd2lkdGggYXMgYSBwZXJjZW50YWdlXG5cdCAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5hdGhhbmFlbGpvbmVzLmNvbS9ibG9nLzIwMTMvcmVhZGluZy1tYXgtd2lkdGgtY3Jvc3MtYnJvd3Nlcn1cblx0ICovXG5cdGZ1bmN0aW9uIGdldENvbnN0cmFpbnREaW1lbnNpb24oZG9tTm9kZSwgbWF4U3R5bGUsIHBlcmNlbnRhZ2VQcm9wZXJ0eSkge1xuXHRcdHZhciB2aWV3ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0dmFyIHBhcmVudE5vZGUgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XG5cdFx0dmFyIGNvbnN0cmFpbmVkTm9kZSA9IHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShkb21Ob2RlKVttYXhTdHlsZV07XG5cdFx0dmFyIGNvbnN0cmFpbmVkQ29udGFpbmVyID0gdmlldy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudE5vZGUpW21heFN0eWxlXTtcblx0XHR2YXIgaGFzQ05vZGUgPSBpc0NvbnN0cmFpbmVkVmFsdWUoY29uc3RyYWluZWROb2RlKTtcblx0XHR2YXIgaGFzQ0NvbnRhaW5lciA9IGlzQ29uc3RyYWluZWRWYWx1ZShjb25zdHJhaW5lZENvbnRhaW5lcik7XG5cdFx0dmFyIGluZmluaXR5ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG5cdFx0aWYgKGhhc0NOb2RlIHx8IGhhc0NDb250YWluZXIpIHtcblx0XHRcdHJldHVybiBNYXRoLm1pbihcblx0XHRcdFx0aGFzQ05vZGUgPyBwYXJzZU1heFN0eWxlKGNvbnN0cmFpbmVkTm9kZSwgZG9tTm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5LFxuXHRcdFx0XHRoYXNDQ29udGFpbmVyID8gcGFyc2VNYXhTdHlsZShjb25zdHJhaW5lZENvbnRhaW5lciwgcGFyZW50Tm9kZSwgcGVyY2VudGFnZVByb3BlcnR5KSA6IGluZmluaXR5KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJ25vbmUnO1xuXHR9XG5cdC8vIHJldHVybnMgTnVtYmVyIG9yIHVuZGVmaW5lZCBpZiBubyBjb25zdHJhaW50XG5cdGhlbHBlcnMkMS5nZXRDb25zdHJhaW50V2lkdGggPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0cmV0dXJuIGdldENvbnN0cmFpbnREaW1lbnNpb24oZG9tTm9kZSwgJ21heC13aWR0aCcsICdjbGllbnRXaWR0aCcpO1xuXHR9O1xuXHQvLyByZXR1cm5zIE51bWJlciBvciB1bmRlZmluZWQgaWYgbm8gY29uc3RyYWludFxuXHRoZWxwZXJzJDEuZ2V0Q29uc3RyYWludEhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHRyZXR1cm4gZ2V0Q29uc3RyYWludERpbWVuc2lvbihkb21Ob2RlLCAnbWF4LWhlaWdodCcsICdjbGllbnRIZWlnaHQnKTtcblx0fTtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG4gXHQgKi9cblx0aGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nID0gZnVuY3Rpb24oY29udGFpbmVyLCBwYWRkaW5nLCBwYXJlbnREaW1lbnNpb24pIHtcblx0XHRwYWRkaW5nID0gaGVscGVycyQxLmdldFN0eWxlKGNvbnRhaW5lciwgcGFkZGluZyk7XG5cblx0XHRyZXR1cm4gcGFkZGluZy5pbmRleE9mKCclJykgPiAtMSA/IHBhcmVudERpbWVuc2lvbiAqIHBhcnNlSW50KHBhZGRpbmcsIDEwKSAvIDEwMCA6IHBhcnNlSW50KHBhZGRpbmcsIDEwKTtcblx0fTtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUgPSBmdW5jdGlvbihkb21Ob2RlKSB7XG5cdFx0dmFyIHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcblx0XHRpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5ob3N0O1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyZW50O1xuXHR9O1xuXHRoZWxwZXJzJDEuZ2V0TWF4aW11bVdpZHRoID0gZnVuY3Rpb24oZG9tTm9kZSkge1xuXHRcdHZhciBjb250YWluZXIgPSBoZWxwZXJzJDEuX2dldFBhcmVudE5vZGUoZG9tTm9kZSk7XG5cdFx0aWYgKCFjb250YWluZXIpIHtcblx0XHRcdHJldHVybiBkb21Ob2RlLmNsaWVudFdpZHRoO1xuXHRcdH1cblxuXHRcdHZhciBjbGllbnRXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcblx0XHR2YXIgcGFkZGluZ0xlZnQgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1sZWZ0JywgY2xpZW50V2lkdGgpO1xuXHRcdHZhciBwYWRkaW5nUmlnaHQgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy1yaWdodCcsIGNsaWVudFdpZHRoKTtcblxuXHRcdHZhciB3ID0gY2xpZW50V2lkdGggLSBwYWRkaW5nTGVmdCAtIHBhZGRpbmdSaWdodDtcblx0XHR2YXIgY3cgPSBoZWxwZXJzJDEuZ2V0Q29uc3RyYWludFdpZHRoKGRvbU5vZGUpO1xuXHRcdHJldHVybiBpc05hTihjdykgPyB3IDogTWF0aC5taW4odywgY3cpO1xuXHR9O1xuXHRoZWxwZXJzJDEuZ2V0TWF4aW11bUhlaWdodCA9IGZ1bmN0aW9uKGRvbU5vZGUpIHtcblx0XHR2YXIgY29udGFpbmVyID0gaGVscGVycyQxLl9nZXRQYXJlbnROb2RlKGRvbU5vZGUpO1xuXHRcdGlmICghY29udGFpbmVyKSB7XG5cdFx0XHRyZXR1cm4gZG9tTm9kZS5jbGllbnRIZWlnaHQ7XG5cdFx0fVxuXG5cdFx0dmFyIGNsaWVudEhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG5cdFx0dmFyIHBhZGRpbmdUb3AgPSBoZWxwZXJzJDEuX2NhbGN1bGF0ZVBhZGRpbmcoY29udGFpbmVyLCAncGFkZGluZy10b3AnLCBjbGllbnRIZWlnaHQpO1xuXHRcdHZhciBwYWRkaW5nQm90dG9tID0gaGVscGVycyQxLl9jYWxjdWxhdGVQYWRkaW5nKGNvbnRhaW5lciwgJ3BhZGRpbmctYm90dG9tJywgY2xpZW50SGVpZ2h0KTtcblxuXHRcdHZhciBoID0gY2xpZW50SGVpZ2h0IC0gcGFkZGluZ1RvcCAtIHBhZGRpbmdCb3R0b207XG5cdFx0dmFyIGNoID0gaGVscGVycyQxLmdldENvbnN0cmFpbnRIZWlnaHQoZG9tTm9kZSk7XG5cdFx0cmV0dXJuIGlzTmFOKGNoKSA/IGggOiBNYXRoLm1pbihoLCBjaCk7XG5cdH07XG5cdGhlbHBlcnMkMS5nZXRTdHlsZSA9IGZ1bmN0aW9uKGVsLCBwcm9wZXJ0eSkge1xuXHRcdHJldHVybiBlbC5jdXJyZW50U3R5bGUgP1xuXHRcdFx0ZWwuY3VycmVudFN0eWxlW3Byb3BlcnR5XSA6XG5cdFx0XHRkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcblx0fTtcblx0aGVscGVycyQxLnJldGluYVNjYWxlID0gZnVuY3Rpb24oY2hhcnQsIGZvcmNlUmF0aW8pIHtcblx0XHR2YXIgcGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHx8IDE7XG5cdFx0aWYgKHBpeGVsUmF0aW8gPT09IDEpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuXHRcdHZhciBoZWlnaHQgPSBjaGFydC5oZWlnaHQ7XG5cdFx0dmFyIHdpZHRoID0gY2hhcnQud2lkdGg7XG5cblx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblx0XHRjYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG5cdFx0Y2hhcnQuY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXG5cdFx0Ly8gSWYgbm8gc3R5bGUgaGFzIGJlZW4gc2V0IG9uIHRoZSBjYW52YXMsIHRoZSByZW5kZXIgc2l6ZSBpcyB1c2VkIGFzIGRpc3BsYXkgc2l6ZSxcblx0XHQvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzU3NVxuXHRcdGlmICghY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSB7XG5cdFx0XHRjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcblx0XHRcdGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4Jztcblx0XHR9XG5cdH07XG5cdC8vIC0tIENhbnZhcyBtZXRob2RzXG5cdGhlbHBlcnMkMS5mb250U3RyaW5nID0gZnVuY3Rpb24ocGl4ZWxTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpIHtcblx0XHRyZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xuXHR9O1xuXHRoZWxwZXJzJDEubG9uZ2VzdFRleHQgPSBmdW5jdGlvbihjdHgsIGZvbnQsIGFycmF5T2ZUaGluZ3MsIGNhY2hlKSB7XG5cdFx0Y2FjaGUgPSBjYWNoZSB8fCB7fTtcblx0XHR2YXIgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuXHRcdHZhciBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG5cblx0XHRpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuXHRcdFx0ZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcblx0XHRcdGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcblx0XHRcdGNhY2hlLmZvbnQgPSBmb250O1xuXHRcdH1cblxuXHRcdGN0eC5mb250ID0gZm9udDtcblx0XHR2YXIgbG9uZ2VzdCA9IDA7XG5cdFx0aGVscGVycyQxLmVhY2goYXJyYXlPZlRoaW5ncywgZnVuY3Rpb24odGhpbmcpIHtcblx0XHRcdC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdFx0aWYgKHRoaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpbmcgIT09IG51bGwgJiYgaGVscGVycyQxLmlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XG5cdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzJDEubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuXHRcdFx0fSBlbHNlIGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aGluZykpIHtcblx0XHRcdFx0Ly8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0cyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuXHRcdFx0XHQvLyB0byBkbyBtYXliZSBzaW1wbGlmeSB0aGlzIGZ1bmN0aW9uIGEgYml0IHNvIHdlIGNhbiBkbyB0aGlzIG1vcmUgcmVjdXJzaXZlbHk/XG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKHRoaW5nLCBmdW5jdGlvbihuZXN0ZWRUaGluZykge1xuXHRcdFx0XHRcdC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuXHRcdFx0XHRcdGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFoZWxwZXJzJDEuaXNBcnJheShuZXN0ZWRUaGluZykpIHtcblx0XHRcdFx0XHRcdGxvbmdlc3QgPSBoZWxwZXJzJDEubWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuXHRcdGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcblx0XHRcdFx0ZGVsZXRlIGRhdGFbZ2NbaV1dO1xuXHRcdFx0fVxuXHRcdFx0Z2Muc3BsaWNlKDAsIGdjTGVuKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvbmdlc3Q7XG5cdH07XG5cdGhlbHBlcnMkMS5tZWFzdXJlVGV4dCA9IGZ1bmN0aW9uKGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuXHRcdHZhciB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG5cdFx0aWYgKCF0ZXh0V2lkdGgpIHtcblx0XHRcdHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXSA9IGN0eC5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuXHRcdFx0Z2MucHVzaChzdHJpbmcpO1xuXHRcdH1cblx0XHRpZiAodGV4dFdpZHRoID4gbG9uZ2VzdCkge1xuXHRcdFx0bG9uZ2VzdCA9IHRleHRXaWR0aDtcblx0XHR9XG5cdFx0cmV0dXJuIGxvbmdlc3Q7XG5cdH07XG5cdGhlbHBlcnMkMS5udW1iZXJPZkxhYmVsTGluZXMgPSBmdW5jdGlvbihhcnJheU9mVGhpbmdzKSB7XG5cdFx0dmFyIG51bWJlck9mTGluZXMgPSAxO1xuXHRcdGhlbHBlcnMkMS5lYWNoKGFycmF5T2ZUaGluZ3MsIGZ1bmN0aW9uKHRoaW5nKSB7XG5cdFx0XHRpZiAoaGVscGVycyQxLmlzQXJyYXkodGhpbmcpKSB7XG5cdFx0XHRcdGlmICh0aGluZy5sZW5ndGggPiBudW1iZXJPZkxpbmVzKSB7XG5cdFx0XHRcdFx0bnVtYmVyT2ZMaW5lcyA9IHRoaW5nLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiBudW1iZXJPZkxpbmVzO1xuXHR9O1xuXG5cdGhlbHBlcnMkMS5jb2xvciA9ICFjaGFydGpzQ29sb3IgP1xuXHRcdGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdDb2xvci5qcyBub3QgZm91bmQhJyk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdC8qIGdsb2JhbCBDYW52YXNHcmFkaWVudCAqL1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQ2FudmFzR3JhZGllbnQpIHtcblx0XHRcdFx0dmFsdWUgPSBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Q29sb3I7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjaGFydGpzQ29sb3IodmFsdWUpO1xuXHRcdH07XG5cblx0aGVscGVycyQxLmdldEhvdmVyQ29sb3IgPSBmdW5jdGlvbihjb2xvclZhbHVlKSB7XG5cdFx0LyogZ2xvYmFsIENhbnZhc1BhdHRlcm4gKi9cblx0XHRyZXR1cm4gKGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNQYXR0ZXJuIHx8IGNvbG9yVmFsdWUgaW5zdGFuY2VvZiBDYW52YXNHcmFkaWVudCkgP1xuXHRcdFx0Y29sb3JWYWx1ZSA6XG5cdFx0XHRoZWxwZXJzJDEuY29sb3IoY29sb3JWYWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5yZ2JTdHJpbmcoKTtcblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFic3RyYWN0KCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0J1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogZWl0aGVyIG5vIGFkYXB0ZXIgY2FuICcgK1xuXHRcdCdiZSBmb3VuZCBvciBhbiBpbmNvbXBsZXRlIGludGVncmF0aW9uIHdhcyBwcm92aWRlZC4nXG5cdCk7XG59XG5cbi8qKlxuICogRGF0ZSBhZGFwdGVyIChjdXJyZW50IHVzZWQgYnkgdGhlIHRpbWUgc2NhbGUpXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVycy5fZGF0ZVxuICogQG1lbWJlcm9mIENoYXJ0Ll9hZGFwdGVyc1xuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIEN1cnJlbnRseSBzdXBwb3J0ZWQgdW5pdCBzdHJpbmcgdmFsdWVzLlxuICogQHR5cGVkZWYgeygnbWlsbGlzZWNvbmQnfCdzZWNvbmQnfCdtaW51dGUnfCdob3VyJ3wnZGF5J3wnd2Vlayd8J21vbnRoJ3wncXVhcnRlcid8J3llYXInKX1cbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnMuX2RhdGVcbiAqIEBuYW1lIFVuaXRcbiAqL1xuXG4vKipcbiAqIEBjbGFzc1xuICovXG5mdW5jdGlvbiBEYXRlQWRhcHRlcihvcHRpb25zKSB7XG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG59XG5cbmhlbHBlcnMkMS5leHRlbmQoRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCAvKiogQGxlbmRzIERhdGVBZGFwdGVyICovIHtcblx0LyoqXG5cdCAqIFJldHVybnMgYSBtYXAgb2YgdGltZSBmb3JtYXRzIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHRpbmcgdW5pdHMgZGVmaW5lZFxuXHQgKiBpbiBVbml0IGFzIHdlbGwgYXMgJ2RhdGV0aW1lJyByZXByZXNlbnRpbmcgYSBkZXRhaWxlZCBkYXRlL3RpbWUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7e3N0cmluZzogc3RyaW5nfX1cblx0ICovXG5cdGZvcm1hdHM6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIGdpdmVuIGB2YWx1ZWAgYW5kIHJldHVybiB0aGUgYXNzb2NpYXRlZCB0aW1lc3RhbXAuXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBwYXJzZSAodXN1YWxseSBjb21lcyBmcm9tIHRoZSBkYXRhKVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW2Zvcm1hdF0gLSB0aGUgZXhwZWN0ZWQgZGF0YSBmb3JtYXRcblx0ICogQHJldHVybnMgeyhudW1iZXJ8bnVsbCl9XG5cdCAqIEBmdW5jdGlvblxuXHQgKi9cblx0cGFyc2U6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBmb3JtYXR0ZWQgZGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGBmb3JtYXRgIGZvciBhIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIHRpbWVzdGFtcCB0byBmb3JtYXRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIHRoZSBkYXRlL3RpbWUgdG9rZW5cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGZvcm1hdDogYWJzdHJhY3QsXG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBgYW1vdW50YCBvZiBgdW5pdGAgdG8gdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCB0byBhZGRcblx0ICogQHBhcmFtIHtVbml0fSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRhZGQ6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYHVuaXRgIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzdGFtcHMuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSB0aGUgaW5wdXQgdGltZXN0YW1wIChyZWZlcmVuY2UpXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gLSB0aGUgdGltZXN0YW1wIHRvIHN1YnN0cmFjdFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGRpZmY6IGFic3RyYWN0LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHN0YXJ0IG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuXHQgKiBAcGFyYW0ge1VuaXR9IHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3ZWVrZGF5XSAtIHRoZSBJU08gZGF5IG9mIHRoZSB3ZWVrIHdpdGggMSBiZWluZyBNb25kYXlcblx0ICogYW5kIDcgYmVpbmcgU3VuZGF5IChvbmx5IG5lZWRlZCBpZiBwYXJhbSAqdW5pdCogaXMgYGlzb1dlZWtgKS5cblx0ICogQGZ1bmN0aW9uXG5cdCAqL1xuXHRzdGFydE9mOiBhYnN0cmFjdCxcblxuXHQvKipcblx0ICogUmV0dXJucyBlbmQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG5cdCAqIEBwYXJhbSB7VW5pdH0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuXHQgKiBAZnVuY3Rpb25cblx0ICovXG5cdGVuZE9mOiBhYnN0cmFjdCxcblxuXHQvLyBERVBSRUNBVElPTlNcblxuXHQvKipcblx0ICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIHNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoKSxcblx0ICogdGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4gb25seSBieSB0aGUgbW9tZW50IGFkYXB0ZXIuXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi44LjBcblx0ICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyZWF0ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cbn0pO1xuXG5EYXRlQWRhcHRlci5vdmVycmlkZSA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcblx0aGVscGVycyQxLmV4dGVuZChEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xufTtcblxudmFyIF9kYXRlID0gRGF0ZUFkYXB0ZXI7XG5cbnZhciBjb3JlX2FkYXB0ZXJzID0ge1xuXHRfZGF0ZTogX2RhdGVcbn07XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3NcbiAqL1xudmFyIGNvcmVfdGlja3MgPSB7XG5cdC8qKlxuXHQgKiBOYW1lc3BhY2UgdG8gaG9sZCBmb3JtYXR0ZXJzIGZvciBkaWZmZXJlbnQgdHlwZXMgb2YgdGlja3Ncblx0ICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG5cdCAqL1xuXHRmb3JtYXR0ZXJzOiB7XG5cdFx0LyoqXG5cdFx0ICogRm9ybWF0dGVyIGZvciB2YWx1ZSBsYWJlbHNcblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG5cdFx0ICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XG5cdFx0ICogQHJldHVybiB7c3RyaW5nfHN0cmluZ1tdfSB0aGUgbGFiZWwgdG8gZGlzcGxheVxuXHRcdCAqL1xuXHRcdHZhbHVlczogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHJldHVybiBoZWxwZXJzJDEuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6ICcnICsgdmFsdWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZvcm1hdHRlciBmb3IgbGluZWFyIG51bWVyaWMgdGlja3Ncblx0XHQgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubGluZWFyXG5cdFx0ICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG5cdFx0ICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcblx0XHQgKiBAcGFyYW0gdGlja3Mge251bWJlcltdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuXHRcdCAqL1xuXHRcdGxpbmVhcjogZnVuY3Rpb24odGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcblx0XHRcdC8vIElmIHdlIGhhdmUgbG90cyBvZiB0aWNrcywgZG9uJ3QgdXNlIHRoZSBvbmVzXG5cdFx0XHR2YXIgZGVsdGEgPSB0aWNrcy5sZW5ndGggPiAzID8gdGlja3NbMl0gLSB0aWNrc1sxXSA6IHRpY2tzWzFdIC0gdGlja3NbMF07XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgYSBudW1iZXIgbGlrZSAyLjUgYXMgdGhlIGRlbHRhLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHdlIG5lZWRcblx0XHRcdGlmIChNYXRoLmFicyhkZWx0YSkgPiAxKSB7XG5cdFx0XHRcdGlmICh0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuXHRcdFx0XHRcdC8vIG5vdCBhbiBpbnRlZ2VyXG5cdFx0XHRcdFx0ZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvZ0RlbHRhID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cdFx0XHR2YXIgdGlja1N0cmluZyA9ICcnO1xuXG5cdFx0XHRpZiAodGlja1ZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdHZhciBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0pLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSkpO1xuXHRcdFx0XHRpZiAobWF4VGljayA8IDFlLTQpIHsgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBudW1iZXJzOyB1c2Ugc2NpZW50aWZpYyBub3RhdGlvblxuXHRcdFx0XHRcdHZhciBsb2dUaWNrID0gaGVscGVycyQxLmxvZzEwKE1hdGguYWJzKHRpY2tWYWx1ZSkpO1xuXHRcdFx0XHRcdHRpY2tTdHJpbmcgPSB0aWNrVmFsdWUudG9FeHBvbmVudGlhbChNYXRoLmZsb29yKGxvZ1RpY2spIC0gTWF0aC5mbG9vcihsb2dEZWx0YSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBudW1EZWNpbWFsID0gLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKTtcblx0XHRcdFx0XHRudW1EZWNpbWFsID0gTWF0aC5tYXgoTWF0aC5taW4obnVtRGVjaW1hbCwgMjApLCAwKTsgLy8gdG9GaXhlZCBoYXMgYSBtYXggb2YgMjAgZGVjaW1hbCBwbGFjZXNcblx0XHRcdFx0XHR0aWNrU3RyaW5nID0gdGlja1ZhbHVlLnRvRml4ZWQobnVtRGVjaW1hbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRpY2tTdHJpbmcgPSAnMCc7IC8vIG5ldmVyIHNob3cgZGVjaW1hbCBwbGFjZXMgZm9yIDBcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRpY2tTdHJpbmc7XG5cdFx0fSxcblxuXHRcdGxvZ2FyaXRobWljOiBmdW5jdGlvbih0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuXHRcdFx0dmFyIHJlbWFpbiA9IHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAodGlja1ZhbHVlKSkpKTtcblxuXHRcdFx0aWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJzAnO1xuXHRcdFx0fSBlbHNlIGlmIChyZW1haW4gPT09IDEgfHwgcmVtYWluID09PSAyIHx8IHJlbWFpbiA9PT0gNSB8fCBpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gdGlja3MubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRyZXR1cm4gdGlja1ZhbHVlLnRvRXhwb25lbnRpYWwoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdH1cbn07XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCQ5ID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCA9IGhlbHBlcnMkMS52YWx1ZUF0SW5kZXhPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnc2NhbGUnLCB7XG5cdGRpc3BsYXk6IHRydWUsXG5cdHBvc2l0aW9uOiAnbGVmdCcsXG5cdG9mZnNldDogZmFsc2UsXG5cblx0Ly8gZ3JpZCBsaW5lIHNldHRpbmdzXG5cdGdyaWRMaW5lczoge1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cdFx0Y29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMSknLFxuXHRcdGxpbmVXaWR0aDogMSxcblx0XHRkcmF3Qm9yZGVyOiB0cnVlLFxuXHRcdGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcblx0XHRkcmF3VGlja3M6IHRydWUsXG5cdFx0dGlja01hcmtMZW5ndGg6IDEwLFxuXHRcdHplcm9MaW5lV2lkdGg6IDEsXG5cdFx0emVyb0xpbmVDb2xvcjogJ3JnYmEoMCwwLDAsMC4yNSknLFxuXHRcdHplcm9MaW5lQm9yZGVyRGFzaDogW10sXG5cdFx0emVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiAwLjAsXG5cdFx0b2Zmc2V0R3JpZExpbmVzOiBmYWxzZSxcblx0XHRib3JkZXJEYXNoOiBbXSxcblx0XHRib3JkZXJEYXNoT2Zmc2V0OiAwLjBcblx0fSxcblxuXHQvLyBzY2FsZSBsYWJlbFxuXHRzY2FsZUxhYmVsOiB7XG5cdFx0Ly8gZGlzcGxheSBwcm9wZXJ0eVxuXHRcdGRpc3BsYXk6IGZhbHNlLFxuXG5cdFx0Ly8gYWN0dWFsIGxhYmVsXG5cdFx0bGFiZWxTdHJpbmc6ICcnLFxuXG5cdFx0Ly8gdG9wL2JvdHRvbSBwYWRkaW5nXG5cdFx0cGFkZGluZzoge1xuXHRcdFx0dG9wOiA0LFxuXHRcdFx0Ym90dG9tOiA0XG5cdFx0fVxuXHR9LFxuXG5cdC8vIGxhYmVsIHNldHRpbmdzXG5cdHRpY2tzOiB7XG5cdFx0YmVnaW5BdFplcm86IGZhbHNlLFxuXHRcdG1pblJvdGF0aW9uOiAwLFxuXHRcdG1heFJvdGF0aW9uOiA1MCxcblx0XHRtaXJyb3I6IGZhbHNlLFxuXHRcdHBhZGRpbmc6IDAsXG5cdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRhdXRvU2tpcDogdHJ1ZSxcblx0XHRhdXRvU2tpcFBhZGRpbmc6IDAsXG5cdFx0bGFiZWxPZmZzZXQ6IDAsXG5cdFx0Ly8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG5cdFx0bWlub3I6IHt9LFxuXHRcdG1ham9yOiB7fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gbGFiZWxzRnJvbVRpY2tzKHRpY2tzKSB7XG5cdHZhciBsYWJlbHMgPSBbXTtcblx0dmFyIGksIGlsZW47XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGxhYmVscy5wdXNoKHRpY2tzW2ldLmxhYmVsKTtcblx0fVxuXG5cdHJldHVybiBsYWJlbHM7XG59XG5cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcblx0dmFyIGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpbmRleCk7XG5cblx0aWYgKG9mZnNldEdyaWRMaW5lcykge1xuXHRcdGlmIChzY2FsZS5nZXRUaWNrcygpLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0bGluZVZhbHVlIC09IHNjYWxlLmlzSG9yaXpvbnRhbCgpID9cblx0XHRcdFx0TWF0aC5tYXgobGluZVZhbHVlIC0gc2NhbGUubGVmdCwgc2NhbGUucmlnaHQgLSBsaW5lVmFsdWUpIDpcblx0XHRcdFx0TWF0aC5tYXgobGluZVZhbHVlIC0gc2NhbGUudG9wLCBzY2FsZS5ib3R0b20gLSBsaW5lVmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdGxpbmVWYWx1ZSAtPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxpbmVWYWx1ZSAtPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4IC0gMSkpIC8gMjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGxpbmVWYWx1ZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRleHRTaXplKGNvbnRleHQsIHRpY2ssIGZvbnQpIHtcblx0cmV0dXJuIGhlbHBlcnMkMS5pc0FycmF5KHRpY2spID9cblx0XHRoZWxwZXJzJDEubG9uZ2VzdFRleHQoY29udGV4dCwgZm9udCwgdGljaykgOlxuXHRcdGNvbnRleHQubWVhc3VyZVRleHQodGljaykud2lkdGg7XG59XG5cbnZhciBjb3JlX3NjYWxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdC8qKlxuXHQgKiBHZXQgdGhlIHBhZGRpbmcgbmVlZGVkIGZvciB0aGUgc2NhbGVcblx0ICogQG1ldGhvZCBnZXRQYWRkaW5nXG5cdCAqIEBwcml2YXRlXG5cdCAqIEByZXR1cm5zIHtQYWRkaW5nfSB0aGUgbmVjZXNzYXJ5IHBhZGRpbmdcblx0ICovXG5cdGdldFBhZGRpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGxlZnQ6IG1lLnBhZGRpbmdMZWZ0IHx8IDAsXG5cdFx0XHR0b3A6IG1lLnBhZGRpbmdUb3AgfHwgMCxcblx0XHRcdHJpZ2h0OiBtZS5wYWRkaW5nUmlnaHQgfHwgMCxcblx0XHRcdGJvdHRvbTogbWUucGFkZGluZ0JvdHRvbSB8fCAwXG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzICh7bGFiZWwsIG1ham9yfSlcblx0ICogQHNpbmNlIDIuN1xuXHQgKi9cblx0Z2V0VGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl90aWNrcztcblx0fSxcblxuXHQvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWxlLiBVdGlsaXRpZXMgdGhlbiBmb2xsb3cuXG5cdC8vIEFueSBmdW5jdGlvbiBkZWZpbmVkIGhlcmUgaXMgaW5oZXJpdGVkIGJ5IGFsbCBzY2FsZSB0eXBlcy5cblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgc2NhbGUgdHlwZVxuXG5cdG1lcmdlVGlja3NPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cdFx0aWYgKHRpY2tzLm1pbm9yID09PSBmYWxzZSkge1xuXHRcdFx0dGlja3MubWlub3IgPSB7XG5cdFx0XHRcdGRpc3BsYXk6IGZhbHNlXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAodGlja3MubWFqb3IgPT09IGZhbHNlKSB7XG5cdFx0XHR0aWNrcy5tYWpvciA9IHtcblx0XHRcdFx0ZGlzcGxheTogZmFsc2Vcblx0XHRcdH07XG5cdFx0fVxuXHRcdGZvciAodmFyIGtleSBpbiB0aWNrcykge1xuXHRcdFx0aWYgKGtleSAhPT0gJ21ham9yJyAmJiBrZXkgIT09ICdtaW5vcicpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0aWNrcy5taW5vcltrZXldID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHRpY2tzLm1pbm9yW2tleV0gPSB0aWNrc1trZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlb2YgdGlja3MubWFqb3Jba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHR0aWNrcy5tYWpvcltrZXldID0gdGlja3Nba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpLCBpbGVuLCBsYWJlbHMsIGxhYmVsLCB0aWNrcywgdGljaztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gaGVscGVycyQxLmV4dGVuZCh7XG5cdFx0XHRsZWZ0OiAwLFxuXHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHR0b3A6IDAsXG5cdFx0XHRib3R0b206IDBcblx0XHR9LCBtYXJnaW5zKTtcblxuXHRcdG1lLl9tYXhMYWJlbExpbmVzID0gMDtcblx0XHRtZS5sb25nZXN0TGFiZWxXaWR0aCA9IDA7XG5cdFx0bWUubG9uZ2VzdFRleHRDYWNoZSA9IG1lLmxvbmdlc3RUZXh0Q2FjaGUgfHwge307XG5cblx0XHQvLyBEaW1lbnNpb25zXG5cdFx0bWUuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLnNldERpbWVuc2lvbnMoKTtcblx0XHRtZS5hZnRlclNldERpbWVuc2lvbnMoKTtcblxuXHRcdC8vIERhdGEgbWluL21heFxuXHRcdG1lLmJlZm9yZURhdGFMaW1pdHMoKTtcblx0XHRtZS5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG5cdFx0bWUuYWZ0ZXJEYXRhTGltaXRzKCk7XG5cblx0XHQvLyBUaWNrcyAtIGB0aGlzLnRpY2tzYCBpcyBub3cgREVQUkVDQVRFRCFcblx0XHQvLyBJbnRlcm5hbCB0aWNrcyBhcmUgbm93IHN0b3JlZCBhcyBvYmplY3RzIGluIHRoZSBQUklWQVRFIGB0aGlzLl90aWNrc2AgbWVtYmVyXG5cdFx0Ly8gYW5kIG11c3Qgbm90IGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gb3V0c2lkZSB0aGlzIGNsYXNzLiBgdGhpcy50aWNrc2AgYmVpbmdcblx0XHQvLyBhcm91bmQgZm9yIGxvbmcgdGltZSBhbmQgbm90IG1hcmtlZCBhcyBwcml2YXRlLCB3ZSBjYW4ndCBjaGFuZ2UgaXRzIHN0cnVjdHVyZVxuXHRcdC8vIHdpdGhvdXQgdW5leHBlY3RlZCBicmVha2luZyBjaGFuZ2VzLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNjYWxlIHRpY2tzLFxuXHRcdC8vIHVzZSBzY2FsZS5nZXRUaWNrcygpIGluc3RlYWQuXG5cblx0XHRtZS5iZWZvcmVCdWlsZFRpY2tzKCk7XG5cblx0XHQvLyBOZXcgaW1wbGVtZW50YXRpb25zIHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBidXQgZm9yIEJBQ0tXQVJEIENPTVBBVCxcblx0XHQvLyB3ZSBzdGlsbCBzdXBwb3J0IG5vIHJldHVybiAoYHRoaXMudGlja3NgIGludGVybmFsbHkgc2V0IGJ5IGNhbGxpbmcgdGhpcyBtZXRob2QpLlxuXHRcdHRpY2tzID0gbWUuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG5cdFx0Ly8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxuXHRcdHRpY2tzID0gbWUuYWZ0ZXJCdWlsZFRpY2tzKHRpY2tzKSB8fCB0aWNrcztcblxuXHRcdG1lLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuXG5cdFx0Ly8gTmV3IGltcGxlbWVudGF0aW9ucyBzaG91bGQgcmV0dXJuIHRoZSBmb3JtYXR0ZWQgdGljayBsYWJlbHMgYnV0IGZvciBCQUNLV0FSRFxuXHRcdC8vIENPTVBBVCwgd2Ugc3RpbGwgc3VwcG9ydCBubyByZXR1cm4gKGB0aGlzLnRpY2tzYCBpbnRlcm5hbGx5IGNoYW5nZWQgYnkgY2FsbGluZ1xuXHRcdC8vIHRoaXMgbWV0aG9kIGFuZCBzdXBwb3NlZCB0byBjb250YWluIG9ubHkgc3RyaW5nIHZhbHVlcykuXG5cdFx0bGFiZWxzID0gbWUuY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHx8IG1lLnRpY2tzO1xuXG5cdFx0bWUuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuXHRcdG1lLnRpY2tzID0gbGFiZWxzOyAgIC8vIEJBQ0tXQVJEIENPTVBBVElCSUxJVFlcblxuXHRcdC8vIElNUE9SVEFOVDogZnJvbSB0aGlzIHBvaW50LCB3ZSBjb25zaWRlciB0aGF0IGB0aGlzLnRpY2tzYCB3aWxsIE5FVkVSIGNoYW5nZSFcblxuXHRcdC8vIEJBQ0tXQVJEIENPTVBBVDogc3luY2hyb25pemUgYF90aWNrc2Agd2l0aCBsYWJlbHMgKHNvIHBvdGVudGlhbGx5IGB0aGlzLnRpY2tzYClcblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0bGFiZWwgPSBsYWJlbHNbaV07XG5cdFx0XHR0aWNrID0gdGlja3NbaV07XG5cdFx0XHRpZiAoIXRpY2spIHtcblx0XHRcdFx0dGlja3MucHVzaCh0aWNrID0ge1xuXHRcdFx0XHRcdGxhYmVsOiBsYWJlbCxcblx0XHRcdFx0XHRtYWpvcjogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aWNrLmxhYmVsID0gbGFiZWw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUuX3RpY2tzID0gdGlja3M7XG5cblx0XHQvLyBUaWNrIFJvdGF0aW9uXG5cdFx0bWUuYmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0bWUuY2FsY3VsYXRlVGlja1JvdGF0aW9uKCk7XG5cdFx0bWUuYWZ0ZXJDYWxjdWxhdGVUaWNrUm90YXRpb24oKTtcblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlU2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuXHR9LFxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblx0fSxcblx0YWZ0ZXJTZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcblx0fSxcblxuXHQvLyBEYXRhIGxpbWl0c1xuXHRiZWZvcmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZURhdGFMaW1pdHMsIFt0aGlzXSk7XG5cdH0sXG5cdGRldGVybWluZURhdGFMaW1pdHM6IGhlbHBlcnMkMS5ub29wLFxuXHRhZnRlckRhdGFMaW1pdHM6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJEYXRhTGltaXRzLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cdGJlZm9yZUJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQnVpbGRUaWNrcywgW3RoaXNdKTtcblx0fSxcblx0YnVpbGRUaWNrczogaGVscGVycyQxLm5vb3AsXG5cdGFmdGVyQnVpbGRUaWNrczogZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIHRpY2tzIGlzIGVtcHR5IGZvciBvbGQgYXhpcyBpbXBsZW1lbnRhdGlvbnMgaGVyZVxuXHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheSh0aWNrcykgJiYgdGlja3MubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gaGVscGVycyQxLmNhbGxiYWNrKG1lLm9wdGlvbnMuYWZ0ZXJCdWlsZFRpY2tzLCBbbWUsIHRpY2tzXSk7XG5cdFx0fVxuXHRcdC8vIFN1cHBvcnQgb2xkIGltcGxlbWVudGF0aW9ucyAodGhhdCBtb2RpZmllZCBgdGhpcy50aWNrc2AgZGlyZWN0bHkgaW4gYnVpbGRUaWNrcylcblx0XHRtZS50aWNrcyA9IGhlbHBlcnMkMS5jYWxsYmFjayhtZS5vcHRpb25zLmFmdGVyQnVpbGRUaWNrcywgW21lLCBtZS50aWNrc10pIHx8IG1lLnRpY2tzO1xuXHRcdHJldHVybiB0aWNrcztcblx0fSxcblxuXHRiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb246IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHR9LFxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBDb252ZXJ0IHRpY2tzIHRvIHN0cmluZ3Ncblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdG1lLnRpY2tzID0gbWUudGlja3MubWFwKHRpY2tPcHRzLnVzZXJDYWxsYmFjayB8fCB0aWNrT3B0cy5jYWxsYmFjaywgdGhpcyk7XG5cdH0sXG5cdGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuXHR9LFxuXG5cdC8vXG5cblx0YmVmb3JlQ2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRoZWxwZXJzJDEuY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0fSxcblx0Y2FsY3VsYXRlVGlja1JvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjb250ZXh0ID0gbWUuY3R4O1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIGxhYmVscyA9IGxhYmVsc0Zyb21UaWNrcyhtZS5fdGlja3MpO1xuXG5cdFx0Ly8gR2V0IHRoZSB3aWR0aCBvZiBlYWNoIGdyaWQgYnkgY2FsY3VsYXRpbmcgdGhlIGRpZmZlcmVuY2Vcblx0XHQvLyBiZXR3ZWVuIHggb2Zmc2V0cyBiZXR3ZWVuIDAgYW5kIDEuXG5cdFx0dmFyIHRpY2tGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udCh0aWNrT3B0cyk7XG5cdFx0Y29udGV4dC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXG5cdFx0dmFyIGxhYmVsUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuXG5cdFx0aWYgKGxhYmVscy5sZW5ndGggJiYgbWUub3B0aW9ucy5kaXNwbGF5ICYmIG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWxMYWJlbFdpZHRoID0gaGVscGVycyQxLmxvbmdlc3RUZXh0KGNvbnRleHQsIHRpY2tGb250LnN0cmluZywgbGFiZWxzLCBtZS5sb25nZXN0VGV4dENhY2hlKTtcblx0XHRcdHZhciBsYWJlbFdpZHRoID0gb3JpZ2luYWxMYWJlbFdpZHRoO1xuXHRcdFx0dmFyIGNvc1JvdGF0aW9uLCBzaW5Sb3RhdGlvbjtcblxuXHRcdFx0Ly8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcblx0XHRcdHZhciB0aWNrV2lkdGggPSBtZS5nZXRQaXhlbEZvclRpY2soMSkgLSBtZS5nZXRQaXhlbEZvclRpY2soMCkgLSA2O1xuXG5cdFx0XHQvLyBNYXggbGFiZWwgcm90YXRpb24gY2FuIGJlIHNldCBvciBkZWZhdWx0IHRvIDkwIC0gYWxzbyBhY3QgYXMgYSBsb29wIGNvdW50ZXJcblx0XHRcdHdoaWxlIChsYWJlbFdpZHRoID4gdGlja1dpZHRoICYmIGxhYmVsUm90YXRpb24gPCB0aWNrT3B0cy5tYXhSb3RhdGlvbikge1xuXHRcdFx0XHR2YXIgYW5nbGVSYWRpYW5zID0gaGVscGVycyQxLnRvUmFkaWFucyhsYWJlbFJvdGF0aW9uKTtcblx0XHRcdFx0Y29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHRzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cblx0XHRcdFx0aWYgKHNpblJvdGF0aW9uICogb3JpZ2luYWxMYWJlbFdpZHRoID4gbWUubWF4SGVpZ2h0KSB7XG5cdFx0XHRcdFx0Ly8gZ28gYmFjayBvbmUgc3RlcFxuXHRcdFx0XHRcdGxhYmVsUm90YXRpb24tLTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxhYmVsUm90YXRpb24rKztcblx0XHRcdFx0bGFiZWxXaWR0aCA9IGNvc1JvdGF0aW9uICogb3JpZ2luYWxMYWJlbFdpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLmxhYmVsUm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuXHR9LFxuXHRhZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbiwgW3RoaXNdKTtcblx0fSxcblxuXHQvL1xuXG5cdGJlZm9yZUZpdDogZnVuY3Rpb24oKSB7XG5cdFx0aGVscGVycyQxLmNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG5cdH0sXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHQvLyBSZXNldFxuXHRcdHZhciBtaW5TaXplID0gbWUubWluU2l6ZSA9IHtcblx0XHRcdHdpZHRoOiAwLFxuXHRcdFx0aGVpZ2h0OiAwXG5cdFx0fTtcblxuXHRcdHZhciBsYWJlbHMgPSBsYWJlbHNGcm9tVGlja3MobWUuX3RpY2tzKTtcblxuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXHRcdHZhciBzY2FsZUxhYmVsT3B0cyA9IG9wdHMuc2NhbGVMYWJlbDtcblx0XHR2YXIgZ3JpZExpbmVPcHRzID0gb3B0cy5ncmlkTGluZXM7XG5cdFx0dmFyIGRpc3BsYXkgPSBtZS5faXNWaXNpYmxlKCk7XG5cdFx0dmFyIHBvc2l0aW9uID0gb3B0cy5wb3NpdGlvbjtcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cblx0XHR2YXIgcGFyc2VGb250ID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udDtcblx0XHR2YXIgdGlja0ZvbnQgPSBwYXJzZUZvbnQodGlja09wdHMpO1xuXHRcdHZhciB0aWNrTWFya0xlbmd0aCA9IG9wdHMuZ3JpZExpbmVzLnRpY2tNYXJrTGVuZ3RoO1xuXG5cdFx0Ly8gV2lkdGhcblx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHQvLyBzdWJ0cmFjdCB0aGUgbWFyZ2lucyB0byBsaW5lIHVwIHdpdGggdGhlIGNoYXJ0QXJlYSBpZiB3ZSBhcmUgYSBmdWxsIHdpZHRoIHNjYWxlXG5cdFx0XHRtaW5TaXplLndpZHRoID0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1heFdpZHRoIC0gbWUubWFyZ2lucy5sZWZ0IC0gbWUubWFyZ2lucy5yaWdodCA6IG1lLm1heFdpZHRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLndpZHRoID0gZGlzcGxheSAmJiBncmlkTGluZU9wdHMuZHJhd1RpY2tzID8gdGlja01hcmtMZW5ndGggOiAwO1xuXHRcdH1cblxuXHRcdC8vIGhlaWdodFxuXHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZGlzcGxheSAmJiBncmlkTGluZU9wdHMuZHJhd1RpY2tzID8gdGlja01hcmtMZW5ndGggOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdC8vIEFyZSB3ZSBzaG93aW5nIGEgdGl0bGUgZm9yIHRoZSBzY2FsZT9cblx0XHRpZiAoc2NhbGVMYWJlbE9wdHMuZGlzcGxheSAmJiBkaXNwbGF5KSB7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbEZvbnQgPSBwYXJzZUZvbnQoc2NhbGVMYWJlbE9wdHMpO1xuXHRcdFx0dmFyIHNjYWxlTGFiZWxQYWRkaW5nID0gaGVscGVycyQxLm9wdGlvbnMudG9QYWRkaW5nKHNjYWxlTGFiZWxPcHRzLnBhZGRpbmcpO1xuXHRcdFx0dmFyIGRlbHRhSGVpZ2h0ID0gc2NhbGVMYWJlbEZvbnQubGluZUhlaWdodCArIHNjYWxlTGFiZWxQYWRkaW5nLmhlaWdodDtcblxuXHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRtaW5TaXplLmhlaWdodCArPSBkZWx0YUhlaWdodDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pblNpemUud2lkdGggKz0gZGVsdGFIZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRG9uJ3QgYm90aGVyIGZpdHRpbmcgdGhlIHRpY2tzIGlmIHdlIGFyZSBub3Qgc2hvd2luZyB0aGUgbGFiZWxzXG5cdFx0aWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgZGlzcGxheSkge1xuXHRcdFx0dmFyIGxhcmdlc3RUZXh0V2lkdGggPSBoZWxwZXJzJDEubG9uZ2VzdFRleHQobWUuY3R4LCB0aWNrRm9udC5zdHJpbmcsIGxhYmVscywgbWUubG9uZ2VzdFRleHRDYWNoZSk7XG5cdFx0XHR2YXIgdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcyA9IGhlbHBlcnMkMS5udW1iZXJPZkxhYmVsTGluZXMobGFiZWxzKTtcblx0XHRcdHZhciBsaW5lU3BhY2UgPSB0aWNrRm9udC5zaXplICogMC41O1xuXHRcdFx0dmFyIHRpY2tQYWRkaW5nID0gbWUub3B0aW9ucy50aWNrcy5wYWRkaW5nO1xuXG5cdFx0XHQvLyBTdG9yZSBtYXggbnVtYmVyIG9mIGxpbmVzIGFuZCB3aWRlc3QgbGFiZWwgZm9yIF9hdXRvU2tpcFxuXHRcdFx0bWUuX21heExhYmVsTGluZXMgPSB0YWxsZXN0TGFiZWxIZWlnaHRJbkxpbmVzO1xuXHRcdFx0bWUubG9uZ2VzdExhYmVsV2lkdGggPSBsYXJnZXN0VGV4dFdpZHRoO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXHRcdFx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0XHR2YXIgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuXG5cdFx0XHRcdC8vIFRPRE8gLSBpbXByb3ZlIHRoaXMgY2FsY3VsYXRpb25cblx0XHRcdFx0dmFyIGxhYmVsSGVpZ2h0ID0gKHNpblJvdGF0aW9uICogbGFyZ2VzdFRleHRXaWR0aClcblx0XHRcdFx0XHQrICh0aWNrRm9udC5saW5lSGVpZ2h0ICogdGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcylcblx0XHRcdFx0XHQrIGxpbmVTcGFjZTsgLy8gcGFkZGluZ1xuXG5cdFx0XHRcdG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4obWUubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuXG5cdFx0XHRcdG1lLmN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXHRcdFx0XHR2YXIgZmlyc3RMYWJlbFdpZHRoID0gY29tcHV0ZVRleHRTaXplKG1lLmN0eCwgbGFiZWxzWzBdLCB0aWNrRm9udC5zdHJpbmcpO1xuXHRcdFx0XHR2YXIgbGFzdExhYmVsV2lkdGggPSBjb21wdXRlVGV4dFNpemUobWUuY3R4LCBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdLCB0aWNrRm9udC5zdHJpbmcpO1xuXHRcdFx0XHR2YXIgb2Zmc2V0TGVmdCA9IG1lLmdldFBpeGVsRm9yVGljaygwKSAtIG1lLmxlZnQ7XG5cdFx0XHRcdHZhciBvZmZzZXRSaWdodCA9IG1lLnJpZ2h0IC0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGxhYmVscy5sZW5ndGggLSAxKTtcblx0XHRcdFx0dmFyIHBhZGRpbmdMZWZ0LCBwYWRkaW5nUmlnaHQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWRcblx0XHRcdFx0Ly8gd2hpY2ggbWVhbnMgdGhhdCB0aGUgcmlnaHQgcGFkZGluZyBpcyBkb21pbmF0ZWQgYnkgdGhlIGZvbnQgaGVpZ2h0XG5cdFx0XHRcdGlmIChtZS5sYWJlbFJvdGF0aW9uICE9PSAwKSB7XG5cdFx0XHRcdFx0cGFkZGluZ0xlZnQgPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgPyAoY29zUm90YXRpb24gKiBmaXJzdExhYmVsV2lkdGgpIDogKGNvc1JvdGF0aW9uICogbGluZVNwYWNlKTtcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgPyAoY29zUm90YXRpb24gKiBsaW5lU3BhY2UpIDogKGNvc1JvdGF0aW9uICogbGFzdExhYmVsV2lkdGgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhZGRpbmdMZWZ0ID0gZmlyc3RMYWJlbFdpZHRoIC8gMjtcblx0XHRcdFx0XHRwYWRkaW5nUmlnaHQgPSBsYXN0TGFiZWxXaWR0aCAvIDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWUucGFkZGluZ0xlZnQgPSBNYXRoLm1heChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQsIDApICsgMzsgLy8gYWRkIDMgcHggdG8gbW92ZSBhd2F5IGZyb20gY2FudmFzIGVkZ2VzXG5cdFx0XHRcdG1lLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0LCAwKSArIDM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG5cdFx0XHRcdC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcblx0XHRcdFx0aWYgKHRpY2tPcHRzLm1pcnJvcikge1xuXHRcdFx0XHRcdGxhcmdlc3RUZXh0V2lkdGggPSAwO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVzZSBsaW5lU3BhY2UgZm9yIGNvbnNpc3RlbmN5IHdpdGggaG9yaXpvbnRhbCBheGlzXG5cdFx0XHRcdFx0Ly8gdGlja1BhZGRpbmcgaXMgbm90IGltcGxlbWVudGVkIGZvciBob3Jpem9udGFsXG5cdFx0XHRcdFx0bGFyZ2VzdFRleHRXaWR0aCArPSB0aWNrUGFkZGluZyArIGxpbmVTcGFjZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1pblNpemUud2lkdGggPSBNYXRoLm1pbihtZS5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhcmdlc3RUZXh0V2lkdGgpO1xuXG5cdFx0XHRcdG1lLnBhZGRpbmdUb3AgPSB0aWNrRm9udC5zaXplIC8gMjtcblx0XHRcdFx0bWUucGFkZGluZ0JvdHRvbSA9IHRpY2tGb250LnNpemUgLyAyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1lLmhhbmRsZU1hcmdpbnMoKTtcblxuXHRcdG1lLndpZHRoID0gbWluU2l6ZS53aWR0aDtcblx0XHRtZS5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRoYW5kbGVNYXJnaW5zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdGlmIChtZS5tYXJnaW5zKSB7XG5cdFx0XHRtZS5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KG1lLnBhZGRpbmdMZWZ0IC0gbWUubWFyZ2lucy5sZWZ0LCAwKTtcblx0XHRcdG1lLnBhZGRpbmdUb3AgPSBNYXRoLm1heChtZS5wYWRkaW5nVG9wIC0gbWUubWFyZ2lucy50b3AsIDApO1xuXHRcdFx0bWUucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgobWUucGFkZGluZ1JpZ2h0IC0gbWUubWFyZ2lucy5yaWdodCwgMCk7XG5cdFx0XHRtZS5wYWRkaW5nQm90dG9tID0gTWF0aC5tYXgobWUucGFkZGluZ0JvdHRvbSAtIG1lLm1hcmdpbnMuYm90dG9tLCAwKTtcblx0XHR9XG5cdH0sXG5cblx0YWZ0ZXJGaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdGhlbHBlcnMkMS5jYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG5cdH0sXG5cblx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuXHR9LFxuXHRpc0Z1bGxXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLm9wdGlvbnMuZnVsbFdpZHRoKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIGNvcnJlY3QgdmFsdWUuIE5hTiBiYWQgaW5wdXRzLCBJZiB0aGUgdmFsdWUgdHlwZSBpcyBvYmplY3QgZ2V0IHRoZSB4IG9yIHkgYmFzZWQgb24gd2hldGhlciB3ZSBhcmUgaG9yaXpvbnRhbCBvciBub3Rcblx0Z2V0UmlnaHRWYWx1ZTogZnVuY3Rpb24ocmF3VmFsdWUpIHtcblx0XHQvLyBOdWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGZpcnN0XG5cdFx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKHJhd1ZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cdFx0Ly8gaXNOYU4ob2JqZWN0KSByZXR1cm5zIHRydWUsIHNvIG1ha2Ugc3VyZSBOYU4gaXMgY2hlY2tpbmcgZm9yIGEgbnVtYmVyOyBEaXNjYXJkIEluZmluaXRlIHZhbHVlc1xuXHRcdGlmICgodHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyB8fCByYXdWYWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKHJhd1ZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIE5hTjtcblx0XHR9XG5cdFx0Ly8gSWYgaXQgaXMgaW4gZmFjdCBhbiBvYmplY3QsIGRpdmUgaW4gb25lIG1vcmUgbGV2ZWxcblx0XHRpZiAocmF3VmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRcdGlmIChyYXdWYWx1ZS54ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlLngpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHJhd1ZhbHVlLnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRSaWdodFZhbHVlKHJhd1ZhbHVlLnkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFZhbHVlIGlzIGdvb2QsIHJldHVybiBpdFxuXHRcdHJldHVybiByYXdWYWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIHZhbHVlIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2x0aXAgZm9yIHRoZSBkYXRhIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBAcGFyYW0gaW5kZXhcblx0ICogQHBhcmFtIGRhdGFzZXRJbmRleFxuXHQgKi9cblx0Z2V0TGFiZWxGb3JJbmRleDogaGVscGVycyQxLm5vb3AsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSBnaXZlbiBkYXRhIHBvaW50LiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0gdmFsdWVcblx0ICogQHBhcmFtIGluZGV4XG5cdCAqIEBwYXJhbSBkYXRhc2V0SW5kZXhcblx0ICovXG5cdGdldFBpeGVsRm9yVmFsdWU6IGhlbHBlcnMkMS5ub29wLFxuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgZGF0YSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gcGl4ZWwuIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgZ2V0UGl4ZWxGb3JWYWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHBpeGVsXG5cdCAqL1xuXHRnZXRWYWx1ZUZvclBpeGVsOiBoZWxwZXJzJDEubm9vcCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIHRpY2sgYXQgdGhlIGdpdmVuIGluZGV4XG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKi9cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9mZnNldCA9IG1lLm9wdGlvbnMub2Zmc2V0O1xuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0dmFyIGlubmVyV2lkdGggPSBtZS53aWR0aCAtIChtZS5wYWRkaW5nTGVmdCArIG1lLnBhZGRpbmdSaWdodCk7XG5cdFx0XHR2YXIgdGlja1dpZHRoID0gaW5uZXJXaWR0aCAvIE1hdGgubWF4KChtZS5fdGlja3MubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSksIDEpO1xuXHRcdFx0dmFyIHBpeGVsID0gKHRpY2tXaWR0aCAqIGluZGV4KSArIG1lLnBhZGRpbmdMZWZ0O1xuXG5cdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdHBpeGVsICs9IHRpY2tXaWR0aCAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBmaW5hbFZhbCA9IG1lLmxlZnQgKyBwaXhlbDtcblx0XHRcdGZpbmFsVmFsICs9IG1lLmlzRnVsbFdpZHRoKCkgPyBtZS5tYXJnaW5zLmxlZnQgOiAwO1xuXHRcdFx0cmV0dXJuIGZpbmFsVmFsO1xuXHRcdH1cblx0XHR2YXIgaW5uZXJIZWlnaHQgPSBtZS5oZWlnaHQgLSAobWUucGFkZGluZ1RvcCArIG1lLnBhZGRpbmdCb3R0b20pO1xuXHRcdHJldHVybiBtZS50b3AgKyAoaW5kZXggKiAoaW5uZXJIZWlnaHQgLyAobWUuX3RpY2tzLmxlbmd0aCAtIDEpKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFV0aWxpdHkgZm9yIGdldHRpbmcgdGhlIHBpeGVsIGxvY2F0aW9uIG9mIGEgcGVyY2VudGFnZSBvZiBzY2FsZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICovXG5cdGdldFBpeGVsRm9yRGVjaW1hbDogZnVuY3Rpb24oZGVjaW1hbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgaW5uZXJXaWR0aCA9IG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KTtcblx0XHRcdHZhciB2YWx1ZU9mZnNldCA9IChpbm5lcldpZHRoICogZGVjaW1hbCkgKyBtZS5wYWRkaW5nTGVmdDtcblxuXHRcdFx0dmFyIGZpbmFsVmFsID0gbWUubGVmdCArIHZhbHVlT2Zmc2V0O1xuXHRcdFx0ZmluYWxWYWwgKz0gbWUuaXNGdWxsV2lkdGgoKSA/IG1lLm1hcmdpbnMubGVmdCA6IDA7XG5cdFx0XHRyZXR1cm4gZmluYWxWYWw7XG5cdFx0fVxuXHRcdHJldHVybiBtZS50b3AgKyAoZGVjaW1hbCAqIG1lLmhlaWdodCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBpeGVsIGZvciB0aGUgbWluaW11bSBjaGFydCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICovXG5cdGdldEJhc2VQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcblx0fSxcblxuXHRnZXRCYXNlVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXG5cdFx0cmV0dXJuIG1lLmJlZ2luQXRaZXJvID8gMCA6XG5cdFx0XHRtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuXHRcdFx0bWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcblx0XHRcdDA7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGlja3MgdG8gYmUgcGxvdHRlZCB0byBhdm9pZCBvdmVybGFwcGluZyBsYWJlbHMuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfYXV0b1NraXA6IGZ1bmN0aW9uKHRpY2tzKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIG9wdGlvblRpY2tzID0gbWUub3B0aW9ucy50aWNrcy5taW5vcjtcblx0XHR2YXIgdGlja0NvdW50ID0gdGlja3MubGVuZ3RoO1xuXHRcdHZhciBza2lwUmF0aW8gPSBmYWxzZTtcblx0XHR2YXIgbWF4VGlja3MgPSBvcHRpb25UaWNrcy5tYXhUaWNrc0xpbWl0O1xuXG5cdFx0Ly8gVG90YWwgc3BhY2UgbmVlZGVkIHRvIGRpc3BsYXkgYWxsIHRpY2tzLiBGaXJzdCBhbmQgbGFzdCB0aWNrcyBhcmVcblx0XHQvLyBkcmF3biBhcyB0aGVpciBjZW50ZXIgYXQgZW5kIG9mIGF4aXMsIHNvIHRpY2tDb3VudC0xXG5cdFx0dmFyIHRpY2tzTGVuZ3RoID0gbWUuX3RpY2tTaXplKCkgKiAodGlja0NvdW50IC0gMSk7XG5cblx0XHQvLyBBeGlzIGxlbmd0aFxuXHRcdHZhciBheGlzTGVuZ3RoID0gaXNIb3Jpem9udGFsXG5cdFx0XHQ/IG1lLndpZHRoIC0gKG1lLnBhZGRpbmdMZWZ0ICsgbWUucGFkZGluZ1JpZ2h0KVxuXHRcdFx0OiBtZS5oZWlnaHQgLSAobWUucGFkZGluZ1RvcCArIG1lLlBhZGRpbmdCb3R0b20pO1xuXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHZhciBpLCB0aWNrO1xuXG5cdFx0aWYgKHRpY2tzTGVuZ3RoID4gYXhpc0xlbmd0aCkge1xuXHRcdFx0c2tpcFJhdGlvID0gMSArIE1hdGguZmxvb3IodGlja3NMZW5ndGggLyBheGlzTGVuZ3RoKTtcblx0XHR9XG5cblx0XHQvLyBpZiB0aGV5IGRlZmluZWQgYSBtYXggbnVtYmVyIG9mIG9wdGlvblRpY2tzLFxuXHRcdC8vIGluY3JlYXNlIHNraXBSYXRpbyB1bnRpbCB0aGF0IG51bWJlciBpcyBtZXRcblx0XHRpZiAodGlja0NvdW50ID4gbWF4VGlja3MpIHtcblx0XHRcdHNraXBSYXRpbyA9IE1hdGgubWF4KHNraXBSYXRpbywgMSArIE1hdGguZmxvb3IodGlja0NvdW50IC8gbWF4VGlja3MpKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgdGlja0NvdW50OyBpKyspIHtcblx0XHRcdHRpY2sgPSB0aWNrc1tpXTtcblxuXHRcdFx0aWYgKHNraXBSYXRpbyA+IDEgJiYgaSAlIHNraXBSYXRpbyA+IDApIHtcblx0XHRcdFx0Ly8gbGVhdmUgdGljayBpbiBwbGFjZSBidXQgbWFrZSBzdXJlIGl0J3Mgbm90IGRpc3BsYXllZCAoIzQ2MzUpXG5cdFx0XHRcdGRlbGV0ZSB0aWNrLmxhYmVsO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnB1c2godGljayk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdGlja1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciBvcHRpb25UaWNrcyA9IG1lLm9wdGlvbnMudGlja3MubWlub3I7XG5cblx0XHQvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGJ5IGxhYmVsIGluIGF4aXMgZGlyZWN0aW9uLlxuXHRcdHZhciByb3QgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXHRcdHZhciBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcblx0XHR2YXIgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG5cblx0XHR2YXIgcGFkZGluZyA9IG9wdGlvblRpY2tzLmF1dG9Ta2lwUGFkZGluZyB8fCAwO1xuXHRcdHZhciB3ID0gKG1lLmxvbmdlc3RMYWJlbFdpZHRoICsgcGFkZGluZykgfHwgMDtcblxuXHRcdHZhciB0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQob3B0aW9uVGlja3MpO1xuXHRcdHZhciBoID0gKG1lLl9tYXhMYWJlbExpbmVzICogdGlja0ZvbnQubGluZUhlaWdodCArIHBhZGRpbmcpIHx8IDA7XG5cblx0XHQvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGZvciAxIHRpY2sgaW4gYXhpcyBkaXJlY3Rpb24uXG5cdFx0cmV0dXJuIGlzSG9yaXpvbnRhbFxuXHRcdFx0PyBoICogY29zID4gdyAqIHNpbiA/IHcgLyBjb3MgOiBoIC8gc2luXG5cdFx0XHQ6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBkaXNwbGF5ID0gbWUub3B0aW9ucy5kaXNwbGF5O1xuXHRcdHZhciBpLCBpbGVuLCBtZXRhO1xuXG5cdFx0aWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuXHRcdFx0cmV0dXJuICEhZGlzcGxheTtcblx0XHR9XG5cblx0XHQvLyBXaGVuICdhdXRvJywgdGhlIHNjYWxlIGlzIHZpc2libGUgaWYgYXQgbGVhc3Qgb25lIGFzc29jaWF0ZWQgZGF0YXNldCBpcyB2aXNpYmxlLlxuXHRcdGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcblx0XHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0XHRpZiAobWV0YS54QXhpc0lEID09PSBtZS5pZCB8fCBtZXRhLnlBeGlzSUQgPT09IG1lLmlkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFjdHVhbGx5IGRyYXcgdGhlIHNjYWxlIG9uIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0QXJlYSAtIHRoZSBhcmVhIG9mIHRoZSBjaGFydCB0byBkcmF3IGZ1bGwgZ3JpZCBsaW5lcyBvblxuXHQgKi9cblx0ZHJhdzogZnVuY3Rpb24oY2hhcnRBcmVhKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cblx0XHRpZiAoIW1lLl9pc1Zpc2libGUoKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjaGFydCA9IG1lLmNoYXJ0O1xuXHRcdHZhciBjb250ZXh0ID0gbWUuY3R4O1xuXHRcdHZhciBnbG9iYWxEZWZhdWx0cyA9IGNvcmVfZGVmYXVsdHMuZ2xvYmFsO1xuXHRcdHZhciBkZWZhdWx0Rm9udENvbG9yID0gZ2xvYmFsRGVmYXVsdHMuZGVmYXVsdEZvbnRDb2xvcjtcblx0XHR2YXIgb3B0aW9uVGlja3MgPSBvcHRpb25zLnRpY2tzLm1pbm9yO1xuXHRcdHZhciBvcHRpb25NYWpvclRpY2tzID0gb3B0aW9ucy50aWNrcy5tYWpvciB8fCBvcHRpb25UaWNrcztcblx0XHR2YXIgZ3JpZExpbmVzID0gb3B0aW9ucy5ncmlkTGluZXM7XG5cdFx0dmFyIHNjYWxlTGFiZWwgPSBvcHRpb25zLnNjYWxlTGFiZWw7XG5cdFx0dmFyIHBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcblxuXHRcdHZhciBpc1JvdGF0ZWQgPSBtZS5sYWJlbFJvdGF0aW9uICE9PSAwO1xuXHRcdHZhciBpc01pcnJvcmVkID0gb3B0aW9uVGlja3MubWlycm9yO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblxuXHRcdHZhciBwYXJzZUZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250O1xuXHRcdHZhciB0aWNrcyA9IG9wdGlvblRpY2tzLmRpc3BsYXkgJiYgb3B0aW9uVGlja3MuYXV0b1NraXAgPyBtZS5fYXV0b1NraXAobWUuZ2V0VGlja3MoKSkgOiBtZS5nZXRUaWNrcygpO1xuXHRcdHZhciB0aWNrRm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkOShvcHRpb25UaWNrcy5mb250Q29sb3IsIGRlZmF1bHRGb250Q29sb3IpO1xuXHRcdHZhciB0aWNrRm9udCA9IHBhcnNlRm9udChvcHRpb25UaWNrcyk7XG5cdFx0dmFyIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuXHRcdHZhciBtYWpvclRpY2tGb250Q29sb3IgPSB2YWx1ZU9yRGVmYXVsdCQ5KG9wdGlvbk1ham9yVGlja3MuZm9udENvbG9yLCBkZWZhdWx0Rm9udENvbG9yKTtcblx0XHR2YXIgbWFqb3JUaWNrRm9udCA9IHBhcnNlRm9udChvcHRpb25NYWpvclRpY2tzKTtcblx0XHR2YXIgdGlja1BhZGRpbmcgPSBvcHRpb25UaWNrcy5wYWRkaW5nO1xuXHRcdHZhciBsYWJlbE9mZnNldCA9IG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuXG5cdFx0dmFyIHRsID0gZ3JpZExpbmVzLmRyYXdUaWNrcyA/IGdyaWRMaW5lcy50aWNrTWFya0xlbmd0aCA6IDA7XG5cblx0XHR2YXIgc2NhbGVMYWJlbEZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JDkoc2NhbGVMYWJlbC5mb250Q29sb3IsIGRlZmF1bHRGb250Q29sb3IpO1xuXHRcdHZhciBzY2FsZUxhYmVsRm9udCA9IHBhcnNlRm9udChzY2FsZUxhYmVsKTtcblx0XHR2YXIgc2NhbGVMYWJlbFBhZGRpbmcgPSBoZWxwZXJzJDEub3B0aW9ucy50b1BhZGRpbmcoc2NhbGVMYWJlbC5wYWRkaW5nKTtcblx0XHR2YXIgbGFiZWxSb3RhdGlvblJhZGlhbnMgPSBoZWxwZXJzJDEudG9SYWRpYW5zKG1lLmxhYmVsUm90YXRpb24pO1xuXG5cdFx0dmFyIGl0ZW1zVG9EcmF3ID0gW107XG5cblx0XHR2YXIgYXhpc1dpZHRoID0gZ3JpZExpbmVzLmRyYXdCb3JkZXIgPyB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgMCwgMCkgOiAwO1xuXHRcdHZhciBhbGlnblBpeGVsID0gaGVscGVycyQxLl9hbGlnblBpeGVsO1xuXHRcdHZhciBib3JkZXJWYWx1ZSwgdGlja1N0YXJ0LCB0aWNrRW5kO1xuXG5cdFx0aWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5ib3R0b20sIGF4aXNXaWR0aCk7XG5cdFx0XHR0aWNrU3RhcnQgPSBtZS5ib3R0b20gLSB0bDtcblx0XHRcdHRpY2tFbmQgPSBib3JkZXJWYWx1ZSAtIGF4aXNXaWR0aCAvIDI7XG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcblx0XHRcdGJvcmRlclZhbHVlID0gYWxpZ25QaXhlbChjaGFydCwgbWUudG9wLCBheGlzV2lkdGgpO1xuXHRcdFx0dGlja1N0YXJ0ID0gYm9yZGVyVmFsdWUgKyBheGlzV2lkdGggLyAyO1xuXHRcdFx0dGlja0VuZCA9IG1lLnRvcCArIHRsO1xuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuXHRcdFx0Ym9yZGVyVmFsdWUgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5yaWdodCwgYXhpc1dpZHRoKTtcblx0XHRcdHRpY2tTdGFydCA9IG1lLnJpZ2h0IC0gdGw7XG5cdFx0XHR0aWNrRW5kID0gYm9yZGVyVmFsdWUgLSBheGlzV2lkdGggLyAyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRib3JkZXJWYWx1ZSA9IGFsaWduUGl4ZWwoY2hhcnQsIG1lLmxlZnQsIGF4aXNXaWR0aCk7XG5cdFx0XHR0aWNrU3RhcnQgPSBib3JkZXJWYWx1ZSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHR0aWNrRW5kID0gbWUubGVmdCArIHRsO1xuXHRcdH1cblxuXHRcdHZhciBlcHNpbG9uID0gMC4wMDAwMDAxOyAvLyAwLjAwMDAwMDEgaXMgbWFyZ2luIGluIHBpeGVscyBmb3IgQWNjdW11bGF0ZWQgZXJyb3IuXG5cblx0XHRoZWxwZXJzJDEuZWFjaCh0aWNrcywgZnVuY3Rpb24odGljaywgaW5kZXgpIHtcblx0XHRcdC8vIGF1dG9za2lwcGVyIHNraXBwZWQgdGhpcyB0aWNrICgjNDYzNSlcblx0XHRcdGlmIChoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZih0aWNrLmxhYmVsKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsYWJlbCA9IHRpY2subGFiZWw7XG5cdFx0XHR2YXIgbGluZVdpZHRoLCBsaW5lQ29sb3IsIGJvcmRlckRhc2gsIGJvcmRlckRhc2hPZmZzZXQ7XG5cdFx0XHRpZiAoaW5kZXggPT09IG1lLnplcm9MaW5lSW5kZXggJiYgb3B0aW9ucy5vZmZzZXQgPT09IGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMpIHtcblx0XHRcdFx0Ly8gRHJhdyB0aGUgZmlyc3QgaW5kZXggc3BlY2lhbGx5XG5cdFx0XHRcdGxpbmVXaWR0aCA9IGdyaWRMaW5lcy56ZXJvTGluZVdpZHRoO1xuXHRcdFx0XHRsaW5lQ29sb3IgPSBncmlkTGluZXMuemVyb0xpbmVDb2xvcjtcblx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy56ZXJvTGluZUJvcmRlckRhc2ggfHwgW107XG5cdFx0XHRcdGJvcmRlckRhc2hPZmZzZXQgPSBncmlkTGluZXMuemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMubGluZVdpZHRoLCBpbmRleCk7XG5cdFx0XHRcdGxpbmVDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMuY29sb3IsIGluZGV4KTtcblx0XHRcdFx0Ym9yZGVyRGFzaCA9IGdyaWRMaW5lcy5ib3JkZXJEYXNoIHx8IFtdO1xuXHRcdFx0XHRib3JkZXJEYXNoT2Zmc2V0ID0gZ3JpZExpbmVzLmJvcmRlckRhc2hPZmZzZXQgfHwgMC4wO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21tb24gcHJvcGVydGllc1xuXHRcdFx0dmFyIHR4MSwgdHkxLCB0eDIsIHR5MiwgeDEsIHkxLCB4MiwgeTIsIGxhYmVsWCwgbGFiZWxZLCB0ZXh0T2Zmc2V0LCB0ZXh0QWxpZ247XG5cdFx0XHR2YXIgbGFiZWxDb3VudCA9IGhlbHBlcnMkMS5pc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG5cdFx0XHR2YXIgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZShtZSwgaW5kZXgsIGdyaWRMaW5lcy5vZmZzZXRHcmlkTGluZXMpO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdHZhciBsYWJlbFlPZmZzZXQgPSB0bCArIHRpY2tQYWRkaW5nO1xuXG5cdFx0XHRcdGlmIChsaW5lVmFsdWUgPCBtZS5sZWZ0IC0gZXBzaWxvbikge1xuXHRcdFx0XHRcdGxpbmVDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnblBpeGVsKGNoYXJ0LCBsaW5lVmFsdWUsIGxpbmVXaWR0aCk7XG5cdFx0XHRcdHR5MSA9IHRpY2tTdGFydDtcblx0XHRcdFx0dHkyID0gdGlja0VuZDtcblx0XHRcdFx0bGFiZWxYID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSArIGxhYmVsT2Zmc2V0OyAvLyB4IHZhbHVlcyBmb3Igb3B0aW9uVGlja3MgKG5lZWQgdG8gY29uc2lkZXIgb2Zmc2V0TGFiZWwgb3B0aW9uKVxuXG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcblx0XHRcdFx0XHR5MSA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS50b3AsIGF4aXNXaWR0aCkgKyBheGlzV2lkdGggLyAyO1xuXHRcdFx0XHRcdHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcblx0XHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKCghaXNSb3RhdGVkID8gMC41IDogMSkgLSBsYWJlbENvdW50KSAqIGxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gIWlzUm90YXRlZCA/ICdjZW50ZXInIDogJ2xlZnQnO1xuXHRcdFx0XHRcdGxhYmVsWSA9IG1lLmJvdHRvbSAtIGxhYmVsWU9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5MSA9IGNoYXJ0QXJlYS50b3A7XG5cdFx0XHRcdFx0eTIgPSBhbGlnblBpeGVsKGNoYXJ0LCBjaGFydEFyZWEuYm90dG9tLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcblx0XHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKCFpc1JvdGF0ZWQgPyAwLjUgOiAwKSAqIGxpbmVIZWlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gIWlzUm90YXRlZCA/ICdjZW50ZXInIDogJ3JpZ2h0Jztcblx0XHRcdFx0XHRsYWJlbFkgPSBtZS50b3AgKyBsYWJlbFlPZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBsYWJlbFhPZmZzZXQgPSAoaXNNaXJyb3JlZCA/IDAgOiB0bCkgKyB0aWNrUGFkZGluZztcblxuXHRcdFx0XHRpZiAobGluZVZhbHVlIDwgbWUudG9wIC0gZXBzaWxvbikge1xuXHRcdFx0XHRcdGxpbmVDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHR4MSA9IHRpY2tTdGFydDtcblx0XHRcdFx0dHgyID0gdGlja0VuZDtcblx0XHRcdFx0dHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcblx0XHRcdFx0bGFiZWxZID0gbWUuZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSArIGxhYmVsT2Zmc2V0O1xuXHRcdFx0XHR0ZXh0T2Zmc2V0ID0gKDEgLSBsYWJlbENvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuXG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG5cdFx0XHRcdFx0eDEgPSBhbGlnblBpeGVsKGNoYXJ0LCBjaGFydEFyZWEubGVmdCwgYXhpc1dpZHRoKSArIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHRcdFx0eDIgPSBjaGFydEFyZWEucmlnaHQ7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gaXNNaXJyb3JlZCA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cdFx0XHRcdFx0bGFiZWxYID0gbWUucmlnaHQgLSBsYWJlbFhPZmZzZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eDEgPSBjaGFydEFyZWEubGVmdDtcblx0XHRcdFx0XHR4MiA9IGFsaWduUGl4ZWwoY2hhcnQsIGNoYXJ0QXJlYS5yaWdodCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG5cdFx0XHRcdFx0dGV4dEFsaWduID0gaXNNaXJyb3JlZCA/ICdyaWdodCcgOiAnbGVmdCc7XG5cdFx0XHRcdFx0bGFiZWxYID0gbWUubGVmdCArIGxhYmVsWE9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpdGVtc1RvRHJhdy5wdXNoKHtcblx0XHRcdFx0dHgxOiB0eDEsXG5cdFx0XHRcdHR5MTogdHkxLFxuXHRcdFx0XHR0eDI6IHR4Mixcblx0XHRcdFx0dHkyOiB0eTIsXG5cdFx0XHRcdHgxOiB4MSxcblx0XHRcdFx0eTE6IHkxLFxuXHRcdFx0XHR4MjogeDIsXG5cdFx0XHRcdHkyOiB5Mixcblx0XHRcdFx0bGFiZWxYOiBsYWJlbFgsXG5cdFx0XHRcdGxhYmVsWTogbGFiZWxZLFxuXHRcdFx0XHRnbFdpZHRoOiBsaW5lV2lkdGgsXG5cdFx0XHRcdGdsQ29sb3I6IGxpbmVDb2xvcixcblx0XHRcdFx0Z2xCb3JkZXJEYXNoOiBib3JkZXJEYXNoLFxuXHRcdFx0XHRnbEJvcmRlckRhc2hPZmZzZXQ6IGJvcmRlckRhc2hPZmZzZXQsXG5cdFx0XHRcdHJvdGF0aW9uOiAtMSAqIGxhYmVsUm90YXRpb25SYWRpYW5zLFxuXHRcdFx0XHRsYWJlbDogbGFiZWwsXG5cdFx0XHRcdG1ham9yOiB0aWNrLm1ham9yLFxuXHRcdFx0XHR0ZXh0T2Zmc2V0OiB0ZXh0T2Zmc2V0LFxuXHRcdFx0XHR0ZXh0QWxpZ246IHRleHRBbGlnblxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBEcmF3IGFsbCBvZiB0aGUgdGljayBsYWJlbHMsIHRpY2sgbWFya3MsIGFuZCBncmlkIGxpbmVzIGF0IHRoZSBjb3JyZWN0IHBsYWNlc1xuXHRcdGhlbHBlcnMkMS5lYWNoKGl0ZW1zVG9EcmF3LCBmdW5jdGlvbihpdGVtVG9EcmF3KSB7XG5cdFx0XHR2YXIgZ2xXaWR0aCA9IGl0ZW1Ub0RyYXcuZ2xXaWR0aDtcblx0XHRcdHZhciBnbENvbG9yID0gaXRlbVRvRHJhdy5nbENvbG9yO1xuXG5cdFx0XHRpZiAoZ3JpZExpbmVzLmRpc3BsYXkgJiYgZ2xXaWR0aCAmJiBnbENvbG9yKSB7XG5cdFx0XHRcdGNvbnRleHQuc2F2ZSgpO1xuXHRcdFx0XHRjb250ZXh0LmxpbmVXaWR0aCA9IGdsV2lkdGg7XG5cdFx0XHRcdGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBnbENvbG9yO1xuXHRcdFx0XHRpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuXHRcdFx0XHRcdGNvbnRleHQuc2V0TGluZURhc2goaXRlbVRvRHJhdy5nbEJvcmRlckRhc2gpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZURhc2hPZmZzZXQgPSBpdGVtVG9EcmF3LmdsQm9yZGVyRGFzaE9mZnNldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cblx0XHRcdFx0aWYgKGdyaWRMaW5lcy5kcmF3VGlja3MpIHtcblx0XHRcdFx0XHRjb250ZXh0Lm1vdmVUbyhpdGVtVG9EcmF3LnR4MSwgaXRlbVRvRHJhdy50eTEpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZVRvKGl0ZW1Ub0RyYXcudHgyLCBpdGVtVG9EcmF3LnR5Mik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZ3JpZExpbmVzLmRyYXdPbkNoYXJ0QXJlYSkge1xuXHRcdFx0XHRcdGNvbnRleHQubW92ZVRvKGl0ZW1Ub0RyYXcueDEsIGl0ZW1Ub0RyYXcueTEpO1xuXHRcdFx0XHRcdGNvbnRleHQubGluZVRvKGl0ZW1Ub0RyYXcueDIsIGl0ZW1Ub0RyYXcueTIpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29udGV4dC5zdHJva2UoKTtcblx0XHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBkcmF3IHRleHQgaW4gdGhlIGNvcnJlY3QgY29sb3IgYW5kIGZvbnRcblx0XHRcdFx0Y29udGV4dC5zYXZlKCk7XG5cdFx0XHRcdGNvbnRleHQudHJhbnNsYXRlKGl0ZW1Ub0RyYXcubGFiZWxYLCBpdGVtVG9EcmF3LmxhYmVsWSk7XG5cdFx0XHRcdGNvbnRleHQucm90YXRlKGl0ZW1Ub0RyYXcucm90YXRpb24pO1xuXHRcdFx0XHRjb250ZXh0LmZvbnQgPSBpdGVtVG9EcmF3Lm1ham9yID8gbWFqb3JUaWNrRm9udC5zdHJpbmcgOiB0aWNrRm9udC5zdHJpbmc7XG5cdFx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gaXRlbVRvRHJhdy5tYWpvciA/IG1ham9yVGlja0ZvbnRDb2xvciA6IHRpY2tGb250Q29sb3I7XG5cdFx0XHRcdGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cdFx0XHRcdGNvbnRleHQudGV4dEFsaWduID0gaXRlbVRvRHJhdy50ZXh0QWxpZ247XG5cblx0XHRcdFx0dmFyIGxhYmVsID0gaXRlbVRvRHJhdy5sYWJlbDtcblx0XHRcdFx0dmFyIHkgPSBpdGVtVG9EcmF3LnRleHRPZmZzZXQ7XG5cdFx0XHRcdGlmIChoZWxwZXJzJDEuaXNBcnJheShsYWJlbCkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxhYmVsLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0XHQvLyBXZSBqdXN0IG1ha2Ugc3VyZSB0aGUgbXVsdGlsaW5lIGVsZW1lbnQgaXMgYSBzdHJpbmcgaGVyZS4uXG5cdFx0XHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KCcnICsgbGFiZWxbaV0sIDAsIHkpO1xuXHRcdFx0XHRcdFx0eSArPSBsaW5lSGVpZ2h0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250ZXh0LmZpbGxUZXh0KGxhYmVsLCAwLCB5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250ZXh0LnJlc3RvcmUoKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChzY2FsZUxhYmVsLmRpc3BsYXkpIHtcblx0XHRcdC8vIERyYXcgdGhlIHNjYWxlIGxhYmVsXG5cdFx0XHR2YXIgc2NhbGVMYWJlbFg7XG5cdFx0XHR2YXIgc2NhbGVMYWJlbFk7XG5cdFx0XHR2YXIgcm90YXRpb24gPSAwO1xuXHRcdFx0dmFyIGhhbGZMaW5lSGVpZ2h0ID0gc2NhbGVMYWJlbEZvbnQubGluZUhlaWdodCAvIDI7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0c2NhbGVMYWJlbFggPSBtZS5sZWZ0ICsgKChtZS5yaWdodCAtIG1lLmxlZnQpIC8gMik7IC8vIG1pZHBvaW50IG9mIHRoZSB3aWR0aFxuXHRcdFx0XHRzY2FsZUxhYmVsWSA9IHBvc2l0aW9uID09PSAnYm90dG9tJ1xuXHRcdFx0XHRcdD8gbWUuYm90dG9tIC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy5ib3R0b21cblx0XHRcdFx0XHQ6IG1lLnRvcCArIGhhbGZMaW5lSGVpZ2h0ICsgc2NhbGVMYWJlbFBhZGRpbmcudG9wO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGlzTGVmdCA9IHBvc2l0aW9uID09PSAnbGVmdCc7XG5cdFx0XHRcdHNjYWxlTGFiZWxYID0gaXNMZWZ0XG5cdFx0XHRcdFx0PyBtZS5sZWZ0ICsgaGFsZkxpbmVIZWlnaHQgKyBzY2FsZUxhYmVsUGFkZGluZy50b3Bcblx0XHRcdFx0XHQ6IG1lLnJpZ2h0IC0gaGFsZkxpbmVIZWlnaHQgLSBzY2FsZUxhYmVsUGFkZGluZy50b3A7XG5cdFx0XHRcdHNjYWxlTGFiZWxZID0gbWUudG9wICsgKChtZS5ib3R0b20gLSBtZS50b3ApIC8gMik7XG5cdFx0XHRcdHJvdGF0aW9uID0gaXNMZWZ0ID8gLTAuNSAqIE1hdGguUEkgOiAwLjUgKiBNYXRoLlBJO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250ZXh0LnNhdmUoKTtcblx0XHRcdGNvbnRleHQudHJhbnNsYXRlKHNjYWxlTGFiZWxYLCBzY2FsZUxhYmVsWSk7XG5cdFx0XHRjb250ZXh0LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuXHRcdFx0Y29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdGNvbnRleHQuZmlsbFN0eWxlID0gc2NhbGVMYWJlbEZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRjb250ZXh0LmZvbnQgPSBzY2FsZUxhYmVsRm9udC5zdHJpbmc7XG5cdFx0XHRjb250ZXh0LmZpbGxUZXh0KHNjYWxlTGFiZWwubGFiZWxTdHJpbmcsIDAsIDApO1xuXHRcdFx0Y29udGV4dC5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGF4aXNXaWR0aCkge1xuXHRcdFx0Ly8gRHJhdyB0aGUgbGluZSBhdCB0aGUgZWRnZSBvZiB0aGUgYXhpc1xuXHRcdFx0dmFyIGZpcnN0TGluZVdpZHRoID0gYXhpc1dpZHRoO1xuXHRcdFx0dmFyIGxhc3RMaW5lV2lkdGggPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQoZ3JpZExpbmVzLmxpbmVXaWR0aCwgdGlja3MubGVuZ3RoIC0gMSwgMCk7XG5cdFx0XHR2YXIgeDEsIHgyLCB5MSwgeTI7XG5cblx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0eDEgPSBhbGlnblBpeGVsKGNoYXJ0LCBtZS5sZWZ0LCBmaXJzdExpbmVXaWR0aCkgLSBmaXJzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHgyID0gYWxpZ25QaXhlbChjaGFydCwgbWUucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHkxID0geTIgPSBib3JkZXJWYWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHkxID0gYWxpZ25QaXhlbChjaGFydCwgbWUudG9wLCBmaXJzdExpbmVXaWR0aCkgLSBmaXJzdExpbmVXaWR0aCAvIDI7XG5cdFx0XHRcdHkyID0gYWxpZ25QaXhlbChjaGFydCwgbWUuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuXHRcdFx0XHR4MSA9IHgyID0gYm9yZGVyVmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRleHQubGluZVdpZHRoID0gYXhpc1dpZHRoO1xuXHRcdFx0Y29udGV4dC5zdHJva2VTdHlsZSA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdChncmlkTGluZXMuY29sb3IsIDApO1xuXHRcdFx0Y29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdGNvbnRleHQubW92ZVRvKHgxLCB5MSk7XG5cdFx0XHRjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuXHRcdFx0Y29udGV4dC5zdHJva2UoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcblx0cG9zaXRpb246ICdib3R0b20nXG59O1xuXG52YXIgc2NhbGVfY2F0ZWdvcnkgPSBjb3JlX3NjYWxlLmV4dGVuZCh7XG5cdC8qKlxuXHQqIEludGVybmFsIGZ1bmN0aW9uIHRvIGdldCB0aGUgY29ycmVjdCBsYWJlbHMuIElmIGRhdGEueExhYmVscyBvciBkYXRhLnlMYWJlbHMgYXJlIGRlZmluZWQsIHVzZSB0aG9zZVxuXHQqIGVsc2UgZmFsbCBiYWNrIHRvIGRhdGEubGFiZWxzXG5cdCogQHByaXZhdGVcblx0Ki9cblx0Z2V0TGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHM7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG5cdFx0bWUubWluSW5kZXggPSAwO1xuXHRcdG1lLm1heEluZGV4ID0gbGFiZWxzLmxlbmd0aCAtIDE7XG5cdFx0dmFyIGZpbmRJbmRleDtcblxuXHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtaW4gdmFsdWVcblx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1lLm9wdGlvbnMudGlja3MubWluKTtcblx0XHRcdG1lLm1pbkluZGV4ID0gZmluZEluZGV4ICE9PSAtMSA/IGZpbmRJbmRleCA6IG1lLm1pbkluZGV4O1xuXHRcdH1cblxuXHRcdGlmIChtZS5vcHRpb25zLnRpY2tzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvLyB1c2VyIHNwZWNpZmllZCBtYXggdmFsdWVcblx0XHRcdGZpbmRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1lLm9wdGlvbnMudGlja3MubWF4KTtcblx0XHRcdG1lLm1heEluZGV4ID0gZmluZEluZGV4ICE9PSAtMSA/IGZpbmRJbmRleCA6IG1lLm1heEluZGV4O1xuXHRcdH1cblxuXHRcdG1lLm1pbiA9IGxhYmVsc1ttZS5taW5JbmRleF07XG5cdFx0bWUubWF4ID0gbGFiZWxzW21lLm1heEluZGV4XTtcblx0fSxcblxuXHRidWlsZFRpY2tzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsYWJlbHMgPSBtZS5nZXRMYWJlbHMoKTtcblx0XHQvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxuXHRcdG1lLnRpY2tzID0gKG1lLm1pbkluZGV4ID09PSAwICYmIG1lLm1heEluZGV4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWUubWluSW5kZXgsIG1lLm1heEluZGV4ICsgMSk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cblx0XHRpZiAoY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLl9nZXRWYWx1ZVNjYWxlSWQoKSA9PT0gbWUuaWQpIHtcblx0XHRcdHJldHVybiBtZS5nZXRSaWdodFZhbHVlKGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lLnRpY2tzW2luZGV4IC0gbWUubWluSW5kZXhdO1xuXHR9LFxuXG5cdC8vIFVzZWQgdG8gZ2V0IGRhdGEgdmFsdWUgbG9jYXRpb25zLiAgVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvZmZzZXQgPSBtZS5vcHRpb25zLm9mZnNldDtcblx0XHQvLyAxIGlzIGFkZGVkIGJlY2F1c2Ugd2UgbmVlZCB0aGUgbGVuZ3RoIGJ1dCB3ZSBoYXZlIHRoZSBpbmRleGVzXG5cdFx0dmFyIG9mZnNldEFtdCA9IE1hdGgubWF4KChtZS5tYXhJbmRleCArIDEgLSBtZS5taW5JbmRleCAtIChvZmZzZXQgPyAwIDogMSkpLCAxKTtcblxuXHRcdC8vIElmIHZhbHVlIGlzIGEgZGF0YSBvYmplY3QsIHRoZW4gaW5kZXggaXMgdGhlIGluZGV4IGluIHRoZSBkYXRhIGFycmF5LFxuXHRcdC8vIG5vdCB0aGUgaW5kZXggb2YgdGhlIHNjYWxlLiBXZSBuZWVkIHRvIGNoYW5nZSB0aGF0LlxuXHRcdHZhciB2YWx1ZUNhdGVnb3J5O1xuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG5cdFx0XHR2YWx1ZUNhdGVnb3J5ID0gbWUuaXNIb3Jpem9udGFsKCkgPyB2YWx1ZS54IDogdmFsdWUueTtcblx0XHR9XG5cdFx0aWYgKHZhbHVlQ2F0ZWdvcnkgIT09IHVuZGVmaW5lZCB8fCAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBpc05hTihpbmRleCkpKSB7XG5cdFx0XHR2YXIgbGFiZWxzID0gbWUuZ2V0TGFiZWxzKCk7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlQ2F0ZWdvcnkgfHwgdmFsdWU7XG5cdFx0XHR2YXIgaWR4ID0gbGFiZWxzLmluZGV4T2YodmFsdWUpO1xuXHRcdFx0aW5kZXggPSBpZHggIT09IC0xID8gaWR4IDogaW5kZXg7XG5cdFx0fVxuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHR2YXIgdmFsdWVXaWR0aCA9IG1lLndpZHRoIC8gb2Zmc2V0QW10O1xuXHRcdFx0dmFyIHdpZHRoT2Zmc2V0ID0gKHZhbHVlV2lkdGggKiAoaW5kZXggLSBtZS5taW5JbmRleCkpO1xuXG5cdFx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRcdHdpZHRoT2Zmc2V0ICs9ICh2YWx1ZVdpZHRoIC8gMik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtZS5sZWZ0ICsgd2lkdGhPZmZzZXQ7XG5cdFx0fVxuXHRcdHZhciB2YWx1ZUhlaWdodCA9IG1lLmhlaWdodCAvIG9mZnNldEFtdDtcblx0XHR2YXIgaGVpZ2h0T2Zmc2V0ID0gKHZhbHVlSGVpZ2h0ICogKGluZGV4IC0gbWUubWluSW5kZXgpKTtcblxuXHRcdGlmIChvZmZzZXQpIHtcblx0XHRcdGhlaWdodE9mZnNldCArPSAodmFsdWVIZWlnaHQgLyAyKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWUudG9wICsgaGVpZ2h0T2Zmc2V0O1xuXHR9LFxuXG5cdGdldFBpeGVsRm9yVGljazogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLCBpbmRleCArIHRoaXMubWluSW5kZXgsIG51bGwpO1xuXHR9LFxuXG5cdGdldFZhbHVlRm9yUGl4ZWw6IGZ1bmN0aW9uKHBpeGVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb2Zmc2V0ID0gbWUub3B0aW9ucy5vZmZzZXQ7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvZmZzZXRBbXQgPSBNYXRoLm1heCgobWUuX3RpY2tzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSkpLCAxKTtcblx0XHR2YXIgaG9yeiA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdHZhciB2YWx1ZURpbWVuc2lvbiA9IChob3J6ID8gbWUud2lkdGggOiBtZS5oZWlnaHQpIC8gb2Zmc2V0QW10O1xuXG5cdFx0cGl4ZWwgLT0gaG9yeiA/IG1lLmxlZnQgOiBtZS50b3A7XG5cblx0XHRpZiAob2Zmc2V0KSB7XG5cdFx0XHRwaXhlbCAtPSAodmFsdWVEaW1lbnNpb24gLyAyKTtcblx0XHR9XG5cblx0XHRpZiAocGl4ZWwgPD0gMCkge1xuXHRcdFx0dmFsdWUgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQocGl4ZWwgLyB2YWx1ZURpbWVuc2lvbik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlICsgbWUubWluSW5kZXg7XG5cdH0sXG5cblx0Z2V0QmFzZVBpeGVsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5ib3R0b207XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMgPSBkZWZhdWx0Q29uZmlnO1xuc2NhbGVfY2F0ZWdvcnkuX2RlZmF1bHRzID0gX2RlZmF1bHRzO1xuXG52YXIgbm9vcCA9IGhlbHBlcnMkMS5ub29wO1xudmFyIGlzTnVsbE9yVW5kZWYgPSBoZWxwZXJzJDEuaXNOdWxsT3JVbmRlZjtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsaW5lYXIgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdGljayB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG5cdHZhciB0aWNrcyA9IFtdO1xuXHQvLyBUbyBnZXQgYSBcIm5pY2VcIiB2YWx1ZSBmb3IgdGhlIHRpY2sgc3BhY2luZywgd2Ugd2lsbCB1c2UgdGhlIGFwcHJvcHJpYXRlbHkgbmFtZWRcblx0Ly8gXCJuaWNlIG51bWJlclwiIGFsZ29yaXRobS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDY4ODEvbmljZS1sYWJlbC1hbGdvcml0aG0tZm9yLWNoYXJ0cy13aXRoLW1pbmltdW0tdGlja3Ncblx0Ly8gZm9yIGRldGFpbHMuXG5cblx0dmFyIE1JTl9TUEFDSU5HID0gMWUtMTQ7XG5cdHZhciBzdGVwU2l6ZSA9IGdlbmVyYXRpb25PcHRpb25zLnN0ZXBTaXplO1xuXHR2YXIgdW5pdCA9IHN0ZXBTaXplIHx8IDE7XG5cdHZhciBtYXhOdW1TcGFjZXMgPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXhUaWNrcyAtIDE7XG5cdHZhciBtaW4gPSBnZW5lcmF0aW9uT3B0aW9ucy5taW47XG5cdHZhciBtYXggPSBnZW5lcmF0aW9uT3B0aW9ucy5tYXg7XG5cdHZhciBwcmVjaXNpb24gPSBnZW5lcmF0aW9uT3B0aW9ucy5wcmVjaXNpb247XG5cdHZhciBybWluID0gZGF0YVJhbmdlLm1pbjtcblx0dmFyIHJtYXggPSBkYXRhUmFuZ2UubWF4O1xuXHR2YXIgc3BhY2luZyA9IGhlbHBlcnMkMS5uaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhOdW1TcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG5cdHZhciBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcblxuXHQvLyBCZXlvbmQgTUlOX1NQQUNJTkcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBiZWluZyB0byBsb3NlIHByZWNpc2lvblxuXHQvLyBzdWNoIHRoYXQgd2UgY2FuJ3QgZG8gdGhlIG1hdGggbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRpY2tzXG5cdGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgaXNOdWxsT3JVbmRlZihtaW4pICYmIGlzTnVsbE9yVW5kZWYobWF4KSkge1xuXHRcdHJldHVybiBbcm1pbiwgcm1heF07XG5cdH1cblxuXHRudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG5cdGlmIChudW1TcGFjZXMgPiBtYXhOdW1TcGFjZXMpIHtcblx0XHQvLyBJZiB0aGUgY2FsY3VsYXRlZCBudW0gb2Ygc3BhY2VzIGV4Y2VlZHMgbWF4TnVtU3BhY2VzLCByZWNhbGN1bGF0ZSBpdFxuXHRcdHNwYWNpbmcgPSBoZWxwZXJzJDEubmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4TnVtU3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuXHR9XG5cblx0aWYgKHN0ZXBTaXplIHx8IGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuXHRcdC8vIElmIGEgcHJlY2lzaW9uIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBmYWN0b3IgYmFzZWQgb24gc3BhY2luZ1xuXHRcdGZhY3RvciA9IE1hdGgucG93KDEwLCBoZWxwZXJzJDEuX2RlY2ltYWxQbGFjZXMoc3BhY2luZykpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRoZSB1c2VyIHNwZWNpZmllZCBhIHByZWNpc2lvbiwgcm91bmQgdG8gdGhhdCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcblx0XHRmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcblx0XHRzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXHR9XG5cblx0bmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcblx0bmljZU1heCA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgKiBzcGFjaW5nO1xuXG5cdC8vIElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBpcyBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cblx0aWYgKHN0ZXBTaXplKSB7XG5cdFx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgd2hvbGUgbnVtYmVyLCB1c2UgaXQuXG5cdFx0aWYgKCFpc051bGxPclVuZGVmKG1pbikgJiYgaGVscGVycyQxLmFsbW9zdFdob2xlKG1pbiAvIHNwYWNpbmcsIHNwYWNpbmcgLyAxMDAwKSkge1xuXHRcdFx0bmljZU1pbiA9IG1pbjtcblx0XHR9XG5cdFx0aWYgKCFpc051bGxPclVuZGVmKG1heCkgJiYgaGVscGVycyQxLmFsbW9zdFdob2xlKG1heCAvIHNwYWNpbmcsIHNwYWNpbmcgLyAxMDAwKSkge1xuXHRcdFx0bmljZU1heCA9IG1heDtcblx0XHR9XG5cdH1cblxuXHRudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcblx0Ly8gSWYgdmVyeSBjbG9zZSB0byBvdXIgcm91bmRlZCB2YWx1ZSwgdXNlIGl0LlxuXHRpZiAoaGVscGVycyQxLmFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG5cdFx0bnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuXHR9IGVsc2Uge1xuXHRcdG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuXHR9XG5cblx0bmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cdG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuXHR0aWNrcy5wdXNoKGlzTnVsbE9yVW5kZWYobWluKSA/IG5pY2VNaW4gOiBtaW4pO1xuXHRmb3IgKHZhciBqID0gMTsgaiA8IG51bVNwYWNlczsgKytqKSB7XG5cdFx0dGlja3MucHVzaChNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3Rvcik7XG5cdH1cblx0dGlja3MucHVzaChpc051bGxPclVuZGVmKG1heCkgPyBuaWNlTWF4IDogbWF4KTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbnZhciBzY2FsZV9saW5lYXJiYXNlID0gY29yZV9zY2FsZS5leHRlbmQoe1xuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gK3ZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUuZ2V0UmlnaHRWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0fSxcblxuXHRoYW5kbGVUaWNrUmFuZ2VPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG5cdFx0Ly8gSWYgd2UgYXJlIGZvcmNpbmcgaXQgdG8gYmVnaW4gYXQgMCwgYnV0IDAgd2lsbCBhbHJlYWR5IGJlIHJlbmRlcmVkIG9uIHRoZSBjaGFydCxcblx0XHQvLyBkbyBub3RoaW5nIHNpbmNlIHRoYXQgd291bGQgbWFrZSB0aGUgY2hhcnQgd2VpcmQuIElmIHRoZSB1c2VyIHJlYWxseSB3YW50cyBhIHdlaXJkIGNoYXJ0XG5cdFx0Ly8gYXhpcywgdGhleSBjYW4gbWFudWFsbHkgb3ZlcnJpZGUgaXRcblx0XHRpZiAodGlja09wdHMuYmVnaW5BdFplcm8pIHtcblx0XHRcdHZhciBtaW5TaWduID0gaGVscGVycyQxLnNpZ24obWUubWluKTtcblx0XHRcdHZhciBtYXhTaWduID0gaGVscGVycyQxLnNpZ24obWUubWF4KTtcblxuXHRcdFx0aWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG5cdFx0XHRcdC8vIG1vdmUgdGhlIHRvcCB1cCB0byAwXG5cdFx0XHRcdG1lLm1heCA9IDA7XG5cdFx0XHR9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG5cdFx0XHRcdC8vIG1vdmUgdGhlIGJvdHRvbSBkb3duIHRvIDBcblx0XHRcdFx0bWUubWluID0gMDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgc2V0TWluID0gdGlja09wdHMubWluICE9PSB1bmRlZmluZWQgfHwgdGlja09wdHMuc3VnZ2VzdGVkTWluICE9PSB1bmRlZmluZWQ7XG5cdFx0dmFyIHNldE1heCA9IHRpY2tPcHRzLm1heCAhPT0gdW5kZWZpbmVkIHx8IHRpY2tPcHRzLnN1Z2dlc3RlZE1heCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKHRpY2tPcHRzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtZS5taW4gPSB0aWNrT3B0cy5taW47XG5cdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNaW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRtZS5taW4gPSB0aWNrT3B0cy5zdWdnZXN0ZWRNaW47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5taW4gPSBNYXRoLm1pbihtZS5taW4sIHRpY2tPcHRzLnN1Z2dlc3RlZE1pbik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRpY2tPcHRzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5tYXg7XG5cdFx0fSBlbHNlIGlmICh0aWNrT3B0cy5zdWdnZXN0ZWRNYXggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRtZS5tYXggPSB0aWNrT3B0cy5zdWdnZXN0ZWRNYXg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5tYXggPSBNYXRoLm1heChtZS5tYXgsIHRpY2tPcHRzLnN1Z2dlc3RlZE1heCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHNldE1pbiAhPT0gc2V0TWF4KSB7XG5cdFx0XHQvLyBXZSBzZXQgdGhlIG1pbiBvciB0aGUgbWF4IGJ1dCBub3QgYm90aC5cblx0XHRcdC8vIFNvIGVuc3VyZSB0aGF0IG91ciByYW5nZSBpcyBnb29kXG5cdFx0XHQvLyBJbnZlcnRlZCBvciAwIGxlbmd0aCByYW5nZSBjYW4gaGFwcGVuIHdoZW5cblx0XHRcdC8vIHRpY2tzLm1pbiBpcyBzZXQsIGFuZCBubyBkYXRhc2V0cyBhcmUgdmlzaWJsZVxuXHRcdFx0aWYgKG1lLm1pbiA+PSBtZS5tYXgpIHtcblx0XHRcdFx0aWYgKHNldE1pbikge1xuXHRcdFx0XHRcdG1lLm1heCA9IG1lLm1pbiArIDE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWUubWluID0gbWUubWF4IC0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtZS5taW4gPT09IG1lLm1heCkge1xuXHRcdFx0bWUubWF4Kys7XG5cblx0XHRcdGlmICghdGlja09wdHMuYmVnaW5BdFplcm8pIHtcblx0XHRcdFx0bWUubWluLS07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciBzdGVwU2l6ZSA9IHRpY2tPcHRzLnN0ZXBTaXplO1xuXHRcdHZhciBtYXhUaWNrc0xpbWl0ID0gdGlja09wdHMubWF4VGlja3NMaW1pdDtcblx0XHR2YXIgbWF4VGlja3M7XG5cblx0XHRpZiAoc3RlcFNpemUpIHtcblx0XHRcdG1heFRpY2tzID0gTWF0aC5jZWlsKG1lLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IobWUubWluIC8gc3RlcFNpemUpICsgMTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF4VGlja3MgPSBtZS5fY29tcHV0ZVRpY2tMaW1pdCgpO1xuXHRcdFx0bWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG5cdFx0fVxuXG5cdFx0aWYgKG1heFRpY2tzTGltaXQpIHtcblx0XHRcdG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXhUaWNrcztcblx0fSxcblxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblx0fSxcblxuXHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IG5vb3AsXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuXHRcdC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgbWF4IG51bWJlciBvZiB0aWNrcyB3ZSBjYW4gc3VwcG9ydCBpdCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZlxuXHRcdC8vIHRoZSBheGlzIGFyZWEuIEZvciBub3csIHdlIHNheSB0aGF0IHRoZSBtaW5pbXVtIHRpY2sgc3BhY2luZyBpbiBwaXhlbHMgbXVzdCBiZSA0MFxuXHRcdC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXG5cdFx0Ly8gdGhlIGdyYXBoLiBNYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYXQgbGVhc3QgMiB0aWNrc1xuXHRcdHZhciBtYXhUaWNrcyA9IG1lLmdldFRpY2tMaW1pdCgpO1xuXHRcdG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG5cdFx0dmFyIG51bWVyaWNHZW5lcmF0b3JPcHRpb25zID0ge1xuXHRcdFx0bWF4VGlja3M6IG1heFRpY2tzLFxuXHRcdFx0bWluOiB0aWNrT3B0cy5taW4sXG5cdFx0XHRtYXg6IHRpY2tPcHRzLm1heCxcblx0XHRcdHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuXHRcdFx0c3RlcFNpemU6IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5maXhlZFN0ZXBTaXplLCB0aWNrT3B0cy5zdGVwU2l6ZSlcblx0XHR9O1xuXHRcdHZhciB0aWNrcyA9IG1lLnRpY2tzID0gZ2VuZXJhdGVUaWNrcyhudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgbWUpO1xuXG5cdFx0bWUuaGFuZGxlRGlyZWN0aW9uYWxDaGFuZ2VzKCk7XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzIHNpbmNlIHdlIGhhdmUgZXhwYW5kZWQgdGhlXG5cdFx0Ly8gcmFuZ2Ugb2YgdGhlIHNjYWxlXG5cdFx0bWUubWF4ID0gaGVscGVycyQxLm1heCh0aWNrcyk7XG5cdFx0bWUubWluID0gaGVscGVycyQxLm1pbih0aWNrcyk7XG5cblx0XHRpZiAodGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXG5cdFx0XHRtZS5zdGFydCA9IG1lLm1heDtcblx0XHRcdG1lLmVuZCA9IG1lLm1pbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuc3RhcnQgPSBtZS5taW47XG5cdFx0XHRtZS5lbmQgPSBtZS5tYXg7XG5cdFx0fVxuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdG1lLnRpY2tzQXNOdW1iZXJzID0gbWUudGlja3Muc2xpY2UoKTtcblx0XHRtZS56ZXJvTGluZUluZGV4ID0gbWUudGlja3MuaW5kZXhPZigwKTtcblxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwobWUpO1xuXHR9XG59KTtcblxudmFyIGRlZmF1bHRDb25maWckMSA9IHtcblx0cG9zaXRpb246ICdsZWZ0Jyxcblx0dGlja3M6IHtcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxpbmVhclxuXHR9XG59O1xuXG52YXIgc2NhbGVfbGluZWFyID0gc2NhbGVfbGluZWFyYmFzZS5leHRlbmQoe1xuXHRkZXRlcm1pbmVEYXRhTGltaXRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgZGF0YSA9IGNoYXJ0LmRhdGE7XG5cdFx0dmFyIGRhdGFzZXRzID0gZGF0YS5kYXRhc2V0cztcblx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0dmFyIERFRkFVTFRfTUlOID0gMDtcblx0XHR2YXIgREVGQVVMVF9NQVggPSAxO1xuXG5cdFx0ZnVuY3Rpb24gSURNYXRjaGVzKG1ldGEpIHtcblx0XHRcdHJldHVybiBpc0hvcml6b250YWwgPyBtZXRhLnhBeGlzSUQgPT09IG1lLmlkIDogbWV0YS55QXhpc0lEID09PSBtZS5pZDtcblx0XHR9XG5cblx0XHQvLyBGaXJzdCBDYWxjdWxhdGUgdGhlIHJhbmdlXG5cdFx0bWUubWluID0gbnVsbDtcblx0XHRtZS5tYXggPSBudWxsO1xuXG5cdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcblx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0aWYgKGhhc1N0YWNrcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkgJiZcblx0XHRcdFx0XHRtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xuXHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIga2V5ID0gW1xuXHRcdFx0XHRcdG1ldGEudHlwZSxcblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxuXHRcdFx0XHRcdG1ldGEuc3RhY2tcblx0XHRcdFx0XS5qb2luKCcuJyk7XG5cblx0XHRcdFx0aWYgKHZhbHVlc1BlclN0YWNrW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHZhbHVlc1BlclN0YWNrW2tleV0gPSB7XG5cdFx0XHRcdFx0XHRwb3NpdGl2ZVZhbHVlczogW10sXG5cdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlczogW11cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3RvcmUgdGhlc2UgcGVyIHR5cGVcblx0XHRcdFx0dmFyIHBvc2l0aXZlVmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XS5wb3NpdGl2ZVZhbHVlcztcblx0XHRcdFx0dmFyIG5lZ2F0aXZlVmFsdWVzID0gdmFsdWVzUGVyU3RhY2tba2V5XS5uZWdhdGl2ZVZhbHVlcztcblxuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdID0gcG9zaXRpdmVWYWx1ZXNbaW5kZXhdIHx8IDA7XG5cdFx0XHRcdFx0XHRuZWdhdGl2ZVZhbHVlc1tpbmRleF0gPSBuZWdhdGl2ZVZhbHVlc1tpbmRleF0gfHwgMDtcblxuXHRcdFx0XHRcdFx0aWYgKG9wdHMucmVsYXRpdmVQb2ludHMpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdID0gMTAwO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0bmVnYXRpdmVWYWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpdmVWYWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHZhbHVlc0ZvclR5cGUucG9zaXRpdmVWYWx1ZXMuY29uY2F0KHZhbHVlc0ZvclR5cGUubmVnYXRpdmVWYWx1ZXMpO1xuXHRcdFx0XHR2YXIgbWluVmFsID0gaGVscGVycyQxLm1pbih2YWx1ZXMpO1xuXHRcdFx0XHR2YXIgbWF4VmFsID0gaGVscGVycyQxLm1heCh2YWx1ZXMpO1xuXHRcdFx0XHRtZS5taW4gPSBtZS5taW4gPT09IG51bGwgPyBtaW5WYWwgOiBNYXRoLm1pbihtZS5taW4sIG1pblZhbCk7XG5cdFx0XHRcdG1lLm1heCA9IG1lLm1heCA9PT0gbnVsbCA/IG1heFZhbCA6IE1hdGgubWF4KG1lLm1heCwgbWF4VmFsKTtcblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpIHx8IG1ldGEuZGF0YVtpbmRleF0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1lLm1pbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCBtZS5taW4pIHtcblx0XHRcdFx0XHRcdFx0bWUubWluID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChtZS5tYXggPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlID4gbWUubWF4KSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1heCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRtZS5taW4gPSBpc0Zpbml0ZShtZS5taW4pICYmICFpc05hTihtZS5taW4pID8gbWUubWluIDogREVGQVVMVF9NSU47XG5cdFx0bWUubWF4ID0gaXNGaW5pdGUobWUubWF4KSAmJiAhaXNOYU4obWUubWF4KSA/IG1lLm1heCA6IERFRkFVTFRfTUFYO1xuXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4LCB0aWNrcy5iZWdpbkF0WmVyb1xuXHRcdHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuXHR9LFxuXG5cdC8vIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0X2NvbXB1dGVUaWNrTGltaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tGb250O1xuXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5jZWlsKG1lLndpZHRoIC8gNDApO1xuXHRcdH1cblx0XHR0aWNrRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobWUub3B0aW9ucy50aWNrcyk7XG5cdFx0cmV0dXJuIE1hdGguY2VpbChtZS5oZWlnaHQgLyB0aWNrRm9udC5saW5lSGVpZ2h0KTtcblx0fSxcblxuXHQvLyBDYWxsZWQgYWZ0ZXIgdGhlIHRpY2tzIGFyZSBidWlsdC4gV2UgbmVlZFxuXHRoYW5kbGVEaXJlY3Rpb25hbENoYW5nZXM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0Ly8gV2UgYXJlIGluIGEgdmVydGljYWwgb3JpZW50YXRpb24uIFRoZSB0b3AgdmFsdWUgaXMgdGhlIGhpZ2hlc3QuIFNvIHJldmVyc2UgdGhlIGFycmF5XG5cdFx0XHR0aGlzLnRpY2tzLnJldmVyc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHQvLyBVdGlsc1xuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZml0IGhhcyBiZWVuIHJ1biBzbyB0aGF0XG5cdFx0Ly8gdGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy5yaWdodCwgYW5kIHRoaXMuYm90dG9tIGhhdmUgYmVlbiBkZWZpbmVkXG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgc3RhcnQgPSBtZS5zdGFydDtcblxuXHRcdHZhciByaWdodFZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUodmFsdWUpO1xuXHRcdHZhciBwaXhlbDtcblx0XHR2YXIgcmFuZ2UgPSBtZS5lbmQgLSBzdGFydDtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0cGl4ZWwgPSBtZS5sZWZ0ICsgKG1lLndpZHRoIC8gcmFuZ2UgKiAocmlnaHRWYWx1ZSAtIHN0YXJ0KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBpeGVsID0gbWUuYm90dG9tIC0gKG1lLmhlaWdodCAvIHJhbmdlICogKHJpZ2h0VmFsdWUgLSBzdGFydCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWw7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpc0hvcml6b250YWwgPSBtZS5pc0hvcml6b250YWwoKTtcblx0XHR2YXIgaW5uZXJEaW1lbnNpb24gPSBpc0hvcml6b250YWwgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHR2YXIgb2Zmc2V0ID0gKGlzSG9yaXpvbnRhbCA/IHBpeGVsIC0gbWUubGVmdCA6IG1lLmJvdHRvbSAtIHBpeGVsKSAvIGlubmVyRGltZW5zaW9uO1xuXHRcdHJldHVybiBtZS5zdGFydCArICgobWUuZW5kIC0gbWUuc3RhcnQpICogb2Zmc2V0KTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLnRpY2tzQXNOdW1iZXJzW2luZGV4XSk7XG5cdH1cbn0pO1xuXG4vLyBJTlRFUk5BTDogc3RhdGljIGRlZmF1bHQgb3B0aW9ucywgcmVnaXN0ZXJlZCBpbiBzcmMvaW5kZXguanNcbnZhciBfZGVmYXVsdHMkMSA9IGRlZmF1bHRDb25maWckMTtcbnNjYWxlX2xpbmVhci5fZGVmYXVsdHMgPSBfZGVmYXVsdHMkMTtcblxudmFyIHZhbHVlT3JEZWZhdWx0JGEgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbG9nYXJpdGhtaWMgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gYXJyYXkgb2YgdGljayB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcblx0dmFyIHRpY2tzID0gW107XG5cblx0dmFyIHRpY2tWYWwgPSB2YWx1ZU9yRGVmYXVsdCRhKGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xuXG5cdHZhciBlbmRFeHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChkYXRhUmFuZ2UubWF4KSk7XG5cdHZhciBlbmRTaWduaWZpY2FuZCA9IE1hdGguY2VpbChkYXRhUmFuZ2UubWF4IC8gTWF0aC5wb3coMTAsIGVuZEV4cCkpO1xuXHR2YXIgZXhwLCBzaWduaWZpY2FuZDtcblxuXHRpZiAodGlja1ZhbCA9PT0gMCkge1xuXHRcdGV4cCA9IE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKGRhdGFSYW5nZS5taW5Ob3RaZXJvKSk7XG5cdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKGRhdGFSYW5nZS5taW5Ob3RaZXJvIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuXG5cdFx0dGlja3MucHVzaCh0aWNrVmFsKTtcblx0XHR0aWNrVmFsID0gc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKTtcblx0fSBlbHNlIHtcblx0XHRleHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh0aWNrVmFsKSk7XG5cdFx0c2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cdH1cblx0dmFyIHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuXG5cdGRvIHtcblx0XHR0aWNrcy5wdXNoKHRpY2tWYWwpO1xuXG5cdFx0KytzaWduaWZpY2FuZDtcblx0XHRpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG5cdFx0XHRzaWduaWZpY2FuZCA9IDE7XG5cdFx0XHQrK2V4cDtcblx0XHRcdHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcblx0XHR9XG5cblx0XHR0aWNrVmFsID0gTWF0aC5yb3VuZChzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcblx0fSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XG5cblx0dmFyIGxhc3RUaWNrID0gdmFsdWVPckRlZmF1bHQkYShnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHRpY2tWYWwpO1xuXHR0aWNrcy5wdXNoKGxhc3RUaWNrKTtcblxuXHRyZXR1cm4gdGlja3M7XG59XG5cbnZhciBkZWZhdWx0Q29uZmlnJDIgPSB7XG5cdHBvc2l0aW9uOiAnbGVmdCcsXG5cblx0Ly8gbGFiZWwgc2V0dGluZ3Ncblx0dGlja3M6IHtcblx0XHRjYWxsYmFjazogY29yZV90aWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljXG5cdH1cbn07XG5cbi8vIFRPRE8odjMpOiBjaGFuZ2UgdGhpcyB0byBwb3NpdGl2ZU9yRGVmYXVsdFxuZnVuY3Rpb24gbm9uTmVnYXRpdmVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+PSAwID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbnZhciBzY2FsZV9sb2dhcml0aG1pYyA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGNoYXJ0ID0gbWUuY2hhcnQ7XG5cdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdHZhciBkYXRhc2V0cyA9IGRhdGEuZGF0YXNldHM7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXHRcdGZ1bmN0aW9uIElETWF0Y2hlcyhtZXRhKSB7XG5cdFx0XHRyZXR1cm4gaXNIb3Jpem9udGFsID8gbWV0YS54QXhpc0lEID09PSBtZS5pZCA6IG1ldGEueUF4aXNJRCA9PT0gbWUuaWQ7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIFJhbmdlXG5cdFx0bWUubWluID0gbnVsbDtcblx0XHRtZS5tYXggPSBudWxsO1xuXHRcdG1lLm1pbk5vdFplcm8gPSBudWxsO1xuXG5cdFx0dmFyIGhhc1N0YWNrcyA9IG9wdHMuc3RhY2tlZDtcblx0XHRpZiAoaGFzU3RhY2tzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0aWYgKGhhc1N0YWNrcykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkgJiZcblx0XHRcdFx0XHRtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRoYXNTdGFja3MgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAob3B0cy5zdGFja2VkIHx8IGhhc1N0YWNrcykge1xuXHRcdFx0dmFyIHZhbHVlc1BlclN0YWNrID0ge307XG5cblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHR2YXIga2V5ID0gW1xuXHRcdFx0XHRcdG1ldGEudHlwZSxcblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3RhY2sgZm9yIHN0YWNrPXVuZGVmaW5lZCBkYXRhc2V0cyB3aGVuIHRoZSBvcHRzLnN0YWNrZWQgaXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0KChvcHRzLnN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpID8gZGF0YXNldEluZGV4IDogJycpLFxuXHRcdFx0XHRcdG1ldGEuc3RhY2tcblx0XHRcdFx0XS5qb2luKCcuJyk7XG5cblx0XHRcdFx0aWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSAmJiBJRE1hdGNoZXMobWV0YSkpIHtcblx0XHRcdFx0XHRpZiAodmFsdWVzUGVyU3RhY2tba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXNQZXJTdGFja1trZXldID0gW107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aGVscGVycyQxLmVhY2goZGF0YXNldC5kYXRhLCBmdW5jdGlvbihyYXdWYWx1ZSwgaW5kZXgpIHtcblx0XHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB2YWx1ZXNQZXJTdGFja1trZXldO1xuXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdFx0Ly8gaW52YWxpZCwgaGlkZGVuIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGlnbm9yZWRcblx0XHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4gfHwgdmFsdWUgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHZhbHVlc1tpbmRleF0gPSB2YWx1ZXNbaW5kZXhdIHx8IDA7XG5cdFx0XHRcdFx0XHR2YWx1ZXNbaW5kZXhdICs9IHZhbHVlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aGVscGVycyQxLmVhY2godmFsdWVzUGVyU3RhY2ssIGZ1bmN0aW9uKHZhbHVlc0ZvclR5cGUpIHtcblx0XHRcdFx0aWYgKHZhbHVlc0ZvclR5cGUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHZhciBtaW5WYWwgPSBoZWxwZXJzJDEubWluKHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdHZhciBtYXhWYWwgPSBoZWxwZXJzJDEubWF4KHZhbHVlc0ZvclR5cGUpO1xuXHRcdFx0XHRcdG1lLm1pbiA9IG1lLm1pbiA9PT0gbnVsbCA/IG1pblZhbCA6IE1hdGgubWluKG1lLm1pbiwgbWluVmFsKTtcblx0XHRcdFx0XHRtZS5tYXggPSBtZS5tYXggPT09IG51bGwgPyBtYXhWYWwgOiBNYXRoLm1heChtZS5tYXgsIG1heFZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXHRcdFx0XHRpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpICYmIElETWF0Y2hlcyhtZXRhKSkge1xuXHRcdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZShyYXdWYWx1ZSk7XG5cdFx0XHRcdFx0XHQvLyBpbnZhbGlkLCBoaWRkZW4gYW5kIG5lZ2F0aXZlIHZhbHVlcyBhcmUgaWdub3JlZFxuXHRcdFx0XHRcdFx0aWYgKGlzTmFOKHZhbHVlKSB8fCBtZXRhLmRhdGFbaW5kZXhdLmhpZGRlbiB8fCB2YWx1ZSA8IDApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobWUubWluID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbiA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA8IG1lLm1pbikge1xuXHRcdFx0XHRcdFx0XHRtZS5taW4gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKG1lLm1heCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRtZS5tYXggPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPiBtZS5tYXgpIHtcblx0XHRcdFx0XHRcdFx0bWUubWF4ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gMCAmJiAobWUubWluTm90WmVybyA9PT0gbnVsbCB8fCB2YWx1ZSA8IG1lLm1pbk5vdFplcm8pKSB7XG5cdFx0XHRcdFx0XHRcdG1lLm1pbk5vdFplcm8gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIHRpY2tzLm1pbiwgdGlja3MubWF4XG5cdFx0dGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblx0aGFuZGxlVGlja1JhbmdlT3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciBERUZBVUxUX01JTiA9IDE7XG5cdFx0dmFyIERFRkFVTFRfTUFYID0gMTA7XG5cblx0XHRtZS5taW4gPSBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5taW4sIG1lLm1pbik7XG5cdFx0bWUubWF4ID0gbm9uTmVnYXRpdmVPckRlZmF1bHQodGlja09wdHMubWF4LCBtZS5tYXgpO1xuXG5cdFx0aWYgKG1lLm1pbiA9PT0gbWUubWF4KSB7XG5cdFx0XHRpZiAobWUubWluICE9PSAwICYmIG1lLm1pbiAhPT0gbnVsbCkge1xuXHRcdFx0XHRtZS5taW4gPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWluKSkgLSAxKTtcblx0XHRcdFx0bWUubWF4ID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1heCkpICsgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZS5taW4gPSBERUZBVUxUX01JTjtcblx0XHRcdFx0bWUubWF4ID0gREVGQVVMVF9NQVg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChtZS5taW4gPT09IG51bGwpIHtcblx0XHRcdG1lLm1pbiA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMChtZS5tYXgpKSAtIDEpO1xuXHRcdH1cblx0XHRpZiAobWUubWF4ID09PSBudWxsKSB7XG5cdFx0XHRtZS5tYXggPSBtZS5taW4gIT09IDBcblx0XHRcdFx0PyBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihoZWxwZXJzJDEubG9nMTAobWUubWluKSkgKyAxKVxuXHRcdFx0XHQ6IERFRkFVTFRfTUFYO1xuXHRcdH1cblx0XHRpZiAobWUubWluTm90WmVybyA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKG1lLm1pbiA+IDApIHtcblx0XHRcdFx0bWUubWluTm90WmVybyA9IG1lLm1pbjtcblx0XHRcdH0gZWxzZSBpZiAobWUubWF4IDwgMSkge1xuXHRcdFx0XHRtZS5taW5Ob3RaZXJvID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoaGVscGVycyQxLmxvZzEwKG1lLm1heCkpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lLm1pbk5vdFplcm8gPSBERUZBVUxUX01JTjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0YnVpbGRUaWNrczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja09wdHMgPSBtZS5vcHRpb25zLnRpY2tzO1xuXHRcdHZhciByZXZlcnNlID0gIW1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0dmFyIGdlbmVyYXRpb25PcHRpb25zID0ge1xuXHRcdFx0bWluOiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5taW4pLFxuXHRcdFx0bWF4OiBub25OZWdhdGl2ZU9yRGVmYXVsdCh0aWNrT3B0cy5tYXgpXG5cdFx0fTtcblx0XHR2YXIgdGlja3MgPSBtZS50aWNrcyA9IGdlbmVyYXRlVGlja3MkMShnZW5lcmF0aW9uT3B0aW9ucywgbWUpO1xuXG5cdFx0Ly8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyBzaW5jZSB3ZSBoYXZlIGV4cGFuZGVkIHRoZVxuXHRcdC8vIHJhbmdlIG9mIHRoZSBzY2FsZVxuXHRcdG1lLm1heCA9IGhlbHBlcnMkMS5tYXgodGlja3MpO1xuXHRcdG1lLm1pbiA9IGhlbHBlcnMkMS5taW4odGlja3MpO1xuXG5cdFx0aWYgKHRpY2tPcHRzLnJldmVyc2UpIHtcblx0XHRcdHJldmVyc2UgPSAhcmV2ZXJzZTtcblx0XHRcdG1lLnN0YXJ0ID0gbWUubWF4O1xuXHRcdFx0bWUuZW5kID0gbWUubWluO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZS5zdGFydCA9IG1lLm1pbjtcblx0XHRcdG1lLmVuZCA9IG1lLm1heDtcblx0XHR9XG5cdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdHRpY2tzLnJldmVyc2UoKTtcblx0XHR9XG5cdH0sXG5cblx0Y29udmVydFRpY2tzVG9MYWJlbHM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudGlja1ZhbHVlcyA9IHRoaXMudGlja3Muc2xpY2UoKTtcblxuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmNvbnZlcnRUaWNrc1RvTGFiZWxzLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBjb3JyZWN0IHRvb2x0aXAgbGFiZWxcblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclRpY2s6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLnRpY2tWYWx1ZXNbaW5kZXhdKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IHRpY2suXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBtaW5pbXVtIG5vdCB6ZXJvIHZhbHVlLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBmaXJzdCB0aWNrIHZhbHVlLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldEZpcnN0VGlja1ZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciBleHAgPSBNYXRoLmZsb29yKGhlbHBlcnMkMS5sb2cxMCh2YWx1ZSkpO1xuXHRcdHZhciBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodmFsdWUgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG5cblx0XHRyZXR1cm4gc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKTtcblx0fSxcblxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgcmV2ZXJzZSA9IHRpY2tPcHRzLnJldmVyc2U7XG5cdFx0dmFyIGxvZzEwID0gaGVscGVycyQxLmxvZzEwO1xuXHRcdHZhciBmaXJzdFRpY2tWYWx1ZSA9IG1lLl9nZXRGaXJzdFRpY2tWYWx1ZShtZS5taW5Ob3RaZXJvKTtcblx0XHR2YXIgb2Zmc2V0ID0gMDtcblx0XHR2YXIgaW5uZXJEaW1lbnNpb24sIHBpeGVsLCBzdGFydCwgZW5kLCBzaWduO1xuXG5cdFx0dmFsdWUgPSArbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdHN0YXJ0ID0gbWUuZW5kO1xuXHRcdFx0ZW5kID0gbWUuc3RhcnQ7XG5cdFx0XHRzaWduID0gLTE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXJ0ID0gbWUuc3RhcnQ7XG5cdFx0XHRlbmQgPSBtZS5lbmQ7XG5cdFx0XHRzaWduID0gMTtcblx0XHR9XG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLndpZHRoO1xuXHRcdFx0cGl4ZWwgPSByZXZlcnNlID8gbWUucmlnaHQgOiBtZS5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLmhlaWdodDtcblx0XHRcdHNpZ24gKj0gLTE7IC8vIGludmVydCwgc2luY2UgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXMgaXMgYXQgcGl4ZWwgKDAsIDApXG5cdFx0XHRwaXhlbCA9IHJldmVyc2UgPyBtZS50b3AgOiBtZS5ib3R0b207XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSAhPT0gc3RhcnQpIHtcblx0XHRcdGlmIChzdGFydCA9PT0gMCkgeyAvLyBpbmNsdWRlIHplcm8gdGlja1xuXHRcdFx0XHRvZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdCRhKHRpY2tPcHRzLmZvbnRTaXplLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udFNpemUpO1xuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiAtPSBvZmZzZXQ7XG5cdFx0XHRcdHN0YXJ0ID0gZmlyc3RUaWNrVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IDApIHtcblx0XHRcdFx0b2Zmc2V0ICs9IGlubmVyRGltZW5zaW9uIC8gKGxvZzEwKGVuZCkgLSBsb2cxMChzdGFydCkpICogKGxvZzEwKHZhbHVlKSAtIGxvZzEwKHN0YXJ0KSk7XG5cdFx0XHR9XG5cdFx0XHRwaXhlbCArPSBzaWduICogb2Zmc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWw7XG5cdH0sXG5cblx0Z2V0VmFsdWVGb3JQaXhlbDogZnVuY3Rpb24ocGl4ZWwpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG1lLm9wdGlvbnMudGlja3M7XG5cdFx0dmFyIHJldmVyc2UgPSB0aWNrT3B0cy5yZXZlcnNlO1xuXHRcdHZhciBsb2cxMCA9IGhlbHBlcnMkMS5sb2cxMDtcblx0XHR2YXIgZmlyc3RUaWNrVmFsdWUgPSBtZS5fZ2V0Rmlyc3RUaWNrVmFsdWUobWUubWluTm90WmVybyk7XG5cdFx0dmFyIGlubmVyRGltZW5zaW9uLCBzdGFydCwgZW5kLCB2YWx1ZTtcblxuXHRcdGlmIChyZXZlcnNlKSB7XG5cdFx0XHRzdGFydCA9IG1lLmVuZDtcblx0XHRcdGVuZCA9IG1lLnN0YXJ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdGFydCA9IG1lLnN0YXJ0O1xuXHRcdFx0ZW5kID0gbWUuZW5kO1xuXHRcdH1cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdGlubmVyRGltZW5zaW9uID0gbWUud2lkdGg7XG5cdFx0XHR2YWx1ZSA9IHJldmVyc2UgPyBtZS5yaWdodCAtIHBpeGVsIDogcGl4ZWwgLSBtZS5sZWZ0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbm5lckRpbWVuc2lvbiA9IG1lLmhlaWdodDtcblx0XHRcdHZhbHVlID0gcmV2ZXJzZSA/IHBpeGVsIC0gbWUudG9wIDogbWUuYm90dG9tIC0gcGl4ZWw7XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSAhPT0gc3RhcnQpIHtcblx0XHRcdGlmIChzdGFydCA9PT0gMCkgeyAvLyBpbmNsdWRlIHplcm8gdGlja1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQkYSh0aWNrT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblx0XHRcdFx0dmFsdWUgLT0gb2Zmc2V0O1xuXHRcdFx0XHRpbm5lckRpbWVuc2lvbiAtPSBvZmZzZXQ7XG5cdFx0XHRcdHN0YXJ0ID0gZmlyc3RUaWNrVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSAqPSBsb2cxMChlbmQpIC0gbG9nMTAoc3RhcnQpO1xuXHRcdFx0dmFsdWUgLz0gaW5uZXJEaW1lbnNpb247XG5cdFx0XHR2YWx1ZSA9IE1hdGgucG93KDEwLCBsb2cxMChzdGFydCkgKyB2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxufSk7XG5cbi8vIElOVEVSTkFMOiBzdGF0aWMgZGVmYXVsdCBvcHRpb25zLCByZWdpc3RlcmVkIGluIHNyYy9pbmRleC5qc1xudmFyIF9kZWZhdWx0cyQyID0gZGVmYXVsdENvbmZpZyQyO1xuc2NhbGVfbG9nYXJpdGhtaWMuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDI7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCRiID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xudmFyIHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxID0gaGVscGVycyQxLnZhbHVlQXRJbmRleE9yRGVmYXVsdDtcbnZhciByZXNvbHZlJDcgPSBoZWxwZXJzJDEub3B0aW9ucy5yZXNvbHZlO1xuXG52YXIgZGVmYXVsdENvbmZpZyQzID0ge1xuXHRkaXNwbGF5OiB0cnVlLFxuXG5cdC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgc2NhbGluZyB0aGUgY2hhcnQgZnJvbSB0aGUgY2VudHJlXG5cdGFuaW1hdGU6IHRydWUsXG5cdHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcblxuXHRhbmdsZUxpbmVzOiB7XG5cdFx0ZGlzcGxheTogdHJ1ZSxcblx0XHRjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4xKScsXG5cdFx0bGluZVdpZHRoOiAxLFxuXHRcdGJvcmRlckRhc2g6IFtdLFxuXHRcdGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuXHR9LFxuXG5cdGdyaWRMaW5lczoge1xuXHRcdGNpcmN1bGFyOiBmYWxzZVxuXHR9LFxuXG5cdC8vIGxhYmVsIHNldHRpbmdzXG5cdHRpY2tzOiB7XG5cdFx0Ly8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcblx0XHRzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcblxuXHRcdC8vIFN0cmluZyAtIFRoZSBjb2xvdXIgb2YgdGhlIGxhYmVsIGJhY2tkcm9wXG5cdFx0YmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMC43NSknLFxuXG5cdFx0Ly8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgYWJvdmUgJiBiZWxvdyB0aGUgbGFiZWwgaW4gcGl4ZWxzXG5cdFx0YmFja2Ryb3BQYWRkaW5nWTogMixcblxuXHRcdC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIHRvIHRoZSBzaWRlIG9mIHRoZSBsYWJlbCBpbiBwaXhlbHNcblx0XHRiYWNrZHJvcFBhZGRpbmdYOiAyLFxuXG5cdFx0Y2FsbGJhY2s6IGNvcmVfdGlja3MuZm9ybWF0dGVycy5saW5lYXJcblx0fSxcblxuXHRwb2ludExhYmVsczoge1xuXHRcdC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBzaG93IHBvaW50IGxhYmVsc1xuXHRcdGRpc3BsYXk6IHRydWUsXG5cblx0XHQvLyBOdW1iZXIgLSBQb2ludCBsYWJlbCBmb250IHNpemUgaW4gcGl4ZWxzXG5cdFx0Zm9udFNpemU6IDEwLFxuXG5cdFx0Ly8gRnVuY3Rpb24gLSBVc2VkIHRvIGNvbnZlcnQgcG9pbnQgbGFiZWxzXG5cdFx0Y2FsbGJhY2s6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0fVxuXHR9XG59O1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUNvdW50KHNjYWxlKSB7XG5cdHZhciBvcHRzID0gc2NhbGUub3B0aW9ucztcblx0cmV0dXJuIG9wdHMuYW5nbGVMaW5lcy5kaXNwbGF5IHx8IG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSA/IHNjYWxlLmNoYXJ0LmRhdGEubGFiZWxzLmxlbmd0aCA6IDA7XG59XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG5cdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0aWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG5cdFx0cmV0dXJuIHZhbHVlT3JEZWZhdWx0JGIodGlja09wdHMuZm9udFNpemUsIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250U2l6ZSkgKyB0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmdZICogMjtcblx0fVxuXHRyZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGxpbmVIZWlnaHQsIGxhYmVsKSB7XG5cdGlmIChoZWxwZXJzJDEuaXNBcnJheShsYWJlbCkpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dzogaGVscGVycyQxLmxvbmdlc3RUZXh0KGN0eCwgY3R4LmZvbnQsIGxhYmVsKSxcblx0XHRcdGg6IGxhYmVsLmxlbmd0aCAqIGxpbmVIZWlnaHRcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHR3OiBjdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoLFxuXHRcdGg6IGxpbmVIZWlnaHRcblx0fTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG5cdGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG5cdFx0XHRlbmQ6IHBvcyArIChzaXplIC8gMilcblx0XHR9O1xuXHR9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXJ0OiBwb3MgLSBzaXplLFxuXHRcdFx0ZW5kOiBwb3Ncblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzdGFydDogcG9zLFxuXHRcdGVuZDogcG9zICsgc2l6ZVxuXHR9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBmaXQgYSByYWRpYWwgbGluZWFyIHNjYWxlIHdpdGggcG9pbnQgbGFiZWxzXG4gKi9cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuXG5cdC8vIFJpZ2h0LCB0aGlzIGlzIHJlYWxseSBjb25mdXNpbmcgYW5kIHRoZXJlIGlzIGEgbG90IG9mIG1hdGhzIGdvaW5nIG9uIGhlcmVcblx0Ly8gVGhlIGdpc3Qgb2YgdGhlIHByb2JsZW0gaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbm5uaWNrLzY5NmNjOWM1NWY0YjBiZWI4ZmU5XG5cdC8vXG5cdC8vIFJlYWN0aW9uOiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My90b29tdWNoc2NpZW5jZS5naWZcblx0Ly9cblx0Ly8gU29sdXRpb246XG5cdC8vXG5cdC8vIFdlIGFzc3VtZSB0aGUgcmFkaXVzIG9mIHRoZSBwb2x5Z29uIGlzIGhhbGYgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBhdCBmaXJzdFxuXHQvLyBhdCBlYWNoIGluZGV4IHdlIGNoZWNrIGlmIHRoZSB0ZXh0IG92ZXJsYXBzLlxuXHQvL1xuXHQvLyBXaGVyZSBpdCBkb2VzLCB3ZSBzdG9yZSB0aGF0IGFuZ2xlIGFuZCB0aGF0IGluZGV4LlxuXHQvL1xuXHQvLyBBZnRlciBmaW5kaW5nIHRoZSBsYXJnZXN0IGluZGV4IGFuZCBhbmdsZSB3ZSBjYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byByZW1vdmVcblx0Ly8gZnJvbSB0aGUgc2hhcGUgcmFkaXVzIHRvIG1vdmUgdGhlIHBvaW50IGlud2FyZHMgYnkgdGhhdCB4LlxuXHQvL1xuXHQvLyBXZSBhdmVyYWdlIHRoZSBsZWZ0IGFuZCByaWdodCBkaXN0YW5jZXMgdG8gZ2V0IHRoZSBtYXhpbXVtIHNoYXBlIHJhZGl1cyB0aGF0IGNhbiBmaXQgaW4gdGhlIGJveFxuXHQvLyBhbG9uZyB3aXRoIGxhYmVscy5cblx0Ly9cblx0Ly8gT25jZSB3ZSBoYXZlIHRoYXQsIHdlIGNhbiBmaW5kIHRoZSBjZW50cmUgcG9pbnQgZm9yIHRoZSBjaGFydCwgYnkgdGFraW5nIHRoZSB4IHRleHQgcHJvdHJ1c2lvblxuXHQvLyBvbiBlYWNoIHNpZGUsIHJlbW92aW5nIHRoYXQgZnJvbSB0aGUgc2l6ZSwgaGFsdmluZyBpdCBhbmQgYWRkaW5nIHRoZSBsZWZ0IHggcHJvdHJ1c2lvbiB3aWR0aC5cblx0Ly9cblx0Ly8gVGhpcyB3aWxsIG1lYW4gd2UgaGF2ZSBhIHNoYXBlIGZpdHRlZCB0byB0aGUgY2FudmFzLCBhcyBsYXJnZSBhcyBpdCBjYW4gYmUgd2l0aCB0aGUgbGFiZWxzXG5cdC8vIGFuZCBwb3NpdGlvbiBpdCBpbiB0aGUgbW9zdCBzcGFjZSBlZmZpY2llbnQgbWFubmVyXG5cdC8vXG5cdC8vIGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3llYWhzY2llbmNlLmdpZlxuXG5cdHZhciBwbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHMpO1xuXG5cdC8vIEdldCBtYXhpbXVtIHJhZGl1cyBvZiB0aGUgcG9seWdvbi4gRWl0aGVyIGhhbGYgdGhlIGhlaWdodCAobWludXMgdGhlIHRleHQgd2lkdGgpIG9yIGhhbGYgdGhlIHdpZHRoLlxuXHQvLyBVc2UgdGhpcyB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCArIGNoYW5nZS4gLSBNYWtlIHN1cmUgTC9SIHByb3RydXNpb24gaXMgYXQgbGVhc3QgMCB0byBzdG9wIGlzc3VlcyB3aXRoIGNlbnRyZSBwb2ludHNcblx0dmFyIGZ1cnRoZXN0TGltaXRzID0ge1xuXHRcdGw6IDAsXG5cdFx0cjogc2NhbGUud2lkdGgsXG5cdFx0dDogMCxcblx0XHRiOiBzY2FsZS5oZWlnaHQgLSBzY2FsZS5wYWRkaW5nVG9wXG5cdH07XG5cdHZhciBmdXJ0aGVzdEFuZ2xlcyA9IHt9O1xuXHR2YXIgaSwgdGV4dFNpemUsIHBvaW50UG9zaXRpb247XG5cblx0c2NhbGUuY3R4LmZvbnQgPSBwbEZvbnQuc3RyaW5nO1xuXHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzID0gW107XG5cblx0dmFyIHZhbHVlQ291bnQgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKTtcblx0Zm9yIChpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuXHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHNjYWxlLmRyYXdpbmdBcmVhICsgNSk7XG5cdFx0dGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LmxpbmVIZWlnaHQsIHNjYWxlLnBvaW50TGFiZWxzW2ldIHx8ICcnKTtcblx0XHRzY2FsZS5fcG9pbnRMYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cblx0XHQvLyBBZGQgcXVhcnRlciBjaXJjbGUgdG8gbWFrZSBkZWdyZWUgMCBtZWFuIHRvcCBvZiBjaXJjbGVcblx0XHR2YXIgYW5nbGVSYWRpYW5zID0gc2NhbGUuZ2V0SW5kZXhBbmdsZShpKTtcblx0XHR2YXIgYW5nbGUgPSBoZWxwZXJzJDEudG9EZWdyZWVzKGFuZ2xlUmFkaWFucykgJSAzNjA7XG5cdFx0dmFyIGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcblx0XHR2YXIgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcblxuXHRcdGlmIChoTGltaXRzLnN0YXJ0IDwgZnVydGhlc3RMaW1pdHMubCkge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMubCA9IGhMaW1pdHMuc3RhcnQ7XG5cdFx0XHRmdXJ0aGVzdEFuZ2xlcy5sID0gYW5nbGVSYWRpYW5zO1xuXHRcdH1cblxuXHRcdGlmIChoTGltaXRzLmVuZCA+IGZ1cnRoZXN0TGltaXRzLnIpIHtcblx0XHRcdGZ1cnRoZXN0TGltaXRzLnIgPSBoTGltaXRzLmVuZDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnIgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKHZMaW1pdHMuc3RhcnQgPCBmdXJ0aGVzdExpbWl0cy50KSB7XG5cdFx0XHRmdXJ0aGVzdExpbWl0cy50ID0gdkxpbWl0cy5zdGFydDtcblx0XHRcdGZ1cnRoZXN0QW5nbGVzLnQgPSBhbmdsZVJhZGlhbnM7XG5cdFx0fVxuXG5cdFx0aWYgKHZMaW1pdHMuZW5kID4gZnVydGhlc3RMaW1pdHMuYikge1xuXHRcdFx0ZnVydGhlc3RMaW1pdHMuYiA9IHZMaW1pdHMuZW5kO1xuXHRcdFx0ZnVydGhlc3RBbmdsZXMuYiA9IGFuZ2xlUmFkaWFucztcblx0XHR9XG5cdH1cblxuXHRzY2FsZS5zZXRSZWR1Y3Rpb25zKHNjYWxlLmRyYXdpbmdBcmVhLCBmdXJ0aGVzdExpbWl0cywgZnVydGhlc3RBbmdsZXMpO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuXHRpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuXHRcdHJldHVybiAnY2VudGVyJztcblx0fSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuXHRcdHJldHVybiAnbGVmdCc7XG5cdH1cblxuXHRyZXR1cm4gJ3JpZ2h0Jztcbn1cblxuZnVuY3Rpb24gZmlsbFRleHQoY3R4LCB0ZXh0LCBwb3NpdGlvbiwgbGluZUhlaWdodCkge1xuXHR2YXIgeSA9IHBvc2l0aW9uLnkgKyBsaW5lSGVpZ2h0IC8gMjtcblx0dmFyIGksIGlsZW47XG5cblx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRleHQpKSB7XG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRleHQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRjdHguZmlsbFRleHQodGV4dFtpXSwgcG9zaXRpb24ueCwgeSk7XG5cdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGN0eC5maWxsVGV4dCh0ZXh0LCBwb3NpdGlvbi54LCB5KTtcblx0fVxufVxuXG5mdW5jdGlvbiBhZGp1c3RQb2ludFBvc2l0aW9uRm9yTGFiZWxIZWlnaHQoYW5nbGUsIHRleHRTaXplLCBwb3NpdGlvbikge1xuXHRpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcblx0XHRwb3NpdGlvbi55IC09ICh0ZXh0U2l6ZS5oIC8gMik7XG5cdH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuXHRcdHBvc2l0aW9uLnkgLT0gdGV4dFNpemUuaDtcblx0fVxufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbHMoc2NhbGUpIHtcblx0dmFyIGN0eCA9IHNjYWxlLmN0eDtcblx0dmFyIG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuXHR2YXIgYW5nbGVMaW5lT3B0cyA9IG9wdHMuYW5nbGVMaW5lcztcblx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHR2YXIgcG9pbnRMYWJlbE9wdHMgPSBvcHRzLnBvaW50TGFiZWxzO1xuXHR2YXIgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQkYihhbmdsZUxpbmVPcHRzLmxpbmVXaWR0aCwgZ3JpZExpbmVPcHRzLmxpbmVXaWR0aCk7XG5cdHZhciBsaW5lQ29sb3IgPSB2YWx1ZU9yRGVmYXVsdCRiKGFuZ2xlTGluZU9wdHMuY29sb3IsIGdyaWRMaW5lT3B0cy5jb2xvcik7XG5cdHZhciB0aWNrQmFja2Ryb3BIZWlnaHQgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cyk7XG5cblx0Y3R4LnNhdmUoKTtcblx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0Y3R4LnN0cm9rZVN0eWxlID0gbGluZUNvbG9yO1xuXHRpZiAoY3R4LnNldExpbmVEYXNoKSB7XG5cdFx0Y3R4LnNldExpbmVEYXNoKHJlc29sdmUkNyhbYW5nbGVMaW5lT3B0cy5ib3JkZXJEYXNoLCBncmlkTGluZU9wdHMuYm9yZGVyRGFzaCwgW11dKSk7XG5cdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gcmVzb2x2ZSQ3KFthbmdsZUxpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQsIGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0LCAwLjBdKTtcblx0fVxuXG5cdHZhciBvdXRlckRpc3RhbmNlID0gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUob3B0cy50aWNrcy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4KTtcblxuXHQvLyBQb2ludCBMYWJlbCBGb250XG5cdHZhciBwbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHBvaW50TGFiZWxPcHRzKTtcblxuXHRjdHguZm9udCA9IHBsRm9udC5zdHJpbmc7XG5cdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuXHRmb3IgKHZhciBpID0gZ2V0VmFsdWVDb3VudChzY2FsZSkgLSAxOyBpID49IDA7IGktLSkge1xuXHRcdGlmIChhbmdsZUxpbmVPcHRzLmRpc3BsYXkgJiYgbGluZVdpZHRoICYmIGxpbmVDb2xvcikge1xuXHRcdFx0dmFyIG91dGVyUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UpO1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0Y3R4Lm1vdmVUbyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyKTtcblx0XHRcdGN0eC5saW5lVG8ob3V0ZXJQb3NpdGlvbi54LCBvdXRlclBvc2l0aW9uLnkpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblxuXHRcdGlmIChwb2ludExhYmVsT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHQvLyBFeHRyYSBwaXhlbHMgb3V0IGZvciBzb21lIGxhYmVsIHNwYWNpbmdcblx0XHRcdHZhciBleHRyYSA9IChpID09PSAwID8gdGlja0JhY2tkcm9wSGVpZ2h0IC8gMiA6IDApO1xuXHRcdFx0dmFyIHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgNSk7XG5cblx0XHRcdC8vIEtlZXAgdGhpcyBpbiBsb29wIHNpbmNlIHdlIG1heSBzdXBwb3J0IGFycmF5IHByb3BlcnRpZXMgaGVyZVxuXHRcdFx0dmFyIHBvaW50TGFiZWxGb250Q29sb3IgPSB2YWx1ZUF0SW5kZXhPckRlZmF1bHQkMShwb2ludExhYmVsT3B0cy5mb250Q29sb3IsIGksIGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRGb250Q29sb3IpO1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHBvaW50TGFiZWxGb250Q29sb3I7XG5cblx0XHRcdHZhciBhbmdsZVJhZGlhbnMgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKGkpO1xuXHRcdFx0dmFyIGFuZ2xlID0gaGVscGVycyQxLnRvRGVncmVlcyhhbmdsZVJhZGlhbnMpO1xuXHRcdFx0Y3R4LnRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcblx0XHRcdGFkanVzdFBvaW50UG9zaXRpb25Gb3JMYWJlbEhlaWdodChhbmdsZSwgc2NhbGUuX3BvaW50TGFiZWxTaXplc1tpXSwgcG9pbnRMYWJlbFBvc2l0aW9uKTtcblx0XHRcdGZpbGxUZXh0KGN0eCwgc2NhbGUucG9pbnRMYWJlbHNbaV0gfHwgJycsIHBvaW50TGFiZWxQb3NpdGlvbiwgcGxGb250LmxpbmVIZWlnaHQpO1xuXHRcdH1cblx0fVxuXHRjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGluZGV4KSB7XG5cdHZhciBjdHggPSBzY2FsZS5jdHg7XG5cdHZhciBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcblx0dmFyIHZhbHVlQ291bnQgPSBnZXRWYWx1ZUNvdW50KHNjYWxlKTtcblx0dmFyIGxpbmVDb2xvciA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5jb2xvciwgaW5kZXggLSAxKTtcblx0dmFyIGxpbmVXaWR0aCA9IHZhbHVlQXRJbmRleE9yRGVmYXVsdCQxKGdyaWRMaW5lT3B0cy5saW5lV2lkdGgsIGluZGV4IC0gMSk7XG5cdHZhciBwb2ludFBvc2l0aW9uO1xuXG5cdGlmICgoIWNpcmN1bGFyICYmICF2YWx1ZUNvdW50KSB8fCAhbGluZUNvbG9yIHx8ICFsaW5lV2lkdGgpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjdHguc2F2ZSgpO1xuXHRjdHguc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XG5cdGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG5cdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRjdHguc2V0TGluZURhc2goZ3JpZExpbmVPcHRzLmJvcmRlckRhc2ggfHwgW10pO1xuXHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0IHx8IDAuMDtcblx0fVxuXG5cdGN0eC5iZWdpblBhdGgoKTtcblx0aWYgKGNpcmN1bGFyKSB7XG5cdFx0Ly8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xuXHRcdGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gRHJhdyBzdHJhaWdodCBsaW5lcyBjb25uZWN0aW5nIGVhY2ggaW5kZXhcblx0XHRwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuXHRcdGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcblx0XHRcdHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIHJhZGl1cyk7XG5cdFx0XHRjdHgubGluZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblx0XHR9XG5cdH1cblx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRjdHguc3Ryb2tlKCk7XG5cdGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlck9yWmVybyhwYXJhbSkge1xuXHRyZXR1cm4gaGVscGVycyQxLmlzTnVtYmVyKHBhcmFtKSA/IHBhcmFtIDogMDtcbn1cblxudmFyIHNjYWxlX3JhZGlhbExpbmVhciA9IHNjYWxlX2xpbmVhcmJhc2UuZXh0ZW5kKHtcblx0c2V0RGltZW5zaW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRtZS5oZWlnaHQgPSBtZS5tYXhIZWlnaHQ7XG5cdFx0bWUucGFkZGluZ1RvcCA9IGdldFRpY2tCYWNrZHJvcEhlaWdodChtZS5vcHRpb25zKSAvIDI7XG5cdFx0bWUueENlbnRlciA9IE1hdGguZmxvb3IobWUud2lkdGggLyAyKTtcblx0XHRtZS55Q2VudGVyID0gTWF0aC5mbG9vcigobWUuaGVpZ2h0IC0gbWUucGFkZGluZ1RvcCkgLyAyKTtcblx0XHRtZS5kcmF3aW5nQXJlYSA9IE1hdGgubWluKG1lLmhlaWdodCAtIG1lLnBhZGRpbmdUb3AsIG1lLndpZHRoKSAvIDI7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXHRcdHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cblx0XHRoZWxwZXJzJDEuZWFjaChjaGFydC5kYXRhLmRhdGFzZXRzLCBmdW5jdGlvbihkYXRhc2V0LCBkYXRhc2V0SW5kZXgpIHtcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkpIHtcblx0XHRcdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKGRhdGFzZXQuZGF0YSwgZnVuY3Rpb24ocmF3VmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gK21lLmdldFJpZ2h0VmFsdWUocmF3VmFsdWUpO1xuXHRcdFx0XHRcdGlmIChpc05hTih2YWx1ZSkgfHwgbWV0YS5kYXRhW2luZGV4XS5oaWRkZW4pIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtaW4gPSBNYXRoLm1pbih2YWx1ZSwgbWluKTtcblx0XHRcdFx0XHRtYXggPSBNYXRoLm1heCh2YWx1ZSwgbWF4KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRtZS5taW4gPSAobWluID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgPyAwIDogbWluKTtcblx0XHRtZS5tYXggPSAobWF4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPyAwIDogbWF4KTtcblxuXHRcdC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSB0aWNrcy5taW4sIHRpY2tzLm1heCwgdGlja3MuYmVnaW5BdFplcm9cblx0XHRtZS5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG5cdH0sXG5cblx0Ly8gUmV0dXJucyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGlja3MgYmFzZWQgb24gdGhlIHNjYWxlIGRpbWVuc2lvblxuXHRfY29tcHV0ZVRpY2tMaW1pdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuXHR9LFxuXG5cdGNvbnZlcnRUaWNrc1RvTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0c2NhbGVfbGluZWFyYmFzZS5wcm90b3R5cGUuY29udmVydFRpY2tzVG9MYWJlbHMuY2FsbChtZSk7XG5cblx0XHQvLyBQb2ludCBsYWJlbHNcblx0XHRtZS5wb2ludExhYmVscyA9IG1lLmNoYXJ0LmRhdGEubGFiZWxzLm1hcChtZS5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBtZSk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHJldHVybiArdGhpcy5nZXRSaWdodFZhbHVlKHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdKTtcblx0fSxcblxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcblx0XHRcdGZpdFdpdGhQb2ludExhYmVscyhtZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHJhZGl1cyByZWR1Y3Rpb25zIGFuZCBkZXRlcm1pbmUgbmV3IHJhZGl1cyBhbmQgY2VudGVyIHBvaW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzZXRSZWR1Y3Rpb25zOiBmdW5jdGlvbihsYXJnZXN0UG9zc2libGVSYWRpdXMsIGZ1cnRoZXN0TGltaXRzLCBmdXJ0aGVzdEFuZ2xlcykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBmdXJ0aGVzdExpbWl0cy5sIC8gTWF0aC5zaW4oZnVydGhlc3RBbmdsZXMubCk7XG5cdFx0dmFyIHJhZGl1c1JlZHVjdGlvblJpZ2h0ID0gTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuciAtIG1lLndpZHRoLCAwKSAvIE1hdGguc2luKGZ1cnRoZXN0QW5nbGVzLnIpO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Ub3AgPSAtZnVydGhlc3RMaW1pdHMudCAvIE1hdGguY29zKGZ1cnRoZXN0QW5nbGVzLnQpO1xuXHRcdHZhciByYWRpdXNSZWR1Y3Rpb25Cb3R0b20gPSAtTWF0aC5tYXgoZnVydGhlc3RMaW1pdHMuYiAtIChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSwgMCkgLyBNYXRoLmNvcyhmdXJ0aGVzdEFuZ2xlcy5iKTtcblxuXHRcdHJhZGl1c1JlZHVjdGlvbkxlZnQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uTGVmdCk7XG5cdFx0cmFkaXVzUmVkdWN0aW9uUmlnaHQgPSBudW1iZXJPclplcm8ocmFkaXVzUmVkdWN0aW9uUmlnaHQpO1xuXHRcdHJhZGl1c1JlZHVjdGlvblRvcCA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Ub3ApO1xuXHRcdHJhZGl1c1JlZHVjdGlvbkJvdHRvbSA9IG51bWJlck9yWmVybyhyYWRpdXNSZWR1Y3Rpb25Cb3R0b20pO1xuXG5cdFx0bWUuZHJhd2luZ0FyZWEgPSBNYXRoLm1pbihcblx0XHRcdE1hdGguZmxvb3IobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvbkxlZnQgKyByYWRpdXNSZWR1Y3Rpb25SaWdodCkgLyAyKSxcblx0XHRcdE1hdGguZmxvb3IobGFyZ2VzdFBvc3NpYmxlUmFkaXVzIC0gKHJhZGl1c1JlZHVjdGlvblRvcCArIHJhZGl1c1JlZHVjdGlvbkJvdHRvbSkgLyAyKSk7XG5cdFx0bWUuc2V0Q2VudGVyUG9pbnQocmFkaXVzUmVkdWN0aW9uTGVmdCwgcmFkaXVzUmVkdWN0aW9uUmlnaHQsIHJhZGl1c1JlZHVjdGlvblRvcCwgcmFkaXVzUmVkdWN0aW9uQm90dG9tKTtcblx0fSxcblxuXHRzZXRDZW50ZXJQb2ludDogZnVuY3Rpb24obGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBtYXhSaWdodCA9IG1lLndpZHRoIC0gcmlnaHRNb3ZlbWVudCAtIG1lLmRyYXdpbmdBcmVhO1xuXHRcdHZhciBtYXhMZWZ0ID0gbGVmdE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heFRvcCA9IHRvcE1vdmVtZW50ICsgbWUuZHJhd2luZ0FyZWE7XG5cdFx0dmFyIG1heEJvdHRvbSA9IChtZS5oZWlnaHQgLSBtZS5wYWRkaW5nVG9wKSAtIGJvdHRvbU1vdmVtZW50IC0gbWUuZHJhd2luZ0FyZWE7XG5cblx0XHRtZS54Q2VudGVyID0gTWF0aC5mbG9vcigoKG1heExlZnQgKyBtYXhSaWdodCkgLyAyKSArIG1lLmxlZnQpO1xuXHRcdG1lLnlDZW50ZXIgPSBNYXRoLmZsb29yKCgobWF4VG9wICsgbWF4Qm90dG9tKSAvIDIpICsgbWUudG9wICsgbWUucGFkZGluZ1RvcCk7XG5cdH0sXG5cblx0Z2V0SW5kZXhBbmdsZTogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHR2YXIgYW5nbGVNdWx0aXBsaWVyID0gKE1hdGguUEkgKiAyKSAvIGdldFZhbHVlQ291bnQodGhpcyk7XG5cdFx0dmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMgJiYgdGhpcy5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgP1xuXHRcdFx0dGhpcy5jaGFydC5vcHRpb25zLnN0YXJ0QW5nbGUgOlxuXHRcdFx0MDtcblxuXHRcdHZhciBzdGFydEFuZ2xlUmFkaWFucyA9IHN0YXJ0QW5nbGUgKiBNYXRoLlBJICogMiAvIDM2MDtcblxuXHRcdC8vIFN0YXJ0IGZyb20gdGhlIHRvcCBpbnN0ZWFkIG9mIHJpZ2h0LCBzbyByZW1vdmUgYSBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblx0XHRyZXR1cm4gaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyBzdGFydEFuZ2xlUmFkaWFucztcblx0fSxcblxuXHRnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gMDsgLy8gbnVsbCBhbHdheXMgaW4gY2VudGVyXG5cdFx0fVxuXG5cdFx0Ly8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuXHRcdHZhciBzY2FsaW5nRmFjdG9yID0gbWUuZHJhd2luZ0FyZWEgLyAobWUubWF4IC0gbWUubWluKTtcblx0XHRpZiAobWUub3B0aW9ucy50aWNrcy5yZXZlcnNlKSB7XG5cdFx0XHRyZXR1cm4gKG1lLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG5cdFx0fVxuXHRcdHJldHVybiAodmFsdWUgLSBtZS5taW4pICogc2NhbGluZ0ZhY3Rvcjtcblx0fSxcblxuXHRnZXRQb2ludFBvc2l0aW9uOiBmdW5jdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGhpc0FuZ2xlID0gbWUuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSAoTWF0aC5QSSAvIDIpO1xuXHRcdHJldHVybiB7XG5cdFx0XHR4OiBNYXRoLmNvcyh0aGlzQW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgbWUueENlbnRlcixcblx0XHRcdHk6IE1hdGguc2luKHRoaXNBbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyBtZS55Q2VudGVyXG5cdFx0fTtcblx0fSxcblxuXHRnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWU6IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuXHRcdHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcblx0fSxcblxuXHRnZXRCYXNlUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXG5cdFx0cmV0dXJuIG1lLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLFxuXHRcdFx0bWUuYmVnaW5BdFplcm8gPyAwIDpcblx0XHRcdG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG5cdFx0XHRtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuXHRcdFx0MCk7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGdyaWRMaW5lT3B0cyA9IG9wdHMuZ3JpZExpbmVzO1xuXHRcdHZhciB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cblx0XHRpZiAob3B0cy5kaXNwbGF5KSB7XG5cdFx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXHRcdFx0dmFyIHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG5cdFx0XHR2YXIgdGlja0ZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KHRpY2tPcHRzKTtcblxuXHRcdFx0aWYgKG9wdHMuYW5nbGVMaW5lcy5kaXNwbGF5IHx8IG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuXHRcdFx0XHRkcmF3UG9pbnRMYWJlbHMobWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRoZWxwZXJzJDEuZWFjaChtZS50aWNrcywgZnVuY3Rpb24obGFiZWwsIGluZGV4KSB7XG5cdFx0XHRcdC8vIERvbid0IGRyYXcgYSBjZW50cmUgdmFsdWUgKGlmIGl0IGlzIG1pbmltdW0pXG5cdFx0XHRcdGlmIChpbmRleCA+IDAgfHwgdGlja09wdHMucmV2ZXJzZSkge1xuXHRcdFx0XHRcdHZhciB5Q2VudGVyT2Zmc2V0ID0gbWUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUobWUudGlja3NBc051bWJlcnNbaW5kZXhdKTtcblxuXHRcdFx0XHRcdC8vIERyYXcgY2lyY3VsYXIgbGluZXMgYXJvdW5kIHRoZSBzY2FsZVxuXHRcdFx0XHRcdGlmIChncmlkTGluZU9wdHMuZGlzcGxheSAmJiBpbmRleCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0ZHJhd1JhZGl1c0xpbmUobWUsIGdyaWRMaW5lT3B0cywgeUNlbnRlck9mZnNldCwgaW5kZXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0aWNrT3B0cy5kaXNwbGF5KSB7XG5cdFx0XHRcdFx0XHR2YXIgdGlja0ZvbnRDb2xvciA9IHZhbHVlT3JEZWZhdWx0JGIodGlja09wdHMuZm9udENvbG9yLCBjb3JlX2RlZmF1bHRzLmdsb2JhbC5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdFx0XHRcdGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuXG5cdFx0XHRcdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZShtZS54Q2VudGVyLCBtZS55Q2VudGVyKTtcblx0XHRcdFx0XHRcdGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG5cblx0XHRcdFx0XHRcdGlmICh0aWNrT3B0cy5zaG93TGFiZWxCYWNrZHJvcCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbGFiZWxXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG5cdFx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrT3B0cy5iYWNrZHJvcENvbG9yO1xuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFJlY3QoXG5cdFx0XHRcdFx0XHRcdFx0LWxhYmVsV2lkdGggLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCxcblx0XHRcdFx0XHRcdFx0XHQteUNlbnRlck9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWSxcblx0XHRcdFx0XHRcdFx0XHRsYWJlbFdpZHRoICsgdGlja09wdHMuYmFja2Ryb3BQYWRkaW5nWCAqIDIsXG5cdFx0XHRcdFx0XHRcdFx0dGlja0ZvbnQuc2l6ZSArIHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZ1kgKiAyXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcblx0XHRcdFx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB0aWNrRm9udENvbG9yO1xuXHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxhYmVsLCAwLCAteUNlbnRlck9mZnNldCk7XG5cdFx0XHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDMgPSBkZWZhdWx0Q29uZmlnJDM7XG5zY2FsZV9yYWRpYWxMaW5lYXIuX2RlZmF1bHRzID0gX2RlZmF1bHRzJDM7XG5cbnZhciB2YWx1ZU9yRGVmYXVsdCRjID0gaGVscGVycyQxLnZhbHVlT3JEZWZhdWx0O1xuXG4vLyBJbnRlZ2VyIGNvbnN0YW50cyBhcmUgZnJvbSB0aGUgRVM2IHNwZWMuXG52YXIgTUlOX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiB8fCAtOTAwNzE5OTI1NDc0MDk5MTtcbnZhciBNQVhfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbnZhciBJTlRFUlZBTFMgPSB7XG5cdG1pbGxpc2Vjb25kOiB7XG5cdFx0Y29tbW9uOiB0cnVlLFxuXHRcdHNpemU6IDEsXG5cdFx0c3RlcHM6IFsxLCAyLCA1LCAxMCwgMjAsIDUwLCAxMDAsIDI1MCwgNTAwXVxuXHR9LFxuXHRzZWNvbmQ6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMTAwMCxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdH0sXG5cdG1pbnV0ZToge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiA2MDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDUsIDEwLCAxNSwgMzBdXG5cdH0sXG5cdGhvdXI6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMzYwMDAwMCxcblx0XHRzdGVwczogWzEsIDIsIDMsIDYsIDEyXVxuXHR9LFxuXHRkYXk6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogODY0MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCA1XVxuXHR9LFxuXHR3ZWVrOiB7XG5cdFx0Y29tbW9uOiBmYWxzZSxcblx0XHRzaXplOiA2MDQ4MDAwMDAsXG5cdFx0c3RlcHM6IFsxLCAyLCAzLCA0XVxuXHR9LFxuXHRtb250aDoge1xuXHRcdGNvbW1vbjogdHJ1ZSxcblx0XHRzaXplOiAyLjYyOGU5LFxuXHRcdHN0ZXBzOiBbMSwgMiwgM11cblx0fSxcblx0cXVhcnRlcjoge1xuXHRcdGNvbW1vbjogZmFsc2UsXG5cdFx0c2l6ZTogNy44ODRlOSxcblx0XHRzdGVwczogWzEsIDIsIDMsIDRdXG5cdH0sXG5cdHllYXI6IHtcblx0XHRjb21tb246IHRydWUsXG5cdFx0c2l6ZTogMy4xNTRlMTBcblx0fVxufTtcblxudmFyIFVOSVRTID0gT2JqZWN0LmtleXMoSU5URVJWQUxTKTtcblxuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcblx0cmV0dXJuIGEgLSBiO1xufVxuXG5mdW5jdGlvbiBhcnJheVVuaXF1ZShpdGVtcykge1xuXHR2YXIgaGFzaCA9IHt9O1xuXHR2YXIgb3V0ID0gW107XG5cdHZhciBpLCBpbGVuLCBpdGVtO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRpdGVtID0gaXRlbXNbaV07XG5cdFx0aWYgKCFoYXNoW2l0ZW1dKSB7XG5cdFx0XHRoYXNoW2l0ZW1dID0gdHJ1ZTtcblx0XHRcdG91dC5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB7dGltZSwgcG9zfSBvYmplY3RzIHVzZWQgdG8gaW50ZXJwb2xhdGUgYSBzcGVjaWZpYyBgdGltZWAgb3IgcG9zaXRpb25cbiAqIChgcG9zYCkgb24gdGhlIHNjYWxlLCBieSBzZWFyY2hpbmcgZW50cmllcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSByZXF1ZXN0ZWQgdmFsdWUuIGBwb3NgIGlzXG4gKiBhIGRlY2ltYWwgYmV0d2VlbiAwIGFuZCAxOiAwIGJlaW5nIHRoZSBzdGFydCBvZiB0aGUgc2NhbGUgKGxlZnQgb3IgdG9wKSBhbmQgMSB0aGUgb3RoZXJcbiAqIGV4dHJlbWl0eSAobGVmdCArIHdpZHRoIG9yIHRvcCArIGhlaWdodCkuIE5vdGUgdGhhdCBpdCB3b3VsZCBiZSBtb3JlIG9wdGltaXplZCB0byBkaXJlY3RseVxuICogc3RvcmUgcHJlLWNvbXB1dGVkIHBpeGVscywgYnV0IHRoZSBzY2FsZSBkaW1lbnNpb25zIGFyZSBub3QgZ3VhcmFudGVlZCBhdCB0aGUgdGltZSB3ZSBuZWVkXG4gKiB0byBjcmVhdGUgdGhlIGxvb2t1cCB0YWJsZS4gVGhlIHRhYmxlIEFMV0FZUyBjb250YWlucyBhdCBsZWFzdCB0d28gaXRlbXM6IG1pbiBhbmQgbWF4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHMgLSB0aW1lc3RhbXBzIHNvcnRlZCBmcm9tIGxvd2VzdCB0byBoaWdoZXN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3RyaWJ1dGlvbiAtIElmICdsaW5lYXInLCB0aW1lc3RhbXBzIHdpbGwgYmUgc3ByZWFkIGxpbmVhcmx5IGFsb25nIHRoZSBtaW5cbiAqIGFuZCBtYXggcmFuZ2UsIHNvIGJhc2ljYWxseSwgdGhlIHRhYmxlIHdpbGwgY29udGFpbnMgb25seSB0d28gaXRlbXM6IHttaW4sIDB9IGFuZCB7bWF4LCAxfS5cbiAqIElmICdzZXJpZXMnLCB0aW1lc3RhbXBzIHdpbGwgYmUgcG9zaXRpb25lZCBhdCB0aGUgc2FtZSBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuIEluIHRoaXNcbiAqIGNhc2UsIG9ubHkgdGltZXN0YW1wcyB0aGF0IGJyZWFrIHRoZSB0aW1lIGxpbmVhcml0eSBhcmUgcmVnaXN0ZXJlZCwgbWVhbmluZyB0aGF0IGluIHRoZVxuICogYmVzdCBjYXNlLCBhbGwgdGltZXN0YW1wcyBhcmUgbGluZWFyLCB0aGUgdGFibGUgY29udGFpbnMgb25seSBtaW4gYW5kIG1heC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzLCBtaW4sIG1heCwgZGlzdHJpYnV0aW9uKSB7XG5cdGlmIChkaXN0cmlidXRpb24gPT09ICdsaW5lYXInIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdHJldHVybiBbXG5cdFx0XHR7dGltZTogbWluLCBwb3M6IDB9LFxuXHRcdFx0e3RpbWU6IG1heCwgcG9zOiAxfVxuXHRcdF07XG5cdH1cblxuXHR2YXIgdGFibGUgPSBbXTtcblx0dmFyIGl0ZW1zID0gW21pbl07XG5cdHZhciBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGN1cnIgPSB0aW1lc3RhbXBzW2ldO1xuXHRcdGlmIChjdXJyID4gbWluICYmIGN1cnIgPCBtYXgpIHtcblx0XHRcdGl0ZW1zLnB1c2goY3Vycik7XG5cdFx0fVxuXHR9XG5cblx0aXRlbXMucHVzaChtYXgpO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRuZXh0ID0gaXRlbXNbaSArIDFdO1xuXHRcdHByZXYgPSBpdGVtc1tpIC0gMV07XG5cdFx0Y3VyciA9IGl0ZW1zW2ldO1xuXG5cdFx0Ly8gb25seSBhZGQgcG9pbnRzIHRoYXQgYnJlYWtzIHRoZSBzY2FsZSBsaW5lYXJpdHlcblx0XHRpZiAocHJldiA9PT0gdW5kZWZpbmVkIHx8IG5leHQgPT09IHVuZGVmaW5lZCB8fCBNYXRoLnJvdW5kKChuZXh0ICsgcHJldikgLyAyKSAhPT0gY3Vycikge1xuXHRcdFx0dGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0YWJsZTtcbn1cblxuLy8gQHNlZSBhZGFwdGVkIGZyb20gaHR0cHM6Ly93d3cuYW51amdha2hhci5jb20vMjAxNC8wMy8wMS9iaW5hcnktc2VhcmNoLWluLWphdmFzY3JpcHQvXG5mdW5jdGlvbiBsb29rdXAodGFibGUsIGtleSwgdmFsdWUpIHtcblx0dmFyIGxvID0gMDtcblx0dmFyIGhpID0gdGFibGUubGVuZ3RoIC0gMTtcblx0dmFyIG1pZCwgaTAsIGkxO1xuXG5cdHdoaWxlIChsbyA+PSAwICYmIGxvIDw9IGhpKSB7XG5cdFx0bWlkID0gKGxvICsgaGkpID4+IDE7XG5cdFx0aTAgPSB0YWJsZVttaWQgLSAxXSB8fCBudWxsO1xuXHRcdGkxID0gdGFibGVbbWlkXTtcblxuXHRcdGlmICghaTApIHtcblx0XHRcdC8vIGdpdmVuIHZhbHVlIGlzIG91dHNpZGUgdGFibGUgKGJlZm9yZSBmaXJzdCBpdGVtKVxuXHRcdFx0cmV0dXJuIHtsbzogbnVsbCwgaGk6IGkxfTtcblx0XHR9IGVsc2UgaWYgKGkxW2tleV0gPCB2YWx1ZSkge1xuXHRcdFx0bG8gPSBtaWQgKyAxO1xuXHRcdH0gZWxzZSBpZiAoaTBba2V5XSA+IHZhbHVlKSB7XG5cdFx0XHRoaSA9IG1pZCAtIDE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB7bG86IGkwLCBoaTogaTF9O1xuXHRcdH1cblx0fVxuXG5cdC8vIGdpdmVuIHZhbHVlIGlzIG91dHNpZGUgdGFibGUgKGFmdGVyIGxhc3QgaXRlbSlcblx0cmV0dXJuIHtsbzogaTEsIGhpOiBudWxsfTtcbn1cblxuLyoqXG4gKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdGhlIGdpdmVuIHNvdXJjZSBgdmFsdWVgIHVzaW5nIHRoZSB0YWJsZSBpdGVtcyBgc2tleWAgdmFsdWVzIGFuZFxuICogcmV0dXJucyB0aGUgYXNzb2NpYXRlZCBgdGtleWAgdmFsdWUuIEZvciBleGFtcGxlLCBpbnRlcnBvbGF0ZSh0YWJsZSwgJ3RpbWUnLCA0MiwgJ3BvcycpXG4gKiByZXR1cm5zIHRoZSBwb3NpdGlvbiBmb3IgYSB0aW1lc3RhbXAgZXF1YWwgdG8gNDIuIElmIHZhbHVlIGlzIG91dCBvZiBib3VuZHMsIHZhbHVlcyBhdFxuICogaW5kZXggWzAsIDFdIG9yIFtuIC0gMSwgbl0gYXJlIHVzZWQgZm9yIHRoZSBpbnRlcnBvbGF0aW9uLlxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSQxKHRhYmxlLCBza2V5LCBzdmFsLCB0a2V5KSB7XG5cdHZhciByYW5nZSA9IGxvb2t1cCh0YWJsZSwgc2tleSwgc3ZhbCk7XG5cblx0Ly8gTm90ZTogdGhlIGxvb2t1cCB0YWJsZSBBTFdBWVMgY29udGFpbnMgYXQgbGVhc3QgMiBpdGVtcyAobWluIGFuZCBtYXgpXG5cdHZhciBwcmV2ID0gIXJhbmdlLmxvID8gdGFibGVbMF0gOiAhcmFuZ2UuaGkgPyB0YWJsZVt0YWJsZS5sZW5ndGggLSAyXSA6IHJhbmdlLmxvO1xuXHR2YXIgbmV4dCA9ICFyYW5nZS5sbyA/IHRhYmxlWzFdIDogIXJhbmdlLmhpID8gdGFibGVbdGFibGUubGVuZ3RoIC0gMV0gOiByYW5nZS5oaTtcblxuXHR2YXIgc3BhbiA9IG5leHRbc2tleV0gLSBwcmV2W3NrZXldO1xuXHR2YXIgcmF0aW8gPSBzcGFuID8gKHN2YWwgLSBwcmV2W3NrZXldKSAvIHNwYW4gOiAwO1xuXHR2YXIgb2Zmc2V0ID0gKG5leHRbdGtleV0gLSBwcmV2W3RrZXldKSAqIHJhdGlvO1xuXG5cdHJldHVybiBwcmV2W3RrZXldICsgb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiB0b1RpbWVzdGFtcChzY2FsZSwgaW5wdXQpIHtcblx0dmFyIGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XG5cdHZhciBwYXJzZXIgPSBvcHRpb25zLnBhcnNlcjtcblx0dmFyIGZvcm1hdCA9IHBhcnNlciB8fCBvcHRpb25zLmZvcm1hdDtcblx0dmFyIHZhbHVlID0gaW5wdXQ7XG5cblx0aWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XG5cdH1cblxuXHQvLyBPbmx5IHBhcnNlIGlmIGl0cyBub3QgYSB0aW1lc3RhbXAgYWxyZWFkeVxuXHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh2YWx1ZSkpIHtcblx0XHR2YWx1ZSA9IHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnXG5cdFx0XHQ/IGFkYXB0ZXIucGFyc2UodmFsdWUsIGZvcm1hdClcblx0XHRcdDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG5cdH1cblxuXHRpZiAodmFsdWUgIT09IG51bGwpIHtcblx0XHRyZXR1cm4gK3ZhbHVlO1xuXHR9XG5cblx0Ly8gTGFiZWxzIGFyZSBpbiBhbiBpbmNvbXBhdGlibGUgZm9ybWF0IGFuZCBubyBgcGFyc2VyYCBoYXMgYmVlbiBwcm92aWRlZC5cblx0Ly8gVGhlIHVzZXIgbWlnaHQgc3RpbGwgdXNlIHRoZSBkZXByZWNhdGVkIGBmb3JtYXRgIG9wdGlvbiBmb3IgcGFyc2luZy5cblx0aWYgKCFwYXJzZXIgJiYgdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhbHVlID0gZm9ybWF0KGlucHV0KTtcblxuXHRcdC8vIGBmb3JtYXRgIGNvdWxkIHJldHVybiBzb21ldGhpbmcgZWxzZSB0aGFuIGEgdGltZXN0YW1wLCBpZiBzbywgcGFyc2UgaXRcblx0XHRpZiAoIWhlbHBlcnMkMS5pc0Zpbml0ZSh2YWx1ZSkpIHtcblx0XHRcdHZhbHVlID0gYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcblx0aWYgKGhlbHBlcnMkMS5pc051bGxPclVuZGVmKGlucHV0KSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zLnRpbWU7XG5cdHZhciB2YWx1ZSA9IHRvVGltZXN0YW1wKHNjYWxlLCBzY2FsZS5nZXRSaWdodFZhbHVlKGlucHV0KSk7XG5cdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGlmIChvcHRpb25zLnJvdW5kKSB7XG5cdFx0dmFsdWUgPSArc2NhbGUuX2FkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgb3B0aW9ucy5yb3VuZCk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHVuaXQgdG8gc2tpcCB0byBiZSBhYmxlIHRvIGRpc3BsYXkgdXAgdG8gYGNhcGFjaXR5YCBudW1iZXIgb2YgdGlja3NcbiAqIGluIGB1bml0YCBmb3IgdGhlIGdpdmVuIGBtaW5gIC8gYG1heGAgcmFuZ2UgYW5kIHJlc3BlY3RpbmcgdGhlIGludGVydmFsIHN0ZXBzIGNvbnN0cmFpbnRzLlxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVTdGVwU2l6ZShtaW4sIG1heCwgdW5pdCwgY2FwYWNpdHkpIHtcblx0dmFyIHJhbmdlID0gbWF4IC0gbWluO1xuXHR2YXIgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbdW5pdF07XG5cdHZhciBtaWxsaXNlY29uZHMgPSBpbnRlcnZhbC5zaXplO1xuXHR2YXIgc3RlcHMgPSBpbnRlcnZhbC5zdGVwcztcblx0dmFyIGksIGlsZW4sIGZhY3RvcjtcblxuXHRpZiAoIXN0ZXBzKSB7XG5cdFx0cmV0dXJuIE1hdGguY2VpbChyYW5nZSAvIChjYXBhY2l0eSAqIG1pbGxpc2Vjb25kcykpO1xuXHR9XG5cblx0Zm9yIChpID0gMCwgaWxlbiA9IHN0ZXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdGZhY3RvciA9IHN0ZXBzW2ldO1xuXHRcdGlmIChNYXRoLmNlaWwocmFuZ2UgLyAobWlsbGlzZWNvbmRzICogZmFjdG9yKSkgPD0gY2FwYWNpdHkpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmYWN0b3I7XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHJlc3VsdHMgaW4gYW4gYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGF1dG8tZ2VuZXJhdGVkIHRpY2tzXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JBdXRvVGlja3MobWluVW5pdCwgbWluLCBtYXgsIGNhcGFjaXR5KSB7XG5cdHZhciBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXHR2YXIgaSwgaW50ZXJ2YWwsIGZhY3RvcjtcblxuXHRmb3IgKGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xuXHRcdGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcblx0XHRmYWN0b3IgPSBpbnRlcnZhbC5zdGVwcyA/IGludGVydmFsLnN0ZXBzW2ludGVydmFsLnN0ZXBzLmxlbmd0aCAtIDFdIDogTUFYX0lOVEVHRVI7XG5cblx0XHRpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcblx0XHRcdHJldHVybiBVTklUU1tpXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCB0byBmb3JtYXQgYSBzZXQgb2YgdGlja3Mgd2l0aFxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgdGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG5cdHZhciBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXHR2YXIgaSwgdW5pdDtcblxuXHRmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcblx0XHR1bml0ID0gVU5JVFNbaV07XG5cdFx0aWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gdGlja3MubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdW5pdDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcblx0Zm9yICh2YXIgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG5cdFx0XHRyZXR1cm4gVU5JVFNbaV07XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWF4aW11bSBvZiBgY2FwYWNpdHlgIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgcm91bmRlZCB0byB0aGVcbiAqIGBtaW5vcmAgdW5pdCwgYWxpZ25lZCBvbiB0aGUgYG1ham9yYCB1bml0IGFuZCB1c2luZyB0aGUgZ2l2ZW4gc2NhbGUgdGltZSBgb3B0aW9uc2AuXG4gKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG4gKiByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGluZyBjb2RlIHRvIGNsYW1wIHZhbHVlcyBpZiBuZWVkZWQuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKHNjYWxlLCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcblx0dmFyIGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcblx0dmFyIG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuXHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdHZhciBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpO1xuXHR2YXIgbWFqb3IgPSBkZXRlcm1pbmVNYWpvclVuaXQobWlub3IpO1xuXHR2YXIgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpbWVPcHRzLnN0ZXBTaXplLCB0aW1lT3B0cy51bml0U3RlcFNpemUpO1xuXHR2YXIgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG5cdHZhciBtYWpvclRpY2tzRW5hYmxlZCA9IG9wdGlvbnMudGlja3MubWFqb3IuZW5hYmxlZDtcblx0dmFyIGludGVydmFsID0gSU5URVJWQUxTW21pbm9yXTtcblx0dmFyIGZpcnN0ID0gbWluO1xuXHR2YXIgbGFzdCA9IG1heDtcblx0dmFyIHRpY2tzID0gW107XG5cdHZhciB0aW1lO1xuXG5cdGlmICghc3RlcFNpemUpIHtcblx0XHRzdGVwU2l6ZSA9IGRldGVybWluZVN0ZXBTaXplKG1pbiwgbWF4LCBtaW5vciwgY2FwYWNpdHkpO1xuXHR9XG5cblx0Ly8gRm9yICd3ZWVrJyB1bml0LCBoYW5kbGUgdGhlIGZpcnN0IGRheSBvZiB3ZWVrIG9wdGlvblxuXHRpZiAod2Vla2RheSkge1xuXHRcdGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcblx0XHRsYXN0ID0gK2FkYXB0ZXIuc3RhcnRPZihsYXN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuXHR9XG5cblx0Ly8gQWxpZ24gZmlyc3QvbGFzdCB0aWNrcyBvbiB1bml0XG5cdGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgd2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXHRsYXN0ID0gK2FkYXB0ZXIuc3RhcnRPZihsYXN0LCB3ZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG5cblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGxhc3QgdGljayBpbmNsdWRlIG1heFxuXHRpZiAobGFzdCA8IG1heCkge1xuXHRcdGxhc3QgPSArYWRhcHRlci5hZGQobGFzdCwgMSwgbWlub3IpO1xuXHR9XG5cblx0dGltZSA9IGZpcnN0O1xuXG5cdGlmIChtYWpvclRpY2tzRW5hYmxlZCAmJiBtYWpvciAmJiAhd2Vla2RheSAmJiAhdGltZU9wdHMucm91bmQpIHtcblx0XHQvLyBBbGlnbiB0aGUgZmlyc3QgdGljayBvbiB0aGUgcHJldmlvdXMgYG1pbm9yYCB1bml0IGFsaWduZWQgb24gdGhlIGBtYWpvcmAgdW5pdDpcblx0XHQvLyB3ZSBmaXJzdCBhbGlnbmVkIHRpbWUgb24gdGhlIHByZXZpb3VzIGBtYWpvcmAgdW5pdCB0aGVuIGFkZCB0aGUgbnVtYmVyIG9mIGZ1bGxcblx0XHQvLyBzdGVwU2l6ZSB0aGVyZSBpcyBiZXR3ZWVuIGZpcnN0IGFuZCB0aGUgcHJldmlvdXMgbWFqb3IgdGltZS5cblx0XHR0aW1lID0gK2FkYXB0ZXIuc3RhcnRPZih0aW1lLCBtYWpvcik7XG5cdFx0dGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCB+figoZmlyc3QgLSB0aW1lKSAvIChpbnRlcnZhbC5zaXplICogc3RlcFNpemUpKSAqIHN0ZXBTaXplLCBtaW5vcik7XG5cdH1cblxuXHRmb3IgKDsgdGltZSA8IGxhc3Q7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSkge1xuXHRcdHRpY2tzLnB1c2goK3RpbWUpO1xuXHR9XG5cblx0dGlja3MucHVzaCgrdGltZSk7XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtzdGFydCwgZW5kfVxuICogd2hlcmUgZWFjaCB2YWx1ZSBpcyBhIHJlbGF0aXZlIHdpZHRoIHRvIHRoZSBzY2FsZSBhbmQgcmFuZ2VzIGJldHdlZW4gMCBhbmQgMS5cbiAqIFRoZXkgYWRkIGV4dHJhIG1hcmdpbnMgb24gdGhlIGJvdGggc2lkZXMgYnkgc2NhbGluZyBkb3duIHRoZSBvcmlnaW5hbCBzY2FsZS5cbiAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuICovXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyh0YWJsZSwgdGlja3MsIG1pbiwgbWF4LCBvcHRpb25zKSB7XG5cdHZhciBzdGFydCA9IDA7XG5cdHZhciBlbmQgPSAwO1xuXHR2YXIgZmlyc3QsIGxhc3Q7XG5cblx0aWYgKG9wdGlvbnMub2Zmc2V0ICYmIHRpY2tzLmxlbmd0aCkge1xuXHRcdGlmICghb3B0aW9ucy50aW1lLm1pbikge1xuXHRcdFx0Zmlyc3QgPSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzWzBdLCAncG9zJyk7XG5cdFx0XHRpZiAodGlja3MubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHN0YXJ0ID0gMSAtIGZpcnN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhcnQgPSAoaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1sxXSwgJ3BvcycpIC0gZmlyc3QpIC8gMjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFvcHRpb25zLnRpbWUubWF4KSB7XG5cdFx0XHRsYXN0ID0gaW50ZXJwb2xhdGUkMSh0YWJsZSwgJ3RpbWUnLCB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSwgJ3BvcycpO1xuXHRcdFx0aWYgKHRpY2tzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRlbmQgPSBsYXN0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZW5kID0gKGxhc3QgLSBpbnRlcnBvbGF0ZSQxKHRhYmxlLCAndGltZScsIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDJdLCAncG9zJykpIC8gMjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge3N0YXJ0OiBzdGFydCwgZW5kOiBlbmR9O1xufVxuXG5mdW5jdGlvbiB0aWNrc0Zyb21UaW1lc3RhbXBzKHNjYWxlLCB2YWx1ZXMsIG1ham9yVW5pdCkge1xuXHR2YXIgdGlja3MgPSBbXTtcblx0dmFyIGksIGlsZW4sIHZhbHVlLCBtYWpvcjtcblxuXHRmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuXHRcdHZhbHVlID0gdmFsdWVzW2ldO1xuXHRcdG1ham9yID0gbWFqb3JVbml0ID8gdmFsdWUgPT09ICtzY2FsZS5fYWRhcHRlci5zdGFydE9mKHZhbHVlLCBtYWpvclVuaXQpIDogZmFsc2U7XG5cblx0XHR0aWNrcy5wdXNoKHtcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdG1ham9yOiBtYWpvclxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHRpY2tzO1xufVxuXG52YXIgZGVmYXVsdENvbmZpZyQ0ID0ge1xuXHRwb3NpdGlvbjogJ2JvdHRvbScsXG5cblx0LyoqXG5cdCAqIERhdGEgZGlzdHJpYnV0aW9uIGFsb25nIHRoZSBzY2FsZTpcblx0ICogLSAnbGluZWFyJzogZGF0YSBhcmUgc3ByZWFkIGFjY29yZGluZyB0byB0aGVpciB0aW1lIChkaXN0YW5jZXMgY2FuIHZhcnkpLFxuXHQgKiAtICdzZXJpZXMnOiBkYXRhIGFyZSBzcHJlYWQgYXQgdGhlIHNhbWUgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLlxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGRpc3RyaWJ1dGlvbjogJ2xpbmVhcicsXG5cblx0LyoqXG5cdCAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcblx0ICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG5cdCAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuXHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxuXHQgKiBAc2luY2UgMi43LjBcblx0ICovXG5cdGJvdW5kczogJ2RhdGEnLFxuXG5cdGFkYXB0ZXJzOiB7fSxcblx0dGltZToge1xuXHRcdHBhcnNlcjogZmFsc2UsIC8vIGZhbHNlID09IGEgcGF0dGVybiBzdHJpbmcgZnJvbSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvcGFyc2luZy9zdHJpbmctZm9ybWF0LyBvciBhIGN1c3RvbSBjYWxsYmFjayB0aGF0IGNvbnZlcnRzIGl0cyBhcmd1bWVudCB0byBhIG1vbWVudFxuXHRcdGZvcm1hdDogZmFsc2UsIC8vIERFUFJFQ0FURUQgZmFsc2UgPT0gZGF0ZSBvYmplY3RzLCBtb21lbnQgb2JqZWN0LCBjYWxsYmFjayBvciBhIHBhdHRlcm4gc3RyaW5nIGZyb20gaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdC9cblx0XHR1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRyb3VuZDogZmFsc2UsIC8vIG5vbmUsIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cblx0XHRkaXNwbGF5Rm9ybWF0OiBmYWxzZSwgLy8gREVQUkVDQVRFRFxuXHRcdGlzb1dlZWtkYXk6IGZhbHNlLCAvLyBvdmVycmlkZSB3ZWVrIHN0YXJ0IGRheSAtIHNlZSBodHRwczovL21vbWVudGpzLmNvbS9kb2NzLyMvZ2V0LXNldC9pc28td2Vla2RheS9cblx0XHRtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuXHRcdGRpc3BsYXlGb3JtYXRzOiB7fVxuXHR9LFxuXHR0aWNrczoge1xuXHRcdGF1dG9Ta2lwOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCAqIFRpY2tzIGdlbmVyYXRpb24gaW5wdXQgdmFsdWVzOlxuXHRcdCAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxuXHRcdCAqIC0gJ2RhdGEnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSBkYXRhIChpbmNsdWRpbmcgbGFiZWxzIGZyb20gZGF0YSB7dHx4fHl9IG9iamVjdHMpLlxuXHRcdCAqIC0gJ2xhYmVscyc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIHVzZXIgZ2l2ZW4gYGRhdGEubGFiZWxzYCB2YWx1ZXMgT05MWS5cblx0XHQgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuXHRcdCAqIEBzaW5jZSAyLjcuMFxuXHRcdCAqL1xuXHRcdHNvdXJjZTogJ2F1dG8nLFxuXG5cdFx0bWFqb3I6IHtcblx0XHRcdGVuYWJsZWQ6IGZhbHNlXG5cdFx0fVxuXHR9XG59O1xuXG52YXIgc2NhbGVfdGltZSA9IGNvcmVfc2NhbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tZXJnZVRpY2tzT3B0aW9ucygpO1xuXHRcdGNvcmVfc2NhbGUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0aW1lID0gb3B0aW9ucy50aW1lIHx8IChvcHRpb25zLnRpbWUgPSB7fSk7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlciA9IG5ldyBjb3JlX2FkYXB0ZXJzLl9kYXRlKG9wdGlvbnMuYWRhcHRlcnMuZGF0ZSk7XG5cblx0XHQvLyBERVBSRUNBVElPTlM6IG91dHB1dCBhIG1lc3NhZ2Ugb25seSBvbmUgdGltZSBwZXIgdXBkYXRlXG5cdFx0aWYgKHRpbWUuZm9ybWF0KSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ29wdGlvbnMudGltZS5mb3JtYXQgaXMgZGVwcmVjYXRlZCBhbmQgcmVwbGFjZWQgYnkgb3B0aW9ucy50aW1lLnBhcnNlci4nKTtcblx0XHR9XG5cblx0XHQvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBiZWZvcmUgaW50cm9kdWNpbmcgYWRhcHRlciwgYGRpc3BsYXlGb3JtYXRzYCB3YXNcblx0XHQvLyBzdXBwb3NlZCB0byBjb250YWluICphbGwqIHVuaXQvc3RyaW5nIHBhaXJzIGJ1dCB0aGlzIGNhbid0IGJlIHJlc29sdmVkXG5cdFx0Ly8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxuXHRcdC8vIG1pc3NpbmcgZm9ybWF0cyBvbiB1cGRhdGVcblx0XHRoZWxwZXJzJDEubWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG5cblx0XHRyZXR1cm4gY29yZV9zY2FsZS5wcm90b3R5cGUudXBkYXRlLmFwcGx5KG1lLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBbGxvd3MgZGF0YSB0byBiZSByZWZlcmVuY2VkIHZpYSAndCcgYXR0cmlidXRlXG5cdCAqL1xuXHRnZXRSaWdodFZhbHVlOiBmdW5jdGlvbihyYXdWYWx1ZSkge1xuXHRcdGlmIChyYXdWYWx1ZSAmJiByYXdWYWx1ZS50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJhd1ZhbHVlID0gcmF3VmFsdWUudDtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcmVfc2NhbGUucHJvdG90eXBlLmdldFJpZ2h0VmFsdWUuY2FsbCh0aGlzLCByYXdWYWx1ZSk7XG5cdH0sXG5cblx0ZGV0ZXJtaW5lRGF0YUxpbWl0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgY2hhcnQgPSBtZS5jaGFydDtcblx0XHR2YXIgYWRhcHRlciA9IG1lLl9hZGFwdGVyO1xuXHRcdHZhciB0aW1lT3B0cyA9IG1lLm9wdGlvbnMudGltZTtcblx0XHR2YXIgdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgJ2RheSc7XG5cdFx0dmFyIG1pbiA9IE1BWF9JTlRFR0VSO1xuXHRcdHZhciBtYXggPSBNSU5fSU5URUdFUjtcblx0XHR2YXIgdGltZXN0YW1wcyA9IFtdO1xuXHRcdHZhciBkYXRhc2V0cyA9IFtdO1xuXHRcdHZhciBsYWJlbHMgPSBbXTtcblx0XHR2YXIgaSwgaiwgaWxlbiwgamxlbiwgZGF0YSwgdGltZXN0YW1wO1xuXHRcdHZhciBkYXRhTGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG5cblx0XHQvLyBDb252ZXJ0IGxhYmVscyB0byB0aW1lc3RhbXBzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IGRhdGFMYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRsYWJlbHMucHVzaChwYXJzZShtZSwgZGF0YUxhYmVsc1tpXSkpO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSB0byB0aW1lc3RhbXBzXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcblx0XHRcdGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG5cdFx0XHRcdGRhdGEgPSBjaGFydC5kYXRhLmRhdGFzZXRzW2ldLmRhdGE7XG5cblx0XHRcdFx0Ly8gTGV0J3MgY29uc2lkZXIgdGhhdCBhbGwgZGF0YSBoYXZlIHRoZSBzYW1lIGZvcm1hdC5cblx0XHRcdFx0aWYgKGhlbHBlcnMkMS5pc09iamVjdChkYXRhWzBdKSkge1xuXHRcdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XG5cblx0XHRcdFx0XHRmb3IgKGogPSAwLCBqbGVuID0gZGF0YS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcCA9IHBhcnNlKG1lLCBkYXRhW2pdKTtcblx0XHRcdFx0XHRcdHRpbWVzdGFtcHMucHVzaCh0aW1lc3RhbXApO1xuXHRcdFx0XHRcdFx0ZGF0YXNldHNbaV1bal0gPSB0aW1lc3RhbXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbHMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG5cdFx0XHRcdFx0XHR0aW1lc3RhbXBzLnB1c2gobGFiZWxzW2pdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YXNldHNbaV0gPSBsYWJlbHMuc2xpY2UoMCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFzZXRzW2ldID0gW107XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGxhYmVscy5sZW5ndGgpIHtcblx0XHRcdC8vIFNvcnQgbGFiZWxzICoqYWZ0ZXIqKiBkYXRhIGhhdmUgYmVlbiBjb252ZXJ0ZWRcblx0XHRcdGxhYmVscyA9IGFycmF5VW5pcXVlKGxhYmVscykuc29ydChzb3J0ZXIpO1xuXHRcdFx0bWluID0gTWF0aC5taW4obWluLCBsYWJlbHNbMF0pO1xuXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCBsYWJlbHNbbGFiZWxzLmxlbmd0aCAtIDFdKTtcblx0XHR9XG5cblx0XHRpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcblx0XHRcdHRpbWVzdGFtcHMgPSBhcnJheVVuaXF1ZSh0aW1lc3RhbXBzKS5zb3J0KHNvcnRlcik7XG5cdFx0XHRtaW4gPSBNYXRoLm1pbihtaW4sIHRpbWVzdGFtcHNbMF0pO1xuXHRcdFx0bWF4ID0gTWF0aC5tYXgobWF4LCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuXHRcdH1cblxuXHRcdG1pbiA9IHBhcnNlKG1lLCB0aW1lT3B0cy5taW4pIHx8IG1pbjtcblx0XHRtYXggPSBwYXJzZShtZSwgdGltZU9wdHMubWF4KSB8fCBtYXg7XG5cblx0XHQvLyBJbiBjYXNlIHRoZXJlIGlzIG5vIHZhbGlkIG1pbi9tYXgsIHNldCBsaW1pdHMgYmFzZWQgb24gdW5pdCB0aW1lIG9wdGlvblxuXHRcdG1pbiA9IG1pbiA9PT0gTUFYX0lOVEVHRVIgPyArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpIDogbWluO1xuXHRcdG1heCA9IG1heCA9PT0gTUlOX0lOVEVHRVIgPyArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDEgOiBtYXg7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBtYXggaXMgc3RyaWN0bHkgaGlnaGVyIHRoYW4gbWluIChyZXF1aXJlZCBieSB0aGUgbG9va3VwIHRhYmxlKVxuXHRcdG1lLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4KTtcblx0XHRtZS5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuXG5cdFx0Ly8gUFJJVkFURVxuXHRcdG1lLl9ob3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0bWUuX3RhYmxlID0gW107XG5cdFx0bWUuX3RpbWVzdGFtcHMgPSB7XG5cdFx0XHRkYXRhOiB0aW1lc3RhbXBzLFxuXHRcdFx0ZGF0YXNldHM6IGRhdGFzZXRzLFxuXHRcdFx0bGFiZWxzOiBsYWJlbHNcblx0XHR9O1xuXHR9LFxuXG5cdGJ1aWxkVGlja3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG1pbiA9IG1lLm1pbjtcblx0XHR2YXIgbWF4ID0gbWUubWF4O1xuXHRcdHZhciBvcHRpb25zID0gbWUub3B0aW9ucztcblx0XHR2YXIgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG5cdFx0dmFyIHRpbWVzdGFtcHMgPSBbXTtcblx0XHR2YXIgdGlja3MgPSBbXTtcblx0XHR2YXIgaSwgaWxlbiwgdGltZXN0YW1wO1xuXG5cdFx0c3dpdGNoIChvcHRpb25zLnRpY2tzLnNvdXJjZSkge1xuXHRcdGNhc2UgJ2RhdGEnOlxuXHRcdFx0dGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzLmRhdGE7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbHMnOlxuXHRcdFx0dGltZXN0YW1wcyA9IG1lLl90aW1lc3RhbXBzLmxhYmVscztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2F1dG8nOlxuXHRcdGRlZmF1bHQ6XG5cdFx0XHR0aW1lc3RhbXBzID0gZ2VuZXJhdGUobWUsIG1pbiwgbWF4LCBtZS5nZXRMYWJlbENhcGFjaXR5KG1pbiksIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuXHRcdFx0bWluID0gdGltZXN0YW1wc1swXTtcblx0XHRcdG1heCA9IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcblx0XHR9XG5cblx0XHQvLyBFbmZvcmNlIGxpbWl0cyB3aXRoIHVzZXIgbWluL21heCBvcHRpb25zXG5cdFx0bWluID0gcGFyc2UobWUsIHRpbWVPcHRzLm1pbikgfHwgbWluO1xuXHRcdG1heCA9IHBhcnNlKG1lLCB0aW1lT3B0cy5tYXgpIHx8IG1heDtcblxuXHRcdC8vIFJlbW92ZSB0aWNrcyBvdXRzaWRlIHRoZSBtaW4vbWF4IHJhbmdlXG5cdFx0Zm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHR0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2ldO1xuXHRcdFx0aWYgKHRpbWVzdGFtcCA+PSBtaW4gJiYgdGltZXN0YW1wIDw9IG1heCkge1xuXHRcdFx0XHR0aWNrcy5wdXNoKHRpbWVzdGFtcCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUubWluID0gbWluO1xuXHRcdG1lLm1heCA9IG1heDtcblxuXHRcdC8vIFBSSVZBVEVcblx0XHRtZS5fdW5pdCA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcobWUsIHRpY2tzLCB0aW1lT3B0cy5taW5Vbml0LCBtZS5taW4sIG1lLm1heCk7XG5cdFx0bWUuX21ham9yVW5pdCA9IGRldGVybWluZU1ham9yVW5pdChtZS5fdW5pdCk7XG5cdFx0bWUuX3RhYmxlID0gYnVpbGRMb29rdXBUYWJsZShtZS5fdGltZXN0YW1wcy5kYXRhLCBtaW4sIG1heCwgb3B0aW9ucy5kaXN0cmlidXRpb24pO1xuXHRcdG1lLl9vZmZzZXRzID0gY29tcHV0ZU9mZnNldHMobWUuX3RhYmxlLCB0aWNrcywgbWluLCBtYXgsIG9wdGlvbnMpO1xuXG5cdFx0aWYgKG9wdGlvbnMudGlja3MucmV2ZXJzZSkge1xuXHRcdFx0dGlja3MucmV2ZXJzZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKG1lLCB0aWNrcywgbWUuX21ham9yVW5pdCk7XG5cdH0sXG5cblx0Z2V0TGFiZWxGb3JJbmRleDogZnVuY3Rpb24oaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcblx0XHR2YXIgZGF0YSA9IG1lLmNoYXJ0LmRhdGE7XG5cdFx0dmFyIHRpbWVPcHRzID0gbWUub3B0aW9ucy50aW1lO1xuXHRcdHZhciBsYWJlbCA9IGRhdGEubGFiZWxzICYmIGluZGV4IDwgZGF0YS5sYWJlbHMubGVuZ3RoID8gZGF0YS5sYWJlbHNbaW5kZXhdIDogJyc7XG5cdFx0dmFyIHZhbHVlID0gZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdO1xuXG5cdFx0aWYgKGhlbHBlcnMkMS5pc09iamVjdCh2YWx1ZSkpIHtcblx0XHRcdGxhYmVsID0gbWUuZ2V0UmlnaHRWYWx1ZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG5cdFx0XHRyZXR1cm4gYWRhcHRlci5mb3JtYXQodG9UaW1lc3RhbXAobWUsIGxhYmVsKSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbGFiZWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0fVxuXHRcdHJldHVybiBhZGFwdGVyLmZvcm1hdCh0b1RpbWVzdGFtcChtZSwgbGFiZWwpLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRvIGZvcm1hdCBhbiBpbmRpdmlkdWFsIHRpY2sgbWFya1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dGlja0Zvcm1hdEZ1bmN0aW9uOiBmdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGFkYXB0ZXIgPSBtZS5fYWRhcHRlcjtcblx0XHR2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG5cdFx0dmFyIG1pbm9yRm9ybWF0ID0gZm9ybWF0c1ttZS5fdW5pdF07XG5cdFx0dmFyIG1ham9yVW5pdCA9IG1lLl9tYWpvclVuaXQ7XG5cdFx0dmFyIG1ham9yRm9ybWF0ID0gZm9ybWF0c1ttYWpvclVuaXRdO1xuXHRcdHZhciBtYWpvclRpbWUgPSArYWRhcHRlci5zdGFydE9mKHRpbWUsIG1ham9yVW5pdCk7XG5cdFx0dmFyIG1ham9yVGlja09wdHMgPSBvcHRpb25zLnRpY2tzLm1ham9yO1xuXHRcdHZhciBtYWpvciA9IG1ham9yVGlja09wdHMuZW5hYmxlZCAmJiBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGltZSA9PT0gbWFqb3JUaW1lO1xuXHRcdHZhciBsYWJlbCA9IGFkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCA/IGZvcm1hdCA6IG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCk7XG5cdFx0dmFyIHRpY2tPcHRzID0gbWFqb3IgPyBtYWpvclRpY2tPcHRzIDogb3B0aW9ucy50aWNrcy5taW5vcjtcblx0XHR2YXIgZm9ybWF0dGVyID0gdmFsdWVPckRlZmF1bHQkYyh0aWNrT3B0cy5jYWxsYmFjaywgdGlja09wdHMudXNlckNhbGxiYWNrKTtcblxuXHRcdHJldHVybiBmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIobGFiZWwsIGluZGV4LCB0aWNrcykgOiBsYWJlbDtcblx0fSxcblxuXHRjb252ZXJ0VGlja3NUb0xhYmVsczogZnVuY3Rpb24odGlja3MpIHtcblx0XHR2YXIgbGFiZWxzID0gW107XG5cdFx0dmFyIGksIGlsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0XHRsYWJlbHMucHVzaCh0aGlzLnRpY2tGb3JtYXRGdW5jdGlvbih0aWNrc1tpXS52YWx1ZSwgaSwgdGlja3MpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGFiZWxzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0UGl4ZWxGb3JPZmZzZXQ6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBpc1JldmVyc2UgPSBtZS5vcHRpb25zLnRpY2tzLnJldmVyc2U7XG5cdFx0dmFyIHNpemUgPSBtZS5faG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBzdGFydCA9IG1lLl9ob3Jpem9udGFsID8gaXNSZXZlcnNlID8gbWUucmlnaHQgOiBtZS5sZWZ0IDogaXNSZXZlcnNlID8gbWUuYm90dG9tIDogbWUudG9wO1xuXHRcdHZhciBwb3MgPSBpbnRlcnBvbGF0ZSQxKG1lLl90YWJsZSwgJ3RpbWUnLCB0aW1lLCAncG9zJyk7XG5cdFx0dmFyIG9mZnNldCA9IHNpemUgKiAobWUuX29mZnNldHMuc3RhcnQgKyBwb3MpIC8gKG1lLl9vZmZzZXRzLnN0YXJ0ICsgMSArIG1lLl9vZmZzZXRzLmVuZCk7XG5cblx0XHRyZXR1cm4gaXNSZXZlcnNlID8gc3RhcnQgLSBvZmZzZXQgOiBzdGFydCArIG9mZnNldDtcblx0fSxcblxuXHRnZXRQaXhlbEZvclZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGRhdGFzZXRJbmRleCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHRpbWUgPSBudWxsO1xuXG5cdFx0aWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldEluZGV4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRpbWUgPSBtZS5fdGltZXN0YW1wcy5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdW2luZGV4XTtcblx0XHR9XG5cblx0XHRpZiAodGltZSA9PT0gbnVsbCkge1xuXHRcdFx0dGltZSA9IHBhcnNlKG1lLCB2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRpbWUgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiBtZS5nZXRQaXhlbEZvck9mZnNldCh0aW1lKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UGl4ZWxGb3JUaWNrOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciB0aWNrcyA9IHRoaXMuZ2V0VGlja3MoKTtcblx0XHRyZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCA/XG5cdFx0XHR0aGlzLmdldFBpeGVsRm9yT2Zmc2V0KHRpY2tzW2luZGV4XS52YWx1ZSkgOlxuXHRcdFx0bnVsbDtcblx0fSxcblxuXHRnZXRWYWx1ZUZvclBpeGVsOiBmdW5jdGlvbihwaXhlbCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIHNpemUgPSBtZS5faG9yaXpvbnRhbCA/IG1lLndpZHRoIDogbWUuaGVpZ2h0O1xuXHRcdHZhciBzdGFydCA9IG1lLl9ob3Jpem9udGFsID8gbWUubGVmdCA6IG1lLnRvcDtcblx0XHR2YXIgcG9zID0gKHNpemUgPyAocGl4ZWwgLSBzdGFydCkgLyBzaXplIDogMCkgKiAobWUuX29mZnNldHMuc3RhcnQgKyAxICsgbWUuX29mZnNldHMuc3RhcnQpIC0gbWUuX29mZnNldHMuZW5kO1xuXHRcdHZhciB0aW1lID0gaW50ZXJwb2xhdGUkMShtZS5fdGFibGUsICdwb3MnLCBwb3MsICd0aW1lJyk7XG5cblx0XHQvLyBERVBSRUNBVElPTiwgd2Ugc2hvdWxkIHJldHVybiB0aW1lIGRpcmVjdGx5XG5cdFx0cmV0dXJuIG1lLl9hZGFwdGVyLl9jcmVhdGUodGltZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENydWRlIGFwcHJveGltYXRpb24gb2Ygd2hhdCB0aGUgbGFiZWwgd2lkdGggbWlnaHQgYmVcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGdldExhYmVsV2lkdGg6IGZ1bmN0aW9uKGxhYmVsKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgdGlja3NPcHRzID0gbWUub3B0aW9ucy50aWNrcztcblx0XHR2YXIgdGlja0xhYmVsV2lkdGggPSBtZS5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuXHRcdHZhciBhbmdsZSA9IGhlbHBlcnMkMS50b1JhZGlhbnModGlja3NPcHRzLm1heFJvdGF0aW9uKTtcblx0XHR2YXIgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0dmFyIHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuXHRcdHZhciB0aWNrRm9udFNpemUgPSB2YWx1ZU9yRGVmYXVsdCRjKHRpY2tzT3B0cy5mb250U2l6ZSwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTaXplKTtcblxuXHRcdHJldHVybiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0Z2V0TGFiZWxDYXBhY2l0eTogZnVuY3Rpb24oZXhhbXBsZVRpbWUpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXG5cdFx0Ly8gcGljayB0aGUgbG9uZ2VzdCBmb3JtYXQgKG1pbGxpc2Vjb25kcykgZm9yIGd1ZXN0aW1hdGlvblxuXHRcdHZhciBmb3JtYXQgPSBtZS5vcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG5cdFx0dmFyIGV4YW1wbGVMYWJlbCA9IG1lLnRpY2tGb3JtYXRGdW5jdGlvbihleGFtcGxlVGltZSwgMCwgW10sIGZvcm1hdCk7XG5cdFx0dmFyIHRpY2tMYWJlbFdpZHRoID0gbWUuZ2V0TGFiZWxXaWR0aChleGFtcGxlTGFiZWwpO1xuXHRcdHZhciBpbm5lcldpZHRoID0gbWUuaXNIb3Jpem9udGFsKCkgPyBtZS53aWR0aCA6IG1lLmhlaWdodDtcblx0XHR2YXIgY2FwYWNpdHkgPSBNYXRoLmZsb29yKGlubmVyV2lkdGggLyB0aWNrTGFiZWxXaWR0aCk7XG5cblx0XHRyZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuXHR9XG59KTtcblxuLy8gSU5URVJOQUw6IHN0YXRpYyBkZWZhdWx0IG9wdGlvbnMsIHJlZ2lzdGVyZWQgaW4gc3JjL2luZGV4LmpzXG52YXIgX2RlZmF1bHRzJDQgPSBkZWZhdWx0Q29uZmlnJDQ7XG5zY2FsZV90aW1lLl9kZWZhdWx0cyA9IF9kZWZhdWx0cyQ0O1xuXG52YXIgc2NhbGVzID0ge1xuXHRjYXRlZ29yeTogc2NhbGVfY2F0ZWdvcnksXG5cdGxpbmVhcjogc2NhbGVfbGluZWFyLFxuXHRsb2dhcml0aG1pYzogc2NhbGVfbG9nYXJpdGhtaWMsXG5cdHJhZGlhbExpbmVhcjogc2NhbGVfcmFkaWFsTGluZWFyLFxuXHR0aW1lOiBzY2FsZV90aW1lXG59O1xuXG52YXIgRk9STUFUUyA9IHtcblx0ZGF0ZXRpbWU6ICdNTU0gRCwgWVlZWSwgaDptbTpzcyBhJyxcblx0bWlsbGlzZWNvbmQ6ICdoOm1tOnNzLlNTUyBhJyxcblx0c2Vjb25kOiAnaDptbTpzcyBhJyxcblx0bWludXRlOiAnaDptbSBhJyxcblx0aG91cjogJ2hBJyxcblx0ZGF5OiAnTU1NIEQnLFxuXHR3ZWVrOiAnbGwnLFxuXHRtb250aDogJ01NTSBZWVlZJyxcblx0cXVhcnRlcjogJ1tRXVEgLSBZWVlZJyxcblx0eWVhcjogJ1lZWVknXG59O1xuXG5jb3JlX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlKHR5cGVvZiBtb21lbnQgPT09ICdmdW5jdGlvbicgPyB7XG5cdF9pZDogJ21vbWVudCcsIC8vIERFQlVHIE9OTFlcblxuXHRmb3JtYXRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gRk9STUFUUztcblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24odmFsdWUsIGZvcm1hdCkge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YWx1ZSA9IG1vbWVudCh2YWx1ZSwgZm9ybWF0KTtcblx0XHR9IGVsc2UgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBtb21lbnQpKSB7XG5cdFx0XHR2YWx1ZSA9IG1vbWVudCh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZS5pc1ZhbGlkKCkgPyB2YWx1ZS52YWx1ZU9mKCkgOiBudWxsO1xuXHR9LFxuXG5cdGZvcm1hdDogZnVuY3Rpb24odGltZSwgZm9ybWF0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5mb3JtYXQoZm9ybWF0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKHRpbWUsIGFtb3VudCwgdW5pdCkge1xuXHRcdHJldHVybiBtb21lbnQodGltZSkuYWRkKGFtb3VudCwgdW5pdCkudmFsdWVPZigpO1xuXHR9LFxuXG5cdGRpZmY6IGZ1bmN0aW9uKG1heCwgbWluLCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudC5kdXJhdGlvbihtb21lbnQobWF4KS5kaWZmKG1vbWVudChtaW4pKSkuYXModW5pdCk7XG5cdH0sXG5cblx0c3RhcnRPZjogZnVuY3Rpb24odGltZSwgdW5pdCwgd2Vla2RheSkge1xuXHRcdHRpbWUgPSBtb21lbnQodGltZSk7XG5cdFx0aWYgKHVuaXQgPT09ICdpc29XZWVrJykge1xuXHRcdFx0cmV0dXJuIHRpbWUuaXNvV2Vla2RheSh3ZWVrZGF5KS52YWx1ZU9mKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aW1lLnN0YXJ0T2YodW5pdCkudmFsdWVPZigpO1xuXHR9LFxuXG5cdGVuZE9mOiBmdW5jdGlvbih0aW1lLCB1bml0KSB7XG5cdFx0cmV0dXJuIG1vbWVudCh0aW1lKS5lbmRPZih1bml0KS52YWx1ZU9mKCk7XG5cdH0sXG5cblx0Ly8gREVQUkVDQVRJT05TXG5cblx0LyoqXG5cdCAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggc2NhbGUuZ2V0VmFsdWVGb3JQaXhlbCgpLlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuOC4wXG5cdCAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKHRpbWUpIHtcblx0XHRyZXR1cm4gbW9tZW50KHRpbWUpO1xuXHR9LFxufSA6IHt9KTtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHBsdWdpbnM6IHtcblx0XHRmaWxsZXI6IHtcblx0XHRcdHByb3BhZ2F0ZTogdHJ1ZVxuXHRcdH1cblx0fVxufSk7XG5cbnZhciBtYXBwZXJzID0ge1xuXHRkYXRhc2V0OiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHR2YXIgaW5kZXggPSBzb3VyY2UuZmlsbDtcblx0XHR2YXIgY2hhcnQgPSBzb3VyY2UuY2hhcnQ7XG5cdFx0dmFyIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cdFx0dmFyIHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuXHRcdHZhciBwb2ludHMgPSAodmlzaWJsZSAmJiBtZXRhLmRhdGFzZXQuX2NoaWxkcmVuKSB8fCBbXTtcblx0XHR2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCB8fCAwO1xuXG5cdFx0cmV0dXJuICFsZW5ndGggPyBudWxsIDogZnVuY3Rpb24ocG9pbnQsIGkpIHtcblx0XHRcdHJldHVybiAoaSA8IGxlbmd0aCAmJiBwb2ludHNbaV0uX3ZpZXcpIHx8IG51bGw7XG5cdFx0fTtcblx0fSxcblxuXHRib3VuZGFyeTogZnVuY3Rpb24oc291cmNlKSB7XG5cdFx0dmFyIGJvdW5kYXJ5ID0gc291cmNlLmJvdW5kYXJ5O1xuXHRcdHZhciB4ID0gYm91bmRhcnkgPyBib3VuZGFyeS54IDogbnVsbDtcblx0XHR2YXIgeSA9IGJvdW5kYXJ5ID8gYm91bmRhcnkueSA6IG51bGw7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IHggPT09IG51bGwgPyBwb2ludC54IDogeCxcblx0XHRcdFx0eTogeSA9PT0gbnVsbCA/IHBvaW50LnkgOiB5LFxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG59O1xuXG4vLyBAdG9kbyBpZiAoZmlsbFswXSA9PT0gJyMnKVxuZnVuY3Rpb24gZGVjb2RlRmlsbChlbCwgaW5kZXgsIGNvdW50KSB7XG5cdHZhciBtb2RlbCA9IGVsLl9tb2RlbCB8fCB7fTtcblx0dmFyIGZpbGwgPSBtb2RlbC5maWxsO1xuXHR2YXIgdGFyZ2V0O1xuXG5cdGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcblx0XHRmaWxsID0gISFtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XG5cdH1cblxuXHRpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmIChmaWxsID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuICdvcmlnaW4nO1xuXHR9XG5cblx0dGFyZ2V0ID0gcGFyc2VGbG9hdChmaWxsLCAxMCk7XG5cdGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG5cdFx0aWYgKGZpbGxbMF0gPT09ICctJyB8fCBmaWxsWzBdID09PSAnKycpIHtcblx0XHRcdHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuXHRcdH1cblxuXHRcdGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdHN3aXRjaCAoZmlsbCkge1xuXHQvLyBjb21wYXRpYmlsaXR5XG5cdGNhc2UgJ2JvdHRvbSc6XG5cdFx0cmV0dXJuICdzdGFydCc7XG5cdGNhc2UgJ3RvcCc6XG5cdFx0cmV0dXJuICdlbmQnO1xuXHRjYXNlICd6ZXJvJzpcblx0XHRyZXR1cm4gJ29yaWdpbic7XG5cdC8vIHN1cHBvcnRlZCBib3VuZGFyaWVzXG5cdGNhc2UgJ29yaWdpbic6XG5cdGNhc2UgJ3N0YXJ0Jzpcblx0Y2FzZSAnZW5kJzpcblx0XHRyZXR1cm4gZmlsbDtcblx0Ly8gaW52YWxpZCBmaWxsIHZhbHVlc1xuXHRkZWZhdWx0OlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG5cdHZhciBtb2RlbCA9IHNvdXJjZS5lbC5fbW9kZWwgfHwge307XG5cdHZhciBzY2FsZSA9IHNvdXJjZS5lbC5fc2NhbGUgfHwge307XG5cdHZhciBmaWxsID0gc291cmNlLmZpbGw7XG5cdHZhciB0YXJnZXQgPSBudWxsO1xuXHR2YXIgaG9yaXpvbnRhbDtcblxuXHRpZiAoaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IHVudGlsIHYzLCB3ZSBzdGlsbCBuZWVkIHRvIHN1cHBvcnQgYm91bmRhcnkgdmFsdWVzIHNldCBvblxuXHQvLyB0aGUgbW9kZWwgKHNjYWxlVG9wLCBzY2FsZUJvdHRvbSBhbmQgc2NhbGVaZXJvKSBiZWNhdXNlIHNvbWUgZXh0ZXJuYWwgcGx1Z2lucyBhbmRcblx0Ly8gY29udHJvbGxlcnMgbWlnaHQgc3RpbGwgdXNlIGl0IChlLmcuIHRoZSBTbWl0aCBjaGFydCkuXG5cblx0aWYgKGZpbGwgPT09ICdzdGFydCcpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZUJvdHRvbSA9PT0gdW5kZWZpbmVkID8gc2NhbGUuYm90dG9tIDogbW9kZWwuc2NhbGVCb3R0b207XG5cdH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVRvcCA9PT0gdW5kZWZpbmVkID8gc2NhbGUudG9wIDogbW9kZWwuc2NhbGVUb3A7XG5cdH0gZWxzZSBpZiAobW9kZWwuc2NhbGVaZXJvICE9PSB1bmRlZmluZWQpIHtcblx0XHR0YXJnZXQgPSBtb2RlbC5zY2FsZVplcm87XG5cdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBvc2l0aW9uKSB7XG5cdFx0dGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBvc2l0aW9uKCk7XG5cdH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG5cdFx0dGFyZ2V0ID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG5cdH1cblxuXHRpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBudWxsKSB7XG5cdFx0aWYgKHRhcmdldC54ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHRpZiAoaGVscGVycyQxLmlzRmluaXRlKHRhcmdldCkpIHtcblx0XHRcdGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHg6IGhvcml6b250YWwgPyB0YXJnZXQgOiBudWxsLFxuXHRcdFx0XHR5OiBob3Jpem9udGFsID8gbnVsbCA6IHRhcmdldFxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG5cdHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHZpc2l0ZWQgPSBbaW5kZXhdO1xuXHR2YXIgdGFyZ2V0O1xuXG5cdGlmICghcHJvcGFnYXRlKSB7XG5cdFx0cmV0dXJuIGZpbGw7XG5cdH1cblxuXHR3aGlsZSAoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSkge1xuXHRcdGlmICghaXNGaW5pdGUoZmlsbCkpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG5cdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAodGFyZ2V0LnZpc2libGUpIHtcblx0XHRcdHJldHVybiBmaWxsO1xuXHRcdH1cblxuXHRcdHZpc2l0ZWQucHVzaChmaWxsKTtcblx0XHRmaWxsID0gdGFyZ2V0LmZpbGw7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcHBlcihzb3VyY2UpIHtcblx0dmFyIGZpbGwgPSBzb3VyY2UuZmlsbDtcblx0dmFyIHR5cGUgPSAnZGF0YXNldCc7XG5cblx0aWYgKGZpbGwgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG5cdFx0dHlwZSA9ICdib3VuZGFyeSc7XG5cdH1cblxuXHRyZXR1cm4gbWFwcGVyc1t0eXBlXShzb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBpc0RyYXdhYmxlKHBvaW50KSB7XG5cdHJldHVybiBwb2ludCAmJiAhcG9pbnQuc2tpcDtcbn1cblxuZnVuY3Rpb24gZHJhd0FyZWEoY3R4LCBjdXJ2ZTAsIGN1cnZlMSwgbGVuMCwgbGVuMSkge1xuXHR2YXIgaTtcblxuXHRpZiAoIWxlbjAgfHwgIWxlbjEpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBidWlsZGluZyBmaXJzdCBhcmVhIGN1cnZlIChub3JtYWwpXG5cdGN0eC5tb3ZlVG8oY3VydmUwWzBdLngsIGN1cnZlMFswXS55KTtcblx0Zm9yIChpID0gMTsgaSA8IGxlbjA7ICsraSkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgY3VydmUwW2kgLSAxXSwgY3VydmUwW2ldKTtcblx0fVxuXG5cdC8vIGpvaW5pbmcgdGhlIHR3byBhcmVhIGN1cnZlc1xuXHRjdHgubGluZVRvKGN1cnZlMVtsZW4xIC0gMV0ueCwgY3VydmUxW2xlbjEgLSAxXS55KTtcblxuXHQvLyBidWlsZGluZyBvcHBvc2l0ZSBhcmVhIGN1cnZlIChyZXZlcnNlKVxuXHRmb3IgKGkgPSBsZW4xIC0gMTsgaSA+IDA7IC0taSkge1xuXHRcdGhlbHBlcnMkMS5jYW52YXMubGluZVRvKGN0eCwgY3VydmUxW2ldLCBjdXJ2ZTFbaSAtIDFdLCB0cnVlKTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGxvb3ApIHtcblx0dmFyIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcblx0dmFyIHNwYW4gPSB2aWV3LnNwYW5HYXBzO1xuXHR2YXIgY3VydmUwID0gW107XG5cdHZhciBjdXJ2ZTEgPSBbXTtcblx0dmFyIGxlbjAgPSAwO1xuXHR2YXIgbGVuMSA9IDA7XG5cdHZhciBpLCBpbGVuLCBpbmRleCwgcDAsIHAxLCBkMCwgZDE7XG5cblx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdGZvciAoaSA9IDAsIGlsZW4gPSAoY291bnQgKyAhIWxvb3ApOyBpIDwgaWxlbjsgKytpKSB7XG5cdFx0aW5kZXggPSBpICUgY291bnQ7XG5cdFx0cDAgPSBwb2ludHNbaW5kZXhdLl92aWV3O1xuXHRcdHAxID0gbWFwcGVyKHAwLCBpbmRleCwgdmlldyk7XG5cdFx0ZDAgPSBpc0RyYXdhYmxlKHAwKTtcblx0XHRkMSA9IGlzRHJhd2FibGUocDEpO1xuXG5cdFx0aWYgKGQwICYmIGQxKSB7XG5cdFx0XHRsZW4wID0gY3VydmUwLnB1c2gocDApO1xuXHRcdFx0bGVuMSA9IGN1cnZlMS5wdXNoKHAxKTtcblx0XHR9IGVsc2UgaWYgKGxlbjAgJiYgbGVuMSkge1xuXHRcdFx0aWYgKCFzcGFuKSB7XG5cdFx0XHRcdGRyYXdBcmVhKGN0eCwgY3VydmUwLCBjdXJ2ZTEsIGxlbjAsIGxlbjEpO1xuXHRcdFx0XHRsZW4wID0gbGVuMSA9IDA7XG5cdFx0XHRcdGN1cnZlMCA9IFtdO1xuXHRcdFx0XHRjdXJ2ZTEgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChkMCkge1xuXHRcdFx0XHRcdGN1cnZlMC5wdXNoKHAwKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZDEpIHtcblx0XHRcdFx0XHRjdXJ2ZTEucHVzaChwMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRkcmF3QXJlYShjdHgsIGN1cnZlMCwgY3VydmUxLCBsZW4wLCBsZW4xKTtcblxuXHRjdHguY2xvc2VQYXRoKCk7XG5cdGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblx0Y3R4LmZpbGwoKTtcbn1cblxudmFyIHBsdWdpbl9maWxsZXIgPSB7XG5cdGlkOiAnZmlsbGVyJyxcblxuXHRhZnRlckRhdGFzZXRzVXBkYXRlOiBmdW5jdGlvbihjaGFydCwgb3B0aW9ucykge1xuXHRcdHZhciBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG5cdFx0dmFyIHByb3BhZ2F0ZSA9IG9wdGlvbnMucHJvcGFnYXRlO1xuXHRcdHZhciBzb3VyY2VzID0gW107XG5cdFx0dmFyIG1ldGEsIGksIGVsLCBzb3VyY2U7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0bWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuXHRcdFx0ZWwgPSBtZXRhLmRhdGFzZXQ7XG5cdFx0XHRzb3VyY2UgPSBudWxsO1xuXG5cdFx0XHRpZiAoZWwgJiYgZWwuX21vZGVsICYmIGVsIGluc3RhbmNlb2YgZWxlbWVudHMuTGluZSkge1xuXHRcdFx0XHRzb3VyY2UgPSB7XG5cdFx0XHRcdFx0dmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcblx0XHRcdFx0XHRmaWxsOiBkZWNvZGVGaWxsKGVsLCBpLCBjb3VudCksXG5cdFx0XHRcdFx0Y2hhcnQ6IGNoYXJ0LFxuXHRcdFx0XHRcdGVsOiBlbFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRtZXRhLiRmaWxsZXIgPSBzb3VyY2U7XG5cdFx0XHRzb3VyY2VzLnB1c2goc291cmNlKTtcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuXHRcdFx0c291cmNlID0gc291cmNlc1tpXTtcblx0XHRcdGlmICghc291cmNlKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzb3VyY2UuZmlsbCA9IHJlc29sdmVUYXJnZXQoc291cmNlcywgaSwgcHJvcGFnYXRlKTtcblx0XHRcdHNvdXJjZS5ib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuXHRcdFx0c291cmNlLm1hcHBlciA9IGNyZWF0ZU1hcHBlcihzb3VyY2UpO1xuXHRcdH1cblx0fSxcblxuXHRiZWZvcmVEYXRhc2V0RHJhdzogZnVuY3Rpb24oY2hhcnQsIGFyZ3MpIHtcblx0XHR2YXIgbWV0YSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuXHRcdGlmICghbWV0YSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBjdHggPSBjaGFydC5jdHg7XG5cdFx0dmFyIGVsID0gbWV0YS5lbDtcblx0XHR2YXIgdmlldyA9IGVsLl92aWV3O1xuXHRcdHZhciBwb2ludHMgPSBlbC5fY2hpbGRyZW4gfHwgW107XG5cdFx0dmFyIG1hcHBlciA9IG1ldGEubWFwcGVyO1xuXHRcdHZhciBjb2xvciA9IHZpZXcuYmFja2dyb3VuZENvbG9yIHx8IGNvcmVfZGVmYXVsdHMuZ2xvYmFsLmRlZmF1bHRDb2xvcjtcblxuXHRcdGlmIChtYXBwZXIgJiYgY29sb3IgJiYgcG9pbnRzLmxlbmd0aCkge1xuXHRcdFx0aGVscGVycyQxLmNhbnZhcy5jbGlwQXJlYShjdHgsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cdFx0XHRkb0ZpbGwoY3R4LCBwb2ludHMsIG1hcHBlciwgdmlldywgY29sb3IsIGVsLl9sb29wKTtcblx0XHRcdGhlbHBlcnMkMS5jYW52YXMudW5jbGlwQXJlYShjdHgpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIG5vb3AkMSA9IGhlbHBlcnMkMS5ub29wO1xudmFyIHZhbHVlT3JEZWZhdWx0JGQgPSBoZWxwZXJzJDEudmFsdWVPckRlZmF1bHQ7XG5cbmNvcmVfZGVmYXVsdHMuX3NldCgnZ2xvYmFsJywge1xuXHRsZWdlbmQ6IHtcblx0XHRkaXNwbGF5OiB0cnVlLFxuXHRcdHBvc2l0aW9uOiAndG9wJyxcblx0XHRmdWxsV2lkdGg6IHRydWUsXG5cdFx0cmV2ZXJzZTogZmFsc2UsXG5cdFx0d2VpZ2h0OiAxMDAwLFxuXG5cdFx0Ly8gYSBjYWxsYmFjayB0aGF0IHdpbGwgaGFuZGxlXG5cdFx0b25DbGljazogZnVuY3Rpb24oZSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0dmFyIGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG5cdFx0XHR2YXIgY2kgPSB0aGlzLmNoYXJ0O1xuXHRcdFx0dmFyIG1ldGEgPSBjaS5nZXREYXRhc2V0TWV0YShpbmRleCk7XG5cblx0XHRcdC8vIFNlZSBjb250cm9sbGVyLmlzRGF0YXNldFZpc2libGUgY29tbWVudFxuXHRcdFx0bWV0YS5oaWRkZW4gPSBtZXRhLmhpZGRlbiA9PT0gbnVsbCA/ICFjaS5kYXRhLmRhdGFzZXRzW2luZGV4XS5oaWRkZW4gOiBudWxsO1xuXG5cdFx0XHQvLyBXZSBoaWQgYSBkYXRhc2V0IC4uLiByZXJlbmRlciB0aGUgY2hhcnRcblx0XHRcdGNpLnVwZGF0ZSgpO1xuXHRcdH0sXG5cblx0XHRvbkhvdmVyOiBudWxsLFxuXHRcdG9uTGVhdmU6IG51bGwsXG5cblx0XHRsYWJlbHM6IHtcblx0XHRcdGJveFdpZHRoOiA0MCxcblx0XHRcdHBhZGRpbmc6IDEwLFxuXHRcdFx0Ly8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG5cdFx0XHQvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcblx0XHRcdC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcblx0XHRcdC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG5cdFx0XHQvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuXHRcdFx0Ly8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuXHRcdFx0Ly8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuXHRcdFx0Ly8gbGluZURhc2hcblx0XHRcdC8vIGxpbmVEYXNoT2Zmc2V0IDpcblx0XHRcdC8vIGxpbmVKb2luIDpcblx0XHRcdC8vIGxpbmVXaWR0aCA6XG5cdFx0XHRnZW5lcmF0ZUxhYmVsczogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHRcdFx0dmFyIGRhdGEgPSBjaGFydC5kYXRhO1xuXHRcdFx0XHRyZXR1cm4gaGVscGVycyQxLmlzQXJyYXkoZGF0YS5kYXRhc2V0cykgPyBkYXRhLmRhdGFzZXRzLm1hcChmdW5jdGlvbihkYXRhc2V0LCBpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHRleHQ6IGRhdGFzZXQubGFiZWwsXG5cdFx0XHRcdFx0XHRmaWxsU3R5bGU6ICghaGVscGVycyQxLmlzQXJyYXkoZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IpID8gZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgOiBkYXRhc2V0LmJhY2tncm91bmRDb2xvclswXSksXG5cdFx0XHRcdFx0XHRoaWRkZW46ICFjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuXHRcdFx0XHRcdFx0bGluZUNhcDogZGF0YXNldC5ib3JkZXJDYXBTdHlsZSxcblx0XHRcdFx0XHRcdGxpbmVEYXNoOiBkYXRhc2V0LmJvcmRlckRhc2gsXG5cdFx0XHRcdFx0XHRsaW5lRGFzaE9mZnNldDogZGF0YXNldC5ib3JkZXJEYXNoT2Zmc2V0LFxuXHRcdFx0XHRcdFx0bGluZUpvaW46IGRhdGFzZXQuYm9yZGVySm9pblN0eWxlLFxuXHRcdFx0XHRcdFx0bGluZVdpZHRoOiBkYXRhc2V0LmJvcmRlcldpZHRoLFxuXHRcdFx0XHRcdFx0c3Ryb2tlU3R5bGU6IGRhdGFzZXQuYm9yZGVyQ29sb3IsXG5cdFx0XHRcdFx0XHRwb2ludFN0eWxlOiBkYXRhc2V0LnBvaW50U3R5bGUsXG5cblx0XHRcdFx0XHRcdC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXG5cdFx0XHRcdFx0XHRkYXRhc2V0SW5kZXg6IGlcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9LCB0aGlzKSA6IFtdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRsZWdlbmRDYWxsYmFjazogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgdGV4dCA9IFtdO1xuXHRcdHRleHQucHVzaCgnPHVsIGNsYXNzPVwiJyArIGNoYXJ0LmlkICsgJy1sZWdlbmRcIj4nKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRleHQucHVzaCgnPGxpPjxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgY2hhcnQuZGF0YS5kYXRhc2V0c1tpXS5iYWNrZ3JvdW5kQ29sb3IgKyAnXCI+PC9zcGFuPicpO1xuXHRcdFx0aWYgKGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0ubGFiZWwpIHtcblx0XHRcdFx0dGV4dC5wdXNoKGNoYXJ0LmRhdGEuZGF0YXNldHNbaV0ubGFiZWwpO1xuXHRcdFx0fVxuXHRcdFx0dGV4dC5wdXNoKCc8L2xpPicpO1xuXHRcdH1cblx0XHR0ZXh0LnB1c2goJzwvdWw+Jyk7XG5cdFx0cmV0dXJuIHRleHQuam9pbignJyk7XG5cdH1cbn0pO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJveCB3aWR0aCBiYXNlZCBvbiB0aGUgdXNlUG9pbnRTdHlsZSBvcHRpb25cbiAqIEBwYXJhbSB7b2JqZWN0fSBsYWJlbG9wdHMgLSB0aGUgbGFiZWwgb3B0aW9ucyBvbiB0aGUgbGVnZW5kXG4gKiBAcGFyYW0ge251bWJlcn0gZm9udFNpemUgLSB0aGUgbGFiZWwgZm9udCBzaXplXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoIG9mIHRoZSBjb2xvciBib3ggYXJlYVxuICovXG5mdW5jdGlvbiBnZXRCb3hXaWR0aChsYWJlbE9wdHMsIGZvbnRTaXplKSB7XG5cdHJldHVybiBsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSAmJiBsYWJlbE9wdHMuYm94V2lkdGggPiBmb250U2l6ZSA/XG5cdFx0Zm9udFNpemUgOlxuXHRcdGxhYmVsT3B0cy5ib3hXaWR0aDtcbn1cblxuLyoqXG4gKiBJTVBPUlRBTlQ6IHRoaXMgY2xhc3MgaXMgZXhwb3NlZCBwdWJsaWNseSBhcyBDaGFydC5MZWdlbmQsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgcmVxdWlyZWQhXG4gKi9cbnZhciBMZWdlbmQgPSBjb3JlX2VsZW1lbnQuZXh0ZW5kKHtcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihjb25maWcpIHtcblx0XHRoZWxwZXJzJDEuZXh0ZW5kKHRoaXMsIGNvbmZpZyk7XG5cblx0XHQvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcblx0XHR0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHQvKipcbiBcdFx0ICogQHByaXZhdGVcbiBcdFx0ICovXG5cdFx0dGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuXG5cdFx0Ly8gQXJlIHdlIGluIGRvdWdobnV0IG1vZGUgd2hpY2ggaGFzIGEgZGlmZmVyZW50IGRhdGEgdHlwZVxuXHRcdHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG5cdH0sXG5cblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblx0Ly8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIGxlZ2VuZCB0eXBlcy5cblx0Ly8gQW55IGZ1bmN0aW9uIGNhbiBiZSBleHRlbmRlZCBieSB0aGUgbGVnZW5kIHR5cGVcblxuXHRiZWZvcmVVcGRhdGU6IG5vb3AkMSxcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcblxuXHRcdC8vIERpbWVuc2lvbnNcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXHRcdC8vIExhYmVsc1xuXHRcdG1lLmJlZm9yZUJ1aWxkTGFiZWxzKCk7XG5cdFx0bWUuYnVpbGRMYWJlbHMoKTtcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXHR9LFxuXHRhZnRlclVwZGF0ZTogbm9vcCQxLFxuXG5cdC8vXG5cblx0YmVmb3JlU2V0RGltZW5zaW9uczogbm9vcCQxLFxuXHRzZXREaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG5cdFx0aWYgKG1lLmlzSG9yaXpvbnRhbCgpKSB7XG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLndpZHRoID0gbWUubWF4V2lkdGg7XG5cdFx0XHRtZS5sZWZ0ID0gMDtcblx0XHRcdG1lLnJpZ2h0ID0gbWUud2lkdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lLmhlaWdodCA9IG1lLm1heEhlaWdodDtcblxuXHRcdFx0Ly8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG5cdFx0XHRtZS50b3AgPSAwO1xuXHRcdFx0bWUuYm90dG9tID0gbWUuaGVpZ2h0O1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHBhZGRpbmdcblx0XHRtZS5wYWRkaW5nTGVmdCA9IDA7XG5cdFx0bWUucGFkZGluZ1RvcCA9IDA7XG5cdFx0bWUucGFkZGluZ1JpZ2h0ID0gMDtcblx0XHRtZS5wYWRkaW5nQm90dG9tID0gMDtcblxuXHRcdC8vIFJlc2V0IG1pblNpemVcblx0XHRtZS5taW5TaXplID0ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDBcblx0XHR9O1xuXHR9LFxuXHRhZnRlclNldERpbWVuc2lvbnM6IG5vb3AkMSxcblxuXHQvL1xuXG5cdGJlZm9yZUJ1aWxkTGFiZWxzOiBub29wJDEsXG5cdGJ1aWxkTGFiZWxzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBsYWJlbE9wdHMgPSBtZS5vcHRpb25zLmxhYmVscyB8fCB7fTtcblx0XHR2YXIgbGVnZW5kSXRlbXMgPSBoZWxwZXJzJDEuY2FsbGJhY2sobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbbWUuY2hhcnRdLCBtZSkgfHwgW107XG5cblx0XHRpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuXHRcdFx0bGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRyZXR1cm4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCBtZS5jaGFydC5kYXRhKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmIChtZS5vcHRpb25zLnJldmVyc2UpIHtcblx0XHRcdGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcblx0XHR9XG5cblx0XHRtZS5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuXHR9LFxuXHRhZnRlckJ1aWxkTGFiZWxzOiBub29wJDEsXG5cblx0Ly9cblxuXHRiZWZvcmVGaXQ6IG5vb3AkMSxcblx0Zml0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cblx0XHR2YXIgY3R4ID0gbWUuY3R4O1xuXG5cdFx0dmFyIGxhYmVsRm9udCA9IGhlbHBlcnMkMS5vcHRpb25zLl9wYXJzZUZvbnQobGFiZWxPcHRzKTtcblx0XHR2YXIgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcblxuXHRcdC8vIFJlc2V0IGhpdCBib3hlc1xuXHRcdHZhciBoaXRib3hlcyA9IG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cblx0XHR2YXIgbWluU2l6ZSA9IG1lLm1pblNpemU7XG5cdFx0dmFyIGlzSG9yaXpvbnRhbCA9IG1lLmlzSG9yaXpvbnRhbCgpO1xuXG5cdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gZGlzcGxheSA/IDEwIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IGRpc3BsYXkgPyAxMCA6IDA7XG5cdFx0XHRtaW5TaXplLmhlaWdodCA9IG1lLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuXHRcdH1cblxuXHRcdC8vIEluY3JlYXNlIHNpemVzIGhlcmVcblx0XHRpZiAoZGlzcGxheSkge1xuXHRcdFx0Y3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdC8vIExhYmVsc1xuXG5cdFx0XHRcdC8vIFdpZHRoIG9mIGVhY2ggbGluZSBvZiBsZWdlbmQgYm94ZXMuIExhYmVscyB3cmFwIG9udG8gbXVsdGlwbGUgbGluZXMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgdG8gZml0IG9uIG9uZVxuXHRcdFx0XHR2YXIgbGluZVdpZHRocyA9IG1lLmxpbmVXaWR0aHMgPSBbMF07XG5cdFx0XHRcdHZhciB0b3RhbEhlaWdodCA9IDA7XG5cblx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0Jztcblx0XHRcdFx0Y3R4LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuXG5cdFx0XHRcdGhlbHBlcnMkMS5lYWNoKG1lLmxlZ2VuZEl0ZW1zLCBmdW5jdGlvbihsZWdlbmRJdGVtLCBpKSB7XG5cdFx0XHRcdFx0dmFyIGJveFdpZHRoID0gZ2V0Qm94V2lkdGgobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cdFx0XHRcdFx0dmFyIHdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG5cdFx0XHRcdFx0aWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZyA+IG1pblNpemUud2lkdGgpIHtcblx0XHRcdFx0XHRcdHRvdGFsSGVpZ2h0ICs9IGZvbnRTaXplICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG5cdFx0XHRcdFx0aGl0Ym94ZXNbaV0gPSB7XG5cdFx0XHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBmb250U2l6ZVxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKz0gd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZztcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0bWluU2l6ZS5oZWlnaHQgKz0gdG90YWxIZWlnaHQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciB2UGFkZGluZyA9IGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR2YXIgY29sdW1uV2lkdGhzID0gbWUuY29sdW1uV2lkdGhzID0gW107XG5cdFx0XHRcdHZhciB0b3RhbFdpZHRoID0gbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdHZhciBjdXJyZW50Q29sV2lkdGggPSAwO1xuXHRcdFx0XHR2YXIgY3VycmVudENvbEhlaWdodCA9IDA7XG5cdFx0XHRcdHZhciBpdGVtSGVpZ2h0ID0gZm9udFNpemUgKyB2UGFkZGluZztcblxuXHRcdFx0XHRoZWxwZXJzJDEuZWFjaChtZS5sZWdlbmRJdGVtcywgZnVuY3Rpb24obGVnZW5kSXRlbSwgaSkge1xuXHRcdFx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXHRcdFx0XHRcdHZhciBpdGVtV2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG5cblx0XHRcdFx0XHQvLyBJZiB0b28gdGFsbCwgZ28gdG8gbmV3IGNvbHVtblxuXHRcdFx0XHRcdGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCA+IG1pblNpemUuaGVpZ2h0IC0gdlBhZGRpbmcpIHtcblx0XHRcdFx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpOyAvLyBwcmV2aW91cyBjb2x1bW4gd2lkdGhcblxuXHRcdFx0XHRcdFx0Y3VycmVudENvbFdpZHRoID0gMDtcblx0XHRcdFx0XHRcdGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEdldCBtYXggd2lkdGhcblx0XHRcdFx0XHRjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG5cdFx0XHRcdFx0Y3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0O1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGhpdGJveCB3aWR0aCBhbmQgaGVpZ2h0IGhlcmUuIEZpbmFsIHBvc2l0aW9uIHdpbGwgYmUgdXBkYXRlZCBpbiBgZHJhd2Bcblx0XHRcdFx0XHRoaXRib3hlc1tpXSA9IHtcblx0XHRcdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHR3aWR0aDogaXRlbVdpZHRoLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBmb250U2l6ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuXHRcdFx0XHRjb2x1bW5XaWR0aHMucHVzaChjdXJyZW50Q29sV2lkdGgpO1xuXHRcdFx0XHRtaW5TaXplLndpZHRoICs9IHRvdGFsV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXHR9LFxuXHRhZnRlckZpdDogbm9vcCQxLFxuXG5cdC8vIFNoYXJlZCBNZXRob2RzXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcblx0fSxcblxuXHQvLyBBY3R1YWxseSBkcmF3IHRoZSBsZWdlbmQgb24gdGhlIGNhbnZhc1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBvcHRzID0gbWUub3B0aW9ucztcblx0XHR2YXIgbGFiZWxPcHRzID0gb3B0cy5sYWJlbHM7XG5cdFx0dmFyIGdsb2JhbERlZmF1bHRzID0gY29yZV9kZWZhdWx0cy5nbG9iYWw7XG5cdFx0dmFyIGRlZmF1bHRDb2xvciA9IGdsb2JhbERlZmF1bHRzLmRlZmF1bHRDb2xvcjtcblx0XHR2YXIgbGluZURlZmF1bHQgPSBnbG9iYWxEZWZhdWx0cy5lbGVtZW50cy5saW5lO1xuXHRcdHZhciBsZWdlbmRXaWR0aCA9IG1lLndpZHRoO1xuXHRcdHZhciBsaW5lV2lkdGhzID0gbWUubGluZVdpZHRocztcblxuXHRcdGlmIChvcHRzLmRpc3BsYXkpIHtcblx0XHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0XHR2YXIgZm9udENvbG9yID0gdmFsdWVPckRlZmF1bHQkZChsYWJlbE9wdHMuZm9udENvbG9yLCBnbG9iYWxEZWZhdWx0cy5kZWZhdWx0Rm9udENvbG9yKTtcblx0XHRcdHZhciBsYWJlbEZvbnQgPSBoZWxwZXJzJDEub3B0aW9ucy5fcGFyc2VGb250KGxhYmVsT3B0cyk7XG5cdFx0XHR2YXIgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcblx0XHRcdHZhciBjdXJzb3I7XG5cblx0XHRcdC8vIENhbnZhcyBzZXR1cFxuXHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdsZWZ0Jztcblx0XHRcdGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblx0XHRcdGN0eC5saW5lV2lkdGggPSAwLjU7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBmb250Q29sb3I7IC8vIGZvciBzdHJpa2V0aHJvdWdoIGVmZmVjdFxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cdFx0XHRjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG5cblx0XHRcdHZhciBib3hXaWR0aCA9IGdldEJveFdpZHRoKGxhYmVsT3B0cywgZm9udFNpemUpO1xuXHRcdFx0dmFyIGhpdGJveGVzID0gbWUubGVnZW5kSGl0Qm94ZXM7XG5cblx0XHRcdC8vIGN1cnJlbnQgcG9zaXRpb25cblx0XHRcdHZhciBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuXHRcdFx0XHRpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgdGhlIGN0eCBmb3IgdGhlIGJveFxuXHRcdFx0XHRjdHguc2F2ZSgpO1xuXG5cdFx0XHRcdHZhciBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCBsaW5lRGVmYXVsdC5ib3JkZXJXaWR0aCk7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdCRkKGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuXHRcdFx0XHRjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lQ2FwLCBsaW5lRGVmYXVsdC5ib3JkZXJDYXBTdHlsZSk7XG5cdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgbGluZURlZmF1bHQuYm9yZGVyRGFzaE9mZnNldCk7XG5cdFx0XHRcdGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0JGQobGVnZW5kSXRlbS5saW5lSm9pbiwgbGluZURlZmF1bHQuYm9yZGVySm9pblN0eWxlKTtcblx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuXG5cdFx0XHRcdGlmIChjdHguc2V0TGluZURhc2gpIHtcblx0XHRcdFx0XHQvLyBJRSA5IGFuZCAxMCBkbyBub3Qgc3VwcG9ydCBsaW5lIGRhc2hcblx0XHRcdFx0XHRjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQkZChsZWdlbmRJdGVtLmxpbmVEYXNoLCBsaW5lRGVmYXVsdC5ib3JkZXJEYXNoKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0cy5sYWJlbHMgJiYgb3B0cy5sYWJlbHMudXNlUG9pbnRTdHlsZSkge1xuXHRcdFx0XHRcdC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuXHRcdFx0XHRcdC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcblx0XHRcdFx0XHR2YXIgcmFkaXVzID0gYm94V2lkdGggKiBNYXRoLlNRUlQyIC8gMjtcblx0XHRcdFx0XHR2YXIgY2VudGVyWCA9IHggKyBib3hXaWR0aCAvIDI7XG5cdFx0XHRcdFx0dmFyIGNlbnRlclkgPSB5ICsgZm9udFNpemUgLyAyO1xuXG5cdFx0XHRcdFx0Ly8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcblx0XHRcdFx0XHRoZWxwZXJzJDEuY2FudmFzLmRyYXdQb2ludChjdHgsIGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSwgcmFkaXVzLCBjZW50ZXJYLCBjZW50ZXJZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBEcmF3IGJveCBhcyBsZWdlbmQgc3ltYm9sXG5cdFx0XHRcdFx0aWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVJlY3QoeCwgeSwgYm94V2lkdGgsIGZvbnRTaXplKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KHgsIHksIGJveFdpZHRoLCBmb250U2l6ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBmaWxsVGV4dCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0sIHRleHRXaWR0aCkge1xuXHRcdFx0XHR2YXIgaGFsZkZvbnRTaXplID0gZm9udFNpemUgLyAyO1xuXHRcdFx0XHR2YXIgeExlZnQgPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHg7XG5cdFx0XHRcdHZhciB5TWlkZGxlID0geSArIGhhbGZGb250U2l6ZTtcblxuXHRcdFx0XHRjdHguZmlsbFRleHQobGVnZW5kSXRlbS50ZXh0LCB4TGVmdCwgeU1pZGRsZSk7XG5cblx0XHRcdFx0aWYgKGxlZ2VuZEl0ZW0uaGlkZGVuKSB7XG5cdFx0XHRcdFx0Ly8gU3RyaWtldGhyb3VnaCB0aGUgdGV4dCBpZiBoaWRkZW5cblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDI7XG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyh4TGVmdCwgeU1pZGRsZSk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyh4TGVmdCArIHRleHRXaWR0aCwgeU1pZGRsZSk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBIb3Jpem9udGFsXG5cdFx0XHR2YXIgaXNIb3Jpem9udGFsID0gbWUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHRpZiAoaXNIb3Jpem9udGFsKSB7XG5cdFx0XHRcdGN1cnNvciA9IHtcblx0XHRcdFx0XHR4OiBtZS5sZWZ0ICsgKChsZWdlbmRXaWR0aCAtIGxpbmVXaWR0aHNbMF0pIC8gMikgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHR5OiBtZS50b3AgKyBsYWJlbE9wdHMucGFkZGluZyxcblx0XHRcdFx0XHRsaW5lOiAwXG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdXJzb3IgPSB7XG5cdFx0XHRcdFx0eDogbWUubGVmdCArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdHk6IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nLFxuXHRcdFx0XHRcdGxpbmU6IDBcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGl0ZW1IZWlnaHQgPSBmb250U2l6ZSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0aGVscGVycyQxLmVhY2gobWUubGVnZW5kSXRlbXMsIGZ1bmN0aW9uKGxlZ2VuZEl0ZW0sIGkpIHtcblx0XHRcdFx0dmFyIHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXHRcdFx0XHR2YXIgd2lkdGggPSBib3hXaWR0aCArIChmb250U2l6ZSAvIDIpICsgdGV4dFdpZHRoO1xuXHRcdFx0XHR2YXIgeCA9IGN1cnNvci54O1xuXHRcdFx0XHR2YXIgeSA9IGN1cnNvci55O1xuXG5cdFx0XHRcdC8vIFVzZSAobWUubGVmdCArIG1lLm1pblNpemUud2lkdGgpIGFuZCAobWUudG9wICsgbWUubWluU2l6ZS5oZWlnaHQpXG5cdFx0XHRcdC8vIGluc3RlYWQgb2YgbWUucmlnaHQgYW5kIG1lLmJvdHRvbSBiZWNhdXNlIG1lLndpZHRoIGFuZCBtZS5oZWlnaHRcblx0XHRcdFx0Ly8gbWF5IGhhdmUgYmVlbiBjaGFuZ2VkIHNpbmNlIG1lLm1pblNpemUgd2FzIGNhbGN1bGF0ZWRcblx0XHRcdFx0aWYgKGlzSG9yaXpvbnRhbCkge1xuXHRcdFx0XHRcdGlmIChpID4gMCAmJiB4ICsgd2lkdGggKyBsYWJlbE9wdHMucGFkZGluZyA+IG1lLmxlZnQgKyBtZS5taW5TaXplLndpZHRoKSB7XG5cdFx0XHRcdFx0XHR5ID0gY3Vyc29yLnkgKz0gaXRlbUhlaWdodDtcblx0XHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdFx0XHR4ID0gY3Vyc29yLnggPSBtZS5sZWZ0ICsgKChsZWdlbmRXaWR0aCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKSAvIDIpICsgbGFiZWxPcHRzLnBhZGRpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBpdGVtSGVpZ2h0ID4gbWUudG9wICsgbWUubWluU2l6ZS5oZWlnaHQpIHtcblx0XHRcdFx0XHR4ID0gY3Vyc29yLnggPSB4ICsgbWUuY29sdW1uV2lkdGhzW2N1cnNvci5saW5lXSArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdHkgPSBjdXJzb3IueSA9IG1lLnRvcCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHRcdGN1cnNvci5saW5lKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkcmF3TGVnZW5kQm94KHgsIHksIGxlZ2VuZEl0ZW0pO1xuXG5cdFx0XHRcdGhpdGJveGVzW2ldLmxlZnQgPSB4O1xuXHRcdFx0XHRoaXRib3hlc1tpXS50b3AgPSB5O1xuXG5cdFx0XHRcdC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxuXHRcdFx0XHRmaWxsVGV4dCh4LCB5LCBsZWdlbmRJdGVtLCB0ZXh0V2lkdGgpO1xuXG5cdFx0XHRcdGlmIChpc0hvcml6b250YWwpIHtcblx0XHRcdFx0XHRjdXJzb3IueCArPSB3aWR0aCArIGxhYmVsT3B0cy5wYWRkaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1cnNvci55ICs9IGl0ZW1IZWlnaHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldExlZ2VuZEl0ZW1BdDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIGksIGhpdEJveCwgbGg7XG5cblx0XHRpZiAoeCA+PSBtZS5sZWZ0ICYmIHggPD0gbWUucmlnaHQgJiYgeSA+PSBtZS50b3AgJiYgeSA8PSBtZS5ib3R0b20pIHtcblx0XHRcdC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXG5cdFx0XHRsaCA9IG1lLmxlZ2VuZEhpdEJveGVzO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdGhpdEJveCA9IGxoW2ldO1xuXG5cdFx0XHRcdGlmICh4ID49IGhpdEJveC5sZWZ0ICYmIHggPD0gaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGggJiYgeSA+PSBoaXRCb3gudG9wICYmIHkgPD0gaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpIHtcblx0XHRcdFx0XHQvLyBUb3VjaGluZyBhbiBlbGVtZW50XG5cdFx0XHRcdFx0cmV0dXJuIG1lLmxlZ2VuZEl0ZW1zW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0lFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqL1xuXHRoYW5kbGVFdmVudDogZnVuY3Rpb24oZSkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXHRcdHZhciB0eXBlID0gZS50eXBlID09PSAnbW91c2V1cCcgPyAnY2xpY2snIDogZS50eXBlO1xuXHRcdHZhciBob3ZlcmVkSXRlbTtcblxuXHRcdGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuXHRcdFx0aWYgKCFvcHRzLm9uSG92ZXIgJiYgIW9wdHMub25MZWF2ZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2xpY2snKSB7XG5cdFx0XHRpZiAoIW9wdHMub25DbGljaykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDaGFydCBldmVudCBhbHJlYWR5IGhhcyByZWxhdGl2ZSBwb3NpdGlvbiBpbiBpdFxuXHRcdGhvdmVyZWRJdGVtID0gbWUuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG5cblx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0aWYgKGhvdmVyZWRJdGVtICYmIG9wdHMub25DbGljaykge1xuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdHMub25DbGljay5jYWxsKG1lLCBlLm5hdGl2ZSwgaG92ZXJlZEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAob3B0cy5vbkxlYXZlICYmIGhvdmVyZWRJdGVtICE9PSBtZS5faG92ZXJlZEl0ZW0pIHtcblx0XHRcdFx0aWYgKG1lLl9ob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHRcdG9wdHMub25MZWF2ZS5jYWxsKG1lLCBlLm5hdGl2ZSwgbWUuX2hvdmVyZWRJdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtZS5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdHMub25Ib3ZlciAmJiBob3ZlcmVkSXRlbSkge1xuXHRcdFx0XHQvLyB1c2UgZS5uYXRpdmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0XHRcdG9wdHMub25Ib3Zlci5jYWxsKG1lLCBlLm5hdGl2ZSwgaG92ZXJlZEl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cykge1xuXHR2YXIgbGVnZW5kID0gbmV3IExlZ2VuZCh7XG5cdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0b3B0aW9uczogbGVnZW5kT3B0cyxcblx0XHRjaGFydDogY2hhcnRcblx0fSk7XG5cblx0Y29yZV9sYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBsZWdlbmRPcHRzKTtcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcblx0Y2hhcnQubGVnZW5kID0gbGVnZW5kO1xufVxuXG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcblx0aWQ6ICdsZWdlbmQnLFxuXG5cdC8qKlxuXHQgKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzaW5jZSAyLjEuNSwgdGhlIGxlZ2VuZCBpcyByZWdpc3RlcmVkIGFzIGEgcGx1Z2luLCBtYWtpbmdcblx0ICogQ2hhcnQuTGVnZW5kIG9ic29sZXRlLiBUbyBhdm9pZCBhIGJyZWFraW5nIGNoYW5nZSwgd2UgZXhwb3J0IHRoZSBMZWdlbmQgYXMgcGFydCBvZlxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzI2NDBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbGVtZW50OiBMZWdlbmQsXG5cblx0YmVmb3JlSW5pdDogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXG5cdFx0aWYgKGxlZ2VuZE9wdHMpIHtcblx0XHRcdGNyZWF0ZU5ld0xlZ2VuZEFuZEF0dGFjaChjaGFydCwgbGVnZW5kT3B0cyk7XG5cdFx0fVxuXHR9LFxuXG5cdGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcblx0XHR2YXIgbGVnZW5kT3B0cyA9IGNoYXJ0Lm9wdGlvbnMubGVnZW5kO1xuXHRcdHZhciBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG5cblx0XHRpZiAobGVnZW5kT3B0cykge1xuXHRcdFx0aGVscGVycyQxLm1lcmdlSWYobGVnZW5kT3B0cywgY29yZV9kZWZhdWx0cy5nbG9iYWwubGVnZW5kKTtcblxuXHRcdFx0aWYgKGxlZ2VuZCkge1xuXHRcdFx0XHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0XHRsZWdlbmQub3B0aW9ucyA9IGxlZ2VuZE9wdHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVOZXdMZWdlbmRBbmRBdHRhY2goY2hhcnQsIGxlZ2VuZE9wdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobGVnZW5kKSB7XG5cdFx0XHRjb3JlX2xheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBsZWdlbmQpO1xuXHRcdFx0ZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcblx0XHR9XG5cdH0sXG5cblx0YWZ0ZXJFdmVudDogZnVuY3Rpb24oY2hhcnQsIGUpIHtcblx0XHR2YXIgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuXHRcdGlmIChsZWdlbmQpIHtcblx0XHRcdGxlZ2VuZC5oYW5kbGVFdmVudChlKTtcblx0XHR9XG5cdH1cbn07XG5cbnZhciBub29wJDIgPSBoZWxwZXJzJDEubm9vcDtcblxuY29yZV9kZWZhdWx0cy5fc2V0KCdnbG9iYWwnLCB7XG5cdHRpdGxlOiB7XG5cdFx0ZGlzcGxheTogZmFsc2UsXG5cdFx0Zm9udFN0eWxlOiAnYm9sZCcsXG5cdFx0ZnVsbFdpZHRoOiB0cnVlLFxuXHRcdHBhZGRpbmc6IDEwLFxuXHRcdHBvc2l0aW9uOiAndG9wJyxcblx0XHR0ZXh0OiAnJyxcblx0XHR3ZWlnaHQ6IDIwMDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXG5cdH1cbn0pO1xuXG4vKipcbiAqIElNUE9SVEFOVDogdGhpcyBjbGFzcyBpcyBleHBvc2VkIHB1YmxpY2x5IGFzIENoYXJ0LkxlZ2VuZCwgYmFja3dhcmQgY29tcGF0aWJpbGl0eSByZXF1aXJlZCFcbiAqL1xudmFyIFRpdGxlID0gY29yZV9lbGVtZW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0aGVscGVycyQxLmV4dGVuZChtZSwgY29uZmlnKTtcblxuXHRcdC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuXHRcdG1lLmxlZ2VuZEhpdEJveGVzID0gW107XG5cdH0sXG5cblx0Ly8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cblxuXHRiZWZvcmVVcGRhdGU6IG5vb3AkMixcblx0dXBkYXRlOiBmdW5jdGlvbihtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG5cdFx0bWUuYmVmb3JlVXBkYXRlKCk7XG5cblx0XHQvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcblx0XHRtZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdG1lLm1heEhlaWdodCA9IG1heEhlaWdodDtcblx0XHRtZS5tYXJnaW5zID0gbWFyZ2lucztcblxuXHRcdC8vIERpbWVuc2lvbnNcblx0XHRtZS5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG5cdFx0bWUuc2V0RGltZW5zaW9ucygpO1xuXHRcdG1lLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXHRcdC8vIExhYmVsc1xuXHRcdG1lLmJlZm9yZUJ1aWxkTGFiZWxzKCk7XG5cdFx0bWUuYnVpbGRMYWJlbHMoKTtcblx0XHRtZS5hZnRlckJ1aWxkTGFiZWxzKCk7XG5cblx0XHQvLyBGaXRcblx0XHRtZS5iZWZvcmVGaXQoKTtcblx0XHRtZS5maXQoKTtcblx0XHRtZS5hZnRlckZpdCgpO1xuXHRcdC8vXG5cdFx0bWUuYWZ0ZXJVcGRhdGUoKTtcblxuXHRcdHJldHVybiBtZS5taW5TaXplO1xuXG5cdH0sXG5cdGFmdGVyVXBkYXRlOiBub29wJDIsXG5cblx0Ly9cblxuXHRiZWZvcmVTZXREaW1lbnNpb25zOiBub29wJDIsXG5cdHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtZSA9IHRoaXM7XG5cdFx0Ly8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cblx0XHRpZiAobWUuaXNIb3Jpem9udGFsKCkpIHtcblx0XHRcdC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuXHRcdFx0bWUud2lkdGggPSBtZS5tYXhXaWR0aDtcblx0XHRcdG1lLmxlZnQgPSAwO1xuXHRcdFx0bWUucmlnaHQgPSBtZS53aWR0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0O1xuXG5cdFx0XHQvLyBSZXNldCBwb3NpdGlvbiBiZWZvcmUgY2FsY3VsYXRpbmcgcm90YXRpb25cblx0XHRcdG1lLnRvcCA9IDA7XG5cdFx0XHRtZS5ib3R0b20gPSBtZS5oZWlnaHQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcGFkZGluZ1xuXHRcdG1lLnBhZGRpbmdMZWZ0ID0gMDtcblx0XHRtZS5wYWRkaW5nVG9wID0gMDtcblx0XHRtZS5wYWRkaW5nUmlnaHQgPSAwO1xuXHRcdG1lLnBhZGRpbmdCb3R0b20gPSAwO1xuXG5cdFx0Ly8gUmVzZXQgbWluU2l6ZVxuXHRcdG1lLm1pblNpemUgPSB7XG5cdFx0XHR3aWR0aDogMCxcblx0XHRcdGhlaWdodDogMFxuXHRcdH07XG5cdH0sXG5cdGFmdGVyU2V0RGltZW5zaW9uczogbm9vcCQyLFxuXG5cdC8vXG5cblx0YmVmb3JlQnVpbGRMYWJlbHM6IG5vb3AkMixcblx0YnVpbGRMYWJlbHM6IG5vb3AkMixcblx0YWZ0ZXJCdWlsZExhYmVsczogbm9vcCQyLFxuXG5cdC8vXG5cblx0YmVmb3JlRml0OiBub29wJDIsXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1lID0gdGhpcztcblx0XHR2YXIgb3B0cyA9IG1lLm9wdGlvbnM7XG5cdFx0dmFyIGRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cdFx0dmFyIG1pblNpemUgPSBtZS5taW5TaXplO1xuXHRcdHZhciBsaW5lQ291bnQgPSBoZWxwZXJzJDEuaXNBcnJheShvcHRzLnRleHQpID8gb3B0cy50ZXh0Lmxlbmd0aCA6IDE7XG5cdFx0dmFyIGZvbnRPcHRzID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRzKTtcblx0XHR2YXIgdGV4dFNpemUgPSBkaXNwbGF5ID8gKGxpbmVDb3VudCAqIGZvbnRPcHRzLmxpbmVIZWlnaHQpICsgKG9wdHMucGFkZGluZyAqIDIpIDogMDtcblxuXHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0bWluU2l6ZS53aWR0aCA9IG1lLm1heFdpZHRoOyAvLyBmaWxsIGFsbCB0aGUgd2lkdGhcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gdGV4dFNpemU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1pblNpemUud2lkdGggPSB0ZXh0U2l6ZTtcblx0XHRcdG1pblNpemUuaGVpZ2h0ID0gbWUubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG5cdFx0fVxuXG5cdFx0bWUud2lkdGggPSBtaW5TaXplLndpZHRoO1xuXHRcdG1lLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuXG5cdH0sXG5cdGFmdGVyRml0OiBub29wJDIsXG5cblx0Ly8gU2hhcmVkIE1ldGhvZHNcblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXHRcdHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG5cdH0sXG5cblx0Ly8gQWN0dWFsbHkgZHJhdyB0aGUgdGl0bGUgYmxvY2sgb24gdGhlIGNhbnZhc1xuXHRkcmF3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWUgPSB0aGlzO1xuXHRcdHZhciBjdHggPSBtZS5jdHg7XG5cdFx0dmFyIG9wdHMgPSBtZS5vcHRpb25zO1xuXG5cdFx0aWYgKG9wdHMuZGlzcGxheSkge1xuXHRcdFx0dmFyIGZvbnRPcHRzID0gaGVscGVycyQxLm9wdGlvbnMuX3BhcnNlRm9udChvcHRzKTtcblx0XHRcdHZhciBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcblx0XHRcdHZhciBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIG9wdHMucGFkZGluZztcblx0XHRcdHZhciByb3RhdGlvbiA9IDA7XG5cdFx0XHR2YXIgdG9wID0gbWUudG9wO1xuXHRcdFx0dmFyIGxlZnQgPSBtZS5sZWZ0O1xuXHRcdFx0dmFyIGJvdHRvbSA9IG1lLmJvdHRvbTtcblx0XHRcdHZhciByaWdodCA9IG1lLnJpZ2h0O1xuXHRcdFx0dmFyIG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcblxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGhlbHBlcnMkMS52YWx1ZU9yRGVmYXVsdChvcHRzLmZvbnRDb2xvciwgY29yZV9kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRDb2xvcik7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXHRcdFx0Y3R4LmZvbnQgPSBmb250T3B0cy5zdHJpbmc7XG5cblx0XHRcdC8vIEhvcml6b250YWxcblx0XHRcdGlmIChtZS5pc0hvcml6b250YWwoKSkge1xuXHRcdFx0XHR0aXRsZVggPSBsZWZ0ICsgKChyaWdodCAtIGxlZnQpIC8gMik7IC8vIG1pZHBvaW50IG9mIHRoZSB3aWR0aFxuXHRcdFx0XHR0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG5cdFx0XHRcdG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGl0bGVYID0gb3B0cy5wb3NpdGlvbiA9PT0gJ2xlZnQnID8gbGVmdCArIG9mZnNldCA6IHJpZ2h0IC0gb2Zmc2V0O1xuXHRcdFx0XHR0aXRsZVkgPSB0b3AgKyAoKGJvdHRvbSAtIHRvcCkgLyAyKTtcblx0XHRcdFx0bWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG5cdFx0XHRcdHJvdGF0aW9uID0gTWF0aC5QSSAqIChvcHRzLnBvc2l0aW9uID09PSAnbGVmdCcgPyAtMC41IDogMC41KTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC50cmFuc2xhdGUodGl0bGVYLCB0aXRsZVkpO1xuXHRcdFx0Y3R4LnJvdGF0ZShyb3RhdGlvbik7XG5cdFx0XHRjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cdFx0XHRjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cblx0XHRcdHZhciB0ZXh0ID0gb3B0cy50ZXh0O1xuXHRcdFx0aWYgKGhlbHBlcnMkMS5pc0FycmF5KHRleHQpKSB7XG5cdFx0XHRcdHZhciB5ID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KHRleHRbaV0sIDAsIHksIG1heFdpZHRoKTtcblx0XHRcdFx0XHR5ICs9IGxpbmVIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dCh0ZXh0LCAwLCAwLCBtYXhXaWR0aCk7XG5cdFx0XHR9XG5cblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKSB7XG5cdHZhciB0aXRsZSA9IG5ldyBUaXRsZSh7XG5cdFx0Y3R4OiBjaGFydC5jdHgsXG5cdFx0b3B0aW9uczogdGl0bGVPcHRzLFxuXHRcdGNoYXJ0OiBjaGFydFxuXHR9KTtcblxuXHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcblx0Y29yZV9sYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuXHRjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG5cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG5cdGlkOiAndGl0bGUnLFxuXG5cdC8qKlxuXHQgKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBzaW5jZSAyLjEuNSwgdGhlIHRpdGxlIGlzIHJlZ2lzdGVyZWQgYXMgYSBwbHVnaW4sIG1ha2luZ1xuXHQgKiBDaGFydC5UaXRsZSBvYnNvbGV0ZS4gVG8gYXZvaWQgYSBicmVha2luZyBjaGFuZ2UsIHdlIGV4cG9ydCB0aGUgVGl0bGUgYXMgcGFydCBvZlxuXHQgKiB0aGUgcGx1Z2luLCB3aGljaCBvbmUgd2lsbCBiZSByZS1leHBvc2VkIGluIHRoZSBjaGFydC5qcyBmaWxlLlxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzI2NDBcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9lbGVtZW50OiBUaXRsZSxcblxuXHRiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXG5cdFx0aWYgKHRpdGxlT3B0cykge1xuXHRcdFx0Y3JlYXRlTmV3VGl0bGVCbG9ja0FuZEF0dGFjaChjaGFydCwgdGl0bGVPcHRzKTtcblx0XHR9XG5cdH0sXG5cblx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuXHRcdHZhciB0aXRsZU9wdHMgPSBjaGFydC5vcHRpb25zLnRpdGxlO1xuXHRcdHZhciB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcblxuXHRcdGlmICh0aXRsZU9wdHMpIHtcblx0XHRcdGhlbHBlcnMkMS5tZXJnZUlmKHRpdGxlT3B0cywgY29yZV9kZWZhdWx0cy5nbG9iYWwudGl0bGUpO1xuXG5cdFx0XHRpZiAodGl0bGVCbG9jaykge1xuXHRcdFx0XHRjb3JlX2xheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZUJsb2NrLCB0aXRsZU9wdHMpO1xuXHRcdFx0XHR0aXRsZUJsb2NrLm9wdGlvbnMgPSB0aXRsZU9wdHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVOZXdUaXRsZUJsb2NrQW5kQXR0YWNoKGNoYXJ0LCB0aXRsZU9wdHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGl0bGVCbG9jaykge1xuXHRcdFx0Y29yZV9sYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG5cdFx0XHRkZWxldGUgY2hhcnQudGl0bGVCbG9jaztcblx0XHR9XG5cdH1cbn07XG5cbnZhciBwbHVnaW5zID0ge307XG52YXIgZmlsbGVyID0gcGx1Z2luX2ZpbGxlcjtcbnZhciBsZWdlbmQgPSBwbHVnaW5fbGVnZW5kO1xudmFyIHRpdGxlID0gcGx1Z2luX3RpdGxlO1xucGx1Z2lucy5maWxsZXIgPSBmaWxsZXI7XG5wbHVnaW5zLmxlZ2VuZCA9IGxlZ2VuZDtcbnBsdWdpbnMudGl0bGUgPSB0aXRsZTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0XG4gKi9cblxuXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycyA9IGhlbHBlcnMkMTtcblxuLy8gQHRvZG8gZGlzcGF0Y2ggdGhlc2UgaGVscGVycyBpbnRvIGFwcHJvcHJpYXRlZCBoZWxwZXJzL2hlbHBlcnMuKiBmaWxlIGFuZCB3cml0ZSB1bml0IHRlc3RzIVxuY29yZV9oZWxwZXJzKGNvcmVfY29udHJvbGxlcik7XG5cbmNvcmVfY29udHJvbGxlci5fYWRhcHRlcnMgPSBjb3JlX2FkYXB0ZXJzO1xuY29yZV9jb250cm9sbGVyLkFuaW1hdGlvbiA9IGNvcmVfYW5pbWF0aW9uO1xuY29yZV9jb250cm9sbGVyLmFuaW1hdGlvblNlcnZpY2UgPSBjb3JlX2FuaW1hdGlvbnM7XG5jb3JlX2NvbnRyb2xsZXIuY29udHJvbGxlcnMgPSBjb250cm9sbGVycztcbmNvcmVfY29udHJvbGxlci5EYXRhc2V0Q29udHJvbGxlciA9IGNvcmVfZGF0YXNldENvbnRyb2xsZXI7XG5jb3JlX2NvbnRyb2xsZXIuZGVmYXVsdHMgPSBjb3JlX2RlZmF1bHRzO1xuY29yZV9jb250cm9sbGVyLkVsZW1lbnQgPSBjb3JlX2VsZW1lbnQ7XG5jb3JlX2NvbnRyb2xsZXIuZWxlbWVudHMgPSBlbGVtZW50cztcbmNvcmVfY29udHJvbGxlci5JbnRlcmFjdGlvbiA9IGNvcmVfaW50ZXJhY3Rpb247XG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0cyA9IGNvcmVfbGF5b3V0cztcbmNvcmVfY29udHJvbGxlci5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuY29yZV9jb250cm9sbGVyLnBsdWdpbnMgPSBjb3JlX3BsdWdpbnM7XG5jb3JlX2NvbnRyb2xsZXIuU2NhbGUgPSBjb3JlX3NjYWxlO1xuY29yZV9jb250cm9sbGVyLnNjYWxlU2VydmljZSA9IGNvcmVfc2NhbGVTZXJ2aWNlO1xuY29yZV9jb250cm9sbGVyLlRpY2tzID0gY29yZV90aWNrcztcbmNvcmVfY29udHJvbGxlci5Ub29sdGlwID0gY29yZV90b29sdGlwO1xuXG4vLyBSZWdpc3RlciBidWlsdC1pbiBzY2FsZXNcblxuY29yZV9jb250cm9sbGVyLmhlbHBlcnMuZWFjaChzY2FsZXMsIGZ1bmN0aW9uKHNjYWxlLCB0eXBlKSB7XG5cdGNvcmVfY29udHJvbGxlci5zY2FsZVNlcnZpY2UucmVnaXN0ZXJTY2FsZVR5cGUodHlwZSwgc2NhbGUsIHNjYWxlLl9kZWZhdWx0cyk7XG59KTtcblxuLy8gTG9hZCB0byByZWdpc3RlciBidWlsdC1pbiBhZGFwdGVycyAoYXMgc2lkZSBlZmZlY3RzKVxuXG5cbi8vIExvYWRpbmcgYnVpbHQtaW4gcGx1Z2luc1xuXG5mb3IgKHZhciBrIGluIHBsdWdpbnMpIHtcblx0aWYgKHBsdWdpbnMuaGFzT3duUHJvcGVydHkoaykpIHtcblx0XHRjb3JlX2NvbnRyb2xsZXIucGx1Z2lucy5yZWdpc3RlcihwbHVnaW5zW2tdKTtcblx0fVxufVxuXG5jb3JlX2NvbnRyb2xsZXIucGxhdGZvcm0uaW5pdGlhbGl6ZSgpO1xuXG52YXIgc3JjID0gY29yZV9jb250cm9sbGVyO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5DaGFydCA9IGNvcmVfY29udHJvbGxlcjtcbn1cblxuLy8gREVQUkVDQVRJT05TXG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5DaGFydFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLkNoYXJ0ID0gY29yZV9jb250cm9sbGVyO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmVcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuTGVnZW5kXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIuTGVnZW5kID0gcGx1Z2lucy5sZWdlbmQuX2VsZW1lbnQ7XG5cbi8qKlxuICogUHJvdmlkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIG5vdCBhdmFpbGFibGUgYW55bW9yZVxuICogQG5hbWVzcGFjZSBDaGFydC5UaXRsZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjEuNVxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICogQHByaXZhdGVcbiAqL1xuY29yZV9jb250cm9sbGVyLlRpdGxlID0gcGx1Z2lucy50aXRsZS5fZWxlbWVudDtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LnBsdWdpbnMgaW5zdGVhZFxuICogQG5hbWVzcGFjZSBDaGFydC5wbHVnaW5TZXJ2aWNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuMS41XG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIucGx1Z2luU2VydmljZSA9IGNvcmVfY29udHJvbGxlci5wbHVnaW5zO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbmhlcml0aW5nIGZyb20gQ2hhcnQuUGx1Z2luZ0Jhc2UgaGFzIG5vXG4gKiBlZmZlY3QsIGluc3RlYWQgc2ltcGx5IGNyZWF0ZS9yZWdpc3RlciBwbHVnaW5zIHZpYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKiBAaW50ZXJmYWNlIENoYXJ0LlBsdWdpbkJhc2VcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi41LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5QbHVnaW5CYXNlID0gY29yZV9jb250cm9sbGVyLkVsZW1lbnQuZXh0ZW5kKHt9KTtcblxuLyoqXG4gKiBQcm92aWRlZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdXNlIENoYXJ0LmhlbHBlcnMuY2FudmFzIGluc3RlYWQuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmNhbnZhc0hlbHBlcnNcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMi42LjBcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5jYW52YXNIZWxwZXJzID0gY29yZV9jb250cm9sbGVyLmhlbHBlcnMuY2FudmFzO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB1c2UgQ2hhcnQubGF5b3V0cyBpbnN0ZWFkLlxuICogQG5hbWVzcGFjZSBDaGFydC5sYXlvdXRTZXJ2aWNlXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDIuNy4zXG4gKiBAdG9kbyByZW1vdmUgYXQgdmVyc2lvbiAzXG4gKiBAcHJpdmF0ZVxuICovXG5jb3JlX2NvbnRyb2xsZXIubGF5b3V0U2VydmljZSA9IGNvcmVfY29udHJvbGxlci5sYXlvdXRzO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBub3QgYXZhaWxhYmxlIGFueW1vcmUuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkxpbmVhclNjYWxlQmFzZVxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjhcbiAqIEB0b2RvIHJlbW92ZSBhdCB2ZXJzaW9uIDNcbiAqIEBwcml2YXRlXG4gKi9cbmNvcmVfY29udHJvbGxlci5MaW5lYXJTY2FsZUJhc2UgPSBzY2FsZV9saW5lYXJiYXNlO1xuXG4vKipcbiAqIFByb3ZpZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpbnN0ZWFkIHdlIHNob3VsZCBjcmVhdGUgYSBuZXcgQ2hhcnRcbiAqIGJ5IHNldHRpbmcgdGhlIHR5cGUgaW4gdGhlIGNvbmZpZyAoYG5ldyBDaGFydChpZCwge3R5cGU6ICd7Y2hhcnQtdHlwZX0nfWApLlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAyLjguMFxuICogQHRvZG8gcmVtb3ZlIGF0IHZlcnNpb24gM1xuICovXG5jb3JlX2NvbnRyb2xsZXIuaGVscGVycy5lYWNoKFxuXHRbXG5cdFx0J0JhcicsXG5cdFx0J0J1YmJsZScsXG5cdFx0J0RvdWdobnV0Jyxcblx0XHQnTGluZScsXG5cdFx0J1BvbGFyQXJlYScsXG5cdFx0J1JhZGFyJyxcblx0XHQnU2NhdHRlcidcblx0XSxcblx0ZnVuY3Rpb24oa2xhc3MpIHtcblx0XHRjb3JlX2NvbnRyb2xsZXJba2xhc3NdID0gZnVuY3Rpb24oY3R4LCBjZmcpIHtcblx0XHRcdHJldHVybiBuZXcgY29yZV9jb250cm9sbGVyKGN0eCwgY29yZV9jb250cm9sbGVyLmhlbHBlcnMubWVyZ2UoY2ZnIHx8IHt9LCB7XG5cdFx0XHRcdHR5cGU6IGtsYXNzLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2xhc3Muc2xpY2UoMSlcblx0XHRcdH0pKTtcblx0XHR9O1xuXHR9XG4pO1xuXG5yZXR1cm4gc3JjO1xuXG59KSkpO1xuIiwiaW1wb3J0IENoYXJ0IGZyb20gJ2NoYXJ0LmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUNoYXJ0KGNoYXJ0SWQsIGNoYXJ0VHlwZSkge1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlcyxcbiAgICAgICAgY2xhc3M6IHRoaXMuY3NzQ2xhc3Nlc1xuICAgICAgfSwgW2NyZWF0ZUVsZW1lbnQoJ2NhbnZhcycsIHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICBpZDogdGhpcy5jaGFydElkLFxuICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiAnY2FudmFzJ1xuICAgICAgfSldKTtcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBjaGFydElkOiB7XG4gICAgICAgIGRlZmF1bHQ6IGNoYXJ0SWQsXG4gICAgICAgIHR5cGU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIHdpZHRoOiB7XG4gICAgICAgIGRlZmF1bHQ6IDQwMCxcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIGRlZmF1bHQ6IDQwMCxcbiAgICAgICAgdHlwZTogTnVtYmVyXG4gICAgICB9LFxuICAgICAgY3NzQ2xhc3Nlczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdFxuICAgICAgfSxcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9jaGFydDogbnVsbCxcbiAgICAgICAgX3BsdWdpbnM6IHRoaXMucGx1Z2luc1xuICAgICAgfTtcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGFkZFBsdWdpbjogZnVuY3Rpb24gYWRkUGx1Z2luKHBsdWdpbikge1xuICAgICAgICB0aGlzLiRkYXRhLl9wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUxlZ2VuZDogZnVuY3Rpb24gZ2VuZXJhdGVMZWdlbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLiRkYXRhLl9jaGFydCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRkYXRhLl9jaGFydC5nZW5lcmF0ZUxlZ2VuZCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVuZGVyQ2hhcnQ6IGZ1bmN0aW9uIHJlbmRlckNoYXJ0KGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB0aGlzLiRkYXRhLl9jaGFydC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGRhdGEuX2NoYXJ0ID0gbmV3IENoYXJ0KHRoaXMuJHJlZnMuY2FudmFzLmdldENvbnRleHQoJzJkJyksIHtcbiAgICAgICAgICB0eXBlOiBjaGFydFR5cGUsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgIHBsdWdpbnM6IHRoaXMuJGRhdGEuX3BsdWdpbnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMuJGRhdGEuX2NoYXJ0KSB7XG4gICAgICAgIHRoaXMuJGRhdGEuX2NoYXJ0LmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5leHBvcnQgdmFyIEJhciA9IGdlbmVyYXRlQ2hhcnQoJ2Jhci1jaGFydCcsICdiYXInKTtcbmV4cG9ydCB2YXIgSG9yaXpvbnRhbEJhciA9IGdlbmVyYXRlQ2hhcnQoJ2hvcml6b250YWxiYXItY2hhcnQnLCAnaG9yaXpvbnRhbEJhcicpO1xuZXhwb3J0IHZhciBEb3VnaG51dCA9IGdlbmVyYXRlQ2hhcnQoJ2RvdWdobnV0LWNoYXJ0JywgJ2RvdWdobnV0Jyk7XG5leHBvcnQgdmFyIExpbmUgPSBnZW5lcmF0ZUNoYXJ0KCdsaW5lLWNoYXJ0JywgJ2xpbmUnKTtcbmV4cG9ydCB2YXIgUGllID0gZ2VuZXJhdGVDaGFydCgncGllLWNoYXJ0JywgJ3BpZScpO1xuZXhwb3J0IHZhciBQb2xhckFyZWEgPSBnZW5lcmF0ZUNoYXJ0KCdwb2xhci1jaGFydCcsICdwb2xhckFyZWEnKTtcbmV4cG9ydCB2YXIgUmFkYXIgPSBnZW5lcmF0ZUNoYXJ0KCdyYWRhci1jaGFydCcsICdyYWRhcicpO1xuZXhwb3J0IHZhciBCdWJibGUgPSBnZW5lcmF0ZUNoYXJ0KCdidWJibGUtY2hhcnQnLCAnYnViYmxlJyk7XG5leHBvcnQgdmFyIFNjYXR0ZXIgPSBnZW5lcmF0ZUNoYXJ0KCdzY2F0dGVyLWNoYXJ0JywgJ3NjYXR0ZXInKTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgQmFyOiBCYXIsXG4gIEhvcml6b250YWxCYXI6IEhvcml6b250YWxCYXIsXG4gIERvdWdobnV0OiBEb3VnaG51dCxcbiAgTGluZTogTGluZSxcbiAgUGllOiBQaWUsXG4gIFBvbGFyQXJlYTogUG9sYXJBcmVhLFxuICBSYWRhcjogUmFkYXIsXG4gIEJ1YmJsZTogQnViYmxlLFxuICBTY2F0dGVyOiBTY2F0dGVyXG59OyIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IEJhciwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogQmFyLFxuICAgIG1peGluczogW3JlYWN0aXZlUHJvcF0sXG4gICAgcHJvcHM6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0KCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCh0aGlzLmNoYXJ0RGF0YSwgdGhpcy5vcHRpb25zKTtcbiAgICB9LFxuICB9O1xuPC9zY3JpcHQ+IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjaGFydExhYmVscyA9IFsnMTk4MCcsICcxOTkwJywgJzIwMDAnLCAnMjAxMCcsICcyMDIwJ107XG5cbmNvbnN0IGNoYXJ0RGF0YUxpc3QgPSBbNjU0MjU2NCwgNzMyMjU2NCwgODAwODI3OCwgODE3NTEzMywgNTQ3NTEzM107XG5cbmNvbnN0IENoYXJ0RGF0YSA9IHtcbiAgZGF0YToge1xuICAgIGxhYmVsczogY2hhcnRMYWJlbHMsXG4gICAgZGF0YXNldHM6IFtcbiAgICAgIHtcbiAgICAgICAgZGF0YTogY2hhcnREYXRhTGlzdCxcbiAgICAgICAgZmlsbDogZmFsc2UsIC8vIHVzZWQgYnkgbGluZSBjaGFydFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcbiAgICAgICAgICAnIzJGMzM0RicsXG4gICAgICAgICAgJyMzMTU1QTYnLFxuICAgICAgICAgICcjRjI2OTVEJyxcbiAgICAgICAgICAnI0VCQkNEOCcsXG4gICAgICAgICAgJyNGOUExMzcnLFxuICAgICAgICBdLFxuICAgICAgICBib3JkZXJDb2xvcjogW1xuICAgICAgICAgICcjQUNBRUI5J1xuICAgICAgICBdLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfSxcbiAgICBdXG4gIH0sXG4gIGJhcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgIHRleHQ6ICdQb3B1bGF0aW9uIENoYXJ0JyxcbiAgICAgIH0sXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICB9LFxuICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgICBzY2FsZXM6IHtcbiAgICAgICAgeEF4ZXM6IFt7XG4gICAgICAgICAgc2NhbGVMYWJlbDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxhYmVsU3RyaW5nOiAnWWVhcnMnLFxuICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgIHlBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1BvcHVsYXRpb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IDI1LFxuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGhvcml6b250YWxCYXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICB0ZXh0OiAnUG9wdWxhdGlvbiBDaGFydCcsXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHhBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1BvcHVsYXRpb24nLFxuICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgIHlBeGVzOiBbe1xuICAgICAgICAgIHNjYWxlTGFiZWw6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsYWJlbFN0cmluZzogJ1llYXJzJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBwYWRkaW5nOiAyNSxcbiAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwaWU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICB0ZXh0OiAnUG9wdWxhdGlvbiBDaGFydCcsXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICB9LFxuICAgICAgbGluZVRlbnNpb246IDEsXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0RGF0YTsiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBWdWUgZnJvbSAndnVlL2Rpc3QvdnVlLmVzbS5icm93c2VyJztcbmltcG9ydCBDaGFydENvbXBvbmVudCBmcm9tICcuL2NoYXJ0LS1iYXIudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IENoYXJ0RGF0YSBmcm9tICcuL2NoYXJ0LmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY29uc3QgY2hhcnRUeXBlID0gJ2Jhcic7XG5cbmNsYXNzIENoYXJ0QmFyIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KGBueWNvLWNoYXJ0LSR7Y2hhcnRUeXBlfWAsIENoYXJ0Q29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6IGBbZGF0YS1qcz1cImNoYXJ0LSR7Y2hhcnRUeXBlfVwiXWAsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogQ2hhcnREYXRhLmRhdGEsXG4gICAgICAgICAgb3B0aW9uczogQ2hhcnREYXRhLmJhci5vcHRpb25zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2hhcnRCYXI7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgSG9yaXpvbnRhbEJhciwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogSG9yaXpvbnRhbEJhcixcbiAgICBtaXhpbnM6IFtyZWFjdGl2ZVByb3BdLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLWhvcml6b250YWwtYmFyLnZ1ZSc7IC8vIE91ciBjb21wb25lbnRcbmltcG9ydCBDaGFydERhdGEgZnJvbSAnLi9jaGFydC5kYXRhJzsgLy8gT3VyIHNhbXBsZSBkYXRhXG5cbmNvbnN0IGNoYXJ0VHlwZSA9ICdob3Jpem9udGFsLWJhcic7XG5cbmNsYXNzIENoYXJ0SG9yaXpvbnRhbEJhciB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzID0ge30sIGRhdGEgPSB7fSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgVnVlLmNvbXBvbmVudChgbnljby1jaGFydC0ke2NoYXJ0VHlwZX1gLCBDaGFydENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiBgW2RhdGEtanM9XCJjaGFydC0ke2NoYXJ0VHlwZX1cIl1gLFxuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IENoYXJ0RGF0YS5kYXRhLFxuICAgICAgICAgIG9wdGlvbnM6IENoYXJ0RGF0YS5ob3Jpem9udGFsQmFyLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydEhvcml6b250YWxCYXI7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgTGluZSwgbWl4aW5zIH0gZnJvbSAndnVlLWNoYXJ0anMnO1xuICBjb25zdCB7IHJlYWN0aXZlUHJvcCB9ID0gbWl4aW5zO1xuXG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5wYWRkaW5nID0gMjA7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5mb250U2l6ZSA9IDE2O1xuICBDaGFydC5kZWZhdWx0cy5nbG9iYWwudGl0bGUubGluZUhlaWdodCA9IDEuNjtcblxuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZXh0ZW5kczogTGluZSxcbiAgICBtaXhpbnM6IFtyZWFjdGl2ZVByb3BdLFxuICAgIHByb3BzOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLWxpbmUudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IENoYXJ0RGF0YSBmcm9tICcuL2NoYXJ0LmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcblxuY29uc3QgY2hhcnRUeXBlID0gJ2xpbmUnO1xuXG5jbGFzcyBDaGFydExpbmUge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoYG55Y28tY2hhcnQtJHtjaGFydFR5cGV9YCwgQ2hhcnRDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogYFtkYXRhLWpzPVwiY2hhcnQtJHtjaGFydFR5cGV9XCJdYCxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBDaGFydERhdGEuZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBDaGFydERhdGEuYmFyLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydExpbmU7IiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgUGllLCBtaXhpbnMgfSBmcm9tICd2dWUtY2hhcnRqcyc7XG4gIGNvbnN0IHsgcmVhY3RpdmVQcm9wIH0gPSBtaXhpbnM7XG5cbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLnBhZGRpbmcgPSAyMDtcbiAgQ2hhcnQuZGVmYXVsdHMuZ2xvYmFsLnRpdGxlLmZvbnRTaXplID0gMTY7XG4gIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC50aXRsZS5saW5lSGVpZ2h0ID0gMS42O1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBleHRlbmRzOiBQaWUsXG4gICAgbWl4aW5zOiBbcmVhY3RpdmVQcm9wXSxcbiAgICBwcm9wczoge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVUZW5zaW9uOiAxLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIHRoaXMucmVuZGVyQ2hhcnQodGhpcy5jaGFydERhdGEsIHRoaXMub3B0aW9ucyk7XG4gICAgfSxcbiAgfTtcbjwvc2NyaXB0PiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IENoYXJ0Q29tcG9uZW50IGZyb20gJy4vY2hhcnQtLXBpZS52dWUnOyAvLyBPdXIgY29tcG9uZW50XG5pbXBvcnQgQ2hhcnREYXRhIGZyb20gJy4vY2hhcnQuZGF0YSc7IC8vIE91ciBzYW1wbGUgZGF0YVxuXG5jb25zdCBjaGFydFR5cGUgPSAncGllJztcblxuY2xhc3MgQ2hhcnRQaWUge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoYG55Y28tY2hhcnQtJHtjaGFydFR5cGV9YCwgQ2hhcnRDb21wb25lbnQpO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBlbDogYFtkYXRhLWpzPVwiY2hhcnQtJHtjaGFydFR5cGV9XCJdYCxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBDaGFydERhdGEuZGF0YSxcbiAgICAgICAgICBvcHRpb25zOiBDaGFydERhdGEucGllLm9wdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgY29uc3RhbnRzIHRvIHRoZSBkZWJ1Z2dlclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtIC0gb3VyIGNvbnN0YW50c1xuICAgKi9cbiAgX2NvbnN0YW50cyhwYXJhbSkge1xuICAgIGNvbnNvbGUuZGlyKHBhcmFtKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDaGFydFBpZTsiLCI8dGVtcGxhdGU+PC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIHByb3BzOiB7XG4gICAgICAnbGF5ZXJzJzoge1xuICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgfSxcbiAgICAgICdjb25maWcnOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hcDogbnVsbCxcbiAgICAgICAgbWFwUG9wdXA6IG51bGwsXG4gICAgICAgIG1hcEZpbHRlcjogbnVsbCxcbiAgICAgICAgYWN0aXZlTGF5ZXI6IG51bGwsXG4gICAgICAgIG1hcExvYWRlZDogZmFsc2UsXG4gICAgICAgIG1lbnVJdGVtczogW10sXG4gICAgICAgIHNlbGVjdGVkSXRlbXM6IFtdLFxuICAgICAgfTtcbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVNYXAoKTtcbiAgICB9LFxuICAgIGRlc3Ryb3llZCgpIHtcbiAgICAgIHRoaXMubWFwLnJlbW92ZSgpO1xuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICdsYXllcnMnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IHRoaXMubGF5ZXJzO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5tYXBUeXBlID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgICAgICAgdGhpcy50cmFja0xheWVyKGxheWVyLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAobGF5ZXIuZGVmYXVsdCB8fCB0aGlzLmxheWVycy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZlTGF5ZXIgPSBsYXllci5uYW1lO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQpXG4gICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcubWFwVHlwZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzWzBdO1xuXG4gICAgICAgICAgdGhpcy5hY3RpdmVMYXllciA9IGxheWVyLm5hbWU7XG4gICAgICAgICAgdGhpcy5nZW5lcmF0ZUxlZ2VuZChsYXllci5kYXRhKTtcblxuICAgICAgICAgIGlmICh0aGlzLm1hcExvYWRlZClcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUxheWVyKGxheWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFR5cGUgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnbWFwTG9hZGVkJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tYXBMb2FkZWQgJiYgdGhpcy5sYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplTGF5ZXIobGF5ZXJzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnbWVudUl0ZW1zJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tZW51SXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVUb2dnbGUodGhpcy5tZW51SXRlbXMpO1xuICAgICAgfSxcbiAgICAgICdzZWxlY3RlZEl0ZW1zJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBsYXllciA9IHRoaXMubGF5ZXJzWzBdO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBbJ2luJywgbGF5ZXIubGVnZW5kQ29sdW1uXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGZpbHRlci5wdXNoKHRoaXMuc2VsZWN0ZWRJdGVtc1tpXSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCByZWxhdGVkRmVhdHVyZXMgPSB0aGlzLm1hcC5xdWVyeVNvdXJjZUZlYXR1cmVzKGxheWVyLm5hbWUsIHtcbiAgICAgICAgICAgIHNvdXJjZUxheWVyOiBsYXllci5uYW1lLFxuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXJcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHNldCBmaWx0ZXIgd2hlbiBsZWdlbmQgaXRlbSBzZWxlY3RlZFxuICAgICAgICAgIHRoaXMubWFwLnNldEZpbHRlcihgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGAsIGZpbHRlcik7XG4gICAgICAgICAgdGhpcy5tYXAuc2V0TGF5b3V0UHJvcGVydHkoYCR7bGF5ZXIubmFtZX0taGlnaGxpZ2h0ZWRgLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWRJdGVtcy5sZW5ndGggJiYgIXRoaXMubWFwUG9wdXApIHtcbiAgICAgICAgICB0aGlzLm1hcC5zZXRGaWx0ZXIoYCR7bGF5ZXIubmFtZX0taGlnaGxpZ2h0ZWRgLCBudWxsKTtcbiAgICAgICAgICB0aGlzLm1hcC5zZXRMYXlvdXRQcm9wZXJ0eShgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGAsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIGluaXRpYWxpemVNYXAoKSB7XG4gICAgICAgIGNvbnN0IG1hcENvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICAgIGNvbnRhaW5lcjogbWFwQ29uZmlnLmNvbnRhaW5lcklkLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBDb25maWcuY2VudGVyKVxuICAgICAgICAgIG9wdGlvbnMuY2VudGVyID0gbWFwQ29uZmlnLmNlbnRlcjtcblxuICAgICAgICBpZiAobWFwQ29uZmlnLnN0eWxlKVxuICAgICAgICAgIG9wdGlvbnMuc3R5bGUgPSBtYXBDb25maWcuc3R5bGU7XG5cbiAgICAgICAgaWYgKG1hcENvbmZpZy56b29tKVxuICAgICAgICAgIG9wdGlvbnMuem9vbSA9IG1hcENvbmZpZy56b29tO1xuXG4gICAgICAgIG1hcGJveGdsLmFjY2Vzc1Rva2VuID0gbWFwQ29uZmlnLkFQSUtleTtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgbWFwYm94Z2wuTWFwKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1hcC5hZGRDb250cm9sKG5ldyBtYXBib3hnbC5OYXZpZ2F0aW9uQ29udHJvbCgpKTtcblxuICAgICAgICAvLyBkaXNhYmxlIG1hcCB6b29tIHdoZW4gdXNpbmcgc2Nyb2xsXG4gICAgICAgIGlmIChtYXBDb25maWcuZGlzYWJsZVNjcm9sbClcbiAgICAgICAgICB0aGlzLm1hcC5zY3JvbGxab29tLmRpc2FibGUoKTtcblxuICAgICAgICB0aGlzLm1hcC5vbignbG9hZCcsICgpID0+IHRoaXMubWFwTG9hZGVkID0gdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgaW5pdGlhbGl6ZUxheWVyKGxheWVyKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcC5nZXRMYXllcihsYXllci5uYW1lKSA9PT0gdW5kZWZpbmVkICYmIE9iamVjdC5lbnRyaWVzKGxheWVyLmRhdGEpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IHZpc2liaWxpdHkgPSBsYXllci5uYW1lID09PSB0aGlzLmFjdGl2ZUxheWVyID8gJ3Zpc2libGUnIDogJ25vbmUnO1xuICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGxheWVyLmZpbHRlckJ5ID8gWydpbicsIGxheWVyLmZpbHRlckJ5LCAnJ10gOiBbXTtcbiAgICAgICAgICBjb25zdCBmaWxsID0gdGhpcy5jb25maWcuY29sb3JzID8gdGhpcy5nZW5lcmF0ZUZpbGxDb2xvcih0aGlzLmNvbmZpZy5jb2xvcnMpIDogbGF5ZXIuZmlsbDtcblxuICAgICAgICAgIHRoaXMubWFwLmFkZFNvdXJjZShsYXllci5uYW1lLCB7XG4gICAgICAgICAgICAndHlwZSc6ICdnZW9qc29uJyxcbiAgICAgICAgICAgICdkYXRhJzogbGF5ZXIuZGF0YVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIoe1xuICAgICAgICAgICAgJ2lkJzogbGF5ZXIubmFtZSxcbiAgICAgICAgICAgICd0eXBlJzogJ2ZpbGwnLFxuICAgICAgICAgICAgJ3NvdXJjZSc6IGxheWVyLm5hbWUsXG4gICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICdmaWxsLW91dGxpbmUtY29sb3InOiBmaWxsWzBdLFxuICAgICAgICAgICAgICAnZmlsbC1jb2xvcic6IGZpbGxbMV0sXG4gICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAwLjdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6IHZpc2liaWxpdHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMubWFwLmFkZExheWVyKHtcbiAgICAgICAgICAgICdpZCc6IGAke2xheWVyLm5hbWV9LWhpZ2hsaWdodGVkYCxcbiAgICAgICAgICAgICd0eXBlJzogJ2ZpbGwnLFxuICAgICAgICAgICAgJ3NvdXJjZSc6IGxheWVyLm5hbWUsXG4gICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICdmaWxsLW91dGxpbmUtY29sb3InOiBmaWxsWzBdLFxuICAgICAgICAgICAgICAnZmlsbC1jb2xvcic6IGZpbGxbMV0sXG4gICAgICAgICAgICAgICdmaWxsLW9wYWNpdHknOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2ZpbHRlcic6IGZpbHRlcixcbiAgICAgICAgICAgICdsYXlvdXQnOiB7XG4gICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogdmlzaWJpbGl0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplRmlsdGVyKGxheWVyKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnNvck9uSG92ZXIobGF5ZXIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbml0aWFsaXplUG9wdXAoZXZlbnQsIGxheWVyKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1hcFR5cGUgPT09ICdtdWx0aScgPyB0aGlzLnBvcHVwTXVsdGlMYXllcihldmVudCwgbGF5ZXIpIDogdGhpcy5wb3B1cFNpbmdsZUxheWVyKGV2ZW50LCBsYXllcik7XG4gICAgICB9LFxuICAgICAgaW5pdGlhbGl6ZVRvZ2dsZSh0b2dnbGVMaXN0KSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1hcFR5cGUgPT09ICdtdWx0aScgPyB0aGlzLnRvZ2dsZU11bHRpTGF5ZXIodG9nZ2xlTGlzdCkgOiB0aGlzLnRvZ2dsZVNpbmdsZUxheWVyKHRvZ2dsZUxpc3QpO1xuICAgICAgfSxcbiAgICAgIGluaXRpYWxpemVGaWx0ZXIobGF5ZXIpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWFwVHlwZSA9PT0gJ211bHRpJyA/IHRoaXMuZmlsdGVyTXVsdGlMYXllcihsYXllcikgOiB0aGlzLmZpbHRlclNpbmdsZUxheWVyKGxheWVyKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVDdXJzb3JPbkhvdmVyKGxheWVySWQpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy5tYXA7XG5cbiAgICAgICAgLy8gY2hhbmdlIHRoZSBjdXJzb3IgdG8gYSBwb2ludGVyIHdoZW4gdGhlIG1vdXNlIGlzIG92ZXIgdGhlIGxheWVyLlxuICAgICAgICBtYXAub24oJ21vdXNlZW50ZXInLCBsYXllcklkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWFwLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2hhbmdlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgZGVmYXVsdCB3aGVuIGl0IGxlYXZlcyB0aGUgbGF5ZXIuXG4gICAgICAgIG1hcC5vbignbW91c2VsZWF2ZScsIGxheWVySWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtYXAuZ2V0Q2FudmFzKCkuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlRmlsbENvbG9yKGNvbG9ycykge1xuICAgICAgICByZXR1cm4gY29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbG9ycy5sZW5ndGgpXTtcbiAgICAgIH0sXG4gICAgICAvLyBtdWx0aSBsYXllclxuICAgICAgdHJhY2tMYXllcihyZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lbnVJdGVtcy5pbmNsdWRlcyhyZWZlcmVuY2UpKVxuICAgICAgICAgIHRoaXMubWVudUl0ZW1zLnB1c2gocmVmZXJlbmNlKTtcbiAgICAgIH0sXG4gICAgICBwb3B1cE11bHRpTGF5ZXIoZXZlbnQsIGxheWVyKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuICAgICAgICBjb25zdCBsYXllck5hbWUgPSBgJHtsYXllci5uYW1lfS1oaWdobGlnaHRlZGA7XG4gICAgICAgIGNvbnN0IHBvcHVwID0gbmV3IG1hcGJveGdsLlBvcHVwKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRMbmdMYXQoZXZlbnQubG5nTGF0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldEhUTUwoZXZlbnQuZmVhdHVyZXNbMF0ucHJvcGVydGllc1tsYXllci5maWx0ZXJCeV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkVG8obWFwKTtcblxuICAgICAgICBpZiAocG9wdXAuaXNPcGVuKCkpIHtcbiAgICAgICAgICAkdGhpcy5tYXBQb3B1cCA9IHBvcHVwO1xuICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShsYXllck5hbWUsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgJHRoaXMubWFwRmlsdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcHVwLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyByZXNldCBhc3NvY2lhdGVkIHN0YXRlcyB3aGVuIHBvcHVwIGRpc21pc3NlZCB3aGlsZSBhY3RpdmVcbiAgICAgICAgICBpZiAoJHRoaXMubWFwUG9wdXAgPT09IHBvcHVwKSB7XG4gICAgICAgICAgICAkdGhpcy5tYXBQb3B1cCA9IG51bGw7XG4gICAgICAgICAgICAkdGhpcy5tYXBGaWx0ZXIgPSBudWxsO1xuICAgICAgICAgICAgbWFwLnNldEZpbHRlcihsYXllck5hbWUsIG51bGwpO1xuICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGxheWVyTmFtZSwgJ3Zpc2liaWxpdHknLCAnbm9uZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZmlsdGVyTXVsdGlMYXllcihsYXllcikge1xuICAgICAgICBjb25zdCAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1hcCA9ICR0aGlzLm1hcDtcblxuICAgICAgICBtYXAub24oJ2NsaWNrJywgbGF5ZXIubmFtZSwgKGUpID0+IHtcbiAgICAgICAgICAvLyBzZXQgYmJveCBhcyByZWFjdGFuZ2xlIGFyZWEgYXJvdW5kIGNsaWNrZWQgcG9pbnRcbiAgICAgICAgICBsZXQgYmJveCA9IFtbZS5wb2ludC54LCBlLnBvaW50LnldLCBbZS5wb2ludC54LCBlLnBvaW50LnldXTtcbiAgICAgICAgICBsZXQgZmVhdHVyZXMgPSBtYXAucXVlcnlSZW5kZXJlZEZlYXR1cmVzKGJib3gsIHsgbGF5ZXJzOiBbbGF5ZXIubmFtZV0gfSk7XG5cbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBmZWF0dXJlcy5yZWR1Y2UoZnVuY3Rpb24obWVtbywgZmVhdHVyZSkge1xuICAgICAgICAgICAgbWVtby5wdXNoKGZlYXR1cmUucHJvcGVydGllc1tsYXllci5maWx0ZXJCeV0pO1xuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgICAgfSwgWydpbicsIGAke2xheWVyLmZpbHRlckJ5fWBdKTtcblxuICAgICAgICAgICR0aGlzLm1hcEZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgICAkdGhpcy5pbml0aWFsaXplUG9wdXAoZSwgbGF5ZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVNdWx0aUxheWVyKGxheWVyc1RvVG9nZ2xlKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuICAgICAgICBjb25zdCBhY3RpdmVMYXllciA9ICR0aGlzLmFjdGl2ZUxheWVyO1xuICAgICAgICBjb25zdCBsaW5rQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5jb25maWcubGVnZW5kSWQpO1xuXG4gICAgICAgIC8vIGNsZWFyIGFsbCBsaW5rcyBiZWZvcmUgYXBwZW5kaW5nIG5ldyBvbmVzIHRvIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICB3aGlsZSAobGlua0NvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgbGlua0NvbnRhaW5lci5yZW1vdmVDaGlsZChsaW5rQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnNUb1RvZ2dsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxheWVyUmVmID0gbGF5ZXJzVG9Ub2dnbGVbaV07XG4gICAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICAgICAgICAgIGxpbmsuaHJlZiA9ICcjJztcbiAgICAgICAgICBsaW5rLnRleHRDb250ZW50ID0gbGF5ZXJSZWY7XG5cbiAgICAgICAgICBpZiAobGF5ZXJSZWYgPT09IGFjdGl2ZUxheWVyKVxuICAgICAgICAgICAgbGluay5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcblxuICAgICAgICAgIC8vIG9uIGNsaWNrIHVwZGF0ZSBsaW5rIHN0YXRlLCBhY3RpdmUgbGF5ZXIgcmVmZXJlbmNlLCBhbmQgbGF5ZXIgdmlzaWJpbGl0eVxuICAgICAgICAgIGxpbmsub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZExheWVyID0gdGhpcy50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gbGlua0NvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgYWN0aXZlIHBvcHVwXG4gICAgICAgICAgICBpZiAoJHRoaXMubWFwUG9wdXApXG4gICAgICAgICAgICAgICR0aGlzLm1hcFBvcHVwLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMaW5rID0gbGlua3NbaV07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMYXllciA9IGN1cnJlbnRMaW5rLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TGF5ZXJIaWdobGlnaHQgPSBgJHtjdXJyZW50TGF5ZXJ9LWhpZ2hsaWdodGVkYDtcbiAgICAgICAgICAgICAgY29uc3QgbGF5ZXJWaXNpYmlsaXR5ID0gbWFwLmdldExheW91dFByb3BlcnR5KGN1cnJlbnRMYXllciwgJ3Zpc2liaWxpdHknKTtcblxuICAgICAgICAgICAgICBpZiAoY3VycmVudExheWVyID09PSBzZWxlY3RlZExheWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGlmIGxheWVyIGlzIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJWaXNpYmlsaXR5ID09PSAndmlzaWJsZScgJiYgY3VycmVudExpbmsuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSlcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIHNldCBvdXIgY3VycmVudCBsYXllciBhcyB0aGUgZ2xvYmFsIGFjdGl2ZSBsYXllcixcbiAgICAgICAgICAgICAgICAvLyBhZGQgYWN0aXZlIGNsYXNzIHRvIGxpbmssIHNldCBsYXllciBhcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgJHRoaXMuYWN0aXZlTGF5ZXIgPSBjdXJyZW50TGF5ZXI7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmsuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGN1cnJlbnRMYXllciwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsaW5rcyBhY3RpdmUgY2xhc3MsIHNldCBsYXllciB2aXNpYmlsaXR5IHRvIG5vbmUgYW5kIHJlbW92ZSBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgY3VycmVudExpbmsuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgbWFwLnNldExheW91dFByb3BlcnR5KGN1cnJlbnRMYXllciwgJ3Zpc2liaWxpdHknLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShjdXJyZW50TGF5ZXJIaWdobGlnaHQsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGN1cnJlbnRMYXllckhpZ2hsaWdodCwgbnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbGlua0NvbnRhaW5lci5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIHNpbmdsZSBsYXllclxuICAgICAgZ2VuZXJhdGVMZWdlbmQobGF5ZXJEYXRhKSB7XG4gICAgICAgIGxheWVyRGF0YS5mZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IGZlYXR1cmUucHJvcGVydGllc1t0aGlzLmxheWVyc1swXS5sZWdlbmRDb2x1bW5dO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLm1lbnVJdGVtcy5pbmNsdWRlcyhpdGVtKSAmJiBpdGVtKVxuICAgICAgICAgICAgdGhpcy5tZW51SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcG9wdXBTaW5nbGVMYXllcihldmVudCwgbGF5ZXIpIHtcbiAgICAgICAgY29uc3QgJHRoaXMgPSB0aGlzO1xuICAgICAgICBjb25zdCBtYXAgPSAkdGhpcy5tYXA7XG4gICAgICAgIGNvbnN0IGxheWVyTmFtZSA9IGAke2xheWVyLm5hbWV9LWhpZ2hsaWdodGVkYDtcblxuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHNoYXBlIGZhbGxzIHVuZGVyIGN1cnJlbnQgbGVnZW5kIHNlbGVjdGlvblxuICAgICAgICBsZXQgaW5DdXJyZW50U2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgbGV0IGNvbHVtbkZpbHRlciA9IGV2ZW50LmZlYXR1cmVzWzBdLnByb3BlcnRpZXNbbGF5ZXIubGVnZW5kQ29sdW1uXTtcblxuICAgICAgICBpZiAoISR0aGlzLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoY29sdW1uRmlsdGVyKSlcbiAgICAgICAgICBpbkN1cnJlbnRTZWxlY3Rpb24gPSBmYWxzZTtcblxuICAgICAgICBjb25zdCBwb3B1cCA9IG5ldyBtYXBib3hnbC5Qb3B1cCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0TG5nTGF0KGV2ZW50LmxuZ0xhdClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRIVE1MKGV2ZW50LmZlYXR1cmVzWzBdLnByb3BlcnRpZXNbbGF5ZXIuZmlsdGVyQnldKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZFRvKG1hcCk7XG5cbiAgICAgICAgaWYgKHBvcHVwLmlzT3BlbigpKSB7XG4gICAgICAgICAgJHRoaXMubWFwUG9wdXAgPSBwb3B1cDtcblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBsZWdlbmQgaXRlbXMgc2VsZWN0ZWQsIGhpZ2hsaWdodCBzZWxlY3RlZCBtYXAgc2hhcGVcbiAgICAgICAgICBpZiAoISR0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJOYW1lLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgJHRoaXMubWFwRmlsdGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbGVnZW5kIGl0ZW1zIHNlbGVjdGVkIGFuZCBzZWxlY3RlZCBtYXAgc2hhcGUgaXNuJ3RcbiAgICAgICAgICAvLyB3aXRoaW4gYW55IG9mIHRoZSBzZWxlY3RlZCBsZWdlbmQgaXRlbXMsIGhpZ2hsaWdodCBzZWxlY3RlZFxuICAgICAgICAgIC8vIG1hcCBzaGFwZSBhbmQgY2xlYXIgbGVnZW5kXG4gICAgICAgICAgaWYgKCR0aGlzLnNlbGVjdGVkSXRlbXMubGVuZ3RoID4gMCAmJiAhaW5DdXJyZW50U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBtYXAuc2V0TGF5b3V0UHJvcGVydHkobGF5ZXJOYW1lLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgJHRoaXMubWFwRmlsdGVyKTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgYWxsIGNoZWNrZWQgbGVnZW5kIGl0ZW1zXG4gICAgICAgICAgICAkdGhpcy5zZWxlY3RlZEl0ZW1zID0gW107XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJHcm91cElucHV0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuY29uZmlnLmxlZ2VuZElkKS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dDpjaGVja2VkJyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyR3JvdXBJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZmlsdGVyR3JvdXBJbnB1dHNbaV0uY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBvcHVwLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyByZXNldCBhc3NvY2lhdGVkIHN0YXRlcyB3aGVuIHBvcHVwIGRpc21pc3NlZCB3aGlsZSBhY3RpdmVcbiAgICAgICAgICBpZiAoJHRoaXMubWFwUG9wdXAgPT09IHBvcHVwKSB7XG4gICAgICAgICAgICAkdGhpcy5tYXBQb3B1cCA9IG51bGw7XG4gICAgICAgICAgICAkdGhpcy5tYXBGaWx0ZXIgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbGVnZW5kIGl0ZW1zIHNlbGVjdGVkLCByZXNldCBhbGwgZmlsdGVyc1xuICAgICAgICAgICAgaWYgKCEkdGhpcy5zZWxlY3RlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXAuc2V0RmlsdGVyKGxheWVyTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICAgIG1hcC5zZXRMYXlvdXRQcm9wZXJ0eShsYXllck5hbWUsICd2aXNpYmlsaXR5JywgJ25vbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZpbHRlclNpbmdsZUxheWVyKGxheWVyKSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gdGhpcztcbiAgICAgICAgY29uc3QgbWFwID0gJHRoaXMubWFwO1xuXG4gICAgICAgIG1hcC5vbignY2xpY2snLCBsYXllci5uYW1lLCAoZSkgPT4ge1xuICAgICAgICAgIC8vIHNldCBiYm94IGFzIHJlYWN0YW5nbGUgYXJlYSBhcm91bmQgY2xpY2tlZCBwb2ludFxuICAgICAgICAgIGxldCBiYm94ID0gW1tlLnBvaW50LngsIGUucG9pbnQueV0sIFtlLnBvaW50LngsIGUucG9pbnQueV1dO1xuICAgICAgICAgIGxldCBmZWF0dXJlcyA9IG1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoYmJveCwgeyBsYXllcnM6IFtsYXllci5uYW1lXSB9KTtcbiAgICAgICAgICBsZXQgbGVnZW5kQ29sdW1uVmFsdWUgPSBudWxsO1xuXG4gICAgICAgICAgY29uc3QgZmlsdGVyID0gZmVhdHVyZXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIGZlYXR1cmUpIHtcbiAgICAgICAgICAgIGxlZ2VuZENvbHVtblZhbHVlID0gZmVhdHVyZS5wcm9wZXJ0aWVzW2xheWVyLmxlZ2VuZENvbHVtbl07XG4gICAgICAgICAgICBtZW1vLnB1c2goZmVhdHVyZS5wcm9wZXJ0aWVzW2xheWVyLmZpbHRlckJ5XSk7XG4gICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICB9LCBbJ2luJywgYCR7bGF5ZXIuZmlsdGVyQnl9YF0pO1xuXG4gICAgICAgICAgJHRoaXMubWFwRmlsdGVyID0gZmlsdGVyO1xuICAgICAgICAgICR0aGlzLmluaXRpYWxpemVQb3B1cChlLCBsYXllcik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZVNpbmdsZUxheWVyKGZpbHRlcnNUb1RvZ2dsZSkge1xuICAgICAgICBjb25zdCAkdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1hcCA9ICR0aGlzLm1hcDtcbiAgICAgICAgY29uc3QgZmlsdGVyR3JvdXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmNvbmZpZy5sZWdlbmRJZCk7XG5cbiAgICAgICAgY29uc3QgbGF5ZXIgPSAkdGhpcy5sYXllcnNbMF07XG4gICAgICAgIGNvbnN0IGxlZ2VuZENvbHVtbiA9IGxheWVyLmxlZ2VuZENvbHVtbjtcblxuICAgICAgICAvLyBjbGVhciBhbGwgbGlua3MgYmVmb3JlIGFwcGVuZGluZyBuZXcgb25lcyB0byBwcmV2ZW50IGR1cGxpY2F0ZXNcbiAgICAgICAgd2hpbGUgKGZpbHRlckdyb3VwLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBmaWx0ZXJHcm91cC5yZW1vdmVDaGlsZChmaWx0ZXJHcm91cC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluaXRpbGl6ZSBhbiBpbnB1dCBlbGVtZW50IGZvciBlYWNoIGZpbHRlciB0eXBlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyc1RvVG9nZ2xlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGF5ZXJSZWYgPSBmaWx0ZXJzVG9Ub2dnbGVbaV07XG5cbiAgICAgICAgICAvLyBjaGVja2JveFxuICAgICAgICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICBpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgICBpbnB1dC5pZCA9IGxheWVyUmVmO1xuICAgICAgICAgIGlucHV0LnZhbHVlID0gbGF5ZXJSZWY7XG4gICAgICAgICAgZmlsdGVyR3JvdXAuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXG4gICAgICAgICAgLy8gY2hlY2tib3ggbGFiZWxcbiAgICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCBsYXllclJlZik7XG4gICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGxheWVyUmVmKTtcbiAgICAgICAgICBsYWJlbC50ZXh0Q29udGVudCA9IGxheWVyUmVmO1xuICAgICAgICAgIGZpbHRlckdyb3VwLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgICAgICAgIC8vIHdoZW4gdGhlIGNoZWNrYm94IGNoYW5nZXMgc3RhdGUsIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgaXRlbXMgYXJyYXkuXG4gICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGUudGFyZ2V0LnZhbHVlO1xuXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgY2hlY2tib3hlcyBjaGVja2VkIHN0YXRlXG4gICAgICAgICAgICBlLnRhcmdldC5jaGVja2VkID8gJ3Zpc2libGUnIDogJ25vbmUnO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgcG9wdXAgaWYgb25lIGV4aXN0c1xuICAgICAgICAgICAgaWYgKCR0aGlzLm1hcFBvcHVwKVxuICAgICAgICAgICAgICAkdGhpcy5tYXBQb3B1cC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNoZWNrZWQgJiYgISR0aGlzLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbSkpXG4gICAgICAgICAgICAgICR0aGlzLnNlbGVjdGVkSXRlbXMucHVzaChpdGVtKTtcblxuICAgICAgICAgICAgaWYgKCFlLnRhcmdldC5jaGVja2VkICYmICR0aGlzLnNlbGVjdGVkSXRlbXMuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgJHRoaXMuc2VsZWN0ZWRJdGVtcyA9ICR0aGlzLnNlbGVjdGVkSXRlbXMuZmlsdGVyKCh2YWwpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsICE9PSBpdGVtO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbjwvc2NyaXB0PiIsIi8qKlxuICogQ29uZmlnXG4gKi9cblxuY29uc3Qgbnljb0NvbG9ycyA9IHtcbiAgY29sb3JzOiB7XG4gICAgJ3ByaW1hcnktbmF2eSc6ICcjMkYzMzRGJyxcbiAgICAncHJpbWFyeS1uYXZ5LTcwdCc6ICcjNkU3MDg1JyxcbiAgICAncHJpbWFyeS1uYXZ5LTUwdCc6ICcjOTY5OEE3JyxcbiAgICAncHJpbWFyeS1uYXZ5LTMwdCc6ICcjQzBDMkNBJyxcbiAgICAncHJpbWFyeS1ibHVlJzogJyMzMTU1QTYnLFxuICAgICdwcmltYXJ5LWJsdWUtNzB0JzogJyM2Qzg4QzEnLFxuICAgICdwcmltYXJ5LWJsdWUtNTB0JzogJyM5NkFCRDInLFxuICAgICdwcmltYXJ5LWJsdWUtMzB0JzogJyNDMENDRTMnLFxuICAgICdwcmltYXJ5LXJlZCc6ICcjRjI2OTVEJyxcbiAgICAncHJpbWFyeS1yZWQtNzB0JzogJyNGNjk1OEQnLFxuICAgICdwcmltYXJ5LXJlZC01MHQnOiAnI0Y4QjJBRCcsXG4gICAgJ3ByaW1hcnktcmVkLTMwdCc6ICcjRkJEMUNFJyxcbiAgICAnc2Vjb25kYXJ5LWdyZXknOiAnI0FDQUVCOScsXG4gICAgJ3NlY29uZGFyeS1ncmV5LTcwdCc6ICcjQzRDNkNEJyxcbiAgICAnc2Vjb25kYXJ5LWdyZXktNTB0JzogJyNENUQ2REMnLFxuICAgICdzZWNvbmRhcnktZ3JleS0zMHQnOiAnI0U4RTdFOScsXG4gICAgJ3NlY29uZGFyeS13aGl0ZSc6ICcjRjNGM0YzJyxcbiAgICAnc2Vjb25kYXJ5LXdoaXRlLTcwdCc6ICcjRjZGNkY2JyxcbiAgICAnc2Vjb25kYXJ5LXdoaXRlLTUwdCc6ICcjRjlGOUZBJyxcbiAgICAnc2Vjb25kYXJ5LXdoaXRlLTMwdCc6ICcjRkJGQ0ZDJyxcbiAgICAnc2Vjb25kYXJ5LW9yYW5nZSc6ICcjRjlBMTM3JyxcbiAgICAnc2Vjb25kYXJ5LW9yYW5nZS03MHQnOiAnI0ZGQTEzMycsXG4gICAgJ3NlY29uZGFyeS1vcmFuZ2UtNTB0JzogJyNGRUQwOUEnLFxuICAgICdzZWNvbmRhcnktb3JhbmdlLTMwdCc6ICcjRkZFM0MyJyxcbiAgICAnc2Vjb25kYXJ5LXBpbmsnOiAnI0VCQkNEOCcsXG4gICAgJ3NlY29uZGFyeS1waW5rLTcwdCc6ICcjRjJEMEUzJyxcbiAgICAnc2Vjb25kYXJ5LXBpbmstNTB0JzogJyNGN0RERUInLFxuICAgICdzZWNvbmRhcnktcGluay0zMHQnOiAnI0ZERUJGMycsXG4gICAgJ2Jhc2UtYmxhY2snOiAnIzAwMDAwMCcsXG4gICAgJ2Jhc2Utd2hpdGUnOiAnI0ZGRkZGRidcbiAgfSxcbiAgY29sb3JDb21iaW5hdGlvbnM6IHtcbiAgICAnbGlnaHQtYmFja2dyb3VuZCc6IHtcbiAgICAgICdjb2xvcic6ICdiYXNlLWJsYWNrJyxcbiAgICAgICdoZWFkaW5ncyc6ICdwcmltYXJ5LW5hdnknLFxuICAgICAgJ2h5cGVybGlua3MnOiAncHJpbWFyeS1ibHVlJyxcbiAgICAgICd2aXNpdGVkJzogJ3ByaW1hcnktYmx1ZScsXG4gICAgICAnaG92ZXInOiAncHJpbWFyeS1uYXZ5JyxcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJ2Jhc2Utd2hpdGUnLFxuICAgICAgJ2JvcmRlcic6ICdzZWNvbmRhcnktZ3JleScsXG4gICAgICAncGxhY2Vob2xkZXInOiAnc2Vjb25kYXJ5LWdyZXknLFxuICAgICAgJ2NoZWNrYm94LWJhY2tncm91bmQnOiAncHJpbWFyeS1uYXZ5JyxcbiAgICAgICdlcnJvcic6ICdwcmltYXJ5LXJlZCcsXG4gICAgfSxcbiAgICAnbWlkLWJhY2tncm91bmQnOiB7XG4gICAgICAnY29sb3InOiAnYmFzZS1ibGFjaycsXG4gICAgICAnaGVhZGluZ3MnOiAncHJpbWFyeS1uYXZ5JyxcbiAgICAgICdoeXBlcmxpbmtzJzogJ3ByaW1hcnktYmx1ZScsXG4gICAgICAndmlzaXRlZCc6ICdwcmltYXJ5LWJsdWUnLFxuICAgICAgJ2hvdmVyJzogJ3ByaW1hcnktbmF2eScsXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICdzZWNvbmRhcnktd2hpdGUnXG4gICAgfSxcbiAgICAnZGFyay1iYWNrZ3JvdW5kJzoge1xuICAgICAgJ2NvbG9yJzogJ2Jhc2Utd2hpdGUnLFxuICAgICAgJ2ZvbnQtc21vb3RoJzogdHJ1ZSxcbiAgICAgICdoZWFkaW5ncyc6ICdiYXNlLXdoaXRlJyxcbiAgICAgICdoeXBlcmxpbmtzJzogJ2Jhc2Utd2hpdGUnLFxuICAgICAgJ3Zpc2l0ZWQnOiAnYmFzZS13aGl0ZScsXG4gICAgICAnaG92ZXInOiAnYmFzZS13aGl0ZScsXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICdwcmltYXJ5LW5hdnknXG4gICAgfSxcbiAgICAncHJpbWFyeS1idXR0b24nOiB7XG4gICAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXG4gICAgICAnY29sb3InOiAnYmFzZS13aGl0ZScsXG4gICAgICAnZm9udC1zbW9vdGgnOiB0cnVlLFxuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAncHJpbWFyeS1ibHVlJ1xuICAgIH0sXG4gICAgJ3NlY29uZGFyeS1idXR0b24nOiB7XG4gICAgICAnZm9udC13ZWlnaHQnOiAnYm9sZCcsXG4gICAgICAnY29sb3InOiAnYmFzZS13aGl0ZScsXG4gICAgICAnZm9udC1zbW9vdGgnOiB0cnVlLFxuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAncHJpbWFyeS1yZWQnXG4gICAgfVxuICB9LFxufTtcblxuY29uc3QgY29sb3IgPSBueWNvQ29sb3JzLmNvbG9ycztcbmNvbnN0IG1hcENvbG9yQ29tYmluYXRpb25zID0gW1xuICBbY29sb3JbJ3ByaW1hcnktbmF2eSddLCBjb2xvclsncHJpbWFyeS1uYXZ5LTcwdCddXSxcbiAgW2NvbG9yWydiYXNlLWJsYWNrJ10sIGNvbG9yWydzZWNvbmRhcnktb3JhbmdlJ11dLFxuICBbY29sb3JbJ3ByaW1hcnktbmF2eSddLCBjb2xvclsnc2Vjb25kYXJ5LWdyZXknXV0sXG4gIFtjb2xvclsncHJpbWFyeS1ibHVlJ10sIGNvbG9yWydzZWNvbmRhcnktb3JhbmdlJ11dLFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG55Y29Db2xvcnMsXG4gIG1hcENvbG9yQ29tYmluYXRpb25zXG59OyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgbWFwQ29sb3JDb21iaW5hdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9jb25maWcvY29sb3JzJztcblxuY29uc3QgTWFwRGF0YSA9IHtcbiAgc2luZ2xlOiB7XG4gICAgbGF5ZXJzOiBbXSxcbiAgICBjb25maWc6IHtcbiAgICAgIEFQSUtleTogJ3BrLmV5SjFJam9pYm5samJ5MXdjbTlrZFdOMGN5SXNJbUVpT2lKamFuWmpaM1k0YjJJeE5YWXdNM2wwWkRONmJXTjRhakE1SW4wLlhTdC1ob3o1cDNqMnNpeWxpMGcwb2cnLFxuICAgICAgY29udGFpbmVySWQ6ICdueWNvLW1hcC1zbCcsXG4gICAgICBsZWdlbmRJZDogJ255Y28tbWFwLWxlZ2VuZCcsXG4gICAgICBjZW50ZXI6IFstNzMuOTg2NzEwLCA0MC42OTMzOTFdLFxuICAgICAgem9vbTogOSxcbiAgICAgIGRpc2FibGVTY3JvbGw6IHRydWUsXG4gICAgICBzdHlsZTogJ21hcGJveDovL3N0eWxlcy9ueWNvLXByb2R1Y3RzL2NqdjZ3anE4ODEyeXMxZ3AzOW1udnVrMncnLFxuICAgICAgbWFwVHlwZTogJ3NpbmdsZSdcbiAgICB9XG4gIH0sXG4gIG11bHRpOiB7XG4gICAgbGF5ZXJzOiBbXSxcbiAgICBjb25maWc6IHtcbiAgICAgIEFQSUtleTogJ3BrLmV5SjFJam9pYm5samJ5MXdjbTlrZFdOMGN5SXNJbUVpT2lKamFuWmpaM1k0YjJJeE5YWXdNM2wwWkRONmJXTjRhakE1SW4wLlhTdC1ob3o1cDNqMnNpeWxpMGcwb2cnLFxuICAgICAgY29udGFpbmVySWQ6ICdueWNvLW1hcC1tbCcsXG4gICAgICBsZWdlbmRJZDogJ255Y28tbWFwLW1lbnUnLFxuICAgICAgY2VudGVyOiBbLTczLjk4NjcxMCwgNDAuNjkzMzkxXSxcbiAgICAgIHpvb206IDksXG4gICAgICBkaXNhYmxlU2Nyb2xsOiB0cnVlLFxuICAgICAgc3R5bGU6ICdtYXBib3g6Ly9zdHlsZXMvbnljby1wcm9kdWN0cy9janY2d2pxODgxMnlzMWdwMzltbnZ1azJ3JyxcbiAgICAgIG1hcFR5cGU6ICdtdWx0aScsXG4gICAgICBjb2xvcnM6IG1hcENvbG9yQ29tYmluYXRpb25zXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hcERhdGE7IiwiKGZ1bmN0aW9uKEdlb0pTT04pIHtcbiAgR2VvSlNPTi52ZXJzaW9uID0gJzAuNS4wJztcblxuICAvLyBBbGxvdyB1c2VyIHRvIHNwZWNpZnkgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gIEdlb0pTT04uZGVmYXVsdHMgPSB7XG4gICAgZG9UaHJvd3M6IHtcbiAgICAgIGludmFsaWRHZW9tZXRyeTogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSW52YWxpZEdlb21ldHJ5RXJyb3IoKSB7XG4gICAgdmFyIGFyZ3MgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICB2YXIgaXRlbSA9IGFyZ3Muc2hpZnQoKTtcbiAgICB2YXIgcGFyYW1zID0gYXJncy5zaGlmdCgpO1xuXG4gICAgRXJyb3IuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5tZXNzYWdlIHx8IFwiSW52YWxpZCBHZW9tZXRyeTogXCIgKyAnaXRlbTogJyArIEpTT04uc3RyaW5naWZ5KGl0ZW0pICsgJywgcGFyYW1zOiAnICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgfVxuXG4gIEludmFsaWRHZW9tZXRyeUVycm9yLnByb3RvdHlwZSA9IEVycm9yO1xuXG5cbiAgR2VvSlNPTi5lcnJvcnMgPSB7XG4gICAgSW52YWxpZEdlb21ldHJ5RXJyb3I6IEludmFsaWRHZW9tZXRyeUVycm9yXG4gIH07XG5cbiAgLy9leHBvc2luZyBzbyB0aGlzIGNhbiBiZSBvdmVycmlkZW4gbWF5YmUgYnkgZ2VvanNvbi12YWxpZGF0aW9uIG9yIHRoZSBsaWtlXG4gIEdlb0pTT04uaXNHZW9tZXRyeVZhbGlkID0gZnVuY3Rpb24oZ2VvbWV0cnkpe1xuICAgIGlmKCFnZW9tZXRyeSB8fCAhT2JqZWN0LmtleXMoZ2VvbWV0cnkpLmxlbmd0aClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiAhIWdlb21ldHJ5LnR5cGUgJiYgISFnZW9tZXRyeS5jb29yZGluYXRlcyAmJiBBcnJheS5pc0FycmF5KGdlb21ldHJ5LmNvb3JkaW5hdGVzKSAmJiAhIWdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgfTtcblxuICAvLyBUaGUgb25lIGFuZCBvbmx5IHB1YmxpYyBmdW5jdGlvbi5cbiAgLy8gQ29udmVydHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgR2VvSlNPTiBmZWF0dXJlIGNvbGxlY3Rpb25cbiAgR2VvSlNPTi5wYXJzZSA9IGZ1bmN0aW9uKG9iamVjdHMsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgZ2VvanNvbixcbiAgICAgICAgc2V0dGluZ3MgPSBhcHBseURlZmF1bHRzKHBhcmFtcywgdGhpcy5kZWZhdWx0cyksXG4gICAgICAgIHByb3BGdW5jO1xuXG4gICAgZ2VvbUF0dHJzLmxlbmd0aCA9IDA7IC8vIFJlc2V0IHRoZSBsaXN0IG9mIGdlb21ldHJ5IGZpZWxkc1xuICAgIHNldEdlb20oc2V0dGluZ3MpO1xuICAgIHByb3BGdW5jID0gZ2V0UHJvcEZ1bmN0aW9uKHNldHRpbmdzKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdHMpKSB7XG4gICAgICBnZW9qc29uID0ge1widHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsIFwiZmVhdHVyZXNcIjogW119O1xuICAgICAgb2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pe1xuICAgICAgICBnZW9qc29uLmZlYXR1cmVzLnB1c2goZ2V0RmVhdHVyZSh7aXRlbTppdGVtLCBwYXJhbXM6IHNldHRpbmdzLCBwcm9wRnVuYzpwcm9wRnVuY30pKTtcbiAgICAgIH0pO1xuICAgICAgYWRkT3B0aW9uYWxzKGdlb2pzb24sIHNldHRpbmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VvanNvbiA9IGdldEZlYXR1cmUoe2l0ZW06b2JqZWN0cywgcGFyYW1zOiBzZXR0aW5ncywgcHJvcEZ1bmM6cHJvcEZ1bmN9KTtcbiAgICAgIGFkZE9wdGlvbmFscyhnZW9qc29uLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2soZ2VvanNvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZW9qc29uO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb25zXG4gIHZhciBnZW9tcyA9IFsnUG9pbnQnLCAnTXVsdGlQb2ludCcsICdMaW5lU3RyaW5nJywgJ011bHRpTGluZVN0cmluZycsICdQb2x5Z29uJywgJ011bHRpUG9seWdvbicsICdHZW9KU09OJ10sXG4gICAgICBnZW9tQXR0cnMgPSBbXTtcblxuICAvLyBBZGRzIGRlZmF1bHQgc2V0dGluZ3MgdG8gdXNlci1zcGVjaWZpZWQgcGFyYW1zXG4gIC8vIERvZXMgbm90IG92ZXJ3cml0ZSBhbnkgc2V0dGluZ3MtLW9ubHkgYWRkcyBkZWZhdWx0c1xuICAvLyB0aGUgdGhlIHVzZXIgZGlkIG5vdCBzcGVjaWZ5XG4gIGZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMocGFyYW1zLCBkZWZhdWx0cykge1xuICAgIHZhciBzZXR0aW5ncyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIGZvcih2YXIgc2V0dGluZyBpbiBkZWZhdWx0cykge1xuICAgICAgaWYoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoc2V0dGluZykgJiYgIXNldHRpbmdzW3NldHRpbmddKSB7XG4gICAgICAgIHNldHRpbmdzW3NldHRpbmddID0gZGVmYXVsdHNbc2V0dGluZ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldHRpbmdzO1xuICB9XG5cbiAgLy8gQWRkcyB0aGUgb3B0aW9uYWwgR2VvSlNPTiBwcm9wZXJ0aWVzIGNycyBhbmQgYmJveFxuICAvLyBpZiB0aGV5IGhhdmUgYmVlbiBzcGVjaWZpZWRcbiAgZnVuY3Rpb24gYWRkT3B0aW9uYWxzKGdlb2pzb24sIHNldHRpbmdzKXtcbiAgICBpZihzZXR0aW5ncy5jcnMgJiYgY2hlY2tDUlMoc2V0dGluZ3MuY3JzKSkge1xuICAgICAgaWYoc2V0dGluZ3MuaXNQb3N0Z3JlcylcbiAgICAgICAgZ2VvanNvbi5nZW9tZXRyeS5jcnMgPSBzZXR0aW5ncy5jcnM7XG4gICAgICBlbHNlXG4gICAgICAgIGdlb2pzb24uY3JzID0gc2V0dGluZ3MuY3JzO1xuICAgIH1cbiAgICBpZiAoc2V0dGluZ3MuYmJveCkge1xuICAgICAgZ2VvanNvbi5iYm94ID0gc2V0dGluZ3MuYmJveDtcbiAgICB9XG4gICAgaWYgKHNldHRpbmdzLmV4dHJhR2xvYmFsKSB7XG4gICAgICBnZW9qc29uLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzZXR0aW5ncy5leHRyYUdsb2JhbCkge1xuICAgICAgICBnZW9qc29uLnByb3BlcnRpZXNba2V5XSA9IHNldHRpbmdzLmV4dHJhR2xvYmFsW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIHN0cnVjdHVyZSBvZiBDUlMgb2JqZWN0IGlzIHZhbGlkXG4gIGZ1bmN0aW9uIGNoZWNrQ1JTKGNycykge1xuICAgIGlmIChjcnMudHlwZSA9PT0gJ25hbWUnKSB7XG4gICAgICAgIGlmIChjcnMucHJvcGVydGllcyAmJiBjcnMucHJvcGVydGllcy5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDUlMuIFByb3BlcnRpZXMgbXVzdCBjb250YWluIFwibmFtZVwiIGtleScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChjcnMudHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgIGlmIChjcnMucHJvcGVydGllcyAmJiBjcnMucHJvcGVydGllcy5ocmVmICYmIGNycy5wcm9wZXJ0aWVzLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENSUy4gUHJvcGVydGllcyBtdXN0IGNvbnRhaW4gXCJocmVmXCIgYW5kIFwidHlwZVwiIGtleScpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGQgQ1JTLiBUeXBlIGF0dHJpYnV0ZSBtdXN0IGJlIFwibmFtZVwiIG9yIFwibGlua1wiJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gTW92ZXMgdGhlIHVzZXItc3BlY2lmaWVkIGdlb21ldHJ5IHBhcmFtZXRlcnNcbiAgLy8gdW5kZXIgdGhlIGBnZW9tYCBrZXkgaW4gcGFyYW0gZm9yIGVhc2llciBhY2Nlc3NcbiAgZnVuY3Rpb24gc2V0R2VvbShwYXJhbXMpIHtcbiAgICBwYXJhbXMuZ2VvbSA9IHt9O1xuXG4gICAgZm9yKHZhciBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICAgIGlmKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbSkgJiYgZ2VvbXMuaW5kZXhPZihwYXJhbSkgIT09IC0xKXtcbiAgICAgICAgcGFyYW1zLmdlb21bcGFyYW1dID0gcGFyYW1zW3BhcmFtXTtcbiAgICAgICAgZGVsZXRlIHBhcmFtc1twYXJhbV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0R2VvbUF0dHJMaXN0KHBhcmFtcy5nZW9tKTtcbiAgfVxuXG4gIC8vIEFkZHMgZmllbGRzIHdoaWNoIGNvbnRhaW4gZ2VvbWV0cnkgZGF0YVxuICAvLyB0byBnZW9tQXR0cnMuIFRoaXMgbGlzdCBpcyB1c2VkIHdoZW4gYWRkaW5nXG4gIC8vIHByb3BlcnRpZXMgdG8gdGhlIGZlYXR1cmVzIHNvIHRoYXQgbm8gZ2VvbWV0cnlcbiAgLy8gZmllbGRzIGFyZSBhZGRlZCB0aGUgcHJvcGVydGllcyBrZXlcbiAgZnVuY3Rpb24gc2V0R2VvbUF0dHJMaXN0KHBhcmFtcykge1xuICAgIGZvcih2YXIgcGFyYW0gaW4gcGFyYW1zKSB7XG4gICAgICBpZihwYXJhbXMuaGFzT3duUHJvcGVydHkocGFyYW0pKSB7XG4gICAgICAgIGlmKHR5cGVvZiBwYXJhbXNbcGFyYW1dID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGdlb21BdHRycy5wdXNoKHBhcmFtc1twYXJhbV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXNbcGFyYW1dID09PSAnb2JqZWN0JykgeyAvLyBBcnJheSBvZiBjb29yZGluYXRlcyBmb3IgUG9pbnRcbiAgICAgICAgICBnZW9tQXR0cnMucHVzaChwYXJhbXNbcGFyYW1dWzBdKTtcbiAgICAgICAgICBnZW9tQXR0cnMucHVzaChwYXJhbXNbcGFyYW1dWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGdlb21BdHRycy5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdObyBnZW9tZXRyeSBhdHRyaWJ1dGVzIHNwZWNpZmllZCcpOyB9XG4gIH1cblxuICAvLyBDcmVhdGVzIGEgZmVhdHVyZSBvYmplY3QgdG8gYmUgYWRkZWRcbiAgLy8gdG8gdGhlIEdlb0pTT04gZmVhdHVyZXMgYXJyYXlcbiAgZnVuY3Rpb24gZ2V0RmVhdHVyZShhcmdzKSB7XG4gICAgdmFyIGl0ZW0gPSBhcmdzLml0ZW0sXG4gICAgICBwYXJhbXMgPSBhcmdzLnBhcmFtcyxcbiAgICAgIHByb3BGdW5jID0gYXJncy5wcm9wRnVuYztcblxuICAgIHZhciBmZWF0dXJlID0geyBcInR5cGVcIjogXCJGZWF0dXJlXCIgfTtcblxuICAgIGZlYXR1cmUuZ2VvbWV0cnkgPSBidWlsZEdlb20oaXRlbSwgcGFyYW1zKTtcbiAgICBmZWF0dXJlLnByb3BlcnRpZXMgPSBwcm9wRnVuYy5jYWxsKGl0ZW0pO1xuXG4gICAgcmV0dXJuIGZlYXR1cmU7XG4gIH1cblxuICBmdW5jdGlvbiBpc05lc3RlZCh2YWwpe1xuICAgIHJldHVybiAoL14uK1xcLi4rJC8udGVzdCh2YWwpKTtcbiAgfVxuXG4gIC8vIEFzc2VtYmxlcyB0aGUgYGdlb21ldHJ5YCBwcm9wZXJ0eVxuICAvLyBmb3IgdGhlIGZlYXR1cmUgb3V0cHV0XG4gIGZ1bmN0aW9uIGJ1aWxkR2VvbShpdGVtLCBwYXJhbXMpIHtcbiAgICB2YXIgZ2VvbSA9IHt9LFxuICAgICAgICBhdHRyO1xuXG4gICAgZm9yKHZhciBndHlwZSBpbiBwYXJhbXMuZ2VvbSkge1xuICAgICAgdmFyIHZhbCA9IHBhcmFtcy5nZW9tW2d0eXBlXTtcblxuICAgICAgLy8gR2VvbWV0cnkgcGFyYW1ldGVyIHNwZWNpZmllZCBhczoge1BvaW50OiAnY29vcmRzJ31cbiAgICAgIGlmKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIGl0ZW0uaGFzT3duUHJvcGVydHkodmFsKSkge1xuICAgICAgICBpZihndHlwZSA9PT0gJ0dlb0pTT04nKSB7XG4gICAgICAgICAgZ2VvbSA9IGl0ZW1bdmFsXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW9tLnR5cGUgPSBndHlwZTtcbiAgICAgICAgICBnZW9tLmNvb3JkaW5hdGVzID0gaXRlbVt2YWxdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIEhhbmRsZSB0aGluZ3MgbGlrZTpcbiAgICAgIFBvbHlnb246IHtcbiAgICAgICAgbm9ydGhlYXN0OiBbJ2xhdCcsICdsbmcnXSxcbiAgICAgICAgc291dGh3ZXN0OiBbJ2xhdCcsICdsbmcnXVxuICAgICAgfVxuICAgICAgKi9cbiAgICAgIGVsc2UgaWYodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAvKmpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuICAgICAgICB2YXIgcG9pbnRzID0gT2JqZWN0LmtleXModmFsKS5tYXAoZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgICB2YXIgb3JkZXIgPSB2YWxba2V5XTtcbiAgICAgICAgICB2YXIgbmV3SXRlbSA9IGl0ZW1ba2V5XTtcbiAgICAgICAgICByZXR1cm4gYnVpbGRHZW9tKG5ld0l0ZW0sIHtnZW9tOnsgUG9pbnQ6IG9yZGVyfX0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2VvbS50eXBlID0gZ3R5cGU7XG4gICAgICAgIC8qanNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgICAgIGdlb20uY29vcmRpbmF0ZXMgPSBbXS5jb25jYXQocG9pbnRzLm1hcChmdW5jdGlvbihwKXtcbiAgICAgICAgICByZXR1cm4gcC5jb29yZGluYXRlcztcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZW9tZXRyeSBwYXJhbWV0ZXIgc3BlY2lmaWVkIGFzOiB7UG9pbnQ6IFsnbGF0JywgJ2xuZyddfVxuICAgICAgZWxzZSBpZihBcnJheS5pc0FycmF5KHZhbCkgJiYgaXRlbS5oYXNPd25Qcm9wZXJ0eSh2YWxbMF0pICYmIGl0ZW0uaGFzT3duUHJvcGVydHkodmFsWzFdKSl7XG4gICAgICAgIGdlb20udHlwZSA9IGd0eXBlO1xuICAgICAgICBnZW9tLmNvb3JkaW5hdGVzID0gW051bWJlcihpdGVtW3ZhbFsxXV0pLCBOdW1iZXIoaXRlbVt2YWxbMF1dKV07XG4gICAgICB9XG5cbiAgICAgIC8vIEdlb21ldHJ5IHBhcmFtZXRlciBzcGVjaWZpZWQgYXM6IHtQb2ludDogWydjb250YWluZXIubGF0JywgJ2NvbnRhaW5lci5sbmcnXX1cbiAgICAgIGVsc2UgaWYoQXJyYXkuaXNBcnJheSh2YWwpICYmIGlzTmVzdGVkKHZhbFswXSkgJiYgaXNOZXN0ZWQodmFsWzFdKSl7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1x0Ly8gaS5lLiAwIGFuZCAxXG4gICAgICAgICAgdmFyIHBhdGhzID0gdmFsW2ldLnNwbGl0KCcuJyk7XG4gICAgICAgICAgdmFyIGl0ZW1DbG9uZSA9IGl0ZW07XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXRocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCFpdGVtQ2xvbmUuaGFzT3duUHJvcGVydHkocGF0aHNbal0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1DbG9uZSA9IGl0ZW1DbG9uZVtwYXRoc1tqXV07XHQvLyBJdGVyYXRlIGRlZXBlciBpbnRvIHRoZSBvYmplY3RcbiAgICAgICAgICB9XG4gICAgICAgICAgY29vcmRpbmF0ZXNbaV0gPSBpdGVtQ2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbS50eXBlID0gZ3R5cGU7XG4gICAgICAgIGdlb20uY29vcmRpbmF0ZXMgPSBbTnVtYmVyKGNvb3JkaW5hdGVzWzFdKSwgTnVtYmVyKGNvb3JkaW5hdGVzWzBdKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYocGFyYW1zLmRvVGhyb3dzICYmIHBhcmFtcy5kb1Rocm93cy5pbnZhbGlkR2VvbWV0cnkgJiYgIUdlb0pTT04uaXNHZW9tZXRyeVZhbGlkKGdlb20pKXtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkR2VvbWV0cnlFcnJvcihpdGVtLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIHJldHVybiBnZW9tO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZnVuY3Rpb24gdG8gYmUgdXNlZCB0b1xuICAvLyBidWlsZCB0aGUgcHJvcGVydGllcyBvYmplY3QgZm9yIGVhY2ggZmVhdHVyZVxuICBmdW5jdGlvbiBnZXRQcm9wRnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIGZ1bmM7XG5cbiAgICBpZighcGFyYW1zLmV4Y2x1ZGUgJiYgIXBhcmFtcy5pbmNsdWRlKSB7XG4gICAgICBmdW5jID0gZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICBmb3IodmFyIGF0dHIgaW4gdGhpcykge1xuICAgICAgICAgIGlmKHRoaXMuaGFzT3duUHJvcGVydHkoYXR0cikgJiYgKGdlb21BdHRycy5pbmRleE9mKGF0dHIpID09PSAtMSkpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNbYXR0cl0gPSB0aGlzW2F0dHJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYocGFyYW1zLmluY2x1ZGUpIHtcbiAgICAgIGZ1bmMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHBhcmFtcy5pbmNsdWRlLmZvckVhY2goZnVuY3Rpb24oYXR0cil7XG4gICAgICAgICAgcHJvcGVydGllc1thdHRyXSA9IHRoaXNbYXR0cl07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYocGFyYW1zLmV4Y2x1ZGUpIHtcbiAgICAgIGZ1bmMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGZvcih2YXIgYXR0ciBpbiB0aGlzKSB7XG4gICAgICAgICAgaWYodGhpcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSAmJiAoZ2VvbUF0dHJzLmluZGV4T2YoYXR0cikgPT09IC0xKSAmJiAocGFyYW1zLmV4Y2x1ZGUuaW5kZXhPZihhdHRyKSA9PT0gLTEpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzW2F0dHJdID0gdGhpc1thdHRyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcblxuICAgICAgZnVuYy5jYWxsKHRoaXMsIHByb3BlcnRpZXMpO1xuXG4gICAgICBpZihwYXJhbXMuZXh0cmEpIHsgYWRkRXh0cmEocHJvcGVydGllcywgcGFyYW1zLmV4dHJhKTsgfVxuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfTtcbiAgfVxuXG4gIC8vIEFkZHMgZGF0YSBjb250YWluZWQgaW4gdGhlIGBleHRyYWBcbiAgLy8gcGFyYW1ldGVyIGlmIGl0IGhhcyBiZWVuIHNwZWNpZmllZFxuICBmdW5jdGlvbiBhZGRFeHRyYShwcm9wZXJ0aWVzLCBleHRyYSkge1xuICAgIGZvcih2YXIga2V5IGluIGV4dHJhKXtcbiAgICAgIGlmKGV4dHJhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcHJvcGVydGllc1trZXldID0gZXh0cmFba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuXG59KHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgPyBtb2R1bGUuZXhwb3J0cyA6IHdpbmRvdy5HZW9KU09OID0ge30pKTtcbiIsIm1vZHVsZS5leHBvcnRzLlJBRElVUyA9IDYzNzgxMzc7XG5tb2R1bGUuZXhwb3J0cy5GTEFUVEVOSU5HID0gMS8yOTguMjU3MjIzNTYzO1xubW9kdWxlLmV4cG9ydHMuUE9MQVJfUkFESVVTID0gNjM1Njc1Mi4zMTQyO1xuIiwidmFyIHdnczg0ID0gcmVxdWlyZSgnd2dzODQnKTtcblxubW9kdWxlLmV4cG9ydHMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbm1vZHVsZS5leHBvcnRzLnJpbmcgPSByaW5nQXJlYTtcblxuZnVuY3Rpb24gZ2VvbWV0cnkoXykge1xuICAgIHZhciBhcmVhID0gMCwgaTtcbiAgICBzd2l0Y2ggKF8udHlwZSkge1xuICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAgIHJldHVybiBwb2x5Z29uQXJlYShfLmNvb3JkaW5hdGVzKTtcbiAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJlYSArPSBwb2x5Z29uQXJlYShfLmNvb3JkaW5hdGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmVhO1xuICAgICAgICBjYXNlICdQb2ludCc6XG4gICAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF8uZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZWEgKz0gZ2VvbWV0cnkoXy5nZW9tZXRyaWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcmVhO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9seWdvbkFyZWEoY29vcmRzKSB7XG4gICAgdmFyIGFyZWEgPSAwO1xuICAgIGlmIChjb29yZHMgJiYgY29vcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXJlYSArPSBNYXRoLmFicyhyaW5nQXJlYShjb29yZHNbMF0pKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZWEgLT0gTWF0aC5hYnMocmluZ0FyZWEoY29vcmRzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZWE7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBhcHByb3hpbWF0ZSBhcmVhIG9mIHRoZSBwb2x5Z29uIHdlcmUgaXQgcHJvamVjdGVkIG9udG9cbiAqICAgICB0aGUgZWFydGguICBOb3RlIHRoYXQgdGhpcyBhcmVhIHdpbGwgYmUgcG9zaXRpdmUgaWYgcmluZyBpcyBvcmllbnRlZFxuICogICAgIGNsb2Nrd2lzZSwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgbmVnYXRpdmUuXG4gKlxuICogUmVmZXJlbmNlOlxuICogUm9iZXJ0LiBHLiBDaGFtYmVybGFpbiBhbmQgV2lsbGlhbSBILiBEdXF1ZXR0ZSwgXCJTb21lIEFsZ29yaXRobXMgZm9yXG4gKiAgICAgUG9seWdvbnMgb24gYSBTcGhlcmVcIiwgSlBMIFB1YmxpY2F0aW9uIDA3LTAzLCBKZXQgUHJvcHVsc2lvblxuICogICAgIExhYm9yYXRvcnksIFBhc2FkZW5hLCBDQSwgSnVuZSAyMDA3IGh0dHA6Ly90cnMtbmV3LmpwbC5uYXNhLmdvdi9kc3BhY2UvaGFuZGxlLzIwMTQvNDA0MDlcbiAqXG4gKiBSZXR1cm5zOlxuICoge2Zsb2F0fSBUaGUgYXBwcm94aW1hdGUgc2lnbmVkIGdlb2Rlc2ljIGFyZWEgb2YgdGhlIHBvbHlnb24gaW4gc3F1YXJlXG4gKiAgICAgbWV0ZXJzLlxuICovXG5cbmZ1bmN0aW9uIHJpbmdBcmVhKGNvb3Jkcykge1xuICAgIHZhciBwMSwgcDIsIHAzLCBsb3dlckluZGV4LCBtaWRkbGVJbmRleCwgdXBwZXJJbmRleCwgaSxcbiAgICBhcmVhID0gMCxcbiAgICBjb29yZHNMZW5ndGggPSBjb29yZHMubGVuZ3RoO1xuXG4gICAgaWYgKGNvb3Jkc0xlbmd0aCA+IDIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvb3Jkc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gY29vcmRzTGVuZ3RoIC0gMikgey8vIGkgPSBOLTJcbiAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gY29vcmRzTGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICBtaWRkbGVJbmRleCA9IGNvb3Jkc0xlbmd0aCAtMTtcbiAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gY29vcmRzTGVuZ3RoIC0gMSkgey8vIGkgPSBOLTFcbiAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gY29vcmRzTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBtaWRkbGVJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpID0gMCB0byBOLTNcbiAgICAgICAgICAgICAgICBsb3dlckluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBtaWRkbGVJbmRleCA9IGkrMTtcbiAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gaSsyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcDEgPSBjb29yZHNbbG93ZXJJbmRleF07XG4gICAgICAgICAgICBwMiA9IGNvb3Jkc1ttaWRkbGVJbmRleF07XG4gICAgICAgICAgICBwMyA9IGNvb3Jkc1t1cHBlckluZGV4XTtcbiAgICAgICAgICAgIGFyZWEgKz0gKCByYWQocDNbMF0pIC0gcmFkKHAxWzBdKSApICogTWF0aC5zaW4oIHJhZChwMlsxXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJlYSA9IGFyZWEgKiB3Z3M4NC5SQURJVVMgKiB3Z3M4NC5SQURJVVMgLyAyO1xuICAgIH1cblxuICAgIHJldHVybiBhcmVhO1xufVxuXG5mdW5jdGlvbiByYWQoXykge1xuICAgIHJldHVybiBfICogTWF0aC5QSSAvIDE4MDtcbn0iLCJ2YXIgZ2VvanNvbkFyZWEgPSByZXF1aXJlKCdAbWFwYm94L2dlb2pzb24tYXJlYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJld2luZDtcblxuZnVuY3Rpb24gcmV3aW5kKGdqLCBvdXRlcikge1xuICAgIHN3aXRjaCAoKGdqICYmIGdqLnR5cGUpIHx8IG51bGwpIHtcbiAgICAgICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZ2ouZmVhdHVyZXMgPSBnai5mZWF0dXJlcy5tYXAoY3VycnlPdXRlcihyZXdpbmQsIG91dGVyKSk7XG4gICAgICAgICAgICByZXR1cm4gZ2o7XG4gICAgICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgICAgICAgZ2ouZ2VvbWV0cnkgPSByZXdpbmQoZ2ouZ2VvbWV0cnksIG91dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBnajtcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgICByZXR1cm4gY29ycmVjdChnaiwgb3V0ZXIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGdqO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3VycnlPdXRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8pIHsgcmV0dXJuIGEoXywgYik7IH07XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3QoXywgb3V0ZXIpIHtcbiAgICBpZiAoXy50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgXy5jb29yZGluYXRlcyA9IGNvcnJlY3RSaW5ncyhfLmNvb3JkaW5hdGVzLCBvdXRlcik7XG4gICAgfSBlbHNlIGlmIChfLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIF8uY29vcmRpbmF0ZXMgPSBfLmNvb3JkaW5hdGVzLm1hcChjdXJyeU91dGVyKGNvcnJlY3RSaW5ncywgb3V0ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIF87XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3RSaW5ncyhfLCBvdXRlcikge1xuICAgIG91dGVyID0gISFvdXRlcjtcbiAgICBfWzBdID0gd2luZChfWzBdLCBvdXRlcik7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9baV0gPSB3aW5kKF9baV0sICFvdXRlcik7XG4gICAgfVxuICAgIHJldHVybiBfO1xufVxuXG5mdW5jdGlvbiB3aW5kKF8sIGRpcikge1xuICAgIHJldHVybiBjdyhfKSA9PT0gZGlyID8gXyA6IF8ucmV2ZXJzZSgpO1xufVxuXG5mdW5jdGlvbiBjdyhfKSB7XG4gICAgcmV0dXJuIGdlb2pzb25BcmVhLnJpbmcoXykgPj0gMDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUvZGlzdC92dWUuZXNtLmJyb3dzZXInO1xuaW1wb3J0IE1hcENvbXBvbmVudCBmcm9tICcuLi9vYmplY3RzL21hcC9tYXAudnVlJzsgLy8gT3VyIGNvbXBvbmVudFxuaW1wb3J0IE1hcERhdGEgZnJvbSAnLi4vb2JqZWN0cy9tYXAvbWFwLmRhdGEnOyAvLyBPdXIgc2FtcGxlIGRhdGFcbmltcG9ydCBHZW9KU09OIGZyb20gJ2dlb2pzb24nO1xuaW1wb3J0IHJld2luZCBmcm9tICdnZW9qc29uLXJld2luZCc7XG5pbXBvcnQgeyBtYXBDb2xvckNvbWJpbmF0aW9ucyB9IGZyb20gJy4uLy4uL2NvbmZpZy9jb2xvcnMnXG5cbmNsYXNzIE1hcE11bHRpTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9LCBkYXRhID0ge30pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIFZ1ZS5jb21wb25lbnQoJ255Y28tbWFwLW1sJywgTWFwQ29tcG9uZW50KTtcblxuICAgIG5ldyBWdWUoe1xuICAgICAgZWw6ICdbZGF0YS1qcz1cIm55Y28tbWFwLW1sXCJdJyxcbiAgICAgIGRlbGltaXRlcnM6IFsndnsnLCAnfSddLFxuICAgICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsYXllcnM6IE1hcERhdGEubXVsdGkubGF5ZXJzLFxuICAgICAgICAgIGNvbmZpZzogTWFwRGF0YS5tdWx0aS5jb25maWcsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLmdldFppcGNvZGVEYXRhKCk7XG4gICAgICAgIHRoaXMuZ2V0Qm9yb3VnaERhdGEoKTtcbiAgICAgICAgdGhpcy5nZXROZWlnaGJvcmhvb2REYXRhKCk7XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBnZXRaaXBjb2RlRGF0YSgpIHtcbiAgICAgICAgICBmZXRjaCgnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2tpbXBlbmd1aW4vZ2VvSlNPTkBtYXN0ZXIvdGlnZXItemN0YS5nZW9qc29uJylcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIE1hcERhdGEubXVsdGkubGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd6aXBjb2RlcycsXG4gICAgICAgICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShkYXRhKSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGZpbHRlckJ5OiAnR0VPSUQxMCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Qm9yb3VnaERhdGEoKSB7XG4gICAgICAgICAgZmV0Y2goJ2h0dHBzOi8vZGF0YS5jaXR5b2ZuZXd5b3JrLnVzL3Jlc291cmNlLzd0M2IteXd2dy5qc29uJylcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIocmVzcG9uc2UpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgaWYgKFV0aWxpdHkuZGVidWcoKSkgY29uc29sZS5kaXIoZXJyb3IpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgICAgICAgICAgIE1hcERhdGEubXVsdGkubGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdib3JvdWdocycsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5jb252ZXJ0VG9HZW9KU09OKGRhdGEpLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpbHRlckJ5OiAnYm9yb19uYW1lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBnZXROZWlnaGJvcmhvb2REYXRhKCkge1xuICAgICAgICAgIGZldGNoKCdodHRwczovL2RhdGEuY2l0eW9mbmV3eW9yay51cy9yZXNvdXJjZS9xMno1LWFpMzguanNvbicpXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgIGlmIChVdGlsaXR5LmRlYnVnKCkpIGNvbnNvbGUuZGlyKGVycm9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgICAgICAgICAgICBNYXBEYXRhLm11bHRpLmxheWVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbmVpZ2hib3Job29kcycsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5jb252ZXJ0VG9HZW9KU09OKGRhdGEpLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpbHRlckJ5OiAnbnRhbmFtZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydFRvR2VvSlNPTihqc29uRGF0YSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBnZW9qc29uIHNhdGlzZmllcyByaWdodC1oYW5kIHJ1bGVcbiAgICAgICAgICBjb25zdCBkYXRhID0gcmV3aW5kKEdlb0pTT04ucGFyc2UoanNvbkRhdGEsIHtHZW9KU09OOiAndGhlX2dlb20nfSkpO1xuXG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBjb25zdGFudHMgdG8gdGhlIGRlYnVnZ2VyXG4gICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW0gLSBvdXIgY29uc3RhbnRzXG4gICAqL1xuICBfY29uc3RhbnRzKHBhcmFtKSB7XG4gICAgY29uc29sZS5kaXIocGFyYW0pO1xuICB9XG59XG5cbmNsYXNzIE1hcFNpbmdsZUxheWVyIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSwgZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZVxuICAgKi9cbiAgaW5pdCgpIHtcbiAgICBWdWUuY29tcG9uZW50KCdueWNvLW1hcC1zbCcsIE1hcENvbXBvbmVudCk7XG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIGVsOiAnW2RhdGEtanM9XCJueWNvLW1hcC1zbFwiXScsXG4gICAgICBkZWxpbWl0ZXJzOiBbJ3Z7JywgJ30nXSxcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGF5ZXJzOiBNYXBEYXRhLnNpbmdsZS5sYXllcnMsXG4gICAgICAgICAgY29uZmlnOiBNYXBEYXRhLnNpbmdsZS5jb25maWcsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLmdldERhdGEoKTtcbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldERhdGEoKSB7XG4gICAgICAgICAgZmV0Y2goJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9raW1wZW5ndWluL2dlb0pTT05AbWFzdGVyL255Y28tbnljX3ppcGNvZGVzLmdlb2pzb24nKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICBpZiAoVXRpbGl0eS5kZWJ1ZygpKSBjb25zb2xlLmRpcihlcnJvcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgTWFwRGF0YS5zaW5nbGUubGF5ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdueWNvLW55Y196aXBjb2RlcycsXG4gICAgICAgICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShkYXRhKSxcbiAgICAgICAgICAgICAgICBmaWx0ZXJCeTogJ1pDVEE1Q0UxMCcsXG4gICAgICAgICAgICAgICAgbGVnZW5kQ29sdW1uOiAnQk9STycsXG4gICAgICAgICAgICAgICAgZmlsbDogbWFwQ29sb3JDb21iaW5hdGlvbnNbM11cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgTWFwTXVsdGlMYXllcixcbiAgTWFwU2luZ2xlTGF5ZXJcbn0iLCIvKipcbiAqIEphcm9XaW5rbGVyIGZ1bmN0aW9uLlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSmFybyVFMiU4MCU5M1dpbmtsZXJfZGlzdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzMSBzdHJpbmcgb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHMyIHNlY29uZCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGFtb3VudCBvZiBtYXRjaGVzLlxuICovXG5mdW5jdGlvbiBqYXJvKHMxLCBzMikge1xuICBsZXQgc2hvcnRlcjtcbiAgbGV0IGxvbmdlcjtcblxuICBbbG9uZ2VyLCBzaG9ydGVyXSA9IHMxLmxlbmd0aCA+IHMyLmxlbmd0aCA/IFtzMSwgczJdIDogW3MyLCBzMV07XG5cbiAgY29uc3QgbWF0Y2hpbmdXaW5kb3cgPSBNYXRoLmZsb29yKGxvbmdlci5sZW5ndGggLyAyKSAtIDE7XG4gIGNvbnN0IHNob3J0ZXJNYXRjaGVzID0gW107XG4gIGNvbnN0IGxvbmdlck1hdGNoZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3J0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2ggPSBzaG9ydGVyW2ldO1xuICAgIGNvbnN0IHdpbmRvd1N0YXJ0ID0gTWF0aC5tYXgoMCwgaSAtIG1hdGNoaW5nV2luZG93KTtcbiAgICBjb25zdCB3aW5kb3dFbmQgPSBNYXRoLm1pbihpICsgbWF0Y2hpbmdXaW5kb3cgKyAxLCBsb25nZXIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBqID0gd2luZG93U3RhcnQ7IGogPCB3aW5kb3dFbmQ7IGorKylcbiAgICAgIGlmIChsb25nZXJNYXRjaGVzW2pdID09PSB1bmRlZmluZWQgJiYgY2ggPT09IGxvbmdlcltqXSkge1xuICAgICAgICBzaG9ydGVyTWF0Y2hlc1tpXSA9IGxvbmdlck1hdGNoZXNbal0gPSBjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICBjb25zdCBzaG9ydGVyTWF0Y2hlc1N0cmluZyA9IHNob3J0ZXJNYXRjaGVzLmpvaW4oJycpO1xuICBjb25zdCBsb25nZXJNYXRjaGVzU3RyaW5nID0gbG9uZ2VyTWF0Y2hlcy5qb2luKCcnKTtcbiAgY29uc3QgbnVtTWF0Y2hlcyA9IHNob3J0ZXJNYXRjaGVzU3RyaW5nLmxlbmd0aDtcblxuICBsZXQgdHJhbnNwb3NpdGlvbnMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3J0ZXJNYXRjaGVzU3RyaW5nLmxlbmd0aDsgaSsrKVxuICAgIGlmIChzaG9ydGVyTWF0Y2hlc1N0cmluZ1tpXSAhPT0gbG9uZ2VyTWF0Y2hlc1N0cmluZ1tpXSlcbiAgICAgIHRyYW5zcG9zaXRpb25zKys7XG4gIHJldHVybiBudW1NYXRjaGVzID4gMFxuICAgID8gKFxuICAgICAgICBudW1NYXRjaGVzIC8gc2hvcnRlci5sZW5ndGggK1xuICAgICAgICBudW1NYXRjaGVzIC8gbG9uZ2VyLmxlbmd0aCArXG4gICAgICAgIChudW1NYXRjaGVzIC0gTWF0aC5mbG9vcih0cmFuc3Bvc2l0aW9ucyAvIDIpKSAvIG51bU1hdGNoZXNcbiAgICAgICkgLyAzLjBcbiAgICA6IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHMxIHN0cmluZyBvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gczIgc2Vjb25kIHN0cmluZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmVmaXhTY2FsaW5nRmFjdG9yXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGphcm9TaW1pbGFyaXR5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHMxLCBzMiwgcHJlZml4U2NhbGluZ0ZhY3RvciA9IDAuMikge1xuICBjb25zdCBqYXJvU2ltaWxhcml0eSA9IGphcm8oczEsIHMyKTtcblxuICBsZXQgY29tbW9uUHJlZml4TGVuZ3RoID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzMS5sZW5ndGg7IGkrKylcbiAgICBpZiAoczFbaV0gPT09IHMyW2ldKVxuICAgICAgY29tbW9uUHJlZml4TGVuZ3RoKys7XG4gICAgZWxzZVxuICAgICAgYnJlYWs7XG5cbiAgcmV0dXJuIGphcm9TaW1pbGFyaXR5ICtcbiAgICBNYXRoLm1pbihjb21tb25QcmVmaXhMZW5ndGgsIDQpICpcbiAgICBwcmVmaXhTY2FsaW5nRmFjdG9yICpcbiAgICAoMSAtIGphcm9TaW1pbGFyaXR5KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IChmbikgPT4ge1xuICBjb25zdCBjYWNoZSA9IHt9O1xuXG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xuICAgIHJldHVybiBjYWNoZVtrZXldIHx8IChcbiAgICAgIGNhY2hlW2tleV0gPSBmbiguLi5hcmdzKVxuICAgICk7XG4gIH07XG59O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBqYXJvV2lua2xlciBmcm9tICcuL2phcm9XaW5rbGVyLmpzJztcbmltcG9ydCBtZW1vaXplIGZyb20gJy4vbWVtb2l6ZS5qcyc7XG5cbi8qKlxuICogQXV0b2NvbXBsZXRlIGZvciBhdXRvY29tcGxldGUuXG4gKiBGb3JrZWQgYW5kIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3hhdmkvbWlzcy1wbGV0ZVxuICovXG5jbGFzcyBBdXRvY29tcGxldGUge1xuICAvKipcbiAgICogQHBhcmFtICAge29iamVjdH0gc2V0dGluZ3MgIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcmV0dXJuICB7dGhpc30gICAgICAgICAgICAgVGhlIGNsYXNzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MgPSB7fSkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSB7XG4gICAgICAnc2VsZWN0b3InOiBzZXR0aW5ncy5zZWxlY3RvciwgLy8gcmVxdWlyZWRcbiAgICAgICdvcHRpb25zJzogc2V0dGluZ3Mub3B0aW9ucywgLy8gcmVxdWlyZWRcbiAgICAgICdjbGFzc25hbWUnOiBzZXR0aW5ncy5jbGFzc25hbWUsIC8vIHJlcXVpcmVkXG4gICAgICAnc2VsZWN0ZWQnOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3NlbGVjdGVkJykpID9cbiAgICAgICAgc2V0dGluZ3Muc2VsZWN0ZWQgOiBmYWxzZSxcbiAgICAgICdzY29yZSc6IChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnc2NvcmUnKSkgP1xuICAgICAgICBzZXR0aW5ncy5zY29yZSA6IG1lbW9pemUoQXV0b2NvbXBsZXRlLnNjb3JlKSxcbiAgICAgICdsaXN0SXRlbSc6IChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eSgnbGlzdEl0ZW0nKSkgP1xuICAgICAgICBzZXR0aW5ncy5saXN0SXRlbSA6IEF1dG9jb21wbGV0ZS5saXN0SXRlbSxcbiAgICAgICdnZXRTaWJsaW5nSW5kZXgnOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2dldFNpYmxpbmdJbmRleCcpKSA/XG4gICAgICAgIHNldHRpbmdzLmdldFNpYmxpbmdJbmRleCA6IEF1dG9jb21wbGV0ZS5nZXRTaWJsaW5nSW5kZXhcbiAgICB9O1xuXG4gICAgdGhpcy5zY29yZWRPcHRpb25zID0gbnVsbDtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy51bCA9IG51bGw7XG4gICAgdGhpcy5oaWdobGlnaHRlZCA9IC0xO1xuXG4gICAgdGhpcy5TRUxFQ1RPUlMgPSBBdXRvY29tcGxldGUuc2VsZWN0b3JzO1xuICAgIHRoaXMuU1RSSU5HUyA9IEF1dG9jb21wbGV0ZS5zdHJpbmdzO1xuICAgIHRoaXMuTUFYX0lURU1TID0gQXV0b2NvbXBsZXRlLm1heEl0ZW1zO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZSkgPT4ge1xuICAgICAgdGhpcy5rZXlkb3duRXZlbnQoZSk7XG4gICAgfSk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZSkgPT4ge1xuICAgICAgdGhpcy5rZXl1cEV2ZW50KGUpO1xuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGUpID0+IHtcbiAgICAgIHRoaXMuaW5wdXRFdmVudChlKTtcbiAgICB9KTtcblxuICAgIGxldCBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIChlKSA9PiB7XG4gICAgICB0aGlzLmZvY3VzRXZlbnQoZSk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoZSkgPT4ge1xuICAgICAgdGhpcy5ibHVyRXZlbnQoZSk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFVkVOVFNcbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBmb2N1cyBldmVudFxuICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3RcbiAgICovXG4gIGZvY3VzRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMuc2V0dGluZ3Muc2VsZWN0b3IpKSByZXR1cm47XG5cbiAgICB0aGlzLmlucHV0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgaWYgKHRoaXMuaW5wdXQudmFsdWUgPT09ICcnKVxuICAgICAgdGhpcy5tZXNzYWdlKCdJTklUJyk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlucHV0IGtleWRvd24gZXZlbnRcbiAgICogQHBhcmFtICAge29iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0XG4gICAqL1xuICBrZXlkb3duRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMuc2V0dGluZ3Muc2VsZWN0b3IpKSByZXR1cm47XG4gICAgdGhpcy5pbnB1dCA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmICh0aGlzLnVsKVxuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgMTM6IHRoaXMua2V5RW50ZXIoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OiB0aGlzLmtleUVzY2FwZShldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDA6IHRoaXMua2V5RG93bihldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzg6IHRoaXMua2V5VXAoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBrZXl1cCBldmVudFxuICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3RcbiAgICovXG4gIGtleXVwRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMuc2V0dGluZ3Muc2VsZWN0b3IpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdGhpcy5pbnB1dCA9IGV2ZW50LnRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaW5wdXQgZXZlbnRcbiAgICogQHBhcmFtICAge29iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0XG4gICAqL1xuICBpbnB1dEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC50YXJnZXQubWF0Y2hlcyh0aGlzLnNldHRpbmdzLnNlbGVjdG9yKSlcbiAgICAgIHJldHVybjtcblxuICAgIHRoaXMuaW5wdXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICBpZiAodGhpcy5pbnB1dC52YWx1ZS5sZW5ndGggPiAwKVxuICAgICAgdGhpcy5zY29yZWRPcHRpb25zID0gdGhpcy5zZXR0aW5ncy5vcHRpb25zXG4gICAgICAgIC5tYXAoKG9wdGlvbikgPT4gdGhpcy5zZXR0aW5ncy5zY29yZSh0aGlzLmlucHV0LnZhbHVlLCBvcHRpb24pKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuc2NvcmVkT3B0aW9ucyA9IFtdO1xuXG4gICAgdGhpcy5kcm9wZG93bigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBpbnB1dCBibHVyIGV2ZW50XG4gICAqIEBwYXJhbSAgIHtvYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdFxuICAgKi9cbiAgYmx1ckV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gd2luZG93IHx8XG4gICAgICAgICAgIWV2ZW50LnRhcmdldC5tYXRjaGVzKHRoaXMuc2V0dGluZ3Muc2VsZWN0b3IpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdGhpcy5pbnB1dCA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmICh0aGlzLmlucHV0LmRhdGFzZXQucGVyc2lzdERyb3Bkb3duID09PSAndHJ1ZScpXG4gICAgICByZXR1cm47XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIHRoaXMuaGlnaGxpZ2h0ZWQgPSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBLRVkgSU5QVVQgRVZFTlRTXG4gICAqL1xuXG4gIC8qKlxuICAgKiBXaGF0IGhhcHBlbnMgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZSBkb3duIGFycm93XG4gICAqIEBwYXJhbSAgIHtvYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuICB7b2JqZWN0fSAgICAgICAgIFRoZSBDbGFzc1xuICAgKi9cbiAga2V5RG93bihldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLmhpZ2hsaWdodCgodGhpcy5oaWdobGlnaHRlZCA8IHRoaXMudWwuY2hpbGRyZW4ubGVuZ3RoIC0gMSkgP1xuICAgICAgICB0aGlzLmhpZ2hsaWdodGVkICsgMSA6IC0xXG4gICAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogV2hhdCBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgdXAgYXJyb3dcbiAgICogQHBhcmFtICAge29iamVjdH0gIGV2ZW50ICBUaGUgZXZlbnQgb2JqZWN0XG4gICAqIEByZXR1cm4gIHtvYmplY3R9ICAgICAgICAgVGhlIENsYXNzXG4gICAqL1xuICBrZXlVcChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB0aGlzLmhpZ2hsaWdodCgodGhpcy5oaWdobGlnaHRlZCA+IC0xKSA/XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQgLSAxIDogdGhpcy51bC5jaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogV2hhdCBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgZW50ZXIga2V5XG4gICAqIEBwYXJhbSAgIHtvYmplY3R9ICBldmVudCAgVGhlIGV2ZW50IG9iamVjdFxuICAgKiBAcmV0dXJuICB7b2JqZWN0fSAgICAgICAgIFRoZSBDbGFzc1xuICAgKi9cbiAga2V5RW50ZXIoZXZlbnQpIHtcbiAgICB0aGlzLnNlbGVjdGVkKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogV2hhdCBoYXBwZW5zIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyB0aGUgZXNjYXBlIGtleVxuICAgKiBAcGFyYW0gICB7b2JqZWN0fSAgZXZlbnQgIFRoZSBldmVudCBvYmplY3RcbiAgICogQHJldHVybiAge29iamVjdH0gICAgICAgICBUaGUgQ2xhc3NcbiAgICovXG4gIGtleUVzY2FwZShldmVudCkge1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU1RBVElDXG4gICAqL1xuXG4gIC8qKlxuICAgKiBJdCBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCB0aGUgcHJvcGVydGllcyAnc2NvcmUnXG4gICAqIGFuZCAnZGlzcGxheVZhbHVlLicgRGVmYXVsdCBpcyBhIEphcm/igJNXaW5rbGVyIHNpbWlsYXJpdHkgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAge2FycmF5fSAgdmFsdWVcbiAgICogQHBhcmFtICB7YXJyYXl9ICBzeW5vbnltc1xuICAgKiBAcmV0dXJuIHtpbnR9ICAgIFNjb3JlIG9yIGRpc3BsYXlWYWx1ZVxuICAgKi9cbiAgc3RhdGljIHNjb3JlKHZhbHVlLCBzeW5vbnltcykge1xuICAgIGxldCBjbG9zZXN0U3lub255bSA9IG51bGw7XG5cbiAgICBzeW5vbnltcy5mb3JFYWNoKChzeW5vbnltKSA9PiB7XG4gICAgICBsZXQgc2ltaWxhcml0eSA9IGphcm9XaW5rbGVyKFxuICAgICAgICAgIHN5bm9ueW0udHJpbSgpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgdmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgKTtcblxuICAgICAgaWYgKGNsb3Nlc3RTeW5vbnltID09PSBudWxsIHx8IHNpbWlsYXJpdHkgPiBjbG9zZXN0U3lub255bS5zaW1pbGFyaXR5KSB7XG4gICAgICAgIGNsb3Nlc3RTeW5vbnltID0ge3NpbWlsYXJpdHksIHZhbHVlOiBzeW5vbnltfTtcbiAgICAgICAgaWYgKHNpbWlsYXJpdHkgPT09IDEpIHJldHVybjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBzY29yZTogY2xvc2VzdFN5bm9ueW0uc2ltaWxhcml0eSxcbiAgICAgIGRpc3BsYXlWYWx1ZTogc3lub255bXNbMF1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgaXRlbSBmb3IgZHJvcGRvd24gbGlzdC5cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgc2NvcmVkT3B0aW9uXG4gICAqIEBwYXJhbSAge051bWJlcn0gIGluZGV4XG4gICAqIEByZXR1cm4ge3N0cmluZ30gIFRoZSBhIGxpc3QgaXRlbSA8bGk+LlxuICAgKi9cbiAgc3RhdGljIGxpc3RJdGVtKHNjb3JlZE9wdGlvbiwgaW5kZXgsIG1heEl0ZW1zKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEluZGV4ID0gaW5kZXggKyAxOyAvLyBzdGFydCBhdCAxXG5cbiAgICBjb25zdCBsaSA9IChub3JtYWxpemVkSW5kZXggPiBtYXhJdGVtcykgP1xuICAgICAgbnVsbCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICBpZiAobGkpIHtcbiAgICAgIGxpLnNldEF0dHJpYnV0ZSgncm9sZScsICdvcHRpb24nKTtcbiAgICAgIGxpLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIGxpLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsICdmYWxzZScpO1xuICAgIH1cblxuICAgIGxpICYmIGxpLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHNjb3JlZE9wdGlvbi5kaXNwbGF5VmFsdWUpKTtcblxuICAgIHJldHVybiBsaTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgcHJldmlvdXMgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YXJyYXl9ICAgbm9kZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICBpbmRleCBvZiBwcmV2aW91cyBlbGVtZW50LlxuICAgKi9cbiAgc3RhdGljIGdldFNpYmxpbmdJbmRleChub2RlKSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgbGV0IG4gPSBub2RlO1xuXG4gICAgZG8ge1xuICAgICAgaW5kZXgrKzsgbiA9IG4ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICB9XG4gICAgd2hpbGUgKG4pO1xuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFBVQkxJQyBNRVRIT0RTXG4gICAqL1xuXG4gIC8qKlxuICAgKiBEaXNwbGF5IG9wdGlvbnMgYXMgYSBsaXN0LlxuICAgKiBAcmV0dXJuICB7b2JqZWN0fSBUaGUgQ2xhc3NcbiAgICovXG4gIGRyb3Bkb3duKCkge1xuICAgIGNvbnN0IGRvY3VtZW50RnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICB0aGlzLnNjb3JlZE9wdGlvbnMuZXZlcnkoKHNjb3JlZE9wdGlvbiwgaSkgPT4ge1xuICAgICAgbGV0IGxpc3RJdGVtID0gdGhpcy5zZXR0aW5ncy5saXN0SXRlbShzY29yZWRPcHRpb24sIGksIHRoaXMuTUFYX0lURU1TKTtcblxuICAgICAgbGlzdEl0ZW0gJiYgZG9jdW1lbnRGcmFnbWVudC5hcHBlbmRDaGlsZChsaXN0SXRlbSk7XG4gICAgICByZXR1cm4gISFsaXN0SXRlbTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgdGhpcy5oaWdobGlnaHRlZCA9IC0xO1xuXG4gICAgaWYgKGRvY3VtZW50RnJhZ21lbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICBjb25zdCBuZXdVbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG5cbiAgICAgIG5ld1VsLnNldEF0dHJpYnV0ZSgncm9sZScsICdsaXN0Ym94Jyk7XG4gICAgICBuZXdVbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgIG5ld1VsLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLlNFTEVDVE9SUy5PUFRJT05TKTtcblxuICAgICAgbmV3VWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0xJJylcbiAgICAgICAgICB0aGlzLmhpZ2hsaWdodCh0aGlzLnNldHRpbmdzLmdldFNpYmxpbmdJbmRleChldmVudC50YXJnZXQpKTtcbiAgICAgIH0pO1xuXG4gICAgICBuZXdVbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZXZlbnQpID0+XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCkpO1xuXG4gICAgICBuZXdVbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09ICdMSScpXG4gICAgICAgICAgdGhpcy5zZWxlY3RlZCgpO1xuICAgICAgfSk7XG5cbiAgICAgIG5ld1VsLmFwcGVuZENoaWxkKGRvY3VtZW50RnJhZ21lbnQpO1xuXG4gICAgICAvLyBTZWUgQ1NTIHRvIHVuZGVyc3RhbmQgd2h5IHRoZSA8dWw+IGhhcyB0byBiZSB3cmFwcGVkIGluIGEgPGRpdj5cbiAgICAgIGNvbnN0IG5ld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICBuZXdDb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy5zZXR0aW5ncy5jbGFzc25hbWU7XG4gICAgICBuZXdDb250YWluZXIuYXBwZW5kQ2hpbGQobmV3VWwpO1xuXG4gICAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG5cbiAgICAgIC8vIEluc2VydHMgdGhlIGRyb3Bkb3duIGp1c3QgYWZ0ZXIgdGhlIDxpbnB1dD4gZWxlbWVudFxuICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdDb250YWluZXIsIHRoaXMuaW5wdXQubmV4dFNpYmxpbmcpO1xuICAgICAgdGhpcy5jb250YWluZXIgPSBuZXdDb250YWluZXI7XG4gICAgICB0aGlzLnVsID0gbmV3VWw7XG5cbiAgICAgIHRoaXMubWVzc2FnZSgnVFlQSU5HJywgdGhpcy5zZXR0aW5ncy5vcHRpb25zLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSGlnaGxpZ2h0IG5ldyBvcHRpb24gc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSAgIHtOdW1iZXJ9ICBuZXdJbmRleFxuICAgKiBAcmV0dXJuICB7b2JqZWN0fSAgVGhlIENsYXNzXG4gICAqL1xuICBoaWdobGlnaHQobmV3SW5kZXgpIHtcbiAgICBpZiAobmV3SW5kZXggPiAtMSAmJiBuZXdJbmRleCA8IHRoaXMudWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBJZiBhbnkgb3B0aW9uIGFscmVhZHkgc2VsZWN0ZWQsIHRoZW4gdW5zZWxlY3QgaXRcbiAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkICE9PSAtMSkge1xuICAgICAgICB0aGlzLnVsLmNoaWxkcmVuW3RoaXMuaGlnaGxpZ2h0ZWRdLmNsYXNzTGlzdFxuICAgICAgICAgIC5yZW1vdmUodGhpcy5TRUxFQ1RPUlMuSElHSExJR0hUKTtcbiAgICAgICAgdGhpcy51bC5jaGlsZHJlblt0aGlzLmhpZ2hsaWdodGVkXS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgICAgICAgdGhpcy51bC5jaGlsZHJlblt0aGlzLmhpZ2hsaWdodGVkXS5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICAgICAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhpZ2hsaWdodGVkID0gbmV3SW5kZXg7XG5cbiAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkICE9PSAtMSkge1xuICAgICAgICB0aGlzLnVsLmNoaWxkcmVuW3RoaXMuaGlnaGxpZ2h0ZWRdLmNsYXNzTGlzdFxuICAgICAgICAgIC5hZGQodGhpcy5TRUxFQ1RPUlMuSElHSExJR0hUKTtcbiAgICAgICAgdGhpcy51bC5jaGlsZHJlblt0aGlzLmhpZ2hsaWdodGVkXVxuICAgICAgICAgIC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLnVsLmNoaWxkcmVuW3RoaXMuaGlnaGxpZ2h0ZWRdXG4gICAgICAgICAgLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLlNFTEVDVE9SUy5BQ1RJVkVfREVTQ0VOREFOVCk7XG5cbiAgICAgICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsXG4gICAgICAgICAgdGhpcy5TRUxFQ1RPUlMuQUNUSVZFX0RFU0NFTkRBTlQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYW4gb3B0aW9uIGZyb20gYSBsaXN0IG9mIGl0ZW1zLlxuICAgKiBAcmV0dXJuICB7b2JqZWN0fSBUaGUgQ2xhc3NcbiAgICovXG4gIHNlbGVjdGVkKCkge1xuICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkICE9PSAtMSkge1xuICAgICAgdGhpcy5pbnB1dC52YWx1ZSA9IHRoaXMuc2NvcmVkT3B0aW9uc1t0aGlzLmhpZ2hsaWdodGVkXS5kaXNwbGF5VmFsdWU7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgdGhpcy5tZXNzYWdlKCdTRUxFQ1RFRCcsIHRoaXMuaW5wdXQudmFsdWUpO1xuXG4gICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPD0gNzY4KVxuICAgICAgICB0aGlzLmlucHV0LnNjcm9sbEludG9WaWV3KHRydWUpO1xuICAgIH1cblxuICAgIC8vIFVzZXIgcHJvdmlkZWQgY2FsbGJhY2sgbWV0aG9kIGZvciBzZWxlY3RlZCBvcHRpb24uXG4gICAgaWYgKHRoaXMuc2V0dGluZ3Muc2VsZWN0ZWQpXG4gICAgICB0aGlzLnNldHRpbmdzLnNlbGVjdGVkKHRoaXMuaW5wdXQudmFsdWUsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGRyb3Bkb3duIGxpc3Qgb25jZSBhIGxpc3QgaXRlbSBpcyBzZWxlY3RlZC5cbiAgICogQHJldHVybiAge29iamVjdH0gVGhlIENsYXNzXG4gICAqL1xuICByZW1vdmUoKSB7XG4gICAgdGhpcy5jb250YWluZXIgJiYgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLnVsID0gbnVsbDtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lc3NhZ2luZyB0aGF0IGlzIHBhc3NlZCB0byB0aGUgc2NyZWVuIHJlYWRlclxuICAgKiBAcGFyYW0gICB7c3RyaW5nfSAga2V5ICAgICAgIFRoZSBLZXkgb2YgdGhlIG1lc3NhZ2UgdG8gd3JpdGVcbiAgICogQHBhcmFtICAge3N0cmluZ30gIHZhcmlhYmxlICBBIHZhcmlhYmxlIHRvIHByb3ZpZGUgdG8gdGhlIHN0cmluZy5cbiAgICogQHJldHVybiAge29iamVjdH0gICAgICAgICAgICBUaGUgQ2xhc3NcbiAgICovXG4gIG1lc3NhZ2Uoa2V5ID0gZmFsc2UsIHZhcmlhYmxlID0gJycpIHtcbiAgICBpZiAoIWtleSkgcmV0dXJuIHRoaXM7XG5cbiAgICBsZXQgbWVzc2FnZXMgPSB7XG4gICAgICAnSU5JVCc6ICgpID0+IHRoaXMuU1RSSU5HUy5ESVJFQ1RJT05TX1RZUEUsXG4gICAgICAnVFlQSU5HJzogKCkgPT4gKFtcbiAgICAgICAgICB0aGlzLlNUUklOR1MuT1BUSU9OX0FWQUlMQUJMRS5yZXBsYWNlKCd7eyBOVU1CRVIgfX0nLCB2YXJpYWJsZSksXG4gICAgICAgICAgdGhpcy5TVFJJTkdTLkRJUkVDVElPTlNfUkVWSUVXXG4gICAgICAgIF0uam9pbignLiAnKSksXG4gICAgICAnU0VMRUNURUQnOiAoKSA9PiAoW1xuICAgICAgICAgIHRoaXMuU1RSSU5HUy5PUFRJT05fU0VMRUNURUQucmVwbGFjZSgne3sgVkFMVUUgfX0nLCB2YXJpYWJsZSksXG4gICAgICAgICAgdGhpcy5TVFJJTkdTLkRJUkVDVElPTlNfVFlQRVxuICAgICAgICBdLmpvaW4oJy4gJykpXG4gICAgfTtcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke3RoaXMuaW5wdXQuZ2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyl9YClcbiAgICAgIC5pbm5lckhUTUwgPSBtZXNzYWdlc1trZXldKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKiogU2VsZWN0b3JzIGZvciB0aGUgQXV0b2NvbXBsZXRlIGNsYXNzLiAqL1xuQXV0b2NvbXBsZXRlLnNlbGVjdG9ycyA9IHtcbiAgJ0hJR0hMSUdIVCc6ICdpbnB1dC1hdXRvY29tcGxldGVfX2hpZ2hsaWdodCcsXG4gICdPUFRJT05TJzogJ2lucHV0LWF1dG9jb21wbGV0ZV9fb3B0aW9ucycsXG4gICdBQ1RJVkVfREVTQ0VOREFOVCc6ICdpbnB1dC1hdXRvY29tcGxldGVfX3NlbGVjdGVkJyxcbiAgJ1NDUkVFTl9SRUFERVJfT05MWSc6ICdzci1vbmx5J1xufTtcblxuLyoqICAqL1xuQXV0b2NvbXBsZXRlLnN0cmluZ3MgPSB7XG4gICdESVJFQ1RJT05TX1RZUEUnOlxuICAgICdTdGFydCB0eXBpbmcgdG8gZ2VuZXJhdGUgYSBsaXN0IG9mIHBvdGVudGlhbCBpbnB1dCBvcHRpb25zJyxcbiAgJ0RJUkVDVElPTlNfUkVWSUVXJzogW1xuICAgICAgJ0tleWJvYXJkIHVzZXJzIGNhbiB1c2UgdGhlIHVwIGFuZCBkb3duIGFycm93cyB0byAnLFxuICAgICAgJ3JldmlldyBvcHRpb25zIGFuZCBwcmVzcyBlbnRlciB0byBzZWxlY3QgYW4gb3B0aW9uJ1xuICAgIF0uam9pbignJyksXG4gICdPUFRJT05fQVZBSUxBQkxFJzogJ3t7IE5VTUJFUiB9fSBvcHRpb25zIGF2YWlsYWJsZScsXG4gICdPUFRJT05fU0VMRUNURUQnOiAne3sgVkFMVUUgfX0gc2VsZWN0ZWQnXG59O1xuXG4vKiogTWF4aW11bSBhbW91bnQgb2YgcmVzdWx0cyB0byBiZSByZXR1cm5lZC4gKi9cbkF1dG9jb21wbGV0ZS5tYXhJdGVtcyA9IDU7XG5cbmV4cG9ydCBkZWZhdWx0IEF1dG9jb21wbGV0ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEF1dG9jb21wbGV0ZSBmcm9tICcuLi8uLi9qcy9tb2R1bGVzL2F1dG9jb21wbGV0ZSc7XG5cbi8qKlxuICogVGhlIElucHV0QXV0b2NvbXBsZXRlIGNsYXNzLlxuICovXG5jbGFzcyBJbnB1dEF1dG9jb21wbGV0ZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHNldHRpbmdzIFRoaXMgY291bGQgYmUgc29tZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHRoZSBwYXR0ZXJuIG1vZHVsZS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncyA9IHt9KSB7XG4gICAgdGhpcy5saWJyYXJ5ID0gbmV3IEF1dG9jb21wbGV0ZSh7XG4gICAgICBvcHRpb25zOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ29wdGlvbnMnKSlcbiAgICAgICAgPyBzZXR0aW5ncy5vcHRpb25zIDogSW5wdXRBdXRvY29tcGxldGUub3B0aW9ucyxcbiAgICAgIHNlbGVjdGVkOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3NlbGVjdGVkJykpXG4gICAgICAgID8gc2V0dGluZ3Muc2VsZWN0ZWQgOiBmYWxzZSxcbiAgICAgIHNlbGVjdG9yOiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ3NlbGVjdG9yJykpXG4gICAgICAgID8gc2V0dGluZ3Muc2VsZWN0b3IgOiBJbnB1dEF1dG9jb21wbGV0ZS5zZWxlY3RvcixcbiAgICAgIGNsYXNzbmFtZTogKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdjbGFzc25hbWUnKSlcbiAgICAgICAgPyBzZXR0aW5ncy5jbGFzc25hbWUgOiBJbnB1dEF1dG9jb21wbGV0ZS5jbGFzc25hbWUsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBBdXRvY29tcGxldGUgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9IHJlc2V0IFNldCBvZiBhcnJheSBvcHRpb25zIGZvciB0aGUgQXV0b2NvbXBsZXRlIGNsYXNzXG4gICAqIEByZXR1cm4ge29iamVjdH0gSW5wdXRBdXRvY29tcGxldGUgb2JqZWN0IHdpdGggbmV3IG9wdGlvbnMuXG4gICAqL1xuICBvcHRpb25zKHJlc2V0KSB7XG4gICAgdGhpcy5saWJyYXJ5LnNldHRpbmdzLm9wdGlvbnMgPSByZXNldDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBBdXRvY29tcGxldGUgc3RyaW5nc1xuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBsb2NhbGl6ZWRTdHJpbmdzICBPYmplY3QgY29udGFpbmluZyBzdHJpbmdzLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IEF1dG9jb21wbGV0ZSBzdHJpbmdzXG4gICAqL1xuICBzdHJpbmdzKGxvY2FsaXplZFN0cmluZ3MpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMubGlicmFyeS5TVFJJTkdTLCBsb2NhbGl6ZWRTdHJpbmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG4vKiogQHR5cGUge2FycmF5fSBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBhdXRvY29tcGxldGUgY2xhc3MgKi9cbklucHV0QXV0b2NvbXBsZXRlLm9wdGlvbnMgPSBbXTtcblxuLyoqIEB0eXBlIHtzdHJpbmd9IFRoZSBzZWFyY2ggYm94IGRvbSBzZWxlY3RvciAqL1xuSW5wdXRBdXRvY29tcGxldGUuc2VsZWN0b3IgPSAnW2RhdGEtanM9XCJpbnB1dC1hdXRvY29tcGxldGVfX2lucHV0XCJdJztcblxuLyoqIEB0eXBlIHtzdHJpbmd9IFRoZSBjbGFzc25hbWUgZm9yIHRoZSBkcm9wZG93biBlbGVtZW50ICovXG5JbnB1dEF1dG9jb21wbGV0ZS5jbGFzc25hbWUgPSAnaW5wdXQtYXV0b2NvbXBsZXRlX19kcm9wZG93bic7XG5cbmV4cG9ydCBkZWZhdWx0IElucHV0QXV0b2NvbXBsZXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgSWNvbnMgZnJvbSAnLi4vZWxlbWVudHMvaWNvbnMvSWNvbnMnO1xuaW1wb3J0IEZlZWQgZnJvbSAnLi4vb2JqZWN0cy9mZWVkL0ZlZWQnO1xuaW1wb3J0IFRvZ2dsZSBmcm9tICcuLi91dGlsaXRpZXMvdG9nZ2xlL1RvZ2dsZSc7XG5pbXBvcnQgVHJhY2sgZnJvbSAnLi4vdXRpbGl0aWVzL3RyYWNrL1RyYWNrJztcbmltcG9ydCBTZWxlY3QgZnJvbSAnLi4vZWxlbWVudHMvc2VsZWN0L3NlbGVjdCc7XG5pbXBvcnQgQ2hhcnRCYXIgZnJvbSAnLi4vb2JqZWN0cy9jaGFydHMvY2hhcnQtLWJhcic7XG5pbXBvcnQgQ2hhcnRIb3Jpem9udGFsQmFyIGZyb20gJy4uL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1ob3Jpem9udGFsLWJhcic7XG5pbXBvcnQgQ2hhcnRMaW5lIGZyb20gJy4uL29iamVjdHMvY2hhcnRzL2NoYXJ0LS1saW5lJztcbmltcG9ydCBDaGFydFBpZSBmcm9tICcuLi9vYmplY3RzL2NoYXJ0cy9jaGFydC0tcGllJztcbmltcG9ydCB7IE1hcE11bHRpTGF5ZXIsIE1hcFNpbmdsZUxheWVyIH0gZnJvbSAnLi9NYXAnO1xuaW1wb3J0IElucHV0QXV0b2NvbXBsZXRlIGZyb20gJy4uL2VsZW1lbnRzL2lucHV0cy9pbnB1dC1hdXRvY29tcGxldGUnO1xuLyoqIGltcG9ydCBtb2R1bGVzIGhlcmUgYXMgdGhleSBhcmUgd3JpdHRlbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIHRoZSBnbG9iYWwgTnljb1BhdHRlcm5zIGluc3RhbmNlXG4gKi9cbmNsYXNzIG55Y28ge1xuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgSWNvbnMgRWxlbWVudFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggIFRoZSBwYXRoIG9mIHRoZSBpY29uIGZpbGVcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBJY29ucyBpbnN0YW5jZVxuICAgKi9cbiAgaWNvbnMocGF0aCkge1xuICAgIHJldHVybiBuZXcgSWNvbnMocGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZvciB0aGUgRmVlZCBPYmplY3RcbiAgICogQHBhcmFtICAge09iamVjdH0gIHNldHRpbmdzICBTZXR0aW5nIGZvciB0aGUgZmVlZFxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSAgICAgICAgICAgIEZlZWQgaW5zdGFuY2VcbiAgICovXG4gIGZlZWQoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gbmV3IEZlZWQoc2V0dGluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgdGhlIFRvZ2dsZSBVdGlsaXR5XG4gICAqIEByZXR1cm4gIHtPYmplY3R9IFRvZ2dsZSBpbnN0YW5jZVxuICAgKi9cbiAgdG9nZ2xlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBUb2dnbGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBUcmFjayBNb2R1bGVcbiAgICogQHJldHVybiAge09iamVjdH0gVHJhY2sgTW9kdWxlXG4gICAqL1xuICB0cmFjayhzZXR0aW5ncykge1xuICAgIHJldHVybiBuZXcgVHJhY2soKTtcbiAgfVxuXG4gIHNlbGVjdCgpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBDaGFydCBPYmplY3RzXG4gICAqIEByZXR1cm4gIHtPYmplY3R9IENoYXJ0IGluc3RhbmNlXG4gICAqL1xuICBjaGFydCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdiYXInKVxuICAgICAgcmV0dXJuIG5ldyBDaGFydEJhcigpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdob3Jpem9udGFsQmFyJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRIb3Jpem9udGFsQmFyKCk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2xpbmUnKVxuICAgICAgcmV0dXJuIG5ldyBDaGFydExpbmUoKTtcblxuICAgIGlmICh0eXBlID09PSAncGllJylcbiAgICAgIHJldHVybiBuZXcgQ2hhcnRQaWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBNYXAgTW9kdWxlXG4gICAqIEByZXR1cm4gIHtPYmplY3R9IE1hcCBNb2R1bGVcbiAgICovXG4gIG1hcCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdtdWx0aScpXG4gICAgICByZXR1cm4gbmV3IE1hcE11bHRpTGF5ZXIoKTtcblxuICAgIGlmICh0eXBlID09PSAnc2luZ2xlJylcbiAgICAgIHJldHVybiBuZXcgTWFwU2luZ2xlTGF5ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgZm9yIHRoZSBJbnB1dCBBdXRvY29tcGxldGUgRWxlbWVudFxuICAgKiBAcmV0dXJuICB7T2JqZWN0fSBJbnB1dCBBdXRvY29tcGxldGUgaW5zdGFuY2VcbiAgICovXG4gIGlucHV0QXV0b2NvbXBsZXRlKHNldHRpbmdzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IElucHV0QXV0b2NvbXBsZXRlKHNldHRpbmdzKTtcbiAgfVxuXG4gIC8qKiBhZGQgQVBJcyBoZXJlIGFzIHRoZXkgYXJlIHdyaXR0ZW4gKi9cbn1cblxuZXhwb3J0IGRlZmF1bHQgbnljbztcbiJdLCJuYW1lcyI6WyJVdGlsaXR5IiwiZGVidWciLCJnZXRVcmxQYXJhbWV0ZXIiLCJQQVJBTVMiLCJERUJVRyIsIm5hbWUiLCJxdWVyeVN0cmluZyIsInF1ZXJ5Iiwid2luZG93IiwibG9jYXRpb24iLCJzZWFyY2giLCJjb25zdCIsInBhcmFtIiwicmVwbGFjZSIsInJlZ2V4IiwiUmVnRXhwIiwicmVzdWx0cyIsImV4ZWMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJsb2NhbGl6ZSIsInNsdWciLCJ0ZXh0IiwibGV0Iiwic3RyaW5ncyIsIkxPQ0FMSVpFRF9TVFJJTkdTIiwibWF0Y2giLCJmaWx0ZXIiLCJzIiwiaGFzT3duUHJvcGVydHkiLCJsYWJlbCIsIlNFTEVDVE9SUyIsInBhcnNlTWFya2Rvd24iLCJJY29ucyIsInBhdGgiLCJmZXRjaCIsInRoZW4iLCJyZXNwb25zZSIsIm9rIiwiY29uc29sZSIsImRpciIsImVycm9yIiwiZGF0YSIsInNwcml0ZSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJPYmplY3QiLCJmcmVlU2VsZiIsInNlbGYiLCJyb290IiwiRnVuY3Rpb24iLCJTeW1ib2wiLCJvYmplY3RQcm90byIsInByb3RvdHlwZSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwidG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwidW5kZWZpbmVkIiwiZ2V0UmF3VGFnIiwidmFsdWUiLCJpc093biIsImNhbGwiLCJ0YWciLCJ1bm1hc2tlZCIsImUiLCJyZXN1bHQiLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJiYXNlR2V0VGFnIiwiaXNPYmplY3QiLCJ0eXBlIiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwiY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJrZXlzIiwiSUVfUFJPVE8iLCJpc01hc2tlZCIsImZ1bmMiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsInJlSXNOYXRpdmUiLCJiYXNlSXNOYXRpdmUiLCJwYXR0ZXJuIiwidGVzdCIsImdldFZhbHVlIiwib2JqZWN0Iiwia2V5IiwiZ2V0TmF0aXZlIiwiZGVmaW5lUHJvcGVydHkiLCJiYXNlQXNzaWduVmFsdWUiLCJlcSIsIm90aGVyIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImNvcHlPYmplY3QiLCJzb3VyY2UiLCJwcm9wcyIsImN1c3RvbWl6ZXIiLCJpc05ldyIsImluZGV4IiwibGVuZ3RoIiwibmV3VmFsdWUiLCJpZGVudGl0eSIsImFwcGx5IiwidGhpc0FyZyIsImFyZ3MiLCJuYXRpdmVNYXgiLCJNYXRoIiwibWF4Iiwib3ZlclJlc3QiLCJzdGFydCIsInRyYW5zZm9ybSIsImFyZ3VtZW50cyIsImFycmF5IiwiQXJyYXkiLCJvdGhlckFyZ3MiLCJjb25zdGFudCIsImJhc2VTZXRUb1N0cmluZyIsInN0cmluZyIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93IiwiRGF0ZSIsIm5vdyIsInNob3J0T3V0IiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJzZXRUb1N0cmluZyIsImJhc2VSZXN0IiwiTUFYX1NBRkVfSU5URUdFUiIsImlzTGVuZ3RoIiwiaXNBcnJheUxpa2UiLCJyZUlzVWludCIsImlzSW5kZXgiLCJpc0l0ZXJhdGVlQ2FsbCIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJiYXNlVGltZXMiLCJuIiwiaXRlcmF0ZWUiLCJpc09iamVjdExpa2UiLCJhcmdzVGFnIiwiYmFzZUlzQXJndW1lbnRzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJpc0FyZ3VtZW50cyIsImlzQXJyYXkiLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsImV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwibmF0aXZlSXNCdWZmZXIiLCJpc0J1ZmZlciIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJiYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5IiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJTdHJpbmciLCJwdXNoIiwiaXNQcm90b3R5cGUiLCJDdG9yIiwiY29uc3RydWN0b3IiLCJwcm90byIsIm5hdGl2ZUtleXNJbiIsImJhc2VLZXlzSW4iLCJpc1Byb3RvIiwia2V5c0luIiwiYXNzaWduSW5XaXRoIiwic3JjSW5kZXgiLCJvdmVyQXJnIiwiYXJnIiwiZ2V0UHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJvYmplY3RDdG9yU3RyaW5nIiwiaXNQbGFpbk9iamVjdCIsImRvbUV4Y1RhZyIsImlzRXJyb3IiLCJtZXNzYWdlIiwiYXR0ZW1wdCIsIkVycm9yIiwiYXJyYXlNYXAiLCJiYXNlVmFsdWVzIiwiY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiIsInNyY1ZhbHVlIiwic3RyaW5nRXNjYXBlcyIsImVzY2FwZVN0cmluZ0NoYXIiLCJjaHIiLCJuYXRpdmVLZXlzIiwiYmFzZUtleXMiLCJyZUludGVycG9sYXRlIiwiYmFzZVByb3BlcnR5T2YiLCJodG1sRXNjYXBlcyIsImVzY2FwZUh0bWxDaGFyIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wiLCJJTkZJTklUWSIsInN5bWJvbFByb3RvIiwic3ltYm9sVG9TdHJpbmciLCJiYXNlVG9TdHJpbmciLCJyZVVuZXNjYXBlZEh0bWwiLCJyZUhhc1VuZXNjYXBlZEh0bWwiLCJlc2NhcGUiLCJyZUVzY2FwZSIsInJlRXZhbHVhdGUiLCJ0ZW1wbGF0ZVNldHRpbmdzIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc1RlbXBsYXRlIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJ0ZW1wbGF0ZSIsIm9wdGlvbnMiLCJzZXR0aW5ncyIsImltcG9ydHMiLCJfIiwiaW1wb3J0c0tleXMiLCJpbXBvcnRzVmFsdWVzIiwiaXNFc2NhcGluZyIsImlzRXZhbHVhdGluZyIsImludGVycG9sYXRlIiwicmVEZWxpbWl0ZXJzIiwiZXZhbHVhdGUiLCJzb3VyY2VVUkwiLCJlc2NhcGVWYWx1ZSIsImludGVycG9sYXRlVmFsdWUiLCJlc1RlbXBsYXRlVmFsdWUiLCJldmFsdWF0ZVZhbHVlIiwib2Zmc2V0Iiwic2xpY2UiLCJ2YXJpYWJsZSIsImFycmF5RWFjaCIsImNyZWF0ZUJhc2VGb3IiLCJmcm9tUmlnaHQiLCJrZXlzRnVuYyIsIml0ZXJhYmxlIiwiYmFzZUZvciIsImJhc2VGb3JPd24iLCJjcmVhdGVCYXNlRWFjaCIsImVhY2hGdW5jIiwiY29sbGVjdGlvbiIsImJhc2VFYWNoIiwiY2FzdEZ1bmN0aW9uIiwiZm9yRWFjaCIsImxpc3RDYWNoZUNsZWFyIiwiX19kYXRhX18iLCJzaXplIiwiYXNzb2NJbmRleE9mIiwiYXJyYXlQcm90byIsInNwbGljZSIsImxpc3RDYWNoZURlbGV0ZSIsImxhc3RJbmRleCIsInBvcCIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsImVudHJpZXMiLCJjbGVhciIsImVudHJ5Iiwic2V0IiwiZ2V0IiwiaGFzIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsIk1hcCIsIm5hdGl2ZUNyZWF0ZSIsImhhc2hDbGVhciIsImhhc2hEZWxldGUiLCJIQVNIX1VOREVGSU5FRCIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2giLCJtYXBDYWNoZUNsZWFyIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsIm1hcCIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJMQVJHRV9BUlJBWV9TSVpFIiwic3RhY2tTZXQiLCJwYWlycyIsIlN0YWNrIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImFsbG9jVW5zYWZlIiwiY2xvbmVCdWZmZXIiLCJidWZmZXIiLCJpc0RlZXAiLCJjb3B5IiwiVWludDhBcnJheSIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJjbG9uZVR5cGVkQXJyYXkiLCJ0eXBlZEFycmF5IiwiYnl0ZU9mZnNldCIsImNvcHlBcnJheSIsIm9iamVjdENyZWF0ZSIsImNyZWF0ZSIsImJhc2VDcmVhdGUiLCJpbml0Q2xvbmVPYmplY3QiLCJpc0FycmF5TGlrZU9iamVjdCIsInNhZmVHZXQiLCJ0b1BsYWluT2JqZWN0IiwiYmFzZU1lcmdlRGVlcCIsIm1lcmdlRnVuYyIsInN0YWNrIiwic3RhY2tlZCIsImlzQ29tbW9uIiwiaXNUeXBlZCIsImJhc2VNZXJnZSIsIm1lcmdlIiwidmFsdWVzIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlNldENhY2hlIiwiYWRkIiwiYXJyYXlTb21lIiwicHJlZGljYXRlIiwiY2FjaGVIYXMiLCJjYWNoZSIsIkNPTVBBUkVfUEFSVElBTF9GTEFHIiwiQ09NUEFSRV9VTk9SREVSRURfRkxBRyIsImVxdWFsQXJyYXlzIiwiYml0bWFzayIsImVxdWFsRnVuYyIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsInNlZW4iLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJvdGhJbmRleCIsIm1hcFRvQXJyYXkiLCJzZXRUb0FycmF5Iiwic3ltYm9sVmFsdWVPZiIsInZhbHVlT2YiLCJlcXVhbEJ5VGFnIiwiY29udmVydCIsImFycmF5UHVzaCIsImJhc2VHZXRBbGxLZXlzIiwic3ltYm9sc0Z1bmMiLCJhcnJheUZpbHRlciIsInJlc0luZGV4Iiwic3R1YkFycmF5IiwibmF0aXZlR2V0U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldFN5bWJvbHMiLCJzeW1ib2wiLCJnZXRBbGxLZXlzIiwiZXF1YWxPYmplY3RzIiwib2JqUHJvcHMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsInNraXBDdG9yIiwib2JqQ3RvciIsIm90aEN0b3IiLCJEYXRhVmlldyIsIlByb21pc2UiLCJTZXQiLCJXZWFrTWFwIiwicHJvbWlzZVRhZyIsImRhdGFWaWV3Q3RvclN0cmluZyIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsImdldFRhZyIsIkFycmF5QnVmZmVyIiwicmVzb2x2ZSIsImN0b3JTdHJpbmciLCJiYXNlSXNFcXVhbERlZXAiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImJhc2VJc0VxdWFsIiwiYmFzZUlzTWF0Y2giLCJtYXRjaERhdGEiLCJub0N1c3RvbWl6ZXIiLCJpc1N0cmljdENvbXBhcmFibGUiLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsImJhc2VNYXRjaGVzIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsImlzS2V5IiwiRlVOQ19FUlJPUl9URVhUIiwibWVtb2l6ZSIsInJlc29sdmVyIiwiVHlwZUVycm9yIiwibWVtb2l6ZWQiLCJDYWNoZSIsIk1BWF9NRU1PSVpFX1NJWkUiLCJtZW1vaXplQ2FwcGVkIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsInN0cmluZ1RvUGF0aCIsImNoYXJDb2RlQXQiLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0IiwiZGVmYXVsdFZhbHVlIiwiYmFzZUhhc0luIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJoYXNJbiIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJiYXNlUHJvcGVydHkiLCJiYXNlUHJvcGVydHlEZWVwIiwicHJvcGVydHkiLCJiYXNlSXRlcmF0ZWUiLCJiYXNlTWFwIiwiYmFzZVNvcnRCeSIsImNvbXBhcmVyIiwic29ydCIsImNvbXBhcmVBc2NlbmRpbmciLCJ2YWxJc0RlZmluZWQiLCJ2YWxJc051bGwiLCJ2YWxJc1JlZmxleGl2ZSIsInZhbElzU3ltYm9sIiwib3RoSXNEZWZpbmVkIiwib3RoSXNOdWxsIiwib3RoSXNSZWZsZXhpdmUiLCJvdGhJc1N5bWJvbCIsImNvbXBhcmVNdWx0aXBsZSIsIm9yZGVycyIsIm9iakNyaXRlcmlhIiwiY3JpdGVyaWEiLCJvdGhDcml0ZXJpYSIsIm9yZGVyc0xlbmd0aCIsIm9yZGVyIiwiYmFzZU9yZGVyQnkiLCJpdGVyYXRlZXMiLCJvcmRlckJ5Iiwibm9vcCIsImNyZWF0ZVNldCIsIkZlZWQiLCJjb25maWciLCJfc2V0dGluZ3MiLCJfbWVyZ2UiLCJpbml0IiwiZmVlZCIsInJzc1RvSnNvbiIsInJzc1VybCIsIl9mb3JFYWNoIiwidXJsIiwidGhpcyIsIl9yZXF1ZXN0IiwiX3Byb2Nlc3MiLCJKU09OIiwicGFyc2UiLCJ0aGlzJDEiLCJjb21waWxlZCIsIl9yZW5kZXIiLCJlbCIsInF1ZXJ5U2VsZWN0b3IiLCJzZWxlY3RvciIsInJlamVjdCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwiZXZlbnQiLCJfeGhyIiwidGFyZ2V0IiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsIm9udGltZW91dCIsIm9wZW4iLCJzZW5kIiwibG9nIiwiX3ZhbHVlcyIsInRlbXBsYXRlcyIsImpvaW4iLCJfdGVtcGxhdGUiLCJtZWRpdW0iLCJvcGVuZXIiLCJoZWFkZXIiLCJwb3N0cyIsImNsb3NlciIsInBvc3RFeGNlcnB0TGVuZ3RoIiwiaXRlbXMiLCJwb3N0IiwiZXhjZXJwdCIsImRhdGUiLCJkZXNjcmlwdGlvbiIsInN1YnN0ciIsIm1pbiIsImxhc3RJbmRleE9mIiwicHViRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInBvc3REYXRlTG9jYWwiLCJwb3N0RGF0ZUZvcm1hdCIsIm1lcmdlZCIsImNvbmNhdCIsIl9vcmRlckJ5IiwidGl0bGUiLCJ0aXRsZVVybCIsInByb2ZpbGVJbWciLCJmb250U2l6ZSIsInJhdGlvUHJvZmlsZSIsInBvc3RCb3JkZXJDb2xvciIsInBvc3RJbWdIZWlnaHQiLCJwb3N0RXhjZXJwdFRyYWlsIiwicG9zdEN0YVRleHQiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJwb3N0RGF0ZVRpdGxlIiwiY2xhc3NlcyIsIndyYXBwZXIiLCJmZWVkSXRlbSIsImxpbmsiLCJ0aHVtYm5haWwiLCJpdGVtRm9vdGVyIiwiY3RhIiwidW5pcXVlIiwiVG9nZ2xlIiwibmFtZXNwYWNlIiwiaW5hY3RpdmVDbGFzcyIsImFjdGl2ZUNsYXNzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm1hdGNoZXMiLCJwcmV2ZW50RGVmYXVsdCIsIl90b2dnbGUiLCJnZXRBdHRyaWJ1dGUiLCJlbGVtZW50VG9nZ2xlIiwiZGF0YXNldCIsInVuZG8iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwiaSIsImVsQXJpYVJvbGVzIiwidGFyZ2V0QXJpYVJvbGVzIiwiY29udGFpbnMiLCJoYXNoIiwiVHJhY2siLCJ0cmFja0tleSIsInRyYWNrRGF0YSIsImNsaWNrIiwiZCIsInBhdGhuYW1lIiwid3QiLCJ3ZWJ0cmVuZHMiLCJnYSIsImd0YWciLCJ2aWV3IiwiYXBwIiwiZ3RhZ1ZpZXciLCJhc3NpZ24iLCJ3dGQiLCJhcmdzYSIsImZsYXRNYXAiLCJrIiwiV2VidHJlbmRzIiwibXVsdGlUcmFjayIsInVyaSIsImZpbmQiLCJlbGVtZW50IiwiYXBwX25hbWUiLCJzY3JlZW5fbmFtZSIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwiaXNVbmRlZiIsInYiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsIm9iaiIsIl90b1N0cmluZyIsInRvUmF3VHlwZSIsImlzUmVnRXhwIiwiaXNWYWxpZEFycmF5SW5kZXgiLCJ2YWwiLCJwYXJzZUZsb2F0IiwiZmxvb3IiLCJpc0Zpbml0ZSIsImlzUHJvbWlzZSIsImNhdGNoIiwic3RyaW5naWZ5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibGlzdCIsInNwbGl0IiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJpc1Jlc2VydmVkQXR0cmlidXRlIiwicmVtb3ZlIiwiYXJyIiwiaXRlbSIsImluZGV4T2YiLCJoYXNPd24iLCJjYWNoZWQiLCJmbiIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiX2xlbmd0aCIsIm5hdGl2ZUJpbmQiLCJiaW5kIiwidG9BcnJheSIsInJldCIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJ0b09iamVjdCIsInJlcyIsImIiLCJubyIsImdlblN0YXRpY0tleXMiLCJtb2R1bGVzIiwicmVkdWNlIiwibSIsInN0YXRpY0tleXMiLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsImV2ZXJ5IiwiZ2V0VGltZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwid2FybkhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiYXN5bmMiLCJfbGlmZWN5Y2xlSG9va3MiLCJ1bmljb2RlTGV0dGVycyIsImlzUmVzZXJ2ZWQiLCJkZWYiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJiYWlsUkUiLCJwYXJzZVBhdGgiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwiaXNQaGFudG9tSlMiLCJpc0ZGIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlclJlbmRlcmluZyIsImVudiIsIlZVRV9FTlYiLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaXNOYXRpdmUiLCJoYXNTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJ3YXJuIiwidGlwIiwiZ2VuZXJhdGVDb21wb25lbnRUcmFjZSIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJ0cmFjZSIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJjaWQiLCJfaXNWdWUiLCIkb3B0aW9ucyIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwicmVwZWF0IiwiJHBhcmVudCIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJsYXN0IiwiRGVwIiwiaWQiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwiYWRkRGVwIiwibm90aWZ5IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwicG9wVGFyZ2V0IiwiVk5vZGUiLCJjaGlsZHJlbiIsImVsbSIsImNvbnRleHQiLCJjb21wb25lbnRPcHRpb25zIiwiYXN5bmNGYWN0b3J5IiwibnMiLCJmbkNvbnRleHQiLCJmbk9wdGlvbnMiLCJmblNjb3BlSWQiLCJjb21wb25lbnRJbnN0YW5jZSIsInBhcmVudCIsInJhdyIsImlzU3RhdGljIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJhc3luY01ldGEiLCJpc0FzeW5jUGxhY2Vob2xkZXIiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJjaGlsZCIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJub2RlIiwiY3JlYXRlVGV4dFZOb2RlIiwiY2xvbmVWTm9kZSIsInZub2RlIiwiY2xvbmVkIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kc1RvUGF0Y2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInNob3VsZE9ic2VydmUiLCJ0b2dnbGVPYnNlcnZpbmciLCJPYnNlcnZlciIsInZtQ291bnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSQkMSIsIm9ic2VydmUiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJkZWwiLCJzdHJhdHMiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImRlZHVwZUhvb2tzIiwiaG9va3MiLCJob29rIiwibWVyZ2VBc3NldHMiLCJhc3NlcnRPYmplY3RUeXBlIiwibWV0aG9kcyIsImluamVjdCIsImNvbXB1dGVkIiwicHJvdmlkZSIsImNoZWNrQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJ2YWxpZGF0ZUNvbXBvbmVudE5hbWUiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJkZWYkJDEiLCJtZXJnZU9wdGlvbnMiLCJfYmFzZSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJwcm9wIiwiYWJzZW50IiwiYm9vbGVhbkluZGV4IiwiZ2V0VHlwZUluZGV4IiwiQm9vbGVhbiIsInN0cmluZ0luZGV4IiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRPYnNlcnZlIiwiYXNzZXJ0UHJvcCIsImRlZmF1bHQiLCJfcHJvcHMiLCJnZXRUeXBlIiwicmVxdWlyZWQiLCJ2YWxpZCIsImV4cGVjdGVkVHlwZXMiLCJhc3NlcnRlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZXhwZWN0ZWRUeXBlIiwiZ2V0SW52YWxpZFR5cGVNZXNzYWdlIiwidmFsaWRhdG9yIiwic2ltcGxlQ2hlY2tSRSIsInQiLCJpc1NhbWVUeXBlIiwibGVuIiwicmVjZWl2ZWRUeXBlIiwiZXhwZWN0ZWRWYWx1ZSIsInN0eWxlVmFsdWUiLCJyZWNlaXZlZFZhbHVlIiwiaXNFeHBsaWNhYmxlIiwiaXNCb29sZWFuIiwiTnVtYmVyIiwiZXhwbGljaXRUeXBlcyIsInNvbWUiLCJlbGVtIiwiaGFuZGxlRXJyb3IiLCJlcnIiLCJpbmZvIiwiY3VyIiwiZXJyb3JDYXB0dXJlZCIsImNhcHR1cmUiLCJnbG9iYWxIYW5kbGVFcnJvciIsImludm9rZVdpdGhFcnJvckhhbmRsaW5nIiwiaGFuZGxlciIsImxvZ0Vycm9yIiwiaXNVc2luZ01pY3JvVGFzayIsImNhbGxiYWNrcyIsInBlbmRpbmciLCJmbHVzaENhbGxiYWNrcyIsImNvcGllcyIsInRpbWVyRnVuYyIsInAiLCJzZXRUaW1lb3V0IiwiTXV0YXRpb25PYnNlcnZlciIsImNvdW50ZXIiLCJvYnNlcnZlciIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJjaGFyYWN0ZXJEYXRhIiwic2V0SW1tZWRpYXRlIiwibmV4dFRpY2siLCJjYiIsIl9yZXNvbHZlIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJ3YXJuUmVzZXJ2ZWRQcmVmaXgiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiJGRhdGEiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5Iiwic2Vlbk9iamVjdHMiLCJ0cmF2ZXJzZSIsIl90cmF2ZXJzZSIsImlzQSIsImlzRnJvemVuIiwiZGVwSWQiLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY3JlYXRlRm5JbnZva2VyIiwiZm5zIiwiaW52b2tlciIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9sZCIsInBhcmFtcyIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJhdHRycyIsImFsdEtleSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsInNoaWZ0IiwiX2lzVkxpc3QiLCJpbml0UHJvdmlkZSIsIl9wcm92aWRlZCIsImluaXRJbmplY3Rpb25zIiwicmVzb2x2ZUluamVjdCIsInByb3ZpZGVLZXkiLCJwcm92aWRlRGVmYXVsdCIsInJlc29sdmVTbG90cyIsInNsb3RzIiwic2xvdCIsImlzV2hpdGVzcGFjZSIsIm5vcm1hbGl6ZVNjb3BlZFNsb3RzIiwibm9ybWFsU2xvdHMiLCJwcmV2U2xvdHMiLCJfbm9ybWFsaXplZCIsIiRzdGFibGUiLCJub3JtYWxpemVTY29wZWRTbG90IiwicHJveHlOb3JtYWxTbG90IiwicHJveHkiLCJyZW5kZXJMaXN0IiwiaXRlcmF0b3IiLCJuZXh0IiwiZG9uZSIsInJlbmRlclNsb3QiLCJmYWxsYmFjayIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCIkc2NvcGVkU2xvdHMiLCJub2RlcyIsIiRzbG90cyIsIiRjcmVhdGVFbGVtZW50IiwicmVzb2x2ZUZpbHRlciIsImlzS2V5Tm90TWF0Y2giLCJleHBlY3QiLCJhY3R1YWwiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbktleUNvZGUiLCJldmVudEtleU5hbWUiLCJidWlsdEluS2V5TmFtZSIsIm1hcHBlZEtleUNvZGUiLCJiaW5kT2JqZWN0UHJvcHMiLCJhc1Byb3AiLCJpc1N5bmMiLCJkb21Qcm9wcyIsImNhbWVsaXplZEtleSIsIiRldmVudCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJfc3RhdGljVHJlZXMiLCJzdGF0aWNSZW5kZXJGbnMiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJleGlzdGluZyIsIm91cnMiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJoYXNEeW5hbWljS2V5cyIsImJpbmREeW5hbWljS2V5cyIsImJhc2VPYmoiLCJwcmVwZW5kTW9kaWZpZXIiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIl9kIiwiX3AiLCJGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCIsImNvbnRleHRWbSIsIl9vcmlnaW5hbCIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsImxpc3RlbmVycyIsImluamVjdGlvbnMiLCJzY29wZWRTbG90cyIsIl9zY29wZUlkIiwiX2MiLCJjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibWVyZ2VQcm9wcyIsInJlbmRlckNvbnRleHQiLCJjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0Iiwidm5vZGVzIiwiY2xvbmUiLCJkZXZ0b29sc01ldGEiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwiaHlkcmF0aW5nIiwiX2lzRGVzdHJveWVkIiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCJhY3RpdmVJbnN0YW5jZSIsIiRtb3VudCIsIm9sZFZub2RlIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJpbnNlcnQiLCJfaXNNb3VudGVkIiwiY2FsbEhvb2siLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkZXN0cm95IiwiJGRlc3Ryb3kiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJiYXNlQ3RvciIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsImFic3RyYWN0IiwiaW5zdGFsbENvbXBvbmVudEhvb2tzIiwiX2lzQ29tcG9uZW50IiwiX3BhcmVudFZub2RlIiwiaW5saW5lVGVtcGxhdGUiLCJ0b01lcmdlIiwiX21lcmdlZCIsIm1lcmdlSG9vayQxIiwiZjEiLCJmMiIsImNhbGxiYWNrIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiaXMiLCIkdm5vZGUiLCJwcmUiLCJhcHBseU5TIiwicmVnaXN0ZXJEZWVwQmluZGluZ3MiLCJmb3JjZSIsInN0eWxlIiwiY2xhc3MiLCJpbml0UmVuZGVyIiwiX3Zub2RlIiwicGFyZW50Vm5vZGUiLCJfcmVuZGVyQ2hpbGRyZW4iLCJwYXJlbnREYXRhIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiX3BhcmVudExpc3RlbmVycyIsImN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSIsInJlbmRlck1peGluIiwiVnVlIiwiJG5leHRUaWNrIiwicmVuZGVyRXJyb3IiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwiZmFjdG9yeSIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwib3duZXIiLCJvd25lcnMiLCJzeW5jIiwiZm9yY2VSZW5kZXIiLCJyZW5kZXJDb21wbGV0ZWQiLCIkZm9yY2VVcGRhdGUiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsInRpbWVvdXQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uIiwicmVtb3ZlJDEiLCIkb2ZmIiwiX3RhcmdldCIsIm9uY2VIYW5kbGVyIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJob29rUkUiLCIkb25jZSIsImNicyIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJzZXRBY3RpdmVJbnN0YW5jZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsImluaXRMaWZlY3ljbGUiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2luYWN0aXZlIiwiX2RpcmVjdEluYWN0aXZlIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJyZXN0b3JlQWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfX3Z1ZV9fIiwidGVhcmRvd24iLCJfd2F0Y2hlcnMiLCJfZGF0YSIsIm1vdW50Q29tcG9uZW50IiwidXBkYXRlQ29tcG9uZW50IiwiX25hbWUiLCJfdWlkIiwiV2F0Y2hlciIsImJlZm9yZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzRHluYW1pY1Njb3BlZFNsb3QiLCJuZWVkc0ZvcmNlVXBkYXRlIiwiJGF0dHJzIiwiJGxpc3RlbmVycyIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiaXNJbkluYWN0aXZlVHJlZSIsImRpcmVjdCIsImoiLCJNQVhfVVBEQVRFX0NPVU5UIiwicXVldWUiLCJhY3RpdmF0ZWRDaGlsZHJlbiIsImNpcmN1bGFyIiwid2FpdGluZyIsImZsdXNoaW5nIiwicmVzZXRTY2hlZHVsZXJTdGF0ZSIsImN1cnJlbnRGbHVzaFRpbWVzdGFtcCIsImdldE5vdyIsImNyZWF0ZUV2ZW50IiwidGltZVN0YW1wIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJydW4iLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsImVtaXQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMiIsImV4cE9yRm4iLCJpc1JlbmRlcldhdGNoZXIiLCJkZWVwIiwibGF6eSIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJjbGVhbnVwRGVwcyIsInRtcCIsIm9sZFZhbHVlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwic291cmNlS2V5IiwicHJveHlHZXR0ZXIiLCJwcm94eVNldHRlciIsImluaXRTdGF0ZSIsImluaXRQcm9wcyIsImluaXRNZXRob2RzIiwiaW5pdERhdGEiLCJpbml0Q29tcHV0ZWQiLCJpbml0V2F0Y2giLCJwcm9wc09wdGlvbnMiLCJpc1Jvb3QiLCJoeXBoZW5hdGVkS2V5IiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwiaXNTU1IiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCJzaG91bGRDYWNoZSIsImNyZWF0ZUNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlR2V0dGVySW52b2tlciIsImNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlV2F0Y2hlciIsIiR3YXRjaCIsInN0YXRlTWl4aW4iLCJkYXRhRGVmIiwicHJvcHNEZWYiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsInVpZCQzIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJpbml0VXNlIiwidXNlIiwicGx1Z2luIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl9pbnN0YWxsZWRQbHVnaW5zIiwidW5zaGlmdCIsImluc3RhbGwiLCJpbml0TWl4aW4kMSIsIm1peGluIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnROYW1lIiwicHJ1bmVDYWNoZSIsImtlZXBBbGl2ZUluc3RhbmNlIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsImN1cnJlbnQiLCJjYWNoZWQkJDEiLCJwYXR0ZXJuVHlwZXMiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNyZWF0ZWQiLCJkZXN0cm95ZWQiLCJtb3VudGVkIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJkZWxldGUiLCJvYnNlcnZhYmxlIiwic3NyQ29udGV4dCIsInZlcnNpb24iLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlIiwiY29udmVydEVudW1lcmF0ZWRWYWx1ZSIsImlzRmFsc3lBdHRyVmFsdWUiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwic2VsZWN0ZWQiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJyZW1vdmVDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsInNldFN0eWxlU2NvcGUiLCJzY29wZUlkIiwibm9kZU9wcyIsInJlZiIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpc1Vua25vd25FbGVtZW50JCQxIiwiaW5WUHJlIiwiaWdub3JlIiwiY3JlYXRpbmdFbG1JblZQcmUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJuZXN0ZWQiLCJvd25lckFycmF5Iiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJlbmQiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsIl9sZWF2ZUNiIiwicGF0Y2hhYmxlIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImNhbGxIb29rJDEiLCJvbGRBcmciLCJjb21wb25lbnRVcGRhdGVkIiwiY2FsbEluc2VydCIsImVtcHR5TW9kaWZpZXJzIiwibW9kaWZpZXJzIiwiZ2V0UmF3RGlyTmFtZSIsInJhd05hbWUiLCJiYXNlTW9kdWxlcyIsInVwZGF0ZUF0dHJzIiwiaW5oZXJpdEF0dHJzIiwib2xkQXR0cnMiLCJzZXRBdHRyIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJiYXNlU2V0QXR0ciIsInNldEF0dHJpYnV0ZU5TIiwiX19pZXBoIiwiYmxvY2tlciIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwicHJldiIsImZpbHRlcnMiLCJ0cmltIiwicHVzaEZpbHRlciIsIndyYXBGaWx0ZXIiLCJiYXNlV2FybiIsInJhbmdlIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJkeW5hbWljIiwicmFuZ2VTZXRJdGVtIiwicGxhaW4iLCJhZGRBdHRyIiwiZHluYW1pY0F0dHJzIiwiYWRkUmF3QXR0ciIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiYWRkRGlyZWN0aXZlIiwiaXNEeW5hbWljQXJnIiwicHJlcGVuZE1vZGlmaWVyTWFya2VyIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJyaWdodCIsIm1pZGRsZSIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRSYXdCaW5kaW5nQXR0ciIsInJhd0F0dHJzTWFwIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJyZW1vdmVGcm9tTWFwIiwiZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgiLCJnZW5Db21wb25lbnRNb2RlbCIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJwYXJzZU1vZGVsIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwiZW9mIiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0IiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJnZW5TZWxlY3QiLCJnZW5DaGVja2JveE1vZGVsIiwiZ2VuUmFkaW9Nb2RlbCIsImdlbkRlZmF1bHRNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsInNlbGVjdGVkVmFsIiwiY29kZSIsInR5cGVCaW5kaW5nIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyJDEiLCJyZW1vdmUkMiIsInVzZU1pY3JvdGFza0ZpeCIsImFkZCQxIiwiYXR0YWNoZWRUaW1lc3RhbXAiLCJfd3JhcHBlciIsImN1cnJlbnRUYXJnZXQiLCJvd25lckRvY3VtZW50IiwidXBkYXRlRE9NTGlzdGVuZXJzIiwic3ZnQ29udGFpbmVyIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc05vdEluRm9jdXNBbmREaXJ0eSIsImlzRGlydHlXaXRoTW9kaWZpZXJzIiwibm90SW5Gb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsIm5vcm1hbGl6ZVN0eWxlQmluZGluZyIsInN0YXRpY1N0eWxlIiwiYmluZGluZ1N0eWxlIiwiZ2V0U3R5bGUiLCJjaGVja0NoaWxkIiwic3R5bGVEYXRhIiwiY3NzVmFyUkUiLCJpbXBvcnRhbnRSRSIsInNldFByb3AiLCJzZXRQcm9wZXJ0eSIsIm5vcm1hbGl6ZWROYW1lIiwibm9ybWFsaXplIiwidmVuZG9yTmFtZXMiLCJlbXB0eVN0eWxlIiwiY2FwTmFtZSIsInVwZGF0ZVN0eWxlIiwib2xkU3RhdGljU3R5bGUiLCJvbGRTdHlsZUJpbmRpbmciLCJub3JtYWxpemVkU3R5bGUiLCJvbGRTdHlsZSIsIm5ld1N0eWxlIiwid2hpdGVzcGFjZVJFIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsInRhciIsInJlc29sdmVUcmFuc2l0aW9uIiwiY3NzIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJlbnRlckNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImxlYXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwiaGFzVHJhbnNpdGlvbiIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvblByb3AiLCJhbmltYXRpb25FbmRFdmVudCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ud2Via2l0dHJhbnNpdGlvbmVuZCIsIm9uYW5pbWF0aW9uZW5kIiwib253ZWJraXRhbmltYXRpb25lbmQiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJ0cmFuc2l0aW9uQ2xhc3NlcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwiZW5kZWQiLCJvbkVuZCIsInByb3BDb3VudCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJhcHBlYXIiLCJzdGFydENsYXNzIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiYmVmb3JlQXBwZWFyIiwiYmVmb3JlRW50ZXIiLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImFmdGVyQXBwZWFyIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkSG9vayIsImFwcGVhckNhbmNlbGxlZCIsImVudGVyQ2FuY2VsbGVkIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiZHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsImxlYXZlQ2FuY2VsbGVkIiwiYWZ0ZXJMZWF2ZSIsImRlbGF5TGVhdmUiLCJwZXJmb3JtTGVhdmUiLCJiZWZvcmVMZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJ0cmlnZ2VyIiwiZGlyZWN0aXZlIiwiX3ZPcHRpb25zIiwic2V0U2VsZWN0ZWQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwicGxhY2Vob2xkZXIiLCJoIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsImlzTm90VGV4dE5vZGUiLCJpc1ZTaG93RGlyZWN0aXZlIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJiZWZvcmVNb3VudCIsImtlcHQiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwicmVtb3ZlZCIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJfcmVmbG93Iiwib2Zmc2V0SGVpZ2h0IiwibW92ZWQiLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsImRlZmF1bHRUYWdSRSIsInJlZ2V4RXNjYXBlUkUiLCJidWlsZFJlZ2V4IiwiZGVsaW1pdGVycyIsImNsb3NlIiwicGFyc2VUZXh0IiwidGFnUkUiLCJ0b2tlbnMiLCJyYXdUb2tlbnMiLCJ0b2tlblZhbHVlIiwidHJhbnNmb3JtTm9kZSIsImNsYXNzQmluZGluZyIsImdlbkRhdGEiLCJrbGFzcyQxIiwidHJhbnNmb3JtTm9kZSQxIiwic3R5bGVCaW5kaW5nIiwiZ2VuRGF0YSQxIiwic3R5bGUkMSIsImRlY29kZXIiLCJoZSIsImRlY29kZSIsImh0bWwiLCJpc1VuYXJ5VGFnIiwiY2FuQmVMZWZ0T3BlblRhZyIsImlzTm9uUGhyYXNpbmdUYWciLCJhdHRyaWJ1dGUiLCJkeW5hbWljQXJnQXR0cmlidXRlIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImlzSWdub3JlTmV3bGluZVRhZyIsInNob3VsZElnbm9yZUZpcnN0TmV3bGluZSIsImRlY29kZUF0dHIiLCJzaG91bGREZWNvZGVOZXdsaW5lcyIsInJlIiwicGFyc2VIVE1MIiwiZXhwZWN0SFRNTCIsImlzVW5hcnlUYWckJDEiLCJjYW5CZUxlZnRPcGVuVGFnJCQxIiwibGFzdFRhZyIsInRleHRFbmQiLCJjb21tZW50RW5kIiwic2hvdWxkS2VlcENvbW1lbnQiLCJzdWJzdHJpbmciLCJhZHZhbmNlIiwiY29uZGl0aW9uYWxFbmQiLCJkb2N0eXBlTWF0Y2giLCJlbmRUYWdNYXRjaCIsImN1ckluZGV4IiwicGFyc2VFbmRUYWciLCJzdGFydFRhZ01hdGNoIiwicGFyc2VTdGFydFRhZyIsImhhbmRsZVN0YXJ0VGFnIiwicmVzdCIsImNoYXJzIiwiZW5kVGFnTGVuZ3RoIiwic3RhY2tlZFRhZyIsInJlU3RhY2tlZFRhZyIsImFsbCIsInVuYXJ5U2xhc2giLCJ1bmFyeSIsInNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZiIsIm91dHB1dFNvdXJjZVJhbmdlIiwibG93ZXJDYXNlZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJzdHJpcFBhcmVuc1JFIiwiZHluYW1pY0FyZ1JFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwic2xvdFJFIiwibGluZUJyZWFrUkUiLCJ3aGl0ZXNwYWNlUkUkMSIsImludmFsaWRBdHRyaWJ1dGVSRSIsImRlY29kZUhUTUxDYWNoZWQiLCJlbXB0eVNsb3RTY29wZVRva2VuIiwid2FybiQyIiwidHJhbnNmb3JtcyIsInByZVRyYW5zZm9ybXMiLCJwb3N0VHJhbnNmb3JtcyIsInBsYXRmb3JtSXNQcmVUYWciLCJwbGF0Zm9ybU11c3RVc2VQcm9wIiwicGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UiLCJtYXliZUNvbXBvbmVudCIsImNyZWF0ZUFTVEVsZW1lbnQiLCJtYWtlQXR0cnNNYXAiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJ3aGl0ZXNwYWNlT3B0aW9uIiwid2hpdGVzcGFjZSIsImN1cnJlbnRQYXJlbnQiLCJpblByZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiY2xvc2VFbGVtZW50IiwidHJpbUVuZGluZ1doaXRlc3BhY2UiLCJwcm9jZXNzZWQiLCJwcm9jZXNzRWxlbWVudCIsImlmIiwiZWxzZWlmIiwiZWxzZSIsImNoZWNrUm9vdENvbnN0cmFpbnRzIiwiYWRkSWZDb25kaXRpb24iLCJibG9jayIsImZvcmJpZGRlbiIsInByb2Nlc3NJZkNvbmRpdGlvbnMiLCJzbG90U2NvcGUiLCJzbG90VGFyZ2V0IiwibGFzdE5vZGUiLCJjb21tZW50cyIsImd1YXJkSUVTVkdCdWciLCJjdW11bGF0ZWQiLCJpc0ZvcmJpZGRlblRhZyIsInByb2Nlc3NQcmUiLCJwcm9jZXNzUmF3QXR0cnMiLCJwcm9jZXNzRm9yIiwicHJvY2Vzc0lmIiwicHJvY2Vzc09uY2UiLCJpc1RleHRUYWciLCJwcm9jZXNzS2V5IiwicHJvY2Vzc1JlZiIsInByb2Nlc3NTbG90Q29udGVudCIsInByb2Nlc3NTbG90T3V0bGV0IiwicHJvY2Vzc0NvbXBvbmVudCIsInByb2Nlc3NBdHRycyIsImZvciIsIml0ZXJhdG9yMiIsIml0ZXJhdG9yMSIsImNoZWNrSW5Gb3IiLCJwYXJzZUZvciIsImluTWF0Y2giLCJhbGlhcyIsIml0ZXJhdG9yTWF0Y2giLCJmaW5kUHJldkVsZW1lbnQiLCJjb25kaXRpb24iLCJpZkNvbmRpdGlvbnMiLCJzbG90VGFyZ2V0RHluYW1pYyIsInNsb3RCaW5kaW5nIiwiZ2V0U2xvdE5hbWUiLCJzbG90Q29udGFpbmVyIiwic2xvdE5hbWUiLCJzeW5jR2VuIiwiaXNEeW5hbWljIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsInByZVRyYW5zZm9ybU5vZGUiLCJpZkNvbmRpdGlvbiIsImlmQ29uZGl0aW9uRXh0cmEiLCJoYXNFbHNlIiwiZWxzZUlmQ29uZGl0aW9uIiwiYnJhbmNoMCIsImNsb25lQVNURWxlbWVudCIsImJyYW5jaDEiLCJicmFuY2gyIiwibW9kZWwkMSIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsImJhc2VPcHRpb25zIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJmbkludm9rZVJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsImRvd24iLCJrZXlOYW1lcyIsImdlbkd1YXJkIiwibW9kaWZpZXJDb2RlIiwic3RvcCIsImN0cmwiLCJhbHQiLCJtZXRhIiwiZ2VuSGFuZGxlcnMiLCJwcmVmaXgiLCJzdGF0aWNIYW5kbGVycyIsImR5bmFtaWNIYW5kbGVycyIsImhhbmRsZXJDb2RlIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiaXNGdW5jdGlvbkludm9jYXRpb24iLCJnZW5Nb2RpZmllckNvZGUiLCJrZXlNb2RpZmllciIsImdlbktleUZpbHRlciIsImdlbkZpbHRlckNvZGUiLCJrZXlWYWwiLCJrZXlDb2RlIiwia2V5TmFtZSIsIndyYXBMaXN0ZW5lcnMiLCJiaW5kJDEiLCJ3cmFwRGF0YSIsImJhc2VEaXJlY3RpdmVzIiwiY2xvYWsiLCJDb2RlZ2VuU3RhdGUiLCJkYXRhR2VuRm5zIiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJzdGF0ZSIsImdlbkVsZW1lbnQiLCJzdGF0aWNQcm9jZXNzZWQiLCJnZW5TdGF0aWMiLCJvbmNlUHJvY2Vzc2VkIiwiZ2VuT25jZSIsImZvclByb2Nlc3NlZCIsImdlbkZvciIsImlmUHJvY2Vzc2VkIiwiZ2VuSWYiLCJnZW5DaGlsZHJlbiIsImdlblNsb3QiLCJnZW5Db21wb25lbnQiLCJnZW5EYXRhJDIiLCJvcmlnaW5hbFByZVN0YXRlIiwiYWx0R2VuIiwiYWx0RW1wdHkiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsImFsdEhlbHBlciIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJjb250YWluc1Nsb3RDaGlsZCIsImdlblNjb3BlZFNsb3QiLCJpc0xlZ2FjeVN5bnRheCIsInJldmVyc2VQcm94eSIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZ2V0Tm9ybWFsaXphdGlvblR5cGUiLCJnZW5Ob2RlIiwibmVlZHNOb3JtYWxpemF0aW9uIiwiZ2VuQ29tbWVudCIsImdlblRleHQiLCJ0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMiLCJiaW5kJCQxIiwiY29tcG9uZW50TmFtZSIsInN0YXRpY1Byb3BzIiwiZHluYW1pY1Byb3BzIiwicHJvaGliaXRlZEtleXdvcmRSRSIsInVuYXJ5T3BlcmF0b3JzUkUiLCJzdHJpcFN0cmluZ1JFIiwiZGV0ZWN0RXJyb3JzIiwiY2hlY2tOb2RlIiwiY2hlY2tGb3IiLCJjaGVja0V2ZW50IiwiY2hlY2tFeHByZXNzaW9uIiwic3RpcHBlZCIsImtleXdvcmRNYXRjaCIsImNoZWNrSWRlbnRpZmllciIsImlkZW50IiwiZ2VuZXJhdGVDb2RlRnJhbWUiLCJsaW5lcyIsImxpbmVMZW5ndGgiLCJwYWQiLCJjcmVhdGVGdW5jdGlvbiIsImVycm9ycyIsImNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4iLCJjb21waWxlIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwid2FybiQkMSIsInRpcHMiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJsZWFkaW5nU3BhY2VMZW5ndGgiLCJkaXYiLCJnZXRTaG91bGREZWNvZGUiLCJocmVmIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiLCJTZWxlY3REYXRhIiwiU2VsZWN0IiwiU2VsZWN0Q29tcG9uZW50IiwiX2NvbnN0YW50cyIsImRhdGFIYW5kbGVyIiwibmV3RGF0YSIsImNoYXJ0IiwiX2NoYXJ0IiwibmV3RGF0YXNldExhYmVscyIsImRhdGFzZXRzIiwib2xkRGF0YXNldExhYmVscyIsIm9sZExhYmVscyIsIm5ld0xhYmVscyIsIm9sZERhdGFzZXRLZXlzIiwibmV3RGF0YXNldEtleXMiLCJkZWxldGlvbktleXMiLCJkZWxldGlvbktleSIsImxhYmVscyIsInhMYWJlbHMiLCJ5TGFiZWxzIiwicmVuZGVyQ2hhcnQiLCJjaGFydERhdGEiLCJyZWFjdGl2ZURhdGEiLCJyZWFjdGl2ZVByb3AiLCJob29rQ2FsbGJhY2siLCJzZXRIb29rQ2FsbGJhY2siLCJpbnB1dCIsImlzT2JqZWN0RW1wdHkiLCJpc1VuZGVmaW5lZCIsImlzTnVtYmVyIiwiaXNEYXRlIiwiaGFzT3duUHJvcCIsImNyZWF0ZVVUQyIsImZvcm1hdCIsImxvY2FsZSIsInN0cmljdCIsImNyZWF0ZUxvY2FsT3JVVEMiLCJ1dGMiLCJkZWZhdWx0UGFyc2luZ0ZsYWdzIiwiZW1wdHkiLCJ1bnVzZWRUb2tlbnMiLCJ1bnVzZWRJbnB1dCIsIm92ZXJmbG93IiwiY2hhcnNMZWZ0T3ZlciIsIm51bGxJbnB1dCIsImludmFsaWRNb250aCIsImludmFsaWRGb3JtYXQiLCJ1c2VySW52YWxpZGF0ZWQiLCJpc28iLCJwYXJzZWREYXRlUGFydHMiLCJtZXJpZGllbSIsInJmYzI4MjIiLCJ3ZWVrZGF5TWlzbWF0Y2giLCJnZXRQYXJzaW5nRmxhZ3MiLCJfcGYiLCJmdW4iLCJpc1ZhbGlkIiwiX2lzVmFsaWQiLCJmbGFncyIsInBhcnNlZFBhcnRzIiwiaXNOb3dWYWxpZCIsImludmFsaWRXZWVrZGF5IiwiX3N0cmljdCIsImJpZ0hvdXIiLCJjcmVhdGVJbnZhbGlkIiwiTmFOIiwibW9tZW50UHJvcGVydGllcyIsImNvcHlDb25maWciLCJfaXNBTW9tZW50T2JqZWN0IiwiX3R6bSIsIl9pc1VUQyIsIl9vZmZzZXQiLCJfbG9jYWxlIiwidXBkYXRlSW5Qcm9ncmVzcyIsIk1vbWVudCIsInVwZGF0ZU9mZnNldCIsImlzTW9tZW50IiwiYWJzRmxvb3IiLCJjZWlsIiwidG9JbnQiLCJhcmd1bWVudEZvckNvZXJjaW9uIiwiY29lcmNlZE51bWJlciIsImNvbXBhcmVBcnJheXMiLCJhcnJheTEiLCJhcnJheTIiLCJkb250Q29udmVydCIsImxlbmd0aERpZmYiLCJhYnMiLCJkaWZmcyIsInN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyIsImRlcHJlY2F0ZSIsImZpcnN0VGltZSIsImRlcHJlY2F0aW9uSGFuZGxlciIsImRlcHJlY2F0aW9ucyIsImRlcHJlY2F0ZVNpbXBsZSIsIl9jb25maWciLCJfZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQiLCJfZGF5T2ZNb250aE9yZGluYWxQYXJzZSIsIl9vcmRpbmFsUGFyc2UiLCJtZXJnZUNvbmZpZ3MiLCJwYXJlbnRDb25maWciLCJjaGlsZENvbmZpZyIsIkxvY2FsZSIsImRlZmF1bHRDYWxlbmRhciIsInNhbWVEYXkiLCJuZXh0RGF5IiwibmV4dFdlZWsiLCJsYXN0RGF5IiwibGFzdFdlZWsiLCJzYW1lRWxzZSIsImNhbGVuZGFyIiwibW9tIiwib3V0cHV0IiwiX2NhbGVuZGFyIiwiZGVmYXVsdExvbmdEYXRlRm9ybWF0IiwiTFRTIiwiTFQiLCJMIiwiTEwiLCJMTEwiLCJMTExMIiwibG9uZ0RhdGVGb3JtYXQiLCJfbG9uZ0RhdGVGb3JtYXQiLCJmb3JtYXRVcHBlciIsImRlZmF1bHRJbnZhbGlkRGF0ZSIsImludmFsaWREYXRlIiwiX2ludmFsaWREYXRlIiwiZGVmYXVsdE9yZGluYWwiLCJkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSIsIm9yZGluYWwiLCJfb3JkaW5hbCIsImRlZmF1bHRSZWxhdGl2ZVRpbWUiLCJmdXR1cmUiLCJwYXN0Iiwic3MiLCJtbSIsImhoIiwiZGQiLCJNIiwiTU0iLCJ5IiwieXkiLCJyZWxhdGl2ZVRpbWUiLCJ3aXRob3V0U3VmZml4IiwiaXNGdXR1cmUiLCJfcmVsYXRpdmVUaW1lIiwicGFzdEZ1dHVyZSIsImRpZmYiLCJhbGlhc2VzIiwiYWRkVW5pdEFsaWFzIiwidW5pdCIsInNob3J0aGFuZCIsImxvd2VyQ2FzZSIsIm5vcm1hbGl6ZVVuaXRzIiwidW5pdHMiLCJub3JtYWxpemVPYmplY3RVbml0cyIsImlucHV0T2JqZWN0Iiwibm9ybWFsaXplZElucHV0Iiwibm9ybWFsaXplZFByb3AiLCJwcmlvcml0aWVzIiwiYWRkVW5pdFByaW9yaXR5IiwicHJpb3JpdHkiLCJnZXRQcmlvcml0aXplZFVuaXRzIiwidW5pdHNPYmoiLCJ1IiwiemVyb0ZpbGwiLCJ0YXJnZXRMZW5ndGgiLCJmb3JjZVNpZ24iLCJhYnNOdW1iZXIiLCJ6ZXJvc1RvRmlsbCIsInNpZ24iLCJwb3ciLCJmb3JtYXR0aW5nVG9rZW5zIiwibG9jYWxGb3JtYXR0aW5nVG9rZW5zIiwiZm9ybWF0RnVuY3Rpb25zIiwiZm9ybWF0VG9rZW5GdW5jdGlvbnMiLCJhZGRGb3JtYXRUb2tlbiIsInRva2VuIiwicGFkZGVkIiwibG9jYWxlRGF0YSIsInJlbW92ZUZvcm1hdHRpbmdUb2tlbnMiLCJtYWtlRm9ybWF0RnVuY3Rpb24iLCJmb3JtYXRNb21lbnQiLCJleHBhbmRGb3JtYXQiLCJyZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMiLCJtYXRjaDEiLCJtYXRjaDIiLCJtYXRjaDMiLCJtYXRjaDQiLCJtYXRjaDYiLCJtYXRjaDF0bzIiLCJtYXRjaDN0bzQiLCJtYXRjaDV0bzYiLCJtYXRjaDF0bzMiLCJtYXRjaDF0bzQiLCJtYXRjaDF0bzYiLCJtYXRjaFVuc2lnbmVkIiwibWF0Y2hTaWduZWQiLCJtYXRjaE9mZnNldCIsIm1hdGNoU2hvcnRPZmZzZXQiLCJtYXRjaFRpbWVzdGFtcCIsIm1hdGNoV29yZCIsInJlZ2V4ZXMiLCJhZGRSZWdleFRva2VuIiwic3RyaWN0UmVnZXgiLCJpc1N0cmljdCIsImdldFBhcnNlUmVnZXhGb3JUb2tlbiIsInVuZXNjYXBlRm9ybWF0IiwicmVnZXhFc2NhcGUiLCJtYXRjaGVkIiwicDEiLCJwMiIsInAzIiwicDQiLCJhZGRQYXJzZVRva2VuIiwiYWRkV2Vla1BhcnNlVG9rZW4iLCJfdyIsImFkZFRpbWVUb0FycmF5RnJvbVRva2VuIiwiX2EiLCJZRUFSIiwiTU9OVEgiLCJEQVRFIiwiSE9VUiIsIk1JTlVURSIsIlNFQ09ORCIsIk1JTExJU0VDT05EIiwiV0VFSyIsIldFRUtEQVkiLCJwYXJzZVR3b0RpZ2l0WWVhciIsImRheXNJblllYXIiLCJpc0xlYXBZZWFyIiwiZ2V0U2V0WWVhciIsIm1ha2VHZXRTZXQiLCJnZXRJc0xlYXBZZWFyIiwia2VlcFRpbWUiLCJzZXQkMSIsImRheXNJbk1vbnRoIiwic3RyaW5nR2V0Iiwic3RyaW5nU2V0IiwicHJpb3JpdGl6ZWQiLCJtb2QiLCJ4IiwibW9kTW9udGgiLCJtb250aHNTaG9ydCIsIm1vbnRocyIsIm1vbnRoc1Nob3J0UmVnZXgiLCJtb250aHNSZWdleCIsIm1vbnRoc1BhcnNlIiwiTU9OVEhTX0lOX0ZPUk1BVCIsImRlZmF1bHRMb2NhbGVNb250aHMiLCJsb2NhbGVNb250aHMiLCJfbW9udGhzIiwiaXNGb3JtYXQiLCJkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQiLCJsb2NhbGVNb250aHNTaG9ydCIsIl9tb250aHNTaG9ydCIsImhhbmRsZVN0cmljdFBhcnNlIiwibW9udGhOYW1lIiwiaWkiLCJsbGMiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsIl9tb250aHNQYXJzZSIsIl9sb25nTW9udGhzUGFyc2UiLCJfc2hvcnRNb250aHNQYXJzZSIsImxvY2FsZU1vbnRoc1BhcnNlIiwiX21vbnRoc1BhcnNlRXhhY3QiLCJzZXRNb250aCIsImRheU9mTW9udGgiLCJnZXRTZXRNb250aCIsImdldERheXNJbk1vbnRoIiwiZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXgiLCJjb21wdXRlTW9udGhzUGFyc2UiLCJfbW9udGhzU2hvcnRTdHJpY3RSZWdleCIsIl9tb250aHNTaG9ydFJlZ2V4IiwiZGVmYXVsdE1vbnRoc1JlZ2V4IiwiX21vbnRoc1N0cmljdFJlZ2V4IiwiX21vbnRoc1JlZ2V4IiwiY21wTGVuUmV2Iiwic2hvcnRQaWVjZXMiLCJsb25nUGllY2VzIiwibWl4ZWRQaWVjZXMiLCJjcmVhdGVEYXRlIiwibXMiLCJnZXRGdWxsWWVhciIsInNldEZ1bGxZZWFyIiwiY3JlYXRlVVRDRGF0ZSIsIlVUQyIsImdldFVUQ0Z1bGxZZWFyIiwic2V0VVRDRnVsbFllYXIiLCJmaXJzdFdlZWtPZmZzZXQiLCJkb3ciLCJkb3kiLCJmd2QiLCJmd2RsdyIsImdldFVUQ0RheSIsImRheU9mWWVhckZyb21XZWVrcyIsIndlZWsiLCJ3ZWVrZGF5IiwibG9jYWxXZWVrZGF5Iiwid2Vla09mZnNldCIsImRheU9mWWVhciIsInJlc1llYXIiLCJyZXNEYXlPZlllYXIiLCJ3ZWVrT2ZZZWFyIiwicmVzV2VlayIsIndlZWtzSW5ZZWFyIiwid2Vla09mZnNldE5leHQiLCJsb2NhbGVXZWVrIiwiX3dlZWsiLCJkZWZhdWx0TG9jYWxlV2VlayIsImxvY2FsZUZpcnN0RGF5T2ZXZWVrIiwibG9jYWxlRmlyc3REYXlPZlllYXIiLCJnZXRTZXRXZWVrIiwiZ2V0U2V0SVNPV2VlayIsIndlZWtkYXlzTWluIiwid2Vla2RheXNTaG9ydCIsIndlZWtkYXlzIiwid2Vla2RheXNNaW5SZWdleCIsIndlZWtkYXlzU2hvcnRSZWdleCIsIndlZWtkYXlzUmVnZXgiLCJ3ZWVrZGF5c1BhcnNlIiwicGFyc2VXZWVrZGF5IiwicGFyc2VJc29XZWVrZGF5Iiwic2hpZnRXZWVrZGF5cyIsIndzIiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzIiwibG9jYWxlV2Vla2RheXMiLCJfd2Vla2RheXMiLCJkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCIsImxvY2FsZVdlZWtkYXlzU2hvcnQiLCJfd2Vla2RheXNTaG9ydCIsImRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiIsImxvY2FsZVdlZWtkYXlzTWluIiwiX3dlZWtkYXlzTWluIiwiaGFuZGxlU3RyaWN0UGFyc2UkMSIsIndlZWtkYXlOYW1lIiwiX3dlZWtkYXlzUGFyc2UiLCJfc2hvcnRXZWVrZGF5c1BhcnNlIiwiX21pbldlZWtkYXlzUGFyc2UiLCJsb2NhbGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzUGFyc2VFeGFjdCIsIl9mdWxsV2Vla2RheXNQYXJzZSIsImdldFNldERheU9mV2VlayIsImdldERheSIsImdldFNldExvY2FsZURheU9mV2VlayIsImdldFNldElTT0RheU9mV2VlayIsImRlZmF1bHRXZWVrZGF5c1JlZ2V4IiwiY29tcHV0ZVdlZWtkYXlzUGFyc2UiLCJfd2Vla2RheXNTdHJpY3RSZWdleCIsIl93ZWVrZGF5c1JlZ2V4IiwiZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCIsIl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXgiLCJfd2Vla2RheXNTaG9ydFJlZ2V4IiwiZGVmYXVsdFdlZWtkYXlzTWluUmVnZXgiLCJfd2Vla2RheXNNaW5TdHJpY3RSZWdleCIsIl93ZWVrZGF5c01pblJlZ2V4IiwibWluUGllY2VzIiwibWlucCIsInNob3J0cCIsImxvbmdwIiwiaEZvcm1hdCIsImhvdXJzIiwia0Zvcm1hdCIsIm1pbnV0ZXMiLCJzZWNvbmRzIiwibG93ZXJjYXNlIiwibWF0Y2hNZXJpZGllbSIsIl9tZXJpZGllbVBhcnNlIiwia0lucHV0IiwiX2lzUG0iLCJpc1BNIiwiX21lcmlkaWVtIiwicG9zMSIsInBvczIiLCJsb2NhbGVJc1BNIiwiZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UiLCJsb2NhbGVNZXJpZGllbSIsImlzTG93ZXIiLCJnZXRTZXRIb3VyIiwiYmFzZUNvbmZpZyIsImRheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJtZXJpZGllbVBhcnNlIiwibG9jYWxlcyIsImxvY2FsZUZhbWlsaWVzIiwiZ2xvYmFsTG9jYWxlIiwibm9ybWFsaXplTG9jYWxlIiwiY2hvb3NlTG9jYWxlIiwibmFtZXMiLCJsb2FkTG9jYWxlIiwib2xkTG9jYWxlIiwiX2FiYnIiLCJhbGlhc2VkUmVxdWlyZSIsImdldFNldEdsb2JhbExvY2FsZSIsImdldExvY2FsZSIsImRlZmluZUxvY2FsZSIsImFiYnIiLCJwYXJlbnRMb2NhbGUiLCJ1cGRhdGVMb2NhbGUiLCJ0bXBMb2NhbGUiLCJsaXN0TG9jYWxlcyIsImNoZWNrT3ZlcmZsb3ciLCJfb3ZlcmZsb3dEYXlPZlllYXIiLCJfb3ZlcmZsb3dXZWVrcyIsIl9vdmVyZmxvd1dlZWtkYXkiLCJkZWZhdWx0cyIsImN1cnJlbnREYXRlQXJyYXkiLCJub3dWYWx1ZSIsIl91c2VVVEMiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRNb250aCIsImdldERhdGUiLCJjb25maWdGcm9tQXJyYXkiLCJjdXJyZW50RGF0ZSIsImV4cGVjdGVkV2Vla2RheSIsInllYXJUb1VzZSIsImRheU9mWWVhckZyb21XZWVrSW5mbyIsIl9kYXlPZlllYXIiLCJfbmV4dERheSIsInNldFVUQ01pbnV0ZXMiLCJnZXRVVENNaW51dGVzIiwidyIsIndlZWtZZWFyIiwidGVtcCIsIndlZWtkYXlPdmVyZmxvdyIsIkdHIiwiVyIsIkUiLCJjcmVhdGVMb2NhbCIsImN1cldlZWsiLCJnZyIsImV4dGVuZGVkSXNvUmVnZXgiLCJiYXNpY0lzb1JlZ2V4IiwidHpSZWdleCIsImlzb0RhdGVzIiwiaXNvVGltZXMiLCJhc3BOZXRKc29uUmVnZXgiLCJjb25maWdGcm9tSVNPIiwiYWxsb3dUaW1lIiwiZGF0ZUZvcm1hdCIsInRpbWVGb3JtYXQiLCJ0ekZvcm1hdCIsImNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQiLCJleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzIiwieWVhclN0ciIsIm1vbnRoU3RyIiwiZGF5U3RyIiwiaG91clN0ciIsIm1pbnV0ZVN0ciIsInNlY29uZFN0ciIsInVudHJ1bmNhdGVZZWFyIiwicHJlcHJvY2Vzc1JGQzI4MjIiLCJjaGVja1dlZWtkYXkiLCJ3ZWVrZGF5U3RyIiwicGFyc2VkSW5wdXQiLCJ3ZWVrZGF5UHJvdmlkZWQiLCJ3ZWVrZGF5QWN0dWFsIiwib2JzT2Zmc2V0cyIsIlVUIiwiR01UIiwiRURUIiwiRVNUIiwiQ0RUIiwiQ1NUIiwiTURUIiwiTVNUIiwiUERUIiwiUFNUIiwiY2FsY3VsYXRlT2Zmc2V0Iiwib2JzT2Zmc2V0IiwibWlsaXRhcnlPZmZzZXQiLCJudW1PZmZzZXQiLCJobSIsImNvbmZpZ0Zyb21SRkMyODIyIiwicGFyc2VkQXJyYXkiLCJjb25maWdGcm9tU3RyaW5nIiwiY3JlYXRlRnJvbUlucHV0RmFsbGJhY2siLCJJU09fODYwMSIsIlJGQ18yODIyIiwic2tpcHBlZCIsInN0cmluZ0xlbmd0aCIsInRvdGFsUGFyc2VkSW5wdXRMZW5ndGgiLCJtZXJpZGllbUZpeFdyYXAiLCJob3VyIiwiaXNQbSIsIm1lcmlkaWVtSG91ciIsImNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheSIsInRlbXBDb25maWciLCJiZXN0TW9tZW50Iiwic2NvcmVUb0JlYXQiLCJjdXJyZW50U2NvcmUiLCJzY29yZSIsImNvbmZpZ0Zyb21PYmplY3QiLCJtaW51dGUiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsImNyZWF0ZUZyb21Db25maWciLCJwcmVwYXJlQ29uZmlnIiwicHJlcGFyc2UiLCJjb25maWdGcm9tSW5wdXQiLCJpc1VUQyIsInByb3RvdHlwZU1pbiIsInByb3RvdHlwZU1heCIsInBpY2tCeSIsIm1vbWVudHMiLCJvcmRlcmluZyIsImlzRHVyYXRpb25WYWxpZCIsInVuaXRIYXNEZWNpbWFsIiwiaXNWYWxpZCQxIiwiY3JlYXRlSW52YWxpZCQxIiwiY3JlYXRlRHVyYXRpb24iLCJEdXJhdGlvbiIsInllYXJzIiwicXVhcnRlcnMiLCJxdWFydGVyIiwid2Vla3MiLCJpc29XZWVrIiwiZGF5cyIsIm1pbGxpc2Vjb25kcyIsIl9taWxsaXNlY29uZHMiLCJfZGF5cyIsIl9idWJibGUiLCJpc0R1cmF0aW9uIiwiYWJzUm91bmQiLCJyb3VuZCIsInNlcGFyYXRvciIsInV0Y09mZnNldCIsIm9mZnNldEZyb21TdHJpbmciLCJjaHVua09mZnNldCIsIm1hdGNoZXIiLCJjaHVuayIsInBhcnRzIiwiY2xvbmVXaXRoT2Zmc2V0Iiwic2V0VGltZSIsImxvY2FsIiwiZ2V0RGF0ZU9mZnNldCIsImdldFRpbWV6b25lT2Zmc2V0IiwiZ2V0U2V0T2Zmc2V0Iiwia2VlcExvY2FsVGltZSIsImtlZXBNaW51dGVzIiwibG9jYWxBZGp1c3QiLCJfY2hhbmdlSW5Qcm9ncmVzcyIsImFkZFN1YnRyYWN0IiwiZ2V0U2V0Wm9uZSIsInNldE9mZnNldFRvVVRDIiwic2V0T2Zmc2V0VG9Mb2NhbCIsInN1YnRyYWN0Iiwic2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQiLCJ0Wm9uZSIsImhhc0FsaWduZWRIb3VyT2Zmc2V0IiwiaXNEYXlsaWdodFNhdmluZ1RpbWUiLCJpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQiLCJfaXNEU1RTaGlmdGVkIiwiaXNMb2NhbCIsImlzVXRjT2Zmc2V0IiwiaXNVdGMiLCJhc3BOZXRSZWdleCIsImlzb1JlZ2V4IiwiZGlmZlJlcyIsInBhcnNlSXNvIiwibW9tZW50c0RpZmZlcmVuY2UiLCJpbnZhbGlkIiwiaW5wIiwicG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZSIsImlzQWZ0ZXIiLCJpc0JlZm9yZSIsImNyZWF0ZUFkZGVyIiwiZGlyZWN0aW9uIiwicGVyaW9kIiwiZHVyIiwiaXNBZGRpbmciLCJnZXRDYWxlbmRhckZvcm1hdCIsIm15TW9tZW50IiwiY2FsZW5kYXIkMSIsInRpbWUiLCJmb3JtYXRzIiwic29kIiwic3RhcnRPZiIsImNhbGVuZGFyRm9ybWF0IiwibG9jYWxJbnB1dCIsImVuZE9mIiwiaXNCZXR3ZWVuIiwiaW5jbHVzaXZpdHkiLCJsb2NhbEZyb20iLCJsb2NhbFRvIiwiaXNTYW1lIiwiaW5wdXRNcyIsImlzU2FtZU9yQWZ0ZXIiLCJpc1NhbWVPckJlZm9yZSIsImFzRmxvYXQiLCJ0aGF0Iiwiem9uZURlbHRhIiwibW9udGhEaWZmIiwid2hvbGVNb250aERpZmYiLCJhbmNob3IiLCJhbmNob3IyIiwiYWRqdXN0IiwiZGVmYXVsdEZvcm1hdCIsImRlZmF1bHRGb3JtYXRVdGMiLCJ0b0lTT1N0cmluZyIsImtlZXBPZmZzZXQiLCJ0b0RhdGUiLCJpbnNwZWN0Iiwiem9uZSIsImRhdGV0aW1lIiwic3VmZml4IiwiaW5wdXRTdHJpbmciLCJwb3N0Zm9ybWF0IiwiaHVtYW5pemUiLCJmcm9tTm93IiwidG9Ob3ciLCJuZXdMb2NhbGVEYXRhIiwibGFuZyIsIk1TX1BFUl9TRUNPTkQiLCJNU19QRVJfTUlOVVRFIiwiTVNfUEVSX0hPVVIiLCJNU19QRVJfNDAwX1lFQVJTIiwibW9kJDEiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJsb2NhbFN0YXJ0T2ZEYXRlIiwidXRjU3RhcnRPZkRhdGUiLCJzdGFydE9mRGF0ZSIsImlzb1dlZWtkYXkiLCJ1bml4IiwidG9KU09OIiwiaXNWYWxpZCQyIiwicGFyc2luZ0ZsYWdzIiwiaW52YWxpZEF0IiwiY3JlYXRpb25EYXRhIiwiaXNvV2Vla1llYXIiLCJhZGRXZWVrWWVhckZvcm1hdFRva2VuIiwiZ2V0U2V0V2Vla1llYXIiLCJnZXRTZXRXZWVrWWVhckhlbHBlciIsImdldFNldElTT1dlZWtZZWFyIiwiZ2V0SVNPV2Vla3NJblllYXIiLCJnZXRXZWVrc0luWWVhciIsIndlZWtJbmZvIiwid2Vla3NUYXJnZXQiLCJzZXRXZWVrQWxsIiwiZGF5T2ZZZWFyRGF0YSIsImdldFNldFF1YXJ0ZXIiLCJnZXRTZXREYXlPZk1vbnRoIiwiZ2V0U2V0RGF5T2ZZZWFyIiwiZ2V0U2V0TWludXRlIiwiZ2V0U2V0U2Vjb25kIiwicGFyc2VNcyIsImdldFNldE1pbGxpc2Vjb25kIiwiZ2V0Wm9uZUFiYnIiLCJnZXRab25lTmFtZSIsImlzb1dlZWtzIiwiaXNvV2Vla3NJblllYXIiLCJwYXJzZVpvbmUiLCJpc0RTVCIsInpvbmVBYmJyIiwiem9uZU5hbWUiLCJkYXRlcyIsImlzRFNUU2hpZnRlZCIsImNyZWF0ZVVuaXgiLCJjcmVhdGVJblpvbmUiLCJwcmVQYXJzZVBvc3RGb3JtYXQiLCJwcm90byQxIiwiZmlyc3REYXlPZlllYXIiLCJmaXJzdERheU9mV2VlayIsImdldCQxIiwiZmllbGQiLCJsaXN0TW9udGhzSW1wbCIsIm91dCIsImxpc3RXZWVrZGF5c0ltcGwiLCJsb2NhbGVTb3J0ZWQiLCJsaXN0TW9udGhzIiwibGlzdE1vbnRoc1Nob3J0IiwibGlzdFdlZWtkYXlzIiwibGlzdFdlZWtkYXlzU2hvcnQiLCJsaXN0V2Vla2RheXNNaW4iLCJsYW5nRGF0YSIsIm1hdGhBYnMiLCJhZGRTdWJ0cmFjdCQxIiwic3VidHJhY3QkMSIsImFic0NlaWwiLCJidWJibGUiLCJtb250aHNGcm9tRGF5cyIsIm1vbnRoc1RvRGF5cyIsImRheXNUb01vbnRocyIsImFzIiwidmFsdWVPZiQxIiwibWFrZUFzIiwiYXNNaWxsaXNlY29uZHMiLCJhc1NlY29uZHMiLCJhc01pbnV0ZXMiLCJhc0hvdXJzIiwiYXNEYXlzIiwiYXNXZWVrcyIsImFzTW9udGhzIiwiYXNRdWFydGVycyIsImFzWWVhcnMiLCJjbG9uZSQxIiwiZ2V0JDIiLCJtYWtlR2V0dGVyIiwidGhyZXNob2xkcyIsInN1YnN0aXR1dGVUaW1lQWdvIiwicmVsYXRpdmVUaW1lJDEiLCJwb3NOZWdEdXJhdGlvbiIsImdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIiwicm91bmRpbmdGdW5jdGlvbiIsImdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCIsInRocmVzaG9sZCIsImxpbWl0Iiwid2l0aFN1ZmZpeCIsImFicyQxIiwidG9JU09TdHJpbmckMSIsIlkiLCJEIiwidG9GaXhlZCIsInRvdGFsIiwidG90YWxTaWduIiwieW1TaWduIiwiZGF5c1NpZ24iLCJobXNTaWduIiwicHJvdG8kMiIsInRvSXNvU3RyaW5nIiwicmVsYXRpdmVUaW1lUm91bmRpbmciLCJyZWxhdGl2ZVRpbWVUaHJlc2hvbGQiLCJIVE1MNV9GTVQiLCJEQVRFVElNRV9MT0NBTCIsIkRBVEVUSU1FX0xPQ0FMX1NFQ09ORFMiLCJEQVRFVElNRV9MT0NBTF9NUyIsIlRJTUUiLCJUSU1FX1NFQ09ORFMiLCJUSU1FX01TIiwicmVxdWlyZSQkMCIsIm1vbWVudCIsImNvbnZlcnNpb25zIiwicmdiMmhzbCIsInJnYjJoc3YiLCJyZ2IyaHdiIiwicmdiMmNteWsiLCJyZ2Iya2V5d29yZCIsInJnYjJ4eXoiLCJyZ2IybGFiIiwicmdiMmxjaCIsImhzbDJyZ2IiLCJoc2wyaHN2IiwiaHNsMmh3YiIsImhzbDJjbXlrIiwiaHNsMmtleXdvcmQiLCJoc3YycmdiIiwiaHN2MmhzbCIsImhzdjJod2IiLCJoc3YyY215ayIsImhzdjJrZXl3b3JkIiwiaHdiMnJnYiIsImh3YjJoc2wiLCJod2IyaHN2IiwiaHdiMmNteWsiLCJod2Iya2V5d29yZCIsImNteWsycmdiIiwiY215azJoc2wiLCJjbXlrMmhzdiIsImNteWsyaHdiIiwiY215azJrZXl3b3JkIiwia2V5d29yZDJyZ2IiLCJrZXl3b3JkMmhzbCIsImtleXdvcmQyaHN2Iiwia2V5d29yZDJod2IiLCJrZXl3b3JkMmNteWsiLCJrZXl3b3JkMmxhYiIsImtleXdvcmQyeHl6IiwieHl6MnJnYiIsInh5ejJsYWIiLCJ4eXoybGNoIiwibGFiMnh5eiIsImxhYjJyZ2IiLCJsYWIybGNoIiwibGNoMmxhYiIsImxjaDJ4eXoiLCJsY2gycmdiIiwicmdiIiwiciIsImciLCJkZWx0YSIsInJldmVyc2VLZXl3b3JkcyIsInoiLCJ4eXoiLCJoc2wiLCJ0MSIsInQyIiwidDMiLCJzdiIsImhzdiIsImhpIiwiZiIsInEiLCJzbCIsImh3YiIsIndoIiwiYmwiLCJyYXRpbyIsImNteWsiLCJsYWIiLCJ5MiIsImhyIiwiYXRhbjIiLCJQSSIsInNxcnQiLCJsY2giLCJjb3MiLCJzaW4iLCJrZXl3b3JkIiwiY3NzS2V5d29yZHMiLCJhbGljZWJsdWUiLCJhbnRpcXVld2hpdGUiLCJhcXVhIiwiYXF1YW1hcmluZSIsImF6dXJlIiwiYmVpZ2UiLCJiaXNxdWUiLCJibGFjayIsImJsYW5jaGVkYWxtb25kIiwiYmx1ZSIsImJsdWV2aW9sZXQiLCJicm93biIsImJ1cmx5d29vZCIsImNhZGV0Ymx1ZSIsImNoYXJ0cmV1c2UiLCJjaG9jb2xhdGUiLCJjb3JhbCIsImNvcm5mbG93ZXJibHVlIiwiY29ybnNpbGsiLCJjcmltc29uIiwiY3lhbiIsImRhcmtibHVlIiwiZGFya2N5YW4iLCJkYXJrZ29sZGVucm9kIiwiZGFya2dyYXkiLCJkYXJrZ3JlZW4iLCJkYXJrZ3JleSIsImRhcmtraGFraSIsImRhcmttYWdlbnRhIiwiZGFya29saXZlZ3JlZW4iLCJkYXJrb3JhbmdlIiwiZGFya29yY2hpZCIsImRhcmtyZWQiLCJkYXJrc2FsbW9uIiwiZGFya3NlYWdyZWVuIiwiZGFya3NsYXRlYmx1ZSIsImRhcmtzbGF0ZWdyYXkiLCJkYXJrc2xhdGVncmV5IiwiZGFya3R1cnF1b2lzZSIsImRhcmt2aW9sZXQiLCJkZWVwcGluayIsImRlZXBza3libHVlIiwiZGltZ3JheSIsImRpbWdyZXkiLCJkb2RnZXJibHVlIiwiZmlyZWJyaWNrIiwiZmxvcmFsd2hpdGUiLCJmb3Jlc3RncmVlbiIsImZ1Y2hzaWEiLCJnYWluc2Jvcm8iLCJnaG9zdHdoaXRlIiwiZ29sZCIsImdvbGRlbnJvZCIsImdyYXkiLCJncmVlbiIsImdyZWVueWVsbG93IiwiZ3JleSIsImhvbmV5ZGV3IiwiaG90cGluayIsImluZGlhbnJlZCIsImluZGlnbyIsIml2b3J5Iiwia2hha2kiLCJsYXZlbmRlciIsImxhdmVuZGVyYmx1c2giLCJsYXduZ3JlZW4iLCJsZW1vbmNoaWZmb24iLCJsaWdodGJsdWUiLCJsaWdodGNvcmFsIiwibGlnaHRjeWFuIiwibGlnaHRnb2xkZW5yb2R5ZWxsb3ciLCJsaWdodGdyYXkiLCJsaWdodGdyZWVuIiwibGlnaHRncmV5IiwibGlnaHRwaW5rIiwibGlnaHRzYWxtb24iLCJsaWdodHNlYWdyZWVuIiwibGlnaHRza3libHVlIiwibGlnaHRzbGF0ZWdyYXkiLCJsaWdodHNsYXRlZ3JleSIsImxpZ2h0c3RlZWxibHVlIiwibGlnaHR5ZWxsb3ciLCJsaW1lIiwibGltZWdyZWVuIiwibGluZW4iLCJtYWdlbnRhIiwibWFyb29uIiwibWVkaXVtYXF1YW1hcmluZSIsIm1lZGl1bWJsdWUiLCJtZWRpdW1vcmNoaWQiLCJtZWRpdW1wdXJwbGUiLCJtZWRpdW1zZWFncmVlbiIsIm1lZGl1bXNsYXRlYmx1ZSIsIm1lZGl1bXNwcmluZ2dyZWVuIiwibWVkaXVtdHVycXVvaXNlIiwibWVkaXVtdmlvbGV0cmVkIiwibWlkbmlnaHRibHVlIiwibWludGNyZWFtIiwibWlzdHlyb3NlIiwibW9jY2FzaW4iLCJuYXZham93aGl0ZSIsIm5hdnkiLCJvbGRsYWNlIiwib2xpdmUiLCJvbGl2ZWRyYWIiLCJvcmFuZ2UiLCJvcmFuZ2VyZWQiLCJvcmNoaWQiLCJwYWxlZ29sZGVucm9kIiwicGFsZWdyZWVuIiwicGFsZXR1cnF1b2lzZSIsInBhbGV2aW9sZXRyZWQiLCJwYXBheWF3aGlwIiwicGVhY2hwdWZmIiwicGVydSIsInBpbmsiLCJwbHVtIiwicG93ZGVyYmx1ZSIsInB1cnBsZSIsInJlYmVjY2FwdXJwbGUiLCJyZWQiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRhbiIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsIkNvbnZlcnRlciIsInBhaXIiLCJjb252cyIsInJvdXRlU3BhY2UiLCJnZXRWYWx1ZXMiLCJzZXRWYWx1ZXMiLCJ2YWxzIiwiZnNwYWNlIiwiY29sb3JDb252ZXJ0IiwiY29sb3JOYW1lIiwiY29sb3JTdHJpbmciLCJnZXRSZ2JhIiwiZ2V0SHNsYSIsImdldFJnYiIsImdldEhzbCIsImdldEh3YiIsImdldEFscGhhIiwiaGV4U3RyaW5nIiwicmdiU3RyaW5nIiwicmdiYVN0cmluZyIsInBlcmNlbnRTdHJpbmciLCJwZXJjZW50YVN0cmluZyIsImhzbFN0cmluZyIsImhzbGFTdHJpbmciLCJod2JTdHJpbmciLCJoZXgiLCJyZ2JhIiwicGVyIiwiaGV4QWxwaGEiLCJzY2FsZSIsImFscGhhIiwiaHNsYSIsImhleERvdWJsZSIsInJldmVyc2VOYW1lcyIsIm51bSIsIkNvbG9yIiwibGlnaHRuZXNzIiwid2hpdGVuZXNzIiwic2V0U3BhY2UiLCJyZ2JBcnJheSIsImhzbEFycmF5IiwiaHN2QXJyYXkiLCJod2JBcnJheSIsImNteWtBcnJheSIsInJnYmFBcnJheSIsImhzbGFBcnJheSIsInNldENoYW5uZWwiLCJodWUiLCJzYXR1cmF0aW9uIiwic2F0dXJhdGlvbnYiLCJibGFja25lc3MiLCJyZ2JOdW1iZXIiLCJsdW1pbm9zaXR5IiwibHVtIiwiY2hhbiIsImNvbnRyYXN0IiwiY29sb3IyIiwibHVtMSIsImx1bTIiLCJsZXZlbCIsImNvbnRyYXN0UmF0aW8iLCJkYXJrIiwieWlxIiwibGlnaHQiLCJuZWdhdGUiLCJsaWdodGVuIiwiZGFya2VuIiwic2F0dXJhdGUiLCJkZXNhdHVyYXRlIiwid2hpdGVuIiwiYmxhY2tlbiIsImdyZXlzY2FsZSIsImNsZWFyZXIiLCJvcGFxdWVyIiwicm90YXRlIiwiZGVncmVlcyIsIm1peCIsIm1peGluQ29sb3IiLCJ3ZWlnaHQiLCJjb2xvcjEiLCJ3MSIsIncyIiwic3BhY2VzIiwibWF4ZXMiLCJjaGFucyIsImNhcHBlZCIsInNuYW1lIiwic3ZhbHVlcyIsImNoYXJ0anNDb2xvciIsImhlbHBlcnMiLCJpc051bGxPclVuZGVmIiwidmFsdWVPckRlZmF1bHQiLCJ2YWx1ZUF0SW5kZXhPckRlZmF1bHQiLCJlYWNoIiwibG9vcGFibGUiLCJyZXZlcnNlIiwiYXJyYXlFcXVhbHMiLCJhMCIsImExIiwiaWxlbiIsInYwIiwidjEiLCJrbGVuIiwiX21lcmdlciIsInR2YWwiLCJzdmFsIiwiX21lcmdlcklmIiwibWVyZ2VJZiIsIm1lcmdlciIsInNldEZuIiwiaW5oZXJpdHMiLCJleHRlbnNpb25zIiwibWUiLCJDaGFydEVsZW1lbnQiLCJTdXJyb2dhdGUiLCJfX3N1cGVyX18iLCJoZWxwZXJzX2NvcmUiLCJjYWxsQ2FsbGJhY2siLCJmcm9tSW5kZXgiLCJnZXRWYWx1ZU9yRGVmYXVsdCIsImdldFZhbHVlQXRJbmRleE9yRGVmYXVsdCIsImVmZmVjdHMiLCJsaW5lYXIiLCJlYXNlSW5RdWFkIiwiZWFzZU91dFF1YWQiLCJlYXNlSW5PdXRRdWFkIiwiZWFzZUluQ3ViaWMiLCJlYXNlT3V0Q3ViaWMiLCJlYXNlSW5PdXRDdWJpYyIsImVhc2VJblF1YXJ0IiwiZWFzZU91dFF1YXJ0IiwiZWFzZUluT3V0UXVhcnQiLCJlYXNlSW5RdWludCIsImVhc2VPdXRRdWludCIsImVhc2VJbk91dFF1aW50IiwiZWFzZUluU2luZSIsImVhc2VPdXRTaW5lIiwiZWFzZUluT3V0U2luZSIsImVhc2VJbkV4cG8iLCJlYXNlT3V0RXhwbyIsImVhc2VJbk91dEV4cG8iLCJlYXNlSW5DaXJjIiwiZWFzZU91dENpcmMiLCJlYXNlSW5PdXRDaXJjIiwiZWFzZUluRWxhc3RpYyIsImFzaW4iLCJlYXNlT3V0RWxhc3RpYyIsImVhc2VJbk91dEVsYXN0aWMiLCJlYXNlSW5CYWNrIiwiZWFzZU91dEJhY2siLCJlYXNlSW5PdXRCYWNrIiwiZWFzZUluQm91bmNlIiwiZWFzZU91dEJvdW5jZSIsImVhc2VJbk91dEJvdW5jZSIsImhlbHBlcnNfZWFzaW5nIiwiZWFzaW5nRWZmZWN0cyIsIlJBRF9QRVJfREVHIiwiRE9VQkxFX1BJIiwiSEFMRl9QSSIsIlFVQVJURVJfUEkiLCJUV09fVEhJUkRTX1BJIiwiZXhwb3J0cyQxIiwiY2xlYXJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJyb3VuZGVkUmVjdCIsInJhZGl1cyIsImJvdHRvbSIsIm1vdmVUbyIsImFyYyIsImNsb3NlUGF0aCIsInJlY3QiLCJkcmF3UG9pbnQiLCJyb3RhdGlvbiIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiY29ybmVyUmFkaXVzIiwicmFkIiwiZHJhd0ltYWdlIiwiYmVnaW5QYXRoIiwibGluZVRvIiwiU1FSVDFfMiIsImZpbGwiLCJzdHJva2UiLCJfaXNQb2ludEluQXJlYSIsInBvaW50IiwiYXJlYSIsImVwc2lsb24iLCJjbGlwQXJlYSIsInNhdmUiLCJjbGlwIiwidW5jbGlwQXJlYSIsInJlc3RvcmUiLCJwcmV2aW91cyIsImZsaXAiLCJzdGVwcGVkIiwic3RlcHBlZExpbmUiLCJtaWRwb2ludCIsInRlbnNpb24iLCJiZXppZXJDdXJ2ZVRvIiwiY29udHJvbFBvaW50UHJldmlvdXNYIiwiY29udHJvbFBvaW50TmV4dFgiLCJjb250cm9sUG9pbnRQcmV2aW91c1kiLCJjb250cm9sUG9pbnROZXh0WSIsImhlbHBlcnNfY2FudmFzIiwiZHJhd1JvdW5kZWRSZWN0YW5nbGUiLCJfc2V0Iiwic2NvcGUiLCJkZWZhdWx0Q29sb3IiLCJkZWZhdWx0Rm9udENvbG9yIiwiZGVmYXVsdEZvbnRGYW1pbHkiLCJkZWZhdWx0Rm9udFNpemUiLCJkZWZhdWx0Rm9udFN0eWxlIiwiZGVmYXVsdExpbmVIZWlnaHQiLCJzaG93TGluZXMiLCJjb3JlX2RlZmF1bHRzIiwidG9Gb250U3RyaW5nIiwiZm9udCIsImZhbWlseSIsImhlbHBlcnNfb3B0aW9ucyIsInRvTGluZUhlaWdodCIsInRvUGFkZGluZyIsIl9wYXJzZUZvbnQiLCJnbG9iYWxEZWZhdWx0cyIsImZvbnRGYW1pbHkiLCJsaW5lSGVpZ2h0IiwiZm9udFN0eWxlIiwiaW5wdXRzIiwiaGVscGVycyQxIiwiZWFzaW5nIiwiY2FudmFzIiwiZWFzZSIsIm9yaWdpbiIsImMwIiwiYzEiLCJFbGVtZW50IiwiY29uZmlndXJhdGlvbiIsImluaXRpYWxpemUiLCJoaWRkZW4iLCJwaXZvdCIsIl92aWV3IiwiX21vZGVsIiwiX3N0YXJ0IiwidG9vbHRpcFBvc2l0aW9uIiwiaGFzVmFsdWUiLCJjb3JlX2VsZW1lbnQiLCJleHBvcnRzJDIiLCJjdXJyZW50U3RlcCIsIm51bVN0ZXBzIiwib25BbmltYXRpb25Qcm9ncmVzcyIsIm9uQW5pbWF0aW9uQ29tcGxldGUiLCJjb3JlX2FuaW1hdGlvbiIsImFuaW1hdGlvbiIsIm9uUHJvZ3Jlc3MiLCJvbkNvbXBsZXRlIiwiY29yZV9hbmltYXRpb25zIiwiYW5pbWF0aW9ucyIsInJlcXVlc3QiLCJhZGRBbmltYXRpb24iLCJzdGFydFRpbWUiLCJhbmltYXRpbmciLCJjYW5jZWxBbmltYXRpb24iLCJmaW5kSW5kZXgiLCJyZXF1ZXN0QW5pbUZyYW1lIiwic3RhcnREaWdlc3QiLCJuZXh0U3RlcCIsImFycmF5RXZlbnRzIiwibGlzdGVuQXJyYXlFdmVudHMiLCJsaXN0ZW5lciIsIl9jaGFydGpzIiwidW5saXN0ZW5BcnJheUV2ZW50cyIsInN0dWIiLCJEYXRhc2V0Q29udHJvbGxlciIsImRhdGFzZXRJbmRleCIsImRhdGFzZXRFbGVtZW50VHlwZSIsImRhdGFFbGVtZW50VHlwZSIsImxpbmtTY2FsZXMiLCJhZGRFbGVtZW50cyIsInVwZGF0ZUluZGV4IiwiZ2V0TWV0YSIsImdldERhdGFzZXQiLCJ4QXhpc0lEIiwic2NhbGVzIiwieEF4ZXMiLCJ5QXhpc0lEIiwieUF4ZXMiLCJnZXREYXRhc2V0TWV0YSIsImdldFNjYWxlRm9ySWQiLCJzY2FsZUlEIiwiX2dldFZhbHVlU2NhbGVJZCIsIl9nZXRJbmRleFNjYWxlSWQiLCJfZ2V0VmFsdWVTY2FsZSIsIl9nZXRJbmRleFNjYWxlIiwicmVzZXQiLCJjcmVhdGVNZXRhRGF0YXNldCIsIl9kYXRhc2V0SW5kZXgiLCJjcmVhdGVNZXRhRGF0YSIsIl9pbmRleCIsIm1ldGFEYXRhIiwiYWRkRWxlbWVudEFuZFJlc2V0IiwidXBkYXRlRWxlbWVudCIsImJ1aWxkT3JVcGRhdGVFbGVtZW50cyIsInJlc3luY0VsZW1lbnRzIiwiZWFzaW5nVmFsdWUiLCJlbGVtZW50cyIsImRyYXciLCJyZW1vdmVIb3ZlclN0eWxlIiwiJHByZXZpb3VzU3R5bGUiLCJzZXRIb3ZlclN0eWxlIiwiY3VzdG9tIiwiZ2V0SG92ZXJDb2xvciIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwiYm9yZGVyV2lkdGgiLCJob3ZlckJhY2tncm91bmRDb2xvciIsImhvdmVyQm9yZGVyQ29sb3IiLCJob3ZlckJvcmRlcldpZHRoIiwibnVtTWV0YSIsIm51bURhdGEiLCJpbnNlcnRFbGVtZW50cyIsIm9uRGF0YVB1c2giLCJvbkRhdGFQb3AiLCJvbkRhdGFTaGlmdCIsIm9uRGF0YVNwbGljZSIsIm9uRGF0YVVuc2hpZnQiLCJjb3JlX2RhdGFzZXRDb250cm9sbGVyIiwiYm9yZGVyQWxpZ24iLCJlbGVtZW50X2FyYyIsImluTGFiZWxSYW5nZSIsIm1vdXNlWCIsImhvdmVyUmFkaXVzIiwiaW5SYW5nZSIsImNoYXJ0WCIsImNoYXJ0WSIsInBvaW50UmVsYXRpdmVQb3NpdGlvbiIsImdldEFuZ2xlRnJvbVBvaW50IiwiYW5nbGUiLCJkaXN0YW5jZSIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImJldHdlZW5BbmdsZXMiLCJ3aXRoaW5SYWRpdXMiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwiZ2V0Q2VudGVyUG9pbnQiLCJoYWxmQW5nbGUiLCJoYWxmUmFkaXVzIiwiZ2V0QXJlYSIsImNlbnRyZUFuZ2xlIiwicmFuZ2VGcm9tQ2VudHJlIiwic0EiLCJlQSIsInBpeGVsTWFyZ2luIiwiYW5nbGVNYXJnaW4iLCJmaWxsU3R5bGUiLCJsaW5lV2lkdGgiLCJsaW5lSm9pbiIsInN0cm9rZVN0eWxlIiwidmFsdWVPckRlZmF1bHQkMSIsImxpbmUiLCJib3JkZXJDYXBTdHlsZSIsImJvcmRlckRhc2giLCJib3JkZXJEYXNoT2Zmc2V0IiwiYm9yZGVySm9pblN0eWxlIiwiY2FwQmV6aWVyUG9pbnRzIiwiZWxlbWVudF9saW5lIiwic3BhbkdhcHMiLCJwb2ludHMiLCJfY2hpbGRyZW4iLCJnbG9iYWxPcHRpb25MaW5lRWxlbWVudHMiLCJsYXN0RHJhd25JbmRleCIsImN1cnJlbnRWTSIsIl9sb29wIiwibGluZUNhcCIsInNldExpbmVEYXNoIiwibGluZURhc2hPZmZzZXQiLCJwcmV2aW91c0l0ZW0iLCJza2lwIiwidmFsdWVPckRlZmF1bHQkMiIsImRlZmF1bHRDb2xvciQxIiwicG9pbnRTdHlsZSIsImhpdFJhZGl1cyIsInhSYW5nZSIsInlSYW5nZSIsIm1vdXNlWSIsImVsZW1lbnRfcG9pbnQiLCJpblhSYW5nZSIsImluWVJhbmdlIiwicGFkZGluZyIsImNoYXJ0QXJlYSIsImRlZmF1bHRDb2xvciQyIiwicmVjdGFuZ2xlIiwiYm9yZGVyU2tpcHBlZCIsImlzVmVydGljYWwiLCJnZXRCYXJCb3VuZHMiLCJ4MSIsIngyIiwieTEiLCJoYWxmIiwic3dhcCIsIm9yaWciLCJ2MiIsInBhcnNlQm9yZGVyU2tpcHBlZCIsImVkZ2UiLCJob3Jpem9udGFsIiwicGFyc2VCb3JkZXJXaWR0aCIsIm1heFciLCJtYXhIIiwiYm91bmRpbmdSZWN0cyIsImJvdW5kcyIsImJvcmRlciIsIm91dGVyIiwiaW5uZXIiLCJza2lwWCIsInNraXBZIiwiZWxlbWVudF9yZWN0YW5nbGUiLCJyZWN0cyIsImZpbGxSZWN0IiwiQXJjIiwiTGluZSIsIlBvaW50IiwiUmVjdGFuZ2xlIiwicmVzb2x2ZSQxIiwiaG92ZXIiLCJjYXRlZ29yeVBlcmNlbnRhZ2UiLCJiYXJQZXJjZW50YWdlIiwiZ3JpZExpbmVzIiwib2Zmc2V0R3JpZExpbmVzIiwiY29tcHV0ZU1pblNhbXBsZVNpemUiLCJwaXhlbHMiLCJpc0hvcml6b250YWwiLCJ0aWNrcyIsImdldFRpY2tzIiwiY3VyciIsImdldFBpeGVsRm9yVGljayIsImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsInJ1bGVyIiwidGhpY2tuZXNzIiwiYmFyVGhpY2tuZXNzIiwic3RhY2tDb3VudCIsImNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMiLCJwZXJjZW50IiwiY29udHJvbGxlcl9iYXIiLCJiYXIiLCJfcnVsZXIiLCJnZXRSdWxlciIsIl9yZXNvbHZlRWxlbWVudE9wdGlvbnMiLCJfeFNjYWxlIiwiX3lTY2FsZSIsImRhdGFzZXRMYWJlbCIsIl91cGRhdGVFbGVtZW50R2VvbWV0cnkiLCJ2c2NhbGUiLCJnZXRCYXNlUGl4ZWwiLCJ2cGl4ZWxzIiwiY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMiLCJpcGl4ZWxzIiwiY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMiLCJoZWFkIiwiY2VudGVyIiwiX2dldFN0YWNrcyIsInN0YWNrcyIsImlzRGF0YXNldFZpc2libGUiLCJnZXRTdGFja0NvdW50IiwiZ2V0U3RhY2tJbmRleCIsImdldFBpeGVsRm9yVmFsdWUiLCJnZXRSaWdodFZhbHVlIiwibWluQmFyTGVuZ3RoIiwiaW1ldGEiLCJpdmFsdWUiLCJjb250cm9sbGVyIiwic3RhY2tJbmRleCIsIm1heEJhclRoaWNrbmVzcyIsIkluZmluaXR5IiwiZGF0YUluZGV4IiwidmFsdWVPckRlZmF1bHQkMyIsInJlc29sdmUkMiIsInBvc2l0aW9uIiwidG9vbHRpcHMiLCJkYXRhUG9pbnQiLCJ4TGFiZWwiLCJ5TGFiZWwiLCJjb250cm9sbGVyX2J1YmJsZSIsInhTY2FsZSIsInlTY2FsZSIsImRzSW5kZXgiLCJnZXRQaXhlbEZvckRlY2ltYWwiLCJfb3B0aW9ucyIsInJlc29sdmUkMyIsInZhbHVlT3JEZWZhdWx0JDQiLCJhbmltYXRlUm90YXRlIiwiYW5pbWF0ZVNjYWxlIiwibGVnZW5kQ2FsbGJhY2siLCJsZWdlbmQiLCJnZW5lcmF0ZUxhYmVscyIsImRzIiwiYXJjT3B0cyIsImJ3Iiwib25DbGljayIsImxlZ2VuZEl0ZW0iLCJjdXRvdXRQZXJjZW50YWdlIiwiY2lyY3VtZmVyZW5jZSIsInRvb2x0aXBJdGVtIiwiZGF0YUxhYmVsIiwiY29udHJvbGxlcl9kb3VnaG51dCIsImdldFJpbmdJbmRleCIsInJpbmdJbmRleCIsImF2YWlsYWJsZVdpZHRoIiwiYXZhaWxhYmxlSGVpZ2h0IiwibWluU2l6ZSIsImFyY3MiLCJjaGFydFdlaWdodCIsIl9nZXRSaW5nV2VpZ2h0IiwiY29udGFpbnMwIiwiY29udGFpbnM5MCIsImNvbnRhaW5zMTgwIiwiY29udGFpbnMyNzAiLCJjdXRvdXQiLCJnZXRNYXhCb3JkZXJXaWR0aCIsInJhZGl1c0xlbmd0aCIsIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJjYWxjdWxhdGVUb3RhbCIsIl9nZXRSaW5nV2VpZ2h0T2Zmc2V0IiwiYW5pbWF0aW9uT3B0cyIsImNlbnRlclgiLCJjZW50ZXJZIiwiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsImhvdmVyV2lkdGgiLCJyaW5nV2VpZ2h0T2Zmc2V0IiwiZGF0YVNldEluZGV4IiwiYXhpcyIsImNvbnRyb2xsZXJfaG9yaXpvbnRhbEJhciIsInZhbHVlT3JEZWZhdWx0JDUiLCJyZXNvbHZlJDQiLCJpc1BvaW50SW5BcmVhIiwibGluZUVuYWJsZWQiLCJzaG93TGluZSIsImNvbnRyb2xsZXJfbGluZSIsImxpbmVUZW5zaW9uIiwiX3NjYWxlIiwiX3Jlc29sdmVMaW5lT3B0aW9ucyIsInVwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCJsaW5lTW9kZWwiLCJfcmVzb2x2ZVBvaW50T3B0aW9ucyIsImNhbGN1bGF0ZVBvaW50WSIsIkVMRU1FTlRfT1BUSU9OUyIsImVsZW1lbnRPcHRpb25zIiwic3VtUG9zIiwic3VtTmVnIiwiZHNNZXRhIiwic3RhY2tlZFJpZ2h0VmFsdWUiLCJyaWdodFZhbHVlIiwiY29udHJvbFBvaW50cyIsInB0IiwiY2FwQ29udHJvbFBvaW50IiwiY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSIsInNwbGluZUN1cnZlTW9ub3RvbmUiLCJzcGxpbmVDdXJ2ZSIsIm5leHRJdGVtIiwiaGFsZkJvcmRlcldpZHRoIiwicmVzb2x2ZSQ1IiwiYW5nbGVMaW5lcyIsInBvaW50TGFiZWxzIiwiYmVnaW5BdFplcm8iLCJjb250cm9sbGVyX3BvbGFyQXJlYSIsInN0YXJ0cyIsIl9zdGFydHMiLCJhbmdsZXMiLCJfYW5nbGVzIiwiX3VwZGF0ZVJhZGl1cyIsImNvdW50VmlzaWJsZUVsZW1lbnRzIiwiX2NvbXB1dGVBbmdsZSIsImdldFZpc2libGVEYXRhc2V0Q291bnQiLCJ4Q2VudGVyIiwieUNlbnRlciIsImRhdGFzZXRTdGFydEFuZ2xlIiwiZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUiLCJyZXNldFJhZGl1cyIsImRvdWdobnV0IiwiY29udHJvbGxlcl9waWUiLCJ2YWx1ZU9yRGVmYXVsdCQ2IiwicmVzb2x2ZSQ2IiwiY29udHJvbGxlcl9yYWRhciIsInBvaW50UG9zaXRpb24iLCJnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUiLCJjb250cm9sbGVyX3NjYXR0ZXIiLCJjb250cm9sbGVycyIsImhvcml6b250YWxCYXIiLCJwb2xhckFyZWEiLCJwaWUiLCJyYWRhciIsInNjYXR0ZXIiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwicGFyc2VWaXNpYmxlSXRlbXMiLCJqbGVuIiwiZ2V0SW50ZXJzZWN0SXRlbXMiLCJnZXROZWFyZXN0SXRlbXMiLCJpbnRlcnNlY3QiLCJkaXN0YW5jZU1ldHJpYyIsIm1pbkRpc3RhbmNlIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJuZWFyZXN0SXRlbXMiLCJnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMiLCJ1c2VYIiwidXNlWSIsInB0MSIsInB0MiIsImRlbHRhWCIsImRlbHRhWSIsImluZGV4TW9kZSIsImNvcmVfaW50ZXJhY3Rpb24iLCJtb2RlcyIsInNpbmdsZSIsIm5lYXJlc3QiLCJpbnRlcnNlY3RzSXRlbSIsImZpbHRlckJ5UG9zaXRpb24iLCJ3aGVyZSIsInNvcnRCeVdlaWdodCIsIl90bXBJbmRleF8iLCJmaW5kTWF4UGFkZGluZyIsImJveGVzIiwiYm94IiwiZ2V0UGFkZGluZyIsImJveFBhZGRpbmciLCJhZGRTaXplQnlQb3NpdGlvbiIsImxheW91dCIsImNvcmVfbGF5b3V0cyIsImFkZEJveCIsImZ1bGxXaWR0aCIsInJlbW92ZUJveCIsImxheW91dEl0ZW0iLCJjb25maWd1cmUiLCJsYXlvdXRPcHRpb25zIiwibGVmdFBhZGRpbmciLCJyaWdodFBhZGRpbmciLCJ0b3BQYWRkaW5nIiwiYm90dG9tUGFkZGluZyIsImxlZnRCb3hlcyIsInJpZ2h0Qm94ZXMiLCJ0b3BCb3hlcyIsImJvdHRvbUJveGVzIiwiY2hhcnRBcmVhQm94ZXMiLCJ2ZXJ0aWNhbEJveGVzIiwiaG9yaXpvbnRhbEJveGVzIiwib3V0ZXJCb3hlcyIsImNoYXJ0V2lkdGgiLCJjaGFydEhlaWdodCIsImNoYXJ0QXJlYVdpZHRoIiwidmVydGljYWxCb3hXaWR0aCIsIm1heENoYXJ0QXJlYVdpZHRoIiwibWF4Q2hhcnRBcmVhSGVpZ2h0Iiwib3V0ZXJCb3hTaXplcyIsIm1pbkJveFNpemVzIiwibWF4UGFkZGluZyIsImdldE1pbmltdW1Cb3hTaXplIiwiZml0Qm94IiwibWluQm94U2l6ZSIsImZpbmROZXh0V2hlcmUiLCJtaW5Cb3giLCJzY2FsZU1hcmdpbiIsImZpbmFsRml0VmVydGljYWxCb3giLCJsZWZ0UGFkZGluZ0FkZGl0aW9uIiwidG9wUGFkZGluZ0FkZGl0aW9uIiwibmV3TWF4Q2hhcnRBcmVhSGVpZ2h0IiwibmV3TWF4Q2hhcnRBcmVhV2lkdGgiLCJwbGFjZUJveCIsInBsYXRmb3JtX2Jhc2ljIiwiYWNxdWlyZUNvbnRleHQiLCJnZXRDb250ZXh0IiwicGxhdGZvcm1fZG9tIiwicGxhdGZvcm1fZG9tJDEiLCJnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlIiwic3R5bGVzaGVldCIsIkVYUEFORE9fS0VZIiwiQ1NTX1BSRUZJWCIsIkNTU19TSVpFX01PTklUT1IiLCJDU1NfUkVOREVSX01PTklUT1IiLCJDU1NfUkVOREVSX0FOSU1BVElPTiIsIkFOSU1BVElPTl9TVEFSVF9FVkVOVFMiLCJFVkVOVF9UWVBFUyIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJkb3duIiwicG9pbnRlcm1vdmUiLCJwb2ludGVydXAiLCJwb2ludGVybGVhdmUiLCJwb2ludGVyb3V0IiwicmVhZFVzZWRTaXplIiwiaW5pdENhbnZhcyIsInJlbmRlckhlaWdodCIsInJlbmRlcldpZHRoIiwiZGlzcGxheVdpZHRoIiwiYXNwZWN0UmF0aW8iLCJkaXNwbGF5SGVpZ2h0Iiwic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsInN1cHBvcnRzIiwiZXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwibmF0aXZlRXZlbnQiLCJmcm9tTmF0aXZlRXZlbnQiLCJ0aHJvdHRsZWQiLCJ0aWNraW5nIiwiY3JlYXRlRGl2IiwiY2xhc3NOYW1lIiwiY3JlYXRlUmVzaXplciIsIm1heFNpemUiLCJyZXNpemVyIiwiZXhwYW5kIiwic2hyaW5rIiwiX3Jlc2V0Iiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsIm9uU2Nyb2xsIiwid2F0Y2hGb3JSZW5kZXIiLCJleHBhbmRvIiwicmVuZGVyUHJveHkiLCJhbmltYXRpb25OYW1lIiwicmVmbG93Iiwib2Zmc2V0UGFyZW50IiwidW53YXRjaEZvclJlbmRlciIsImFkZFJlc2l6ZUxpc3RlbmVyIiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsImNsaWVudFdpZHRoIiwicmVtb3ZlUmVzaXplTGlzdGVuZXIiLCJpbmplY3RDU1MiLCJfc3R5bGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInBsYXRmb3JtX2RvbSQyIiwiZGlzYWJsZUNTU0luamVjdGlvbiIsIl9lbmFibGVkIiwiX2Vuc3VyZUxvYWRlZCIsIl9sb2FkZWQiLCJnZXRFbGVtZW50QnlJZCIsInJlbGVhc2VDb250ZXh0IiwicHJveGllcyIsImFkZEV2ZW50IiwicmVtb3ZlRXZlbnQiLCJpbXBsZW1lbnRhdGlvbiIsInBsdWdpbnMiLCJjb3JlX3BsdWdpbnMiLCJfcGx1Z2lucyIsIl9jYWNoZUlkIiwicmVnaXN0ZXIiLCJ1bnJlZ2lzdGVyIiwiaWR4IiwiZ2V0QWxsIiwiZGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9yIiwiJHBsdWdpbnMiLCJfaW52YWxpZGF0ZSIsImNvcmVfc2NhbGVTZXJ2aWNlIiwiY29uc3RydWN0b3JzIiwicmVnaXN0ZXJTY2FsZVR5cGUiLCJzY2FsZUNvbnN0cnVjdG9yIiwic2NhbGVEZWZhdWx0cyIsImdldFNjYWxlQ29uc3RydWN0b3IiLCJnZXRTY2FsZURlZmF1bHRzIiwidXBkYXRlU2NhbGVEZWZhdWx0cyIsImFkZGl0aW9ucyIsImFkZFNjYWxlc1RvTGF5b3V0IiwidmFsdWVPckRlZmF1bHQkNyIsImVuYWJsZWQiLCJ0aXRsZUZvbnRTdHlsZSIsInRpdGxlU3BhY2luZyIsInRpdGxlTWFyZ2luQm90dG9tIiwidGl0bGVGb250Q29sb3IiLCJ0aXRsZUFsaWduIiwiYm9keVNwYWNpbmciLCJib2R5Rm9udENvbG9yIiwiYm9keUFsaWduIiwiZm9vdGVyRm9udFN0eWxlIiwiZm9vdGVyU3BhY2luZyIsImZvb3Rlck1hcmdpblRvcCIsImZvb3RlckZvbnRDb2xvciIsImZvb3RlckFsaWduIiwieVBhZGRpbmciLCJ4UGFkZGluZyIsImNhcmV0UGFkZGluZyIsImNhcmV0U2l6ZSIsIm11bHRpS2V5QmFja2dyb3VuZCIsImRpc3BsYXlDb2xvcnMiLCJiZWZvcmVUaXRsZSIsInRvb2x0aXBJdGVtcyIsImxhYmVsQ291bnQiLCJhZnRlclRpdGxlIiwiYmVmb3JlQm9keSIsImJlZm9yZUxhYmVsIiwibGFiZWxDb2xvciIsImxhYmVsVGV4dENvbG9yIiwiYWZ0ZXJMYWJlbCIsImFmdGVyQm9keSIsImJlZm9yZUZvb3RlciIsImZvb3RlciIsImFmdGVyRm9vdGVyIiwicG9zaXRpb25lcnMiLCJhdmVyYWdlIiwiZXZlbnRQb3NpdGlvbiIsIm5lYXJlc3RFbGVtZW50IiwiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwidHAiLCJwdXNoT3JDb25jYXQiLCJ0b1B1c2giLCJzcGxpdE5ld2xpbmVzIiwiY3JlYXRlVG9vbHRpcEl0ZW0iLCJpbmRleFNjYWxlIiwidmFsdWVTY2FsZSIsImdldExhYmVsRm9ySW5kZXgiLCJnZXRCYXNlTW9kZWwiLCJ0b29sdGlwT3B0cyIsInhBbGlnbiIsInlBbGlnbiIsIl9ib2R5Rm9udEZhbWlseSIsImJvZHlGb250RmFtaWx5IiwiX2JvZHlGb250U3R5bGUiLCJib2R5Rm9udFN0eWxlIiwiX2JvZHlBbGlnbiIsImJvZHlGb250U2l6ZSIsIl90aXRsZUZvbnRGYW1pbHkiLCJ0aXRsZUZvbnRGYW1pbHkiLCJfdGl0bGVGb250U3R5bGUiLCJ0aXRsZUZvbnRTaXplIiwiX3RpdGxlQWxpZ24iLCJfZm9vdGVyRm9udEZhbWlseSIsImZvb3RlckZvbnRGYW1pbHkiLCJfZm9vdGVyRm9udFN0eWxlIiwiZm9vdGVyRm9udFNpemUiLCJfZm9vdGVyQWxpZ24iLCJvcGFjaXR5IiwibGVnZW5kQ29sb3JCYWNrZ3JvdW5kIiwiZ2V0VG9vbHRpcFNpemUiLCJ0b29sdGlwIiwiY29tYmluZWRCb2R5TGVuZ3RoIiwiYm9keUl0ZW0iLCJhZnRlciIsInRpdGxlTGluZUNvdW50IiwiZm9vdGVyTGluZUNvdW50Iiwid2lkdGhQYWRkaW5nIiwibWF4TGluZVdpZHRoIiwibWVhc3VyZVRleHQiLCJmb250U3RyaW5nIiwiZGV0ZXJtaW5lQWxpZ25tZW50IiwibGYiLCJyZiIsIm9sZiIsIm9yZiIsInlmIiwibWlkWCIsIm1pZFkiLCJnZXRCYWNrZ3JvdW5kUG9pbnQiLCJhbGlnbm1lbnQiLCJwYWRkaW5nQW5kU2l6ZSIsInJhZGl1c0FuZFBhZGRpbmciLCJnZXRBbGlnbmVkWCIsImFsaWduIiwiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCJleHBvcnRzJDMiLCJfbGFzdEFjdGl2ZSIsImdldFRpdGxlIiwiZ2V0QmVmb3JlQm9keSIsImdldEJvZHkiLCJib2R5SXRlbXMiLCJnZXRBZnRlckJvZHkiLCJnZXRGb290ZXIiLCJjaGFuZ2VkIiwiZXhpc3RpbmdNb2RlbCIsIl9hY3RpdmUiLCJiYWNrZ3JvdW5kUG9pbnQiLCJ0b29sdGlwU2l6ZSIsImNhcmV0WCIsImNhcmV0WSIsImxhYmVsQ29sb3JzIiwibGFiZWxUZXh0Q29sb3JzIiwiX2V2ZW50UG9zaXRpb24iLCJpdGVtU29ydCIsImRhdGFQb2ludHMiLCJkcmF3Q2FyZXQiLCJ0b29sdGlwUG9pbnQiLCJjYXJldFBvc2l0aW9uIiwiZ2V0Q2FyZXRQb3NpdGlvbiIsIngzIiwieTMiLCJwdFgiLCJwdFkiLCJkcmF3VGl0bGUiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsVGV4dCIsImRyYXdCb2R5IiwiZHJhd0NvbG9yQm94ZXMiLCJ4TGluZVBhZGRpbmciLCJjb2xvclgiLCJ0ZXh0Q29sb3IiLCJmaWxsTGluZU9mVGV4dCIsInN0cm9rZVJlY3QiLCJkcmF3Rm9vdGVyIiwiZHJhd0JhY2tncm91bmQiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiaGFzVG9vbHRpcENvbnRlbnQiLCJnbG9iYWxBbHBoYSIsImhhbmRsZUV2ZW50IiwiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsInBvc2l0aW9uZXJzXzEiLCJjb3JlX3Rvb2x0aXAiLCJ2YWx1ZU9yRGVmYXVsdCQ4Iiwib25Ib3ZlciIsImFuaW1hdGlvbkR1cmF0aW9uIiwicmVzcG9uc2l2ZSIsInJlc3BvbnNpdmVBbmltYXRpb25EdXJhdGlvbiIsIm1lcmdlU2NhbGVDb25maWciLCJzbGVuIiwibWVyZ2VDb25maWciLCJpbml0Q29uZmlnIiwidXBkYXRlQ29uZmlnIiwibmV3T3B0aW9ucyIsImVuc3VyZVNjYWxlc0hhdmVJRHMiLCJidWlsZE9yVXBkYXRlU2NhbGVzIiwicG9zaXRpb25Jc0hvcml6b250YWwiLCJDaGFydCIsImNvbnN0cnVjdCIsIl9idWZmZXJlZFJlbmRlciIsImluc3RhbmNlcyIsInJldGluYVNjYWxlIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImJpbmRFdmVudHMiLCJyZXNpemUiLCJpbml0VG9vbFRpcCIsIm5ld1dpZHRoIiwiZ2V0TWF4aW11bVdpZHRoIiwibmV3SGVpZ2h0IiwiZ2V0TWF4aW11bUhlaWdodCIsIm5ld1NpemUiLCJvblJlc2l6ZSIsInNjYWxlc09wdGlvbnMiLCJzY2FsZU9wdGlvbnMiLCJ4QXhpc09wdGlvbnMiLCJ5QXhpc09wdGlvbnMiLCJkdHlwZSIsImRwb3NpdGlvbiIsImlzRGVmYXVsdCIsInNjYWxlVHlwZSIsInNjYWxlQ2xhc3MiLCJtZXJnZVRpY2tzT3B0aW9ucyIsImhhc1VwZGF0ZWQiLCJidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMiLCJuZXdDb250cm9sbGVycyIsImRlc3Ryb3lEYXRhc2V0TWV0YSIsIkNvbnRyb2xsZXJDbGFzcyIsInJlc2V0RWxlbWVudHMiLCJ1cGRhdGVMYXlvdXQiLCJ1cGRhdGVEYXRhc2V0cyIsImxhc3RBY3RpdmUiLCJfYnVmZmVyZWRSZXF1ZXN0IiwidXBkYXRlRGF0YXNldCIsImFuaW1hdGlvbk9wdGlvbnMiLCJhbmltYXRpb25PYmplY3QiLCJlYXNpbmdGdW5jdGlvbiIsInN0ZXBEZWNpbWFsIiwiZHJhd0RhdGFzZXRzIiwiX2RyYXdUb29sdGlwIiwiZHJhd0RhdGFzZXQiLCJnZXRFbGVtZW50QXRFdmVudCIsImdldEVsZW1lbnRzQXRFdmVudCIsImdldEVsZW1lbnRzQXRYQXhpcyIsImdldERhdGFzZXRBdEV2ZW50IiwiX21ldGEiLCJnZW5lcmF0ZUxlZ2VuZCIsInVuYmluZEV2ZW50cyIsInRvQmFzZTY0SW1hZ2UiLCJ0b0RhdGFVUkwiLCJfY2hhcnRJbnN0YW5jZSIsIl9saXN0ZW5lcnMiLCJldmVudEhhbmRsZXIiLCJ1cGRhdGVIb3ZlclN0eWxlIiwiYnVmZmVyZWRSZXF1ZXN0IiwiaG92ZXJPcHRpb25zIiwiY29yZV9jb250cm9sbGVyIiwiQ29udHJvbGxlciIsImNvbmZpZ01lcmdlIiwic2NhbGVNZXJnZSIsImNvcmVfaGVscGVycyIsImZpbHRlckNhbGxiYWNrIiwiZmlsdGVyZWQiLCJhcnJheVRvU2VhcmNoIiwic3RhcnRJbmRleCIsImN1cnJlbnRJdGVtIiwiZmluZFByZXZpb3VzV2hlcmUiLCJhbG1vc3RFcXVhbHMiLCJhbG1vc3RXaG9sZSIsInJvdW5kZWQiLCJORUdBVElWRV9JTkZJTklUWSIsImxvZzEwIiwiZXhwb25lbnQiLCJMT0cxMEUiLCJwb3dlck9mMTAiLCJpc1Bvd2VyT2YxMCIsInRvUmFkaWFucyIsInRvRGVncmVlcyIsInJhZGlhbnMiLCJfZGVjaW1hbFBsYWNlcyIsImNlbnRyZVBvaW50IiwiYW5nbGVQb2ludCIsImRpc3RhbmNlRnJvbVhDZW50ZXIiLCJkaXN0YW5jZUZyb21ZQ2VudGVyIiwicmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyIiwiYWxpYXNQaXhlbCIsInBpeGVsV2lkdGgiLCJfYWxpZ25QaXhlbCIsInBpeGVsIiwiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCJoYWxmV2lkdGgiLCJmaXJzdFBvaW50IiwibWlkZGxlUG9pbnQiLCJhZnRlclBvaW50IiwiZDAxIiwiZDEyIiwiczAxIiwiczEyIiwiZmEiLCJmYiIsIkVQU0lMT04iLCJwb2ludHNXaXRoVGFuZ2VudHMiLCJkZWx0YUsiLCJtSyIsInBvaW50c0xlbiIsInBvaW50QmVmb3JlIiwicG9pbnRDdXJyZW50IiwicG9pbnRBZnRlciIsInNsb3BlRGVsdGFYIiwiYWxwaGFLIiwiYmV0YUsiLCJ0YXVLIiwic3F1YXJlZE1hZ25pdHVkZSIsImxvb3AiLCJuaWNlTnVtIiwiZnJhY3Rpb24iLCJuaWNlRnJhY3Rpb24iLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJldnQiLCJvcmlnaW5hbEV2ZW50Iiwic3JjRWxlbWVudCIsImJvdW5kaW5nUmVjdCIsInRvdWNoZXMiLCJjbGllbnRYIiwiY2xpZW50WSIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdCb3R0b20iLCJwYXJzZU1heFN0eWxlIiwicGFyZW50UHJvcGVydHkiLCJ2YWx1ZUluUGl4ZWxzIiwiaXNDb25zdHJhaW5lZFZhbHVlIiwiZ2V0Q29uc3RyYWludERpbWVuc2lvbiIsImRvbU5vZGUiLCJtYXhTdHlsZSIsInBlcmNlbnRhZ2VQcm9wZXJ0eSIsImRlZmF1bHRWaWV3IiwiX2dldFBhcmVudE5vZGUiLCJjb25zdHJhaW5lZE5vZGUiLCJjb25zdHJhaW5lZENvbnRhaW5lciIsImhhc0NOb2RlIiwiaGFzQ0NvbnRhaW5lciIsImluZmluaXR5IiwiZ2V0Q29uc3RyYWludFdpZHRoIiwiZ2V0Q29uc3RyYWludEhlaWdodCIsIl9jYWxjdWxhdGVQYWRkaW5nIiwicGFyZW50RGltZW5zaW9uIiwiaG9zdCIsImN3IiwiY2xpZW50SGVpZ2h0IiwiY3VycmVudFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImZvcmNlUmF0aW8iLCJwaXhlbFJhdGlvIiwicGl4ZWxTaXplIiwibG9uZ2VzdFRleHQiLCJhcnJheU9mVGhpbmdzIiwiZ2MiLCJnYXJiYWdlQ29sbGVjdCIsImxvbmdlc3QiLCJ0aGluZyIsIm5lc3RlZFRoaW5nIiwiZ2NMZW4iLCJ0ZXh0V2lkdGgiLCJudW1iZXJPZkxhYmVsTGluZXMiLCJudW1iZXJPZkxpbmVzIiwiY29sb3IiLCJDYW52YXNHcmFkaWVudCIsImNvbG9yVmFsdWUiLCJDYW52YXNQYXR0ZXJuIiwiRGF0ZUFkYXB0ZXIiLCJfY3JlYXRlIiwib3ZlcnJpZGUiLCJtZW1iZXJzIiwiX2RhdGUiLCJjb3JlX2FkYXB0ZXJzIiwiY29yZV90aWNrcyIsImZvcm1hdHRlcnMiLCJ0aWNrVmFsdWUiLCJsb2dEZWx0YSIsInRpY2tTdHJpbmciLCJtYXhUaWNrIiwibG9nVGljayIsInRvRXhwb25lbnRpYWwiLCJudW1EZWNpbWFsIiwibG9nYXJpdGhtaWMiLCJyZW1haW4iLCJ2YWx1ZU9yRGVmYXVsdCQ5IiwiZHJhd0JvcmRlciIsImRyYXdPbkNoYXJ0QXJlYSIsImRyYXdUaWNrcyIsInRpY2tNYXJrTGVuZ3RoIiwiemVyb0xpbmVXaWR0aCIsInplcm9MaW5lQ29sb3IiLCJ6ZXJvTGluZUJvcmRlckRhc2giLCJ6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQiLCJzY2FsZUxhYmVsIiwibGFiZWxTdHJpbmciLCJtaW5Sb3RhdGlvbiIsIm1heFJvdGF0aW9uIiwibWlycm9yIiwiYXV0b1NraXAiLCJhdXRvU2tpcFBhZGRpbmciLCJsYWJlbE9mZnNldCIsIm1pbm9yIiwibWFqb3IiLCJsYWJlbHNGcm9tVGlja3MiLCJnZXRQaXhlbEZvckdyaWRMaW5lIiwibGluZVZhbHVlIiwiY29tcHV0ZVRleHRTaXplIiwidGljayIsImNvcmVfc2NhbGUiLCJfdGlja3MiLCJiZWZvcmVVcGRhdGUiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm1hcmdpbnMiLCJfbWF4TGFiZWxMaW5lcyIsImxvbmdlc3RMYWJlbFdpZHRoIiwibG9uZ2VzdFRleHRDYWNoZSIsImJlZm9yZVNldERpbWVuc2lvbnMiLCJzZXREaW1lbnNpb25zIiwiYWZ0ZXJTZXREaW1lbnNpb25zIiwiYmVmb3JlRGF0YUxpbWl0cyIsImRldGVybWluZURhdGFMaW1pdHMiLCJhZnRlckRhdGFMaW1pdHMiLCJiZWZvcmVCdWlsZFRpY2tzIiwiYnVpbGRUaWNrcyIsImFmdGVyQnVpbGRUaWNrcyIsImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImNvbnZlcnRUaWNrc1RvTGFiZWxzIiwiYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJiZWZvcmVDYWxjdWxhdGVUaWNrUm90YXRpb24iLCJjYWxjdWxhdGVUaWNrUm90YXRpb24iLCJhZnRlckNhbGN1bGF0ZVRpY2tSb3RhdGlvbiIsImJlZm9yZUZpdCIsImZpdCIsImFmdGVyRml0IiwiYWZ0ZXJVcGRhdGUiLCJ0aWNrT3B0cyIsInVzZXJDYWxsYmFjayIsInRpY2tGb250IiwibGFiZWxSb3RhdGlvbiIsIm9yaWdpbmFsTGFiZWxXaWR0aCIsImxhYmVsV2lkdGgiLCJjb3NSb3RhdGlvbiIsInNpblJvdGF0aW9uIiwidGlja1dpZHRoIiwiYW5nbGVSYWRpYW5zIiwic2NhbGVMYWJlbE9wdHMiLCJncmlkTGluZU9wdHMiLCJfaXNWaXNpYmxlIiwicGFyc2VGb250IiwiaXNGdWxsV2lkdGgiLCJzY2FsZUxhYmVsRm9udCIsInNjYWxlTGFiZWxQYWRkaW5nIiwiZGVsdGFIZWlnaHQiLCJsYXJnZXN0VGV4dFdpZHRoIiwidGFsbGVzdExhYmVsSGVpZ2h0SW5MaW5lcyIsImxpbmVTcGFjZSIsInRpY2tQYWRkaW5nIiwibGFiZWxIZWlnaHQiLCJmaXJzdExhYmVsV2lkdGgiLCJsYXN0TGFiZWxXaWR0aCIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsImhhbmRsZU1hcmdpbnMiLCJyYXdWYWx1ZSIsImdldFZhbHVlRm9yUGl4ZWwiLCJpbm5lcldpZHRoIiwiZmluYWxWYWwiLCJpbm5lckhlaWdodCIsImRlY2ltYWwiLCJ2YWx1ZU9mZnNldCIsImdldEJhc2VWYWx1ZSIsIl9hdXRvU2tpcCIsIm9wdGlvblRpY2tzIiwidGlja0NvdW50Iiwic2tpcFJhdGlvIiwibWF4VGlja3MiLCJtYXhUaWNrc0xpbWl0IiwidGlja3NMZW5ndGgiLCJfdGlja1NpemUiLCJheGlzTGVuZ3RoIiwiUGFkZGluZ0JvdHRvbSIsInJvdCIsIm9wdGlvbk1ham9yVGlja3MiLCJpc1JvdGF0ZWQiLCJpc01pcnJvcmVkIiwidGlja0ZvbnRDb2xvciIsImZvbnRDb2xvciIsIm1ham9yVGlja0ZvbnRDb2xvciIsIm1ham9yVGlja0ZvbnQiLCJ0bCIsInNjYWxlTGFiZWxGb250Q29sb3IiLCJsYWJlbFJvdGF0aW9uUmFkaWFucyIsIml0ZW1zVG9EcmF3IiwiYXhpc1dpZHRoIiwiYWxpZ25QaXhlbCIsImJvcmRlclZhbHVlIiwidGlja1N0YXJ0IiwidGlja0VuZCIsImxpbmVDb2xvciIsInplcm9MaW5lSW5kZXgiLCJ0eDEiLCJ0eTEiLCJ0eDIiLCJ0eTIiLCJsYWJlbFgiLCJsYWJlbFkiLCJ0ZXh0T2Zmc2V0IiwibGFiZWxZT2Zmc2V0IiwibGFiZWxYT2Zmc2V0IiwiZ2xXaWR0aCIsImdsQ29sb3IiLCJnbEJvcmRlckRhc2giLCJnbEJvcmRlckRhc2hPZmZzZXQiLCJpdGVtVG9EcmF3IiwidHJhbnNsYXRlIiwic2NhbGVMYWJlbFgiLCJzY2FsZUxhYmVsWSIsImhhbGZMaW5lSGVpZ2h0IiwiaXNMZWZ0IiwiZmlyc3RMaW5lV2lkdGgiLCJsYXN0TGluZVdpZHRoIiwiZGVmYXVsdENvbmZpZyIsInNjYWxlX2NhdGVnb3J5IiwiZ2V0TGFiZWxzIiwibWluSW5kZXgiLCJtYXhJbmRleCIsIm9mZnNldEFtdCIsInZhbHVlQ2F0ZWdvcnkiLCJ2YWx1ZVdpZHRoIiwid2lkdGhPZmZzZXQiLCJ2YWx1ZUhlaWdodCIsImhlaWdodE9mZnNldCIsImhvcnoiLCJ2YWx1ZURpbWVuc2lvbiIsIl9kZWZhdWx0cyIsImdlbmVyYXRlVGlja3MiLCJnZW5lcmF0aW9uT3B0aW9ucyIsImRhdGFSYW5nZSIsIk1JTl9TUEFDSU5HIiwic3RlcFNpemUiLCJtYXhOdW1TcGFjZXMiLCJwcmVjaXNpb24iLCJybWluIiwicm1heCIsInNwYWNpbmciLCJmYWN0b3IiLCJuaWNlTWluIiwibmljZU1heCIsIm51bVNwYWNlcyIsInNjYWxlX2xpbmVhcmJhc2UiLCJoYW5kbGVUaWNrUmFuZ2VPcHRpb25zIiwibWluU2lnbiIsIm1heFNpZ24iLCJzZXRNaW4iLCJzdWdnZXN0ZWRNaW4iLCJzZXRNYXgiLCJzdWdnZXN0ZWRNYXgiLCJnZXRUaWNrTGltaXQiLCJfY29tcHV0ZVRpY2tMaW1pdCIsImhhbmRsZURpcmVjdGlvbmFsQ2hhbmdlcyIsIm51bWVyaWNHZW5lcmF0b3JPcHRpb25zIiwiZml4ZWRTdGVwU2l6ZSIsInRpY2tzQXNOdW1iZXJzIiwiZGVmYXVsdENvbmZpZyQxIiwic2NhbGVfbGluZWFyIiwiREVGQVVMVF9NSU4iLCJERUZBVUxUX01BWCIsIklETWF0Y2hlcyIsImhhc1N0YWNrcyIsInZhbHVlc1BlclN0YWNrIiwicG9zaXRpdmVWYWx1ZXMiLCJuZWdhdGl2ZVZhbHVlcyIsInJlbGF0aXZlUG9pbnRzIiwidmFsdWVzRm9yVHlwZSIsIm1pblZhbCIsIm1heFZhbCIsImlubmVyRGltZW5zaW9uIiwiX2RlZmF1bHRzJDEiLCJ2YWx1ZU9yRGVmYXVsdCRhIiwiZ2VuZXJhdGVUaWNrcyQxIiwidGlja1ZhbCIsImVuZEV4cCIsImVuZFNpZ25pZmljYW5kIiwic2lnbmlmaWNhbmQiLCJtaW5Ob3RaZXJvIiwibGFzdFRpY2siLCJkZWZhdWx0Q29uZmlnJDIiLCJub25OZWdhdGl2ZU9yRGVmYXVsdCIsInNjYWxlX2xvZ2FyaXRobWljIiwidGlja1ZhbHVlcyIsIl9nZXRGaXJzdFRpY2tWYWx1ZSIsImZpcnN0VGlja1ZhbHVlIiwiX2RlZmF1bHRzJDIiLCJ2YWx1ZU9yRGVmYXVsdCRiIiwidmFsdWVBdEluZGV4T3JEZWZhdWx0JDEiLCJyZXNvbHZlJDciLCJkZWZhdWx0Q29uZmlnJDMiLCJhbmltYXRlIiwic2hvd0xhYmVsQmFja2Ryb3AiLCJiYWNrZHJvcENvbG9yIiwiYmFja2Ryb3BQYWRkaW5nWSIsImJhY2tkcm9wUGFkZGluZ1giLCJnZXRWYWx1ZUNvdW50IiwiZ2V0VGlja0JhY2tkcm9wSGVpZ2h0IiwibWVhc3VyZUxhYmVsU2l6ZSIsImRldGVybWluZUxpbWl0cyIsImZpdFdpdGhQb2ludExhYmVscyIsInBsRm9udCIsImZ1cnRoZXN0TGltaXRzIiwiZnVydGhlc3RBbmdsZXMiLCJ0ZXh0U2l6ZSIsIl9wb2ludExhYmVsU2l6ZXMiLCJ2YWx1ZUNvdW50IiwiZ2V0UG9pbnRQb3NpdGlvbiIsImRyYXdpbmdBcmVhIiwiZ2V0SW5kZXhBbmdsZSIsImhMaW1pdHMiLCJ2TGltaXRzIiwic2V0UmVkdWN0aW9ucyIsImdldFRleHRBbGlnbkZvckFuZ2xlIiwiYWRqdXN0UG9pbnRQb3NpdGlvbkZvckxhYmVsSGVpZ2h0IiwiZHJhd1BvaW50TGFiZWxzIiwiYW5nbGVMaW5lT3B0cyIsInBvaW50TGFiZWxPcHRzIiwidGlja0JhY2tkcm9wSGVpZ2h0Iiwib3V0ZXJEaXN0YW5jZSIsIm91dGVyUG9zaXRpb24iLCJleHRyYSIsInBvaW50TGFiZWxQb3NpdGlvbiIsInBvaW50TGFiZWxGb250Q29sb3IiLCJkcmF3UmFkaXVzTGluZSIsIm51bWJlck9yWmVybyIsInNjYWxlX3JhZGlhbExpbmVhciIsInNldENlbnRlclBvaW50IiwibGFyZ2VzdFBvc3NpYmxlUmFkaXVzIiwicmFkaXVzUmVkdWN0aW9uTGVmdCIsInJhZGl1c1JlZHVjdGlvblJpZ2h0IiwicmFkaXVzUmVkdWN0aW9uVG9wIiwicmFkaXVzUmVkdWN0aW9uQm90dG9tIiwibGVmdE1vdmVtZW50IiwicmlnaHRNb3ZlbWVudCIsInRvcE1vdmVtZW50IiwiYm90dG9tTW92ZW1lbnQiLCJtYXhSaWdodCIsIm1heExlZnQiLCJtYXhUb3AiLCJtYXhCb3R0b20iLCJhbmdsZU11bHRpcGxpZXIiLCJzdGFydEFuZ2xlUmFkaWFucyIsInNjYWxpbmdGYWN0b3IiLCJkaXN0YW5jZUZyb21DZW50ZXIiLCJ0aGlzQW5nbGUiLCJnZXRCYXNlUG9zaXRpb24iLCJ5Q2VudGVyT2Zmc2V0IiwiX2RlZmF1bHRzJDMiLCJ2YWx1ZU9yRGVmYXVsdCRjIiwiTUlOX0lOVEVHRVIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiTUFYX0lOVEVHRVIiLCJJTlRFUlZBTFMiLCJjb21tb24iLCJzdGVwcyIsIlVOSVRTIiwic29ydGVyIiwiYXJyYXlVbmlxdWUiLCJidWlsZExvb2t1cFRhYmxlIiwidGltZXN0YW1wcyIsImRpc3RyaWJ1dGlvbiIsInRhYmxlIiwibG9va3VwIiwibG8iLCJtaWQiLCJpMCIsImkxIiwiaW50ZXJwb2xhdGUkMSIsInNrZXkiLCJ0a2V5Iiwic3BhbiIsInRvVGltZXN0YW1wIiwiYWRhcHRlciIsIl9hZGFwdGVyIiwicGFyc2VyIiwiZGV0ZXJtaW5lU3RlcFNpemUiLCJjYXBhY2l0eSIsImludGVydmFsIiwiZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyIsIm1pblVuaXQiLCJkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyIsImRldGVybWluZU1ham9yVW5pdCIsInRpbWVPcHRzIiwidW5pdFN0ZXBTaXplIiwibWFqb3JUaWNrc0VuYWJsZWQiLCJmaXJzdCIsImNvbXB1dGVPZmZzZXRzIiwidGlja3NGcm9tVGltZXN0YW1wcyIsIm1ham9yVW5pdCIsImRlZmF1bHRDb25maWckNCIsImFkYXB0ZXJzIiwiZGlzcGxheUZvcm1hdCIsImRpc3BsYXlGb3JtYXRzIiwic2NhbGVfdGltZSIsInRpbWVzdGFtcCIsImRhdGFMYWJlbHMiLCJfaG9yaXpvbnRhbCIsIl90YWJsZSIsIl90aW1lc3RhbXBzIiwiZ2V0TGFiZWxDYXBhY2l0eSIsIl91bml0IiwiX21ham9yVW5pdCIsIl9vZmZzZXRzIiwidG9vbHRpcEZvcm1hdCIsInRpY2tGb3JtYXRGdW5jdGlvbiIsIm1pbm9yRm9ybWF0IiwibWFqb3JGb3JtYXQiLCJtYWpvclRpbWUiLCJtYWpvclRpY2tPcHRzIiwiZm9ybWF0dGVyIiwiZ2V0UGl4ZWxGb3JPZmZzZXQiLCJpc1JldmVyc2UiLCJnZXRMYWJlbFdpZHRoIiwidGlja3NPcHRzIiwidGlja0xhYmVsV2lkdGgiLCJ0aWNrRm9udFNpemUiLCJleGFtcGxlVGltZSIsImV4YW1wbGVMYWJlbCIsIl9kZWZhdWx0cyQ0IiwiY2F0ZWdvcnkiLCJyYWRpYWxMaW5lYXIiLCJGT1JNQVRTIiwiX2lkIiwiYW1vdW50IiwiZmlsbGVyIiwicHJvcGFnYXRlIiwibWFwcGVycyIsInZpc2libGUiLCJib3VuZGFyeSIsImRlY29kZUZpbGwiLCJjb21wdXRlQm91bmRhcnkiLCJzY2FsZUJvdHRvbSIsInNjYWxlVG9wIiwic2NhbGVaZXJvIiwicmVzb2x2ZVRhcmdldCIsInZpc2l0ZWQiLCJjcmVhdGVNYXBwZXIiLCJpc0RyYXdhYmxlIiwiZHJhd0FyZWEiLCJjdXJ2ZTAiLCJjdXJ2ZTEiLCJsZW4wIiwibGVuMSIsImRvRmlsbCIsIm1hcHBlciIsInAwIiwiZDAiLCJkMSIsInBsdWdpbl9maWxsZXIiLCJhZnRlckRhdGFzZXRzVXBkYXRlIiwiJGZpbGxlciIsImJlZm9yZURhdGFzZXREcmF3Iiwibm9vcCQxIiwidmFsdWVPckRlZmF1bHQkZCIsImNpIiwib25MZWF2ZSIsImJveFdpZHRoIiwibGluZURhc2giLCJnZXRCb3hXaWR0aCIsImxhYmVsT3B0cyIsInVzZVBvaW50U3R5bGUiLCJMZWdlbmQiLCJsZWdlbmRIaXRCb3hlcyIsIl9ob3ZlcmVkSXRlbSIsImRvdWdobnV0TW9kZSIsImJlZm9yZUJ1aWxkTGFiZWxzIiwiYnVpbGRMYWJlbHMiLCJhZnRlckJ1aWxkTGFiZWxzIiwibGVnZW5kSXRlbXMiLCJsYWJlbEZvbnQiLCJoaXRib3hlcyIsImxpbmVXaWR0aHMiLCJ0b3RhbEhlaWdodCIsInZQYWRkaW5nIiwiY29sdW1uV2lkdGhzIiwidG90YWxXaWR0aCIsImN1cnJlbnRDb2xXaWR0aCIsImN1cnJlbnRDb2xIZWlnaHQiLCJpdGVtSGVpZ2h0IiwiaXRlbVdpZHRoIiwibGluZURlZmF1bHQiLCJsZWdlbmRXaWR0aCIsImN1cnNvciIsImRyYXdMZWdlbmRCb3giLCJTUVJUMiIsImhhbGZGb250U2l6ZSIsInhMZWZ0IiwieU1pZGRsZSIsIl9nZXRMZWdlbmRJdGVtQXQiLCJoaXRCb3giLCJsaCIsImhvdmVyZWRJdGVtIiwiY3JlYXRlTmV3TGVnZW5kQW5kQXR0YWNoIiwibGVnZW5kT3B0cyIsInBsdWdpbl9sZWdlbmQiLCJfZWxlbWVudCIsImJlZm9yZUluaXQiLCJhZnRlckV2ZW50Iiwibm9vcCQyIiwiVGl0bGUiLCJsaW5lQ291bnQiLCJmb250T3B0cyIsInRpdGxlWCIsInRpdGxlWSIsImNyZWF0ZU5ld1RpdGxlQmxvY2tBbmRBdHRhY2giLCJ0aXRsZU9wdHMiLCJ0aXRsZUJsb2NrIiwicGx1Z2luX3RpdGxlIiwiX2FkYXB0ZXJzIiwiQW5pbWF0aW9uIiwiYW5pbWF0aW9uU2VydmljZSIsIkludGVyYWN0aW9uIiwibGF5b3V0cyIsIlNjYWxlIiwic2NhbGVTZXJ2aWNlIiwiVGlja3MiLCJUb29sdGlwIiwicGx1Z2luU2VydmljZSIsIlBsdWdpbkJhc2UiLCJjYW52YXNIZWxwZXJzIiwibGF5b3V0U2VydmljZSIsIkxpbmVhclNjYWxlQmFzZSIsImNmZyIsImdlbmVyYXRlQ2hhcnQiLCJjaGFydElkIiwiY2hhcnRUeXBlIiwiY3NzQ2xhc3NlcyIsIl9kZWZhdWx0IiwiYWRkUGx1Z2luIiwiYmVmb3JlRGVzdHJveSIsIkJhciIsIkhvcml6b250YWxCYXIiLCJQaWUiLCJjaGFydExhYmVscyIsImNoYXJ0RGF0YUxpc3QiLCJDaGFydERhdGEiLCJDaGFydEJhciIsIkNoYXJ0Q29tcG9uZW50IiwiQ2hhcnRIb3Jpem9udGFsQmFyIiwiQ2hhcnRMaW5lIiwiQ2hhcnRQaWUiLCJueWNvQ29sb3JzIiwiY29sb3JzIiwiY29sb3JDb21iaW5hdGlvbnMiLCJtYXBDb2xvckNvbWJpbmF0aW9ucyIsIk1hcERhdGEiLCJsYXllcnMiLCJBUElLZXkiLCJjb250YWluZXJJZCIsImxlZ2VuZElkIiwiem9vbSIsImRpc2FibGVTY3JvbGwiLCJtYXBUeXBlIiwibXVsdGkiLCJHZW9KU09OIiwiZG9UaHJvd3MiLCJpbnZhbGlkR2VvbWV0cnkiLCJJbnZhbGlkR2VvbWV0cnlFcnJvciIsImlzR2VvbWV0cnlWYWxpZCIsImdlb21ldHJ5IiwiY29vcmRpbmF0ZXMiLCJvYmplY3RzIiwiZ2VvanNvbiIsImFwcGx5RGVmYXVsdHMiLCJwcm9wRnVuYyIsImdlb21BdHRycyIsInNldEdlb20iLCJnZXRQcm9wRnVuY3Rpb24iLCJmZWF0dXJlcyIsImdldEZlYXR1cmUiLCJhZGRPcHRpb25hbHMiLCJnZW9tcyIsInNldHRpbmciLCJjcnMiLCJjaGVja0NSUyIsImlzUG9zdGdyZXMiLCJiYm94IiwiZXh0cmFHbG9iYWwiLCJwcm9wZXJ0aWVzIiwiZ2VvbSIsInNldEdlb21BdHRyTGlzdCIsImZlYXR1cmUiLCJidWlsZEdlb20iLCJpc05lc3RlZCIsImd0eXBlIiwibmV3SXRlbSIsInBhdGhzIiwiaXRlbUNsb25lIiwiYWRkRXh0cmEiLCJyaW5nQXJlYSIsInBvbHlnb25BcmVhIiwiZ2VvbWV0cmllcyIsImNvb3JkcyIsImxvd2VySW5kZXgiLCJtaWRkbGVJbmRleCIsInVwcGVySW5kZXgiLCJjb29yZHNMZW5ndGgiLCJ3Z3M4NCIsIlJBRElVUyIsInJld2luZCIsImdqIiwiY3VycnlPdXRlciIsImNvcnJlY3QiLCJjb3JyZWN0UmluZ3MiLCJ3aW5kIiwiZ2VvanNvbkFyZWEiLCJyaW5nIiwiTWFwTXVsdGlMYXllciIsIk1hcENvbXBvbmVudCIsImdldFppcGNvZGVEYXRhIiwiZ2V0Qm9yb3VnaERhdGEiLCJnZXROZWlnaGJvcmhvb2REYXRhIiwiZmlsdGVyQnkiLCJjb252ZXJ0VG9HZW9KU09OIiwianNvbkRhdGEiLCJNYXBTaW5nbGVMYXllciIsImxlZ2VuZENvbHVtbiIsImphcm8iLCJzMSIsInMyIiwic2hvcnRlciIsImxvbmdlciIsIm1hdGNoaW5nV2luZG93Iiwic2hvcnRlck1hdGNoZXMiLCJsb25nZXJNYXRjaGVzIiwid2luZG93U3RhcnQiLCJ3aW5kb3dFbmQiLCJzaG9ydGVyTWF0Y2hlc1N0cmluZyIsImxvbmdlck1hdGNoZXNTdHJpbmciLCJudW1NYXRjaGVzIiwidHJhbnNwb3NpdGlvbnMiLCJwcmVmaXhTY2FsaW5nRmFjdG9yIiwiamFyb1NpbWlsYXJpdHkiLCJjb21tb25QcmVmaXhMZW5ndGgiLCJBdXRvY29tcGxldGUiLCJjbGFzc25hbWUiLCJsaXN0SXRlbSIsImdldFNpYmxpbmdJbmRleCIsInNjb3JlZE9wdGlvbnMiLCJ1bCIsImhpZ2hsaWdodGVkIiwic2VsZWN0b3JzIiwiU1RSSU5HUyIsIk1BWF9JVEVNUyIsIm1heEl0ZW1zIiwia2V5ZG93bkV2ZW50Iiwia2V5dXBFdmVudCIsImlucHV0RXZlbnQiLCJmb2N1c0V2ZW50IiwiYmx1ckV2ZW50Iiwia2V5RW50ZXIiLCJrZXlFc2NhcGUiLCJrZXlEb3duIiwia2V5VXAiLCJkcm9wZG93biIsInBlcnNpc3REcm9wZG93biIsImhpZ2hsaWdodCIsInN5bm9ueW1zIiwiY2xvc2VzdFN5bm9ueW0iLCJzeW5vbnltIiwic2ltaWxhcml0eSIsImphcm9XaW5rbGVyIiwiZGlzcGxheVZhbHVlIiwic2NvcmVkT3B0aW9uIiwibm9ybWFsaXplZEluZGV4IiwibGkiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiZG9jdW1lbnRGcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJuZXdVbCIsIk9QVElPTlMiLCJuZXdDb250YWluZXIiLCJuZXdJbmRleCIsIkhJR0hMSUdIVCIsIkFDVElWRV9ERVNDRU5EQU5UIiwic2Nyb2xsSW50b1ZpZXciLCJtZXNzYWdlcyIsIkRJUkVDVElPTlNfVFlQRSIsIk9QVElPTl9BVkFJTEFCTEUiLCJESVJFQ1RJT05TX1JFVklFVyIsIk9QVElPTl9TRUxFQ1RFRCIsIklucHV0QXV0b2NvbXBsZXRlIiwibGlicmFyeSIsImxvY2FsaXplZFN0cmluZ3MiLCJueWNvIiwiaWNvbnMiLCJ0cmFjayIsInNlbGVjdCIsImlucHV0QXV0b2NvbXBsZXRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBTUEsSUFBTUEsU0FBTyxHQUtYLGdCQUFBLEdBQWM7U0FDTCxJQUFUO0NB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QkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0JNO01BNEJoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUJJO01BNkJoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBN0JFO01BOEJoQkMsY0FBYyxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBOUJBO01BK0JoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBL0JJO01BZ0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBaENJO01BaUNoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLENBakNNO01Ba0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbENJO01BbUNoQkMsWUFBWSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkNFO01Bb0NoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxHQUFQLENBcENBO01BcUNoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLENBckNBO01Bc0NoQkMsYUFBYSxFQUFHLENBQUMsRUFBRCxFQUFJLEVBQUosRUFBTyxFQUFQLENBdENBO01BdUNoQkMsYUFBYSxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBdkNBO01Bd0NoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBeENJO01BeUNoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBekNNO01BMENoQkMsV0FBVyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBMUNFO01BMkNoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0NNO01BNENoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUNNO01BNkNoQkMsVUFBVSxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBN0NJO01BOENoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBOUNJO01BK0NoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0NFO01BZ0RoQkMsV0FBVyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBaERFO01BaURoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBakRNO01Ba0RoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbERJO01BbURoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbkRJO01Bb0RoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxDQUFULENBcERVO01BcURoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBckRJO01Bc0RoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdERVO01BdURoQkMsS0FBSyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxDQUFQLENBdkRRO01Bd0RoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBeERFO01BeURoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBekRVO01BMERoQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBMURNO01BMkRoQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBM0RNO01BNERoQkMsU0FBUyxFQUFHLENBQUMs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LENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBOUdJO01BK0doQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBL0dBO01BZ0hoQkMsYUFBYSxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaEhBO01BaUhoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBakhJO01Ba0hoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbEhJO01BbUhoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBbkhVO01Bb0hoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcEhVO01BcUhoQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBckhVO01Bc0hoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdEhJO01BdUhoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxHQUFQLENBdkhRO01Bd0hoQkMsYUFBYSxFQUFFLENBQUMsR0FBRCxFQUFNLEVBQU4sRUFBVSxHQUFWLENBeEhDO01BeUhoQkMsR0FBRyxFQUFHLENBQUMsR0FBRCxFQUFLLENBQUwsRUFBTyxDQUFQLENBekhVO01BMEhoQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBMUhJO01BMkhoQkMsU0FBUyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBM0hJO01BNEhoQkMsV0FBVyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBNUhFO01BNkhoQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBN0hRO01BOEhoQkMsVUFBVSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxFQUFULENBOUhJO01BK0hoQkMsUUFBUSxFQUFFLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxFQUFSLENBL0hNO01BZ0loQkMsUUFBUSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBaElNO01BaUloQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBaklRO01Ba0loQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbElRO01BbUloQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBbklNO01Bb0loQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxHQUFSLENBcElJO01BcUloQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBcklJO01Bc0loQkMsU0FBUyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdElJO01BdUloQkMsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBdklVO01Bd0loQkMsV0FBVyxFQUFHLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBeElFO01BeUloQkMsU0FBUyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBeklJO01BMEloQkMsR0FBRyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBMUlVO01BMkloQkMsSUFBSSxFQUFFLENBQUMsQ0FBRCxFQUFHLEdBQUgsRUFBTyxHQUFQLENBM0lVO01BNEloQkMsT0FBTyxFQUFHLENBQUMsR0FBRCxFQUFLLEdBQUwsRUFBUyxHQUFULENBNUlNO01BNkloQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEVBQUwsRUFBUSxFQUFSLENBN0lRO01BOEloQkMsU0FBUyxFQUFHLENBQUMsRUFBRCxFQUFJLEdBQUosRUFBUSxHQUFSLENBOUlJO01BK0loQkMsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFLLEdB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
